{"buggy_code": ["\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\" this was causing an ml_get error\nfunc Test_visual_exchange_windows()\n  enew!\n  new\n  call setline(1, ['foo', 'bar'])\n  exe \"normal G\\<C-V>gg\\<C-W>\\<C-X>OO\\<Esc>\"\n  bwipe!\n  bwipe!\nendfunc\n\n\" this was leaving the end of the Visual area beyond the end of a line\nfunc Test_visual_ex_copy_line()\n  new\n  call setline(1, [\"aaa\", \"bbbbbbbbbxbb\"])\n  /x\n  exe \"normal ggvjfxO\"\n  t0\n  normal gNU\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * undo.c: multi level undo facility\n *\n * The saved lines are stored in a list of lists (one for each buffer):\n *\n * b_u_oldhead------------------------------------------------+\n *\t\t\t\t\t\t\t      |\n *\t\t\t\t\t\t\t      V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n * b_u_newhead--->| u_header\t |    | u_header     |\t  | u_header\t |\n *\t\t  |\tuh_next------>|     uh_next------>|\tuh_next---->NULL\n *\t   NULL<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |\n *\t\t  |\tuh_entry |    |     uh_entry |\t  |\tuh_entry |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n *\t\t  | u_entry\t |    | u_entry      |\t  | u_entry\t |\n *\t\t  |\tue_next  |    |     ue_next  |\t  |\tue_next  |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+\t      NULL\t\t  NULL\n *\t\t  | u_entry\t |\n *\t\t  |\tue_next  |\n *\t\t  +--------|-----+\n *\t\t\t   |\n *\t\t\t   V\n *\t\t\t  etc.\n *\n * Each u_entry list contains the information for one undo or redo.\n * curbuf->b_u_curhead points to the header of the last undo (the next redo),\n * or is NULL if nothing has been undone (end of the branch).\n *\n * For keeping alternate undo/redo branches the uh_alt field is used.  Thus at\n * each point in the list a branch may appear for an alternate to redo.  The\n * uh_seq field is numbered sequentially to be able to find a newer or older\n * branch.\n *\n *\t\t   +---------------+\t+---------------+\n * b_u_oldhead --->| u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next ---->|   uh_alt_next ----> NULL\n *\t   NULL <----- uh_alt_prev |<------ uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t   +---------------+\t+---------------+\n *\t\t   | u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next |\t|   uh_alt_next |\n * b_u_newhead --->|   uh_alt_prev |\t|   uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t       NULL\t\t+---------------+    +---------------+\n *\t\t\t\t\t| u_header\t|    | u_header      |\n *\t\t\t\t\t|   uh_alt_next ---->|\t uh_alt_next |\n *\t\t\t\t\t|   uh_alt_prev |<------ uh_alt_prev |\n *\t\t\t\t\t|   uh_prev\t|    |\t uh_prev     |\n *\t\t\t\t\t+-----|---------+    +-----|---------+\n *\t\t\t\t\t      |\t\t\t   |\n *\t\t\t\t\t     etc.\t\t  etc.\n *\n *\n * All data is allocated and will all be freed when the buffer is unloaded.\n */\n\n// Uncomment the next line for including the u_check() function.  This warns\n// for errors in the debug information.\n// #define U_DEBUG 1\n#define UH_MAGIC 0x18dade\t// value for uh_magic when in use\n#define UE_MAGIC 0xabc123\t// value for ue_magic when in use\n\n// Size of buffer used for encryption.\n#define CRYPT_BUF_SIZE 8192\n\n#include \"vim.h\"\n\n// Structure passed around between functions.\n// Avoids passing cryptstate_T when encryption not available.\ntypedef struct {\n    buf_T\t*bi_buf;\n    FILE\t*bi_fp;\n#ifdef FEAT_CRYPT\n    cryptstate_T *bi_state;\n    char_u\t*bi_buffer; // CRYPT_BUF_SIZE, NULL when not buffering\n    size_t\tbi_used;    // bytes written to/read from bi_buffer\n    size_t\tbi_avail;   // bytes available in bi_buffer\n#endif\n} bufinfo_T;\n\n\nstatic void u_unch_branch(u_header_T *uhp);\nstatic u_entry_T *u_get_headentry(void);\nstatic void u_getbot(void);\nstatic void u_doit(int count);\nstatic void u_undoredo(int undo);\nstatic void u_undo_end(int did_undo, int absolute);\nstatic void u_freeheader(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freebranch(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentries(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentry(u_entry_T *, long);\n#ifdef FEAT_PERSISTENT_UNDO\n# ifdef FEAT_CRYPT\nstatic int undo_flush(bufinfo_T *bi);\n# endif\nstatic int undo_read(bufinfo_T *bi, char_u *buffer, size_t size);\nstatic int serialize_uep(bufinfo_T *bi, u_entry_T *uep);\nstatic u_entry_T *unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name);\nstatic void serialize_pos(bufinfo_T *bi, pos_T pos);\nstatic void unserialize_pos(bufinfo_T *bi, pos_T *pos);\nstatic void serialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\nstatic void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\n#endif\nstatic void u_saveline(linenr_T lnum);\n\n#define U_ALLOC_LINE(size) lalloc(size, FALSE)\n\n// used in undo_end() to report number of added and deleted lines\nstatic long\tu_newcount, u_oldcount;\n\n/*\n * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember\n * the action that \"u\" should do.\n */\nstatic int\tundo_undoes = FALSE;\n\nstatic int\tlastmark = 0;\n\n#if defined(U_DEBUG) || defined(PROTO)\n/*\n * Check the undo structures for being valid.  Print a warning when something\n * looks wrong.\n */\nstatic int seen_b_u_curhead;\nstatic int seen_b_u_newhead;\nstatic int header_count;\n\n    static void\nu_check_tree(u_header_T *uhp,\n\tu_header_T *exp_uh_next,\n\tu_header_T *exp_uh_alt_prev)\n{\n    u_entry_T *uep;\n\n    if (uhp == NULL)\n\treturn;\n    ++header_count;\n    if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)\n    {\n\temsg(\"b_u_curhead found twice (looping?)\");\n\treturn;\n    }\n    if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)\n    {\n\temsg(\"b_u_newhead found twice (looping?)\");\n\treturn;\n    }\n\n    if (uhp->uh_magic != UH_MAGIC)\n\temsg(\"uh_magic wrong (may be using freed memory)\");\n    else\n    {\n\t// Check pointers back are correct.\n\tif (uhp->uh_next.ptr != exp_uh_next)\n\t{\n\t    emsg(\"uh_next wrong\");\n\t    smsg(\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t\t       exp_uh_next, uhp->uh_next.ptr);\n\t}\n\tif (uhp->uh_alt_prev.ptr != exp_uh_alt_prev)\n\t{\n\t    emsg(\"uh_alt_prev wrong\");\n\t    smsg(\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t       exp_uh_alt_prev, uhp->uh_alt_prev.ptr);\n\t}\n\n\t// Check the undo tree at this header.\n\tfor (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n\t{\n\t    if (uep->ue_magic != UE_MAGIC)\n\t    {\n\t\temsg(\"ue_magic wrong (may be using freed memory)\");\n\t\tbreak;\n\t    }\n\t}\n\n\t// Check the next alt tree.\n\tu_check_tree(uhp->uh_alt_next.ptr, uhp->uh_next.ptr, uhp);\n\n\t// Check the next header in this branch.\n\tu_check_tree(uhp->uh_prev.ptr, uhp, NULL);\n    }\n}\n\n    static void\nu_check(int newhead_may_be_NULL)\n{\n    seen_b_u_newhead = 0;\n    seen_b_u_curhead = 0;\n    header_count = 0;\n\n    u_check_tree(curbuf->b_u_oldhead, NULL, NULL);\n\n    if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL\n\t    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))\n\tsemsg(\"b_u_newhead invalid: 0x%x\", curbuf->b_u_newhead);\n    if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)\n\tsemsg(\"b_u_curhead invalid: 0x%x\", curbuf->b_u_curhead);\n    if (header_count != curbuf->b_u_numhead)\n    {\n\temsg(\"b_u_numhead invalid\");\n\tsmsg(\"expected: %ld, actual: %ld\",\n\t\t\t       (long)header_count, (long)curbuf->b_u_numhead);\n    }\n}\n#endif\n\n/*\n * Save the current line for both the \"u\" and \"U\" command.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns OK or FAIL.\n */\n    int\nu_save_cursor(void)\n{\n    return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t\t      (linenr_T)(curwin->w_cursor.lnum + 1)));\n}\n\n/*\n * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command.\n * \"top\" may be 0 and \"bot\" may be curbuf->b_ml.ml_line_count + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_save(linenr_T top, linenr_T bot)\n{\n    if (undo_off)\n\treturn OK;\n\n    if (top >= bot || bot > curbuf->b_ml.ml_line_count + 1)\n\treturn FAIL;\t// rely on caller to give an error message\n\n    if (top + 2 == bot)\n\tu_saveline((linenr_T)(top + 1));\n\n    return (u_savecommon(top, bot, (linenr_T)0, FALSE));\n}\n\n/*\n * Save the line \"lnum\" (used by \":s\" and \"~\" command).\n * The line is replaced, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savesub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + 1, lnum + 1, FALSE));\n}\n\n/*\n * A new line is inserted before line \"lnum\" (used by :s command).\n * The line is inserted, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_inssub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum, lnum + 1, FALSE));\n}\n\n/*\n * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command).\n * The lines are deleted, so the new bottom line is lnum, unless the buffer\n * becomes empty.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savedel(linenr_T lnum, long nlines)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + nlines,\n\t\t     nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE));\n}\n\n/*\n * Return TRUE when undo is allowed.  Otherwise give an error message and\n * return FALSE.\n */\n    int\nundo_allowed(void)\n{\n    // Don't allow changes when 'modifiable' is off.\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FALSE;\n    }\n\n#ifdef HAVE_SANDBOX\n    // In the sandbox it's not allowed to change the text.\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn FALSE;\n    }\n#endif\n\n    // Don't allow changes in the buffer while editing the cmdline.  The\n    // caller of getcmdline() may get confused.\n    if (textwinlock != 0 || textlock != 0)\n    {\n\temsg(_(e_not_allowed_to_change_text_here));\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Get the undolevel value for the current buffer.\n */\n    static long\nget_undolevel(void)\n{\n    if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)\n\treturn p_ul;\n    return curbuf->b_p_ul;\n}\n\n/*\n * u_save_line(): save an allocated copy of line \"lnum\" into \"ul\".\n * Returns FAIL when out of memory.\n */\n    static int\nu_save_line(undoline_T *ul, linenr_T lnum)\n{\n    char_u *line = ml_get(lnum);\n\n    if (curbuf->b_ml.ml_line_len == 0)\n    {\n\tul->ul_len = 1;\n\tul->ul_line = vim_strsave((char_u *)\"\");\n    }\n    else\n    {\n\t// This uses the length in the memline, thus text properties are\n\t// included.\n\tul->ul_len = curbuf->b_ml.ml_line_len;\n\tul->ul_line = vim_memsave(line, ul->ul_len);\n    }\n    return ul->ul_line == NULL ? FAIL : OK;\n}\n\n#ifdef FEAT_PROP_POPUP\n/*\n * return TRUE if line \"lnum\" has text property \"flags\".\n */\n    static int\nhas_prop_w_flags(linenr_T lnum, int flags)\n{\n    char_u  *props;\n    int\t    i;\n    int\t    proplen = get_text_props(curbuf, lnum, &props, FALSE);\n\n    for (i = 0; i < proplen; ++i)\n    {\n\ttextprop_T prop;\n\n\tmch_memmove(&prop, props + i * sizeof prop, sizeof prop);\n\tif (prop.tp_flags & flags)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Common code for various ways to save text before a change.\n * \"top\" is the line above the first changed line.\n * \"bot\" is the line below the last changed line.\n * \"newbot\" is the new bottom line.  Use zero when not known.\n * \"reload\" is TRUE when saving for a buffer reload.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savecommon(\n    linenr_T\ttop,\n    linenr_T\tbot,\n    linenr_T\tnewbot,\n    int\t\treload)\n{\n    linenr_T\tlnum;\n    long\ti;\n    u_header_T\t*uhp;\n    u_header_T\t*old_curhead;\n    u_entry_T\t*uep;\n    u_entry_T\t*prev_uep;\n    long\tsize;\n\n    if (!reload)\n    {\n\t// When making changes is not allowed return FAIL.  It's a crude way\n\t// to make all change commands fail.\n\tif (!undo_allowed())\n\t    return FAIL;\n\n#ifdef FEAT_NETBEANS_INTG\n\t/*\n\t * Netbeans defines areas that cannot be modified.  Bail out here when\n\t * trying to change text in a guarded area.\n\t */\n\tif (netbeans_active())\n\t{\n\t    if (netbeans_is_guarded(top, bot))\n\t    {\n\t\temsg(_(e_region_is_guarded_cannot_modify));\n\t\treturn FAIL;\n\t    }\n\t    if (curbuf->b_p_ro)\n\t    {\n\t\temsg(_(e_netbeans_does_not_allow_changes_in_read_only_files));\n\t\treturn FAIL;\n\t    }\n\t}\n#endif\n#ifdef FEAT_TERMINAL\n\t// A change in a terminal buffer removes the highlighting.\n\tterm_change_in_curbuf();\n#endif\n\n\t/*\n\t * Saving text for undo means we are going to make a change.  Give a\n\t * warning for a read-only file before making the change, so that the\n\t * FileChangedRO event can replace the buffer with a read-write version\n\t * (e.g., obtained from a source control system).\n\t */\n\tchange_warning(0);\n\tif (bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n\t    // This happens when the FileChangedRO autocommand changes the\n\t    // file in a way it becomes shorter.\n\t    emsg(_(e_line_count_changed_unexpectedly));\n\t    return FAIL;\n\t}\n    }\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // Include the line above if a text property continues from it.\n    // Include the line below if a text property continues to it.\n    if (bot - top > 1)\n    {\n\tif (top > 0 && has_prop_w_flags(top + 1, TP_FLAG_CONT_PREV))\n\t    --top;\n\tif (bot <= curbuf->b_ml.ml_line_count\n\t\t\t       && has_prop_w_flags(bot - 1, TP_FLAG_CONT_NEXT))\n\t{\n\t    ++bot;\n\t    if (newbot != 0)\n\t\t++newbot;\n\t}\n    }\n#endif\n\n    size = bot - top - 1;\n\n    /*\n     * If curbuf->b_u_synced == TRUE make a new header.\n     */\n    if (curbuf->b_u_synced)\n    {\n\t// Need to create new entry in b_changelist.\n\tcurbuf->b_new_change = TRUE;\n\n\tif (get_undolevel() >= 0)\n\t{\n\t    /*\n\t     * Make a new header entry.  Do this first so that we don't mess\n\t     * up the undo info when out of memory.\n\t     */\n\t    uhp = U_ALLOC_LINE(sizeof(u_header_T));\n\t    if (uhp == NULL)\n\t\tgoto nomem;\n#ifdef U_DEBUG\n\t    uhp->uh_magic = UH_MAGIC;\n#endif\n\t}\n\telse\n\t    uhp = NULL;\n\n\t/*\n\t * If we undid more than we redid, move the entry lists before and\n\t * including curbuf->b_u_curhead to an alternate branch.\n\t */\n\told_curhead = curbuf->b_u_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    curbuf->b_u_newhead = old_curhead->uh_next.ptr;\n\t    curbuf->b_u_curhead = NULL;\n\t}\n\n\t/*\n\t * free headers to keep the size right\n\t */\n\twhile (curbuf->b_u_numhead > get_undolevel()\n\t\t\t\t\t       && curbuf->b_u_oldhead != NULL)\n\t{\n\t    u_header_T\t    *uhfree = curbuf->b_u_oldhead;\n\n\t    if (uhfree == old_curhead)\n\t\t// Can't reconnect the branch, delete all of it.\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    else if (uhfree->uh_alt_next.ptr == NULL)\n\t\t// There is no branch, only free one header.\n\t\tu_freeheader(curbuf, uhfree, &old_curhead);\n\t    else\n\t    {\n\t\t// Free the oldest alternate branch as a whole.\n\t\twhile (uhfree->uh_alt_next.ptr != NULL)\n\t\t    uhfree = uhfree->uh_alt_next.ptr;\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    }\n#ifdef U_DEBUG\n\t    u_check(TRUE);\n#endif\n\t}\n\n\tif (uhp == NULL)\t\t// no undo at all\n\t{\n\t    if (old_curhead != NULL)\n\t\tu_freebranch(curbuf, old_curhead, NULL);\n\t    curbuf->b_u_synced = FALSE;\n\t    return OK;\n\t}\n\n\tuhp->uh_prev.ptr = NULL;\n\tuhp->uh_next.ptr = curbuf->b_u_newhead;\n\tuhp->uh_alt_next.ptr = old_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    uhp->uh_alt_prev.ptr = old_curhead->uh_alt_prev.ptr;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = uhp;\n\t    old_curhead->uh_alt_prev.ptr = uhp;\n\t    if (curbuf->b_u_oldhead == old_curhead)\n\t\tcurbuf->b_u_oldhead = uhp;\n\t}\n\telse\n\t    uhp->uh_alt_prev.ptr = NULL;\n\tif (curbuf->b_u_newhead != NULL)\n\t    curbuf->b_u_newhead->uh_prev.ptr = uhp;\n\n\tuhp->uh_seq = ++curbuf->b_u_seq_last;\n\tcurbuf->b_u_seq_cur = uhp->uh_seq;\n\tuhp->uh_time = vim_time();\n\tuhp->uh_save_nr = 0;\n\tcurbuf->b_u_time_cur = uhp->uh_time + 1;\n\n\tuhp->uh_walk = 0;\n\tuhp->uh_entry = NULL;\n\tuhp->uh_getbot_entry = NULL;\n\tuhp->uh_cursor = curwin->w_cursor;\t// save cursor pos. for undo\n\tif (virtual_active() && curwin->w_cursor.coladd > 0)\n\t    uhp->uh_cursor_vcol = getviscol();\n\telse\n\t    uhp->uh_cursor_vcol = -1;\n\n\t// save changed and buffer empty flag for undo\n\tuhp->uh_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n\n\t// save named marks and Visual marks for undo\n\tmch_memmove(uhp->uh_namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n\tuhp->uh_visual = curbuf->b_visual;\n\n\tcurbuf->b_u_newhead = uhp;\n\tif (curbuf->b_u_oldhead == NULL)\n\t    curbuf->b_u_oldhead = uhp;\n\t++curbuf->b_u_numhead;\n    }\n    else\n    {\n\tif (get_undolevel() < 0)\t// no undo at all\n\t    return OK;\n\n\t/*\n\t * When saving a single line, and it has been saved just before, it\n\t * doesn't make sense saving it again.  Saves a lot of memory when\n\t * making lots of changes inside the same line.\n\t * This is only possible if the previous change didn't increase or\n\t * decrease the number of lines.\n\t * Check the ten last changes.  More doesn't make sense and takes too\n\t * long.\n\t */\n\tif (size == 1)\n\t{\n\t    uep = u_get_headentry();\n\t    prev_uep = NULL;\n\t    for (i = 0; i < 10; ++i)\n\t    {\n\t\tif (uep == NULL)\n\t\t    break;\n\n\t\t// If lines have been inserted/deleted we give up.\n\t\t// Also when the line was included in a multi-line save.\n\t\tif ((curbuf->b_u_newhead->uh_getbot_entry != uep\n\t\t\t    ? (uep->ue_top + uep->ue_size + 1\n\t\t\t\t!= (uep->ue_bot == 0\n\t\t\t\t    ? curbuf->b_ml.ml_line_count + 1\n\t\t\t\t    : uep->ue_bot))\n\t\t\t    : uep->ue_lcount != curbuf->b_ml.ml_line_count)\n\t\t\t|| (uep->ue_size > 1\n\t\t\t    && top >= uep->ue_top\n\t\t\t    && top + 2 <= uep->ue_top + uep->ue_size + 1))\n\t\t    break;\n\n\t\t// If it's the same line we can skip saving it again.\n\t\tif (uep->ue_size == 1 && uep->ue_top == top)\n\t\t{\n\t\t    if (i > 0)\n\t\t    {\n\t\t\t// It's not the last entry: get ue_bot for the last\n\t\t\t// entry now.  Following deleted/inserted lines go to\n\t\t\t// the re-used entry.\n\t\t\tu_getbot();\n\t\t\tcurbuf->b_u_synced = FALSE;\n\n\t\t\t// Move the found entry to become the last entry.  The\n\t\t\t// order of undo/redo doesn't matter for the entries\n\t\t\t// we move it over, since they don't change the line\n\t\t\t// count and don't include this line.  It does matter\n\t\t\t// for the found entry if the line count is changed by\n\t\t\t// the executed command.\n\t\t\tprev_uep->ue_next = uep->ue_next;\n\t\t\tuep->ue_next = curbuf->b_u_newhead->uh_entry;\n\t\t\tcurbuf->b_u_newhead->uh_entry = uep;\n\t\t    }\n\n\t\t    // The executed command may change the line count.\n\t\t    if (newbot != 0)\n\t\t\tuep->ue_bot = newbot;\n\t\t    else if (bot > curbuf->b_ml.ml_line_count)\n\t\t\tuep->ue_bot = 0;\n\t\t    else\n\t\t    {\n\t\t\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\t\t\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n\t\t    }\n\t\t    return OK;\n\t\t}\n\t\tprev_uep = uep;\n\t\tuep = uep->ue_next;\n\t    }\n\t}\n\n\t// find line number for ue_bot for previous u_save()\n\tu_getbot();\n    }\n\n#if !defined(UNIX) && !defined(MSWIN)\n\t/*\n\t * With Amiga we can't handle big undo's, because\n\t * then u_alloc_line would have to allocate a block larger than 32K\n\t */\n    if (size >= 8000)\n\tgoto nomem;\n#endif\n\n    /*\n     * add lines in front of entry list\n     */\n    uep = U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\tgoto nomem;\n    CLEAR_POINTER(uep);\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n\n    uep->ue_size = size;\n    uep->ue_top = top;\n    if (newbot != 0)\n\tuep->ue_bot = newbot;\n    /*\n     * Use 0 for ue_bot if bot is below last line.\n     * Otherwise we have to compute ue_bot later.\n     */\n    else if (bot > curbuf->b_ml.ml_line_count)\n\tuep->ue_bot = 0;\n    else\n    {\n\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n    }\n\n    if (size > 0)\n    {\n\tif ((uep->ue_array = U_ALLOC_LINE(sizeof(undoline_T) * size)) == NULL)\n\t{\n\t    u_freeentry(uep, 0L);\n\t    goto nomem;\n\t}\n\tfor (i = 0, lnum = top + 1; i < size; ++i)\n\t{\n\t    fast_breakcheck();\n\t    if (got_int)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\treturn FAIL;\n\t    }\n\t    if (u_save_line(&uep->ue_array[i], lnum++) == FAIL)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\tgoto nomem;\n\t    }\n\t}\n    }\n    else\n\tuep->ue_array = NULL;\n    uep->ue_next = curbuf->b_u_newhead->uh_entry;\n    curbuf->b_u_newhead->uh_entry = uep;\n    curbuf->b_u_synced = FALSE;\n    undo_undoes = FALSE;\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    return OK;\n\nnomem:\n    msg_silent = 0;\t// must display the prompt\n    if (ask_yesno((char_u *)_(\"No undo possible; continue anyway\"), TRUE)\n\t\t\t\t\t\t\t\t       == 'y')\n    {\n\tundo_off = TRUE;\t    // will be reset when character typed\n\treturn OK;\n    }\n    do_outofmem_msg((long_u)0);\n    return FAIL;\n}\n\n#if defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)\n\n# define UF_START_MAGIC\t    \"Vim\\237UnDo\\345\"  // magic at start of undofile\n# define UF_START_MAGIC_LEN\t9\n# define UF_HEADER_MAGIC\t0x5fd0\t// magic at start of header\n# define UF_HEADER_END_MAGIC\t0xe7aa\t// magic after last header\n# define UF_ENTRY_MAGIC\t\t0xf518\t// magic at start of entry\n# define UF_ENTRY_END_MAGIC\t0x3581\t// magic after last entry\n# define UF_VERSION\t\t2\t// 2-byte undofile version number\n# define UF_VERSION_CRYPT\t0x8002\t// idem, encrypted\n\n// extra fields for header\n# define UF_LAST_SAVE_NR\t1\n\n// extra fields for uhp\n# define UHP_SAVE_NR\t\t1\n\n/*\n * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE].\n */\n    void\nu_compute_hash(char_u *hash)\n{\n    context_sha256_T\tctx;\n    linenr_T\t\tlnum;\n    char_u\t\t*p;\n\n    sha256_start(&ctx);\n    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n    {\n\tp = ml_get(lnum);\n\tsha256_update(&ctx, p, (UINT32_T)(STRLEN(p) + 1));\n    }\n    sha256_finish(&ctx, hash);\n}\n\n/*\n * Return an allocated string of the full path of the target undofile.\n * When \"reading\" is TRUE find the file to read, go over all directories in\n * 'undodir'.\n * When \"reading\" is FALSE use the first name where the directory exists.\n * Returns NULL when there is no place to write or no file to read.\n */\n    static char_u *\nu_get_undo_file_name(char_u *buf_ffname, int reading)\n{\n    char_u\t*dirp;\n    char_u\tdir_name[IOSIZE + 1];\n    char_u\t*munged_name = NULL;\n    char_u\t*undo_file_name = NULL;\n    int\t\tdir_len;\n    char_u\t*p;\n    stat_T\tst;\n    char_u\t*ffname = buf_ffname;\n#ifdef HAVE_READLINK\n    char_u\tfname_buf[MAXPATHL];\n#endif\n\n    if (ffname == NULL)\n\treturn NULL;\n\n#ifdef HAVE_READLINK\n    // Expand symlink in the file name, so that we put the undo file with the\n    // actual file instead of with the symlink.\n    if (resolve_symlink(ffname, fname_buf) == OK)\n\tffname = fname_buf;\n#endif\n\n    // Loop over 'undodir'.  When reading find the first file that exists.\n    // When not reading use the first directory that exists or \".\".\n    dirp = p_udir;\n    while (*dirp != NUL)\n    {\n\tdir_len = copy_option_part(&dirp, dir_name, IOSIZE, \",\");\n\tif (dir_len == 1 && dir_name[0] == '.')\n\t{\n\t    // Use same directory as the ffname,\n\t    // \"dir/name\" -> \"dir/.name.un~\"\n\t    undo_file_name = vim_strnsave(ffname, STRLEN(ffname) + 5);\n\t    if (undo_file_name == NULL)\n\t\tbreak;\n\t    p = gettail(undo_file_name);\n#ifdef VMS\n\t    // VMS can not handle more than one dot in the filenames\n\t    // use \"dir/name\" -> \"dir/_un_name\" - add _un_\n\t    // at the beginning to keep the extension\n\t    mch_memmove(p + 4,  p, STRLEN(p) + 1);\n\t    mch_memmove(p, \"_un_\", 4);\n\n#else\n\t    // Use same directory as the ffname,\n\t    // \"dir/name\" -> \"dir/.name.un~\"\n\t    mch_memmove(p + 1, p, STRLEN(p) + 1);\n\t    *p = '.';\n\t    STRCAT(p, \".un~\");\n#endif\n\t}\n\telse\n\t{\n\t    dir_name[dir_len] = NUL;\n\t    if (mch_isdir(dir_name))\n\t    {\n\t\tif (munged_name == NULL)\n\t\t{\n\t\t    munged_name = vim_strsave(ffname);\n\t\t    if (munged_name == NULL)\n\t\t\treturn NULL;\n\t\t    for (p = munged_name; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (vim_ispathsep(*p))\n\t\t\t    *p = '%';\n\t\t}\n\t\tundo_file_name = concat_fnames(dir_name, munged_name, TRUE);\n\t    }\n\t}\n\n\t// When reading check if the file exists.\n\tif (undo_file_name != NULL && (!reading\n\t\t\t       || mch_stat((char *)undo_file_name, &st) >= 0))\n\t    break;\n\tVIM_CLEAR(undo_file_name);\n    }\n\n    vim_free(munged_name);\n    return undo_file_name;\n}\n\n    static void\ncorruption_error(char *mesg, char_u *file_name)\n{\n    semsg(_(e_corrupted_undo_file_str_str), mesg, file_name);\n}\n\n    static void\nu_free_uhp(u_header_T *uhp)\n{\n    u_entry_T\t*nuep;\n    u_entry_T\t*uep;\n\n    uep = uhp->uh_entry;\n    while (uep != NULL)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n\tuep = nuep;\n    }\n    vim_free(uhp);\n}\n\n/*\n * Write a sequence of bytes to the undo file.\n * Buffers and encrypts as needed.\n * Returns OK or FAIL.\n */\n    static int\nundo_write(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tsize_t\tlen_todo = len;\n\tchar_u  *p = ptr;\n\n\twhile (bi->bi_used + len_todo >= CRYPT_BUF_SIZE)\n\t{\n\t    size_t\tn = CRYPT_BUF_SIZE - bi->bi_used;\n\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, n);\n\t    len_todo -= n;\n\t    p += n;\n\t    bi->bi_used = CRYPT_BUF_SIZE;\n\t    if (undo_flush(bi) == FAIL)\n\t\treturn FAIL;\n\t}\n\tif (len_todo > 0)\n\t{\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, len_todo);\n\t    bi->bi_used += len_todo;\n\t}\n\treturn OK;\n    }\n#endif\n    if (fwrite(ptr, len, (size_t)1, bi->bi_fp) != 1)\n\treturn FAIL;\n    return OK;\n}\n\n#ifdef FEAT_CRYPT\n    static int\nundo_flush(bufinfo_T *bi)\n{\n    if (bi->bi_buffer != NULL && bi->bi_state != NULL && bi->bi_used > 0)\n    {\n\t// Last parameter is only used for sodium encryption and that\n\t// explicitly disables encryption of undofiles.\n\tcrypt_encode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_used, FALSE);\n\tif (fwrite(bi->bi_buffer, bi->bi_used, (size_t)1, bi->bi_fp) != 1)\n\t    return FAIL;\n\tbi->bi_used = 0;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write \"ptr[len]\" and crypt the bytes when needed.\n * Returns OK or FAIL.\n */\n    static int\nfwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    char_u  *copy;\n    char_u  small_buf[100];\n    size_t  i;\n\n    if (bi->bi_state != NULL && bi->bi_buffer == NULL)\n    {\n\t// crypting every piece of text separately\n\tif (len < 100)\n\t    copy = small_buf;  // no malloc()/free() for short strings\n\telse\n\t{\n\t    copy = lalloc(len, FALSE);\n\t    if (copy == NULL)\n\t\treturn 0;\n\t}\n\t// Last parameter is only used for sodium encryption and that\n\t// explicitly disables encryption of undofiles.\n\tcrypt_encode(bi->bi_state, ptr, len, copy, TRUE);\n\ti = fwrite(copy, len, (size_t)1, bi->bi_fp);\n\tif (copy != small_buf)\n\t    vim_free(copy);\n\treturn i == 1 ? OK : FAIL;\n    }\n#endif\n    return undo_write(bi, ptr, len);\n}\n\n/*\n * Write a number, MSB first, in \"len\" bytes.\n * Must match with undo_read_?c() functions.\n * Returns OK or FAIL.\n */\n    static int\nundo_write_bytes(bufinfo_T *bi, long_u nr, int len)\n{\n    char_u  buf[8];\n    int\t    i;\n    int\t    bufi = 0;\n\n    for (i = len - 1; i >= 0; --i)\n\tbuf[bufi++] = (char_u)(nr >> (i * 8));\n    return undo_write(bi, buf, (size_t)len);\n}\n\n/*\n * Write the pointer to an undo header.  Instead of writing the pointer itself\n * we use the sequence number of the header.  This is converted back to\n * pointers when reading. */\n    static void\nput_header_ptr(bufinfo_T *bi, u_header_T *uhp)\n{\n    undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);\n}\n\n    static int\nundo_read_4c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[4];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)4);\n\tn = ((unsigned)buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];\n\treturn n;\n    }\n#endif\n    return get4c(bi->bi_fp);\n}\n\n    static int\nundo_read_2c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[2];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)2);\n\tn = (buf[0] << 8) + buf[1];\n\treturn n;\n    }\n#endif\n    return get2c(bi->bi_fp);\n}\n\n    static int\nundo_read_byte(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[1];\n\n\tundo_read(bi, buf, (size_t)1);\n\treturn buf[0];\n    }\n#endif\n    return getc(bi->bi_fp);\n}\n\n    static time_t\nundo_read_time(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[8];\n\ttime_t\tn = 0;\n\tint\ti;\n\n\tundo_read(bi, buf, (size_t)8);\n\tfor (i = 0; i < 8; ++i)\n\t    n = (n << 8) + buf[i];\n\treturn n;\n    }\n#endif\n    return get8ctime(bi->bi_fp);\n}\n\n/*\n * Read \"buffer[size]\" from the undo file.\n * Return OK or FAIL.\n */\n    static int\nundo_read(bufinfo_T *bi, char_u *buffer, size_t size)\n{\n    int retval = OK;\n\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tint\tsize_todo = (int)size;\n\tchar_u\t*p = buffer;\n\n\twhile (size_todo > 0)\n\t{\n\t    size_t n;\n\n\t    if (bi->bi_used >= bi->bi_avail)\n\t    {\n\t\tn = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);\n\t\tif (n == 0)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tbi->bi_avail = n;\n\t\tbi->bi_used = 0;\n\t\tcrypt_decode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_avail, FALSE);\n\t    }\n\t    n = size_todo;\n\t    if (n > bi->bi_avail - bi->bi_used)\n\t\tn = bi->bi_avail - bi->bi_used;\n\t    mch_memmove(p, bi->bi_buffer + bi->bi_used, n);\n\t    bi->bi_used += n;\n\t    size_todo -= (int)n;\n\t    p += n;\n\t}\n    }\n    else\n#endif\n    if (fread(buffer, (size_t)size, 1, bi->bi_fp) != 1)\n\tretval = FAIL;\n\n    if (retval == FAIL)\n\t// Error may be checked for only later.  Fill with zeros,\n\t// so that the reader won't use garbage.\n\tvim_memset(buffer, 0, size);\n    return retval;\n}\n\n/*\n * Read a string of length \"len\" from \"bi->bi_fd\".\n * \"len\" can be zero to allocate an empty line.\n * Decrypt the bytes if needed.\n * Append a NUL.\n * Returns a pointer to allocated memory or NULL for failure.\n */\n    static char_u *\nread_string_decrypt(bufinfo_T *bi, int len)\n{\n    char_u  *ptr = alloc(len + 1);\n\n    if (ptr != NULL)\n    {\n\tif (len > 0 && undo_read(bi, ptr, len) == FAIL)\n\t{\n\t    vim_free(ptr);\n\t    return NULL;\n\t}\n\t// In case there are text properties there already is a NUL, but\n\t// checking for that is more expensive than just adding a dummy byte.\n\tptr[len] = NUL;\n#ifdef FEAT_CRYPT\n\tif (bi->bi_state != NULL && bi->bi_buffer == NULL)\n\t    crypt_decode_inplace(bi->bi_state, ptr, len, FALSE);\n#endif\n    }\n    return ptr;\n}\n\n/*\n * Writes the (not encrypted) header and initializes encryption if needed.\n */\n    static int\nserialize_header(bufinfo_T *bi, char_u *hash)\n{\n    long\tlen;\n    buf_T\t*buf = bi->bi_buf;\n    FILE\t*fp = bi->bi_fp;\n    char_u\ttime_buf[8];\n\n    // Start writing, first the magic marker and undo info version.\n    if (fwrite(UF_START_MAGIC, (size_t)UF_START_MAGIC_LEN, (size_t)1, fp) != 1)\n\treturn FAIL;\n\n    // If the buffer is encrypted then all text bytes following will be\n    // encrypted.  Numbers and other info is not crypted.\n#ifdef FEAT_CRYPT\n    if (*buf->b_p_key != NUL)\n    {\n\tchar_u *header;\n\tint    header_len;\n\n\tundo_write_bytes(bi, (long_u)UF_VERSION_CRYPT, 2);\n\tbi->bi_state = crypt_create_for_writing(crypt_get_method_nr(buf),\n\t\t\t\t\t  buf->b_p_key, &header, &header_len);\n\tif (bi->bi_state == NULL)\n\t    return FAIL;\n\tlen = (long)fwrite(header, (size_t)header_len, (size_t)1, fp);\n\tvim_free(header);\n\tif (len != 1)\n\t{\n\t    crypt_free_state(bi->bi_state);\n\t    bi->bi_state = NULL;\n\t    return FAIL;\n\t}\n\n\tif (crypt_whole_undofile(crypt_get_method_nr(buf)))\n\t{\n\t    bi->bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi->bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi->bi_state);\n\t\tbi->bi_state = NULL;\n\t\treturn FAIL;\n\t    }\n\t    bi->bi_used = 0;\n\t}\n    }\n    else\n#endif\n\tundo_write_bytes(bi, (long_u)UF_VERSION, 2);\n\n\n    // Write a hash of the buffer text, so that we can verify it is still the\n    // same when reading the buffer text.\n    if (undo_write(bi, hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n\treturn FAIL;\n\n    // buffer-specific data\n    undo_write_bytes(bi, (long_u)buf->b_ml.ml_line_count, 4);\n    len = buf->b_u_line_ptr.ul_line == NULL\n\t\t\t\t? 0L : (long)STRLEN(buf->b_u_line_ptr.ul_line);\n    undo_write_bytes(bi, (long_u)len, 4);\n    if (len > 0 && fwrite_crypt(bi, buf->b_u_line_ptr.ul_line, (size_t)len)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n    undo_write_bytes(bi, (long_u)buf->b_u_line_lnum, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_line_colnr, 4);\n\n    // Undo structures header data\n    put_header_ptr(bi, buf->b_u_oldhead);\n    put_header_ptr(bi, buf->b_u_newhead);\n    put_header_ptr(bi, buf->b_u_curhead);\n\n    undo_write_bytes(bi, (long_u)buf->b_u_numhead, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_last, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_cur, 4);\n    time_to_bytes(buf->b_u_time_cur, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    // Optional fields.\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UF_LAST_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)buf->b_u_save_nr_last, 4);\n\n    undo_write_bytes(bi, 0, 1);  // end marker\n\n    return OK;\n}\n\n    static int\nserialize_uhp(bufinfo_T *bi, u_header_T *uhp)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\ttime_buf[8];\n\n    if (undo_write_bytes(bi, (long_u)UF_HEADER_MAGIC, 2) == FAIL)\n\treturn FAIL;\n\n    put_header_ptr(bi, uhp->uh_next.ptr);\n    put_header_ptr(bi, uhp->uh_prev.ptr);\n    put_header_ptr(bi, uhp->uh_alt_next.ptr);\n    put_header_ptr(bi, uhp->uh_alt_prev.ptr);\n    undo_write_bytes(bi, uhp->uh_seq, 4);\n    serialize_pos(bi, uhp->uh_cursor);\n    undo_write_bytes(bi, (long_u)uhp->uh_cursor_vcol, 4);\n    undo_write_bytes(bi, (long_u)uhp->uh_flags, 2);\n    // Assume NMARKS will stay the same.\n    for (i = 0; i < NMARKS; ++i)\n\tserialize_pos(bi, uhp->uh_namedm[i]);\n    serialize_visualinfo(bi, &uhp->uh_visual);\n    time_to_bytes(uhp->uh_time, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    // Optional fields.\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UHP_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)uhp->uh_save_nr, 4);\n\n    undo_write_bytes(bi, 0, 1);  // end marker\n\n    // Write all the entries.\n    for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n    {\n\tundo_write_bytes(bi, (long_u)UF_ENTRY_MAGIC, 2);\n\tif (serialize_uep(bi, uep) == FAIL)\n\t    return FAIL;\n    }\n    undo_write_bytes(bi, (long_u)UF_ENTRY_END_MAGIC, 2);\n    return OK;\n}\n\n    static u_header_T *\nunserialize_uhp(bufinfo_T *bi, char_u *file_name)\n{\n    u_header_T\t*uhp;\n    int\t\ti;\n    u_entry_T\t*uep, *last_uep;\n    int\t\tc;\n    int\t\terror;\n\n    uhp = U_ALLOC_LINE(sizeof(u_header_T));\n    if (uhp == NULL)\n\treturn NULL;\n    CLEAR_POINTER(uhp);\n#ifdef U_DEBUG\n    uhp->uh_magic = UH_MAGIC;\n#endif\n    uhp->uh_next.seq = undo_read_4c(bi);\n    uhp->uh_prev.seq = undo_read_4c(bi);\n    uhp->uh_alt_next.seq = undo_read_4c(bi);\n    uhp->uh_alt_prev.seq = undo_read_4c(bi);\n    uhp->uh_seq = undo_read_4c(bi);\n    if (uhp->uh_seq <= 0)\n    {\n\tcorruption_error(\"uh_seq\", file_name);\n\tvim_free(uhp);\n\treturn NULL;\n    }\n    unserialize_pos(bi, &uhp->uh_cursor);\n    uhp->uh_cursor_vcol = undo_read_4c(bi);\n    uhp->uh_flags = undo_read_2c(bi);\n    for (i = 0; i < NMARKS; ++i)\n\tunserialize_pos(bi, &uhp->uh_namedm[i]);\n    unserialize_visualinfo(bi, &uhp->uh_visual);\n    uhp->uh_time = undo_read_time(bi);\n\n    // Optional fields.\n    for (;;)\n    {\n\tint len = undo_read_byte(bi);\n\tint what;\n\n\tif (len == EOF)\n\t{\n\t    corruption_error(\"truncated\", file_name);\n\t    u_free_uhp(uhp);\n\t    return NULL;\n\t}\n\tif (len == 0)\n\t    break;\n\twhat = undo_read_byte(bi);\n\tswitch (what)\n\t{\n\t    case UHP_SAVE_NR:\n\t\tuhp->uh_save_nr = undo_read_4c(bi);\n\t\tbreak;\n\t    default:\n\t\t// field not supported, skip\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(bi);\n\t}\n    }\n\n    // Unserialize the uep list.\n    last_uep = NULL;\n    while ((c = undo_read_2c(bi)) == UF_ENTRY_MAGIC)\n    {\n\terror = FALSE;\n\tuep = unserialize_uep(bi, &error, file_name);\n\tif (last_uep == NULL)\n\t    uhp->uh_entry = uep;\n\telse\n\t    last_uep->ue_next = uep;\n\tlast_uep = uep;\n\tif (uep == NULL || error)\n\t{\n\t    u_free_uhp(uhp);\n\t    return NULL;\n\t}\n    }\n    if (c != UF_ENTRY_END_MAGIC)\n    {\n\tcorruption_error(\"entry end\", file_name);\n\tu_free_uhp(uhp);\n\treturn NULL;\n    }\n\n    return uhp;\n}\n\n/*\n * Serialize \"uep\".\n */\n    static int\nserialize_uep(\n    bufinfo_T\t*bi,\n    u_entry_T\t*uep)\n{\n    int\t\ti;\n    size_t\tlen;\n\n    undo_write_bytes(bi, (long_u)uep->ue_top, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_bot, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_lcount, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_size, 4);\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\t// Text is written without the text properties, since we cannot restore\n\t// the text property types.\n\tlen = STRLEN(uep->ue_array[i].ul_line);\n\tif (undo_write_bytes(bi, (long_u)len, 4) == FAIL)\n\t    return FAIL;\n\tif (len > 0 && fwrite_crypt(bi, uep->ue_array[i].ul_line, len) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    static u_entry_T *\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    undoline_T\t*array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    CLEAR_POINTER(uep);\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = U_ALLOC_LINE(sizeof(undoline_T) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(undoline_T) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i].ul_line = line;\n\tarray[i].ul_len = line_len + 1;\n    }\n    return uep;\n}\n\n/*\n * Serialize \"pos\".\n */\n    static void\nserialize_pos(bufinfo_T *bi, pos_T pos)\n{\n    undo_write_bytes(bi, (long_u)pos.lnum, 4);\n    undo_write_bytes(bi, (long_u)pos.col, 4);\n    undo_write_bytes(bi, (long_u)pos.coladd, 4);\n}\n\n/*\n * Unserialize the pos_T at the current position.\n */\n    static void\nunserialize_pos(bufinfo_T *bi, pos_T *pos)\n{\n    pos->lnum = undo_read_4c(bi);\n    if (pos->lnum < 0)\n\tpos->lnum = 0;\n    pos->col = undo_read_4c(bi);\n    if (pos->col < 0)\n\tpos->col = 0;\n    pos->coladd = undo_read_4c(bi);\n    if (pos->coladd < 0)\n\tpos->coladd = 0;\n}\n\n/*\n * Serialize \"info\".\n */\n    static void\nserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    serialize_pos(bi, info->vi_start);\n    serialize_pos(bi, info->vi_end);\n    undo_write_bytes(bi, (long_u)info->vi_mode, 4);\n    undo_write_bytes(bi, (long_u)info->vi_curswant, 4);\n}\n\n/*\n * Unserialize the visualinfo_T at the current position.\n */\n    static void\nunserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    unserialize_pos(bi, &info->vi_start);\n    unserialize_pos(bi, &info->vi_end);\n    info->vi_mode = undo_read_4c(bi);\n    info->vi_curswant = undo_read_4c(bi);\n}\n\n/*\n * Write the undo tree in an undo file.\n * When \"name\" is not NULL, use it as the name of the undo file.\n * Otherwise use buf->b_ffname to generate the undo file name.\n * \"buf\" must never be null, buf->b_ffname is used to obtain the original file\n * permissions.\n * \"forceit\" is TRUE for \":wundo!\", FALSE otherwise.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_write_undo(\n    char_u\t*name,\n    int\t\tforceit,\n    buf_T\t*buf,\n    char_u\t*hash)\n{\n    u_header_T\t*uhp;\n    char_u\t*file_name;\n    int\t\tmark;\n#ifdef U_DEBUG\n    int\t\theaders_written = 0;\n#endif\n    int\t\tfd;\n    FILE\t*fp = NULL;\n    int\t\tperm;\n    int\t\twrite_ok = FALSE;\n#ifdef UNIX\n    int\t\tst_old_valid = FALSE;\n    stat_T\tst_old;\n    stat_T\tst_new;\n#endif\n    bufinfo_T\tbi;\n\n    CLEAR_FIELD(bi);\n\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(buf->b_ffname, FALSE);\n\tif (file_name == NULL)\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg(\n\t\t   _(\"Cannot write undo file in any directory in 'undodir'\"));\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n    }\n    else\n\tfile_name = name;\n\n    /*\n     * Decide about the permission to use for the undo file.  If the buffer\n     * has a name use the permission of the original file.  Otherwise only\n     * allow the user to access the undo file.\n     */\n    perm = 0600;\n    if (buf->b_ffname != NULL)\n    {\n#ifdef UNIX\n\tif (mch_stat((char *)buf->b_ffname, &st_old) >= 0)\n\t{\n\t    perm = st_old.st_mode;\n\t    st_old_valid = TRUE;\n\t}\n#else\n\tperm = mch_getperm(buf->b_ffname);\n\tif (perm < 0)\n\t    perm = 0600;\n#endif\n    }\n\n    // strip any s-bit and executable bit\n    perm = perm & 0666;\n\n    // If the undo file already exists, verify that it actually is an undo\n    // file, and delete it.\n    if (mch_getperm(file_name) >= 0)\n    {\n\tif (name == NULL || !forceit)\n\t{\n\t    // Check we can read it and it's an undo file.\n\t    fd = mch_open((char *)file_name, O_RDONLY|O_EXTRA, 0);\n\t    if (fd < 0)\n\t    {\n\t\tif (name != NULL || p_verbose > 0)\n\t\t{\n\t\t    if (name == NULL)\n\t\t\tverbose_enter();\n\t\t    smsg(\n\t\t      _(\"Will not overwrite with undo file, cannot read: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t    if (name == NULL)\n\t\t\tverbose_leave();\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tchar_u\tmbuf[UF_START_MAGIC_LEN];\n\t\tint\tlen;\n\n\t\tlen = read_eintr(fd, mbuf, UF_START_MAGIC_LEN);\n\t\tclose(fd);\n\t\tif (len < UF_START_MAGIC_LEN\n\t\t      || memcmp(mbuf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n\t\t{\n\t\t    if (name != NULL || p_verbose > 0)\n\t\t    {\n\t\t\tif (name == NULL)\n\t\t\t    verbose_enter();\n\t\t\tsmsg(\n\t\t\t_(\"Will not overwrite, this is not an undo file: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t\tif (name == NULL)\n\t\t\t    verbose_leave();\n\t\t    }\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\tmch_remove(file_name);\n    }\n\n    // If there is no undo information at all, quit here after deleting any\n    // existing undo file.\n    if (buf->b_u_numhead == 0 && buf->b_u_line_ptr.ul_line == NULL)\n    {\n\tif (p_verbose > 0)\n\t    verb_msg(_(\"Skipping undo file write, nothing to undo\"));\n\tgoto theend;\n    }\n\n    fd = mch_open((char *)file_name,\n\t\t\t    O_CREAT|O_EXTRA|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n    if (fd < 0)\n    {\n\tsemsg(_(e_cannot_open_undo_file_for_writing_str), file_name);\n\tgoto theend;\n    }\n    (void)mch_setperm(file_name, perm);\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Writing undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n#ifdef U_DEBUG\n    // Check there is no problem in undo info before writing.\n    u_check(FALSE);\n#endif\n\n#ifdef UNIX\n    /*\n     * Try to set the group of the undo file same as the original file. If\n     * this fails, set the protection bits for the group same as the\n     * protection bits for others.\n     */\n    if (st_old_valid\n\t    && mch_stat((char *)file_name, &st_new) >= 0\n\t    && st_new.st_gid != st_old.st_gid\n# ifdef HAVE_FCHOWN  // sequent-ptx lacks fchown()\n\t    && fchown(fd, (uid_t)-1, st_old.st_gid) != 0\n# endif\n       )\n\tmch_setperm(file_name, (perm & 0707) | ((perm & 07) << 3));\n# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n    if (buf->b_ffname != NULL)\n\tmch_copy_sec(buf->b_ffname, file_name);\n# endif\n#endif\n\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL)\n    {\n\tsemsg(_(e_cannot_open_undo_file_for_writing_str), file_name);\n\tclose(fd);\n\tmch_remove(file_name);\n\tgoto theend;\n    }\n\n    // Undo must be synced.\n    u_sync(TRUE);\n\n    /*\n     * Write the header.  Initializes encryption, if enabled.\n     */\n    bi.bi_buf = buf;\n    bi.bi_fp = fp;\n    if (serialize_header(&bi, hash) == FAIL)\n\tgoto write_error;\n\n    /*\n     * Iteratively serialize UHPs and their UEPs from the top down.\n     */\n    mark = ++lastmark;\n    uhp = buf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\t// Serialize current UHP if we haven't seen it\n\tif (uhp->uh_walk != mark)\n\t{\n\t    uhp->uh_walk = mark;\n#ifdef U_DEBUG\n\t    ++headers_written;\n#endif\n\t    if (serialize_uhp(&bi, uhp) == FAIL)\n\t\tgoto write_error;\n\t}\n\n\t// Now walk through the tree - algorithm from undo_time().\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_prev.ptr;\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t\t\t\t && uhp->uh_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_next.ptr;\n\telse if (uhp->uh_alt_prev.ptr != NULL)\n\t    uhp = uhp->uh_alt_prev.ptr;\n\telse\n\t    uhp = uhp->uh_next.ptr;\n    }\n\n    if (undo_write_bytes(&bi, (long_u)UF_HEADER_END_MAGIC, 2) == OK)\n\twrite_ok = TRUE;\n#ifdef U_DEBUG\n    if (headers_written != buf->b_u_numhead)\n    {\n\tsemsg(\"Written %ld headers, ...\", headers_written);\n\tsemsg(\"... but numhead is %ld\", buf->b_u_numhead);\n    }\n#endif\n\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL && undo_flush(&bi) == FAIL)\n\twrite_ok = FALSE;\n#endif\n\n#if defined(UNIX) && defined(HAVE_FSYNC)\n    if (p_fs && fflush(fp) == 0 && vim_fsync(fd) != 0)\n\twrite_ok = FALSE;\n#endif\n\nwrite_error:\n    fclose(fp);\n    if (!write_ok)\n\tsemsg(_(e_write_error_in_undo_file_str), file_name);\n\n#if defined(MSWIN)\n    // Copy file attributes; for systems where this can only be done after\n    // closing the file.\n    if (buf->b_ffname != NULL)\n\t(void)mch_copy_file_attribute(buf->b_ffname, file_name);\n#endif\n#ifdef HAVE_ACL\n    if (buf->b_ffname != NULL)\n    {\n\tvim_acl_T\t    acl;\n\n\t// For systems that support ACL: get the ACL from the original file.\n\tacl = mch_get_acl(buf->b_ffname);\n\tmch_set_acl(file_name, acl);\n\tmch_free_acl(acl);\n    }\n#endif\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (file_name != name)\n\tvim_free(file_name);\n}\n\n/*\n * Load the undo tree from an undo file.\n * If \"name\" is not NULL use it as the undo file name.  This also means being\n * a bit more verbose.\n * Otherwise use curbuf->b_ffname to generate the undo file name.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_read_undo(char_u *name, char_u *hash, char_u *orig_name UNUSED)\n{\n    char_u\t*file_name;\n    FILE\t*fp;\n    long\tversion, str_len;\n    undoline_T\tline_ptr;\n    linenr_T\tline_lnum;\n    colnr_T\tline_colnr;\n    linenr_T\tline_count;\n    long\tnum_head = 0;\n    long\told_header_seq, new_header_seq, cur_header_seq;\n    long\tseq_last, seq_cur;\n    long\tlast_save_nr = 0;\n    short\told_idx = -1, new_idx = -1, cur_idx = -1;\n    long\tnum_read_uhps = 0;\n    time_t\tseq_time;\n    int\t\ti, j;\n    int\t\tc;\n    u_header_T\t*uhp;\n    u_header_T\t**uhp_table = NULL;\n    char_u\tread_hash[UNDO_HASH_SIZE];\n    char_u\tmagic_buf[UF_START_MAGIC_LEN];\n#ifdef U_DEBUG\n    int\t\t*uhp_table_used;\n#endif\n#ifdef UNIX\n    stat_T\tst_orig;\n    stat_T\tst_undo;\n#endif\n    bufinfo_T\tbi;\n\n    CLEAR_FIELD(bi);\n    line_ptr.ul_len = 0;\n    line_ptr.ul_line = NULL;\n\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);\n\tif (file_name == NULL)\n\t    return;\n\n#ifdef UNIX\n\t// For safety we only read an undo file if the owner is equal to the\n\t// owner of the text file or equal to the current user.\n\tif (mch_stat((char *)orig_name, &st_orig) >= 0\n\t\t&& mch_stat((char *)file_name, &st_undo) >= 0\n\t\t&& st_orig.st_uid != st_undo.st_uid\n\t\t&& st_undo.st_uid != getuid())\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg(_(\"Not reading undo file, owner differs: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n#endif\n    }\n    else\n\tfile_name = name;\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n    fp = mch_fopen((char *)file_name, \"r\");\n    if (fp == NULL)\n    {\n\tif (name != NULL || p_verbose > 0)\n\t    semsg(_(e_cannot_open_undo_file_for_reading_str), file_name);\n\tgoto error;\n    }\n    bi.bi_buf = curbuf;\n    bi.bi_fp = fp;\n\n    /*\n     * Read the undo file header.\n     */\n    if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1\n\t\t|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n    {\n\tsemsg(_(e_not_an_undo_file_str), file_name);\n\tgoto error;\n    }\n    version = get2c(fp);\n    if (version == UF_VERSION_CRYPT)\n    {\n#ifdef FEAT_CRYPT\n\tif (*curbuf->b_p_key == NUL)\n\t{\n\t    semsg(_(e_non_encrypted_file_has_encrypted_undo_file), file_name);\n\t    goto error;\n\t}\n\tbi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);\n\tif (bi.bi_state == NULL)\n\t{\n\t    semsg(_(e_undo_file_decryption_failed), file_name);\n\t    goto error;\n\t}\n\tif (crypt_whole_undofile(bi.bi_state->method_nr))\n\t{\n\t    bi.bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi.bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi.bi_state);\n\t\tbi.bi_state = NULL;\n\t\tgoto error;\n\t    }\n\t    bi.bi_avail = 0;\n\t    bi.bi_used = 0;\n\t}\n#else\n\tsemsg(_(e_undo_file_is_encrypted_str), file_name);\n\tgoto error;\n#endif\n    }\n    else if (version != UF_VERSION)\n    {\n\tsemsg(_(e_incompatible_undo_file_str), file_name);\n\tgoto error;\n    }\n\n    if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n    {\n\tcorruption_error(\"hash\", file_name);\n\tgoto error;\n    }\n    line_count = (linenr_T)undo_read_4c(&bi);\n    if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0\n\t\t\t\t  || line_count != curbuf->b_ml.ml_line_count)\n    {\n\tif (p_verbose > 0 || name != NULL)\n\t{\n\t    if (name == NULL)\n\t\tverbose_enter();\n\t    give_warning((char_u *)\n\t\t      _(\"File contents changed, cannot use undo info\"), TRUE);\n\t    if (name == NULL)\n\t\tverbose_leave();\n\t}\n\tgoto error;\n    }\n\n    // Read undo data for \"U\" command.\n    str_len = undo_read_4c(&bi);\n    if (str_len < 0)\n\tgoto error;\n    if (str_len > 0)\n    {\n\tline_ptr.ul_line = read_string_decrypt(&bi, str_len);\n\tline_ptr.ul_len = str_len + 1;\n    }\n    line_lnum = (linenr_T)undo_read_4c(&bi);\n    line_colnr = (colnr_T)undo_read_4c(&bi);\n    if (line_lnum < 0 || line_colnr < 0)\n    {\n\tcorruption_error(\"line lnum/col\", file_name);\n\tgoto error;\n    }\n\n    // Begin general undo data\n    old_header_seq = undo_read_4c(&bi);\n    new_header_seq = undo_read_4c(&bi);\n    cur_header_seq = undo_read_4c(&bi);\n    num_head = undo_read_4c(&bi);\n    seq_last = undo_read_4c(&bi);\n    seq_cur = undo_read_4c(&bi);\n    seq_time = undo_read_time(&bi);\n\n    // Optional header fields.\n    for (;;)\n    {\n\tint len = undo_read_byte(&bi);\n\tint what;\n\n\tif (len == 0 || len == EOF)\n\t    break;\n\twhat = undo_read_byte(&bi);\n\tswitch (what)\n\t{\n\t    case UF_LAST_SAVE_NR:\n\t\tlast_save_nr = undo_read_4c(&bi);\n\t\tbreak;\n\t    default:\n\t\t// field not supported, skip\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(&bi);\n\t}\n    }\n\n    // uhp_table will store the freshly created undo headers we allocate\n    // until we insert them into curbuf. The table remains sorted by the\n    // sequence numbers of the headers.\n    // When there are no headers uhp_table is NULL.\n    if (num_head > 0)\n    {\n\tif (num_head < LONG_MAX / (long)sizeof(u_header_T *))\n\t    uhp_table = U_ALLOC_LINE(num_head * sizeof(u_header_T *));\n\tif (uhp_table == NULL)\n\t    goto error;\n    }\n\n    while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)\n    {\n\tif (num_read_uhps >= num_head)\n\t{\n\t    corruption_error(\"num_head too small\", file_name);\n\t    goto error;\n\t}\n\n\tuhp = unserialize_uhp(&bi, file_name);\n\tif (uhp == NULL)\n\t    goto error;\n\tuhp_table[num_read_uhps++] = uhp;\n    }\n\n    if (num_read_uhps != num_head)\n    {\n\tcorruption_error(\"num_head\", file_name);\n\tgoto error;\n    }\n    if (c != UF_HEADER_END_MAGIC)\n    {\n\tcorruption_error(\"end marker\", file_name);\n\tgoto error;\n    }\n\n#ifdef U_DEBUG\n    uhp_table_used = alloc_clear(sizeof(int) * num_head + 1);\n# define SET_FLAG(j) ++uhp_table_used[j]\n#else\n# define SET_FLAG(j)\n#endif\n\n    // We have put all of the headers into a table. Now we iterate through the\n    // table and swizzle each sequence number we have stored in uh_*_seq into\n    // a pointer corresponding to the header with that sequence number.\n    for (i = 0; i < num_head; i++)\n    {\n\tuhp = uhp_table[i];\n\tif (uhp == NULL)\n\t    continue;\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL && i != j\n\t\t\t      && uhp_table[i]->uh_seq == uhp_table[j]->uh_seq)\n\t    {\n\t\tcorruption_error(\"duplicate uh_seq\", file_name);\n\t\tgoto error;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_next.seq)\n\t    {\n\t\tuhp->uh_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_prev.seq)\n\t    {\n\t\tuhp->uh_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_next.seq)\n\t    {\n\t\tuhp->uh_alt_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_prev.seq)\n\t    {\n\t\tuhp->uh_alt_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tif (old_header_seq > 0 && old_idx < 0 && uhp->uh_seq == old_header_seq)\n\t{\n\t    old_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (new_header_seq > 0 && new_idx < 0 && uhp->uh_seq == new_header_seq)\n\t{\n\t    new_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (cur_header_seq > 0 && cur_idx < 0 && uhp->uh_seq == cur_header_seq)\n\t{\n\t    cur_idx = i;\n\t    SET_FLAG(i);\n\t}\n    }\n\n    // Now that we have read the undo info successfully, free the current undo\n    // info and use the info from the file.\n    u_blockfree(curbuf);\n    curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];\n    curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];\n    curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];\n    curbuf->b_u_line_ptr = line_ptr;\n    curbuf->b_u_line_lnum = line_lnum;\n    curbuf->b_u_line_colnr = line_colnr;\n    curbuf->b_u_numhead = num_head;\n    curbuf->b_u_seq_last = seq_last;\n    curbuf->b_u_seq_cur = seq_cur;\n    curbuf->b_u_time_cur = seq_time;\n    curbuf->b_u_save_nr_last = last_save_nr;\n    curbuf->b_u_save_nr_cur = last_save_nr;\n\n    curbuf->b_u_synced = TRUE;\n    vim_free(uhp_table);\n\n#ifdef U_DEBUG\n    for (i = 0; i < num_head; ++i)\n\tif (uhp_table_used[i] == 0)\n\t    semsg(\"uhp_table entry %ld not used, leaking memory\", i);\n    vim_free(uhp_table_used);\n    u_check(TRUE);\n#endif\n\n    if (name != NULL)\n\tsmsg(_(\"Finished reading undo file %s\"), file_name);\n    goto theend;\n\nerror:\n    vim_free(line_ptr.ul_line);\n    if (uhp_table != NULL)\n    {\n\tfor (i = 0; i < num_read_uhps; i++)\n\t    if (uhp_table[i] != NULL)\n\t\tu_free_uhp(uhp_table[i]);\n\tvim_free(uhp_table);\n    }\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (fp != NULL)\n\tfclose(fp);\n    if (file_name != name)\n\tvim_free(file_name);\n    return;\n}\n\n#endif // FEAT_PERSISTENT_UNDO\n\n\n/*\n * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).\n * If 'cpoptions' does not contain 'u': Always undo.\n */\n    void\nu_undo(int count)\n{\n    /*\n     * If we get an undo command while executing a macro, we behave like the\n     * original vi. If this happens twice in one macro the result will not\n     * be compatible.\n     */\n    if (curbuf->b_u_synced == FALSE)\n    {\n\tu_sync(TRUE);\n\tcount = 1;\n    }\n\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = TRUE;\n    else\n\tundo_undoes = !undo_undoes;\n    u_doit(count);\n}\n\n/*\n * If 'cpoptions' contains 'u': Repeat the previous undo or redo.\n * If 'cpoptions' does not contain 'u': Always redo.\n */\n    void\nu_redo(int count)\n{\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = FALSE;\n    u_doit(count);\n}\n\n/*\n * Undo or redo, depending on 'undo_undoes', 'count' times.\n */\n    static void\nu_doit(int startcount)\n{\n    int count = startcount;\n\n    if (!undo_allowed())\n\treturn;\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n    while (count--)\n    {\n\t// Do the change warning now, so that it triggers FileChangedRO when\n\t// needed.  This may cause the file to be reloaded, that must happen\n\t// before we do anything, because it may change curbuf->b_u_curhead\n\t// and more.\n\tchange_warning(0);\n\n\tif (undo_undoes)\n\t{\n\t    if (curbuf->b_u_curhead == NULL)\t\t// first undo\n\t\tcurbuf->b_u_curhead = curbuf->b_u_newhead;\n\t    else if (get_undolevel() > 0)\t\t// multi level undo\n\t\t// get next undo\n\t\tcurbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;\n\t    // nothing to undo\n\t    if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL)\n\t    {\n\t\t// stick curbuf->b_u_curhead at end\n\t\tcurbuf->b_u_curhead = curbuf->b_u_oldhead;\n\t\tbeep_flush();\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    msg(_(\"Already at oldest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(TRUE);\n\t}\n\telse\n\t{\n\t    if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0)\n\t    {\n\t\tbeep_flush();\t// nothing to redo\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    msg(_(\"Already at newest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(FALSE);\n\n\t    // Advance for next redo.  Set \"newhead\" when at the end of the\n\t    // redoable changes.\n\t    if (curbuf->b_u_curhead->uh_prev.ptr == NULL)\n\t\tcurbuf->b_u_newhead = curbuf->b_u_curhead;\n\t    curbuf->b_u_curhead = curbuf->b_u_curhead->uh_prev.ptr;\n\t}\n    }\n    u_undo_end(undo_undoes, FALSE);\n}\n\n/*\n * Undo or redo over the timeline.\n * When \"step\" is negative go back in time, otherwise goes forward in time.\n * When \"sec\" is FALSE make \"step\" steps, when \"sec\" is TRUE use \"step\" as\n * seconds.\n * When \"file\" is TRUE use \"step\" as a number of file writes.\n * When \"absolute\" is TRUE use \"step\" as the sequence number to jump to.\n * \"sec\" must be FALSE then.\n */\n    void\nundo_time(\n    long\tstep,\n    int\t\tsec,\n    int\t\tfile,\n    int\t\tabsolute)\n{\n    long\t    target;\n    long\t    closest;\n    long\t    closest_start;\n    long\t    closest_seq = 0;\n    long\t    val;\n    u_header_T\t    *uhp = NULL;\n    u_header_T\t    *last;\n    int\t\t    mark;\n    int\t\t    nomark = 0;  // shut up compiler\n    int\t\t    round;\n    int\t\t    dosec = sec;\n    int\t\t    dofile = file;\n    int\t\t    above = FALSE;\n    int\t\t    did_undo = TRUE;\n\n    // First make sure the current undoable change is synced.\n    if (curbuf->b_u_synced == FALSE)\n\tu_sync(TRUE);\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n\n    // \"target\" is the node below which we want to be.\n    // Init \"closest\" to a value we can't reach.\n    if (absolute)\n    {\n\ttarget = step;\n\tclosest = -1;\n    }\n    else\n    {\n\tif (dosec)\n\t    target = (long)(curbuf->b_u_time_cur) + step;\n\telse if (dofile)\n\t{\n\t    if (step < 0)\n\t    {\n\t\t// Going back to a previous write. If there were changes after\n\t\t// the last write, count that as moving one file-write, so\n\t\t// that \":earlier 1f\" undoes all changes since the last save.\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp != NULL)\n\t\t    uhp = uhp->uh_next.ptr;\n\t\telse\n\t\t    uhp = curbuf->b_u_newhead;\n\t\tif (uhp != NULL && uhp->uh_save_nr != 0)\n\t\t    // \"uh_save_nr\" was set in the last block, that means\n\t\t    // there were no changes since the last write\n\t\t    target = curbuf->b_u_save_nr_cur + step;\n\t\telse\n\t\t    // count the changes since the last write as one step\n\t\t    target = curbuf->b_u_save_nr_cur + step + 1;\n\t\tif (target <= 0)\n\t\t    // Go to before first write: before the oldest change. Use\n\t\t    // the sequence number for that.\n\t\t    dofile = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t// Moving forward to a newer write.\n\t\ttarget = curbuf->b_u_save_nr_cur + step;\n\t\tif (target > curbuf->b_u_save_nr_last)\n\t\t{\n\t\t    // Go to after last write: after the latest change. Use\n\t\t    // the sequence number for that.\n\t\t    target = curbuf->b_u_seq_last + 1;\n\t\t    dofile = FALSE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    target = curbuf->b_u_seq_cur + step;\n\tif (step < 0)\n\t{\n\t    if (target < 0)\n\t\ttarget = 0;\n\t    closest = -1;\n\t}\n\telse\n\t{\n\t    if (dosec)\n\t\tclosest = (long)(vim_time() + 1);\n\t    else if (dofile)\n\t\tclosest = curbuf->b_u_save_nr_last + 2;\n\t    else\n\t\tclosest = curbuf->b_u_seq_last + 2;\n\t    if (target >= closest)\n\t\ttarget = closest - 1;\n\t}\n    }\n    closest_start = closest;\n    closest_seq = curbuf->b_u_seq_cur;\n\n    // When \"target\" is 0; Back to origin.\n    if (target == 0)\n    {\n\tmark = lastmark;  // avoid that GCC complains\n\tgoto target_zero;\n    }\n\n    /*\n     * May do this twice:\n     * 1. Search for \"target\", update \"closest\" to the best match found.\n     * 2. If \"target\" not found search for \"closest\".\n     *\n     * When using the closest time we use the sequence number in the second\n     * round, because there may be several entries with the same time.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t// Find the path from the current state to where we want to go.  The\n\t// desired state can be anywhere in the undo tree, need to go all over\n\t// it.  We put \"nomark\" in uh_walk where we have been without success,\n\t// \"mark\" where it could possibly be.\n\tmark = ++lastmark;\n\tnomark = ++lastmark;\n\n\tif (curbuf->b_u_curhead == NULL)\t// at leaf of the tree\n\t    uhp = curbuf->b_u_newhead;\n\telse\n\t    uhp = curbuf->b_u_curhead;\n\n\twhile (uhp != NULL)\n\t{\n\t    uhp->uh_walk = mark;\n\t    if (dosec)\n\t\tval = (long)(uhp->uh_time);\n\t    else if (dofile)\n\t\tval = uhp->uh_save_nr;\n\t    else\n\t\tval = uhp->uh_seq;\n\n\t    if (round == 1 && !(dofile && val == 0))\n\t    {\n\t\t// Remember the header that is closest to the target.\n\t\t// It must be at least in the right direction (checked with\n\t\t// \"b_u_seq_cur\").  When the timestamp is equal find the\n\t\t// highest/lowest sequence number.\n\t\tif ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur\n\t\t\t      : uhp->uh_seq > curbuf->b_u_seq_cur)\n\t\t\t&& ((dosec && val == closest)\n\t\t\t    ? (step < 0\n\t\t\t\t? uhp->uh_seq < closest_seq\n\t\t\t\t: uhp->uh_seq > closest_seq)\n\t\t\t    : closest == closest_start\n\t\t\t\t|| (val > target\n\t\t\t\t    ? (closest > target\n\t\t\t\t\t? val - target <= closest - target\n\t\t\t\t\t: val - target <= target - closest)\n\t\t\t\t    : (closest > target\n\t\t\t\t\t? target - val <= closest - target\n\t\t\t\t\t: target - val <= target - closest))))\n\t\t{\n\t\t    closest = val;\n\t\t    closest_seq = uhp->uh_seq;\n\t\t}\n\t    }\n\n\t    // Quit searching when we found a match.  But when searching for a\n\t    // time we need to continue looking for the best uh_seq.\n\t    if (target == val && !dosec)\n\t    {\n\t\ttarget = uhp->uh_seq;\n\t\tbreak;\n\t    }\n\n\t    // go down in the tree if we haven't been there\n\t    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_prev.ptr;\n\n\t    // go to alternate branch if we haven't been there\n\t    else if (uhp->uh_alt_next.ptr != NULL\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_alt_next.ptr;\n\n\t    // go up in the tree if we haven't been there and we are at the\n\t    // start of alternate branches\n\t    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t    && uhp->uh_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_next.ptr->uh_walk != mark)\n\t    {\n\t\t// If still at the start we don't go through this change.\n\t\tif (uhp == curbuf->b_u_curhead)\n\t\t    uhp->uh_walk = nomark;\n\t\tuhp = uhp->uh_next.ptr;\n\t    }\n\n\t    else\n\t    {\n\t\t// need to backtrack; mark this node as useless\n\t\tuhp->uh_walk = nomark;\n\t\tif (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\telse\n\t\t    uhp = uhp->uh_next.ptr;\n\t    }\n\t}\n\n\tif (uhp != NULL)    // found it\n\t    break;\n\n\tif (absolute)\n\t{\n\t    semsg(_(e_undo_number_nr_not_found), step);\n\t    return;\n\t}\n\n\tif (closest == closest_start)\n\t{\n\t    if (step < 0)\n\t\tmsg(_(\"Already at oldest change\"));\n\t    else\n\t\tmsg(_(\"Already at newest change\"));\n\t    return;\n\t}\n\n\ttarget = closest_seq;\n\tdosec = FALSE;\n\tdofile = FALSE;\n\tif (step < 0)\n\t    above = TRUE;\t// stop above the header\n    }\n\ntarget_zero:\n    // If we found it: Follow the path to go to where we want to be.\n    if (uhp != NULL || target == 0)\n    {\n\t/*\n\t * First go up the tree as much as needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    // Do the change warning now, for the same reason as above.\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tuhp = curbuf->b_u_newhead;\n\t    else\n\t\tuhp = uhp->uh_next.ptr;\n\t    if (uhp == NULL || (target > 0 && uhp->uh_walk != mark)\n\t\t\t\t\t || (uhp->uh_seq == target && !above))\n\t\tbreak;\n\t    curbuf->b_u_curhead = uhp;\n\t    u_undoredo(TRUE);\n\t    if (target > 0)\n\t\tuhp->uh_walk = nomark;\t// don't go back down here\n\t}\n\n\t// When back to origin, redo is not needed.\n\tif (target > 0)\n\t{\n\t    /*\n\t     * And now go down the tree (redo), branching off where needed.\n\t     */\n\t    while (!got_int)\n\t    {\n\t\t// Do the change warning now, for the same reason as above.\n\t\tchange_warning(0);\n\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp == NULL)\n\t\t    break;\n\n\t\t// Go back to the first branch with a mark.\n\t\twhile (uhp->uh_alt_prev.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_prev.ptr->uh_walk == mark)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\n\t\t// Find the last branch with a mark, that's the one.\n\t\tlast = uhp;\n\t\twhile (last->uh_alt_next.ptr != NULL\n\t\t\t\t    && last->uh_alt_next.ptr->uh_walk == mark)\n\t\t    last = last->uh_alt_next.ptr;\n\t\tif (last != uhp)\n\t\t{\n\t\t    // Make the used branch the first entry in the list of\n\t\t    // alternatives to make \"u\" and CTRL-R take this branch.\n\t\t    while (uhp->uh_alt_prev.ptr != NULL)\n\t\t\tuhp = uhp->uh_alt_prev.ptr;\n\t\t    if (last->uh_alt_next.ptr != NULL)\n\t\t\tlast->uh_alt_next.ptr->uh_alt_prev.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_prev.ptr;\n\t\t    last->uh_alt_prev.ptr->uh_alt_next.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_next.ptr;\n\t\t    last->uh_alt_prev.ptr = NULL;\n\t\t    last->uh_alt_next.ptr = uhp;\n\t\t    uhp->uh_alt_prev.ptr = last;\n\n\t\t    if (curbuf->b_u_oldhead == uhp)\n\t\t\tcurbuf->b_u_oldhead = last;\n\t\t    uhp = last;\n\t\t    if (uhp->uh_next.ptr != NULL)\n\t\t\tuhp->uh_next.ptr->uh_prev.ptr = uhp;\n\t\t}\n\t\tcurbuf->b_u_curhead = uhp;\n\n\t\tif (uhp->uh_walk != mark)\n\t\t    break;\t    // must have reached the target\n\n\t\t// Stop when going backwards in time and didn't find the exact\n\t\t// header we were looking for.\n\t\tif (uhp->uh_seq == target && above)\n\t\t{\n\t\t    curbuf->b_u_seq_cur = target - 1;\n\t\t    break;\n\t\t}\n\n\t\tu_undoredo(FALSE);\n\n\t\t// Advance \"curhead\" to below the header we last used.  If it\n\t\t// becomes NULL then we need to set \"newhead\" to this leaf.\n\t\tif (uhp->uh_prev.ptr == NULL)\n\t\t    curbuf->b_u_newhead = uhp;\n\t\tcurbuf->b_u_curhead = uhp->uh_prev.ptr;\n\t\tdid_undo = FALSE;\n\n\t\tif (uhp->uh_seq == target)\t// found it!\n\t\t    break;\n\n\t\tuhp = uhp->uh_prev.ptr;\n\t\tif (uhp == NULL || uhp->uh_walk != mark)\n\t\t{\n\t\t    // Need to redo more but can't find it...\n\t\t    internal_error(\"undo_time()\");\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    u_undo_end(did_undo, absolute);\n}\n\n/*\n * u_undoredo: common code for undo and redo\n *\n * The lines in the file are replaced by the lines in the entry list at\n * curbuf->b_u_curhead. The replaced lines in the file are saved in the entry\n * list for the next undo/redo.\n *\n * When \"undo\" is TRUE we go up in the tree, when FALSE we go down.\n */\n    static void\nu_undoredo(int undo)\n{\n    undoline_T\t*newarray = NULL;\n    linenr_T\toldsize;\n    linenr_T\tnewsize;\n    linenr_T\ttop, bot;\n    linenr_T\tlnum;\n    linenr_T\tnewlnum = MAXLNUM;\n    pos_T\tnew_curpos = curwin->w_cursor;\n    long\ti;\n    u_entry_T\t*uep, *nuep;\n    u_entry_T\t*newlist = NULL;\n    int\t\told_flags;\n    int\t\tnew_flags;\n    pos_T\tnamedm[NMARKS];\n    visualinfo_T visualinfo;\n    int\t\tempty_buffer;\t\t    // buffer became empty\n    u_header_T\t*curhead = curbuf->b_u_curhead;\n\n    // Don't want autocommands using the undo structures here, they are\n    // invalid till the end.\n    block_autocmds();\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    old_flags = curhead->uh_flags;\n    new_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n    setpcmark();\n\n    /*\n     * save marks before undo/redo\n     */\n    mch_memmove(namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n    visualinfo = curbuf->b_visual;\n    curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;\n    curbuf->b_op_start.col = 0;\n    curbuf->b_op_end.lnum = 0;\n    curbuf->b_op_end.col = 0;\n\n    for (uep = curhead->uh_entry; uep != NULL; uep = nuep)\n    {\n\ttop = uep->ue_top;\n\tbot = uep->ue_bot;\n\tif (bot == 0)\n\t    bot = curbuf->b_ml.ml_line_count + 1;\n\tif (top > curbuf->b_ml.ml_line_count || top >= bot\n\t\t\t\t      || bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n\t    unblock_autocmds();\n\t    iemsg(_(e_u_undo_line_numbers_wrong));\n\t    changed();\t\t// don't want UNCHANGED now\n\t    return;\n\t}\n\n\toldsize = bot - top - 1;    // number of lines before undo\n\tnewsize = uep->ue_size;\t    // number of lines after undo\n\n\t// Decide about the cursor position, depending on what text changed.\n\t// Don't set it yet, it may be invalid if lines are going to be added.\n\tif (top < newlnum)\n\t{\n\t    // If the saved cursor is somewhere in this undo block, move it to\n\t    // the remembered position.  Makes \"gwap\" put the cursor back\n\t    // where it was.\n\t    lnum = curhead->uh_cursor.lnum;\n\t    if (lnum >= top && lnum <= top + newsize + 1)\n\t    {\n\t\tnew_curpos = curhead->uh_cursor;\n\t\tnewlnum = new_curpos.lnum - 1;\n\t    }\n\t    else\n\t    {\n\t\t// Use the first line that actually changed.  Avoids that\n\t\t// undoing auto-formatting puts the cursor in the previous\n\t\t// line.\n\t\tfor (i = 0; i < newsize && i < oldsize; ++i)\n\t\t{\n\t\t    char_u *p = ml_get(top + 1 + i);\n\n\t\t    if (curbuf->b_ml.ml_line_len != uep->ue_array[i].ul_len\n\t\t\t    || memcmp(uep->ue_array[i].ul_line, p,\n\t\t\t\t\t\tcurbuf->b_ml.ml_line_len) != 0)\n\t\t\tbreak;\n\t\t}\n\t\tif (i == newsize && newlnum == MAXLNUM && uep->ue_next == NULL)\n\t\t{\n\t\t    newlnum = top;\n\t\t    new_curpos.lnum = newlnum + 1;\n\t\t}\n\t\telse if (i < newsize)\n\t\t{\n\t\t    newlnum = top + i;\n\t\t    new_curpos.lnum = newlnum + 1;\n\t\t}\n\t    }\n\t}\n\n\tempty_buffer = FALSE;\n\n\t/*\n\t * Delete the lines between top and bot and save them in newarray.\n\t */\n\tif (oldsize > 0)\n\t{\n\t    if ((newarray = U_ALLOC_LINE(sizeof(undoline_T) * oldsize)) == NULL)\n\t    {\n\t\tdo_outofmem_msg((long_u)(sizeof(undoline_T) * oldsize));\n\n\t\t// We have messed up the entry list, repair is impossible.\n\t\t// we have to free the rest of the list.\n\t\twhile (uep != NULL)\n\t\t{\n\t\t    nuep = uep->ue_next;\n\t\t    u_freeentry(uep, uep->ue_size);\n\t\t    uep = nuep;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // delete backwards, it goes faster in most cases\n\t    for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum)\n\t    {\n\t\t// what can we do when we run out of memory?\n\t\tif (u_save_line(&newarray[i], lnum) == FAIL)\n\t\t    do_outofmem_msg((long_u)0);\n\t\t// remember we deleted the last line in the buffer, and a\n\t\t// dummy empty line will be inserted\n\t\tif (curbuf->b_ml.ml_line_count == 1)\n\t\t    empty_buffer = TRUE;\n\t\tml_delete_flags(lnum, ML_DEL_UNDO);\n\t    }\n\t}\n\telse\n\t    newarray = NULL;\n\n\t// make sure the cursor is on a valid line after the deletions\n\tcheck_cursor_lnum();\n\n\t/*\n\t * Insert the lines in u_array between top and bot.\n\t */\n\tif (newsize)\n\t{\n\t    for (lnum = top, i = 0; i < newsize; ++i, ++lnum)\n\t    {\n\t\t// If the file is empty, there is an empty line 1 that we\n\t\t// should get rid of, by replacing it with the new line.\n\t\tif (empty_buffer && lnum == 0)\n\t\t    ml_replace_len((linenr_T)1, uep->ue_array[i].ul_line,\n\t\t\t\t\t  uep->ue_array[i].ul_len, TRUE, TRUE);\n\t\telse\n\t\t    ml_append_flags(lnum, uep->ue_array[i].ul_line,\n\t\t\t     (colnr_T)uep->ue_array[i].ul_len, ML_APPEND_UNDO);\n\t\tvim_free(uep->ue_array[i].ul_line);\n\t    }\n\t    vim_free((char_u *)uep->ue_array);\n\t}\n\n\t// adjust marks\n\tif (oldsize != newsize)\n\t{\n\t    mark_adjust(top + 1, top + oldsize, (long)MAXLNUM,\n\t\t\t\t\t       (long)newsize - (long)oldsize);\n\t    if (curbuf->b_op_start.lnum > top + oldsize)\n\t\tcurbuf->b_op_start.lnum += newsize - oldsize;\n\t    if (curbuf->b_op_end.lnum > top + oldsize)\n\t\tcurbuf->b_op_end.lnum += newsize - oldsize;\n\t}\n\n\tchanged_lines(top + 1, 0, bot, newsize - oldsize);\n\n\t// set '[ and '] mark\n\tif (top + 1 < curbuf->b_op_start.lnum)\n\t    curbuf->b_op_start.lnum = top + 1;\n\tif (newsize == 0 && top + 1 > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + 1;\n\telse if (top + newsize > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + newsize;\n\n\tu_newcount += newsize;\n\tu_oldcount += oldsize;\n\tuep->ue_size = oldsize;\n\tuep->ue_array = newarray;\n\tuep->ue_bot = top + newsize + 1;\n\n\t/*\n\t * insert this entry in front of the new entry list\n\t */\n\tnuep = uep->ue_next;\n\tuep->ue_next = newlist;\n\tnewlist = uep;\n    }\n\n    // Set the cursor to the desired position.  Check that the line is valid.\n    curwin->w_cursor = new_curpos;\n    check_cursor_lnum();\n\n    curhead->uh_entry = newlist;\n    curhead->uh_flags = new_flags;\n    if ((old_flags & UH_EMPTYBUF) && BUFEMPTY())\n\tcurbuf->b_ml.ml_flags |= ML_EMPTY;\n    if (old_flags & UH_CHANGED)\n\tchanged();\n    else\n#ifdef FEAT_NETBEANS_INTG\n\t// per netbeans undo rules, keep it as modified\n\tif (!isNetbeansModified(curbuf))\n#endif\n\tunchanged(curbuf, FALSE, TRUE);\n\n    /*\n     * restore marks from before undo/redo\n     */\n    for (i = 0; i < NMARKS; ++i)\n    {\n\tif (curhead->uh_namedm[i].lnum != 0)\n\t    curbuf->b_namedm[i] = curhead->uh_namedm[i];\n\tif (namedm[i].lnum != 0)\n\t    curhead->uh_namedm[i] = namedm[i];\n\telse\n\t    curhead->uh_namedm[i].lnum = 0;\n    }\n    if (curhead->uh_visual.vi_start.lnum != 0)\n    {\n\tcurbuf->b_visual = curhead->uh_visual;\n\tcurhead->uh_visual = visualinfo;\n    }\n\n    /*\n     * If the cursor is only off by one line, put it at the same position as\n     * before starting the change (for the \"o\" command).\n     * Otherwise the cursor should go to the first undone line.\n     */\n    if (curhead->uh_cursor.lnum + 1 == curwin->w_cursor.lnum\n\t\t\t\t\t\t && curwin->w_cursor.lnum > 1)\n\t--curwin->w_cursor.lnum;\n    if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tif (curhead->uh_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = curhead->uh_cursor.col;\n\t    if (virtual_active() && curhead->uh_cursor_vcol >= 0)\n\t\tcoladvance((colnr_T)curhead->uh_cursor_vcol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse\n\t    beginline(BL_SOL | BL_FIX);\n    }\n    else\n    {\n\t// We get here with the current cursor line being past the end (eg\n\t// after adding lines at the end of the file, and then undoing it).\n\t// check_cursor() will move the cursor to the last line.  Move it to\n\t// the first column here.\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    // Make sure the cursor is on an existing line and column.\n    check_cursor();\n\n    // Remember where we are for \"g-\" and \":earlier 10s\".\n    curbuf->b_u_seq_cur = curhead->uh_seq;\n    if (undo)\n    {\n\t// We are below the previous undo.  However, to make \":earlier 1s\"\n\t// work we compute this as being just above the just undone change.\n\tif (curhead->uh_next.ptr != NULL)\n\t    curbuf->b_u_seq_cur = curhead->uh_next.ptr->uh_seq;\n\telse\n\t    curbuf->b_u_seq_cur = 0;\n    }\n\n    // Remember where we are for \":earlier 1f\" and \":later 1f\".\n    if (curhead->uh_save_nr != 0)\n    {\n\tif (undo)\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;\n\telse\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr;\n    }\n\n    // The timestamp can be the same for multiple changes, just use the one of\n    // the undone/redone change.\n    curbuf->b_u_time_cur = curhead->uh_time;\n\n    unblock_autocmds();\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n}\n\n/*\n * If we deleted or added lines, report the number of less/more lines.\n * Otherwise, report the number of changes (this may be incorrect\n * in some cases, but it's better than nothing).\n */\n    static void\nu_undo_end(\n    int\t\tdid_undo,\t// just did an undo\n    int\t\tabsolute)\t// used \":undo N\"\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t// For \":undo N\" we prefer a \"after #N\" message.\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tadd_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n\n    smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}\n\n/*\n * u_sync: stop adding to the current entry list\n */\n    void\nu_sync(\n    int\t    force)\t// Also sync when no_u_sync is set.\n{\n    // Skip it when already synced or syncing is disabled.\n    if (curbuf->b_u_synced || (!force && no_u_sync > 0))\n\treturn;\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT && im_is_preediting())\n\treturn;\t\t    // XIM is busy, don't break an undo sequence\n#endif\n    if (get_undolevel() < 0)\n\tcurbuf->b_u_synced = TRUE;  // no entries, nothing to do\n    else\n    {\n\tu_getbot();\t\t    // compute ue_bot of previous u_save\n\tcurbuf->b_u_curhead = NULL;\n    }\n}\n\n/*\n * \":undolist\": List the leafs of the undo tree\n */\n    void\nex_undolist(exarg_T *eap UNUSED)\n{\n    garray_T\tga;\n    u_header_T\t*uhp;\n    int\t\tmark;\n    int\t\tnomark;\n    int\t\tchanges = 1;\n    int\t\ti;\n\n    /*\n     * 1: walk the tree to find all leafs, put the info in \"ga\".\n     * 2: sort the lines\n     * 3: display the list\n     */\n    mark = ++lastmark;\n    nomark = ++lastmark;\n    ga_init2(&ga, sizeof(char *), 20);\n\n    uhp = curbuf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\tif (uhp->uh_prev.ptr == NULL && uhp->uh_walk != nomark\n\t\t\t\t\t\t      && uhp->uh_walk != mark)\n\t{\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%6ld %7d  \",\n\t\t\t\t\t\t\tuhp->uh_seq, changes);\n\t    add_time(IObuff + STRLEN(IObuff), IOSIZE - STRLEN(IObuff),\n\t\t\t\t\t\t\t\tuhp->uh_time);\n\t    if (uhp->uh_save_nr > 0)\n\t    {\n\t\twhile (STRLEN(IObuff) < 33)\n\t\t    STRCAT(IObuff, \" \");\n\t\tvim_snprintf_add((char *)IObuff, IOSIZE,\n\t\t\t\t\t\t   \"  %3ld\", uhp->uh_save_nr);\n\t    }\n\t    ((char_u **)(ga.ga_data))[ga.ga_len++] = vim_strsave(IObuff);\n\t}\n\n\tuhp->uh_walk = mark;\n\n\t// go down in the tree if we haven't been there\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_prev.ptr;\n\t    ++changes;\n\t}\n\n\t// go to alternate branch if we haven't been there\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\n\t// go up in the tree if we haven't been there and we are at the\n\t// start of alternate branches\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t&& uhp->uh_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_next.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_next.ptr;\n\t    --changes;\n\t}\n\n\telse\n\t{\n\t    // need to backtrack; mark this node as done\n\t    uhp->uh_walk = nomark;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp = uhp->uh_alt_prev.ptr;\n\t    else\n\t    {\n\t\tuhp = uhp->uh_next.ptr;\n\t\t--changes;\n\t    }\n\t}\n    }\n\n    if (ga.ga_len == 0)\n\tmsg(_(\"Nothing to undo\"));\n    else\n    {\n\tsort_strings((char_u **)ga.ga_data, ga.ga_len);\n\n\tmsg_start();\n\tmsg_puts_attr(_(\"number changes  when               saved\"),\n\t\t\t\t\t\t\t      HL_ATTR(HLF_T));\n\tfor (i = 0; i < ga.ga_len && !got_int; ++i)\n\t{\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_puts(((char **)ga.ga_data)[i]);\n\t}\n\tmsg_end();\n\n\tga_clear_strings(&ga);\n    }\n}\n\n/*\n * \":undojoin\": continue adding to the last entry list\n */\n    void\nex_undojoin(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_u_newhead == NULL)\n\treturn;\t\t    // nothing changed before\n    if (curbuf->b_u_curhead != NULL)\n    {\n\temsg(_(e_undojoin_is_not_allowed_after_undo));\n\treturn;\n    }\n    if (!curbuf->b_u_synced)\n\treturn;\t\t    // already unsynced\n    if (get_undolevel() < 0)\n\treturn;\t\t    // no entries, nothing to do\n    else\n\t// Append next change to the last entry\n\tcurbuf->b_u_synced = FALSE;\n}\n\n/*\n * Called after writing or reloading the file and setting b_changed to FALSE.\n * Now an undo means that the buffer is modified.\n */\n    void\nu_unchanged(buf_T *buf)\n{\n    u_unch_branch(buf->b_u_oldhead);\n    buf->b_did_warn = FALSE;\n}\n\n/*\n * After reloading a buffer which was saved for 'undoreload': Find the first\n * line that was changed and set the cursor there.\n */\n    void\nu_find_first_changed(void)\n{\n    u_header_T\t*uhp = curbuf->b_u_newhead;\n    u_entry_T   *uep;\n    linenr_T\tlnum;\n\n    if (curbuf->b_u_curhead != NULL || uhp == NULL)\n\treturn;  // undid something in an autocmd?\n\n    // Check that the last undo block was for the whole file.\n    uep = uhp->uh_entry;\n    if (uep->ue_top != 0 || uep->ue_bot != 0)\n\treturn;\n\n    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count\n\t\t\t\t\t      && lnum <= uep->ue_size; ++lnum)\n    {\n\tchar_u *p = ml_get_buf(curbuf, lnum, FALSE);\n\n\tif (uep->ue_array[lnum - 1].ul_len != curbuf->b_ml.ml_line_len\n\t\t|| memcmp(p, uep->ue_array[lnum - 1].ul_line, uep->ue_array[lnum - 1].ul_len) != 0)\n\t{\n\t    CLEAR_POS(&(uhp->uh_cursor));\n\t    uhp->uh_cursor.lnum = lnum;\n\t    return;\n\t}\n    }\n    if (curbuf->b_ml.ml_line_count != uep->ue_size)\n    {\n\t// lines added or deleted at the end, put the cursor there\n\tCLEAR_POS(&(uhp->uh_cursor));\n\tuhp->uh_cursor.lnum = lnum;\n    }\n}\n\n/*\n * Increase the write count, store it in the last undo header, what would be\n * used for \"u\".\n */\n    void\nu_update_save_nr(buf_T *buf)\n{\n    u_header_T\t*uhp;\n\n    ++buf->b_u_save_nr_last;\n    buf->b_u_save_nr_cur = buf->b_u_save_nr_last;\n    uhp = buf->b_u_curhead;\n    if (uhp != NULL)\n\tuhp = uhp->uh_next.ptr;\n    else\n\tuhp = buf->b_u_newhead;\n    if (uhp != NULL)\n\tuhp->uh_save_nr = buf->b_u_save_nr_last;\n}\n\n    static void\nu_unch_branch(u_header_T *uhp)\n{\n    u_header_T\t*uh;\n\n    for (uh = uhp; uh != NULL; uh = uh->uh_prev.ptr)\n    {\n\tuh->uh_flags |= UH_CHANGED;\n\tif (uh->uh_alt_next.ptr != NULL)\n\t    u_unch_branch(uh->uh_alt_next.ptr);\t    // recursive\n    }\n}\n\n/*\n * Get pointer to last added entry.\n * If it's not valid, give an error message and return NULL.\n */\n    static u_entry_T *\nu_get_headentry(void)\n{\n    if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)\n    {\n\tiemsg(_(e_undo_list_corrupt));\n\treturn NULL;\n    }\n    return curbuf->b_u_newhead->uh_entry;\n}\n\n/*\n * u_getbot(): compute the line number of the previous u_save\n *\t\tIt is called only when b_u_synced is FALSE.\n */\n    static void\nu_getbot(void)\n{\n    u_entry_T\t*uep;\n    linenr_T\textra;\n\n    uep = u_get_headentry();\t// check for corrupt undo list\n    if (uep == NULL)\n\treturn;\n\n    uep = curbuf->b_u_newhead->uh_getbot_entry;\n    if (uep != NULL)\n    {\n\t/*\n\t * the new ue_bot is computed from the number of lines that has been\n\t * inserted (0 - deleted) since calling u_save. This is equal to the\n\t * old line count subtracted from the current line count.\n\t */\n\textra = curbuf->b_ml.ml_line_count - uep->ue_lcount;\n\tuep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;\n\tif (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)\n\t{\n\t    iemsg(_(e_undo_line_missing));\n\t    uep->ue_bot = uep->ue_top + 1;  // assume all lines deleted, will\n\t\t\t\t\t    // get all the old lines back\n\t\t\t\t\t    // without deleting the current\n\t\t\t\t\t    // ones\n\t}\n\n\tcurbuf->b_u_newhead->uh_getbot_entry = NULL;\n    }\n\n    curbuf->b_u_synced = TRUE;\n}\n\n/*\n * Free one header \"uhp\" and its entry list and adjust the pointers.\n */\n    static void\nu_freeheader(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t// if not NULL reset when freeing this header\n{\n    u_header_T\t    *uhap;\n\n    // When there is an alternate redo list free that branch completely,\n    // because we can never go there.\n    if (uhp->uh_alt_next.ptr != NULL)\n\tu_freebranch(buf, uhp->uh_alt_next.ptr, uhpp);\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    // Update the links in the list to remove the header.\n    if (uhp->uh_next.ptr == NULL)\n\tbuf->b_u_oldhead = uhp->uh_prev.ptr;\n    else\n\tuhp->uh_next.ptr->uh_prev.ptr = uhp->uh_prev.ptr;\n\n    if (uhp->uh_prev.ptr == NULL)\n\tbuf->b_u_newhead = uhp->uh_next.ptr;\n    else\n\tfor (uhap = uhp->uh_prev.ptr; uhap != NULL;\n\t\t\t\t\t\t uhap = uhap->uh_alt_next.ptr)\n\t    uhap->uh_next.ptr = uhp->uh_next.ptr;\n\n    u_freeentries(buf, uhp, uhpp);\n}\n\n/*\n * Free an alternate branch and any following alternate branches.\n */\n    static void\nu_freebranch(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t// if not NULL reset when freeing this header\n{\n    u_header_T\t    *tofree, *next;\n\n    // If this is the top branch we may need to use u_freeheader() to update\n    // all the pointers.\n    if (uhp == buf->b_u_oldhead)\n    {\n\twhile (buf->b_u_oldhead != NULL)\n\t    u_freeheader(buf, buf->b_u_oldhead, uhpp);\n\treturn;\n    }\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    next = uhp;\n    while (next != NULL)\n    {\n\ttofree = next;\n\tif (tofree->uh_alt_next.ptr != NULL)\n\t    u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);   // recursive\n\tnext = tofree->uh_prev.ptr;\n\tu_freeentries(buf, tofree, uhpp);\n    }\n}\n\n/*\n * Free all the undo entries for one header and the header itself.\n * This means that \"uhp\" is invalid when returning.\n */\n    static void\nu_freeentries(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t// if not NULL reset when freeing this header\n{\n    u_entry_T\t    *uep, *nuep;\n\n    // Check for pointers to the header that become invalid now.\n    if (buf->b_u_curhead == uhp)\n\tbuf->b_u_curhead = NULL;\n    if (buf->b_u_newhead == uhp)\n\tbuf->b_u_newhead = NULL;  // freeing the newest entry\n    if (uhpp != NULL && uhp == *uhpp)\n\t*uhpp = NULL;\n\n    for (uep = uhp->uh_entry; uep != NULL; uep = nuep)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n    }\n\n#ifdef U_DEBUG\n    uhp->uh_magic = 0;\n#endif\n    vim_free((char_u *)uhp);\n    --buf->b_u_numhead;\n}\n\n/*\n * free entry 'uep' and 'n' lines in uep->ue_array[]\n */\n    static void\nu_freeentry(u_entry_T *uep, long n)\n{\n    while (n > 0)\n\tvim_free(uep->ue_array[--n].ul_line);\n    vim_free((char_u *)uep->ue_array);\n#ifdef U_DEBUG\n    uep->ue_magic = 0;\n#endif\n    vim_free((char_u *)uep);\n}\n\n/*\n * invalidate the undo buffer; called when storage has already been released\n */\n    void\nu_clearall(buf_T *buf)\n{\n    buf->b_u_newhead = buf->b_u_oldhead = buf->b_u_curhead = NULL;\n    buf->b_u_synced = TRUE;\n    buf->b_u_numhead = 0;\n    buf->b_u_line_ptr.ul_line = NULL;\n    buf->b_u_line_ptr.ul_len = 0;\n    buf->b_u_line_lnum = 0;\n}\n\n/*\n * Save the line \"lnum\" for the \"U\" command.\n */\n    static void\nu_saveline(linenr_T lnum)\n{\n    if (lnum == curbuf->b_u_line_lnum)\t    // line is already saved\n\treturn;\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count) // should never happen\n\treturn;\n    u_clearline();\n    curbuf->b_u_line_lnum = lnum;\n    if (curwin->w_cursor.lnum == lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    else\n\tcurbuf->b_u_line_colnr = 0;\n    if (u_save_line(&curbuf->b_u_line_ptr, lnum) == FAIL)\n\tdo_outofmem_msg((long_u)0);\n}\n\n/*\n * clear the line saved for the \"U\" command\n * (this is used externally for crossing a line while in insert mode)\n */\n    void\nu_clearline(void)\n{\n    if (curbuf->b_u_line_ptr.ul_line != NULL)\n    {\n\tVIM_CLEAR(curbuf->b_u_line_ptr.ul_line);\n\tcurbuf->b_u_line_ptr.ul_len = 0;\n\tcurbuf->b_u_line_lnum = 0;\n    }\n}\n\n/*\n * Implementation of the \"U\" command.\n * Differentiation from vi: \"U\" can be undone with the next \"U\".\n * We also allow the cursor to be in another line.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nu_undoline(void)\n{\n    colnr_T\tt;\n    undoline_T  oldp;\n\n    if (undo_off)\n\treturn;\n\n    if (curbuf->b_u_line_ptr.ul_line == NULL\n\t\t\t|| curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // first save the line for the 'u' command\n    if (u_savecommon(curbuf->b_u_line_lnum - 1,\n\t\t       curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)\n\treturn;\n    if (u_save_line(&oldp, curbuf->b_u_line_lnum) == FAIL)\n    {\n\tdo_outofmem_msg((long_u)0);\n\treturn;\n    }\n    ml_replace_len(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr.ul_line,\n\t\t\t\t     curbuf->b_u_line_ptr.ul_len, TRUE, FALSE);\n    changed_bytes(curbuf->b_u_line_lnum, 0);\n    curbuf->b_u_line_ptr = oldp;\n\n    t = curbuf->b_u_line_colnr;\n    if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    curwin->w_cursor.col = t;\n    curwin->w_cursor.lnum = curbuf->b_u_line_lnum;\n    check_cursor_col();\n}\n\n/*\n * Free all allocated memory blocks for the buffer 'buf'.\n */\n    void\nu_blockfree(buf_T *buf)\n{\n    while (buf->b_u_oldhead != NULL)\n\tu_freeheader(buf, buf->b_u_oldhead, NULL);\n    vim_free(buf->b_u_line_ptr.ul_line);\n}\n\n/*\n * Check if the 'modified' flag is set, or 'ff' has changed (only need to\n * check the first character, because it can only be \"dos\", \"unix\" or \"mac\").\n * \"nofile\" and \"scratch\" type buffers are considered to always be unchanged.\n * Also considers a buffer changed when a terminal window contains a running\n * job.\n */\n    int\nbufIsChanged(buf_T *buf)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\treturn TRUE;\n#endif\n    return bufIsChangedNotTerm(buf);\n}\n\n/*\n * Return TRUE if any buffer has changes.  Also buffers that are not written.\n */\n    int\nanyBufIsChanged(void)\n{\n    buf_T *buf;\n\n    FOR_ALL_BUFFERS(buf)\n\tif (bufIsChanged(buf))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Like bufIsChanged() but ignoring a terminal window.\n */\n    int\nbufIsChangedNotTerm(buf_T *buf)\n{\n    // In a \"prompt\" buffer we do respect 'modified', so that we can control\n    // closing the window by setting or resetting that option.\n    return (!bt_dontwrite(buf) || bt_prompt(buf))\n\t&& (buf->b_changed || file_ff_differs(buf, TRUE));\n}\n\n    int\ncurbufIsChanged(void)\n{\n    return bufIsChanged(curbuf);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * For undotree(): Append the list of undo blocks at \"first_uhp\" to \"list\".\n * Recursive.\n */\n    static void\nu_eval_tree(u_header_T *first_uhp, list_T *list)\n{\n    u_header_T  *uhp = first_uhp;\n    dict_T\t*dict;\n\n    while (uhp != NULL)\n    {\n\tdict = dict_alloc();\n\tif (dict == NULL)\n\t    return;\n\tdict_add_number(dict, \"seq\", uhp->uh_seq);\n\tdict_add_number(dict, \"time\", (long)uhp->uh_time);\n\tif (uhp == curbuf->b_u_newhead)\n\t    dict_add_number(dict, \"newhead\", 1);\n\tif (uhp == curbuf->b_u_curhead)\n\t    dict_add_number(dict, \"curhead\", 1);\n\tif (uhp->uh_save_nr > 0)\n\t    dict_add_number(dict, \"save\", uhp->uh_save_nr);\n\n\tif (uhp->uh_alt_next.ptr != NULL)\n\t{\n\t    list_T\t*alt_list = list_alloc();\n\n\t    if (alt_list != NULL)\n\t    {\n\t\t// Recursive call to add alternate undo tree.\n\t\tu_eval_tree(uhp->uh_alt_next.ptr, alt_list);\n\t\tdict_add_list(dict, \"alt\", alt_list);\n\t    }\n\t}\n\n\tlist_append_dict(list, dict);\n\tuhp = uhp->uh_prev.ptr;\n    }\n}\n\n/*\n * \"undofile(name)\" function\n */\n    void\nf_undofile(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n#ifdef FEAT_PERSISTENT_UNDO\n    {\n\tchar_u *fname = tv_get_string(&argvars[0]);\n\n\tif (*fname == NUL)\n\t{\n\t    // If there is no file name there will be no undo file.\n\t    rettv->vval.v_string = NULL;\n\t}\n\telse\n\t{\n\t    char_u *ffname = FullName_save(fname, TRUE);\n\n\t    if (ffname != NULL)\n\t\trettv->vval.v_string = u_get_undo_file_name(ffname, FALSE);\n\t    vim_free(ffname);\n\t}\n    }\n#else\n    rettv->vval.v_string = NULL;\n#endif\n}\n#ifdef FEAT_PERSISTENT_UNDO\n/*\n * Reset undofile option and delete the undofile\n */\n    void\nu_undofile_reset_and_delete(buf_T *buf)\n{\n    char_u *file_name;\n\n    if (!buf->b_p_udf)\n\treturn;\n\n    file_name = u_get_undo_file_name(buf->b_ffname, TRUE);\n    if (file_name != NULL)\n    {\n\tmch_remove(file_name);\n\tvim_free(file_name);\n    }\n\n    set_option_value((char_u *)\"undofile\", 0L, NULL, OPT_LOCAL);\n}\n #endif\n\n/*\n * \"undotree()\" function\n */\n    void\nf_undotree(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    if (rettv_dict_alloc(rettv) == OK)\n    {\n\tdict_T *dict = rettv->vval.v_dict;\n\tlist_T *list;\n\n\tdict_add_number(dict, \"synced\", (long)curbuf->b_u_synced);\n\tdict_add_number(dict, \"seq_last\", curbuf->b_u_seq_last);\n\tdict_add_number(dict, \"save_last\", (long)curbuf->b_u_save_nr_last);\n\tdict_add_number(dict, \"seq_cur\", curbuf->b_u_seq_cur);\n\tdict_add_number(dict, \"time_cur\", (long)curbuf->b_u_time_cur);\n\tdict_add_number(dict, \"save_cur\", (long)curbuf->b_u_save_nr_cur);\n\n\tlist = list_alloc();\n\tif (list != NULL)\n\t{\n\t    u_eval_tree(curbuf->b_u_oldhead, list);\n\t    dict_add_list(dict, \"entries\", list);\n\t}\n    }\n}\n\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\" this was causing an ml_get error\nfunc Test_visual_exchange_windows()\n  enew!\n  new\n  call setline(1, ['foo', 'bar'])\n  exe \"normal G\\<C-V>gg\\<C-W>\\<C-X>OO\\<Esc>\"\n  bwipe!\n  bwipe!\nendfunc\n\n\" this was leaving the end of the Visual area beyond the end of a line\nfunc Test_visual_ex_copy_line()\n  new\n  call setline(1, [\"aaa\", \"bbbbbbbbbxbb\"])\n  /x\n  exe \"normal ggvjfxO\"\n  t0\n  normal gNU\n  bwipe!\nendfunc\n\n\" This was leaving the end of the Visual area beyond the end of a line.\n\" Set 'undolevels' to start a new undo block.\nfunc Test_visual_undo_deletes_last_line()\n  new\n  call setline(1, [\"aaa\", \"ccc\", \"dyd\"])\n  set undolevels=100\n  exe \"normal obbbbbbbbbxbb\\<Esc>\"\n  set undolevels=100\n  /y\n  exe \"normal ggvjfxO\"\n  undo\n  normal gNU\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * undo.c: multi level undo facility\n *\n * The saved lines are stored in a list of lists (one for each buffer):\n *\n * b_u_oldhead------------------------------------------------+\n *\t\t\t\t\t\t\t      |\n *\t\t\t\t\t\t\t      V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n * b_u_newhead--->| u_header\t |    | u_header     |\t  | u_header\t |\n *\t\t  |\tuh_next------>|     uh_next------>|\tuh_next---->NULL\n *\t   NULL<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |\n *\t\t  |\tuh_entry |    |     uh_entry |\t  |\tuh_entry |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n *\t\t  | u_entry\t |    | u_entry      |\t  | u_entry\t |\n *\t\t  |\tue_next  |    |     ue_next  |\t  |\tue_next  |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+\t      NULL\t\t  NULL\n *\t\t  | u_entry\t |\n *\t\t  |\tue_next  |\n *\t\t  +--------|-----+\n *\t\t\t   |\n *\t\t\t   V\n *\t\t\t  etc.\n *\n * Each u_entry list contains the information for one undo or redo.\n * curbuf->b_u_curhead points to the header of the last undo (the next redo),\n * or is NULL if nothing has been undone (end of the branch).\n *\n * For keeping alternate undo/redo branches the uh_alt field is used.  Thus at\n * each point in the list a branch may appear for an alternate to redo.  The\n * uh_seq field is numbered sequentially to be able to find a newer or older\n * branch.\n *\n *\t\t   +---------------+\t+---------------+\n * b_u_oldhead --->| u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next ---->|   uh_alt_next ----> NULL\n *\t   NULL <----- uh_alt_prev |<------ uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t   +---------------+\t+---------------+\n *\t\t   | u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next |\t|   uh_alt_next |\n * b_u_newhead --->|   uh_alt_prev |\t|   uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t       NULL\t\t+---------------+    +---------------+\n *\t\t\t\t\t| u_header\t|    | u_header      |\n *\t\t\t\t\t|   uh_alt_next ---->|\t uh_alt_next |\n *\t\t\t\t\t|   uh_alt_prev |<------ uh_alt_prev |\n *\t\t\t\t\t|   uh_prev\t|    |\t uh_prev     |\n *\t\t\t\t\t+-----|---------+    +-----|---------+\n *\t\t\t\t\t      |\t\t\t   |\n *\t\t\t\t\t     etc.\t\t  etc.\n *\n *\n * All data is allocated and will all be freed when the buffer is unloaded.\n */\n\n// Uncomment the next line for including the u_check() function.  This warns\n// for errors in the debug information.\n// #define U_DEBUG 1\n#define UH_MAGIC 0x18dade\t// value for uh_magic when in use\n#define UE_MAGIC 0xabc123\t// value for ue_magic when in use\n\n// Size of buffer used for encryption.\n#define CRYPT_BUF_SIZE 8192\n\n#include \"vim.h\"\n\n// Structure passed around between functions.\n// Avoids passing cryptstate_T when encryption not available.\ntypedef struct {\n    buf_T\t*bi_buf;\n    FILE\t*bi_fp;\n#ifdef FEAT_CRYPT\n    cryptstate_T *bi_state;\n    char_u\t*bi_buffer; // CRYPT_BUF_SIZE, NULL when not buffering\n    size_t\tbi_used;    // bytes written to/read from bi_buffer\n    size_t\tbi_avail;   // bytes available in bi_buffer\n#endif\n} bufinfo_T;\n\n\nstatic void u_unch_branch(u_header_T *uhp);\nstatic u_entry_T *u_get_headentry(void);\nstatic void u_getbot(void);\nstatic void u_doit(int count);\nstatic void u_undoredo(int undo);\nstatic void u_undo_end(int did_undo, int absolute);\nstatic void u_freeheader(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freebranch(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentries(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentry(u_entry_T *, long);\n#ifdef FEAT_PERSISTENT_UNDO\n# ifdef FEAT_CRYPT\nstatic int undo_flush(bufinfo_T *bi);\n# endif\nstatic int undo_read(bufinfo_T *bi, char_u *buffer, size_t size);\nstatic int serialize_uep(bufinfo_T *bi, u_entry_T *uep);\nstatic u_entry_T *unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name);\nstatic void serialize_pos(bufinfo_T *bi, pos_T pos);\nstatic void unserialize_pos(bufinfo_T *bi, pos_T *pos);\nstatic void serialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\nstatic void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\n#endif\nstatic void u_saveline(linenr_T lnum);\n\n#define U_ALLOC_LINE(size) lalloc(size, FALSE)\n\n// used in undo_end() to report number of added and deleted lines\nstatic long\tu_newcount, u_oldcount;\n\n/*\n * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember\n * the action that \"u\" should do.\n */\nstatic int\tundo_undoes = FALSE;\n\nstatic int\tlastmark = 0;\n\n#if defined(U_DEBUG) || defined(PROTO)\n/*\n * Check the undo structures for being valid.  Print a warning when something\n * looks wrong.\n */\nstatic int seen_b_u_curhead;\nstatic int seen_b_u_newhead;\nstatic int header_count;\n\n    static void\nu_check_tree(u_header_T *uhp,\n\tu_header_T *exp_uh_next,\n\tu_header_T *exp_uh_alt_prev)\n{\n    u_entry_T *uep;\n\n    if (uhp == NULL)\n\treturn;\n    ++header_count;\n    if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)\n    {\n\temsg(\"b_u_curhead found twice (looping?)\");\n\treturn;\n    }\n    if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)\n    {\n\temsg(\"b_u_newhead found twice (looping?)\");\n\treturn;\n    }\n\n    if (uhp->uh_magic != UH_MAGIC)\n\temsg(\"uh_magic wrong (may be using freed memory)\");\n    else\n    {\n\t// Check pointers back are correct.\n\tif (uhp->uh_next.ptr != exp_uh_next)\n\t{\n\t    emsg(\"uh_next wrong\");\n\t    smsg(\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t\t       exp_uh_next, uhp->uh_next.ptr);\n\t}\n\tif (uhp->uh_alt_prev.ptr != exp_uh_alt_prev)\n\t{\n\t    emsg(\"uh_alt_prev wrong\");\n\t    smsg(\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t       exp_uh_alt_prev, uhp->uh_alt_prev.ptr);\n\t}\n\n\t// Check the undo tree at this header.\n\tfor (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n\t{\n\t    if (uep->ue_magic != UE_MAGIC)\n\t    {\n\t\temsg(\"ue_magic wrong (may be using freed memory)\");\n\t\tbreak;\n\t    }\n\t}\n\n\t// Check the next alt tree.\n\tu_check_tree(uhp->uh_alt_next.ptr, uhp->uh_next.ptr, uhp);\n\n\t// Check the next header in this branch.\n\tu_check_tree(uhp->uh_prev.ptr, uhp, NULL);\n    }\n}\n\n    static void\nu_check(int newhead_may_be_NULL)\n{\n    seen_b_u_newhead = 0;\n    seen_b_u_curhead = 0;\n    header_count = 0;\n\n    u_check_tree(curbuf->b_u_oldhead, NULL, NULL);\n\n    if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL\n\t    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))\n\tsemsg(\"b_u_newhead invalid: 0x%x\", curbuf->b_u_newhead);\n    if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)\n\tsemsg(\"b_u_curhead invalid: 0x%x\", curbuf->b_u_curhead);\n    if (header_count != curbuf->b_u_numhead)\n    {\n\temsg(\"b_u_numhead invalid\");\n\tsmsg(\"expected: %ld, actual: %ld\",\n\t\t\t       (long)header_count, (long)curbuf->b_u_numhead);\n    }\n}\n#endif\n\n/*\n * Save the current line for both the \"u\" and \"U\" command.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns OK or FAIL.\n */\n    int\nu_save_cursor(void)\n{\n    return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t\t      (linenr_T)(curwin->w_cursor.lnum + 1)));\n}\n\n/*\n * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command.\n * \"top\" may be 0 and \"bot\" may be curbuf->b_ml.ml_line_count + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_save(linenr_T top, linenr_T bot)\n{\n    if (undo_off)\n\treturn OK;\n\n    if (top >= bot || bot > curbuf->b_ml.ml_line_count + 1)\n\treturn FAIL;\t// rely on caller to give an error message\n\n    if (top + 2 == bot)\n\tu_saveline((linenr_T)(top + 1));\n\n    return (u_savecommon(top, bot, (linenr_T)0, FALSE));\n}\n\n/*\n * Save the line \"lnum\" (used by \":s\" and \"~\" command).\n * The line is replaced, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savesub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + 1, lnum + 1, FALSE));\n}\n\n/*\n * A new line is inserted before line \"lnum\" (used by :s command).\n * The line is inserted, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_inssub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum, lnum + 1, FALSE));\n}\n\n/*\n * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command).\n * The lines are deleted, so the new bottom line is lnum, unless the buffer\n * becomes empty.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savedel(linenr_T lnum, long nlines)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + nlines,\n\t\t     nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE));\n}\n\n/*\n * Return TRUE when undo is allowed.  Otherwise give an error message and\n * return FALSE.\n */\n    int\nundo_allowed(void)\n{\n    // Don't allow changes when 'modifiable' is off.\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FALSE;\n    }\n\n#ifdef HAVE_SANDBOX\n    // In the sandbox it's not allowed to change the text.\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn FALSE;\n    }\n#endif\n\n    // Don't allow changes in the buffer while editing the cmdline.  The\n    // caller of getcmdline() may get confused.\n    if (textwinlock != 0 || textlock != 0)\n    {\n\temsg(_(e_not_allowed_to_change_text_here));\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Get the undolevel value for the current buffer.\n */\n    static long\nget_undolevel(void)\n{\n    if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)\n\treturn p_ul;\n    return curbuf->b_p_ul;\n}\n\n/*\n * u_save_line(): save an allocated copy of line \"lnum\" into \"ul\".\n * Returns FAIL when out of memory.\n */\n    static int\nu_save_line(undoline_T *ul, linenr_T lnum)\n{\n    char_u *line = ml_get(lnum);\n\n    if (curbuf->b_ml.ml_line_len == 0)\n    {\n\tul->ul_len = 1;\n\tul->ul_line = vim_strsave((char_u *)\"\");\n    }\n    else\n    {\n\t// This uses the length in the memline, thus text properties are\n\t// included.\n\tul->ul_len = curbuf->b_ml.ml_line_len;\n\tul->ul_line = vim_memsave(line, ul->ul_len);\n    }\n    return ul->ul_line == NULL ? FAIL : OK;\n}\n\n#ifdef FEAT_PROP_POPUP\n/*\n * return TRUE if line \"lnum\" has text property \"flags\".\n */\n    static int\nhas_prop_w_flags(linenr_T lnum, int flags)\n{\n    char_u  *props;\n    int\t    i;\n    int\t    proplen = get_text_props(curbuf, lnum, &props, FALSE);\n\n    for (i = 0; i < proplen; ++i)\n    {\n\ttextprop_T prop;\n\n\tmch_memmove(&prop, props + i * sizeof prop, sizeof prop);\n\tif (prop.tp_flags & flags)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Common code for various ways to save text before a change.\n * \"top\" is the line above the first changed line.\n * \"bot\" is the line below the last changed line.\n * \"newbot\" is the new bottom line.  Use zero when not known.\n * \"reload\" is TRUE when saving for a buffer reload.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savecommon(\n    linenr_T\ttop,\n    linenr_T\tbot,\n    linenr_T\tnewbot,\n    int\t\treload)\n{\n    linenr_T\tlnum;\n    long\ti;\n    u_header_T\t*uhp;\n    u_header_T\t*old_curhead;\n    u_entry_T\t*uep;\n    u_entry_T\t*prev_uep;\n    long\tsize;\n\n    if (!reload)\n    {\n\t// When making changes is not allowed return FAIL.  It's a crude way\n\t// to make all change commands fail.\n\tif (!undo_allowed())\n\t    return FAIL;\n\n#ifdef FEAT_NETBEANS_INTG\n\t/*\n\t * Netbeans defines areas that cannot be modified.  Bail out here when\n\t * trying to change text in a guarded area.\n\t */\n\tif (netbeans_active())\n\t{\n\t    if (netbeans_is_guarded(top, bot))\n\t    {\n\t\temsg(_(e_region_is_guarded_cannot_modify));\n\t\treturn FAIL;\n\t    }\n\t    if (curbuf->b_p_ro)\n\t    {\n\t\temsg(_(e_netbeans_does_not_allow_changes_in_read_only_files));\n\t\treturn FAIL;\n\t    }\n\t}\n#endif\n#ifdef FEAT_TERMINAL\n\t// A change in a terminal buffer removes the highlighting.\n\tterm_change_in_curbuf();\n#endif\n\n\t/*\n\t * Saving text for undo means we are going to make a change.  Give a\n\t * warning for a read-only file before making the change, so that the\n\t * FileChangedRO event can replace the buffer with a read-write version\n\t * (e.g., obtained from a source control system).\n\t */\n\tchange_warning(0);\n\tif (bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n\t    // This happens when the FileChangedRO autocommand changes the\n\t    // file in a way it becomes shorter.\n\t    emsg(_(e_line_count_changed_unexpectedly));\n\t    return FAIL;\n\t}\n    }\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // Include the line above if a text property continues from it.\n    // Include the line below if a text property continues to it.\n    if (bot - top > 1)\n    {\n\tif (top > 0 && has_prop_w_flags(top + 1, TP_FLAG_CONT_PREV))\n\t    --top;\n\tif (bot <= curbuf->b_ml.ml_line_count\n\t\t\t       && has_prop_w_flags(bot - 1, TP_FLAG_CONT_NEXT))\n\t{\n\t    ++bot;\n\t    if (newbot != 0)\n\t\t++newbot;\n\t}\n    }\n#endif\n\n    size = bot - top - 1;\n\n    /*\n     * If curbuf->b_u_synced == TRUE make a new header.\n     */\n    if (curbuf->b_u_synced)\n    {\n\t// Need to create new entry in b_changelist.\n\tcurbuf->b_new_change = TRUE;\n\n\tif (get_undolevel() >= 0)\n\t{\n\t    /*\n\t     * Make a new header entry.  Do this first so that we don't mess\n\t     * up the undo info when out of memory.\n\t     */\n\t    uhp = U_ALLOC_LINE(sizeof(u_header_T));\n\t    if (uhp == NULL)\n\t\tgoto nomem;\n#ifdef U_DEBUG\n\t    uhp->uh_magic = UH_MAGIC;\n#endif\n\t}\n\telse\n\t    uhp = NULL;\n\n\t/*\n\t * If we undid more than we redid, move the entry lists before and\n\t * including curbuf->b_u_curhead to an alternate branch.\n\t */\n\told_curhead = curbuf->b_u_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    curbuf->b_u_newhead = old_curhead->uh_next.ptr;\n\t    curbuf->b_u_curhead = NULL;\n\t}\n\n\t/*\n\t * free headers to keep the size right\n\t */\n\twhile (curbuf->b_u_numhead > get_undolevel()\n\t\t\t\t\t       && curbuf->b_u_oldhead != NULL)\n\t{\n\t    u_header_T\t    *uhfree = curbuf->b_u_oldhead;\n\n\t    if (uhfree == old_curhead)\n\t\t// Can't reconnect the branch, delete all of it.\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    else if (uhfree->uh_alt_next.ptr == NULL)\n\t\t// There is no branch, only free one header.\n\t\tu_freeheader(curbuf, uhfree, &old_curhead);\n\t    else\n\t    {\n\t\t// Free the oldest alternate branch as a whole.\n\t\twhile (uhfree->uh_alt_next.ptr != NULL)\n\t\t    uhfree = uhfree->uh_alt_next.ptr;\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    }\n#ifdef U_DEBUG\n\t    u_check(TRUE);\n#endif\n\t}\n\n\tif (uhp == NULL)\t\t// no undo at all\n\t{\n\t    if (old_curhead != NULL)\n\t\tu_freebranch(curbuf, old_curhead, NULL);\n\t    curbuf->b_u_synced = FALSE;\n\t    return OK;\n\t}\n\n\tuhp->uh_prev.ptr = NULL;\n\tuhp->uh_next.ptr = curbuf->b_u_newhead;\n\tuhp->uh_alt_next.ptr = old_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    uhp->uh_alt_prev.ptr = old_curhead->uh_alt_prev.ptr;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = uhp;\n\t    old_curhead->uh_alt_prev.ptr = uhp;\n\t    if (curbuf->b_u_oldhead == old_curhead)\n\t\tcurbuf->b_u_oldhead = uhp;\n\t}\n\telse\n\t    uhp->uh_alt_prev.ptr = NULL;\n\tif (curbuf->b_u_newhead != NULL)\n\t    curbuf->b_u_newhead->uh_prev.ptr = uhp;\n\n\tuhp->uh_seq = ++curbuf->b_u_seq_last;\n\tcurbuf->b_u_seq_cur = uhp->uh_seq;\n\tuhp->uh_time = vim_time();\n\tuhp->uh_save_nr = 0;\n\tcurbuf->b_u_time_cur = uhp->uh_time + 1;\n\n\tuhp->uh_walk = 0;\n\tuhp->uh_entry = NULL;\n\tuhp->uh_getbot_entry = NULL;\n\tuhp->uh_cursor = curwin->w_cursor;\t// save cursor pos. for undo\n\tif (virtual_active() && curwin->w_cursor.coladd > 0)\n\t    uhp->uh_cursor_vcol = getviscol();\n\telse\n\t    uhp->uh_cursor_vcol = -1;\n\n\t// save changed and buffer empty flag for undo\n\tuhp->uh_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n\n\t// save named marks and Visual marks for undo\n\tmch_memmove(uhp->uh_namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n\tuhp->uh_visual = curbuf->b_visual;\n\n\tcurbuf->b_u_newhead = uhp;\n\tif (curbuf->b_u_oldhead == NULL)\n\t    curbuf->b_u_oldhead = uhp;\n\t++curbuf->b_u_numhead;\n    }\n    else\n    {\n\tif (get_undolevel() < 0)\t// no undo at all\n\t    return OK;\n\n\t/*\n\t * When saving a single line, and it has been saved just before, it\n\t * doesn't make sense saving it again.  Saves a lot of memory when\n\t * making lots of changes inside the same line.\n\t * This is only possible if the previous change didn't increase or\n\t * decrease the number of lines.\n\t * Check the ten last changes.  More doesn't make sense and takes too\n\t * long.\n\t */\n\tif (size == 1)\n\t{\n\t    uep = u_get_headentry();\n\t    prev_uep = NULL;\n\t    for (i = 0; i < 10; ++i)\n\t    {\n\t\tif (uep == NULL)\n\t\t    break;\n\n\t\t// If lines have been inserted/deleted we give up.\n\t\t// Also when the line was included in a multi-line save.\n\t\tif ((curbuf->b_u_newhead->uh_getbot_entry != uep\n\t\t\t    ? (uep->ue_top + uep->ue_size + 1\n\t\t\t\t!= (uep->ue_bot == 0\n\t\t\t\t    ? curbuf->b_ml.ml_line_count + 1\n\t\t\t\t    : uep->ue_bot))\n\t\t\t    : uep->ue_lcount != curbuf->b_ml.ml_line_count)\n\t\t\t|| (uep->ue_size > 1\n\t\t\t    && top >= uep->ue_top\n\t\t\t    && top + 2 <= uep->ue_top + uep->ue_size + 1))\n\t\t    break;\n\n\t\t// If it's the same line we can skip saving it again.\n\t\tif (uep->ue_size == 1 && uep->ue_top == top)\n\t\t{\n\t\t    if (i > 0)\n\t\t    {\n\t\t\t// It's not the last entry: get ue_bot for the last\n\t\t\t// entry now.  Following deleted/inserted lines go to\n\t\t\t// the re-used entry.\n\t\t\tu_getbot();\n\t\t\tcurbuf->b_u_synced = FALSE;\n\n\t\t\t// Move the found entry to become the last entry.  The\n\t\t\t// order of undo/redo doesn't matter for the entries\n\t\t\t// we move it over, since they don't change the line\n\t\t\t// count and don't include this line.  It does matter\n\t\t\t// for the found entry if the line count is changed by\n\t\t\t// the executed command.\n\t\t\tprev_uep->ue_next = uep->ue_next;\n\t\t\tuep->ue_next = curbuf->b_u_newhead->uh_entry;\n\t\t\tcurbuf->b_u_newhead->uh_entry = uep;\n\t\t    }\n\n\t\t    // The executed command may change the line count.\n\t\t    if (newbot != 0)\n\t\t\tuep->ue_bot = newbot;\n\t\t    else if (bot > curbuf->b_ml.ml_line_count)\n\t\t\tuep->ue_bot = 0;\n\t\t    else\n\t\t    {\n\t\t\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\t\t\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n\t\t    }\n\t\t    return OK;\n\t\t}\n\t\tprev_uep = uep;\n\t\tuep = uep->ue_next;\n\t    }\n\t}\n\n\t// find line number for ue_bot for previous u_save()\n\tu_getbot();\n    }\n\n#if !defined(UNIX) && !defined(MSWIN)\n\t/*\n\t * With Amiga we can't handle big undo's, because\n\t * then u_alloc_line would have to allocate a block larger than 32K\n\t */\n    if (size >= 8000)\n\tgoto nomem;\n#endif\n\n    /*\n     * add lines in front of entry list\n     */\n    uep = U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\tgoto nomem;\n    CLEAR_POINTER(uep);\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n\n    uep->ue_size = size;\n    uep->ue_top = top;\n    if (newbot != 0)\n\tuep->ue_bot = newbot;\n    /*\n     * Use 0 for ue_bot if bot is below last line.\n     * Otherwise we have to compute ue_bot later.\n     */\n    else if (bot > curbuf->b_ml.ml_line_count)\n\tuep->ue_bot = 0;\n    else\n    {\n\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n    }\n\n    if (size > 0)\n    {\n\tif ((uep->ue_array = U_ALLOC_LINE(sizeof(undoline_T) * size)) == NULL)\n\t{\n\t    u_freeentry(uep, 0L);\n\t    goto nomem;\n\t}\n\tfor (i = 0, lnum = top + 1; i < size; ++i)\n\t{\n\t    fast_breakcheck();\n\t    if (got_int)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\treturn FAIL;\n\t    }\n\t    if (u_save_line(&uep->ue_array[i], lnum++) == FAIL)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\tgoto nomem;\n\t    }\n\t}\n    }\n    else\n\tuep->ue_array = NULL;\n    uep->ue_next = curbuf->b_u_newhead->uh_entry;\n    curbuf->b_u_newhead->uh_entry = uep;\n    curbuf->b_u_synced = FALSE;\n    undo_undoes = FALSE;\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    return OK;\n\nnomem:\n    msg_silent = 0;\t// must display the prompt\n    if (ask_yesno((char_u *)_(\"No undo possible; continue anyway\"), TRUE)\n\t\t\t\t\t\t\t\t       == 'y')\n    {\n\tundo_off = TRUE;\t    // will be reset when character typed\n\treturn OK;\n    }\n    do_outofmem_msg((long_u)0);\n    return FAIL;\n}\n\n#if defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)\n\n# define UF_START_MAGIC\t    \"Vim\\237UnDo\\345\"  // magic at start of undofile\n# define UF_START_MAGIC_LEN\t9\n# define UF_HEADER_MAGIC\t0x5fd0\t// magic at start of header\n# define UF_HEADER_END_MAGIC\t0xe7aa\t// magic after last header\n# define UF_ENTRY_MAGIC\t\t0xf518\t// magic at start of entry\n# define UF_ENTRY_END_MAGIC\t0x3581\t// magic after last entry\n# define UF_VERSION\t\t2\t// 2-byte undofile version number\n# define UF_VERSION_CRYPT\t0x8002\t// idem, encrypted\n\n// extra fields for header\n# define UF_LAST_SAVE_NR\t1\n\n// extra fields for uhp\n# define UHP_SAVE_NR\t\t1\n\n/*\n * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE].\n */\n    void\nu_compute_hash(char_u *hash)\n{\n    context_sha256_T\tctx;\n    linenr_T\t\tlnum;\n    char_u\t\t*p;\n\n    sha256_start(&ctx);\n    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n    {\n\tp = ml_get(lnum);\n\tsha256_update(&ctx, p, (UINT32_T)(STRLEN(p) + 1));\n    }\n    sha256_finish(&ctx, hash);\n}\n\n/*\n * Return an allocated string of the full path of the target undofile.\n * When \"reading\" is TRUE find the file to read, go over all directories in\n * 'undodir'.\n * When \"reading\" is FALSE use the first name where the directory exists.\n * Returns NULL when there is no place to write or no file to read.\n */\n    static char_u *\nu_get_undo_file_name(char_u *buf_ffname, int reading)\n{\n    char_u\t*dirp;\n    char_u\tdir_name[IOSIZE + 1];\n    char_u\t*munged_name = NULL;\n    char_u\t*undo_file_name = NULL;\n    int\t\tdir_len;\n    char_u\t*p;\n    stat_T\tst;\n    char_u\t*ffname = buf_ffname;\n#ifdef HAVE_READLINK\n    char_u\tfname_buf[MAXPATHL];\n#endif\n\n    if (ffname == NULL)\n\treturn NULL;\n\n#ifdef HAVE_READLINK\n    // Expand symlink in the file name, so that we put the undo file with the\n    // actual file instead of with the symlink.\n    if (resolve_symlink(ffname, fname_buf) == OK)\n\tffname = fname_buf;\n#endif\n\n    // Loop over 'undodir'.  When reading find the first file that exists.\n    // When not reading use the first directory that exists or \".\".\n    dirp = p_udir;\n    while (*dirp != NUL)\n    {\n\tdir_len = copy_option_part(&dirp, dir_name, IOSIZE, \",\");\n\tif (dir_len == 1 && dir_name[0] == '.')\n\t{\n\t    // Use same directory as the ffname,\n\t    // \"dir/name\" -> \"dir/.name.un~\"\n\t    undo_file_name = vim_strnsave(ffname, STRLEN(ffname) + 5);\n\t    if (undo_file_name == NULL)\n\t\tbreak;\n\t    p = gettail(undo_file_name);\n#ifdef VMS\n\t    // VMS can not handle more than one dot in the filenames\n\t    // use \"dir/name\" -> \"dir/_un_name\" - add _un_\n\t    // at the beginning to keep the extension\n\t    mch_memmove(p + 4,  p, STRLEN(p) + 1);\n\t    mch_memmove(p, \"_un_\", 4);\n\n#else\n\t    // Use same directory as the ffname,\n\t    // \"dir/name\" -> \"dir/.name.un~\"\n\t    mch_memmove(p + 1, p, STRLEN(p) + 1);\n\t    *p = '.';\n\t    STRCAT(p, \".un~\");\n#endif\n\t}\n\telse\n\t{\n\t    dir_name[dir_len] = NUL;\n\t    if (mch_isdir(dir_name))\n\t    {\n\t\tif (munged_name == NULL)\n\t\t{\n\t\t    munged_name = vim_strsave(ffname);\n\t\t    if (munged_name == NULL)\n\t\t\treturn NULL;\n\t\t    for (p = munged_name; *p != NUL; MB_PTR_ADV(p))\n\t\t\tif (vim_ispathsep(*p))\n\t\t\t    *p = '%';\n\t\t}\n\t\tundo_file_name = concat_fnames(dir_name, munged_name, TRUE);\n\t    }\n\t}\n\n\t// When reading check if the file exists.\n\tif (undo_file_name != NULL && (!reading\n\t\t\t       || mch_stat((char *)undo_file_name, &st) >= 0))\n\t    break;\n\tVIM_CLEAR(undo_file_name);\n    }\n\n    vim_free(munged_name);\n    return undo_file_name;\n}\n\n    static void\ncorruption_error(char *mesg, char_u *file_name)\n{\n    semsg(_(e_corrupted_undo_file_str_str), mesg, file_name);\n}\n\n    static void\nu_free_uhp(u_header_T *uhp)\n{\n    u_entry_T\t*nuep;\n    u_entry_T\t*uep;\n\n    uep = uhp->uh_entry;\n    while (uep != NULL)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n\tuep = nuep;\n    }\n    vim_free(uhp);\n}\n\n/*\n * Write a sequence of bytes to the undo file.\n * Buffers and encrypts as needed.\n * Returns OK or FAIL.\n */\n    static int\nundo_write(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tsize_t\tlen_todo = len;\n\tchar_u  *p = ptr;\n\n\twhile (bi->bi_used + len_todo >= CRYPT_BUF_SIZE)\n\t{\n\t    size_t\tn = CRYPT_BUF_SIZE - bi->bi_used;\n\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, n);\n\t    len_todo -= n;\n\t    p += n;\n\t    bi->bi_used = CRYPT_BUF_SIZE;\n\t    if (undo_flush(bi) == FAIL)\n\t\treturn FAIL;\n\t}\n\tif (len_todo > 0)\n\t{\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, len_todo);\n\t    bi->bi_used += len_todo;\n\t}\n\treturn OK;\n    }\n#endif\n    if (fwrite(ptr, len, (size_t)1, bi->bi_fp) != 1)\n\treturn FAIL;\n    return OK;\n}\n\n#ifdef FEAT_CRYPT\n    static int\nundo_flush(bufinfo_T *bi)\n{\n    if (bi->bi_buffer != NULL && bi->bi_state != NULL && bi->bi_used > 0)\n    {\n\t// Last parameter is only used for sodium encryption and that\n\t// explicitly disables encryption of undofiles.\n\tcrypt_encode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_used, FALSE);\n\tif (fwrite(bi->bi_buffer, bi->bi_used, (size_t)1, bi->bi_fp) != 1)\n\t    return FAIL;\n\tbi->bi_used = 0;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write \"ptr[len]\" and crypt the bytes when needed.\n * Returns OK or FAIL.\n */\n    static int\nfwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    char_u  *copy;\n    char_u  small_buf[100];\n    size_t  i;\n\n    if (bi->bi_state != NULL && bi->bi_buffer == NULL)\n    {\n\t// crypting every piece of text separately\n\tif (len < 100)\n\t    copy = small_buf;  // no malloc()/free() for short strings\n\telse\n\t{\n\t    copy = lalloc(len, FALSE);\n\t    if (copy == NULL)\n\t\treturn 0;\n\t}\n\t// Last parameter is only used for sodium encryption and that\n\t// explicitly disables encryption of undofiles.\n\tcrypt_encode(bi->bi_state, ptr, len, copy, TRUE);\n\ti = fwrite(copy, len, (size_t)1, bi->bi_fp);\n\tif (copy != small_buf)\n\t    vim_free(copy);\n\treturn i == 1 ? OK : FAIL;\n    }\n#endif\n    return undo_write(bi, ptr, len);\n}\n\n/*\n * Write a number, MSB first, in \"len\" bytes.\n * Must match with undo_read_?c() functions.\n * Returns OK or FAIL.\n */\n    static int\nundo_write_bytes(bufinfo_T *bi, long_u nr, int len)\n{\n    char_u  buf[8];\n    int\t    i;\n    int\t    bufi = 0;\n\n    for (i = len - 1; i >= 0; --i)\n\tbuf[bufi++] = (char_u)(nr >> (i * 8));\n    return undo_write(bi, buf, (size_t)len);\n}\n\n/*\n * Write the pointer to an undo header.  Instead of writing the pointer itself\n * we use the sequence number of the header.  This is converted back to\n * pointers when reading. */\n    static void\nput_header_ptr(bufinfo_T *bi, u_header_T *uhp)\n{\n    undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);\n}\n\n    static int\nundo_read_4c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[4];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)4);\n\tn = ((unsigned)buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];\n\treturn n;\n    }\n#endif\n    return get4c(bi->bi_fp);\n}\n\n    static int\nundo_read_2c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[2];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)2);\n\tn = (buf[0] << 8) + buf[1];\n\treturn n;\n    }\n#endif\n    return get2c(bi->bi_fp);\n}\n\n    static int\nundo_read_byte(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[1];\n\n\tundo_read(bi, buf, (size_t)1);\n\treturn buf[0];\n    }\n#endif\n    return getc(bi->bi_fp);\n}\n\n    static time_t\nundo_read_time(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[8];\n\ttime_t\tn = 0;\n\tint\ti;\n\n\tundo_read(bi, buf, (size_t)8);\n\tfor (i = 0; i < 8; ++i)\n\t    n = (n << 8) + buf[i];\n\treturn n;\n    }\n#endif\n    return get8ctime(bi->bi_fp);\n}\n\n/*\n * Read \"buffer[size]\" from the undo file.\n * Return OK or FAIL.\n */\n    static int\nundo_read(bufinfo_T *bi, char_u *buffer, size_t size)\n{\n    int retval = OK;\n\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tint\tsize_todo = (int)size;\n\tchar_u\t*p = buffer;\n\n\twhile (size_todo > 0)\n\t{\n\t    size_t n;\n\n\t    if (bi->bi_used >= bi->bi_avail)\n\t    {\n\t\tn = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);\n\t\tif (n == 0)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tbi->bi_avail = n;\n\t\tbi->bi_used = 0;\n\t\tcrypt_decode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_avail, FALSE);\n\t    }\n\t    n = size_todo;\n\t    if (n > bi->bi_avail - bi->bi_used)\n\t\tn = bi->bi_avail - bi->bi_used;\n\t    mch_memmove(p, bi->bi_buffer + bi->bi_used, n);\n\t    bi->bi_used += n;\n\t    size_todo -= (int)n;\n\t    p += n;\n\t}\n    }\n    else\n#endif\n    if (fread(buffer, (size_t)size, 1, bi->bi_fp) != 1)\n\tretval = FAIL;\n\n    if (retval == FAIL)\n\t// Error may be checked for only later.  Fill with zeros,\n\t// so that the reader won't use garbage.\n\tvim_memset(buffer, 0, size);\n    return retval;\n}\n\n/*\n * Read a string of length \"len\" from \"bi->bi_fd\".\n * \"len\" can be zero to allocate an empty line.\n * Decrypt the bytes if needed.\n * Append a NUL.\n * Returns a pointer to allocated memory or NULL for failure.\n */\n    static char_u *\nread_string_decrypt(bufinfo_T *bi, int len)\n{\n    char_u  *ptr = alloc(len + 1);\n\n    if (ptr != NULL)\n    {\n\tif (len > 0 && undo_read(bi, ptr, len) == FAIL)\n\t{\n\t    vim_free(ptr);\n\t    return NULL;\n\t}\n\t// In case there are text properties there already is a NUL, but\n\t// checking for that is more expensive than just adding a dummy byte.\n\tptr[len] = NUL;\n#ifdef FEAT_CRYPT\n\tif (bi->bi_state != NULL && bi->bi_buffer == NULL)\n\t    crypt_decode_inplace(bi->bi_state, ptr, len, FALSE);\n#endif\n    }\n    return ptr;\n}\n\n/*\n * Writes the (not encrypted) header and initializes encryption if needed.\n */\n    static int\nserialize_header(bufinfo_T *bi, char_u *hash)\n{\n    long\tlen;\n    buf_T\t*buf = bi->bi_buf;\n    FILE\t*fp = bi->bi_fp;\n    char_u\ttime_buf[8];\n\n    // Start writing, first the magic marker and undo info version.\n    if (fwrite(UF_START_MAGIC, (size_t)UF_START_MAGIC_LEN, (size_t)1, fp) != 1)\n\treturn FAIL;\n\n    // If the buffer is encrypted then all text bytes following will be\n    // encrypted.  Numbers and other info is not crypted.\n#ifdef FEAT_CRYPT\n    if (*buf->b_p_key != NUL)\n    {\n\tchar_u *header;\n\tint    header_len;\n\n\tundo_write_bytes(bi, (long_u)UF_VERSION_CRYPT, 2);\n\tbi->bi_state = crypt_create_for_writing(crypt_get_method_nr(buf),\n\t\t\t\t\t  buf->b_p_key, &header, &header_len);\n\tif (bi->bi_state == NULL)\n\t    return FAIL;\n\tlen = (long)fwrite(header, (size_t)header_len, (size_t)1, fp);\n\tvim_free(header);\n\tif (len != 1)\n\t{\n\t    crypt_free_state(bi->bi_state);\n\t    bi->bi_state = NULL;\n\t    return FAIL;\n\t}\n\n\tif (crypt_whole_undofile(crypt_get_method_nr(buf)))\n\t{\n\t    bi->bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi->bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi->bi_state);\n\t\tbi->bi_state = NULL;\n\t\treturn FAIL;\n\t    }\n\t    bi->bi_used = 0;\n\t}\n    }\n    else\n#endif\n\tundo_write_bytes(bi, (long_u)UF_VERSION, 2);\n\n\n    // Write a hash of the buffer text, so that we can verify it is still the\n    // same when reading the buffer text.\n    if (undo_write(bi, hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n\treturn FAIL;\n\n    // buffer-specific data\n    undo_write_bytes(bi, (long_u)buf->b_ml.ml_line_count, 4);\n    len = buf->b_u_line_ptr.ul_line == NULL\n\t\t\t\t? 0L : (long)STRLEN(buf->b_u_line_ptr.ul_line);\n    undo_write_bytes(bi, (long_u)len, 4);\n    if (len > 0 && fwrite_crypt(bi, buf->b_u_line_ptr.ul_line, (size_t)len)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n    undo_write_bytes(bi, (long_u)buf->b_u_line_lnum, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_line_colnr, 4);\n\n    // Undo structures header data\n    put_header_ptr(bi, buf->b_u_oldhead);\n    put_header_ptr(bi, buf->b_u_newhead);\n    put_header_ptr(bi, buf->b_u_curhead);\n\n    undo_write_bytes(bi, (long_u)buf->b_u_numhead, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_last, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_cur, 4);\n    time_to_bytes(buf->b_u_time_cur, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    // Optional fields.\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UF_LAST_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)buf->b_u_save_nr_last, 4);\n\n    undo_write_bytes(bi, 0, 1);  // end marker\n\n    return OK;\n}\n\n    static int\nserialize_uhp(bufinfo_T *bi, u_header_T *uhp)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\ttime_buf[8];\n\n    if (undo_write_bytes(bi, (long_u)UF_HEADER_MAGIC, 2) == FAIL)\n\treturn FAIL;\n\n    put_header_ptr(bi, uhp->uh_next.ptr);\n    put_header_ptr(bi, uhp->uh_prev.ptr);\n    put_header_ptr(bi, uhp->uh_alt_next.ptr);\n    put_header_ptr(bi, uhp->uh_alt_prev.ptr);\n    undo_write_bytes(bi, uhp->uh_seq, 4);\n    serialize_pos(bi, uhp->uh_cursor);\n    undo_write_bytes(bi, (long_u)uhp->uh_cursor_vcol, 4);\n    undo_write_bytes(bi, (long_u)uhp->uh_flags, 2);\n    // Assume NMARKS will stay the same.\n    for (i = 0; i < NMARKS; ++i)\n\tserialize_pos(bi, uhp->uh_namedm[i]);\n    serialize_visualinfo(bi, &uhp->uh_visual);\n    time_to_bytes(uhp->uh_time, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    // Optional fields.\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UHP_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)uhp->uh_save_nr, 4);\n\n    undo_write_bytes(bi, 0, 1);  // end marker\n\n    // Write all the entries.\n    for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n    {\n\tundo_write_bytes(bi, (long_u)UF_ENTRY_MAGIC, 2);\n\tif (serialize_uep(bi, uep) == FAIL)\n\t    return FAIL;\n    }\n    undo_write_bytes(bi, (long_u)UF_ENTRY_END_MAGIC, 2);\n    return OK;\n}\n\n    static u_header_T *\nunserialize_uhp(bufinfo_T *bi, char_u *file_name)\n{\n    u_header_T\t*uhp;\n    int\t\ti;\n    u_entry_T\t*uep, *last_uep;\n    int\t\tc;\n    int\t\terror;\n\n    uhp = U_ALLOC_LINE(sizeof(u_header_T));\n    if (uhp == NULL)\n\treturn NULL;\n    CLEAR_POINTER(uhp);\n#ifdef U_DEBUG\n    uhp->uh_magic = UH_MAGIC;\n#endif\n    uhp->uh_next.seq = undo_read_4c(bi);\n    uhp->uh_prev.seq = undo_read_4c(bi);\n    uhp->uh_alt_next.seq = undo_read_4c(bi);\n    uhp->uh_alt_prev.seq = undo_read_4c(bi);\n    uhp->uh_seq = undo_read_4c(bi);\n    if (uhp->uh_seq <= 0)\n    {\n\tcorruption_error(\"uh_seq\", file_name);\n\tvim_free(uhp);\n\treturn NULL;\n    }\n    unserialize_pos(bi, &uhp->uh_cursor);\n    uhp->uh_cursor_vcol = undo_read_4c(bi);\n    uhp->uh_flags = undo_read_2c(bi);\n    for (i = 0; i < NMARKS; ++i)\n\tunserialize_pos(bi, &uhp->uh_namedm[i]);\n    unserialize_visualinfo(bi, &uhp->uh_visual);\n    uhp->uh_time = undo_read_time(bi);\n\n    // Optional fields.\n    for (;;)\n    {\n\tint len = undo_read_byte(bi);\n\tint what;\n\n\tif (len == EOF)\n\t{\n\t    corruption_error(\"truncated\", file_name);\n\t    u_free_uhp(uhp);\n\t    return NULL;\n\t}\n\tif (len == 0)\n\t    break;\n\twhat = undo_read_byte(bi);\n\tswitch (what)\n\t{\n\t    case UHP_SAVE_NR:\n\t\tuhp->uh_save_nr = undo_read_4c(bi);\n\t\tbreak;\n\t    default:\n\t\t// field not supported, skip\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(bi);\n\t}\n    }\n\n    // Unserialize the uep list.\n    last_uep = NULL;\n    while ((c = undo_read_2c(bi)) == UF_ENTRY_MAGIC)\n    {\n\terror = FALSE;\n\tuep = unserialize_uep(bi, &error, file_name);\n\tif (last_uep == NULL)\n\t    uhp->uh_entry = uep;\n\telse\n\t    last_uep->ue_next = uep;\n\tlast_uep = uep;\n\tif (uep == NULL || error)\n\t{\n\t    u_free_uhp(uhp);\n\t    return NULL;\n\t}\n    }\n    if (c != UF_ENTRY_END_MAGIC)\n    {\n\tcorruption_error(\"entry end\", file_name);\n\tu_free_uhp(uhp);\n\treturn NULL;\n    }\n\n    return uhp;\n}\n\n/*\n * Serialize \"uep\".\n */\n    static int\nserialize_uep(\n    bufinfo_T\t*bi,\n    u_entry_T\t*uep)\n{\n    int\t\ti;\n    size_t\tlen;\n\n    undo_write_bytes(bi, (long_u)uep->ue_top, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_bot, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_lcount, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_size, 4);\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\t// Text is written without the text properties, since we cannot restore\n\t// the text property types.\n\tlen = STRLEN(uep->ue_array[i].ul_line);\n\tif (undo_write_bytes(bi, (long_u)len, 4) == FAIL)\n\t    return FAIL;\n\tif (len > 0 && fwrite_crypt(bi, uep->ue_array[i].ul_line, len) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    static u_entry_T *\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    undoline_T\t*array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    CLEAR_POINTER(uep);\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = U_ALLOC_LINE(sizeof(undoline_T) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(undoline_T) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i].ul_line = line;\n\tarray[i].ul_len = line_len + 1;\n    }\n    return uep;\n}\n\n/*\n * Serialize \"pos\".\n */\n    static void\nserialize_pos(bufinfo_T *bi, pos_T pos)\n{\n    undo_write_bytes(bi, (long_u)pos.lnum, 4);\n    undo_write_bytes(bi, (long_u)pos.col, 4);\n    undo_write_bytes(bi, (long_u)pos.coladd, 4);\n}\n\n/*\n * Unserialize the pos_T at the current position.\n */\n    static void\nunserialize_pos(bufinfo_T *bi, pos_T *pos)\n{\n    pos->lnum = undo_read_4c(bi);\n    if (pos->lnum < 0)\n\tpos->lnum = 0;\n    pos->col = undo_read_4c(bi);\n    if (pos->col < 0)\n\tpos->col = 0;\n    pos->coladd = undo_read_4c(bi);\n    if (pos->coladd < 0)\n\tpos->coladd = 0;\n}\n\n/*\n * Serialize \"info\".\n */\n    static void\nserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    serialize_pos(bi, info->vi_start);\n    serialize_pos(bi, info->vi_end);\n    undo_write_bytes(bi, (long_u)info->vi_mode, 4);\n    undo_write_bytes(bi, (long_u)info->vi_curswant, 4);\n}\n\n/*\n * Unserialize the visualinfo_T at the current position.\n */\n    static void\nunserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    unserialize_pos(bi, &info->vi_start);\n    unserialize_pos(bi, &info->vi_end);\n    info->vi_mode = undo_read_4c(bi);\n    info->vi_curswant = undo_read_4c(bi);\n}\n\n/*\n * Write the undo tree in an undo file.\n * When \"name\" is not NULL, use it as the name of the undo file.\n * Otherwise use buf->b_ffname to generate the undo file name.\n * \"buf\" must never be null, buf->b_ffname is used to obtain the original file\n * permissions.\n * \"forceit\" is TRUE for \":wundo!\", FALSE otherwise.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_write_undo(\n    char_u\t*name,\n    int\t\tforceit,\n    buf_T\t*buf,\n    char_u\t*hash)\n{\n    u_header_T\t*uhp;\n    char_u\t*file_name;\n    int\t\tmark;\n#ifdef U_DEBUG\n    int\t\theaders_written = 0;\n#endif\n    int\t\tfd;\n    FILE\t*fp = NULL;\n    int\t\tperm;\n    int\t\twrite_ok = FALSE;\n#ifdef UNIX\n    int\t\tst_old_valid = FALSE;\n    stat_T\tst_old;\n    stat_T\tst_new;\n#endif\n    bufinfo_T\tbi;\n\n    CLEAR_FIELD(bi);\n\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(buf->b_ffname, FALSE);\n\tif (file_name == NULL)\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg(\n\t\t   _(\"Cannot write undo file in any directory in 'undodir'\"));\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n    }\n    else\n\tfile_name = name;\n\n    /*\n     * Decide about the permission to use for the undo file.  If the buffer\n     * has a name use the permission of the original file.  Otherwise only\n     * allow the user to access the undo file.\n     */\n    perm = 0600;\n    if (buf->b_ffname != NULL)\n    {\n#ifdef UNIX\n\tif (mch_stat((char *)buf->b_ffname, &st_old) >= 0)\n\t{\n\t    perm = st_old.st_mode;\n\t    st_old_valid = TRUE;\n\t}\n#else\n\tperm = mch_getperm(buf->b_ffname);\n\tif (perm < 0)\n\t    perm = 0600;\n#endif\n    }\n\n    // strip any s-bit and executable bit\n    perm = perm & 0666;\n\n    // If the undo file already exists, verify that it actually is an undo\n    // file, and delete it.\n    if (mch_getperm(file_name) >= 0)\n    {\n\tif (name == NULL || !forceit)\n\t{\n\t    // Check we can read it and it's an undo file.\n\t    fd = mch_open((char *)file_name, O_RDONLY|O_EXTRA, 0);\n\t    if (fd < 0)\n\t    {\n\t\tif (name != NULL || p_verbose > 0)\n\t\t{\n\t\t    if (name == NULL)\n\t\t\tverbose_enter();\n\t\t    smsg(\n\t\t      _(\"Will not overwrite with undo file, cannot read: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t    if (name == NULL)\n\t\t\tverbose_leave();\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tchar_u\tmbuf[UF_START_MAGIC_LEN];\n\t\tint\tlen;\n\n\t\tlen = read_eintr(fd, mbuf, UF_START_MAGIC_LEN);\n\t\tclose(fd);\n\t\tif (len < UF_START_MAGIC_LEN\n\t\t      || memcmp(mbuf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n\t\t{\n\t\t    if (name != NULL || p_verbose > 0)\n\t\t    {\n\t\t\tif (name == NULL)\n\t\t\t    verbose_enter();\n\t\t\tsmsg(\n\t\t\t_(\"Will not overwrite, this is not an undo file: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t\tif (name == NULL)\n\t\t\t    verbose_leave();\n\t\t    }\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\tmch_remove(file_name);\n    }\n\n    // If there is no undo information at all, quit here after deleting any\n    // existing undo file.\n    if (buf->b_u_numhead == 0 && buf->b_u_line_ptr.ul_line == NULL)\n    {\n\tif (p_verbose > 0)\n\t    verb_msg(_(\"Skipping undo file write, nothing to undo\"));\n\tgoto theend;\n    }\n\n    fd = mch_open((char *)file_name,\n\t\t\t    O_CREAT|O_EXTRA|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n    if (fd < 0)\n    {\n\tsemsg(_(e_cannot_open_undo_file_for_writing_str), file_name);\n\tgoto theend;\n    }\n    (void)mch_setperm(file_name, perm);\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Writing undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n#ifdef U_DEBUG\n    // Check there is no problem in undo info before writing.\n    u_check(FALSE);\n#endif\n\n#ifdef UNIX\n    /*\n     * Try to set the group of the undo file same as the original file. If\n     * this fails, set the protection bits for the group same as the\n     * protection bits for others.\n     */\n    if (st_old_valid\n\t    && mch_stat((char *)file_name, &st_new) >= 0\n\t    && st_new.st_gid != st_old.st_gid\n# ifdef HAVE_FCHOWN  // sequent-ptx lacks fchown()\n\t    && fchown(fd, (uid_t)-1, st_old.st_gid) != 0\n# endif\n       )\n\tmch_setperm(file_name, (perm & 0707) | ((perm & 07) << 3));\n# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n    if (buf->b_ffname != NULL)\n\tmch_copy_sec(buf->b_ffname, file_name);\n# endif\n#endif\n\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL)\n    {\n\tsemsg(_(e_cannot_open_undo_file_for_writing_str), file_name);\n\tclose(fd);\n\tmch_remove(file_name);\n\tgoto theend;\n    }\n\n    // Undo must be synced.\n    u_sync(TRUE);\n\n    /*\n     * Write the header.  Initializes encryption, if enabled.\n     */\n    bi.bi_buf = buf;\n    bi.bi_fp = fp;\n    if (serialize_header(&bi, hash) == FAIL)\n\tgoto write_error;\n\n    /*\n     * Iteratively serialize UHPs and their UEPs from the top down.\n     */\n    mark = ++lastmark;\n    uhp = buf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\t// Serialize current UHP if we haven't seen it\n\tif (uhp->uh_walk != mark)\n\t{\n\t    uhp->uh_walk = mark;\n#ifdef U_DEBUG\n\t    ++headers_written;\n#endif\n\t    if (serialize_uhp(&bi, uhp) == FAIL)\n\t\tgoto write_error;\n\t}\n\n\t// Now walk through the tree - algorithm from undo_time().\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_prev.ptr;\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t\t\t\t && uhp->uh_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_next.ptr;\n\telse if (uhp->uh_alt_prev.ptr != NULL)\n\t    uhp = uhp->uh_alt_prev.ptr;\n\telse\n\t    uhp = uhp->uh_next.ptr;\n    }\n\n    if (undo_write_bytes(&bi, (long_u)UF_HEADER_END_MAGIC, 2) == OK)\n\twrite_ok = TRUE;\n#ifdef U_DEBUG\n    if (headers_written != buf->b_u_numhead)\n    {\n\tsemsg(\"Written %ld headers, ...\", headers_written);\n\tsemsg(\"... but numhead is %ld\", buf->b_u_numhead);\n    }\n#endif\n\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL && undo_flush(&bi) == FAIL)\n\twrite_ok = FALSE;\n#endif\n\n#if defined(UNIX) && defined(HAVE_FSYNC)\n    if (p_fs && fflush(fp) == 0 && vim_fsync(fd) != 0)\n\twrite_ok = FALSE;\n#endif\n\nwrite_error:\n    fclose(fp);\n    if (!write_ok)\n\tsemsg(_(e_write_error_in_undo_file_str), file_name);\n\n#if defined(MSWIN)\n    // Copy file attributes; for systems where this can only be done after\n    // closing the file.\n    if (buf->b_ffname != NULL)\n\t(void)mch_copy_file_attribute(buf->b_ffname, file_name);\n#endif\n#ifdef HAVE_ACL\n    if (buf->b_ffname != NULL)\n    {\n\tvim_acl_T\t    acl;\n\n\t// For systems that support ACL: get the ACL from the original file.\n\tacl = mch_get_acl(buf->b_ffname);\n\tmch_set_acl(file_name, acl);\n\tmch_free_acl(acl);\n    }\n#endif\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (file_name != name)\n\tvim_free(file_name);\n}\n\n/*\n * Load the undo tree from an undo file.\n * If \"name\" is not NULL use it as the undo file name.  This also means being\n * a bit more verbose.\n * Otherwise use curbuf->b_ffname to generate the undo file name.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_read_undo(char_u *name, char_u *hash, char_u *orig_name UNUSED)\n{\n    char_u\t*file_name;\n    FILE\t*fp;\n    long\tversion, str_len;\n    undoline_T\tline_ptr;\n    linenr_T\tline_lnum;\n    colnr_T\tline_colnr;\n    linenr_T\tline_count;\n    long\tnum_head = 0;\n    long\told_header_seq, new_header_seq, cur_header_seq;\n    long\tseq_last, seq_cur;\n    long\tlast_save_nr = 0;\n    short\told_idx = -1, new_idx = -1, cur_idx = -1;\n    long\tnum_read_uhps = 0;\n    time_t\tseq_time;\n    int\t\ti, j;\n    int\t\tc;\n    u_header_T\t*uhp;\n    u_header_T\t**uhp_table = NULL;\n    char_u\tread_hash[UNDO_HASH_SIZE];\n    char_u\tmagic_buf[UF_START_MAGIC_LEN];\n#ifdef U_DEBUG\n    int\t\t*uhp_table_used;\n#endif\n#ifdef UNIX\n    stat_T\tst_orig;\n    stat_T\tst_undo;\n#endif\n    bufinfo_T\tbi;\n\n    CLEAR_FIELD(bi);\n    line_ptr.ul_len = 0;\n    line_ptr.ul_line = NULL;\n\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);\n\tif (file_name == NULL)\n\t    return;\n\n#ifdef UNIX\n\t// For safety we only read an undo file if the owner is equal to the\n\t// owner of the text file or equal to the current user.\n\tif (mch_stat((char *)orig_name, &st_orig) >= 0\n\t\t&& mch_stat((char *)file_name, &st_undo) >= 0\n\t\t&& st_orig.st_uid != st_undo.st_uid\n\t\t&& st_undo.st_uid != getuid())\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg(_(\"Not reading undo file, owner differs: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n#endif\n    }\n    else\n\tfile_name = name;\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n    fp = mch_fopen((char *)file_name, \"r\");\n    if (fp == NULL)\n    {\n\tif (name != NULL || p_verbose > 0)\n\t    semsg(_(e_cannot_open_undo_file_for_reading_str), file_name);\n\tgoto error;\n    }\n    bi.bi_buf = curbuf;\n    bi.bi_fp = fp;\n\n    /*\n     * Read the undo file header.\n     */\n    if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1\n\t\t|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n    {\n\tsemsg(_(e_not_an_undo_file_str), file_name);\n\tgoto error;\n    }\n    version = get2c(fp);\n    if (version == UF_VERSION_CRYPT)\n    {\n#ifdef FEAT_CRYPT\n\tif (*curbuf->b_p_key == NUL)\n\t{\n\t    semsg(_(e_non_encrypted_file_has_encrypted_undo_file), file_name);\n\t    goto error;\n\t}\n\tbi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);\n\tif (bi.bi_state == NULL)\n\t{\n\t    semsg(_(e_undo_file_decryption_failed), file_name);\n\t    goto error;\n\t}\n\tif (crypt_whole_undofile(bi.bi_state->method_nr))\n\t{\n\t    bi.bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi.bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi.bi_state);\n\t\tbi.bi_state = NULL;\n\t\tgoto error;\n\t    }\n\t    bi.bi_avail = 0;\n\t    bi.bi_used = 0;\n\t}\n#else\n\tsemsg(_(e_undo_file_is_encrypted_str), file_name);\n\tgoto error;\n#endif\n    }\n    else if (version != UF_VERSION)\n    {\n\tsemsg(_(e_incompatible_undo_file_str), file_name);\n\tgoto error;\n    }\n\n    if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n    {\n\tcorruption_error(\"hash\", file_name);\n\tgoto error;\n    }\n    line_count = (linenr_T)undo_read_4c(&bi);\n    if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0\n\t\t\t\t  || line_count != curbuf->b_ml.ml_line_count)\n    {\n\tif (p_verbose > 0 || name != NULL)\n\t{\n\t    if (name == NULL)\n\t\tverbose_enter();\n\t    give_warning((char_u *)\n\t\t      _(\"File contents changed, cannot use undo info\"), TRUE);\n\t    if (name == NULL)\n\t\tverbose_leave();\n\t}\n\tgoto error;\n    }\n\n    // Read undo data for \"U\" command.\n    str_len = undo_read_4c(&bi);\n    if (str_len < 0)\n\tgoto error;\n    if (str_len > 0)\n    {\n\tline_ptr.ul_line = read_string_decrypt(&bi, str_len);\n\tline_ptr.ul_len = str_len + 1;\n    }\n    line_lnum = (linenr_T)undo_read_4c(&bi);\n    line_colnr = (colnr_T)undo_read_4c(&bi);\n    if (line_lnum < 0 || line_colnr < 0)\n    {\n\tcorruption_error(\"line lnum/col\", file_name);\n\tgoto error;\n    }\n\n    // Begin general undo data\n    old_header_seq = undo_read_4c(&bi);\n    new_header_seq = undo_read_4c(&bi);\n    cur_header_seq = undo_read_4c(&bi);\n    num_head = undo_read_4c(&bi);\n    seq_last = undo_read_4c(&bi);\n    seq_cur = undo_read_4c(&bi);\n    seq_time = undo_read_time(&bi);\n\n    // Optional header fields.\n    for (;;)\n    {\n\tint len = undo_read_byte(&bi);\n\tint what;\n\n\tif (len == 0 || len == EOF)\n\t    break;\n\twhat = undo_read_byte(&bi);\n\tswitch (what)\n\t{\n\t    case UF_LAST_SAVE_NR:\n\t\tlast_save_nr = undo_read_4c(&bi);\n\t\tbreak;\n\t    default:\n\t\t// field not supported, skip\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(&bi);\n\t}\n    }\n\n    // uhp_table will store the freshly created undo headers we allocate\n    // until we insert them into curbuf. The table remains sorted by the\n    // sequence numbers of the headers.\n    // When there are no headers uhp_table is NULL.\n    if (num_head > 0)\n    {\n\tif (num_head < LONG_MAX / (long)sizeof(u_header_T *))\n\t    uhp_table = U_ALLOC_LINE(num_head * sizeof(u_header_T *));\n\tif (uhp_table == NULL)\n\t    goto error;\n    }\n\n    while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)\n    {\n\tif (num_read_uhps >= num_head)\n\t{\n\t    corruption_error(\"num_head too small\", file_name);\n\t    goto error;\n\t}\n\n\tuhp = unserialize_uhp(&bi, file_name);\n\tif (uhp == NULL)\n\t    goto error;\n\tuhp_table[num_read_uhps++] = uhp;\n    }\n\n    if (num_read_uhps != num_head)\n    {\n\tcorruption_error(\"num_head\", file_name);\n\tgoto error;\n    }\n    if (c != UF_HEADER_END_MAGIC)\n    {\n\tcorruption_error(\"end marker\", file_name);\n\tgoto error;\n    }\n\n#ifdef U_DEBUG\n    uhp_table_used = alloc_clear(sizeof(int) * num_head + 1);\n# define SET_FLAG(j) ++uhp_table_used[j]\n#else\n# define SET_FLAG(j)\n#endif\n\n    // We have put all of the headers into a table. Now we iterate through the\n    // table and swizzle each sequence number we have stored in uh_*_seq into\n    // a pointer corresponding to the header with that sequence number.\n    for (i = 0; i < num_head; i++)\n    {\n\tuhp = uhp_table[i];\n\tif (uhp == NULL)\n\t    continue;\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL && i != j\n\t\t\t      && uhp_table[i]->uh_seq == uhp_table[j]->uh_seq)\n\t    {\n\t\tcorruption_error(\"duplicate uh_seq\", file_name);\n\t\tgoto error;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_next.seq)\n\t    {\n\t\tuhp->uh_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_prev.seq)\n\t    {\n\t\tuhp->uh_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_next.seq)\n\t    {\n\t\tuhp->uh_alt_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_prev.seq)\n\t    {\n\t\tuhp->uh_alt_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tif (old_header_seq > 0 && old_idx < 0 && uhp->uh_seq == old_header_seq)\n\t{\n\t    old_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (new_header_seq > 0 && new_idx < 0 && uhp->uh_seq == new_header_seq)\n\t{\n\t    new_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (cur_header_seq > 0 && cur_idx < 0 && uhp->uh_seq == cur_header_seq)\n\t{\n\t    cur_idx = i;\n\t    SET_FLAG(i);\n\t}\n    }\n\n    // Now that we have read the undo info successfully, free the current undo\n    // info and use the info from the file.\n    u_blockfree(curbuf);\n    curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];\n    curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];\n    curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];\n    curbuf->b_u_line_ptr = line_ptr;\n    curbuf->b_u_line_lnum = line_lnum;\n    curbuf->b_u_line_colnr = line_colnr;\n    curbuf->b_u_numhead = num_head;\n    curbuf->b_u_seq_last = seq_last;\n    curbuf->b_u_seq_cur = seq_cur;\n    curbuf->b_u_time_cur = seq_time;\n    curbuf->b_u_save_nr_last = last_save_nr;\n    curbuf->b_u_save_nr_cur = last_save_nr;\n\n    curbuf->b_u_synced = TRUE;\n    vim_free(uhp_table);\n\n#ifdef U_DEBUG\n    for (i = 0; i < num_head; ++i)\n\tif (uhp_table_used[i] == 0)\n\t    semsg(\"uhp_table entry %ld not used, leaking memory\", i);\n    vim_free(uhp_table_used);\n    u_check(TRUE);\n#endif\n\n    if (name != NULL)\n\tsmsg(_(\"Finished reading undo file %s\"), file_name);\n    goto theend;\n\nerror:\n    vim_free(line_ptr.ul_line);\n    if (uhp_table != NULL)\n    {\n\tfor (i = 0; i < num_read_uhps; i++)\n\t    if (uhp_table[i] != NULL)\n\t\tu_free_uhp(uhp_table[i]);\n\tvim_free(uhp_table);\n    }\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (fp != NULL)\n\tfclose(fp);\n    if (file_name != name)\n\tvim_free(file_name);\n    return;\n}\n\n#endif // FEAT_PERSISTENT_UNDO\n\n\n/*\n * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).\n * If 'cpoptions' does not contain 'u': Always undo.\n */\n    void\nu_undo(int count)\n{\n    /*\n     * If we get an undo command while executing a macro, we behave like the\n     * original vi. If this happens twice in one macro the result will not\n     * be compatible.\n     */\n    if (curbuf->b_u_synced == FALSE)\n    {\n\tu_sync(TRUE);\n\tcount = 1;\n    }\n\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = TRUE;\n    else\n\tundo_undoes = !undo_undoes;\n    u_doit(count);\n}\n\n/*\n * If 'cpoptions' contains 'u': Repeat the previous undo or redo.\n * If 'cpoptions' does not contain 'u': Always redo.\n */\n    void\nu_redo(int count)\n{\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = FALSE;\n    u_doit(count);\n}\n\n/*\n * Undo or redo, depending on 'undo_undoes', 'count' times.\n */\n    static void\nu_doit(int startcount)\n{\n    int count = startcount;\n\n    if (!undo_allowed())\n\treturn;\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n    while (count--)\n    {\n\t// Do the change warning now, so that it triggers FileChangedRO when\n\t// needed.  This may cause the file to be reloaded, that must happen\n\t// before we do anything, because it may change curbuf->b_u_curhead\n\t// and more.\n\tchange_warning(0);\n\n\tif (undo_undoes)\n\t{\n\t    if (curbuf->b_u_curhead == NULL)\t\t// first undo\n\t\tcurbuf->b_u_curhead = curbuf->b_u_newhead;\n\t    else if (get_undolevel() > 0)\t\t// multi level undo\n\t\t// get next undo\n\t\tcurbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;\n\t    // nothing to undo\n\t    if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL)\n\t    {\n\t\t// stick curbuf->b_u_curhead at end\n\t\tcurbuf->b_u_curhead = curbuf->b_u_oldhead;\n\t\tbeep_flush();\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    msg(_(\"Already at oldest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(TRUE);\n\t}\n\telse\n\t{\n\t    if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0)\n\t    {\n\t\tbeep_flush();\t// nothing to redo\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    msg(_(\"Already at newest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(FALSE);\n\n\t    // Advance for next redo.  Set \"newhead\" when at the end of the\n\t    // redoable changes.\n\t    if (curbuf->b_u_curhead->uh_prev.ptr == NULL)\n\t\tcurbuf->b_u_newhead = curbuf->b_u_curhead;\n\t    curbuf->b_u_curhead = curbuf->b_u_curhead->uh_prev.ptr;\n\t}\n    }\n    u_undo_end(undo_undoes, FALSE);\n}\n\n/*\n * Undo or redo over the timeline.\n * When \"step\" is negative go back in time, otherwise goes forward in time.\n * When \"sec\" is FALSE make \"step\" steps, when \"sec\" is TRUE use \"step\" as\n * seconds.\n * When \"file\" is TRUE use \"step\" as a number of file writes.\n * When \"absolute\" is TRUE use \"step\" as the sequence number to jump to.\n * \"sec\" must be FALSE then.\n */\n    void\nundo_time(\n    long\tstep,\n    int\t\tsec,\n    int\t\tfile,\n    int\t\tabsolute)\n{\n    long\t    target;\n    long\t    closest;\n    long\t    closest_start;\n    long\t    closest_seq = 0;\n    long\t    val;\n    u_header_T\t    *uhp = NULL;\n    u_header_T\t    *last;\n    int\t\t    mark;\n    int\t\t    nomark = 0;  // shut up compiler\n    int\t\t    round;\n    int\t\t    dosec = sec;\n    int\t\t    dofile = file;\n    int\t\t    above = FALSE;\n    int\t\t    did_undo = TRUE;\n\n    // First make sure the current undoable change is synced.\n    if (curbuf->b_u_synced == FALSE)\n\tu_sync(TRUE);\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n\n    // \"target\" is the node below which we want to be.\n    // Init \"closest\" to a value we can't reach.\n    if (absolute)\n    {\n\ttarget = step;\n\tclosest = -1;\n    }\n    else\n    {\n\tif (dosec)\n\t    target = (long)(curbuf->b_u_time_cur) + step;\n\telse if (dofile)\n\t{\n\t    if (step < 0)\n\t    {\n\t\t// Going back to a previous write. If there were changes after\n\t\t// the last write, count that as moving one file-write, so\n\t\t// that \":earlier 1f\" undoes all changes since the last save.\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp != NULL)\n\t\t    uhp = uhp->uh_next.ptr;\n\t\telse\n\t\t    uhp = curbuf->b_u_newhead;\n\t\tif (uhp != NULL && uhp->uh_save_nr != 0)\n\t\t    // \"uh_save_nr\" was set in the last block, that means\n\t\t    // there were no changes since the last write\n\t\t    target = curbuf->b_u_save_nr_cur + step;\n\t\telse\n\t\t    // count the changes since the last write as one step\n\t\t    target = curbuf->b_u_save_nr_cur + step + 1;\n\t\tif (target <= 0)\n\t\t    // Go to before first write: before the oldest change. Use\n\t\t    // the sequence number for that.\n\t\t    dofile = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t// Moving forward to a newer write.\n\t\ttarget = curbuf->b_u_save_nr_cur + step;\n\t\tif (target > curbuf->b_u_save_nr_last)\n\t\t{\n\t\t    // Go to after last write: after the latest change. Use\n\t\t    // the sequence number for that.\n\t\t    target = curbuf->b_u_seq_last + 1;\n\t\t    dofile = FALSE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    target = curbuf->b_u_seq_cur + step;\n\tif (step < 0)\n\t{\n\t    if (target < 0)\n\t\ttarget = 0;\n\t    closest = -1;\n\t}\n\telse\n\t{\n\t    if (dosec)\n\t\tclosest = (long)(vim_time() + 1);\n\t    else if (dofile)\n\t\tclosest = curbuf->b_u_save_nr_last + 2;\n\t    else\n\t\tclosest = curbuf->b_u_seq_last + 2;\n\t    if (target >= closest)\n\t\ttarget = closest - 1;\n\t}\n    }\n    closest_start = closest;\n    closest_seq = curbuf->b_u_seq_cur;\n\n    // When \"target\" is 0; Back to origin.\n    if (target == 0)\n    {\n\tmark = lastmark;  // avoid that GCC complains\n\tgoto target_zero;\n    }\n\n    /*\n     * May do this twice:\n     * 1. Search for \"target\", update \"closest\" to the best match found.\n     * 2. If \"target\" not found search for \"closest\".\n     *\n     * When using the closest time we use the sequence number in the second\n     * round, because there may be several entries with the same time.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t// Find the path from the current state to where we want to go.  The\n\t// desired state can be anywhere in the undo tree, need to go all over\n\t// it.  We put \"nomark\" in uh_walk where we have been without success,\n\t// \"mark\" where it could possibly be.\n\tmark = ++lastmark;\n\tnomark = ++lastmark;\n\n\tif (curbuf->b_u_curhead == NULL)\t// at leaf of the tree\n\t    uhp = curbuf->b_u_newhead;\n\telse\n\t    uhp = curbuf->b_u_curhead;\n\n\twhile (uhp != NULL)\n\t{\n\t    uhp->uh_walk = mark;\n\t    if (dosec)\n\t\tval = (long)(uhp->uh_time);\n\t    else if (dofile)\n\t\tval = uhp->uh_save_nr;\n\t    else\n\t\tval = uhp->uh_seq;\n\n\t    if (round == 1 && !(dofile && val == 0))\n\t    {\n\t\t// Remember the header that is closest to the target.\n\t\t// It must be at least in the right direction (checked with\n\t\t// \"b_u_seq_cur\").  When the timestamp is equal find the\n\t\t// highest/lowest sequence number.\n\t\tif ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur\n\t\t\t      : uhp->uh_seq > curbuf->b_u_seq_cur)\n\t\t\t&& ((dosec && val == closest)\n\t\t\t    ? (step < 0\n\t\t\t\t? uhp->uh_seq < closest_seq\n\t\t\t\t: uhp->uh_seq > closest_seq)\n\t\t\t    : closest == closest_start\n\t\t\t\t|| (val > target\n\t\t\t\t    ? (closest > target\n\t\t\t\t\t? val - target <= closest - target\n\t\t\t\t\t: val - target <= target - closest)\n\t\t\t\t    : (closest > target\n\t\t\t\t\t? target - val <= closest - target\n\t\t\t\t\t: target - val <= target - closest))))\n\t\t{\n\t\t    closest = val;\n\t\t    closest_seq = uhp->uh_seq;\n\t\t}\n\t    }\n\n\t    // Quit searching when we found a match.  But when searching for a\n\t    // time we need to continue looking for the best uh_seq.\n\t    if (target == val && !dosec)\n\t    {\n\t\ttarget = uhp->uh_seq;\n\t\tbreak;\n\t    }\n\n\t    // go down in the tree if we haven't been there\n\t    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_prev.ptr;\n\n\t    // go to alternate branch if we haven't been there\n\t    else if (uhp->uh_alt_next.ptr != NULL\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_alt_next.ptr;\n\n\t    // go up in the tree if we haven't been there and we are at the\n\t    // start of alternate branches\n\t    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t    && uhp->uh_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_next.ptr->uh_walk != mark)\n\t    {\n\t\t// If still at the start we don't go through this change.\n\t\tif (uhp == curbuf->b_u_curhead)\n\t\t    uhp->uh_walk = nomark;\n\t\tuhp = uhp->uh_next.ptr;\n\t    }\n\n\t    else\n\t    {\n\t\t// need to backtrack; mark this node as useless\n\t\tuhp->uh_walk = nomark;\n\t\tif (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\telse\n\t\t    uhp = uhp->uh_next.ptr;\n\t    }\n\t}\n\n\tif (uhp != NULL)    // found it\n\t    break;\n\n\tif (absolute)\n\t{\n\t    semsg(_(e_undo_number_nr_not_found), step);\n\t    return;\n\t}\n\n\tif (closest == closest_start)\n\t{\n\t    if (step < 0)\n\t\tmsg(_(\"Already at oldest change\"));\n\t    else\n\t\tmsg(_(\"Already at newest change\"));\n\t    return;\n\t}\n\n\ttarget = closest_seq;\n\tdosec = FALSE;\n\tdofile = FALSE;\n\tif (step < 0)\n\t    above = TRUE;\t// stop above the header\n    }\n\ntarget_zero:\n    // If we found it: Follow the path to go to where we want to be.\n    if (uhp != NULL || target == 0)\n    {\n\t/*\n\t * First go up the tree as much as needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    // Do the change warning now, for the same reason as above.\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tuhp = curbuf->b_u_newhead;\n\t    else\n\t\tuhp = uhp->uh_next.ptr;\n\t    if (uhp == NULL || (target > 0 && uhp->uh_walk != mark)\n\t\t\t\t\t || (uhp->uh_seq == target && !above))\n\t\tbreak;\n\t    curbuf->b_u_curhead = uhp;\n\t    u_undoredo(TRUE);\n\t    if (target > 0)\n\t\tuhp->uh_walk = nomark;\t// don't go back down here\n\t}\n\n\t// When back to origin, redo is not needed.\n\tif (target > 0)\n\t{\n\t    /*\n\t     * And now go down the tree (redo), branching off where needed.\n\t     */\n\t    while (!got_int)\n\t    {\n\t\t// Do the change warning now, for the same reason as above.\n\t\tchange_warning(0);\n\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp == NULL)\n\t\t    break;\n\n\t\t// Go back to the first branch with a mark.\n\t\twhile (uhp->uh_alt_prev.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_prev.ptr->uh_walk == mark)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\n\t\t// Find the last branch with a mark, that's the one.\n\t\tlast = uhp;\n\t\twhile (last->uh_alt_next.ptr != NULL\n\t\t\t\t    && last->uh_alt_next.ptr->uh_walk == mark)\n\t\t    last = last->uh_alt_next.ptr;\n\t\tif (last != uhp)\n\t\t{\n\t\t    // Make the used branch the first entry in the list of\n\t\t    // alternatives to make \"u\" and CTRL-R take this branch.\n\t\t    while (uhp->uh_alt_prev.ptr != NULL)\n\t\t\tuhp = uhp->uh_alt_prev.ptr;\n\t\t    if (last->uh_alt_next.ptr != NULL)\n\t\t\tlast->uh_alt_next.ptr->uh_alt_prev.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_prev.ptr;\n\t\t    last->uh_alt_prev.ptr->uh_alt_next.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_next.ptr;\n\t\t    last->uh_alt_prev.ptr = NULL;\n\t\t    last->uh_alt_next.ptr = uhp;\n\t\t    uhp->uh_alt_prev.ptr = last;\n\n\t\t    if (curbuf->b_u_oldhead == uhp)\n\t\t\tcurbuf->b_u_oldhead = last;\n\t\t    uhp = last;\n\t\t    if (uhp->uh_next.ptr != NULL)\n\t\t\tuhp->uh_next.ptr->uh_prev.ptr = uhp;\n\t\t}\n\t\tcurbuf->b_u_curhead = uhp;\n\n\t\tif (uhp->uh_walk != mark)\n\t\t    break;\t    // must have reached the target\n\n\t\t// Stop when going backwards in time and didn't find the exact\n\t\t// header we were looking for.\n\t\tif (uhp->uh_seq == target && above)\n\t\t{\n\t\t    curbuf->b_u_seq_cur = target - 1;\n\t\t    break;\n\t\t}\n\n\t\tu_undoredo(FALSE);\n\n\t\t// Advance \"curhead\" to below the header we last used.  If it\n\t\t// becomes NULL then we need to set \"newhead\" to this leaf.\n\t\tif (uhp->uh_prev.ptr == NULL)\n\t\t    curbuf->b_u_newhead = uhp;\n\t\tcurbuf->b_u_curhead = uhp->uh_prev.ptr;\n\t\tdid_undo = FALSE;\n\n\t\tif (uhp->uh_seq == target)\t// found it!\n\t\t    break;\n\n\t\tuhp = uhp->uh_prev.ptr;\n\t\tif (uhp == NULL || uhp->uh_walk != mark)\n\t\t{\n\t\t    // Need to redo more but can't find it...\n\t\t    internal_error(\"undo_time()\");\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    u_undo_end(did_undo, absolute);\n}\n\n/*\n * u_undoredo: common code for undo and redo\n *\n * The lines in the file are replaced by the lines in the entry list at\n * curbuf->b_u_curhead. The replaced lines in the file are saved in the entry\n * list for the next undo/redo.\n *\n * When \"undo\" is TRUE we go up in the tree, when FALSE we go down.\n */\n    static void\nu_undoredo(int undo)\n{\n    undoline_T\t*newarray = NULL;\n    linenr_T\toldsize;\n    linenr_T\tnewsize;\n    linenr_T\ttop, bot;\n    linenr_T\tlnum;\n    linenr_T\tnewlnum = MAXLNUM;\n    pos_T\tnew_curpos = curwin->w_cursor;\n    long\ti;\n    u_entry_T\t*uep, *nuep;\n    u_entry_T\t*newlist = NULL;\n    int\t\told_flags;\n    int\t\tnew_flags;\n    pos_T\tnamedm[NMARKS];\n    visualinfo_T visualinfo;\n    int\t\tempty_buffer;\t\t    // buffer became empty\n    u_header_T\t*curhead = curbuf->b_u_curhead;\n\n    // Don't want autocommands using the undo structures here, they are\n    // invalid till the end.\n    block_autocmds();\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    old_flags = curhead->uh_flags;\n    new_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n    setpcmark();\n\n    /*\n     * save marks before undo/redo\n     */\n    mch_memmove(namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n    visualinfo = curbuf->b_visual;\n    curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;\n    curbuf->b_op_start.col = 0;\n    curbuf->b_op_end.lnum = 0;\n    curbuf->b_op_end.col = 0;\n\n    for (uep = curhead->uh_entry; uep != NULL; uep = nuep)\n    {\n\ttop = uep->ue_top;\n\tbot = uep->ue_bot;\n\tif (bot == 0)\n\t    bot = curbuf->b_ml.ml_line_count + 1;\n\tif (top > curbuf->b_ml.ml_line_count || top >= bot\n\t\t\t\t      || bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n\t    unblock_autocmds();\n\t    iemsg(_(e_u_undo_line_numbers_wrong));\n\t    changed();\t\t// don't want UNCHANGED now\n\t    return;\n\t}\n\n\toldsize = bot - top - 1;    // number of lines before undo\n\tnewsize = uep->ue_size;\t    // number of lines after undo\n\n\t// Decide about the cursor position, depending on what text changed.\n\t// Don't set it yet, it may be invalid if lines are going to be added.\n\tif (top < newlnum)\n\t{\n\t    // If the saved cursor is somewhere in this undo block, move it to\n\t    // the remembered position.  Makes \"gwap\" put the cursor back\n\t    // where it was.\n\t    lnum = curhead->uh_cursor.lnum;\n\t    if (lnum >= top && lnum <= top + newsize + 1)\n\t    {\n\t\tnew_curpos = curhead->uh_cursor;\n\t\tnewlnum = new_curpos.lnum - 1;\n\t    }\n\t    else\n\t    {\n\t\t// Use the first line that actually changed.  Avoids that\n\t\t// undoing auto-formatting puts the cursor in the previous\n\t\t// line.\n\t\tfor (i = 0; i < newsize && i < oldsize; ++i)\n\t\t{\n\t\t    char_u *p = ml_get(top + 1 + i);\n\n\t\t    if (curbuf->b_ml.ml_line_len != uep->ue_array[i].ul_len\n\t\t\t    || memcmp(uep->ue_array[i].ul_line, p,\n\t\t\t\t\t\tcurbuf->b_ml.ml_line_len) != 0)\n\t\t\tbreak;\n\t\t}\n\t\tif (i == newsize && newlnum == MAXLNUM && uep->ue_next == NULL)\n\t\t{\n\t\t    newlnum = top;\n\t\t    new_curpos.lnum = newlnum + 1;\n\t\t}\n\t\telse if (i < newsize)\n\t\t{\n\t\t    newlnum = top + i;\n\t\t    new_curpos.lnum = newlnum + 1;\n\t\t}\n\t    }\n\t}\n\n\tempty_buffer = FALSE;\n\n\t/*\n\t * Delete the lines between top and bot and save them in newarray.\n\t */\n\tif (oldsize > 0)\n\t{\n\t    if ((newarray = U_ALLOC_LINE(sizeof(undoline_T) * oldsize)) == NULL)\n\t    {\n\t\tdo_outofmem_msg((long_u)(sizeof(undoline_T) * oldsize));\n\n\t\t// We have messed up the entry list, repair is impossible.\n\t\t// we have to free the rest of the list.\n\t\twhile (uep != NULL)\n\t\t{\n\t\t    nuep = uep->ue_next;\n\t\t    u_freeentry(uep, uep->ue_size);\n\t\t    uep = nuep;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // delete backwards, it goes faster in most cases\n\t    for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum)\n\t    {\n\t\t// what can we do when we run out of memory?\n\t\tif (u_save_line(&newarray[i], lnum) == FAIL)\n\t\t    do_outofmem_msg((long_u)0);\n\t\t// remember we deleted the last line in the buffer, and a\n\t\t// dummy empty line will be inserted\n\t\tif (curbuf->b_ml.ml_line_count == 1)\n\t\t    empty_buffer = TRUE;\n\t\tml_delete_flags(lnum, ML_DEL_UNDO);\n\t    }\n\t}\n\telse\n\t    newarray = NULL;\n\n\t// make sure the cursor is on a valid line after the deletions\n\tcheck_cursor_lnum();\n\n\t/*\n\t * Insert the lines in u_array between top and bot.\n\t */\n\tif (newsize)\n\t{\n\t    for (lnum = top, i = 0; i < newsize; ++i, ++lnum)\n\t    {\n\t\t// If the file is empty, there is an empty line 1 that we\n\t\t// should get rid of, by replacing it with the new line.\n\t\tif (empty_buffer && lnum == 0)\n\t\t    ml_replace_len((linenr_T)1, uep->ue_array[i].ul_line,\n\t\t\t\t\t  uep->ue_array[i].ul_len, TRUE, TRUE);\n\t\telse\n\t\t    ml_append_flags(lnum, uep->ue_array[i].ul_line,\n\t\t\t     (colnr_T)uep->ue_array[i].ul_len, ML_APPEND_UNDO);\n\t\tvim_free(uep->ue_array[i].ul_line);\n\t    }\n\t    vim_free((char_u *)uep->ue_array);\n\t}\n\n\t// adjust marks\n\tif (oldsize != newsize)\n\t{\n\t    mark_adjust(top + 1, top + oldsize, (long)MAXLNUM,\n\t\t\t\t\t       (long)newsize - (long)oldsize);\n\t    if (curbuf->b_op_start.lnum > top + oldsize)\n\t\tcurbuf->b_op_start.lnum += newsize - oldsize;\n\t    if (curbuf->b_op_end.lnum > top + oldsize)\n\t\tcurbuf->b_op_end.lnum += newsize - oldsize;\n\t}\n\n\tchanged_lines(top + 1, 0, bot, newsize - oldsize);\n\n\t// set '[ and '] mark\n\tif (top + 1 < curbuf->b_op_start.lnum)\n\t    curbuf->b_op_start.lnum = top + 1;\n\tif (newsize == 0 && top + 1 > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + 1;\n\telse if (top + newsize > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + newsize;\n\n\tu_newcount += newsize;\n\tu_oldcount += oldsize;\n\tuep->ue_size = oldsize;\n\tuep->ue_array = newarray;\n\tuep->ue_bot = top + newsize + 1;\n\n\t/*\n\t * insert this entry in front of the new entry list\n\t */\n\tnuep = uep->ue_next;\n\tuep->ue_next = newlist;\n\tnewlist = uep;\n    }\n\n    // Set the cursor to the desired position.  Check that the line is valid.\n    curwin->w_cursor = new_curpos;\n    check_cursor_lnum();\n\n    curhead->uh_entry = newlist;\n    curhead->uh_flags = new_flags;\n    if ((old_flags & UH_EMPTYBUF) && BUFEMPTY())\n\tcurbuf->b_ml.ml_flags |= ML_EMPTY;\n    if (old_flags & UH_CHANGED)\n\tchanged();\n    else\n#ifdef FEAT_NETBEANS_INTG\n\t// per netbeans undo rules, keep it as modified\n\tif (!isNetbeansModified(curbuf))\n#endif\n\tunchanged(curbuf, FALSE, TRUE);\n\n    /*\n     * restore marks from before undo/redo\n     */\n    for (i = 0; i < NMARKS; ++i)\n    {\n\tif (curhead->uh_namedm[i].lnum != 0)\n\t    curbuf->b_namedm[i] = curhead->uh_namedm[i];\n\tif (namedm[i].lnum != 0)\n\t    curhead->uh_namedm[i] = namedm[i];\n\telse\n\t    curhead->uh_namedm[i].lnum = 0;\n    }\n    if (curhead->uh_visual.vi_start.lnum != 0)\n    {\n\tcurbuf->b_visual = curhead->uh_visual;\n\tcurhead->uh_visual = visualinfo;\n    }\n\n    /*\n     * If the cursor is only off by one line, put it at the same position as\n     * before starting the change (for the \"o\" command).\n     * Otherwise the cursor should go to the first undone line.\n     */\n    if (curhead->uh_cursor.lnum + 1 == curwin->w_cursor.lnum\n\t\t\t\t\t\t && curwin->w_cursor.lnum > 1)\n\t--curwin->w_cursor.lnum;\n    if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tif (curhead->uh_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = curhead->uh_cursor.col;\n\t    if (virtual_active() && curhead->uh_cursor_vcol >= 0)\n\t\tcoladvance((colnr_T)curhead->uh_cursor_vcol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse\n\t    beginline(BL_SOL | BL_FIX);\n    }\n    else\n    {\n\t// We get here with the current cursor line being past the end (eg\n\t// after adding lines at the end of the file, and then undoing it).\n\t// check_cursor() will move the cursor to the last line.  Move it to\n\t// the first column here.\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    // Make sure the cursor is on an existing line and column.\n    check_cursor();\n\n    // Remember where we are for \"g-\" and \":earlier 10s\".\n    curbuf->b_u_seq_cur = curhead->uh_seq;\n    if (undo)\n    {\n\t// We are below the previous undo.  However, to make \":earlier 1s\"\n\t// work we compute this as being just above the just undone change.\n\tif (curhead->uh_next.ptr != NULL)\n\t    curbuf->b_u_seq_cur = curhead->uh_next.ptr->uh_seq;\n\telse\n\t    curbuf->b_u_seq_cur = 0;\n    }\n\n    // Remember where we are for \":earlier 1f\" and \":later 1f\".\n    if (curhead->uh_save_nr != 0)\n    {\n\tif (undo)\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;\n\telse\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr;\n    }\n\n    // The timestamp can be the same for multiple changes, just use the one of\n    // the undone/redone change.\n    curbuf->b_u_time_cur = curhead->uh_time;\n\n    unblock_autocmds();\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n}\n\n/*\n * If we deleted or added lines, report the number of less/more lines.\n * Otherwise, report the number of changes (this may be incorrect\n * in some cases, but it's better than nothing).\n */\n    static void\nu_undo_end(\n    int\t\tdid_undo,\t// just did an undo\n    int\t\tabsolute)\t// used \":undo N\"\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t// For \":undo N\" we prefer a \"after #N\" message.\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tadd_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}\n\n/*\n * u_sync: stop adding to the current entry list\n */\n    void\nu_sync(\n    int\t    force)\t// Also sync when no_u_sync is set.\n{\n    // Skip it when already synced or syncing is disabled.\n    if (curbuf->b_u_synced || (!force && no_u_sync > 0))\n\treturn;\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT && im_is_preediting())\n\treturn;\t\t    // XIM is busy, don't break an undo sequence\n#endif\n    if (get_undolevel() < 0)\n\tcurbuf->b_u_synced = TRUE;  // no entries, nothing to do\n    else\n    {\n\tu_getbot();\t\t    // compute ue_bot of previous u_save\n\tcurbuf->b_u_curhead = NULL;\n    }\n}\n\n/*\n * \":undolist\": List the leafs of the undo tree\n */\n    void\nex_undolist(exarg_T *eap UNUSED)\n{\n    garray_T\tga;\n    u_header_T\t*uhp;\n    int\t\tmark;\n    int\t\tnomark;\n    int\t\tchanges = 1;\n    int\t\ti;\n\n    /*\n     * 1: walk the tree to find all leafs, put the info in \"ga\".\n     * 2: sort the lines\n     * 3: display the list\n     */\n    mark = ++lastmark;\n    nomark = ++lastmark;\n    ga_init2(&ga, sizeof(char *), 20);\n\n    uhp = curbuf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\tif (uhp->uh_prev.ptr == NULL && uhp->uh_walk != nomark\n\t\t\t\t\t\t      && uhp->uh_walk != mark)\n\t{\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%6ld %7d  \",\n\t\t\t\t\t\t\tuhp->uh_seq, changes);\n\t    add_time(IObuff + STRLEN(IObuff), IOSIZE - STRLEN(IObuff),\n\t\t\t\t\t\t\t\tuhp->uh_time);\n\t    if (uhp->uh_save_nr > 0)\n\t    {\n\t\twhile (STRLEN(IObuff) < 33)\n\t\t    STRCAT(IObuff, \" \");\n\t\tvim_snprintf_add((char *)IObuff, IOSIZE,\n\t\t\t\t\t\t   \"  %3ld\", uhp->uh_save_nr);\n\t    }\n\t    ((char_u **)(ga.ga_data))[ga.ga_len++] = vim_strsave(IObuff);\n\t}\n\n\tuhp->uh_walk = mark;\n\n\t// go down in the tree if we haven't been there\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_prev.ptr;\n\t    ++changes;\n\t}\n\n\t// go to alternate branch if we haven't been there\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\n\t// go up in the tree if we haven't been there and we are at the\n\t// start of alternate branches\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t&& uhp->uh_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_next.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_next.ptr;\n\t    --changes;\n\t}\n\n\telse\n\t{\n\t    // need to backtrack; mark this node as done\n\t    uhp->uh_walk = nomark;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp = uhp->uh_alt_prev.ptr;\n\t    else\n\t    {\n\t\tuhp = uhp->uh_next.ptr;\n\t\t--changes;\n\t    }\n\t}\n    }\n\n    if (ga.ga_len == 0)\n\tmsg(_(\"Nothing to undo\"));\n    else\n    {\n\tsort_strings((char_u **)ga.ga_data, ga.ga_len);\n\n\tmsg_start();\n\tmsg_puts_attr(_(\"number changes  when               saved\"),\n\t\t\t\t\t\t\t      HL_ATTR(HLF_T));\n\tfor (i = 0; i < ga.ga_len && !got_int; ++i)\n\t{\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_puts(((char **)ga.ga_data)[i]);\n\t}\n\tmsg_end();\n\n\tga_clear_strings(&ga);\n    }\n}\n\n/*\n * \":undojoin\": continue adding to the last entry list\n */\n    void\nex_undojoin(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_u_newhead == NULL)\n\treturn;\t\t    // nothing changed before\n    if (curbuf->b_u_curhead != NULL)\n    {\n\temsg(_(e_undojoin_is_not_allowed_after_undo));\n\treturn;\n    }\n    if (!curbuf->b_u_synced)\n\treturn;\t\t    // already unsynced\n    if (get_undolevel() < 0)\n\treturn;\t\t    // no entries, nothing to do\n    else\n\t// Append next change to the last entry\n\tcurbuf->b_u_synced = FALSE;\n}\n\n/*\n * Called after writing or reloading the file and setting b_changed to FALSE.\n * Now an undo means that the buffer is modified.\n */\n    void\nu_unchanged(buf_T *buf)\n{\n    u_unch_branch(buf->b_u_oldhead);\n    buf->b_did_warn = FALSE;\n}\n\n/*\n * After reloading a buffer which was saved for 'undoreload': Find the first\n * line that was changed and set the cursor there.\n */\n    void\nu_find_first_changed(void)\n{\n    u_header_T\t*uhp = curbuf->b_u_newhead;\n    u_entry_T   *uep;\n    linenr_T\tlnum;\n\n    if (curbuf->b_u_curhead != NULL || uhp == NULL)\n\treturn;  // undid something in an autocmd?\n\n    // Check that the last undo block was for the whole file.\n    uep = uhp->uh_entry;\n    if (uep->ue_top != 0 || uep->ue_bot != 0)\n\treturn;\n\n    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count\n\t\t\t\t\t      && lnum <= uep->ue_size; ++lnum)\n    {\n\tchar_u *p = ml_get_buf(curbuf, lnum, FALSE);\n\n\tif (uep->ue_array[lnum - 1].ul_len != curbuf->b_ml.ml_line_len\n\t\t|| memcmp(p, uep->ue_array[lnum - 1].ul_line, uep->ue_array[lnum - 1].ul_len) != 0)\n\t{\n\t    CLEAR_POS(&(uhp->uh_cursor));\n\t    uhp->uh_cursor.lnum = lnum;\n\t    return;\n\t}\n    }\n    if (curbuf->b_ml.ml_line_count != uep->ue_size)\n    {\n\t// lines added or deleted at the end, put the cursor there\n\tCLEAR_POS(&(uhp->uh_cursor));\n\tuhp->uh_cursor.lnum = lnum;\n    }\n}\n\n/*\n * Increase the write count, store it in the last undo header, what would be\n * used for \"u\".\n */\n    void\nu_update_save_nr(buf_T *buf)\n{\n    u_header_T\t*uhp;\n\n    ++buf->b_u_save_nr_last;\n    buf->b_u_save_nr_cur = buf->b_u_save_nr_last;\n    uhp = buf->b_u_curhead;\n    if (uhp != NULL)\n\tuhp = uhp->uh_next.ptr;\n    else\n\tuhp = buf->b_u_newhead;\n    if (uhp != NULL)\n\tuhp->uh_save_nr = buf->b_u_save_nr_last;\n}\n\n    static void\nu_unch_branch(u_header_T *uhp)\n{\n    u_header_T\t*uh;\n\n    for (uh = uhp; uh != NULL; uh = uh->uh_prev.ptr)\n    {\n\tuh->uh_flags |= UH_CHANGED;\n\tif (uh->uh_alt_next.ptr != NULL)\n\t    u_unch_branch(uh->uh_alt_next.ptr);\t    // recursive\n    }\n}\n\n/*\n * Get pointer to last added entry.\n * If it's not valid, give an error message and return NULL.\n */\n    static u_entry_T *\nu_get_headentry(void)\n{\n    if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)\n    {\n\tiemsg(_(e_undo_list_corrupt));\n\treturn NULL;\n    }\n    return curbuf->b_u_newhead->uh_entry;\n}\n\n/*\n * u_getbot(): compute the line number of the previous u_save\n *\t\tIt is called only when b_u_synced is FALSE.\n */\n    static void\nu_getbot(void)\n{\n    u_entry_T\t*uep;\n    linenr_T\textra;\n\n    uep = u_get_headentry();\t// check for corrupt undo list\n    if (uep == NULL)\n\treturn;\n\n    uep = curbuf->b_u_newhead->uh_getbot_entry;\n    if (uep != NULL)\n    {\n\t/*\n\t * the new ue_bot is computed from the number of lines that has been\n\t * inserted (0 - deleted) since calling u_save. This is equal to the\n\t * old line count subtracted from the current line count.\n\t */\n\textra = curbuf->b_ml.ml_line_count - uep->ue_lcount;\n\tuep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;\n\tif (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)\n\t{\n\t    iemsg(_(e_undo_line_missing));\n\t    uep->ue_bot = uep->ue_top + 1;  // assume all lines deleted, will\n\t\t\t\t\t    // get all the old lines back\n\t\t\t\t\t    // without deleting the current\n\t\t\t\t\t    // ones\n\t}\n\n\tcurbuf->b_u_newhead->uh_getbot_entry = NULL;\n    }\n\n    curbuf->b_u_synced = TRUE;\n}\n\n/*\n * Free one header \"uhp\" and its entry list and adjust the pointers.\n */\n    static void\nu_freeheader(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t// if not NULL reset when freeing this header\n{\n    u_header_T\t    *uhap;\n\n    // When there is an alternate redo list free that branch completely,\n    // because we can never go there.\n    if (uhp->uh_alt_next.ptr != NULL)\n\tu_freebranch(buf, uhp->uh_alt_next.ptr, uhpp);\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    // Update the links in the list to remove the header.\n    if (uhp->uh_next.ptr == NULL)\n\tbuf->b_u_oldhead = uhp->uh_prev.ptr;\n    else\n\tuhp->uh_next.ptr->uh_prev.ptr = uhp->uh_prev.ptr;\n\n    if (uhp->uh_prev.ptr == NULL)\n\tbuf->b_u_newhead = uhp->uh_next.ptr;\n    else\n\tfor (uhap = uhp->uh_prev.ptr; uhap != NULL;\n\t\t\t\t\t\t uhap = uhap->uh_alt_next.ptr)\n\t    uhap->uh_next.ptr = uhp->uh_next.ptr;\n\n    u_freeentries(buf, uhp, uhpp);\n}\n\n/*\n * Free an alternate branch and any following alternate branches.\n */\n    static void\nu_freebranch(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t// if not NULL reset when freeing this header\n{\n    u_header_T\t    *tofree, *next;\n\n    // If this is the top branch we may need to use u_freeheader() to update\n    // all the pointers.\n    if (uhp == buf->b_u_oldhead)\n    {\n\twhile (buf->b_u_oldhead != NULL)\n\t    u_freeheader(buf, buf->b_u_oldhead, uhpp);\n\treturn;\n    }\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    next = uhp;\n    while (next != NULL)\n    {\n\ttofree = next;\n\tif (tofree->uh_alt_next.ptr != NULL)\n\t    u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);   // recursive\n\tnext = tofree->uh_prev.ptr;\n\tu_freeentries(buf, tofree, uhpp);\n    }\n}\n\n/*\n * Free all the undo entries for one header and the header itself.\n * This means that \"uhp\" is invalid when returning.\n */\n    static void\nu_freeentries(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t// if not NULL reset when freeing this header\n{\n    u_entry_T\t    *uep, *nuep;\n\n    // Check for pointers to the header that become invalid now.\n    if (buf->b_u_curhead == uhp)\n\tbuf->b_u_curhead = NULL;\n    if (buf->b_u_newhead == uhp)\n\tbuf->b_u_newhead = NULL;  // freeing the newest entry\n    if (uhpp != NULL && uhp == *uhpp)\n\t*uhpp = NULL;\n\n    for (uep = uhp->uh_entry; uep != NULL; uep = nuep)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n    }\n\n#ifdef U_DEBUG\n    uhp->uh_magic = 0;\n#endif\n    vim_free((char_u *)uhp);\n    --buf->b_u_numhead;\n}\n\n/*\n * free entry 'uep' and 'n' lines in uep->ue_array[]\n */\n    static void\nu_freeentry(u_entry_T *uep, long n)\n{\n    while (n > 0)\n\tvim_free(uep->ue_array[--n].ul_line);\n    vim_free((char_u *)uep->ue_array);\n#ifdef U_DEBUG\n    uep->ue_magic = 0;\n#endif\n    vim_free((char_u *)uep);\n}\n\n/*\n * invalidate the undo buffer; called when storage has already been released\n */\n    void\nu_clearall(buf_T *buf)\n{\n    buf->b_u_newhead = buf->b_u_oldhead = buf->b_u_curhead = NULL;\n    buf->b_u_synced = TRUE;\n    buf->b_u_numhead = 0;\n    buf->b_u_line_ptr.ul_line = NULL;\n    buf->b_u_line_ptr.ul_len = 0;\n    buf->b_u_line_lnum = 0;\n}\n\n/*\n * Save the line \"lnum\" for the \"U\" command.\n */\n    static void\nu_saveline(linenr_T lnum)\n{\n    if (lnum == curbuf->b_u_line_lnum)\t    // line is already saved\n\treturn;\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count) // should never happen\n\treturn;\n    u_clearline();\n    curbuf->b_u_line_lnum = lnum;\n    if (curwin->w_cursor.lnum == lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    else\n\tcurbuf->b_u_line_colnr = 0;\n    if (u_save_line(&curbuf->b_u_line_ptr, lnum) == FAIL)\n\tdo_outofmem_msg((long_u)0);\n}\n\n/*\n * clear the line saved for the \"U\" command\n * (this is used externally for crossing a line while in insert mode)\n */\n    void\nu_clearline(void)\n{\n    if (curbuf->b_u_line_ptr.ul_line != NULL)\n    {\n\tVIM_CLEAR(curbuf->b_u_line_ptr.ul_line);\n\tcurbuf->b_u_line_ptr.ul_len = 0;\n\tcurbuf->b_u_line_lnum = 0;\n    }\n}\n\n/*\n * Implementation of the \"U\" command.\n * Differentiation from vi: \"U\" can be undone with the next \"U\".\n * We also allow the cursor to be in another line.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nu_undoline(void)\n{\n    colnr_T\tt;\n    undoline_T  oldp;\n\n    if (undo_off)\n\treturn;\n\n    if (curbuf->b_u_line_ptr.ul_line == NULL\n\t\t\t|| curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // first save the line for the 'u' command\n    if (u_savecommon(curbuf->b_u_line_lnum - 1,\n\t\t       curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)\n\treturn;\n    if (u_save_line(&oldp, curbuf->b_u_line_lnum) == FAIL)\n    {\n\tdo_outofmem_msg((long_u)0);\n\treturn;\n    }\n    ml_replace_len(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr.ul_line,\n\t\t\t\t     curbuf->b_u_line_ptr.ul_len, TRUE, FALSE);\n    changed_bytes(curbuf->b_u_line_lnum, 0);\n    curbuf->b_u_line_ptr = oldp;\n\n    t = curbuf->b_u_line_colnr;\n    if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    curwin->w_cursor.col = t;\n    curwin->w_cursor.lnum = curbuf->b_u_line_lnum;\n    check_cursor_col();\n}\n\n/*\n * Free all allocated memory blocks for the buffer 'buf'.\n */\n    void\nu_blockfree(buf_T *buf)\n{\n    while (buf->b_u_oldhead != NULL)\n\tu_freeheader(buf, buf->b_u_oldhead, NULL);\n    vim_free(buf->b_u_line_ptr.ul_line);\n}\n\n/*\n * Check if the 'modified' flag is set, or 'ff' has changed (only need to\n * check the first character, because it can only be \"dos\", \"unix\" or \"mac\").\n * \"nofile\" and \"scratch\" type buffers are considered to always be unchanged.\n * Also considers a buffer changed when a terminal window contains a running\n * job.\n */\n    int\nbufIsChanged(buf_T *buf)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\treturn TRUE;\n#endif\n    return bufIsChangedNotTerm(buf);\n}\n\n/*\n * Return TRUE if any buffer has changes.  Also buffers that are not written.\n */\n    int\nanyBufIsChanged(void)\n{\n    buf_T *buf;\n\n    FOR_ALL_BUFFERS(buf)\n\tif (bufIsChanged(buf))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Like bufIsChanged() but ignoring a terminal window.\n */\n    int\nbufIsChangedNotTerm(buf_T *buf)\n{\n    // In a \"prompt\" buffer we do respect 'modified', so that we can control\n    // closing the window by setting or resetting that option.\n    return (!bt_dontwrite(buf) || bt_prompt(buf))\n\t&& (buf->b_changed || file_ff_differs(buf, TRUE));\n}\n\n    int\ncurbufIsChanged(void)\n{\n    return bufIsChanged(curbuf);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * For undotree(): Append the list of undo blocks at \"first_uhp\" to \"list\".\n * Recursive.\n */\n    static void\nu_eval_tree(u_header_T *first_uhp, list_T *list)\n{\n    u_header_T  *uhp = first_uhp;\n    dict_T\t*dict;\n\n    while (uhp != NULL)\n    {\n\tdict = dict_alloc();\n\tif (dict == NULL)\n\t    return;\n\tdict_add_number(dict, \"seq\", uhp->uh_seq);\n\tdict_add_number(dict, \"time\", (long)uhp->uh_time);\n\tif (uhp == curbuf->b_u_newhead)\n\t    dict_add_number(dict, \"newhead\", 1);\n\tif (uhp == curbuf->b_u_curhead)\n\t    dict_add_number(dict, \"curhead\", 1);\n\tif (uhp->uh_save_nr > 0)\n\t    dict_add_number(dict, \"save\", uhp->uh_save_nr);\n\n\tif (uhp->uh_alt_next.ptr != NULL)\n\t{\n\t    list_T\t*alt_list = list_alloc();\n\n\t    if (alt_list != NULL)\n\t    {\n\t\t// Recursive call to add alternate undo tree.\n\t\tu_eval_tree(uhp->uh_alt_next.ptr, alt_list);\n\t\tdict_add_list(dict, \"alt\", alt_list);\n\t    }\n\t}\n\n\tlist_append_dict(list, dict);\n\tuhp = uhp->uh_prev.ptr;\n    }\n}\n\n/*\n * \"undofile(name)\" function\n */\n    void\nf_undofile(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->v_type = VAR_STRING;\n#ifdef FEAT_PERSISTENT_UNDO\n    {\n\tchar_u *fname = tv_get_string(&argvars[0]);\n\n\tif (*fname == NUL)\n\t{\n\t    // If there is no file name there will be no undo file.\n\t    rettv->vval.v_string = NULL;\n\t}\n\telse\n\t{\n\t    char_u *ffname = FullName_save(fname, TRUE);\n\n\t    if (ffname != NULL)\n\t\trettv->vval.v_string = u_get_undo_file_name(ffname, FALSE);\n\t    vim_free(ffname);\n\t}\n    }\n#else\n    rettv->vval.v_string = NULL;\n#endif\n}\n#ifdef FEAT_PERSISTENT_UNDO\n/*\n * Reset undofile option and delete the undofile\n */\n    void\nu_undofile_reset_and_delete(buf_T *buf)\n{\n    char_u *file_name;\n\n    if (!buf->b_p_udf)\n\treturn;\n\n    file_name = u_get_undo_file_name(buf->b_ffname, TRUE);\n    if (file_name != NULL)\n    {\n\tmch_remove(file_name);\n\tvim_free(file_name);\n    }\n\n    set_option_value((char_u *)\"undofile\", 0L, NULL, OPT_LOCAL);\n}\n #endif\n\n/*\n * \"undotree()\" function\n */\n    void\nf_undotree(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    if (rettv_dict_alloc(rettv) == OK)\n    {\n\tdict_T *dict = rettv->vval.v_dict;\n\tlist_T *list;\n\n\tdict_add_number(dict, \"synced\", (long)curbuf->b_u_synced);\n\tdict_add_number(dict, \"seq_last\", curbuf->b_u_seq_last);\n\tdict_add_number(dict, \"save_last\", (long)curbuf->b_u_save_nr_last);\n\tdict_add_number(dict, \"seq_cur\", curbuf->b_u_seq_cur);\n\tdict_add_number(dict, \"time_cur\", (long)curbuf->b_u_time_cur);\n\tdict_add_number(dict, \"save_cur\", (long)curbuf->b_u_save_nr_cur);\n\n\tlist = list_alloc();\n\tif (list != NULL)\n\t{\n\t    u_eval_tree(curbuf->b_u_oldhead, list);\n\t    dict_add_list(dict, \"entries\", list);\n\t}\n    }\n}\n\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/testdir/test_visual.vim", "src/undo.c", "src/version.c"], "buggy_code_start_loc": [1341, 3031, 752], "buggy_code_end_loc": [1341, 3031, 752], "fixing_code_start_loc": [1342, 3032, 753], "fixing_code_end_loc": [1357, 3034, 755], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-0368", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-26T18:15:08.077", "lastModified": "2022-11-09T03:52:57.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Una Lectura fuera de l\u00edmites en el repositorio de GitHub vim/vim anterior a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4217", "matchCriteriaId": "5BF781F0-D4CE-4C79-8019-161DF77ED328"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndExcluding": "12.6", "matchCriteriaId": "7B7BC361-3A04-4C88-A3AE-82B9993A73A0"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/43", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/8d02ce1ed75d008c34a5c9aaa51b67cbb9d33baa", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/bca9ce1f-400a-4bf9-9207-3f3187cb3fa9", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213444", "source": "security@huntr.dev", "tags": ["Vendor Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/8d02ce1ed75d008c34a5c9aaa51b67cbb9d33baa"}}