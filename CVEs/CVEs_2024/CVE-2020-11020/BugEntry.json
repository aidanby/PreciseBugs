{"buggy_code": ["module Faye\n  class Server\n\n    autoload :Socket, File.join(ROOT, 'faye', 'protocol', 'socket')\n\n    include Logging\n    include Extensible\n\n    META_METHODS = %w[handshake connect disconnect subscribe unsubscribe]\n\n    attr_reader :engine\n\n    def initialize(options = {})\n      @options    = options || {}\n      engine_opts = @options[:engine] || {}\n      engine_opts[:timeout] = @options[:timeout]\n      @engine     = Faye::Engine.get(engine_opts)\n\n      info('Created new server: ?', @options)\n    end\n\n    def close\n      @engine.close\n    end\n\n    def open_socket(client_id, socket, env)\n      return unless client_id and socket\n      @engine.open_socket(client_id, Socket.new(self, socket, env))\n    end\n\n    def close_socket(client_id, close = true)\n      @engine.flush_connection(client_id, close)\n    end\n\n    def process(messages, env, &callback)\n      local    = env.nil?\n      messages = [messages].flatten\n      info('Processing messages: ? (local: ?)', messages, local)\n\n      return callback.call([]) if messages.size == 0\n      processed, responses = 0, []\n\n      gather_replies = lambda do |replies|\n        responses.concat(replies)\n        processed += 1\n        responses.compact!\n        info('Returning replies: ?', responses)\n        callback.call(responses) if processed == messages.size\n      end\n\n      handle_reply = lambda do |replies|\n        extended, expected = 0, replies.size\n        gather_replies.call(replies) if expected == 0\n\n        replies.each_with_index do |reply, i|\n          debug('Processing reply: ?', reply)\n          pipe_through_extensions(:outgoing, reply, env) do |message|\n            replies[i] = message\n            extended  += 1\n            gather_replies.call(replies) if extended == expected\n          end\n        end\n      end\n\n      messages.each do |message|\n        pipe_through_extensions(:incoming, message, env) do |piped_message|\n          handle(piped_message, local, &handle_reply)\n        end\n      end\n    end\n\n    def make_response(message)\n      response = {}\n\n      response['id']       = message['id']       if message['id']\n      response['clientId'] = message['clientId'] if message['clientId']\n      response['channel']  = message['channel']  if message['channel']\n      response['error']    = message['error']    if message['error']\n\n      response['successful'] = !response['error']\n      response\n    end\n\n    def handle(message, local = false, &callback)\n      return callback.call([]) if !message\n      info('Handling message: ? (local: ?)', message, local)\n\n      channel_name = message['channel']\n      error        = message['error']\n\n      return handle_meta(message, local, &callback) if Channel.meta?(channel_name)\n\n      if Grammar::CHANNEL_NAME !~ channel_name\n        error = Faye::Error.channel_invalid(channel_name)\n      end\n\n      if message['data'].nil?\n        error = Faye::Error.parameter_missing('data')\n      end\n\n      @engine.publish(message) unless error\n\n      response = make_response(message)\n      response['error'] = error if error\n      response['successful'] = !response['error']\n      callback.call([response])\n    end\n\n    def handle_meta(message, local, &callback)\n      method = Channel.parse(message['channel'])[1]\n\n      unless META_METHODS.include?(method)\n        response = make_response(message)\n        response['error'] = Faye::Error.channel_forbidden(message['channel'])\n        response['successful'] = false\n        return callback.call([response])\n      end\n\n      __send__(method, message, local) do |responses|\n        responses = [responses].flatten\n        responses.each { |r| advize(r, message['connectionType']) }\n        callback.call(responses)\n      end\n    end\n\n    def advize(response, connection_type)\n      return unless [Channel::HANDSHAKE, Channel::CONNECT].include?(response['channel'])\n\n      if connection_type == 'eventsource'\n        interval = (@engine.timeout * 1000).floor\n        timeout  = 0\n      else\n        interval = (@engine.interval * 1000).floor\n        timeout  = (@engine.timeout * 1000).floor\n      end\n\n      advice = response['advice'] ||= {}\n      if response['error']\n        advice['reconnect'] ||= 'handshake'\n      else\n        advice['reconnect'] ||= 'retry'\n        advice['interval']  ||= interval\n        advice['timeout']   ||= timeout\n      end\n    end\n\n    # MUST contain  * version\n    #               * supportedConnectionTypes\n    # MAY contain   * minimumVersion\n    #               * ext\n    #               * id\n    def handshake(message, local = false, &callback)\n      response = make_response(message)\n      response['version'] = BAYEUX_VERSION\n\n      response['error'] = Error.parameter_missing('version') if message['version'].nil?\n\n      client_conns = message['supportedConnectionTypes']\n\n      response['supportedConnectionTypes'] = CONNECTION_TYPES\n\n      if client_conns\n        common_conns = client_conns.select { |c| CONNECTION_TYPES.include?(c) }\n        response['error'] = Error.conntype_mismatch(*client_conns) if common_conns.empty?\n      else\n        response['error'] = Error.parameter_missing('supportedConnectionTypes')\n      end\n\n      response['successful'] = response['error'].nil?\n      return callback.call(response) unless response['successful']\n\n      @engine.create_client do |client_id|\n        response['clientId'] = client_id\n        callback.call(response)\n      end\n    end\n\n    # MUST contain  * clientId\n    #               * connectionType\n    # MAY contain   * ext\n    #               * id\n    def connect(message, local = false, &callback)\n      response        = make_response(message)\n      client_id       = message['clientId']\n      connection_type = message['connectionType']\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n\n        unless CONNECTION_TYPES.include?(connection_type)\n          response['error'] = Error.conntype_mismatch(connection_type)\n        end\n\n        response['error'] = Error.parameter_missing('connectionType') if connection_type.nil?\n\n        response['successful'] = response['error'].nil?\n\n        if !response['successful']\n          response.delete('clientId')\n          next callback.call(response)\n        end\n\n        if message['connectionType'] == 'eventsource'\n          message['advice'] ||= {}\n          message['advice']['timeout'] = 0\n        end\n\n        @engine.connect(response['clientId'], message['advice']) do |events|\n          callback.call([response] + events)\n        end\n      end\n    end\n\n    # MUST contain  * clientId\n    # MAY contain   * ext\n    #               * id\n    def disconnect(message, local = false, &callback)\n      response   = make_response(message)\n      client_id  = message['clientId']\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n\n        response['successful'] = response['error'].nil?\n        response.delete('clientId') unless response['successful']\n\n        @engine.destroy_client(client_id) if response['successful']\n        callback.call(response)\n      end\n    end\n\n    # MUST contain  * clientId\n    #               * subscription\n    # MAY contain   * ext\n    #               * id\n    def subscribe(message, local = false, &callback)\n      response     = make_response(message)\n      client_id    = message['clientId']\n      subscription = [message['subscription']].flatten\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n        response['error'] = Error.parameter_missing('subscription') if message['subscription'].nil?\n\n        response['subscription'] = message['subscription'] || []\n\n        subscription.each do |channel|\n          next if response['error']\n          response['error'] = Error.channel_forbidden(channel) unless local or Channel.subscribable?(channel)\n          response['error'] = Error.channel_invalid(channel) unless Channel.valid?(channel)\n\n          next if response['error']\n          @engine.subscribe(client_id, channel)\n        end\n\n        response['successful'] = response['error'].nil?\n        callback.call(response)\n      end\n    end\n\n    # MUST contain  * clientId\n    #               * subscription\n    # MAY contain   * ext\n    #               * id\n    def unsubscribe(message, local = false, &callback)\n      response     = make_response(message)\n      client_id    = message['clientId']\n      subscription = [message['subscription']].flatten\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n        response['error'] = Error.parameter_missing('subscription') if message['subscription'].nil?\n\n        response['subscription'] = message['subscription'] || []\n\n        subscription.each do |channel|\n          next if response['error']\n          response['error'] = Error.channel_forbidden(channel) unless local or Channel.subscribable?(channel)\n          response['error'] = Error.channel_invalid(channel) unless Channel.valid?(channel)\n\n          next if response['error']\n          @engine.unsubscribe(client_id, channel)\n        end\n\n        response['successful'] = response['error'].nil?\n        callback.call(response)\n      end\n    end\n\n  end\nend\n", "var jstest = require(\"jstest\").Test\n\nvar Engine = require(\"../../../src/engines/proxy\"),\n    Server = require(\"../../../src/protocol/server\")\n\njstest.describe(\"Server extensions\", function() { with(this) {\n    before(function() { with(this) {\n    this.engine = {}\n    stub(Engine, \"get\").returns(engine)\n    this.server = new Server()\n  }})\n\n  describe(\"with an incoming extension installed\", function() { with(this) {\n    before(function() { with(this) {\n      var extension = {\n        incoming: function(message, callback) {\n          message.ext = {auth: \"password\"}\n          callback(message)\n        }\n      }\n      server.addExtension(extension)\n      this.message = {channel: \"/foo\", data: \"hello\"}\n    }})\n\n    it(\"passes incoming messages through the extension\", function() { with(this) {\n      expect(engine, \"publish\").given({channel: \"/foo\", data: \"hello\", ext: {auth: \"password\"}})\n      server.process(message, false, function() {})\n    }})\n\n    it(\"does not pass outgoing messages through the extension\", function() { with(this) {\n      stub(server, \"handshake\").yields([message])\n      stub(engine, \"publish\")\n      var response = null\n      server.process({channel: \"/meta/handshake\"}, false, function(r) { response = r })\n      assertEqual( [{channel: \"/foo\", data: \"hello\"}], response )\n    }})\n  }})\n\n  describe(\"with an outgoing extension installed\", function() { with(this) {\n    before(function() { with(this) {\n      var extension = {\n        outgoing: function(message, callback) {\n          message.ext = {auth: \"password\"}\n          callback(message)\n        }\n      }\n      server.addExtension(extension)\n      this.message = {channel: \"/foo\", data: \"hello\"}\n    }})\n\n    it(\"does not pass incoming messages through the extension\", function() { with(this) {\n      expect(engine, \"publish\").given({channel: \"/foo\", data: \"hello\"})\n      server.process(message, false, function() {})\n    }})\n\n    it(\"passes outgoing messages through the extension\", function() { with(this) {\n      stub(server, \"handshake\").yields([message])\n      stub(engine, \"publish\")\n      var response = null\n      server.process({channel: \"/meta/handshake\"}, false, function(r) { response = r })\n      assertEqual( [{channel: \"/foo\", data: \"hello\", ext: {auth: \"password\"}}], response )\n    }})\n  }})\n}})\n", "require \"spec_helper\"\n\ndescribe \"server extensions\" do\n  let(:engine) do\n    engine = double \"engine\"\n    engine.stub(:interval).and_return(0)\n    engine.stub(:timeout).and_return(60)\n    engine\n  end\n\n  let(:server)  { Faye::Server.new }\n  let(:message) { {\"channel\" => \"/foo\", \"data\" => \"hello\"} }\n\n  before do\n    Faye::Engine.stub(:get).and_return engine\n  end\n\n  describe \"with an incoming extension installed\" do\n    before do\n      extension = Class.new do\n        def incoming(message, callback)\n          message[\"ext\"] = {\"auth\" => \"password\"}\n          callback.call(message)\n        end\n      end\n      server.add_extension(extension.new)\n    end\n\n    it \"passes incoming messages through the extension\" do\n      engine.should_receive(:publish).with({\"channel\" => \"/foo\", \"data\" => \"hello\", \"ext\" => {\"auth\" => \"password\"}})\n      server.process(message, false) {}\n    end\n\n    it \"does not pass outgoing messages through the extension\" do\n      server.stub(:handshake).and_yield(message)\n      engine.stub(:publish)\n      response = nil\n      server.process({\"channel\" => \"/meta/handshake\"}, false) { |r| response = r }\n      response.should == [{\"channel\" => \"/foo\", \"data\" => \"hello\"}]\n    end\n  end\n\n  describe \"with an outgoing extension installed\" do\n    before do\n      extension = Class.new do\n        def outgoing(message, callback)\n          message[\"ext\"] = {\"auth\" => \"password\"}\n          callback.call(message)\n        end\n      end\n      server.add_extension(extension.new)\n    end\n\n    it \"does not pass incoming messages through the extension\" do\n      engine.should_receive(:publish).with({\"channel\" => \"/foo\", \"data\" => \"hello\"})\n      server.process(message, false) {}\n    end\n\n    it \"passes outgoing messages through the extension\" do\n      server.stub(:handshake).and_yield(message)\n      engine.stub(:publish)\n      response = nil\n      server.process({\"channel\" => \"/meta/handshake\"}, false) { |r| response = r }\n      response.should == [{\"channel\" => \"/foo\", \"data\" => \"hello\", \"ext\" => {\"auth\" => \"password\"}}]\n    end\n  end\nend\n", "'use strict';\n\nvar Class      = require('../util/class'),\n    array      = require('../util/array'),\n    extend     = require('../util/extend'),\n    constants  = require('../util/constants'),\n    Logging    = require('../mixins/logging'),\n    Engine     = require('../engines/proxy'),\n    Channel    = require('./channel'),\n    Error      = require('./error'),\n    Extensible = require('./extensible'),\n    Grammar    = require('./grammar'),\n    Socket     = require('./socket');\n\nvar Server = Class({ className: 'Server',\n  META_METHODS: ['handshake', 'connect', 'disconnect', 'subscribe', 'unsubscribe'],\n\n  initialize: function(options) {\n    this._options  = options || {};\n    var engineOpts = this._options.engine || {};\n    engineOpts.timeout = this._options.timeout;\n    this._engine   = Engine.get(engineOpts);\n\n    this.info('Created new server: ?', this._options);\n  },\n\n  close: function() {\n    return this._engine.close();\n  },\n\n  openSocket: function(clientId, socket, request) {\n    if (!clientId || !socket) return;\n    this._engine.openSocket(clientId, new Socket(this, socket, request));\n  },\n\n  closeSocket: function(clientId, close) {\n    this._engine.flushConnection(clientId, close);\n  },\n\n  process: function(messages, request, callback, context) {\n    var local = (request === null);\n\n    messages = [].concat(messages);\n    this.info('Processing messages: ? (local: ?)', messages, local);\n\n    if (messages.length === 0) return callback.call(context, []);\n    var processed = 0, responses = [], self = this;\n\n    var gatherReplies = function(replies) {\n      responses = responses.concat(replies);\n      processed += 1;\n      if (processed < messages.length) return;\n\n      var n = responses.length;\n      while (n--) {\n        if (!responses[n]) responses.splice(n,1);\n      }\n      self.info('Returning replies: ?', responses);\n      callback.call(context, responses);\n    };\n\n    var handleReply = function(replies) {\n      var extended = 0, expected = replies.length;\n      if (expected === 0) gatherReplies(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        this.debug('Processing reply: ?', replies[i]);\n        (function(index) {\n          self.pipeThroughExtensions('outgoing', replies[index], request, function(message) {\n            replies[index] = message;\n            extended += 1;\n            if (extended === expected) gatherReplies(replies);\n          });\n        })(i);\n      }\n    };\n\n    for (var i = 0, n = messages.length; i < n; i++) {\n      this.pipeThroughExtensions('incoming', messages[i], request, function(pipedMessage) {\n        this._handle(pipedMessage, local, handleReply, this);\n      }, this);\n    }\n  },\n\n  _makeResponse: function(message) {\n    var response = {};\n\n    if (message.id)       response.id       = message.id;\n    if (message.clientId) response.clientId = message.clientId;\n    if (message.channel)  response.channel  = message.channel;\n    if (message.error)    response.error    = message.error;\n\n    response.successful = !response.error;\n    return response;\n  },\n\n  _handle: function(message, local, callback, context) {\n    if (!message) return callback.call(context, []);\n    this.info('Handling message: ? (local: ?)', message, local);\n\n    var channelName = message.channel,\n        error       = message.error,\n        response;\n\n    if (Channel.isMeta(channelName))\n      return this._handleMeta(message, local, callback, context);\n\n    if (!Grammar.CHANNEL_NAME.test(channelName))\n      error = Error.channelInvalid(channelName);\n\n    if (message.data === undefined)\n      error = Error.parameterMissing('data');\n\n    if (!error) this._engine.publish(message);\n\n    response = this._makeResponse(message);\n    if (error) response.error = error;\n    response.successful = !response.error;\n    callback.call(context, [response]);\n  },\n\n  _handleMeta: function(message, local, callback, context) {\n    var method = Channel.parse(message.channel)[1],\n        response;\n\n    if (array.indexOf(this.META_METHODS, method) < 0) {\n      response = this._makeResponse(message);\n      response.error = Error.channelForbidden(message.channel);\n      response.successful = false;\n      return callback.call(context, [response]);\n    }\n\n    this[method](message, local, function(responses) {\n      responses = [].concat(responses);\n      for (var i = 0, n = responses.length; i < n; i++) this._advize(responses[i], message.connectionType);\n      callback.call(context, responses);\n    }, this);\n  },\n\n  _advize: function(response, connectionType) {\n    if (array.indexOf([Channel.HANDSHAKE, Channel.CONNECT], response.channel) < 0)\n      return;\n\n    var interval, timeout;\n    if (connectionType === 'eventsource') {\n      interval = Math.floor(this._engine.timeout * 1000);\n      timeout  = 0;\n    } else {\n      interval = Math.floor(this._engine.interval * 1000);\n      timeout  = Math.floor(this._engine.timeout * 1000);\n    }\n\n    response.advice = response.advice || {};\n    if (response.error) {\n      extend(response.advice, {reconnect:  'handshake'}, false);\n    } else {\n      extend(response.advice, {\n        reconnect:  'retry',\n        interval:   interval,\n        timeout:    timeout\n      }, false);\n    }\n  },\n\n  // MUST contain  * version\n  //               * supportedConnectionTypes\n  // MAY contain   * minimumVersion\n  //               * ext\n  //               * id\n  handshake: function(message, local, callback, context) {\n    var response = this._makeResponse(message);\n    response.version = constants.BAYEUX_VERSION;\n\n    if (!message.version)\n      response.error = Error.parameterMissing('version');\n\n    var clientConns = message.supportedConnectionTypes,\n        commonConns;\n\n    response.supportedConnectionTypes = constants.CONNECTION_TYPES;\n\n    if (clientConns) {\n      commonConns = array.filter(clientConns, function(conn) {\n        return array.indexOf(constants.CONNECTION_TYPES, conn) >= 0;\n      });\n      if (commonConns.length === 0)\n        response.error = Error.conntypeMismatch(clientConns);\n    } else {\n      response.error = Error.parameterMissing('supportedConnectionTypes');\n    }\n\n    response.successful = !response.error;\n    if (!response.successful) return callback.call(context, response);\n\n    this._engine.createClient(function(clientId) {\n      response.clientId = clientId;\n      callback.call(context, response);\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  //               * connectionType\n  // MAY contain   * ext\n  //               * id\n  connect: function(message, local, callback, context) {\n    var response       = this._makeResponse(message),\n        clientId       = message.clientId,\n        connectionType = message.connectionType;\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)         response.error = Error.clientUnknown(clientId);\n      if (!clientId)       response.error = Error.parameterMissing('clientId');\n\n      if (array.indexOf(constants.CONNECTION_TYPES, connectionType) < 0)\n        response.error = Error.conntypeMismatch(connectionType);\n\n      if (!connectionType) response.error = Error.parameterMissing('connectionType');\n\n      response.successful = !response.error;\n\n      if (!response.successful) {\n        delete response.clientId;\n        return callback.call(context, response);\n      }\n\n      if (message.connectionType === 'eventsource') {\n        message.advice = message.advice || {};\n        message.advice.timeout = 0;\n      }\n      this._engine.connect(response.clientId, message.advice, function(events) {\n        callback.call(context, [response].concat(events));\n      });\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  // MAY contain   * ext\n  //               * id\n  disconnect: function(message, local, callback, context) {\n    var response = this._makeResponse(message),\n        clientId = message.clientId;\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)   response.error = Error.clientUnknown(clientId);\n      if (!clientId) response.error = Error.parameterMissing('clientId');\n\n      response.successful = !response.error;\n      if (!response.successful) delete response.clientId;\n\n      if (response.successful) this._engine.destroyClient(clientId);\n      callback.call(context, response);\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  //               * subscription\n  // MAY contain   * ext\n  //               * id\n  subscribe: function(message, local, callback, context) {\n    var response     = this._makeResponse(message),\n        clientId     = message.clientId,\n        subscription = message.subscription,\n        channel;\n\n    subscription = subscription ? [].concat(subscription) : [];\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)               response.error = Error.clientUnknown(clientId);\n      if (!clientId)             response.error = Error.parameterMissing('clientId');\n      if (!message.subscription) response.error = Error.parameterMissing('subscription');\n\n      response.subscription = message.subscription || [];\n\n      for (var i = 0, n = subscription.length; i < n; i++) {\n        channel = subscription[i];\n\n        if (response.error) break;\n        if (!local && !Channel.isSubscribable(channel)) response.error = Error.channelForbidden(channel);\n        if (!Channel.isValid(channel))                  response.error = Error.channelInvalid(channel);\n\n        if (response.error) break;\n        this._engine.subscribe(clientId, channel);\n      }\n\n      response.successful = !response.error;\n      callback.call(context, response);\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  //               * subscription\n  // MAY contain   * ext\n  //               * id\n  unsubscribe: function(message, local, callback, context) {\n    var response     = this._makeResponse(message),\n        clientId     = message.clientId,\n        subscription = message.subscription,\n        channel;\n\n    subscription = subscription ? [].concat(subscription) : [];\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)               response.error = Error.clientUnknown(clientId);\n      if (!clientId)             response.error = Error.parameterMissing('clientId');\n      if (!message.subscription) response.error = Error.parameterMissing('subscription');\n\n      response.subscription = message.subscription || [];\n\n      for (var i = 0, n = subscription.length; i < n; i++) {\n        channel = subscription[i];\n\n        if (response.error) break;\n        if (!local && !Channel.isSubscribable(channel)) response.error = Error.channelForbidden(channel);\n        if (!Channel.isValid(channel))                  response.error = Error.channelInvalid(channel);\n\n        if (response.error) break;\n        this._engine.unsubscribe(clientId, channel);\n      }\n\n      response.successful = !response.error;\n      callback.call(context, response);\n    }, this);\n  }\n});\n\nServer.create = function(options) {\n  return new Server(options);\n};\n\nextend(Server.prototype, Logging);\nextend(Server.prototype, Extensible);\n\nmodule.exports = Server;\n"], "fixing_code": ["module Faye\n  class Server\n\n    autoload :Socket, File.join(ROOT, 'faye', 'protocol', 'socket')\n\n    include Logging\n    include Extensible\n\n    attr_reader :engine\n\n    def initialize(options = {})\n      @options    = options || {}\n      engine_opts = @options[:engine] || {}\n      engine_opts[:timeout] = @options[:timeout]\n      @engine     = Faye::Engine.get(engine_opts)\n\n      info('Created new server: ?', @options)\n    end\n\n    def close\n      @engine.close\n    end\n\n    def open_socket(client_id, socket, env)\n      return unless client_id and socket\n      @engine.open_socket(client_id, Socket.new(self, socket, env))\n    end\n\n    def close_socket(client_id, close = true)\n      @engine.flush_connection(client_id, close)\n    end\n\n    def process(messages, env, &callback)\n      local    = env.nil?\n      messages = [messages].flatten\n      info('Processing messages: ? (local: ?)', messages, local)\n\n      return callback.call([]) if messages.size == 0\n      processed, responses = 0, []\n\n      gather_replies = lambda do |replies|\n        responses.concat(replies)\n        processed += 1\n        responses.compact!\n        info('Returning replies: ?', responses)\n        callback.call(responses) if processed == messages.size\n      end\n\n      handle_reply = lambda do |replies|\n        extended, expected = 0, replies.size\n        gather_replies.call(replies) if expected == 0\n\n        replies.each_with_index do |reply, i|\n          debug('Processing reply: ?', reply)\n          pipe_through_extensions(:outgoing, reply, env) do |message|\n            replies[i] = message\n            extended  += 1\n            gather_replies.call(replies) if extended == expected\n          end\n        end\n      end\n\n      messages.each do |message|\n        pipe_through_extensions(:incoming, message, env) do |piped_message|\n          handle(piped_message, local, &handle_reply)\n        end\n      end\n    end\n\n    def make_response(message)\n      response = {}\n\n      response['id']       = message['id']       if message['id']\n      response['clientId'] = message['clientId'] if message['clientId']\n      response['channel']  = message['channel']  if message['channel']\n      response['error']    = message['error']    if message['error']\n\n      response['successful'] = !response['error']\n      response\n    end\n\n    def handle(message, local = false, &callback)\n      return callback.call([]) if !message\n      info('Handling message: ? (local: ?)', message, local)\n\n      channel_name = message['channel']\n      error        = message['error']\n\n      return handle_meta(message, local, &callback) if Channel.meta?(channel_name)\n\n      if Grammar::CHANNEL_NAME !~ channel_name\n        error = Faye::Error.channel_invalid(channel_name)\n      end\n\n      if message['data'].nil?\n        error = Faye::Error.parameter_missing('data')\n      end\n\n      @engine.publish(message) unless error\n\n      response = make_response(message)\n      response['error'] = error if error\n      response['successful'] = !response['error']\n      callback.call([response])\n    end\n\n    def handle_meta(message, local, &callback)\n      method = method_for(message)\n\n      unless method\n        response = make_response(message)\n        response['error'] = Faye::Error.channel_forbidden(message['channel'])\n        response['successful'] = false\n        return callback.call([response])\n      end\n\n      __send__(method, message, local) do |responses|\n        responses = [responses].flatten\n        responses.each { |r| advize(r, message['connectionType']) }\n        callback.call(responses)\n      end\n    end\n\n    def method_for(message)\n      case message['channel']\n      when Channel::HANDSHAKE   then :handshake\n      when Channel::CONNECT     then :connect\n      when Channel::SUBSCRIBE   then :subscribe\n      when Channel::UNSUBSCRIBE then :unsubscribe\n      when Channel::DISCONNECT  then :disconnect\n      end\n    end\n\n    def advize(response, connection_type)\n      return unless [Channel::HANDSHAKE, Channel::CONNECT].include?(response['channel'])\n\n      if connection_type == 'eventsource'\n        interval = (@engine.timeout * 1000).floor\n        timeout  = 0\n      else\n        interval = (@engine.interval * 1000).floor\n        timeout  = (@engine.timeout * 1000).floor\n      end\n\n      advice = response['advice'] ||= {}\n      if response['error']\n        advice['reconnect'] ||= 'handshake'\n      else\n        advice['reconnect'] ||= 'retry'\n        advice['interval']  ||= interval\n        advice['timeout']   ||= timeout\n      end\n    end\n\n    # MUST contain  * version\n    #               * supportedConnectionTypes\n    # MAY contain   * minimumVersion\n    #               * ext\n    #               * id\n    def handshake(message, local = false, &callback)\n      response = make_response(message)\n      response['version'] = BAYEUX_VERSION\n\n      response['error'] = Error.parameter_missing('version') if message['version'].nil?\n\n      client_conns = message['supportedConnectionTypes']\n\n      response['supportedConnectionTypes'] = CONNECTION_TYPES\n\n      if client_conns\n        common_conns = client_conns.select { |c| CONNECTION_TYPES.include?(c) }\n        response['error'] = Error.conntype_mismatch(*client_conns) if common_conns.empty?\n      else\n        response['error'] = Error.parameter_missing('supportedConnectionTypes')\n      end\n\n      response['successful'] = response['error'].nil?\n      return callback.call(response) unless response['successful']\n\n      @engine.create_client do |client_id|\n        response['clientId'] = client_id\n        callback.call(response)\n      end\n    end\n\n    # MUST contain  * clientId\n    #               * connectionType\n    # MAY contain   * ext\n    #               * id\n    def connect(message, local = false, &callback)\n      response        = make_response(message)\n      client_id       = message['clientId']\n      connection_type = message['connectionType']\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n\n        unless CONNECTION_TYPES.include?(connection_type)\n          response['error'] = Error.conntype_mismatch(connection_type)\n        end\n\n        response['error'] = Error.parameter_missing('connectionType') if connection_type.nil?\n\n        response['successful'] = response['error'].nil?\n\n        if !response['successful']\n          response.delete('clientId')\n          next callback.call(response)\n        end\n\n        if message['connectionType'] == 'eventsource'\n          message['advice'] ||= {}\n          message['advice']['timeout'] = 0\n        end\n\n        @engine.connect(response['clientId'], message['advice']) do |events|\n          callback.call([response] + events)\n        end\n      end\n    end\n\n    # MUST contain  * clientId\n    # MAY contain   * ext\n    #               * id\n    def disconnect(message, local = false, &callback)\n      response   = make_response(message)\n      client_id  = message['clientId']\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n\n        response['successful'] = response['error'].nil?\n        response.delete('clientId') unless response['successful']\n\n        @engine.destroy_client(client_id) if response['successful']\n        callback.call(response)\n      end\n    end\n\n    # MUST contain  * clientId\n    #               * subscription\n    # MAY contain   * ext\n    #               * id\n    def subscribe(message, local = false, &callback)\n      response     = make_response(message)\n      client_id    = message['clientId']\n      subscription = [message['subscription']].flatten\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n        response['error'] = Error.parameter_missing('subscription') if message['subscription'].nil?\n\n        response['subscription'] = message['subscription'] || []\n\n        subscription.each do |channel|\n          next if response['error']\n          response['error'] = Error.channel_forbidden(channel) unless local or Channel.subscribable?(channel)\n          response['error'] = Error.channel_invalid(channel) unless Channel.valid?(channel)\n\n          next if response['error']\n          @engine.subscribe(client_id, channel)\n        end\n\n        response['successful'] = response['error'].nil?\n        callback.call(response)\n      end\n    end\n\n    # MUST contain  * clientId\n    #               * subscription\n    # MAY contain   * ext\n    #               * id\n    def unsubscribe(message, local = false, &callback)\n      response     = make_response(message)\n      client_id    = message['clientId']\n      subscription = [message['subscription']].flatten\n\n      @engine.client_exists(client_id) do |exists|\n        response['error'] = Error.client_unknown(client_id) unless exists\n        response['error'] = Error.parameter_missing('clientId') if client_id.nil?\n        response['error'] = Error.parameter_missing('subscription') if message['subscription'].nil?\n\n        response['subscription'] = message['subscription'] || []\n\n        subscription.each do |channel|\n          next if response['error']\n          response['error'] = Error.channel_forbidden(channel) unless local or Channel.subscribable?(channel)\n          response['error'] = Error.channel_invalid(channel) unless Channel.valid?(channel)\n\n          next if response['error']\n          @engine.unsubscribe(client_id, channel)\n        end\n\n        response['successful'] = response['error'].nil?\n        callback.call(response)\n      end\n    end\n\n  end\nend\n", "var jstest = require(\"jstest\").Test\n\nvar Engine = require(\"../../../src/engines/proxy\"),\n    Server = require(\"../../../src/protocol/server\")\n\njstest.describe(\"Server extensions\", function() { with(this) {\n    before(function() { with(this) {\n    this.engine = {}\n    stub(Engine, \"get\").returns(engine)\n    this.server = new Server()\n  }})\n\n  describe(\"with an incoming extension installed\", function() { with(this) {\n    before(function() { with(this) {\n      var extension = {\n        incoming: function(message, callback) {\n          message.ext = {auth: \"password\"}\n          callback(message)\n        }\n      }\n      server.addExtension(extension)\n      this.message = {channel: \"/foo\", data: \"hello\"}\n    }})\n\n    it(\"passes incoming messages through the extension\", function() { with(this) {\n      expect(engine, \"publish\").given({channel: \"/foo\", data: \"hello\", ext: {auth: \"password\"}})\n      server.process(message, false, function() {})\n    }})\n\n    it(\"does not pass outgoing messages through the extension\", function() { with(this) {\n      stub(server, \"handshake\").yields([message])\n      stub(engine, \"publish\")\n      var response = null\n      server.process({channel: \"/meta/handshake\"}, false, function(r) { response = r })\n      assertEqual( [{channel: \"/foo\", data: \"hello\"}], response )\n    }})\n  }})\n\n  describe(\"with subscription auth installed\", function() { with(this) {\n    before(function() { with(this) {\n      var extension = {\n        incoming: function(message, callback) {\n          if (message.channel === \"/meta/subscribe\" && !message.auth) {\n            message.error = \"Invalid auth\"\n          }\n          callback(message)\n        }\n      }\n      server.addExtension(extension)\n    }})\n\n    it(\"does not subscribe using the intended channel\", function() { with(this) {\n      var message = {\n        channel: \"/meta/subscribe\",\n        clientId: \"fakeclientid\",\n        subscription: \"/foo\"\n      }\n      stub(engine, \"clientExists\").yields([true])\n      expect(engine, \"subscribe\").exactly(0)\n      server.process(message, false, function() {})\n    }})\n\n    it(\"does not subscribe using an extended channel\", function() { with(this) {\n      var message = {\n        channel: \"/meta/subscribe/x\",\n        clientId: \"fakeclientid\",\n        subscription: \"/foo\"\n      }\n      stub(engine, \"clientExists\").yields([true])\n      expect(engine, \"subscribe\").exactly(0)\n      server.process(message, false, function() {})\n    }})\n  }})\n\n  describe(\"with an outgoing extension installed\", function() { with(this) {\n    before(function() { with(this) {\n      var extension = {\n        outgoing: function(message, callback) {\n          message.ext = {auth: \"password\"}\n          callback(message)\n        }\n      }\n      server.addExtension(extension)\n      this.message = {channel: \"/foo\", data: \"hello\"}\n    }})\n\n    it(\"does not pass incoming messages through the extension\", function() { with(this) {\n      expect(engine, \"publish\").given({channel: \"/foo\", data: \"hello\"})\n      server.process(message, false, function() {})\n    }})\n\n    it(\"passes outgoing messages through the extension\", function() { with(this) {\n      stub(server, \"handshake\").yields([message])\n      stub(engine, \"publish\")\n      var response = null\n      server.process({channel: \"/meta/handshake\"}, false, function(r) { response = r })\n      assertEqual( [{channel: \"/foo\", data: \"hello\", ext: {auth: \"password\"}}], response )\n    }})\n  }})\n}})\n", "require \"spec_helper\"\n\ndescribe \"server extensions\" do\n  let(:engine) do\n    engine = double \"engine\"\n    engine.stub(:interval).and_return(0)\n    engine.stub(:timeout).and_return(60)\n    engine\n  end\n\n  let(:server)  { Faye::Server.new }\n  let(:message) { {\"channel\" => \"/foo\", \"data\" => \"hello\"} }\n\n  before do\n    Faye::Engine.stub(:get).and_return engine\n  end\n\n  describe \"with an incoming extension installed\" do\n    before do\n      extension = Class.new do\n        def incoming(message, callback)\n          message[\"ext\"] = {\"auth\" => \"password\"}\n          callback.call(message)\n        end\n      end\n      server.add_extension(extension.new)\n    end\n\n    it \"passes incoming messages through the extension\" do\n      engine.should_receive(:publish).with({\"channel\" => \"/foo\", \"data\" => \"hello\", \"ext\" => {\"auth\" => \"password\"}})\n      server.process(message, false) {}\n    end\n\n    it \"does not pass outgoing messages through the extension\" do\n      server.stub(:handshake).and_yield(message)\n      engine.stub(:publish)\n      response = nil\n      server.process({\"channel\" => \"/meta/handshake\"}, false) { |r| response = r }\n      response.should == [{\"channel\" => \"/foo\", \"data\" => \"hello\"}]\n    end\n  end\n\n  describe \"with subscription auth installed\" do\n    before do\n      extension = Class.new do\n        def incoming(message, callback)\n          if message[\"channel\"] == \"/meta/subscribe\" and !message[\"auth\"]\n            message[\"error\"] = \"Invalid auth\"\n          end\n          callback.call(message)\n        end\n      end\n      server.add_extension(extension.new)\n    end\n\n    it \"does not subscribe using the intended channel\" do\n      message = {\n        \"channel\" => \"/meta/subscribe\",\n        \"clientId\" => \"fakeclientid\",\n        \"subscription\" => \"/foo\"\n      }\n      engine.stub(:client_exists).and_yield(true)\n      engine.should_not_receive(:subscribe)\n      server.process(message, false) {}\n    end\n\n    it \"does not subscribe using an extended channel\" do\n      message = {\n        \"channel\" => \"/meta/subscribe/x\",\n        \"clientId\" => \"fakeclientid\",\n        \"subscription\" => \"/foo\"\n      }\n      engine.stub(:client_exists).and_yield(true)\n      engine.should_not_receive(:subscribe)\n      server.process(message, false) {}\n    end\n  end\n\n  describe \"with an outgoing extension installed\" do\n    before do\n      extension = Class.new do\n        def outgoing(message, callback)\n          message[\"ext\"] = {\"auth\" => \"password\"}\n          callback.call(message)\n        end\n      end\n      server.add_extension(extension.new)\n    end\n\n    it \"does not pass incoming messages through the extension\" do\n      engine.should_receive(:publish).with({\"channel\" => \"/foo\", \"data\" => \"hello\"})\n      server.process(message, false) {}\n    end\n\n    it \"passes outgoing messages through the extension\" do\n      server.stub(:handshake).and_yield(message)\n      engine.stub(:publish)\n      response = nil\n      server.process({\"channel\" => \"/meta/handshake\"}, false) { |r| response = r }\n      response.should == [{\"channel\" => \"/foo\", \"data\" => \"hello\", \"ext\" => {\"auth\" => \"password\"}}]\n    end\n  end\nend\n", "'use strict';\n\nvar Class      = require('../util/class'),\n    array      = require('../util/array'),\n    extend     = require('../util/extend'),\n    constants  = require('../util/constants'),\n    Logging    = require('../mixins/logging'),\n    Engine     = require('../engines/proxy'),\n    Channel    = require('./channel'),\n    Error      = require('./error'),\n    Extensible = require('./extensible'),\n    Grammar    = require('./grammar'),\n    Socket     = require('./socket');\n\nvar Server = Class({ className: 'Server',\n  initialize: function(options) {\n    this._options  = options || {};\n    var engineOpts = this._options.engine || {};\n    engineOpts.timeout = this._options.timeout;\n    this._engine   = Engine.get(engineOpts);\n\n    this.info('Created new server: ?', this._options);\n  },\n\n  close: function() {\n    return this._engine.close();\n  },\n\n  openSocket: function(clientId, socket, request) {\n    if (!clientId || !socket) return;\n    this._engine.openSocket(clientId, new Socket(this, socket, request));\n  },\n\n  closeSocket: function(clientId, close) {\n    this._engine.flushConnection(clientId, close);\n  },\n\n  process: function(messages, request, callback, context) {\n    var local = (request === null);\n\n    messages = [].concat(messages);\n    this.info('Processing messages: ? (local: ?)', messages, local);\n\n    if (messages.length === 0) return callback.call(context, []);\n    var processed = 0, responses = [], self = this;\n\n    var gatherReplies = function(replies) {\n      responses = responses.concat(replies);\n      processed += 1;\n      if (processed < messages.length) return;\n\n      var n = responses.length;\n      while (n--) {\n        if (!responses[n]) responses.splice(n,1);\n      }\n      self.info('Returning replies: ?', responses);\n      callback.call(context, responses);\n    };\n\n    var handleReply = function(replies) {\n      var extended = 0, expected = replies.length;\n      if (expected === 0) gatherReplies(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        this.debug('Processing reply: ?', replies[i]);\n        (function(index) {\n          self.pipeThroughExtensions('outgoing', replies[index], request, function(message) {\n            replies[index] = message;\n            extended += 1;\n            if (extended === expected) gatherReplies(replies);\n          });\n        })(i);\n      }\n    };\n\n    for (var i = 0, n = messages.length; i < n; i++) {\n      this.pipeThroughExtensions('incoming', messages[i], request, function(pipedMessage) {\n        this._handle(pipedMessage, local, handleReply, this);\n      }, this);\n    }\n  },\n\n  _makeResponse: function(message) {\n    var response = {};\n\n    if (message.id)       response.id       = message.id;\n    if (message.clientId) response.clientId = message.clientId;\n    if (message.channel)  response.channel  = message.channel;\n    if (message.error)    response.error    = message.error;\n\n    response.successful = !response.error;\n    return response;\n  },\n\n  _handle: function(message, local, callback, context) {\n    if (!message) return callback.call(context, []);\n    this.info('Handling message: ? (local: ?)', message, local);\n\n    var channelName = message.channel,\n        error       = message.error,\n        response;\n\n    if (Channel.isMeta(channelName))\n      return this._handleMeta(message, local, callback, context);\n\n    if (!Grammar.CHANNEL_NAME.test(channelName))\n      error = Error.channelInvalid(channelName);\n\n    if (message.data === undefined)\n      error = Error.parameterMissing('data');\n\n    if (!error) this._engine.publish(message);\n\n    response = this._makeResponse(message);\n    if (error) response.error = error;\n    response.successful = !response.error;\n    callback.call(context, [response]);\n  },\n\n  _handleMeta: function(message, local, callback, context) {\n    var method = this._methodFor(message),\n        response;\n\n    if (method === null) {\n      response = this._makeResponse(message);\n      response.error = Error.channelForbidden(message.channel);\n      response.successful = false;\n      return callback.call(context, [response]);\n    }\n\n    this[method](message, local, function(responses) {\n      responses = [].concat(responses);\n      for (var i = 0, n = responses.length; i < n; i++) this._advize(responses[i], message.connectionType);\n      callback.call(context, responses);\n    }, this);\n  },\n\n  _methodFor: function(message) {\n    var channel = message.channel;\n\n    if (channel === Channel.HANDSHAKE)   return 'handshake';\n    if (channel === Channel.CONNECT)     return 'connect';\n    if (channel === Channel.SUBSCRIBE)   return 'subscribe';\n    if (channel === Channel.UNSUBSCRIBE) return 'unsubscribe';\n    if (channel === Channel.DISCONNECT)  return 'disconnect';\n\n    return null;\n  },\n\n  _advize: function(response, connectionType) {\n    if (array.indexOf([Channel.HANDSHAKE, Channel.CONNECT], response.channel) < 0)\n      return;\n\n    var interval, timeout;\n    if (connectionType === 'eventsource') {\n      interval = Math.floor(this._engine.timeout * 1000);\n      timeout  = 0;\n    } else {\n      interval = Math.floor(this._engine.interval * 1000);\n      timeout  = Math.floor(this._engine.timeout * 1000);\n    }\n\n    response.advice = response.advice || {};\n    if (response.error) {\n      extend(response.advice, {reconnect:  'handshake'}, false);\n    } else {\n      extend(response.advice, {\n        reconnect:  'retry',\n        interval:   interval,\n        timeout:    timeout\n      }, false);\n    }\n  },\n\n  // MUST contain  * version\n  //               * supportedConnectionTypes\n  // MAY contain   * minimumVersion\n  //               * ext\n  //               * id\n  handshake: function(message, local, callback, context) {\n    var response = this._makeResponse(message);\n    response.version = constants.BAYEUX_VERSION;\n\n    if (!message.version)\n      response.error = Error.parameterMissing('version');\n\n    var clientConns = message.supportedConnectionTypes,\n        commonConns;\n\n    response.supportedConnectionTypes = constants.CONNECTION_TYPES;\n\n    if (clientConns) {\n      commonConns = array.filter(clientConns, function(conn) {\n        return array.indexOf(constants.CONNECTION_TYPES, conn) >= 0;\n      });\n      if (commonConns.length === 0)\n        response.error = Error.conntypeMismatch(clientConns);\n    } else {\n      response.error = Error.parameterMissing('supportedConnectionTypes');\n    }\n\n    response.successful = !response.error;\n    if (!response.successful) return callback.call(context, response);\n\n    this._engine.createClient(function(clientId) {\n      response.clientId = clientId;\n      callback.call(context, response);\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  //               * connectionType\n  // MAY contain   * ext\n  //               * id\n  connect: function(message, local, callback, context) {\n    var response       = this._makeResponse(message),\n        clientId       = message.clientId,\n        connectionType = message.connectionType;\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)         response.error = Error.clientUnknown(clientId);\n      if (!clientId)       response.error = Error.parameterMissing('clientId');\n\n      if (array.indexOf(constants.CONNECTION_TYPES, connectionType) < 0)\n        response.error = Error.conntypeMismatch(connectionType);\n\n      if (!connectionType) response.error = Error.parameterMissing('connectionType');\n\n      response.successful = !response.error;\n\n      if (!response.successful) {\n        delete response.clientId;\n        return callback.call(context, response);\n      }\n\n      if (message.connectionType === 'eventsource') {\n        message.advice = message.advice || {};\n        message.advice.timeout = 0;\n      }\n      this._engine.connect(response.clientId, message.advice, function(events) {\n        callback.call(context, [response].concat(events));\n      });\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  // MAY contain   * ext\n  //               * id\n  disconnect: function(message, local, callback, context) {\n    var response = this._makeResponse(message),\n        clientId = message.clientId;\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)   response.error = Error.clientUnknown(clientId);\n      if (!clientId) response.error = Error.parameterMissing('clientId');\n\n      response.successful = !response.error;\n      if (!response.successful) delete response.clientId;\n\n      if (response.successful) this._engine.destroyClient(clientId);\n      callback.call(context, response);\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  //               * subscription\n  // MAY contain   * ext\n  //               * id\n  subscribe: function(message, local, callback, context) {\n    var response     = this._makeResponse(message),\n        clientId     = message.clientId,\n        subscription = message.subscription,\n        channel;\n\n    subscription = subscription ? [].concat(subscription) : [];\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)               response.error = Error.clientUnknown(clientId);\n      if (!clientId)             response.error = Error.parameterMissing('clientId');\n      if (!message.subscription) response.error = Error.parameterMissing('subscription');\n\n      response.subscription = message.subscription || [];\n\n      for (var i = 0, n = subscription.length; i < n; i++) {\n        channel = subscription[i];\n\n        if (response.error) break;\n        if (!local && !Channel.isSubscribable(channel)) response.error = Error.channelForbidden(channel);\n        if (!Channel.isValid(channel))                  response.error = Error.channelInvalid(channel);\n\n        if (response.error) break;\n        this._engine.subscribe(clientId, channel);\n      }\n\n      response.successful = !response.error;\n      callback.call(context, response);\n    }, this);\n  },\n\n  // MUST contain  * clientId\n  //               * subscription\n  // MAY contain   * ext\n  //               * id\n  unsubscribe: function(message, local, callback, context) {\n    var response     = this._makeResponse(message),\n        clientId     = message.clientId,\n        subscription = message.subscription,\n        channel;\n\n    subscription = subscription ? [].concat(subscription) : [];\n\n    this._engine.clientExists(clientId, function(exists) {\n      if (!exists)               response.error = Error.clientUnknown(clientId);\n      if (!clientId)             response.error = Error.parameterMissing('clientId');\n      if (!message.subscription) response.error = Error.parameterMissing('subscription');\n\n      response.subscription = message.subscription || [];\n\n      for (var i = 0, n = subscription.length; i < n; i++) {\n        channel = subscription[i];\n\n        if (response.error) break;\n        if (!local && !Channel.isSubscribable(channel)) response.error = Error.channelForbidden(channel);\n        if (!Channel.isValid(channel))                  response.error = Error.channelInvalid(channel);\n\n        if (response.error) break;\n        this._engine.unsubscribe(clientId, channel);\n      }\n\n      response.successful = !response.error;\n      callback.call(context, response);\n    }, this);\n  }\n});\n\nServer.create = function(options) {\n  return new Server(options);\n};\n\nextend(Server.prototype, Logging);\nextend(Server.prototype, Extensible);\n\nmodule.exports = Server;\n"], "filenames": ["lib/faye/protocol/server.rb", "spec/javascript/server/extensions_spec.js", "spec/ruby/server/extensions_spec.rb", "src/protocol/server.js"], "buggy_code_start_loc": [8, 38, 42, 16], "buggy_code_end_loc": [122, 38, 42, 137], "fixing_code_start_loc": [7, 39, 43, 15], "fixing_code_end_loc": [131, 75, 79, 148], "type": "CWE-287", "message": "Faye (NPM, RubyGem) versions greater than 0.5.0 and before 1.0.4, 1.1.3 and 1.2.5, has the potential for authentication bypass in the extension system. The vulnerability allows any client to bypass checks put in place by server-side extensions, by appending extra segments to the message channel. It is patched in versions 1.0.4, 1.1.3 and 1.2.5.", "other": {"cve": {"id": "CVE-2020-11020", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-29T18:15:13.360", "lastModified": "2020-05-06T18:21:15.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Faye (NPM, RubyGem) versions greater than 0.5.0 and before 1.0.4, 1.1.3 and 1.2.5, has the potential for authentication bypass in the extension system. The vulnerability allows any client to bypass checks put in place by server-side extensions, by appending extra segments to the message channel. It is patched in versions 1.0.4, 1.1.3 and 1.2.5."}, {"lang": "es", "value": "Faye (NPM, RubyGem) versiones superiores a 0.5.0 y anteriores a 1.0.4, 1.1.3 y 1.2.5, presentan el potencial de omitir la autenticaci\u00f3n en el sistema de extensiones. La vulnerabilidad permite que cualquier cliente omita las comprobaciones establecidas por las extensiones del lado del servidor, al agregar segmentos adicionales al canal de mensajes. Est\u00e1 parcheado en las versiones 1.0.4, 1.1.3 y 1.2.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:faye_project:faye:*:*:*:*:*:node.js:*:*", "versionStartExcluding": "0.5.0", "versionEndExcluding": "1.0.4", "matchCriteriaId": "FDF2555F-1E11-4F39-844B-48D120586578"}, {"vulnerable": true, "criteria": "cpe:2.3:a:faye_project:faye:*:*:*:*:*:ruby:*:*", "versionStartExcluding": "0.5.0", "versionEndExcluding": "1.0.4", "matchCriteriaId": "F2DB6AE8-AB9B-4A1A-9A23-80A45A3C7FD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:faye_project:faye:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.1.3", "matchCriteriaId": "4C2E7A43-4236-43CC-8588-DFF7DE651276"}, {"vulnerable": true, "criteria": "cpe:2.3:a:faye_project:faye:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.1.3", "matchCriteriaId": "C62CA8E2-99F2-4A49-8726-1D1F5EB3F148"}, {"vulnerable": true, "criteria": "cpe:2.3:a:faye_project:faye:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.2.0", "versionEndExcluding": "1.2.5", "matchCriteriaId": "A7AECEFE-3AC9-4855-BD8F-9019A6B64541"}, {"vulnerable": true, "criteria": "cpe:2.3:a:faye_project:faye:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "1.2.0", "versionEndExcluding": "1.2.5", "matchCriteriaId": "4005E717-555C-4AEB-9D1B-5400C26F2764"}]}]}], "references": [{"url": "https://github.com/faye/faye/commit/65d297d341b607f3cb0b5fa6021a625a991cc30e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/faye/faye/security/advisories/GHSA-qpg4-4w7w-2mq5", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/faye/faye/commit/65d297d341b607f3cb0b5fa6021a625a991cc30e"}}