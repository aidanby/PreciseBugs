{"buggy_code": ["<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Panique <https://github.com/panique/php-login-advanced/>\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 3.0.0\n **/\n\nnamespace psm\\Service;\n\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * This is a heavily modified version of the php-login-advanced project by Panique.\n *\n * It uses the Session classes from the Symfony HttpFoundation component.\n *\n * @author Panique\n * @author Pepijn Over\n * @link http://www.php-login.net\n * @link https://github.com/panique/php-login-advanced/\n * @license http://opensource.org/licenses/MIT MIT License\n */\nclass User\n{\n\n    /**\n     * The database connection\n     * @var \\PDO $db_connection\n     */\n    protected $db_connection = null;\n\n    /**\n     * Local cache of user data\n     * @var array $user_data\n     */\n    protected $user_data = array();\n\n    /**\n     * Session object\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\Session $session\n     */\n    protected $session;\n\n    /**\n     * Current user id\n     * @var int $user_id\n     */\n    protected $user_id;\n\n    /**\n     *Current user preferences\n     * @var array $user_preferences\n     */\n    protected $user_preferences;\n\n    /**\n     * The user's login status\n     * @var boolean $user_is_logged_in\n     */\n    protected $user_is_logged_in = false;\n\n    /**\n     * Open a new user service\n     *\n     * @param \\psm\\Service\\Database $db\n     * @param \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface $session if NULL, one will be created\n     */\n    public function __construct(Database $db, SessionInterface $session = null)\n    {\n        $this->db_connection = $db->pdo();\n\n        if (!psm_is_cli()) {\n            if ($session == null) {\n                $session = new Session();\n                $session->start();\n            }\n            $this->session = $session;\n\n            if (PSM_PUBLIC === true && PSM_PUBLIC_PAGE === true) {\n                $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                    PSM_DB_PREFIX . 'users WHERE user_name = :user_name and level = :level');\n                $query_user->bindValue(':user_name', \"__PUBLIC__\", \\PDO::PARAM_STR);\n                $query_user->bindValue(':level', PSM_USER_ANONYMOUS, \\PDO::PARAM_STR);\n                $query_user->execute();\n\n                // get result row (as an object)\n                $this->setUserLoggedIn($query_user->fetchObject()->user_id);\n            }\n\n            if ((!defined('PSM_INSTALL') || !PSM_INSTALL)) {\n                // check the possible login actions:\n                // 1. login via session data (happens each time user opens a page on your php project AFTER\n                // he has successfully logged in via the login form)\n                // 2. login via cookie\n\n                // if user has an active session on the server\n                if (!$this->loginWithSessionData()) {\n                    $this->loginWithCookieData();\n                }\n            }\n        }\n    }\n\n    /**\n     * Get user by id, or get current user.\n     * @param int $user_id if null it will attempt current user id\n     * @param boolean $flush if TRUE it will query db regardless of whether we already have the data\n     * @return object|boolean FALSE if user not found, object otherwise\n     */\n    public function getUser($user_id = null, $flush = false)\n    {\n        if ($user_id == null) {\n            if (!$this->isUserLoggedIn()) {\n                return false;\n            } else {\n                $user_id = $this->getUserId();\n            }\n        }\n\n        if (!isset($this->user_data[$user_id]) || $flush) {\n            $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                PSM_DB_PREFIX . 'users WHERE user_id = :user_id');\n            $query_user->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n            $query_user->execute();\n            // get result row (as an object)\n            $this->user_data[$user_id] = $query_user->fetchObject();\n        }\n        return $this->user_data[$user_id];\n    }\n\n    /**\n     * Search into database for the user data of user_name specified as parameter\n     * @return object|boolean user data as an object if existing user\n     */\n    public function getUserByUsername($user_name)\n    {\n        // database query, getting all the info of the selected user\n        $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n            PSM_DB_PREFIX . 'users WHERE user_name = :user_name');\n        $query_user->bindValue(':user_name', $user_name, \\PDO::PARAM_STR);\n        $query_user->execute();\n        // get result row (as an object)\n        return $query_user->fetchObject();\n    }\n\n    /**\n     * Logs in with SESSION data.\n     *\n     * @return boolean\n     */\n    protected function loginWithSessionData()\n    {\n        if (!$this->session->has('user_id')) {\n            return false;\n        }\n        $user = $this->getUser($this->session->get('user_id'));\n\n        if (!empty($user)) {\n            $this->setUserLoggedIn($user->user_id);\n            return true;\n        } else {\n            // user no longer exists in database\n            // call logout to clean up session vars\n            $this->doLogout();\n            return false;\n        }\n    }\n\n    /**\n     * Logs in via the Cookie\n     * @return bool success state of cookie login\n     */\n    private function loginWithCookieData()\n    {\n        if (isset($_COOKIE['rememberme'])) {\n            // extract data from the cookie\n            list ($user_id, $token, $hash) = explode(':', $_COOKIE['rememberme']);\n            // check cookie hash validity\n            if ($hash == hash('sha256', $user_id . ':' . $token . PSM_LOGIN_COOKIE_SECRET_KEY) && !empty($token)) {\n                // cookie looks good, try to select corresponding user\n                // get real token from database (and all other data)\n                $user = $this->getUser($user_id);\n\n                if (!empty($user) && $token === $user->rememberme_token) {\n                    $this->setUserLoggedIn($user->user_id, true);\n\n                    // Cookie token usable only once\n                    $this->newRememberMeCookie();\n                    return true;\n                }\n            }\n            // call logout to remove invalid cookie\n            $this->doLogout();\n        }\n        return false;\n    }\n\n    /**\n     * Logs in with the data provided in $_POST, coming from the login form\n     * @param string $user_name\n     * @param string $user_password\n     * @param boolean $user_rememberme\n     * @return boolean\n     */\n    public function loginWithPostData($user_name, $user_password, $user_rememberme = false)\n    {\n        $user_name = trim($user_name);\n        $user_password = trim($user_password);\n        $ldapauthstatus = false;\n\n        if (empty($user_name) && empty($user_password)) {\n            return false;\n        }\n\n        $dirauthconfig = psm_get_conf('dirauth_status');\n        \n        // LDAP auth enabled\n        if ($dirauthconfig === '1') {\n            $ldaplibpath = realpath(\n                PSM_PATH_SRC . '..' . DIRECTORY_SEPARATOR .\n                'vendor' . DIRECTORY_SEPARATOR .\n                'viharm' . DIRECTORY_SEPARATOR .\n                'psm-ldap-auth' . DIRECTORY_SEPARATOR .\n                'psmldapauth.php'\n            );\n            // If the library is found\n            if ($ldaplibpath) {\n                // Delegate the authentication to the PsmLDAPauth module.\n                // If LDAP auth fails or if library not found, fall back to native auth\n                include_once($ldaplibpath);\n                $ldapauthstatus = psmldapauth($user_name, $user_password, $GLOBALS['sm_config'], $this->db_connection);\n            }\n        }\n\n        $user = $this->getUserByUsername($user_name);\n\n        // Authenticated\n        if ($ldapauthstatus === true) {\n          // Remove password to prevent it from being saved in the DB.\n          // Otherwise, user may still be authenticated if LDAP is disabled later.\n          $user_password = null;\n          @fn_Debug('Authenticated', $user);\n        } else {\n\n          // using PHP 5.5's password_verify() function to check if the provided passwords\n          // fits to the hash of that user's password\n          if (!isset($user->user_id)) {\n              password_verify($user_password, 'dummy_call_against_timing');\n              return false;\n          } elseif (!password_verify($user_password, $user->password)) {\n              return false;\n          }\n        } // not authenticated\n\n        $this->setUserLoggedIn($user->user_id, true);\n\n        // if user has check the \"remember me\" checkbox, then generate token and write cookie\n        if ($user_rememberme) {\n            $this->newRememberMeCookie();\n        }\n\n        // recalculate the user's password hash\n        // DELETE this if-block if you like, it only exists to recalculate\n        // users's hashes when you provide a cost factor,\n        // by default the script will use a cost factor of 10 and never change it.\n        // check if the have defined a cost factor in config/hashing.php\n        if (defined('PSM_LOGIN_HASH_COST_FACTOR')) {\n            // check if the hash needs to be rehashed\n            if (password_needs_rehash($user->password, PASSWORD_DEFAULT, array('cost' => PSM_LOGIN_HASH_COST_FACTOR))) {\n                $this->changePassword($user->user_id, $user_password);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Set the user logged in\n     * @param int $user_id\n     * @param boolean $regenerate regenerate session id against session fixation?\n     */\n    protected function setUserLoggedIn($user_id, $regenerate = false)\n    {\n        if ($regenerate) {\n            $this->session->invalidate();\n        }\n        $this->session->set('user_id', $user_id);\n        $this->session->set('user_logged_in', 1);\n\n        // declare user id, set the login status to true\n        $this->user_id = $user_id;\n        $this->user_is_logged_in = true;\n    }\n\n    /**\n     * Create all data needed for remember me cookie connection on client and server side\n     */\n    protected function newRememberMeCookie()\n    {\n        // generate 64 char random string and store it in current user data\n        $random_token_string = hash('sha256', mt_rand());\n        $sth = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET rememberme_token = :user_rememberme_token WHERE user_id = :user_id');\n        $sth->execute(array(':user_rememberme_token' => $random_token_string, ':user_id' => $this->getUserId()));\n\n        // generate cookie string that consists of userid, randomstring and combined hash of both\n        $cookie_string_first_part = $this->getUserId() . ':' . $random_token_string;\n        $cookie_string_hash = hash('sha256', $cookie_string_first_part . PSM_LOGIN_COOKIE_SECRET_KEY);\n        $cookie_string = $cookie_string_first_part . ':' . $cookie_string_hash;\n\n        // set cookie\n        setcookie('rememberme', $cookie_string, time() + PSM_LOGIN_COOKIE_RUNTIME, \"/\", PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Delete all data needed for remember me cookie connection on client and server side\n     */\n    protected function deleteRememberMeCookie()\n    {\n        // Reset rememberme token\n        if ($this->session->has('user_id')) {\n            $sth = $this->db_connection->prepare('UPDATE ' .\n                PSM_DB_PREFIX . 'users SET rememberme_token = NULL WHERE user_id = :user_id');\n            $sth->execute(array(':user_id' => $this->session->get('user_id')));\n        }\n\n        // set the rememberme-cookie to ten years ago (3600sec * 365 days * 10).\n        // that's obivously the best practice to kill a cookie via php\n        // @see http://stackoverflow.com/a/686166/1114320\n        setcookie('rememberme', false, time() - (3600 * 3650), '/', PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Perform the logout, resetting the session\n     */\n    public function doLogout()\n    {\n        $this->deleteRememberMeCookie();\n\n        $this->session->clear();\n        $this->session->invalidate();\n\n        $this->user_is_logged_in = false;\n    }\n\n    /**\n     * Simply return the current state of the user's login\n     * @return bool user's login status\n     */\n    public function isUserLoggedIn()\n    {\n        return $this->user_is_logged_in;\n    }\n\n    /**\n     * Sets a random token into the database (that will verify the user when he/she comes back via the link\n     * in the email) and returns it\n     * @param int $user_id\n     * @return string|boolean FALSE on error, string otherwise\n     */\n    public function generatePasswordResetToken($user_id)\n    {\n        $user_id = intval($user_id);\n\n        if ($user_id == 0) {\n            return false;\n        }\n        // generate timestamp (to see when exactly the user (or an attacker) requested the password reset mail)\n        $temporary_timestamp = time();\n        // generate random hash for email password reset verification (40 char string)\n        $user_password_reset_hash = sha1(uniqid(mt_rand(), true));\n\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password_reset_hash = :user_password_reset_hash,\n            password_reset_timestamp = :user_password_reset_timestamp\n            WHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_reset_hash', $user_password_reset_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_password_reset_timestamp', $temporary_timestamp, \\PDO::PARAM_INT);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return $user_password_reset_hash;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the verification string in the account verification mail is valid and matches to the user.\n     *\n     * Please note it is valid for 1 hour.\n     * @param int $user_id\n     * @param string $token\n     * @return boolean\n     */\n    public function verifyPasswordResetToken($user_id, $token)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($token)) {\n            return false;\n        }\n        $user = $this->getUser($user_id);\n\n        if (isset($user->user_id) && $user->password_reset_hash == $token) {\n            $runtime = (defined('PSM_LOGIN_RESET_RUNTIME')) ? PSM_LOGIN_RESET_RUNTIME : 3600;\n            $timestamp_max_interval = time() - $runtime;\n\n            if ($user->password_reset_timestamp > $timestamp_max_interval) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Change the password of a user\n     * @param int|\\PDOStatement $user_id\n     * @param string $password\n     * @return boolean TRUE on success, FALSE on failure\n     */\n    public function changePassword($user_id, $password)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($password)) {\n            return false;\n        }\n        // now it gets a little bit crazy: check if we have a constant\n        // PSM_LOGIN_HASH_COST_FACTOR defined (in src/includes/psmconfig.inc.php),\n        // if so: put the value into $hash_cost_factor, if not, make $hash_cost_factor = null\n        $hash_cost_factor = (defined('PSM_LOGIN_HASH_COST_FACTOR') ? PSM_LOGIN_HASH_COST_FACTOR : null);\n\n        // crypt the user's password with the PHP 5.5's password_hash() function, results in a 60 character hash string\n        // the PASSWORD_DEFAULT constant is defined by the PHP 5.5,\n        // or if you are using PHP 5.3/5.4, by the password hashing\n        // compatibility library. the third parameter looks a little bit shitty, but that's how those PHP 5.5 functions\n        // want the parameter: as an array with, currently only used with 'cost' => XX.\n        $user_password_hash = password_hash($password, PASSWORD_DEFAULT, array('cost' => $hash_cost_factor));\n\n        // write users new hash into database\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password = :user_password_hash,\n\t\t\t\tpassword_reset_hash = NULL, password_reset_timestamp = NULL\n\t\t\t\tWHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_hash', $user_password_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_STR);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Gets the user id\n     * @return int\n     */\n    public function getUserId()\n    {\n        return $this->user_id;\n    }\n\n    /**\n     * Gets the username\n     * @return string\n     */\n    public function getUsername()\n    {\n        $user = $this->getUser();\n        return (isset($user->user_name) ? $user->user_name : null);\n    }\n\n    /**\n     * Gets the user level\n     * @return int\n     */\n    public function getUserLevel()\n    {\n        $user = $this->getUser();\n\n        if (isset($user->level)) {\n            return $user->level;\n        } else {\n            return PSM_USER_ANONYMOUS;\n        }\n    }\n\n    /**\n     * read current user preferences from the database\n     * @return boolean return false is user not connected\n     */\n    protected function loadPreferences()\n    {\n        if ($this->user_preferences === null) {\n            if (!$this->getUser()) {\n                return false;\n            }\n\n            $this->user_preferences = array();\n            foreach (\n                $this->db_connection->query('SELECT `key`,`value` FROM `' .\n                PSM_DB_PREFIX . 'users_preferences` WHERE `user_id` = ' . $this->user_id) as $row\n            ) {\n                $this->user_preferences[$row['key']] = $row['value'];\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a user preference value\n     * @param string $key\n     * @param mixed $default\n     * @return mixed\n     */\n    public function getUserPref($key, $default = '')\n    {\n        if (!$this->loadPreferences() || !isset($this->user_preferences[$key])) {\n            return $default;\n        }\n\n        $value = $this->user_preferences[$key];\n        settype($value, gettype($default));\n        return $value;\n    }\n\n    /**\n     * Set a user preference value\n     * @param string $key\n     * @param mixed $value\n     */\n    public function setUserPref($key, $value)\n    {\n        if ($this->loadPreferences()) {\n            if (isset($this->user_preferences[$key])) {\n                if ($this->user_preferences[$key] == $value) {\n                    return; // no change\n                }\n                $sql = 'UPDATE `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ? WHERE `user_id` = ?';\n            } else {\n                $sql = 'INSERT INTO `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ?, `user_id` = ?';\n            }\n            $sth = $this->db_connection->prepare($sql);\n            $sth->execute(array($key, $value, $this->user_id));\n            $this->user_preferences[$key] = $value;\n        }\n    }\n\n    /**\n     * Get session object\n     * @return \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * PHP Server Monitor\n * Monitor your servers and websites.\n *\n * This file is part of PHP Server Monitor.\n * PHP Server Monitor is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PHP Server Monitor is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with PHP Server Monitor.  If not, see <http://www.gnu.org/licenses/>.\n *\n * @package     phpservermon\n * @author      Panique <https://github.com/panique/php-login-advanced/>\n * @author      Pepijn Over <pep@mailbox.org>\n * @copyright   Copyright (c) 2008-2017 Pepijn Over <pep@mailbox.org>\n * @license     http://www.gnu.org/licenses/gpl.txt GNU GPL v3\n * @version     Release: @package_version@\n * @link        http://www.phpservermonitor.org/\n * @since       phpservermon 3.0.0\n **/\n\nnamespace psm\\Service;\n\nuse Symfony\\Component\\HttpFoundation\\Session\\Session;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * This is a heavily modified version of the php-login-advanced project by Panique.\n *\n * It uses the Session classes from the Symfony HttpFoundation component.\n *\n * @author Panique\n * @author Pepijn Over\n * @link http://www.php-login.net\n * @link https://github.com/panique/php-login-advanced/\n * @license http://opensource.org/licenses/MIT MIT License\n */\nclass User\n{\n\n    /**\n     * The database connection\n     * @var \\PDO $db_connection\n     */\n    protected $db_connection = null;\n\n    /**\n     * Local cache of user data\n     * @var array $user_data\n     */\n    protected $user_data = array();\n\n    /**\n     * Session object\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\Session $session\n     */\n    protected $session;\n\n    /**\n     * Current user id\n     * @var int $user_id\n     */\n    protected $user_id;\n\n    /**\n     *Current user preferences\n     * @var array $user_preferences\n     */\n    protected $user_preferences;\n\n    /**\n     * The user's login status\n     * @var boolean $user_is_logged_in\n     */\n    protected $user_is_logged_in = false;\n\n    /**\n     * Open a new user service\n     *\n     * @param \\psm\\Service\\Database $db\n     * @param \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface $session if NULL, one will be created\n     */\n    public function __construct(Database $db, SessionInterface $session = null)\n    {\n        $this->db_connection = $db->pdo();\n\n        if (!psm_is_cli()) {\n            if ($session == null) {\n                $session = new Session();\n                $session->start();\n            }\n            $this->session = $session;\n\n            if (PSM_PUBLIC === true && PSM_PUBLIC_PAGE === true) {\n                $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                    PSM_DB_PREFIX . 'users WHERE user_name = :user_name and level = :level');\n                $query_user->bindValue(':user_name', \"__PUBLIC__\", \\PDO::PARAM_STR);\n                $query_user->bindValue(':level', PSM_USER_ANONYMOUS, \\PDO::PARAM_STR);\n                $query_user->execute();\n\n                // get result row (as an object)\n                $this->setUserLoggedIn($query_user->fetchObject()->user_id);\n            }\n\n            if ((!defined('PSM_INSTALL') || !PSM_INSTALL)) {\n                // check the possible login actions:\n                // 1. login via session data (happens each time user opens a page on your php project AFTER\n                // he has successfully logged in via the login form)\n                // 2. login via cookie\n\n                // if user has an active session on the server\n                if (!$this->loginWithSessionData()) {\n                    $this->loginWithCookieData();\n                }\n            }\n        }\n    }\n\n    /**\n     * Get user by id, or get current user.\n     * @param int $user_id if null it will attempt current user id\n     * @param boolean $flush if TRUE it will query db regardless of whether we already have the data\n     * @return object|boolean FALSE if user not found, object otherwise\n     */\n    public function getUser($user_id = null, $flush = false)\n    {\n        if ($user_id == null) {\n            if (!$this->isUserLoggedIn()) {\n                return false;\n            } else {\n                $user_id = $this->getUserId();\n            }\n        }\n\n        if (!isset($this->user_data[$user_id]) || $flush) {\n            $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n                PSM_DB_PREFIX . 'users WHERE user_id = :user_id');\n            $query_user->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n            $query_user->execute();\n            // get result row (as an object)\n            $this->user_data[$user_id] = $query_user->fetchObject();\n        }\n        return $this->user_data[$user_id];\n    }\n\n    /**\n     * Search into database for the user data of user_name specified as parameter\n     * @return object|boolean user data as an object if existing user\n     */\n    public function getUserByUsername($user_name)\n    {\n        // database query, getting all the info of the selected user\n        $query_user = $this->db_connection->prepare('SELECT * FROM ' .\n            PSM_DB_PREFIX . 'users WHERE user_name = :user_name');\n        $query_user->bindValue(':user_name', $user_name, \\PDO::PARAM_STR);\n        $query_user->execute();\n        // get result row (as an object)\n        return $query_user->fetchObject();\n    }\n\n    /**\n     * Logs in with SESSION data.\n     *\n     * @return boolean\n     */\n    protected function loginWithSessionData()\n    {\n        if (!$this->session->has('user_id')) {\n            return false;\n        }\n        $user = $this->getUser($this->session->get('user_id'));\n\n        if (!empty($user)) {\n            $this->setUserLoggedIn($user->user_id);\n            return true;\n        } else {\n            // user no longer exists in database\n            // call logout to clean up session vars\n            $this->doLogout();\n            return false;\n        }\n    }\n\n    /**\n     * Logs in via the Cookie\n     * @return bool success state of cookie login\n     */\n    private function loginWithCookieData()\n    {\n        if (isset($_COOKIE['rememberme'])) {\n            // extract data from the cookie\n            list($user_id, $token, $hash) = explode('_', $_COOKIE['rememberme']);\n            // check cookie hash validity\n            if ($hash == hash('sha256', $user_id . '_' . $token . PSM_LOGIN_COOKIE_SECRET_KEY) && !empty($token)) {\n                // cookie looks good, try to select corresponding user\n                // get real token from database (and all other data)\n                $user = $this->getUser($user_id);\n\n                if (!empty($user) && $token === $user->rememberme_token) {\n                    $this->setUserLoggedIn($user->user_id, true);\n\n                    // Cookie token usable only once\n                    $this->newRememberMeCookie();\n                    return true;\n                }\n            }\n            // call logout to remove invalid cookie\n            $this->doLogout();\n        }\n        return false;\n    }\n\n    /**\n     * Logs in with the data provided in $_POST, coming from the login form\n     * @param string $user_name\n     * @param string $user_password\n     * @param boolean $user_rememberme\n     * @return boolean\n     */\n    public function loginWithPostData($user_name, $user_password, $user_rememberme = false)\n    {\n        $user_name = trim($user_name);\n        $user_password = trim($user_password);\n        $ldapauthstatus = false;\n\n        if (empty($user_name) && empty($user_password)) {\n            return false;\n        }\n\n        $dirauthconfig = psm_get_conf('dirauth_status');\n        \n        // LDAP auth enabled\n        if ($dirauthconfig === '1') {\n            $ldaplibpath = realpath(\n                PSM_PATH_SRC . '..' . DIRECTORY_SEPARATOR .\n                'vendor' . DIRECTORY_SEPARATOR .\n                'viharm' . DIRECTORY_SEPARATOR .\n                'psm-ldap-auth' . DIRECTORY_SEPARATOR .\n                'psmldapauth.php'\n            );\n            // If the library is found\n            if ($ldaplibpath) {\n                // Delegate the authentication to the PsmLDAPauth module.\n                // If LDAP auth fails or if library not found, fall back to native auth\n                include_once($ldaplibpath);\n                $ldapauthstatus = psmldapauth($user_name, $user_password, $GLOBALS['sm_config'], $this->db_connection);\n            }\n        }\n\n        $user = $this->getUserByUsername($user_name);\n\n        // Authenticated\n        if ($ldapauthstatus === true) {\n          // Remove password to prevent it from being saved in the DB.\n          // Otherwise, user may still be authenticated if LDAP is disabled later.\n          $user_password = null;\n          @fn_Debug('Authenticated', $user);\n        } else {\n\n          // using PHP 5.5's password_verify() function to check if the provided passwords\n          // fits to the hash of that user's password\n          if (!isset($user->user_id)) {\n              password_verify($user_password, 'dummy_call_against_timing');\n              return false;\n          } elseif (!password_verify($user_password, $user->password)) {\n              return false;\n          }\n        } // not authenticated\n\n        $this->setUserLoggedIn($user->user_id, true);\n\n        // if user has check the \"remember me\" checkbox, then generate token and write cookie\n        if ($user_rememberme) {\n            $this->newRememberMeCookie();\n        }\n\n        // recalculate the user's password hash\n        // DELETE this if-block if you like, it only exists to recalculate\n        // users's hashes when you provide a cost factor,\n        // by default the script will use a cost factor of 10 and never change it.\n        // check if the have defined a cost factor in config/hashing.php\n        if (defined('PSM_LOGIN_HASH_COST_FACTOR')) {\n            // check if the hash needs to be rehashed\n            if (password_needs_rehash($user->password, PASSWORD_DEFAULT, array('cost' => PSM_LOGIN_HASH_COST_FACTOR))) {\n                $this->changePassword($user->user_id, $user_password);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Set the user logged in\n     * @param int $user_id\n     * @param boolean $regenerate regenerate session id against session fixation?\n     */\n    protected function setUserLoggedIn($user_id, $regenerate = false)\n    {\n        if ($regenerate) {\n            $this->session->invalidate();\n        }\n        $this->session->set('user_id', $user_id);\n        $this->session->set('user_logged_in', 1);\n\n        // declare user id, set the login status to true\n        $this->user_id = $user_id;\n        $this->user_is_logged_in = true;\n    }\n\n    /**\n     * Create all data needed for remember me cookie connection on client and server side\n     */\n    protected function newRememberMeCookie()\n    {\n        // generate 64 char random string and store it in current user data\n        $random_token_string = hash('sha256', random_bytes(64));\n        $sth = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET rememberme_token = :user_rememberme_token WHERE user_id = :user_id');\n        $sth->execute(array(':user_rememberme_token' => $random_token_string, ':user_id' => $this->getUserId()));\n\n        // generate cookie string that consists of userid, randomstring and combined hash of both\n        $cookie_string_first_part = $this->getUserId() . '_' . $random_token_string;\n        $cookie_string_hash = hash('sha256', $cookie_string_first_part . PSM_LOGIN_COOKIE_SECRET_KEY);\n        $cookie_string = $cookie_string_first_part . '_' . $cookie_string_hash;\n\n        // set cookie\n        setcookie('rememberme', $cookie_string, time() + PSM_LOGIN_COOKIE_RUNTIME, \"/\", PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Delete all data needed for remember me cookie connection on client and server side\n     */\n    protected function deleteRememberMeCookie()\n    {\n        // Reset rememberme token\n        if ($this->session->has('user_id')) {\n            $sth = $this->db_connection->prepare('UPDATE ' .\n                PSM_DB_PREFIX . 'users SET rememberme_token = NULL WHERE user_id = :user_id');\n            $sth->execute(array(':user_id' => $this->session->get('user_id')));\n        }\n\n        // set the rememberme-cookie to ten years ago (3600sec * 365 days * 10).\n        // that's obivously the best practice to kill a cookie via php\n        // @see http://stackoverflow.com/a/686166/1114320\n        setcookie('rememberme', false, time() - (3600 * 3650), '/', PSM_LOGIN_COOKIE_DOMAIN);\n    }\n\n    /**\n     * Perform the logout, resetting the session\n     */\n    public function doLogout()\n    {\n        $this->deleteRememberMeCookie();\n\n        $this->session->clear();\n        $this->session->invalidate();\n\n        $this->user_is_logged_in = false;\n    }\n\n    /**\n     * Simply return the current state of the user's login\n     * @return bool user's login status\n     */\n    public function isUserLoggedIn()\n    {\n        return $this->user_is_logged_in;\n    }\n\n    /**\n     * Sets a random token into the database (that will verify the user when he/she comes back via the link\n     * in the email) and returns it\n     * @param int $user_id\n     * @return string|boolean FALSE on error, string otherwise\n     */\n    public function generatePasswordResetToken($user_id)\n    {\n        $user_id = intval($user_id);\n\n        if ($user_id == 0) {\n            return false;\n        }\n        // generate timestamp (to see when exactly the user (or an attacker) requested the password reset mail)\n        $temporary_timestamp = time();\n        // generate random hash for email password reset verification (40 char string)\n        $user_password_reset_hash = sha1(uniqid(mt_rand(), true));\n\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password_reset_hash = :user_password_reset_hash,\n            password_reset_timestamp = :user_password_reset_timestamp\n            WHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_reset_hash', $user_password_reset_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_password_reset_timestamp', $temporary_timestamp, \\PDO::PARAM_INT);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_INT);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return $user_password_reset_hash;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the verification string in the account verification mail is valid and matches to the user.\n     *\n     * Please note it is valid for 1 hour.\n     * @param int $user_id\n     * @param string $token\n     * @return boolean\n     */\n    public function verifyPasswordResetToken($user_id, $token)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($token)) {\n            return false;\n        }\n        $user = $this->getUser($user_id);\n\n        if (isset($user->user_id) && $user->password_reset_hash == $token) {\n            $runtime = (defined('PSM_LOGIN_RESET_RUNTIME')) ? PSM_LOGIN_RESET_RUNTIME : 3600;\n            $timestamp_max_interval = time() - $runtime;\n\n            if ($user->password_reset_timestamp > $timestamp_max_interval) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Change the password of a user\n     * @param int|\\PDOStatement $user_id\n     * @param string $password\n     * @return boolean TRUE on success, FALSE on failure\n     */\n    public function changePassword($user_id, $password)\n    {\n        $user_id = intval($user_id);\n\n        if (empty($user_id) || empty($password)) {\n            return false;\n        }\n        // now it gets a little bit crazy: check if we have a constant\n        // PSM_LOGIN_HASH_COST_FACTOR defined (in src/includes/psmconfig.inc.php),\n        // if so: put the value into $hash_cost_factor, if not, make $hash_cost_factor = null\n        $hash_cost_factor = (defined('PSM_LOGIN_HASH_COST_FACTOR') ? PSM_LOGIN_HASH_COST_FACTOR : null);\n\n        // crypt the user's password with the PHP 5.5's password_hash() function, results in a 60 character hash string\n        // the PASSWORD_DEFAULT constant is defined by the PHP 5.5,\n        // or if you are using PHP 5.3/5.4, by the password hashing\n        // compatibility library. the third parameter looks a little bit shitty, but that's how those PHP 5.5 functions\n        // want the parameter: as an array with, currently only used with 'cost' => XX.\n        $user_password_hash = password_hash($password, PASSWORD_DEFAULT, array('cost' => $hash_cost_factor));\n\n        // write users new hash into database\n        $query_update = $this->db_connection->prepare('UPDATE ' .\n            PSM_DB_PREFIX . 'users SET password = :user_password_hash,\n\t\t\t\tpassword_reset_hash = NULL, password_reset_timestamp = NULL\n\t\t\t\tWHERE user_id = :user_id');\n        $query_update->bindValue(':user_password_hash', $user_password_hash, \\PDO::PARAM_STR);\n        $query_update->bindValue(':user_id', $user_id, \\PDO::PARAM_STR);\n        $query_update->execute();\n\n        // check if exactly one row was successfully changed:\n        if ($query_update->rowCount() == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Gets the user id\n     * @return int\n     */\n    public function getUserId()\n    {\n        return $this->user_id;\n    }\n\n    /**\n     * Gets the username\n     * @return string\n     */\n    public function getUsername()\n    {\n        $user = $this->getUser();\n        return (isset($user->user_name) ? $user->user_name : null);\n    }\n\n    /**\n     * Gets the user level\n     * @return int\n     */\n    public function getUserLevel()\n    {\n        $user = $this->getUser();\n\n        if (isset($user->level)) {\n            return $user->level;\n        } else {\n            return PSM_USER_ANONYMOUS;\n        }\n    }\n\n    /**\n     * read current user preferences from the database\n     * @return boolean return false is user not connected\n     */\n    protected function loadPreferences()\n    {\n        if ($this->user_preferences === null) {\n            if (!$this->getUser()) {\n                return false;\n            }\n\n            $this->user_preferences = array();\n            foreach ($this->db_connection->query('SELECT `key`,`value` FROM `' .\n                PSM_DB_PREFIX . 'users_preferences` WHERE `user_id` = ' . $this->user_id) as $row) {\n                $this->user_preferences[$row['key']] = $row['value'];\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get a user preference value\n     * @param string $key\n     * @param mixed $default\n     * @return mixed\n     */\n    public function getUserPref($key, $default = '')\n    {\n        if (!$this->loadPreferences() || !isset($this->user_preferences[$key])) {\n            return $default;\n        }\n\n        $value = $this->user_preferences[$key];\n        settype($value, gettype($default));\n        return $value;\n    }\n\n    /**\n     * Set a user preference value\n     * @param string $key\n     * @param mixed $value\n     */\n    public function setUserPref($key, $value)\n    {\n        if ($this->loadPreferences()) {\n            if (isset($this->user_preferences[$key])) {\n                if ($this->user_preferences[$key] == $value) {\n                    return; // no change\n                }\n                $sql = 'UPDATE `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ? WHERE `user_id` = ?';\n            } else {\n                $sql = 'INSERT INTO `' . PSM_DB_PREFIX . 'users_preferences` SET `key` = ?, `value` = ?, `user_id` = ?';\n            }\n            $sth = $this->db_connection->prepare($sql);\n            $sth->execute(array($key, $value, $this->user_id));\n            $this->user_preferences[$key] = $value;\n        }\n    }\n\n    /**\n     * Get session object\n     * @return \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n}\n"], "filenames": ["src/psm/Service/User.php"], "buggy_code_start_loc": [201], "buggy_code_end_loc": [533], "fixing_code_start_loc": [201], "fixing_code_end_loc": [531], "type": "CWE-1241", "message": "A vulnerability, which was classified as problematic, was found in phpservermon. Affected is the function setUserLoggedIn of the file src/psm/Service/User.php. The manipulation leads to use of predictable algorithm in random number generator. The exploit has been disclosed to the public and may be used. The name of the patch is bb10a5f3c68527c58073258cb12446782d223bc3. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-213744.", "other": {"cve": {"id": "CVE-2021-4241", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-15T23:15:14.737", "lastModified": "2022-11-18T19:57:48.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in phpservermon. Affected is the function setUserLoggedIn of the file src/psm/Service/User.php. The manipulation leads to use of predictable algorithm in random number generator. The exploit has been disclosed to the public and may be used. The name of the patch is bb10a5f3c68527c58073258cb12446782d223bc3. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-213744."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1241"}, {"lang": "en", "value": "CWE-331"}, {"lang": "en", "value": "CWE-338"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpservermonitor:php_server_monitor:-:*:*:*:*:*:*:*", "matchCriteriaId": "8BA6165A-0BEC-4027-BFF8-92EF2B82B3CF"}]}]}], "references": [{"url": "https://github.com/phpservermon/phpservermon/commit/bb10a5f3c68527c58073258cb12446782d223bc3", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1-phpservermon/phpservermon/", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.213744", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/phpservermon/phpservermon/commit/bb10a5f3c68527c58073258cb12446782d223bc3"}}