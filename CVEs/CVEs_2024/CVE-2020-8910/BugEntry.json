{"buggy_code": ["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Simple utilities for dealing with URI strings.\n *\n * This is intended to be a lightweight alternative to constructing goog.Uri\n * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless\n * of how much of its functionality you use, this is designed to be a set of\n * mostly-independent utilities so that the compiler includes only what is\n * necessary for the task.  Estimated savings of porting is 5k pre-gzip and\n * 1.5k post-gzip.  To ensure the savings remain, future developers should\n * avoid adding new functionality to existing functions, but instead create\n * new ones and factor out shared code.\n *\n * Many of these utilities have limited functionality, tailored to common\n * cases.  The query parameter utilities assume that the parameter keys are\n * already encoded, since most keys are compile-time alphanumeric strings.  The\n * query parameter mutation utilities also do not tolerate fragment identifiers.\n *\n * By design, these functions can be slower than goog.Uri equivalents.\n * Repeated calls to some of functions may be quadratic in behavior for IE,\n * although the effect is somewhat limited given the 2kb limit.\n *\n * One advantage of the limited functionality here is that this approach is\n * less sensitive to differences in URI encodings than goog.Uri, since these\n * functions operate on strings directly, rather than decoding them and\n * then re-encoding.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\ngoog.provide('goog.uri.utils.QueryArray');\ngoog.provide('goog.uri.utils.QueryValue');\ngoog.provide('goog.uri.utils.StandardQueryParam');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.string');\n\n\n/**\n * Character codes inlined to avoid object allocations due to charCode.\n * @enum {number}\n * @private\n */\ngoog.uri.utils.CharCode_ = {\n  AMPERSAND: 38,\n  EQUAL: 61,\n  HASH: 35,\n  QUESTION: 63\n};\n\n\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?string=} opt_scheme The scheme such as 'http'.\n * @param {?string=} opt_userInfo The user name before the '@'.\n * @param {?string=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {(string|number|null)=} opt_port The port number.\n * @param {?string=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?string=} opt_queryData The URI-encoded query data.\n * @param {?string=} opt_fragment The URI-encoded fragment identifier.\n * @return {string} The fully combined URI.\n */\ngoog.uri.utils.buildFromEncodedParts = function(\n    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,\n    opt_fragment) {\n  var out = '';\n\n  if (opt_scheme) {\n    out += opt_scheme + ':';\n  }\n\n  if (opt_domain) {\n    out += '//';\n\n    if (opt_userInfo) {\n      out += opt_userInfo + '@';\n    }\n\n    out += opt_domain;\n\n    if (opt_port) {\n      out += ':' + opt_port;\n    }\n  }\n\n  if (opt_path) {\n    out += opt_path;\n  }\n\n  if (opt_queryData) {\n    out += '?' + opt_queryData;\n  }\n\n  if (opt_fragment) {\n    out += '#' + opt_fragment;\n  }\n\n  return out;\n};\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +\n    '(?:' +\n    '([^:/?#.]+)' +  // scheme - ignore special characters\n                     // used by other URL parts such as :,\n                     // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +  // userInfo\n    '([^/#?]*?)' +       // domain\n    '(?::([0-9]+))?' +   // port\n    '(?=[/\\\\\\\\#?]|$)' +  // authority-terminating character\n    ')?' +\n    '([^?#]+)?' +          // path\n    '(?:\\\\?([^#]*))?' +    // query\n    '(?:#([\\\\s\\\\S]*))?' +  // fragment\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n\n\n/**\n * @param {?string} uri A possibly null string.\n * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986\n *     reserved characters will not be removed.\n * @return {?string} The string URI-decoded, or null if uri is null.\n * @private\n */\ngoog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {\n  if (!uri) {\n    return uri;\n  }\n\n  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);\n};\n\n\n/**\n * Gets a URI component by index.\n *\n * It is preferred to use the getPathEncoded() variety of functions ahead,\n * since they are more readable.\n *\n * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.\n * @param {string} uri The URI to examine.\n * @return {?string} The still-encoded component, or null if the component\n *     is not present.\n * @private\n */\ngoog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {\n  // Convert undefined, null, and empty string into null.\n  return goog.uri.utils.split(uri)[componentIndex] || null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The protocol or scheme, or null if none.  Does not\n *     include trailing colons or slashes.\n */\ngoog.uri.utils.getScheme = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.SCHEME, uri);\n};\n\n\n/**\n * Gets the effective scheme for the URL.  If the URL is relative then the\n * scheme is derived from the page's location.\n * @param {string} uri The URI to examine.\n * @return {string} The protocol or scheme, always lower case.\n */\ngoog.uri.utils.getEffectiveScheme = function(uri) {\n  var scheme = goog.uri.utils.getScheme(uri);\n  if (!scheme && goog.global.self && goog.global.self.location) {\n    var protocol = goog.global.self.location.protocol;\n    scheme = protocol.substr(0, protocol.length - 1);\n  }\n  // NOTE: When called from a web worker in Firefox 3.5, location may be null.\n  // All other browsers with web workers support self.location from the worker.\n  return scheme ? scheme.toLowerCase() : '';\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The user name still encoded, or null if none.\n */\ngoog.uri.utils.getUserInfoEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.USER_INFO, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded user info, or null if none.\n */\ngoog.uri.utils.getUserInfo = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getUserInfoEncoded(uri));\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The domain name still encoded, or null if none.\n */\ngoog.uri.utils.getDomainEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.DOMAIN, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded domain, or null if none.\n */\ngoog.uri.utils.getDomain = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?number} The port number, or null if none.\n */\ngoog.uri.utils.getPort = function(uri) {\n  // Coerce to a number.  If the result of getComponentByIndex_ is null or\n  // non-numeric, the number coersion yields NaN.  This will then return\n  // null for all non-numeric cases (though also zero, which isn't a relevant\n  // port number).\n  return Number(\n             goog.uri.utils.getComponentByIndex_(\n                 goog.uri.utils.ComponentIndex.PORT, uri)) ||\n      null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The path still encoded, or null if none. Includes the\n *     leading slash, if any.\n */\ngoog.uri.utils.getPathEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.PATH, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded path, or null if none.  Includes the leading\n *     slash, if any.\n */\ngoog.uri.utils.getPath = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The query data still encoded, or null if none.  Does not\n *     include the question mark itself.\n */\ngoog.uri.utils.getQueryData = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The fragment identifier, or null if none.  Does not\n *     include the hash mark itself.\n */\ngoog.uri.utils.getFragmentEncoded = function(uri) {\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @param {?string} fragment The encoded fragment identifier, or null if none.\n *     Does not include the hash mark itself.\n * @return {string} The URI with the fragment set.\n */\ngoog.uri.utils.setFragmentEncoded = function(uri, fragment) {\n  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded fragment identifier, or null if none.  Does\n *     not include the hash mark.\n */\ngoog.uri.utils.getFragment = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getFragmentEncoded(uri));\n};\n\n\n/**\n * Extracts everything up to the port of the URI.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getHost = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME],\n      pieces[goog.uri.utils.ComponentIndex.USER_INFO],\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Returns the origin for a given URL.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getOrigin = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Extracts the path of the URL and everything after.\n * @param {string} uri The URI string.\n * @return {string} The URI, starting at the path and including the query\n *     parameters and fragment identifier.\n */\ngoog.uri.utils.getPathAndAfter = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],\n      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Gets the URI with the fragment identifier removed.\n * @param {string} uri The URI to examine.\n * @return {string} Everything preceding the hash mark.\n */\ngoog.uri.utils.removeFragment = function(uri) {\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);\n};\n\n\n/**\n * Ensures that two URI's have the exact same domain, scheme, and port.\n *\n * Unlike the version in goog.Uri, this checks protocol, and therefore is\n * suitable for checking against the browser's same-origin policy.\n *\n * @param {string} uri1 The first URI.\n * @param {string} uri2 The second URI.\n * @return {boolean} Whether they have the same scheme, domain and port.\n */\ngoog.uri.utils.haveSameDomain = function(uri1, uri2) {\n  var pieces1 = goog.uri.utils.split(uri1);\n  var pieces2 = goog.uri.utils.split(uri2);\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==\n      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&\n      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==\n      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&\n      pieces1[goog.uri.utils.ComponentIndex.PORT] ==\n      pieces2[goog.uri.utils.ComponentIndex.PORT];\n};\n\n\n/**\n * Asserts that there are no fragment or query identifiers, only in uncompiled\n * mode.\n * @param {string} uri The URI to examine.\n * @private\n */\ngoog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {\n  goog.asserts.assert(\n      uri.indexOf('#') < 0 && uri.indexOf('?') < 0,\n      'goog.uri.utils: Fragment or query identifiers are not supported: [%s]',\n      uri);\n};\n\n\n/**\n * Supported query parameter values by the parameter serializing utilities.\n *\n * If a value is null or undefined, the key-value pair is skipped, as an easy\n * way to omit parameters conditionally.  Non-array parameters are converted\n * to a string and URI encoded.  Array values are expanded into multiple\n * &key=value pairs, with each element stringized and URI-encoded.\n *\n * @typedef {*}\n */\ngoog.uri.utils.QueryValue;\n\n\n/**\n * An array representing a set of query parameters with alternating keys\n * and values.\n *\n * Keys are assumed to be URI encoded already and live at even indices.  See\n * goog.uri.utils.QueryValue for details on how parameter values are encoded.\n *\n * Example:\n * <pre>\n * var data = [\n *   // Simple param: ?name=BobBarker\n *   'name', 'BobBarker',\n *   // Conditional param -- may be omitted entirely.\n *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,\n *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null\n *   'house', ['LosAngeles', 'NewYork', null]\n * ];\n * </pre>\n *\n * @typedef {!Array<string|goog.uri.utils.QueryValue>}\n */\ngoog.uri.utils.QueryArray;\n\n\n/**\n * Parses encoded query parameters and calls callback function for every\n * parameter found in the string.\n *\n * Missing value of parameter (e.g. \u201c\u2026&key&\u2026\u201d) is treated as if the value was an\n * empty string.  Keys may be empty strings (e.g. \u201c\u2026&=value&\u2026\u201d) which also means\n * that \u201c\u2026&=&\u2026\u201d and \u201c\u2026&&\u2026\u201d will result in an empty key and value.\n *\n * @param {string} encodedQuery Encoded query string excluding question mark at\n *     the beginning.\n * @param {function(string, string)} callback Function called for every\n *     parameter found in query string.  The first argument (name) will not be\n *     urldecoded (so the function is consistent with buildQueryData), but the\n *     second will.  If the parameter has no value (i.e. \u201c=\u201d was not present)\n *     the second argument (value) will be an empty string.\n */\ngoog.uri.utils.parseQueryData = function(encodedQuery, callback) {\n  if (!encodedQuery) {\n    return;\n  }\n  var pairs = encodedQuery.split('&');\n  for (var i = 0; i < pairs.length; i++) {\n    var indexOfEquals = pairs[i].indexOf('=');\n    var name = null;\n    var value = null;\n    if (indexOfEquals >= 0) {\n      name = pairs[i].substring(0, indexOfEquals);\n      value = pairs[i].substring(indexOfEquals + 1);\n    } else {\n      name = pairs[i];\n    }\n    callback(name, value ? goog.string.urlDecode(value) : '');\n  }\n};\n\n\n/**\n * Split the URI into 3 parts where the [1] is the queryData without a leading\n * '?'. For example, the URI http://foo.com/bar?a=b#abc returns\n * ['http://foo.com/bar','a=b','#abc'].\n * @param {string} uri The URI to parse.\n * @return {!Array<string>} An array representation of uri of length 3 where the\n *     middle value is the queryData without a leading '?'.\n * @private\n */\ngoog.uri.utils.splitQueryData_ = function(uri) {\n  // Find the query data and hash.\n  var hashIndex = uri.indexOf('#');\n  if (hashIndex < 0) {\n    hashIndex = uri.length;\n  }\n  var questionIndex = uri.indexOf('?');\n  var queryData;\n  if (questionIndex < 0 || questionIndex > hashIndex) {\n    questionIndex = hashIndex;\n    queryData = '';\n  } else {\n    queryData = uri.substring(questionIndex + 1, hashIndex);\n  }\n  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];\n};\n\n\n/**\n * Join an array created by splitQueryData_ back into a URI.\n * @param {!Array<string>} parts A URI in the form generated by splitQueryData_.\n * @return {string} The joined URI.\n * @private\n */\ngoog.uri.utils.joinQueryData_ = function(parts) {\n  return parts[0] + (parts[1] ? '?' + parts[1] : '') + parts[2];\n};\n\n\n/**\n * @param {string} queryData\n * @param {string} newData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryData_ = function(queryData, newData) {\n  if (!newData) {\n    return queryData;\n  }\n  return queryData ? queryData + '&' + newData : newData;\n};\n\n\n/**\n * @param {string} uri\n * @param {string} queryData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {\n  if (!queryData) {\n    return uri;\n  }\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Appends key=value pairs to an array, supporting multi-valued objects.\n * @param {*} key The key prefix.\n * @param {goog.uri.utils.QueryValue} value The value to serialize.\n * @param {!Array<string>} pairs The array to which the 'key=value' strings\n *     should be appended.\n * @private\n */\ngoog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {\n  goog.asserts.assertString(key);\n  if (Array.isArray(value)) {\n    // Convince the compiler it's an array.\n    goog.asserts.assertArray(value);\n    for (var j = 0; j < value.length; j++) {\n      // Convert to string explicitly, to short circuit the null and array\n      // logic in this function -- this ensures that null and undefined get\n      // written as literal 'null' and 'undefined', and arrays don't get\n      // expanded out but instead encoded in the default way.\n      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);\n    }\n  } else if (value != null) {\n    // Skip a top-level null or undefined entirely.\n    pairs.push(\n        key +\n        // Check for empty string. Zero gets encoded into the url as literal\n        // strings.  For empty string, skip the equal sign, to be consistent\n        // with UriBuilder.java.\n        (value === '' ? '' : '=' + goog.string.urlEncode(value)));\n  }\n};\n\n\n/**\n * Builds a query data string from a sequence of alternating keys and values.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!IArrayLike<string|goog.uri.utils.QueryValue>} keysAndValues\n *     Alternating keys and values. See the QueryArray typedef.\n * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {\n  goog.asserts.assert(\n      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,\n      'goog.uri.utils: Key/value lists must be even in length.');\n\n  var params = [];\n  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {\n    var key = /** @type {string} */ (keysAndValues[i]);\n    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Builds a query data string from a map.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!Object<string, goog.uri.utils.QueryValue>} map An object where keys\n *     are URI-encoded parameter keys, and the values are arbitrary types\n *     or arrays. Keys with a null value are dropped.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryDataFromMap = function(map) {\n  var params = [];\n  for (var key in map) {\n    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Appends URI parameters to an existing URI.\n *\n * The variable arguments may contain alternating keys and values.  Keys are\n * assumed to be already URI encoded.  The values should not be URI-encoded,\n * and will instead be encoded by this function.\n * <pre>\n * appendParams('http://www.foo.com?existing=true',\n *     'key1', 'value1',\n *     'key2', 'value?willBeEncoded',\n *     'key3', ['valueA', 'valueB', 'valueC'],\n *     'key4', null);\n * result: 'http://www.foo.com?existing=true&' +\n *     'key1=value1&' +\n *     'key2=value%3FwillBeEncoded&' +\n *     'key3=valueA&key3=valueB&key3=valueC'\n * </pre>\n *\n * A single call to this function will not exhibit quadratic behavior in IE,\n * whereas multiple repeated calls may, although the effect is limited by\n * fact that URL's generally can't exceed 2kb.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}\n * var_args\n *     An array or argument list conforming to goog.uri.utils.QueryArray.\n * @return {string} The URI with all query parameters added.\n */\ngoog.uri.utils.appendParams = function(uri, var_args) {\n  var queryData = arguments.length == 2 ?\n      goog.uri.utils.buildQueryData(arguments[1], 0) :\n      goog.uri.utils.buildQueryData(arguments, 1);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends query parameters from a map.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object<goog.uri.utils.QueryValue>} map An object where keys are\n *     URI-encoded parameter keys, and the values are arbitrary types or arrays.\n *     Keys with a null value are dropped.\n * @return {string} The new parameters.\n */\ngoog.uri.utils.appendParamsFromMap = function(uri, map) {\n  var queryData = goog.uri.utils.buildQueryDataFromMap(map);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends a single URI parameter.\n *\n * Repeated calls to this can exhibit quadratic behavior in IE6 due to the\n * way string append works, though it should be limited given the 2kb limit.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} key The key, which must already be URI encoded.\n * @param {*=} opt_value The value, which will be stringized and encoded\n *     (assumed not already to be encoded).  If omitted, undefined, or null, the\n *     key will be added as a valueless parameter.\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.appendParam = function(uri, key, opt_value) {\n  var value = (opt_value != null) ? '=' + goog.string.urlEncode(opt_value) : '';\n  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);\n};\n\n\n/**\n * Finds the next instance of a query parameter with the specified name.\n *\n * Does not instantiate any objects.\n *\n * @param {string} uri The URI to search.  May contain a fragment identifier\n *     if opt_hashIndex is specified.\n * @param {number} startIndex The index to begin searching for the key at.  A\n *     match may be found even if this is one character after the ampersand.\n * @param {string} keyEncoded The URI-encoded key.\n * @param {number} hashOrEndIndex Index to stop looking at.  If a hash\n *     mark is present, it should be its index, otherwise it should be the\n *     length of the string.\n * @return {number} The position of the first character in the key's name,\n *     immediately after either a question mark or a dot.\n * @private\n */\ngoog.uri.utils.findParam_ = function(\n    uri, startIndex, keyEncoded, hashOrEndIndex) {\n  var index = startIndex;\n  var keyLength = keyEncoded.length;\n\n  // Search for the key itself and post-filter for surronuding punctuation,\n  // rather than expensively building a regexp.\n  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&\n         index < hashOrEndIndex) {\n    var precedingChar = uri.charCodeAt(index - 1);\n    // Ensure that the preceding character is '&' or '?'.\n    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n        precedingChar == goog.uri.utils.CharCode_.QUESTION) {\n      // Ensure the following character is '&', '=', '#', or NaN\n      // (end of string).\n      var followingChar = uri.charCodeAt(index + keyLength);\n      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||\n          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n          followingChar == goog.uri.utils.CharCode_.HASH) {\n        return index;\n      }\n    }\n    index += keyLength + 1;\n  }\n\n  return -1;\n};\n\n\n/**\n * Regular expression for finding a hash mark or end of string.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.hashOrEndRe_ = /#|$/;\n\n\n/**\n * Determines if the URI contains a specific key.\n *\n * Performs no object instantiations.\n *\n * @param {string} uri The URI to process.  May contain a fragment\n *     identifier.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {boolean} Whether the key is present.\n */\ngoog.uri.utils.hasParam = function(uri, keyEncoded) {\n  return goog.uri.utils.findParam_(\n             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;\n};\n\n\n/**\n * Gets the first value of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {?string} The first value of the parameter (URI-decoded), or null\n *     if the parameter is not found.\n */\ngoog.uri.utils.getParamValue = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var foundIndex =\n      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);\n\n  if (foundIndex < 0) {\n    return null;\n  } else {\n    var endPosition = uri.indexOf('&', foundIndex);\n    if (endPosition < 0 || endPosition > hashOrEndIndex) {\n      endPosition = hashOrEndIndex;\n    }\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > endPosition.\n    return goog.string.urlDecode(\n        uri.substr(foundIndex, endPosition - foundIndex));\n  }\n};\n\n\n/**\n * Gets all values of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {!Array<string>} All URI-decoded values with the given key.\n *     If the key is not found, this will have length 0, but never be null.\n */\ngoog.uri.utils.getParamValues = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var result = [];\n\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Find where this parameter ends, either the '&' or the end of the\n    // query parameters.\n    position = uri.indexOf('&', foundIndex);\n    if (position < 0 || position > hashOrEndIndex) {\n      position = hashOrEndIndex;\n    }\n\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > position.\n    result.push(\n        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));\n  }\n\n  return result;\n};\n\n\n/**\n * Regexp to find trailing question marks and ampersands.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;\n\n\n/**\n * Removes all instances of a query parameter.\n * @param {string} uri The URI to process.  Must not contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.\n * @return {string} The URI with all instances of the parameter removed.\n */\ngoog.uri.utils.removeParam = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var buffer = [];\n\n  // Look for a query parameter.\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Get the portion of the query string up to, but not including, the ?\n    // or & starting the parameter.\n    buffer.push(uri.substring(position, foundIndex));\n    // Progress to immediately after the '&'.  If not found, go to the end.\n    // Avoid including the hash mark.\n    position = Math.min(\n        (uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);\n  }\n\n  // Append everything that is remaining.\n  buffer.push(uri.substr(position));\n\n  // Join the buffer, and remove trailing punctuation that remains.\n  return buffer.join('').replace(\n      goog.uri.utils.trailingQueryPunctuationRe_, '$1');\n};\n\n\n/**\n * Replaces all existing definitions of a parameter with a single definition.\n *\n * Repeated calls to this can exhibit quadratic behavior due to the need to\n * find existing instances and reconstruct the string, though it should be\n * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap\n * to update multiple parameters in bulk.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} keyEncoded The key, which must already be URI encoded.\n * @param {*} value The value, which will be stringized and encoded (assumed\n *     not already to be encoded).\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.setParam = function(uri, keyEncoded, value) {\n  return goog.uri.utils.appendParam(\n      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);\n};\n\n\n/**\n * Effeciently set or remove multiple query parameters in a URI. Order of\n * unchanged parameters will not be modified, all updated parameters will be\n * appended to the end of the query. Params with values of null or undefined are\n * removed.\n *\n * @param {string} uri The URI to process.\n * @param {!Object<string, goog.uri.utils.QueryValue>} params A list of\n *     parameters to update. If null or undefined, the param will be removed.\n * @return {string} An updated URI where the query data has been updated with\n *     the params.\n */\ngoog.uri.utils.setParamsFromMap = function(uri, params) {\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  var queryData = parts[1];\n  var buffer = [];\n  if (queryData) {\n    goog.array.forEach(queryData.split('&'), function(pair) {\n      var indexOfEquals = pair.indexOf('=');\n      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;\n      if (!params.hasOwnProperty(name)) {\n        buffer.push(pair);\n      }\n    });\n  }\n  parts[1] = goog.uri.utils.appendQueryData_(\n      buffer.join('&'), goog.uri.utils.buildQueryDataFromMap(params));\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Generates a URI path using a given URI and a path with checks to\n * prevent consecutive \"//\". The baseUri passed in must not contain\n * query or fragment identifiers. The path to append may not contain query or\n * fragment identifiers.\n *\n * @param {string} baseUri URI to use as the base.\n * @param {string} path Path to append.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.appendPath = function(baseUri, path) {\n  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);\n\n  // Remove any trailing '/'\n  if (goog.string.endsWith(baseUri, '/')) {\n    baseUri = baseUri.substr(0, baseUri.length - 1);\n  }\n  // Remove any leading '/'\n  if (goog.string.startsWith(path, '/')) {\n    path = path.substr(1);\n  }\n  return goog.string.buildString(baseUri, '/', path);\n};\n\n\n/**\n * Replaces the path.\n * @param {string} uri URI to use as the base.\n * @param {string} path New path.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.setPath = function(uri, path) {\n  // Add any missing '/'.\n  if (!goog.string.startsWith(path, '/')) {\n    path = '/' + path;\n  }\n  var parts = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      parts[goog.uri.utils.ComponentIndex.SCHEME],\n      parts[goog.uri.utils.ComponentIndex.USER_INFO],\n      parts[goog.uri.utils.ComponentIndex.DOMAIN],\n      parts[goog.uri.utils.ComponentIndex.PORT], path,\n      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Standard supported query parameters.\n * @enum {string}\n */\ngoog.uri.utils.StandardQueryParam = {\n\n  /** Unused parameter for unique-ifying. */\n  RANDOM: 'zx'\n};\n\n\n/**\n * Sets the zx parameter of a URI to a random value.\n * @param {string} uri Any URI.\n * @return {string} That URI with the \"zx\" parameter added or replaced to\n *     contain a random string.\n */\ngoog.uri.utils.makeUnique = function(uri) {\n  return goog.uri.utils.setParam(\n      uri, goog.uri.utils.StandardQueryParam.RANDOM,\n      goog.string.getRandomString());\n};\n", "/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.module('goog.uri.utilsTest');\ngoog.setTestOnly();\n\nconst functions = goog.require('goog.functions');\nconst googString = goog.require('goog.string');\nconst testSuite = goog.require('goog.testing.testSuite');\nconst utils = goog.require('goog.uri.utils');\n\n/** Simple class with a constant toString. */\nclass HasString {\n  /** @param {string} stringValue The result of toString. */\n  constructor(stringValue) {\n    this.value_ = stringValue;\n  }\n\n  /** @override */\n  toString() {\n    return this.value_;\n  }\n}\n\ntestSuite({\n  setUpPage() {\n    googString.getRandomString = functions.constant('RANDOM');\n  },\n\n  tearDown() {},\n\n  testSplit() {\n    const uri =\n        'http://www.google.com:80/path%20path+path?q=query&hl=en#fragment';\n    assertEquals('http', utils.getScheme(uri));\n    assertNull(utils.getUserInfoEncoded(uri));\n    assertNull(utils.getUserInfo(uri));\n    assertEquals('www.google.com', utils.getDomainEncoded(uri));\n    assertEquals('www.google.com', utils.getDomain(uri));\n    assertEquals(80, utils.getPort(uri));\n    assertEquals('/path%20path+path', utils.getPathEncoded(uri));\n    assertEquals('/path path+path', utils.getPath(uri));\n    assertEquals('q=query&hl=en', utils.getQueryData(uri));\n    assertEquals('fragment', utils.getFragmentEncoded(uri));\n    assertEquals('fragment', utils.getFragment(uri));\n\n    assertEquals(\n        utils.getDomain('http://[2607:f8b0:4006:802::1006]'),\n        '[2607:f8b0:4006:802::1006]');\n    assertEquals(\n        utils.getDomain('http://[2607:f8b0:4006:802::1006]:80'),\n        '[2607:f8b0:4006:802::1006]');\n    assertEquals(utils.getPort('http://[2607:f8b0:4006:802::1006]:80'), 80);\n    assertEquals(utils.getDomain('http://[2607]:80/?q=]'), '[2607]');\n    assertEquals(utils.getDomain('http://!!!'), '!!!');\n    assertNull(utils.getPath('http://!!!'));\n    assertNull(utils.getScheme('www.x.com:80'));\n    assertEquals(\n        'Query data with no fragment identifier', 'foo=bar&baz=bin',\n        utils.getQueryData('http://google.com?foo=bar&baz=bin'));\n  },\n\n  testSplitWithNewline() {\n    const uri = 'http://www.google.com:80/path%20path+path?q=query#frag\\nment';\n    assertEquals('http', utils.getScheme(uri));\n    assertNull(utils.getUserInfoEncoded(uri));\n    assertNull(utils.getUserInfo(uri));\n    assertEquals('www.google.com', utils.getDomainEncoded(uri));\n    assertEquals('www.google.com', utils.getDomain(uri));\n    assertEquals(80, utils.getPort(uri));\n    assertEquals('/path%20path+path', utils.getPathEncoded(uri));\n    assertEquals('/path path+path', utils.getPath(uri));\n    assertEquals('q=query', utils.getQueryData(uri));\n    assertEquals('frag\\nment', utils.getFragmentEncoded(uri));\n    assertEquals('frag\\nment', utils.getFragment(uri));\n  },\n\n  testMailtoUri() {\n    const uri = 'mailto:joe+random@hominid.com';\n    assertNull(utils.getDomain(uri));\n    assertEquals('mailto', utils.getScheme(uri));\n    assertEquals('joe+random@hominid.com', utils.getPath(uri));\n  },\n\n  testSplitRelativeUri() {\n    const uri = '/path%20path+path?q=query&hl=en#fragment';\n    assertNull(utils.getScheme(uri));\n    assertNull(utils.getDomain(uri));\n    assertNull(utils.getDomainEncoded(uri));\n    assertNull(utils.getPort(uri));\n    assertEquals('/path%20path+path', utils.getPathEncoded(uri));\n    assertEquals('/path path+path', utils.getPath(uri));\n    assertEquals('q=query&hl=en', utils.getQueryData(uri));\n    assertEquals('fragment', utils.getFragmentEncoded(uri));\n    assertEquals('fragment', utils.getFragment(uri));\n  },\n\n  testSplitMaliciousUri() {\n    const uri = 'https://malicious.com\\\\test.google.com';\n    assertEquals('https', utils.getScheme(uri));\n    assertEquals('malicious.com', utils.getDomain(uri));\n    assertEquals('malicious.com', utils.getDomainEncoded(uri));\n    assertNull(utils.getPort(uri));\n    assertEquals('\\\\test.google.com', utils.getPathEncoded(uri));\n    assertEquals('\\\\test.google.com', utils.getPath(uri));\n    assertNull(utils.getQueryData(uri));\n    assertNull(utils.getFragmentEncoded(uri));\n    assertNull(utils.getFragment(uri));\n  },\n\n  testSplitBadAuthority() {\n    // This URL has a syntax error per the RFC (port number must be digits, and\n    // host cannot contain a colon except in [...]). This test is solely to\n    // 'document' the current behavior, which may affect application handling\n    // of erroneous URLs.\n    assertEquals(utils.getDomain('http://host:port/'), 'host:port');\n    assertNull(utils.getPort('http://host:port/'));\n  },\n\n  testSplitIntoHostAndPath() {\n    // Splitting into host and path takes care of one of the major use cases\n    // of resolve, without implementing a generic algorithm that undoubtedly\n    // requires a huge footprint.\n    const uri =\n        'http://www.google.com:80/path%20path+path?q=query&hl=en#fragment';\n    assertEquals('http://www.google.com:80', utils.getHost(uri));\n    assertEquals(\n        '/path%20path+path?q=query&hl=en#fragment', utils.getPathAndAfter(uri));\n\n    const uri2 = 'http://www.google.com/calendar';\n    assertEquals(\n        'should handle missing fields', 'http://www.google.com',\n        utils.getHost(uri2));\n    assertEquals(\n        'should handle missing fields', '/calendar',\n        utils.getPathAndAfter(uri2));\n  },\n\n  testGetOrigin() {\n    const uri =\n        'http://foo:pw@www.google.com:80/path%20path+path?q=query&hl=en#fragment';\n    assertEquals('http://www.google.com:80', utils.getOrigin(uri));\n  },\n\n  testRelativeUrisHaveNoPath() {\n    assertNull(utils.getPathEncoded('?hello'));\n  },\n\n  testReservedCharacters() {\n    const o = '%6F';\n    const uri = `http://www.g${o}ogle.com%40/xxx%2feee/ccc`;\n    assertEquals(\n        'Should not decode reserved characters in path', '/xxx%2feee/ccc',\n        utils.getPath(uri));\n    assertEquals(\n        'Should not decode reserved characters in domain', 'www.google.com%40',\n        utils.getDomain(uri));\n  },\n\n  testSetFragmentEncoded() {\n    const expected = 'http://www.google.com/path#bar';\n    assertEquals(\n        expected,\n        utils.setFragmentEncoded('http://www.google.com/path#foo', 'bar'));\n\n    assertEquals(\n        expected,\n        utils.setFragmentEncoded('http://www.google.com/path', 'bar'));\n\n    assertEquals(\n        'http://www.google.com/path',\n        utils.setFragmentEncoded('http://www.google.com/path', ''));\n\n    assertEquals(\n        'http://www.google.com/path',\n        utils.setFragmentEncoded('http://www.google.com/path', null));\n  },\n\n  testGetParamValue() {\n    assertEquals(\n        'v1',\n        utils.getParamValue('/path?key=v1&c=d&keywithsuffix=v3&key=v2', 'key'));\n\n    assertEquals(\n        'v1',\n        utils.getParamValue('/path?kEY=v1&c=d&keywithsuffix=v3&key=v2', 'kEY'));\n  },\n\n  testGetParamValues() {\n    assertArrayEquals(\n        'should ignore confusing suffixes', ['v1', 'v2'],\n        utils.getParamValues(\n            '/path?a=b&key=v1&c=d&key=v2&keywithsuffix=v3', 'key'));\n    assertArrayEquals(\n        'should be case sensitive', ['v2'],\n        utils.getParamValues(\n            '/path?a=b&keY=v1&c=d&KEy=v2&keywithsuffix=v3', 'KEy'));\n    assertArrayEquals(\n        'should work for the first parameter', ['v1', 'v2'],\n        utils.getParamValues(\n            '/path?key=v1&c=d&key=v2&keywithsuffix=v3', 'key'));\n    assertArrayEquals(\n        'should work for the last parameter', ['v1', 'v2'],\n        utils.getParamValues(\n            '/path?key=v1&c=d&keywithsuffix=v3&key=v2', 'key'));\n    assertArrayEquals(\n        ['1'], utils.getParamValues('http://foo.com?q=1#?q=2&q=3', 'q'));\n  },\n\n  testGetParamValueAllowsEqualInValues() {\n    assertEquals(\n        'equals signs can appear unencoded', 'v1=v2',\n        utils.getParamValue('/path?key=v1=v2', 'key'));\n    assertArrayEquals(\n        ['v1=v2=v3'], utils.getParamValues('/path?key=v1=v2=v3', 'key'));\n  },\n\n  testGetParamValueNoSuchKey() {\n    const uri = '/path?key=v1&c=d&keywithsuffix=v3&key=v2';\n    assertNull(utils.getParamValue(uri, 'nosuchkey'));\n    assertArrayEquals([], utils.getParamValues(uri, 'nosuchkey'));\n    assertFalse(utils.hasParam(uri, 'nosuchkey'));\n    assertNull(utils.getParamValue('q=1', 'q'));\n    assertEquals('1', utils.getParamValue('?q=1', 'q'));\n  },\n\n  testGetParamValueEmptyAndMissingValueStrings() {\n    assertEquals('', utils.getParamValue('/path?key&bar', 'key'));\n    assertEquals('', utils.getParamValue('/path?foo=bar&key', 'key'));\n    assertEquals('', utils.getParamValue('/path?key', 'key'));\n    assertEquals('', utils.getParamValue('/path?key=', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?key', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?key&bar', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?foo=bar&key', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?foo=bar&key=', 'key'));\n    assertArrayEquals(\n        ['', '', '', 'j', ''],\n        utils.getParamValues('/path?key&key&key=&key=j&key', 'key'));\n    assertArrayEquals(\n        ['', '', '', '', ''],\n        utils.getParamValues('/pathqqq?q&qq&q&q=&q&q', 'q'));\n    assertTrue(utils.hasParam('/path?key=', 'key'));\n  },\n\n  testGetParamValueDecoding() {\n    assertEquals(\n        'plus should be supported as alias of space', 'foo bar baz',\n        utils.getParamValue('/path?key=foo+bar%20baz', 'key'));\n    assertArrayEquals(\n        ['foo bar baz'],\n        utils.getParamValues('/path?key=foo%20bar%20baz', 'key'));\n  },\n\n  testGetParamIgnoresParamsInFragmentIdentifiers() {\n    assertFalse(utils.hasParam('/path?bah#a&key=foo', 'key'));\n    assertEquals(null, utils.getParamValue('/path?bah#a&key=bar', 'key'));\n    assertArrayEquals([], utils.getParamValues('/path?bah#a&key=bar', 'key'));\n  },\n\n  testGetParamIgnoresExcludesFragmentFromParameterValue() {\n    // Make sure the '#' doesn't get included anywhere, for parameter values\n    // of different lengths.\n    assertEquals(\n        'foo', utils.getParamValue('/path?key=foo#key=bar&key=baz', 'key'));\n    assertArrayEquals(\n        ['foo'], utils.getParamValues('/path?key=foo#key=bar&key=baz', 'key'));\n    assertEquals('', utils.getParamValue('/path?key#key=bar&key=baz', 'key'));\n    assertArrayEquals(\n        [''], utils.getParamValues('/path?key#key=bar&key=baz', 'key'));\n    assertEquals(\n        'x', utils.getParamValue('/path?key=x#key=bar&key=baz', 'key'));\n    assertArrayEquals(\n        ['x'], utils.getParamValues('/path?key=x#key=bar&key=baz', 'key'));\n\n    // Simply make sure hasParam doesn't die in this case.\n    assertTrue(utils.hasParam('/path?key=foo#key=bar&key=baz', 'key'));\n    assertTrue(utils.hasParam('/path?key=foo#key&key=baz', 'key'));\n  },\n\n  testSameDomainPathsDiffer() {\n    const uri1 = 'http://www.google.com/a';\n    const uri2 = 'http://www.google.com/b';\n    assertTrue(utils.haveSameDomain(uri1, uri2));\n    assertTrue(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainSchemesDiffer() {\n    const uri1 = 'http://www.google.com';\n    const uri2 = 'https://www.google.com';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainPortsDiffer() {\n    const uri1 = 'http://www.google.com:1234/a';\n    const uri2 = 'http://www.google.com/b';\n    const uri3 = 'http://www.google.com:2345/b';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n    assertFalse(utils.haveSameDomain(uri1, uri3));\n  },\n\n  testSameDomainDomainsDiffer() {\n    const uri1 = '/a';\n    const uri2 = 'http://www.google.com/b';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainSubDomainDiffers() {\n    const uri1 = 'http://www.google.com/a';\n    const uri2 = 'http://mail.google.com/b';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainNoDomain() {\n    const uri1 = '/a';\n    const uri2 = '/b';\n    assertTrue(utils.haveSameDomain(uri1, uri2));\n    assertTrue(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testBuildFromEncodedParts() {\n    assertEquals(\n        'should handle full URL',\n        'http://foo@www.google.com:80/path?q=query#fragment',\n        utils.buildFromEncodedParts(\n            'http', 'foo', 'www.google.com', 80, '/path', 'q=query',\n            'fragment'));\n    assertEquals(\n        'should handle unspecified parameters', '/search',\n        utils.buildFromEncodedParts(null, null, undefined, null, '/search'));\n    assertEquals(\n        'should handle params of non-primitive types',\n        'http://foo@www.google.com:80/path?q=query#fragment',\n        utils.buildFromEncodedParts(\n            new HasString('http'), new HasString('foo'),\n            new HasString('www.google.com'), new HasString('80'),\n            new HasString('/path'), new HasString('q=query'),\n            new HasString('fragment')));\n  },\n\n  testAppendParam() {\n    assertEquals(\n        'http://foo.com?q=1', utils.appendParam('http://foo.com', 'q', 1));\n    assertEquals(\n        'http://foo.com?q=1#preserve',\n        utils.appendParam('http://foo.com#preserve', 'q', 1));\n    assertEquals(\n        'should tolerate a lone question mark', 'http://foo.com?q=1',\n        utils.appendParam('http://foo.com?', 'q', 1));\n    assertEquals(\n        'http://foo.com?q=1&r=2',\n        utils.appendParam('http://foo.com?q=1', 'r', 2));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3#preserve',\n        utils.appendParam('http://foo.com?q=1&r=2#preserve', 's', 3));\n    assertEquals('?q=1#preserve', utils.appendParam('#preserve', 'q', 1));\n  },\n\n  testBuildQueryData() {\n    assertEquals(\n        'q=1&r=2&s=3&s=4', utils.buildQueryData(['q', 1, 'r', 2, 's', [3, 4]]));\n    assertEquals('', utils.buildQueryData([]));\n  },\n\n  testAppendParams() {\n    assertEquals('http://foo.com', utils.appendParams('http://foo.com'));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        'http://foo.com?a=1&q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com?a=1#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com?#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        '?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams('#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        'A question mark must not be appended if there are no ' +\n            'parameters, otherwise repeated appends will be broken.',\n        'http://foo.com#test', utils.appendParams('http://foo.com#test'));\n    assertEquals(\n        'If a ? is already in the URL, it should be preserved when appending ' +\n            '0 params',\n        'http://foo.com?#test', utils.appendParams('http://foo.com?#test'));\n    assertEquals(\n        'should handle objects with to-string', 'http://foo.com?q=a&r=b',\n        utils.appendParams(\n            'http://foo.com', 'q', new HasString('a'), 'r',\n            [new HasString('b')]));\n\n    assertThrows(\n        'appendParams should fail with an odd number of arguments.', () => {\n          utils.appendParams('http://foo.com', 'a', 1, 'b');\n        });\n  },\n\n  testValuelessParam() {\n    assertEquals('http://foo.com?q', utils.appendParam('http://foo.com', 'q'));\n    assertEquals(\n        'http://foo.com?q',\n        utils.appendParam('http://foo.com', 'q', null /* opt_value */));\n    assertEquals(\n        'http://foo.com?q#preserve',\n        utils.appendParam('http://foo.com#preserve', 'q'));\n    assertEquals(\n        'should tolerate a lone question mark', 'http://foo.com?q',\n        utils.appendParam('http://foo.com?', 'q'));\n    assertEquals(\n        'http://foo.com?q=1&r', utils.appendParam('http://foo.com?q=1', 'r'));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s#preserve',\n        utils.appendParam('http://foo.com?q=1&r=2#preserve', 's'));\n    assertTrue(utils.hasParam('http://foo.com?q=1&r=2&s#preserve', 's'));\n  },\n\n  testAppendParamsAsArray() {\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', ['q', 1, 'r', 2, 's', [3, 4]]));\n    assertEquals(\n        'http://foo.com?q=1&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', ['q', 1, 'r', null, 's', [3, 4]]));\n    assertEquals(\n        'http://foo.com?q=1&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', ['q', 1, 'r', undefined, 's', [3, 4]]));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4&s=null&s=undefined#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve',\n            ['q', 1, 'r', 2, 's', [3, new HasString('4'), null, undefined]]));\n  },\n\n  testAppendParamEscapes() {\n    assertEquals(\n        'http://foo.com?h=a%20b',\n        utils.appendParams('http://foo.com', 'h', 'a b'));\n    assertEquals('h=a%20b', utils.buildQueryData(['h', 'a b']));\n    assertEquals('h=a%20b', utils.buildQueryDataFromMap({'h': 'a b'}));\n  },\n\n  testAppendParamsFromMap() {\n    const uri = utils.appendParamsFromMap(\n        'http://www.foo.com',\n        {'a': 1, 'b': 'bob', 'c': [1, 2, new HasString('3')]});\n    assertArrayEquals(['1'], utils.getParamValues(uri, 'a'));\n    assertArrayEquals(['bob'], utils.getParamValues(uri, 'b'));\n    assertArrayEquals(['1', '2', '3'], utils.getParamValues(uri, 'c'));\n  },\n\n  testBuildQueryDataFromMap() {\n    assertEquals('a=1', utils.buildQueryDataFromMap({'a': 1}));\n    const uri = 'foo.com?' +\n        utils.buildQueryDataFromMap(\n            {'a': 1, 'b': 'bob', 'c': [1, 2, new HasString('3')]});\n    assertArrayEquals(['1'], utils.getParamValues(uri, 'a'));\n    assertArrayEquals(['bob'], utils.getParamValues(uri, 'b'));\n    assertArrayEquals(['1', '2', '3'], utils.getParamValues(uri, 'c'));\n  },\n\n  testMultiParamSkipsNullParams() {\n    // For the multi-param functions, null and undefined keys should be\n    // skipped, but null within a parameter array should still be appended.\n    assertEquals(\n        'buildQueryDataFromMap', 'a=null',\n        utils.buildQueryDataFromMap({'a': [null], 'b': null, 'c': undefined}));\n    assertEquals(\n        'buildQueryData', 'a=null',\n        utils.buildQueryData(['a', [null], 'b', null, 'c', undefined]));\n    assertEquals(\n        'appendParams', 'foo.com?a=null',\n        utils.appendParams('foo.com', 'a', [null], 'b', null, 'c', undefined));\n    assertEquals(\n        'empty strings should NOT be skipped', 'foo.com?a&b',\n        utils.appendParams('foo.com', 'a', [''], 'b', ''));\n  },\n\n  testRemoveParam() {\n    assertEquals(\n        'remove middle', 'http://foo.com?q=1&s=3',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3', 'r'));\n    assertEquals(\n        'remove first', 'http://foo.com?r=2&s=3',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3', 'q'));\n    assertEquals(\n        'remove last', 'http://foo.com?q=1&r=2',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3', 's'));\n    assertEquals(\n        'remove only param', 'http://foo.com',\n        utils.removeParam('http://foo.com?q=1', 'q'));\n  },\n\n  testRemoveParamWithFragment() {\n    assertEquals(\n        'remove middle', 'http://foo.com?q=1&s=3#?r=1&r=1',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3#?r=1&r=1', 'r'));\n    assertEquals(\n        'remove first', 'http://foo.com?r=2&s=3#?q=1&q=1',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3#?q=1&q=1', 'q'));\n    assertEquals(\n        'remove only param', 'http://foo.com#?q=1&q=1',\n        utils.removeParam('http://foo.com?q=1#?q=1&q=1', 'q'));\n    assertEquals(\n        'remove last', 'http://foo.com?q=1&r=2#?s=1&s=1',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3#?s=1&s=1', 's'));\n  },\n\n  testRemoveNonExistent() {\n    assertEquals(\n        'remove key not present', 'http://foo.com?q=1',\n        utils.removeParam('http://foo.com?q=1', 'nosuchkey'));\n    assertEquals(\n        'remove key not present', 'http://foo.com#q=1',\n        utils.removeParam('http://foo.com#q=1', 'q'));\n    assertEquals(\n        'remove key from empty string', '', utils.removeParam('', 'nosuchkey'));\n  },\n\n  testRemoveMultiple() {\n    assertEquals(\n        'remove four of the same', 'http://foo.com',\n        utils.removeParam('http://foo.com?q=1&q=2&q=3&q=4', 'q'));\n    assertEquals(\n        'remove four of the same with another one in the middle',\n        'http://foo.com?a=99',\n        utils.removeParam('http://foo.com?q=1&q=2&a=99&q=3&q=4', 'q'));\n  },\n\n  testSetParam() {\n    assertEquals(\n        'middle, no fragment', 'http://foo.com?q=1&s=3&r=999',\n        utils.setParam('http://foo.com?q=1&r=2&s=3', 'r', 999));\n    assertEquals(\n        'middle', 'http://foo.com?q=1&s=3&r=999#?r=1&r=1',\n        utils.setParam('http://foo.com?q=1&r=2&s=3#?r=1&r=1', 'r', 999));\n    assertEquals(\n        'first', 'http://foo.com?r=2&s=3&q=999#?q=1&q=1',\n        utils.setParam('http://foo.com?q=1&r=2&s=3#?q=1&q=1', 'q', 999));\n    assertEquals(\n        'only param', 'http://foo.com?q=999#?q=1&q=1',\n        utils.setParam('http://foo.com?q=1#?q=1&q=1', 'q', 999));\n    assertEquals(\n        'last', 'http://foo.com?q=1&r=2&s=999#?s=1&s=1',\n        utils.setParam('http://foo.com?q=1&r=2&s=3#?s=1&s=1', 's', 999));\n    assertEquals(\n        'multiple', 'http://foo.com?s=999#?s=1&s=1',\n        utils.setParam('http://foo.com?s=1&s=2&s=3#?s=1&s=1', 's', 999));\n    assertEquals(\n        'none', 'http://foo.com?r=1&s=999#?s=1&s=1',\n        utils.setParam('http://foo.com?r=1#?s=1&s=1', 's', 999));\n  },\n\n  testSetParamsFromMap() {\n    // These helper assertions are needed because the input is an Object and\n    // we cannot gaurauntee an order.\n    function assertQueryEquals(message, expected, actual) {\n      const expectedQuery = utils.getQueryData(expected);\n      const actualQuery = utils.getQueryData(actual);\n      assertEquals(\n          `Unmatched param count. ${message}`, expectedQuery.split('&').length,\n          actualQuery.split('&').length);\n\n      // Build a map of all of the params for actual.\n      const actualParams = {};\n      utils.parseQueryData(actualQuery, (key, value) => {\n        if (actualParams[key]) {\n          actualParams[key].push(value);\n        } else {\n          actualParams[key] = [value];\n        }\n      });\n\n      for (let key in actualParams) {\n        const expectedParams = utils.getParamValues(actual, key);\n        assertArrayEquals(\n            `Unmatched param ${key}, ${message}`, expectedParams.sort(),\n            actualParams[key].sort());\n      }\n    }\n\n    function assertUriEquals(message, expected, actual) {\n      message = ` for expected URI: \"${expected}\", actual: \"${actual}\"`;\n      const expectedComps = utils.split(expected);\n      const actualComps = utils.split(actual);\n      for (let i = 1; i < expectedComps.length; i++) {\n        if (i === utils.ComponentIndex.QUERY_DATA) {\n          assertQueryEquals(message, expected, actual);\n        } else {\n          assertEquals(message, expectedComps[i], actualComps[i]);\n        }\n      }\n    }\n\n    assertEquals(\n        'remove some params', 'http://foo.com/bar?b=2#b=5',\n        utils.setParamsFromMap(\n            'http://foo.com/bar?a=1&b=2&c=3#b=5', {a: null, c: undefined}));\n    assertEquals(\n        'remove all params', 'http://foo.com#b=5',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&c=3#b=5',\n            {a: null, b: null, c: undefined}));\n    assertEquals(\n        'update one param', 'http://foo.com?b=2&c=3&a=999#b=5',\n        utils.setParamsFromMap('http://foo.com?a=1&b=2&c=3#b=5', {a: 999}));\n    assertEquals(\n        'remove one param, update one param', 'http://foo.com?b=2&a=999',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&c=3', {a: 999, c: null}));\n    assertEquals(\n        'multiple params unmodified', 'http://foo.com?b=2&b=20&b&a=999',\n        utils.setParamsFromMap('http://foo.com?a=1&b=2&b=20&b', {a: 999}));\n    assertEquals(\n        'update multiple values', 'http://foo.com?a=1&c=3&b=5&b&b=10',\n        utils.setParamsFromMap('http://foo.com?a=1&b=2&c=3', {b: [5, '', 10]}));\n    // Tests that update/add multiple params must use assertUriEquals.\n    assertUriEquals(\n        'add from blank query', 'http://foo.com?a=100&b=200#hash',\n        utils.setParamsFromMap('http://foo.com#hash', {a: 100, b: 200}));\n    assertUriEquals(\n        'replace multiple params', 'http://foo.com?d=4&a=100&b=200&c=300',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&b=20&c=3&d=4', {a: 100, b: 200, c: 300}));\n    // update 1, remove b, keep c as is, add d.\n    assertUriEquals(\n        'add, remove and update', 'http://foo.com?a=100&c=3&d=400',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&b=20&c=3', {a: 100, b: null, d: 400}));\n  },\n\n  testModifyQueryParams() {\n    let uri = 'http://foo.com?a=A&a=A2&b=B&b=B2&c=C';\n\n    uri = utils.appendParam(uri, 'd', 'D');\n    assertEquals('http://foo.com?a=A&a=A2&b=B&b=B2&c=C&d=D', uri);\n\n    uri = utils.removeParam(uri, 'd');\n    uri = utils.appendParam(uri, 'd', 'D2');\n    assertEquals('http://foo.com?a=A&a=A2&b=B&b=B2&c=C&d=D2', uri);\n\n    uri = utils.removeParam(uri, 'a');\n    uri = utils.appendParam(uri, 'a', 'A3');\n    assertEquals('http://foo.com?b=B&b=B2&c=C&d=D2&a=A3', uri);\n\n    uri = utils.removeParam(uri, 'a');\n    uri = utils.appendParam(uri, 'a', 'A4');\n    assertEquals('A4', utils.getParamValue(uri, 'a'));\n  },\n\n  testBrowserEncoding() {\n    // Sanity check borrowed from old code to ensure that encodeURIComponent\n    // is good enough.  Entire test should be safe to delete.\n    const allowedInFragment = /[A-Za-z0-9\\-\\._~!$&'()*+,;=:@/?]/g;\n\n    const sb = [];\n    for (let i = 33; i < 500; i++) {  // arbitrarily use first 500 chars.\n      sb.push(String.fromCharCode(i));\n    }\n    const testString = sb.join('');\n\n    let encodedStr = encodeURIComponent(testString);\n\n    // Strip all percent encoded characters, as they're ok.\n    encodedStr = encodedStr.replace(/%[0-9A-F][0-9A-F]/g, '');\n\n    // Remove allowed characters.\n    encodedStr = encodedStr.replace(allowedInFragment, '');\n\n    // Only illegal characters should remain, which is a fail.\n    assertEquals('String should be empty', 0, encodedStr.length);\n  },\n\n  testAppendPath() {\n    let uri = 'http://www.foo.com';\n    const expected = `${uri}/dummy`;\n    assertEquals(\n        'Path has no trailing \"/\", adding with leading \"/\" failed', expected,\n        utils.appendPath(uri, '/dummy'));\n    assertEquals(\n        'Path has no trailing \"/\", adding with no leading \"/\" failed', expected,\n        utils.appendPath(uri, 'dummy'));\n    uri = `${uri}/`;\n    assertEquals(\n        'Path has trailing \"/\", adding with leading \"/\" failed', expected,\n        utils.appendPath(uri, '/dummy'));\n\n    assertEquals(\n        'Path has trailing \"/\", adding with no leading \"/\" failed', expected,\n        utils.appendPath(uri, 'dummy'));\n  },\n\n  testMakeUnique() {\n    assertEquals(\n        'http://www.google.com?zx=RANDOM#blob',\n        utils.makeUnique('http://www.google.com#blob'));\n    assertEquals(\n        'http://www.google.com?a=1&b=2&zx=RANDOM#blob',\n        utils.makeUnique('http://www.google.com?zx=9&a=1&b=2#blob'));\n  },\n\n  testParseQuery() {\n    const result = [];\n    utils.parseQueryData(\n        'foo=bar&no&empty=&tricky%3D%26=%3D%26&=nothing&=&', (name, value) => {\n          result.push(name, value);\n        });\n    assertArrayEquals(\n        [\n          'foo',\n          'bar',\n          'no',\n          '',\n          'empty',\n          '',\n          'tricky%3D%26',\n          '=&',\n          '',\n          'nothing',\n          '',\n          '',\n          '',\n          '',\n        ],\n        result);\n\n    // Go thought buildQueryData and parseQueryData and see if we get the same\n    // result.\n    const result2 = [];\n    utils.parseQueryData(utils.buildQueryData(result), (name, value) => {\n      result2.push(name, value);\n    });\n    assertArrayEquals(result, result2);\n\n    utils.parseQueryData(\n        '', goog.partial(fail, 'Empty string should not run callback'));\n  },\n\n  testSetPath() {\n    assertEquals(\n        'http://www.google.com/bar',\n        utils.setPath('http://www.google.com', 'bar'));\n    assertEquals(\n        'http://www.google.com/bar',\n        utils.setPath('http://www.google.com', '/bar'));\n    assertEquals(\n        'http://www.google.com/bar/',\n        utils.setPath('http://www.google.com', 'bar/'));\n    assertEquals(\n        'http://www.google.com/bar/',\n        utils.setPath('http://www.google.com', '/bar/'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/?q=t', '/bar'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/?q=t', 'bar'));\n    assertEquals(\n        'http://www.google.com/bar/?q=t',\n        utils.setPath('http://www.google.com/?q=t', 'bar/'));\n    assertEquals(\n        'http://www.google.com/bar/?q=t',\n        utils.setPath('http://www.google.com/?q=t', '/bar/'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/foo?q=t', 'bar'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/foo?q=t', '/bar'));\n    assertEquals(\n        'https://www.google.com/bar?q=t&q1=y',\n        utils.setPath('https://www.google.com/foo?q=t&q1=y', 'bar'));\n    assertEquals(\n        'https://www.google.com:8113/bar?q=t&q1=y',\n        utils.setPath('https://www.google.com:8113?q=t&q1=y', 'bar'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', 'foo/bar'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', '/foo/bar'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar/?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', 'foo/bar/'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar/?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', '/foo/bar/'));\n    assertEquals(\n        'https://www.google.com:8113/?q=t&q1=y',\n        utils.setPath('https://www.google.com:8113/foobar?q=t&q1=y', ''));\n  },\n});\n"], "fixing_code": ["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Simple utilities for dealing with URI strings.\n *\n * This is intended to be a lightweight alternative to constructing goog.Uri\n * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless\n * of how much of its functionality you use, this is designed to be a set of\n * mostly-independent utilities so that the compiler includes only what is\n * necessary for the task.  Estimated savings of porting is 5k pre-gzip and\n * 1.5k post-gzip.  To ensure the savings remain, future developers should\n * avoid adding new functionality to existing functions, but instead create\n * new ones and factor out shared code.\n *\n * Many of these utilities have limited functionality, tailored to common\n * cases.  The query parameter utilities assume that the parameter keys are\n * already encoded, since most keys are compile-time alphanumeric strings.  The\n * query parameter mutation utilities also do not tolerate fragment identifiers.\n *\n * By design, these functions can be slower than goog.Uri equivalents.\n * Repeated calls to some of functions may be quadratic in behavior for IE,\n * although the effect is somewhat limited given the 2kb limit.\n *\n * One advantage of the limited functionality here is that this approach is\n * less sensitive to differences in URI encodings than goog.Uri, since these\n * functions operate on strings directly, rather than decoding them and\n * then re-encoding.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\ngoog.provide('goog.uri.utils.QueryArray');\ngoog.provide('goog.uri.utils.QueryValue');\ngoog.provide('goog.uri.utils.StandardQueryParam');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.string');\n\n\n/**\n * Character codes inlined to avoid object allocations due to charCode.\n * @enum {number}\n * @private\n */\ngoog.uri.utils.CharCode_ = {\n  AMPERSAND: 38,\n  EQUAL: 61,\n  HASH: 35,\n  QUESTION: 63\n};\n\n\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?string=} opt_scheme The scheme such as 'http'.\n * @param {?string=} opt_userInfo The user name before the '@'.\n * @param {?string=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {(string|number|null)=} opt_port The port number.\n * @param {?string=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?string=} opt_queryData The URI-encoded query data.\n * @param {?string=} opt_fragment The URI-encoded fragment identifier.\n * @return {string} The fully combined URI.\n */\ngoog.uri.utils.buildFromEncodedParts = function(\n    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,\n    opt_fragment) {\n  var out = '';\n\n  if (opt_scheme) {\n    out += opt_scheme + ':';\n  }\n\n  if (opt_domain) {\n    out += '//';\n\n    if (opt_userInfo) {\n      out += opt_userInfo + '@';\n    }\n\n    out += opt_domain;\n\n    if (opt_port) {\n      out += ':' + opt_port;\n    }\n  }\n\n  if (opt_path) {\n    out += opt_path;\n  }\n\n  if (opt_queryData) {\n    out += '?' + opt_queryData;\n  }\n\n  if (opt_fragment) {\n    out += '#' + opt_fragment;\n  }\n\n  return out;\n};\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n *\n * TODO(user): separate out the authority terminating characters once this\n * file is moved to ES6.\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +  // Anchor against the entire string.\n    '(?:' +\n    '([^:/?#.]+)' +  // scheme - ignore special characters\n                     // used by other URL parts such as :,\n                     // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^\\\\\\\\/?#]*)@)?' +  // userInfo\n    '([^\\\\\\\\/?#]*?)' +       // domain\n    '(?::([0-9]+))?' +       // port\n    '(?=[\\\\\\\\/?#]|$)' +      // authority-terminating character.\n    ')?' +\n    '([^?#]+)?' +          // path\n    '(?:\\\\?([^#]*))?' +    // query\n    '(?:#([\\\\s\\\\S]*))?' +  // fragment. Can't use '.*' with 's' flag as Firefox\n                           // doesn't support the flag, and can't use an\n                           // \"everything set\" ([^]) as IE10 doesn't match any\n                           // characters with it.\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n\n\n/**\n * @param {?string} uri A possibly null string.\n * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986\n *     reserved characters will not be removed.\n * @return {?string} The string URI-decoded, or null if uri is null.\n * @private\n */\ngoog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {\n  if (!uri) {\n    return uri;\n  }\n\n  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);\n};\n\n\n/**\n * Gets a URI component by index.\n *\n * It is preferred to use the getPathEncoded() variety of functions ahead,\n * since they are more readable.\n *\n * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.\n * @param {string} uri The URI to examine.\n * @return {?string} The still-encoded component, or null if the component\n *     is not present.\n * @private\n */\ngoog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {\n  // Convert undefined, null, and empty string into null.\n  return goog.uri.utils.split(uri)[componentIndex] || null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The protocol or scheme, or null if none.  Does not\n *     include trailing colons or slashes.\n */\ngoog.uri.utils.getScheme = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.SCHEME, uri);\n};\n\n\n/**\n * Gets the effective scheme for the URL.  If the URL is relative then the\n * scheme is derived from the page's location.\n * @param {string} uri The URI to examine.\n * @return {string} The protocol or scheme, always lower case.\n */\ngoog.uri.utils.getEffectiveScheme = function(uri) {\n  var scheme = goog.uri.utils.getScheme(uri);\n  if (!scheme && goog.global.self && goog.global.self.location) {\n    var protocol = goog.global.self.location.protocol;\n    scheme = protocol.substr(0, protocol.length - 1);\n  }\n  // NOTE: When called from a web worker in Firefox 3.5, location may be null.\n  // All other browsers with web workers support self.location from the worker.\n  return scheme ? scheme.toLowerCase() : '';\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The user name still encoded, or null if none.\n */\ngoog.uri.utils.getUserInfoEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.USER_INFO, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded user info, or null if none.\n */\ngoog.uri.utils.getUserInfo = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getUserInfoEncoded(uri));\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The domain name still encoded, or null if none.\n */\ngoog.uri.utils.getDomainEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.DOMAIN, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded domain, or null if none.\n */\ngoog.uri.utils.getDomain = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?number} The port number, or null if none.\n */\ngoog.uri.utils.getPort = function(uri) {\n  // Coerce to a number.  If the result of getComponentByIndex_ is null or\n  // non-numeric, the number coersion yields NaN.  This will then return\n  // null for all non-numeric cases (though also zero, which isn't a relevant\n  // port number).\n  return Number(\n             goog.uri.utils.getComponentByIndex_(\n                 goog.uri.utils.ComponentIndex.PORT, uri)) ||\n      null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The path still encoded, or null if none. Includes the\n *     leading slash, if any.\n */\ngoog.uri.utils.getPathEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.PATH, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded path, or null if none.  Includes the leading\n *     slash, if any.\n */\ngoog.uri.utils.getPath = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The query data still encoded, or null if none.  Does not\n *     include the question mark itself.\n */\ngoog.uri.utils.getQueryData = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The fragment identifier, or null if none.  Does not\n *     include the hash mark itself.\n */\ngoog.uri.utils.getFragmentEncoded = function(uri) {\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @param {?string} fragment The encoded fragment identifier, or null if none.\n *     Does not include the hash mark itself.\n * @return {string} The URI with the fragment set.\n */\ngoog.uri.utils.setFragmentEncoded = function(uri, fragment) {\n  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded fragment identifier, or null if none.  Does\n *     not include the hash mark.\n */\ngoog.uri.utils.getFragment = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getFragmentEncoded(uri));\n};\n\n\n/**\n * Extracts everything up to the port of the URI.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getHost = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME],\n      pieces[goog.uri.utils.ComponentIndex.USER_INFO],\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Returns the origin for a given URL.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getOrigin = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Extracts the path of the URL and everything after.\n * @param {string} uri The URI string.\n * @return {string} The URI, starting at the path and including the query\n *     parameters and fragment identifier.\n */\ngoog.uri.utils.getPathAndAfter = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],\n      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Gets the URI with the fragment identifier removed.\n * @param {string} uri The URI to examine.\n * @return {string} Everything preceding the hash mark.\n */\ngoog.uri.utils.removeFragment = function(uri) {\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);\n};\n\n\n/**\n * Ensures that two URI's have the exact same domain, scheme, and port.\n *\n * Unlike the version in goog.Uri, this checks protocol, and therefore is\n * suitable for checking against the browser's same-origin policy.\n *\n * @param {string} uri1 The first URI.\n * @param {string} uri2 The second URI.\n * @return {boolean} Whether they have the same scheme, domain and port.\n */\ngoog.uri.utils.haveSameDomain = function(uri1, uri2) {\n  var pieces1 = goog.uri.utils.split(uri1);\n  var pieces2 = goog.uri.utils.split(uri2);\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==\n      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&\n      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==\n      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&\n      pieces1[goog.uri.utils.ComponentIndex.PORT] ==\n      pieces2[goog.uri.utils.ComponentIndex.PORT];\n};\n\n\n/**\n * Asserts that there are no fragment or query identifiers, only in uncompiled\n * mode.\n * @param {string} uri The URI to examine.\n * @private\n */\ngoog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {\n  goog.asserts.assert(\n      uri.indexOf('#') < 0 && uri.indexOf('?') < 0,\n      'goog.uri.utils: Fragment or query identifiers are not supported: [%s]',\n      uri);\n};\n\n\n/**\n * Supported query parameter values by the parameter serializing utilities.\n *\n * If a value is null or undefined, the key-value pair is skipped, as an easy\n * way to omit parameters conditionally.  Non-array parameters are converted\n * to a string and URI encoded.  Array values are expanded into multiple\n * &key=value pairs, with each element stringized and URI-encoded.\n *\n * @typedef {*}\n */\ngoog.uri.utils.QueryValue;\n\n\n/**\n * An array representing a set of query parameters with alternating keys\n * and values.\n *\n * Keys are assumed to be URI encoded already and live at even indices.  See\n * goog.uri.utils.QueryValue for details on how parameter values are encoded.\n *\n * Example:\n * <pre>\n * var data = [\n *   // Simple param: ?name=BobBarker\n *   'name', 'BobBarker',\n *   // Conditional param -- may be omitted entirely.\n *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,\n *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null\n *   'house', ['LosAngeles', 'NewYork', null]\n * ];\n * </pre>\n *\n * @typedef {!Array<string|goog.uri.utils.QueryValue>}\n */\ngoog.uri.utils.QueryArray;\n\n\n/**\n * Parses encoded query parameters and calls callback function for every\n * parameter found in the string.\n *\n * Missing value of parameter (e.g. \u201c\u2026&key&\u2026\u201d) is treated as if the value was an\n * empty string.  Keys may be empty strings (e.g. \u201c\u2026&=value&\u2026\u201d) which also means\n * that \u201c\u2026&=&\u2026\u201d and \u201c\u2026&&\u2026\u201d will result in an empty key and value.\n *\n * @param {string} encodedQuery Encoded query string excluding question mark at\n *     the beginning.\n * @param {function(string, string)} callback Function called for every\n *     parameter found in query string.  The first argument (name) will not be\n *     urldecoded (so the function is consistent with buildQueryData), but the\n *     second will.  If the parameter has no value (i.e. \u201c=\u201d was not present)\n *     the second argument (value) will be an empty string.\n */\ngoog.uri.utils.parseQueryData = function(encodedQuery, callback) {\n  if (!encodedQuery) {\n    return;\n  }\n  var pairs = encodedQuery.split('&');\n  for (var i = 0; i < pairs.length; i++) {\n    var indexOfEquals = pairs[i].indexOf('=');\n    var name = null;\n    var value = null;\n    if (indexOfEquals >= 0) {\n      name = pairs[i].substring(0, indexOfEquals);\n      value = pairs[i].substring(indexOfEquals + 1);\n    } else {\n      name = pairs[i];\n    }\n    callback(name, value ? goog.string.urlDecode(value) : '');\n  }\n};\n\n\n/**\n * Split the URI into 3 parts where the [1] is the queryData without a leading\n * '?'. For example, the URI http://foo.com/bar?a=b#abc returns\n * ['http://foo.com/bar','a=b','#abc'].\n * @param {string} uri The URI to parse.\n * @return {!Array<string>} An array representation of uri of length 3 where the\n *     middle value is the queryData without a leading '?'.\n * @private\n */\ngoog.uri.utils.splitQueryData_ = function(uri) {\n  // Find the query data and hash.\n  var hashIndex = uri.indexOf('#');\n  if (hashIndex < 0) {\n    hashIndex = uri.length;\n  }\n  var questionIndex = uri.indexOf('?');\n  var queryData;\n  if (questionIndex < 0 || questionIndex > hashIndex) {\n    questionIndex = hashIndex;\n    queryData = '';\n  } else {\n    queryData = uri.substring(questionIndex + 1, hashIndex);\n  }\n  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];\n};\n\n\n/**\n * Join an array created by splitQueryData_ back into a URI.\n * @param {!Array<string>} parts A URI in the form generated by splitQueryData_.\n * @return {string} The joined URI.\n * @private\n */\ngoog.uri.utils.joinQueryData_ = function(parts) {\n  return parts[0] + (parts[1] ? '?' + parts[1] : '') + parts[2];\n};\n\n\n/**\n * @param {string} queryData\n * @param {string} newData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryData_ = function(queryData, newData) {\n  if (!newData) {\n    return queryData;\n  }\n  return queryData ? queryData + '&' + newData : newData;\n};\n\n\n/**\n * @param {string} uri\n * @param {string} queryData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {\n  if (!queryData) {\n    return uri;\n  }\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Appends key=value pairs to an array, supporting multi-valued objects.\n * @param {*} key The key prefix.\n * @param {goog.uri.utils.QueryValue} value The value to serialize.\n * @param {!Array<string>} pairs The array to which the 'key=value' strings\n *     should be appended.\n * @private\n */\ngoog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {\n  goog.asserts.assertString(key);\n  if (Array.isArray(value)) {\n    // Convince the compiler it's an array.\n    goog.asserts.assertArray(value);\n    for (var j = 0; j < value.length; j++) {\n      // Convert to string explicitly, to short circuit the null and array\n      // logic in this function -- this ensures that null and undefined get\n      // written as literal 'null' and 'undefined', and arrays don't get\n      // expanded out but instead encoded in the default way.\n      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);\n    }\n  } else if (value != null) {\n    // Skip a top-level null or undefined entirely.\n    pairs.push(\n        key +\n        // Check for empty string. Zero gets encoded into the url as literal\n        // strings.  For empty string, skip the equal sign, to be consistent\n        // with UriBuilder.java.\n        (value === '' ? '' : '=' + goog.string.urlEncode(value)));\n  }\n};\n\n\n/**\n * Builds a query data string from a sequence of alternating keys and values.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!IArrayLike<string|goog.uri.utils.QueryValue>} keysAndValues\n *     Alternating keys and values. See the QueryArray typedef.\n * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {\n  goog.asserts.assert(\n      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,\n      'goog.uri.utils: Key/value lists must be even in length.');\n\n  var params = [];\n  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {\n    var key = /** @type {string} */ (keysAndValues[i]);\n    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Builds a query data string from a map.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!Object<string, goog.uri.utils.QueryValue>} map An object where keys\n *     are URI-encoded parameter keys, and the values are arbitrary types\n *     or arrays. Keys with a null value are dropped.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryDataFromMap = function(map) {\n  var params = [];\n  for (var key in map) {\n    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Appends URI parameters to an existing URI.\n *\n * The variable arguments may contain alternating keys and values.  Keys are\n * assumed to be already URI encoded.  The values should not be URI-encoded,\n * and will instead be encoded by this function.\n * <pre>\n * appendParams('http://www.foo.com?existing=true',\n *     'key1', 'value1',\n *     'key2', 'value?willBeEncoded',\n *     'key3', ['valueA', 'valueB', 'valueC'],\n *     'key4', null);\n * result: 'http://www.foo.com?existing=true&' +\n *     'key1=value1&' +\n *     'key2=value%3FwillBeEncoded&' +\n *     'key3=valueA&key3=valueB&key3=valueC'\n * </pre>\n *\n * A single call to this function will not exhibit quadratic behavior in IE,\n * whereas multiple repeated calls may, although the effect is limited by\n * fact that URL's generally can't exceed 2kb.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}\n * var_args\n *     An array or argument list conforming to goog.uri.utils.QueryArray.\n * @return {string} The URI with all query parameters added.\n */\ngoog.uri.utils.appendParams = function(uri, var_args) {\n  var queryData = arguments.length == 2 ?\n      goog.uri.utils.buildQueryData(arguments[1], 0) :\n      goog.uri.utils.buildQueryData(arguments, 1);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends query parameters from a map.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object<goog.uri.utils.QueryValue>} map An object where keys are\n *     URI-encoded parameter keys, and the values are arbitrary types or arrays.\n *     Keys with a null value are dropped.\n * @return {string} The new parameters.\n */\ngoog.uri.utils.appendParamsFromMap = function(uri, map) {\n  var queryData = goog.uri.utils.buildQueryDataFromMap(map);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends a single URI parameter.\n *\n * Repeated calls to this can exhibit quadratic behavior in IE6 due to the\n * way string append works, though it should be limited given the 2kb limit.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} key The key, which must already be URI encoded.\n * @param {*=} opt_value The value, which will be stringized and encoded\n *     (assumed not already to be encoded).  If omitted, undefined, or null, the\n *     key will be added as a valueless parameter.\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.appendParam = function(uri, key, opt_value) {\n  var value = (opt_value != null) ? '=' + goog.string.urlEncode(opt_value) : '';\n  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);\n};\n\n\n/**\n * Finds the next instance of a query parameter with the specified name.\n *\n * Does not instantiate any objects.\n *\n * @param {string} uri The URI to search.  May contain a fragment identifier\n *     if opt_hashIndex is specified.\n * @param {number} startIndex The index to begin searching for the key at.  A\n *     match may be found even if this is one character after the ampersand.\n * @param {string} keyEncoded The URI-encoded key.\n * @param {number} hashOrEndIndex Index to stop looking at.  If a hash\n *     mark is present, it should be its index, otherwise it should be the\n *     length of the string.\n * @return {number} The position of the first character in the key's name,\n *     immediately after either a question mark or a dot.\n * @private\n */\ngoog.uri.utils.findParam_ = function(\n    uri, startIndex, keyEncoded, hashOrEndIndex) {\n  var index = startIndex;\n  var keyLength = keyEncoded.length;\n\n  // Search for the key itself and post-filter for surronuding punctuation,\n  // rather than expensively building a regexp.\n  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&\n         index < hashOrEndIndex) {\n    var precedingChar = uri.charCodeAt(index - 1);\n    // Ensure that the preceding character is '&' or '?'.\n    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n        precedingChar == goog.uri.utils.CharCode_.QUESTION) {\n      // Ensure the following character is '&', '=', '#', or NaN\n      // (end of string).\n      var followingChar = uri.charCodeAt(index + keyLength);\n      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||\n          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n          followingChar == goog.uri.utils.CharCode_.HASH) {\n        return index;\n      }\n    }\n    index += keyLength + 1;\n  }\n\n  return -1;\n};\n\n\n/**\n * Regular expression for finding a hash mark or end of string.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.hashOrEndRe_ = /#|$/;\n\n\n/**\n * Determines if the URI contains a specific key.\n *\n * Performs no object instantiations.\n *\n * @param {string} uri The URI to process.  May contain a fragment\n *     identifier.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {boolean} Whether the key is present.\n */\ngoog.uri.utils.hasParam = function(uri, keyEncoded) {\n  return goog.uri.utils.findParam_(\n             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;\n};\n\n\n/**\n * Gets the first value of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {?string} The first value of the parameter (URI-decoded), or null\n *     if the parameter is not found.\n */\ngoog.uri.utils.getParamValue = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var foundIndex =\n      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);\n\n  if (foundIndex < 0) {\n    return null;\n  } else {\n    var endPosition = uri.indexOf('&', foundIndex);\n    if (endPosition < 0 || endPosition > hashOrEndIndex) {\n      endPosition = hashOrEndIndex;\n    }\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > endPosition.\n    return goog.string.urlDecode(\n        uri.substr(foundIndex, endPosition - foundIndex));\n  }\n};\n\n\n/**\n * Gets all values of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {!Array<string>} All URI-decoded values with the given key.\n *     If the key is not found, this will have length 0, but never be null.\n */\ngoog.uri.utils.getParamValues = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var result = [];\n\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Find where this parameter ends, either the '&' or the end of the\n    // query parameters.\n    position = uri.indexOf('&', foundIndex);\n    if (position < 0 || position > hashOrEndIndex) {\n      position = hashOrEndIndex;\n    }\n\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > position.\n    result.push(\n        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));\n  }\n\n  return result;\n};\n\n\n/**\n * Regexp to find trailing question marks and ampersands.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;\n\n\n/**\n * Removes all instances of a query parameter.\n * @param {string} uri The URI to process.  Must not contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.\n * @return {string} The URI with all instances of the parameter removed.\n */\ngoog.uri.utils.removeParam = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var buffer = [];\n\n  // Look for a query parameter.\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Get the portion of the query string up to, but not including, the ?\n    // or & starting the parameter.\n    buffer.push(uri.substring(position, foundIndex));\n    // Progress to immediately after the '&'.  If not found, go to the end.\n    // Avoid including the hash mark.\n    position = Math.min(\n        (uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);\n  }\n\n  // Append everything that is remaining.\n  buffer.push(uri.substr(position));\n\n  // Join the buffer, and remove trailing punctuation that remains.\n  return buffer.join('').replace(\n      goog.uri.utils.trailingQueryPunctuationRe_, '$1');\n};\n\n\n/**\n * Replaces all existing definitions of a parameter with a single definition.\n *\n * Repeated calls to this can exhibit quadratic behavior due to the need to\n * find existing instances and reconstruct the string, though it should be\n * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap\n * to update multiple parameters in bulk.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} keyEncoded The key, which must already be URI encoded.\n * @param {*} value The value, which will be stringized and encoded (assumed\n *     not already to be encoded).\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.setParam = function(uri, keyEncoded, value) {\n  return goog.uri.utils.appendParam(\n      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);\n};\n\n\n/**\n * Effeciently set or remove multiple query parameters in a URI. Order of\n * unchanged parameters will not be modified, all updated parameters will be\n * appended to the end of the query. Params with values of null or undefined are\n * removed.\n *\n * @param {string} uri The URI to process.\n * @param {!Object<string, goog.uri.utils.QueryValue>} params A list of\n *     parameters to update. If null or undefined, the param will be removed.\n * @return {string} An updated URI where the query data has been updated with\n *     the params.\n */\ngoog.uri.utils.setParamsFromMap = function(uri, params) {\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  var queryData = parts[1];\n  var buffer = [];\n  if (queryData) {\n    goog.array.forEach(queryData.split('&'), function(pair) {\n      var indexOfEquals = pair.indexOf('=');\n      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;\n      if (!params.hasOwnProperty(name)) {\n        buffer.push(pair);\n      }\n    });\n  }\n  parts[1] = goog.uri.utils.appendQueryData_(\n      buffer.join('&'), goog.uri.utils.buildQueryDataFromMap(params));\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Generates a URI path using a given URI and a path with checks to\n * prevent consecutive \"//\". The baseUri passed in must not contain\n * query or fragment identifiers. The path to append may not contain query or\n * fragment identifiers.\n *\n * @param {string} baseUri URI to use as the base.\n * @param {string} path Path to append.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.appendPath = function(baseUri, path) {\n  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);\n\n  // Remove any trailing '/'\n  if (goog.string.endsWith(baseUri, '/')) {\n    baseUri = baseUri.substr(0, baseUri.length - 1);\n  }\n  // Remove any leading '/'\n  if (goog.string.startsWith(path, '/')) {\n    path = path.substr(1);\n  }\n  return goog.string.buildString(baseUri, '/', path);\n};\n\n\n/**\n * Replaces the path.\n * @param {string} uri URI to use as the base.\n * @param {string} path New path.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.setPath = function(uri, path) {\n  // Add any missing '/'.\n  if (!goog.string.startsWith(path, '/')) {\n    path = '/' + path;\n  }\n  var parts = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      parts[goog.uri.utils.ComponentIndex.SCHEME],\n      parts[goog.uri.utils.ComponentIndex.USER_INFO],\n      parts[goog.uri.utils.ComponentIndex.DOMAIN],\n      parts[goog.uri.utils.ComponentIndex.PORT], path,\n      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Standard supported query parameters.\n * @enum {string}\n */\ngoog.uri.utils.StandardQueryParam = {\n\n  /** Unused parameter for unique-ifying. */\n  RANDOM: 'zx'\n};\n\n\n/**\n * Sets the zx parameter of a URI to a random value.\n * @param {string} uri Any URI.\n * @return {string} That URI with the \"zx\" parameter added or replaced to\n *     contain a random string.\n */\ngoog.uri.utils.makeUnique = function(uri) {\n  return goog.uri.utils.setParam(\n      uri, goog.uri.utils.StandardQueryParam.RANDOM,\n      goog.string.getRandomString());\n};\n", "/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.module('goog.uri.utilsTest');\ngoog.setTestOnly();\n\nconst functions = goog.require('goog.functions');\nconst googString = goog.require('goog.string');\nconst testSuite = goog.require('goog.testing.testSuite');\nconst utils = goog.require('goog.uri.utils');\n\n/** Simple class with a constant toString. */\nclass HasString {\n  /** @param {string} stringValue The result of toString. */\n  constructor(stringValue) {\n    this.value_ = stringValue;\n  }\n\n  /** @override */\n  toString() {\n    return this.value_;\n  }\n}\n\ntestSuite({\n  setUpPage() {\n    googString.getRandomString = functions.constant('RANDOM');\n  },\n\n  tearDown() {},\n\n  testSplit() {\n    const uri =\n        'http://www.google.com:80/path%20path+path?q=query&hl=en#fragment';\n    assertEquals('http', utils.getScheme(uri));\n    assertNull(utils.getUserInfoEncoded(uri));\n    assertNull(utils.getUserInfo(uri));\n    assertEquals('www.google.com', utils.getDomainEncoded(uri));\n    assertEquals('www.google.com', utils.getDomain(uri));\n    assertEquals(80, utils.getPort(uri));\n    assertEquals('/path%20path+path', utils.getPathEncoded(uri));\n    assertEquals('/path path+path', utils.getPath(uri));\n    assertEquals('q=query&hl=en', utils.getQueryData(uri));\n    assertEquals('fragment', utils.getFragmentEncoded(uri));\n    assertEquals('fragment', utils.getFragment(uri));\n\n    assertEquals(\n        utils.getDomain('http://[2607:f8b0:4006:802::1006]'),\n        '[2607:f8b0:4006:802::1006]');\n    assertEquals(\n        utils.getDomain('http://[2607:f8b0:4006:802::1006]:80'),\n        '[2607:f8b0:4006:802::1006]');\n    assertEquals(utils.getPort('http://[2607:f8b0:4006:802::1006]:80'), 80);\n    assertEquals(utils.getDomain('http://[2607]:80/?q=]'), '[2607]');\n    assertEquals(utils.getDomain('http://!!!'), '!!!');\n    assertNull(utils.getPath('http://!!!'));\n    assertNull(utils.getScheme('www.x.com:80'));\n    assertEquals(\n        'Query data with no fragment identifier', 'foo=bar&baz=bin',\n        utils.getQueryData('http://google.com?foo=bar&baz=bin'));\n  },\n\n  testSplitWithNewline() {\n    const uri = 'http://www.google.com:80/path%20path+path?q=query#frag\\nment';\n    assertEquals('http', utils.getScheme(uri));\n    assertNull(utils.getUserInfoEncoded(uri));\n    assertNull(utils.getUserInfo(uri));\n    assertEquals('www.google.com', utils.getDomainEncoded(uri));\n    assertEquals('www.google.com', utils.getDomain(uri));\n    assertEquals(80, utils.getPort(uri));\n    assertEquals('/path%20path+path', utils.getPathEncoded(uri));\n    assertEquals('/path path+path', utils.getPath(uri));\n    assertEquals('q=query', utils.getQueryData(uri));\n    assertEquals('frag\\nment', utils.getFragmentEncoded(uri));\n    assertEquals('frag\\nment', utils.getFragment(uri));\n  },\n\n  testMailtoUri() {\n    const uri = 'mailto:joe+random@hominid.com';\n    assertNull(utils.getDomain(uri));\n    assertEquals('mailto', utils.getScheme(uri));\n    assertEquals('joe+random@hominid.com', utils.getPath(uri));\n  },\n\n  testSplitRelativeUri() {\n    const uri = '/path%20path+path?q=query&hl=en#fragment';\n    assertNull(utils.getScheme(uri));\n    assertNull(utils.getDomain(uri));\n    assertNull(utils.getDomainEncoded(uri));\n    assertNull(utils.getPort(uri));\n    assertEquals('/path%20path+path', utils.getPathEncoded(uri));\n    assertEquals('/path path+path', utils.getPath(uri));\n    assertEquals('q=query&hl=en', utils.getQueryData(uri));\n    assertEquals('fragment', utils.getFragmentEncoded(uri));\n    assertEquals('fragment', utils.getFragment(uri));\n  },\n\n  testSplitMaliciousUri() {\n    const uri = 'https://malicious.com\\\\test.google.com';\n    assertEquals('https', utils.getScheme(uri));\n    assertEquals('malicious.com', utils.getDomain(uri));\n    assertEquals('malicious.com', utils.getDomainEncoded(uri));\n    assertNull(utils.getPort(uri));\n    assertEquals('\\\\test.google.com', utils.getPathEncoded(uri));\n    assertEquals('\\\\test.google.com', utils.getPath(uri));\n    assertNull(utils.getQueryData(uri));\n    assertNull(utils.getFragmentEncoded(uri));\n    assertNull(utils.getFragment(uri));\n  },\n\n  testSplitMaliciousUriUsername() {\n    const uri = 'https://malicious.com\\\\@test.google.com';\n    assertEquals('https', utils.getScheme(uri));\n    assertEquals('malicious.com', utils.getDomain(uri));\n    assertEquals('malicious.com', utils.getDomainEncoded(uri));\n    assertNull(utils.getPort(uri));\n    assertEquals('\\\\@test.google.com', utils.getPathEncoded(uri));\n    assertEquals('\\\\@test.google.com', utils.getPath(uri));\n    assertNull(utils.getQueryData(uri));\n    assertNull(utils.getFragmentEncoded(uri));\n    assertNull(utils.getFragment(uri));\n  },\n\n  testSplitBadAuthority() {\n    // This URL has a syntax error per the RFC (port number must be digits, and\n    // host cannot contain a colon except in [...]). This test is solely to\n    // 'document' the current behavior, which may affect application handling\n    // of erroneous URLs.\n    assertEquals(utils.getDomain('http://host:port/'), 'host:port');\n    assertNull(utils.getPort('http://host:port/'));\n  },\n\n  testSplitIntoHostAndPath() {\n    // Splitting into host and path takes care of one of the major use cases\n    // of resolve, without implementing a generic algorithm that undoubtedly\n    // requires a huge footprint.\n    const uri =\n        'http://www.google.com:80/path%20path+path?q=query&hl=en#fragment';\n    assertEquals('http://www.google.com:80', utils.getHost(uri));\n    assertEquals(\n        '/path%20path+path?q=query&hl=en#fragment', utils.getPathAndAfter(uri));\n\n    const uri2 = 'http://www.google.com/calendar';\n    assertEquals(\n        'should handle missing fields', 'http://www.google.com',\n        utils.getHost(uri2));\n    assertEquals(\n        'should handle missing fields', '/calendar',\n        utils.getPathAndAfter(uri2));\n  },\n\n  testGetOrigin() {\n    const uri =\n        'http://foo:pw@www.google.com:80/path%20path+path?q=query&hl=en#fragment';\n    assertEquals('http://www.google.com:80', utils.getOrigin(uri));\n  },\n\n  testRelativeUrisHaveNoPath() {\n    assertNull(utils.getPathEncoded('?hello'));\n  },\n\n  testReservedCharacters() {\n    const o = '%6F';\n    const uri = `http://www.g${o}ogle.com%40/xxx%2feee/ccc`;\n    assertEquals(\n        'Should not decode reserved characters in path', '/xxx%2feee/ccc',\n        utils.getPath(uri));\n    assertEquals(\n        'Should not decode reserved characters in domain', 'www.google.com%40',\n        utils.getDomain(uri));\n  },\n\n  testSetFragmentEncoded() {\n    const expected = 'http://www.google.com/path#bar';\n    assertEquals(\n        expected,\n        utils.setFragmentEncoded('http://www.google.com/path#foo', 'bar'));\n\n    assertEquals(\n        expected,\n        utils.setFragmentEncoded('http://www.google.com/path', 'bar'));\n\n    assertEquals(\n        'http://www.google.com/path',\n        utils.setFragmentEncoded('http://www.google.com/path', ''));\n\n    assertEquals(\n        'http://www.google.com/path',\n        utils.setFragmentEncoded('http://www.google.com/path', null));\n  },\n\n  testGetParamValue() {\n    assertEquals(\n        'v1',\n        utils.getParamValue('/path?key=v1&c=d&keywithsuffix=v3&key=v2', 'key'));\n\n    assertEquals(\n        'v1',\n        utils.getParamValue('/path?kEY=v1&c=d&keywithsuffix=v3&key=v2', 'kEY'));\n  },\n\n  testGetParamValues() {\n    assertArrayEquals(\n        'should ignore confusing suffixes', ['v1', 'v2'],\n        utils.getParamValues(\n            '/path?a=b&key=v1&c=d&key=v2&keywithsuffix=v3', 'key'));\n    assertArrayEquals(\n        'should be case sensitive', ['v2'],\n        utils.getParamValues(\n            '/path?a=b&keY=v1&c=d&KEy=v2&keywithsuffix=v3', 'KEy'));\n    assertArrayEquals(\n        'should work for the first parameter', ['v1', 'v2'],\n        utils.getParamValues(\n            '/path?key=v1&c=d&key=v2&keywithsuffix=v3', 'key'));\n    assertArrayEquals(\n        'should work for the last parameter', ['v1', 'v2'],\n        utils.getParamValues(\n            '/path?key=v1&c=d&keywithsuffix=v3&key=v2', 'key'));\n    assertArrayEquals(\n        ['1'], utils.getParamValues('http://foo.com?q=1#?q=2&q=3', 'q'));\n  },\n\n  testGetParamValueAllowsEqualInValues() {\n    assertEquals(\n        'equals signs can appear unencoded', 'v1=v2',\n        utils.getParamValue('/path?key=v1=v2', 'key'));\n    assertArrayEquals(\n        ['v1=v2=v3'], utils.getParamValues('/path?key=v1=v2=v3', 'key'));\n  },\n\n  testGetParamValueNoSuchKey() {\n    const uri = '/path?key=v1&c=d&keywithsuffix=v3&key=v2';\n    assertNull(utils.getParamValue(uri, 'nosuchkey'));\n    assertArrayEquals([], utils.getParamValues(uri, 'nosuchkey'));\n    assertFalse(utils.hasParam(uri, 'nosuchkey'));\n    assertNull(utils.getParamValue('q=1', 'q'));\n    assertEquals('1', utils.getParamValue('?q=1', 'q'));\n  },\n\n  testGetParamValueEmptyAndMissingValueStrings() {\n    assertEquals('', utils.getParamValue('/path?key&bar', 'key'));\n    assertEquals('', utils.getParamValue('/path?foo=bar&key', 'key'));\n    assertEquals('', utils.getParamValue('/path?key', 'key'));\n    assertEquals('', utils.getParamValue('/path?key=', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?key', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?key&bar', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?foo=bar&key', 'key'));\n    assertArrayEquals([''], utils.getParamValues('/path?foo=bar&key=', 'key'));\n    assertArrayEquals(\n        ['', '', '', 'j', ''],\n        utils.getParamValues('/path?key&key&key=&key=j&key', 'key'));\n    assertArrayEquals(\n        ['', '', '', '', ''],\n        utils.getParamValues('/pathqqq?q&qq&q&q=&q&q', 'q'));\n    assertTrue(utils.hasParam('/path?key=', 'key'));\n  },\n\n  testGetParamValueDecoding() {\n    assertEquals(\n        'plus should be supported as alias of space', 'foo bar baz',\n        utils.getParamValue('/path?key=foo+bar%20baz', 'key'));\n    assertArrayEquals(\n        ['foo bar baz'],\n        utils.getParamValues('/path?key=foo%20bar%20baz', 'key'));\n  },\n\n  testGetParamIgnoresParamsInFragmentIdentifiers() {\n    assertFalse(utils.hasParam('/path?bah#a&key=foo', 'key'));\n    assertEquals(null, utils.getParamValue('/path?bah#a&key=bar', 'key'));\n    assertArrayEquals([], utils.getParamValues('/path?bah#a&key=bar', 'key'));\n  },\n\n  testGetParamIgnoresExcludesFragmentFromParameterValue() {\n    // Make sure the '#' doesn't get included anywhere, for parameter values\n    // of different lengths.\n    assertEquals(\n        'foo', utils.getParamValue('/path?key=foo#key=bar&key=baz', 'key'));\n    assertArrayEquals(\n        ['foo'], utils.getParamValues('/path?key=foo#key=bar&key=baz', 'key'));\n    assertEquals('', utils.getParamValue('/path?key#key=bar&key=baz', 'key'));\n    assertArrayEquals(\n        [''], utils.getParamValues('/path?key#key=bar&key=baz', 'key'));\n    assertEquals(\n        'x', utils.getParamValue('/path?key=x#key=bar&key=baz', 'key'));\n    assertArrayEquals(\n        ['x'], utils.getParamValues('/path?key=x#key=bar&key=baz', 'key'));\n\n    // Simply make sure hasParam doesn't die in this case.\n    assertTrue(utils.hasParam('/path?key=foo#key=bar&key=baz', 'key'));\n    assertTrue(utils.hasParam('/path?key=foo#key&key=baz', 'key'));\n  },\n\n  testSameDomainPathsDiffer() {\n    const uri1 = 'http://www.google.com/a';\n    const uri2 = 'http://www.google.com/b';\n    assertTrue(utils.haveSameDomain(uri1, uri2));\n    assertTrue(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainSchemesDiffer() {\n    const uri1 = 'http://www.google.com';\n    const uri2 = 'https://www.google.com';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainPortsDiffer() {\n    const uri1 = 'http://www.google.com:1234/a';\n    const uri2 = 'http://www.google.com/b';\n    const uri3 = 'http://www.google.com:2345/b';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n    assertFalse(utils.haveSameDomain(uri1, uri3));\n  },\n\n  testSameDomainDomainsDiffer() {\n    const uri1 = '/a';\n    const uri2 = 'http://www.google.com/b';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainSubDomainDiffers() {\n    const uri1 = 'http://www.google.com/a';\n    const uri2 = 'http://mail.google.com/b';\n    assertFalse(utils.haveSameDomain(uri1, uri2));\n    assertFalse(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testSameDomainNoDomain() {\n    const uri1 = '/a';\n    const uri2 = '/b';\n    assertTrue(utils.haveSameDomain(uri1, uri2));\n    assertTrue(utils.haveSameDomain(uri2, uri1));\n  },\n\n  testBuildFromEncodedParts() {\n    assertEquals(\n        'should handle full URL',\n        'http://foo@www.google.com:80/path?q=query#fragment',\n        utils.buildFromEncodedParts(\n            'http', 'foo', 'www.google.com', 80, '/path', 'q=query',\n            'fragment'));\n    assertEquals(\n        'should handle unspecified parameters', '/search',\n        utils.buildFromEncodedParts(null, null, undefined, null, '/search'));\n    assertEquals(\n        'should handle params of non-primitive types',\n        'http://foo@www.google.com:80/path?q=query#fragment',\n        utils.buildFromEncodedParts(\n            new HasString('http'), new HasString('foo'),\n            new HasString('www.google.com'), new HasString('80'),\n            new HasString('/path'), new HasString('q=query'),\n            new HasString('fragment')));\n  },\n\n  testAppendParam() {\n    assertEquals(\n        'http://foo.com?q=1', utils.appendParam('http://foo.com', 'q', 1));\n    assertEquals(\n        'http://foo.com?q=1#preserve',\n        utils.appendParam('http://foo.com#preserve', 'q', 1));\n    assertEquals(\n        'should tolerate a lone question mark', 'http://foo.com?q=1',\n        utils.appendParam('http://foo.com?', 'q', 1));\n    assertEquals(\n        'http://foo.com?q=1&r=2',\n        utils.appendParam('http://foo.com?q=1', 'r', 2));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3#preserve',\n        utils.appendParam('http://foo.com?q=1&r=2#preserve', 's', 3));\n    assertEquals('?q=1#preserve', utils.appendParam('#preserve', 'q', 1));\n  },\n\n  testBuildQueryData() {\n    assertEquals(\n        'q=1&r=2&s=3&s=4', utils.buildQueryData(['q', 1, 'r', 2, 's', [3, 4]]));\n    assertEquals('', utils.buildQueryData([]));\n  },\n\n  testAppendParams() {\n    assertEquals('http://foo.com', utils.appendParams('http://foo.com'));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        'http://foo.com?a=1&q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com?a=1#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com?#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        '?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams('#preserve', 'q', 1, 'r', 2, 's', [3, 4]));\n    assertEquals(\n        'A question mark must not be appended if there are no ' +\n            'parameters, otherwise repeated appends will be broken.',\n        'http://foo.com#test', utils.appendParams('http://foo.com#test'));\n    assertEquals(\n        'If a ? is already in the URL, it should be preserved when appending ' +\n            '0 params',\n        'http://foo.com?#test', utils.appendParams('http://foo.com?#test'));\n    assertEquals(\n        'should handle objects with to-string', 'http://foo.com?q=a&r=b',\n        utils.appendParams(\n            'http://foo.com', 'q', new HasString('a'), 'r',\n            [new HasString('b')]));\n\n    assertThrows(\n        'appendParams should fail with an odd number of arguments.', () => {\n          utils.appendParams('http://foo.com', 'a', 1, 'b');\n        });\n  },\n\n  testValuelessParam() {\n    assertEquals('http://foo.com?q', utils.appendParam('http://foo.com', 'q'));\n    assertEquals(\n        'http://foo.com?q',\n        utils.appendParam('http://foo.com', 'q', null /* opt_value */));\n    assertEquals(\n        'http://foo.com?q#preserve',\n        utils.appendParam('http://foo.com#preserve', 'q'));\n    assertEquals(\n        'should tolerate a lone question mark', 'http://foo.com?q',\n        utils.appendParam('http://foo.com?', 'q'));\n    assertEquals(\n        'http://foo.com?q=1&r', utils.appendParam('http://foo.com?q=1', 'r'));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s#preserve',\n        utils.appendParam('http://foo.com?q=1&r=2#preserve', 's'));\n    assertTrue(utils.hasParam('http://foo.com?q=1&r=2&s#preserve', 's'));\n  },\n\n  testAppendParamsAsArray() {\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', ['q', 1, 'r', 2, 's', [3, 4]]));\n    assertEquals(\n        'http://foo.com?q=1&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', ['q', 1, 'r', null, 's', [3, 4]]));\n    assertEquals(\n        'http://foo.com?q=1&s=3&s=4#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve', ['q', 1, 'r', undefined, 's', [3, 4]]));\n    assertEquals(\n        'http://foo.com?q=1&r=2&s=3&s=4&s=null&s=undefined#preserve',\n        utils.appendParams(\n            'http://foo.com#preserve',\n            ['q', 1, 'r', 2, 's', [3, new HasString('4'), null, undefined]]));\n  },\n\n  testAppendParamEscapes() {\n    assertEquals(\n        'http://foo.com?h=a%20b',\n        utils.appendParams('http://foo.com', 'h', 'a b'));\n    assertEquals('h=a%20b', utils.buildQueryData(['h', 'a b']));\n    assertEquals('h=a%20b', utils.buildQueryDataFromMap({'h': 'a b'}));\n  },\n\n  testAppendParamsFromMap() {\n    const uri = utils.appendParamsFromMap(\n        'http://www.foo.com',\n        {'a': 1, 'b': 'bob', 'c': [1, 2, new HasString('3')]});\n    assertArrayEquals(['1'], utils.getParamValues(uri, 'a'));\n    assertArrayEquals(['bob'], utils.getParamValues(uri, 'b'));\n    assertArrayEquals(['1', '2', '3'], utils.getParamValues(uri, 'c'));\n  },\n\n  testBuildQueryDataFromMap() {\n    assertEquals('a=1', utils.buildQueryDataFromMap({'a': 1}));\n    const uri = 'foo.com?' +\n        utils.buildQueryDataFromMap(\n            {'a': 1, 'b': 'bob', 'c': [1, 2, new HasString('3')]});\n    assertArrayEquals(['1'], utils.getParamValues(uri, 'a'));\n    assertArrayEquals(['bob'], utils.getParamValues(uri, 'b'));\n    assertArrayEquals(['1', '2', '3'], utils.getParamValues(uri, 'c'));\n  },\n\n  testMultiParamSkipsNullParams() {\n    // For the multi-param functions, null and undefined keys should be\n    // skipped, but null within a parameter array should still be appended.\n    assertEquals(\n        'buildQueryDataFromMap', 'a=null',\n        utils.buildQueryDataFromMap({'a': [null], 'b': null, 'c': undefined}));\n    assertEquals(\n        'buildQueryData', 'a=null',\n        utils.buildQueryData(['a', [null], 'b', null, 'c', undefined]));\n    assertEquals(\n        'appendParams', 'foo.com?a=null',\n        utils.appendParams('foo.com', 'a', [null], 'b', null, 'c', undefined));\n    assertEquals(\n        'empty strings should NOT be skipped', 'foo.com?a&b',\n        utils.appendParams('foo.com', 'a', [''], 'b', ''));\n  },\n\n  testRemoveParam() {\n    assertEquals(\n        'remove middle', 'http://foo.com?q=1&s=3',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3', 'r'));\n    assertEquals(\n        'remove first', 'http://foo.com?r=2&s=3',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3', 'q'));\n    assertEquals(\n        'remove last', 'http://foo.com?q=1&r=2',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3', 's'));\n    assertEquals(\n        'remove only param', 'http://foo.com',\n        utils.removeParam('http://foo.com?q=1', 'q'));\n  },\n\n  testRemoveParamWithFragment() {\n    assertEquals(\n        'remove middle', 'http://foo.com?q=1&s=3#?r=1&r=1',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3#?r=1&r=1', 'r'));\n    assertEquals(\n        'remove first', 'http://foo.com?r=2&s=3#?q=1&q=1',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3#?q=1&q=1', 'q'));\n    assertEquals(\n        'remove only param', 'http://foo.com#?q=1&q=1',\n        utils.removeParam('http://foo.com?q=1#?q=1&q=1', 'q'));\n    assertEquals(\n        'remove last', 'http://foo.com?q=1&r=2#?s=1&s=1',\n        utils.removeParam('http://foo.com?q=1&r=2&s=3#?s=1&s=1', 's'));\n  },\n\n  testRemoveNonExistent() {\n    assertEquals(\n        'remove key not present', 'http://foo.com?q=1',\n        utils.removeParam('http://foo.com?q=1', 'nosuchkey'));\n    assertEquals(\n        'remove key not present', 'http://foo.com#q=1',\n        utils.removeParam('http://foo.com#q=1', 'q'));\n    assertEquals(\n        'remove key from empty string', '', utils.removeParam('', 'nosuchkey'));\n  },\n\n  testRemoveMultiple() {\n    assertEquals(\n        'remove four of the same', 'http://foo.com',\n        utils.removeParam('http://foo.com?q=1&q=2&q=3&q=4', 'q'));\n    assertEquals(\n        'remove four of the same with another one in the middle',\n        'http://foo.com?a=99',\n        utils.removeParam('http://foo.com?q=1&q=2&a=99&q=3&q=4', 'q'));\n  },\n\n  testSetParam() {\n    assertEquals(\n        'middle, no fragment', 'http://foo.com?q=1&s=3&r=999',\n        utils.setParam('http://foo.com?q=1&r=2&s=3', 'r', 999));\n    assertEquals(\n        'middle', 'http://foo.com?q=1&s=3&r=999#?r=1&r=1',\n        utils.setParam('http://foo.com?q=1&r=2&s=3#?r=1&r=1', 'r', 999));\n    assertEquals(\n        'first', 'http://foo.com?r=2&s=3&q=999#?q=1&q=1',\n        utils.setParam('http://foo.com?q=1&r=2&s=3#?q=1&q=1', 'q', 999));\n    assertEquals(\n        'only param', 'http://foo.com?q=999#?q=1&q=1',\n        utils.setParam('http://foo.com?q=1#?q=1&q=1', 'q', 999));\n    assertEquals(\n        'last', 'http://foo.com?q=1&r=2&s=999#?s=1&s=1',\n        utils.setParam('http://foo.com?q=1&r=2&s=3#?s=1&s=1', 's', 999));\n    assertEquals(\n        'multiple', 'http://foo.com?s=999#?s=1&s=1',\n        utils.setParam('http://foo.com?s=1&s=2&s=3#?s=1&s=1', 's', 999));\n    assertEquals(\n        'none', 'http://foo.com?r=1&s=999#?s=1&s=1',\n        utils.setParam('http://foo.com?r=1#?s=1&s=1', 's', 999));\n  },\n\n  testSetParamsFromMap() {\n    // These helper assertions are needed because the input is an Object and\n    // we cannot gaurauntee an order.\n    function assertQueryEquals(message, expected, actual) {\n      const expectedQuery = utils.getQueryData(expected);\n      const actualQuery = utils.getQueryData(actual);\n      assertEquals(\n          `Unmatched param count. ${message}`, expectedQuery.split('&').length,\n          actualQuery.split('&').length);\n\n      // Build a map of all of the params for actual.\n      const actualParams = {};\n      utils.parseQueryData(actualQuery, (key, value) => {\n        if (actualParams[key]) {\n          actualParams[key].push(value);\n        } else {\n          actualParams[key] = [value];\n        }\n      });\n\n      for (let key in actualParams) {\n        const expectedParams = utils.getParamValues(actual, key);\n        assertArrayEquals(\n            `Unmatched param ${key}, ${message}`, expectedParams.sort(),\n            actualParams[key].sort());\n      }\n    }\n\n    function assertUriEquals(message, expected, actual) {\n      message = ` for expected URI: \"${expected}\", actual: \"${actual}\"`;\n      const expectedComps = utils.split(expected);\n      const actualComps = utils.split(actual);\n      for (let i = 1; i < expectedComps.length; i++) {\n        if (i === utils.ComponentIndex.QUERY_DATA) {\n          assertQueryEquals(message, expected, actual);\n        } else {\n          assertEquals(message, expectedComps[i], actualComps[i]);\n        }\n      }\n    }\n\n    assertEquals(\n        'remove some params', 'http://foo.com/bar?b=2#b=5',\n        utils.setParamsFromMap(\n            'http://foo.com/bar?a=1&b=2&c=3#b=5', {a: null, c: undefined}));\n    assertEquals(\n        'remove all params', 'http://foo.com#b=5',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&c=3#b=5',\n            {a: null, b: null, c: undefined}));\n    assertEquals(\n        'update one param', 'http://foo.com?b=2&c=3&a=999#b=5',\n        utils.setParamsFromMap('http://foo.com?a=1&b=2&c=3#b=5', {a: 999}));\n    assertEquals(\n        'remove one param, update one param', 'http://foo.com?b=2&a=999',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&c=3', {a: 999, c: null}));\n    assertEquals(\n        'multiple params unmodified', 'http://foo.com?b=2&b=20&b&a=999',\n        utils.setParamsFromMap('http://foo.com?a=1&b=2&b=20&b', {a: 999}));\n    assertEquals(\n        'update multiple values', 'http://foo.com?a=1&c=3&b=5&b&b=10',\n        utils.setParamsFromMap('http://foo.com?a=1&b=2&c=3', {b: [5, '', 10]}));\n    // Tests that update/add multiple params must use assertUriEquals.\n    assertUriEquals(\n        'add from blank query', 'http://foo.com?a=100&b=200#hash',\n        utils.setParamsFromMap('http://foo.com#hash', {a: 100, b: 200}));\n    assertUriEquals(\n        'replace multiple params', 'http://foo.com?d=4&a=100&b=200&c=300',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&b=20&c=3&d=4', {a: 100, b: 200, c: 300}));\n    // update 1, remove b, keep c as is, add d.\n    assertUriEquals(\n        'add, remove and update', 'http://foo.com?a=100&c=3&d=400',\n        utils.setParamsFromMap(\n            'http://foo.com?a=1&b=2&b=20&c=3', {a: 100, b: null, d: 400}));\n  },\n\n  testModifyQueryParams() {\n    let uri = 'http://foo.com?a=A&a=A2&b=B&b=B2&c=C';\n\n    uri = utils.appendParam(uri, 'd', 'D');\n    assertEquals('http://foo.com?a=A&a=A2&b=B&b=B2&c=C&d=D', uri);\n\n    uri = utils.removeParam(uri, 'd');\n    uri = utils.appendParam(uri, 'd', 'D2');\n    assertEquals('http://foo.com?a=A&a=A2&b=B&b=B2&c=C&d=D2', uri);\n\n    uri = utils.removeParam(uri, 'a');\n    uri = utils.appendParam(uri, 'a', 'A3');\n    assertEquals('http://foo.com?b=B&b=B2&c=C&d=D2&a=A3', uri);\n\n    uri = utils.removeParam(uri, 'a');\n    uri = utils.appendParam(uri, 'a', 'A4');\n    assertEquals('A4', utils.getParamValue(uri, 'a'));\n  },\n\n  testBrowserEncoding() {\n    // Sanity check borrowed from old code to ensure that encodeURIComponent\n    // is good enough.  Entire test should be safe to delete.\n    const allowedInFragment = /[A-Za-z0-9\\-\\._~!$&'()*+,;=:@/?]/g;\n\n    const sb = [];\n    for (let i = 33; i < 500; i++) {  // arbitrarily use first 500 chars.\n      sb.push(String.fromCharCode(i));\n    }\n    const testString = sb.join('');\n\n    let encodedStr = encodeURIComponent(testString);\n\n    // Strip all percent encoded characters, as they're ok.\n    encodedStr = encodedStr.replace(/%[0-9A-F][0-9A-F]/g, '');\n\n    // Remove allowed characters.\n    encodedStr = encodedStr.replace(allowedInFragment, '');\n\n    // Only illegal characters should remain, which is a fail.\n    assertEquals('String should be empty', 0, encodedStr.length);\n  },\n\n  testAppendPath() {\n    let uri = 'http://www.foo.com';\n    const expected = `${uri}/dummy`;\n    assertEquals(\n        'Path has no trailing \"/\", adding with leading \"/\" failed', expected,\n        utils.appendPath(uri, '/dummy'));\n    assertEquals(\n        'Path has no trailing \"/\", adding with no leading \"/\" failed', expected,\n        utils.appendPath(uri, 'dummy'));\n    uri = `${uri}/`;\n    assertEquals(\n        'Path has trailing \"/\", adding with leading \"/\" failed', expected,\n        utils.appendPath(uri, '/dummy'));\n\n    assertEquals(\n        'Path has trailing \"/\", adding with no leading \"/\" failed', expected,\n        utils.appendPath(uri, 'dummy'));\n  },\n\n  testMakeUnique() {\n    assertEquals(\n        'http://www.google.com?zx=RANDOM#blob',\n        utils.makeUnique('http://www.google.com#blob'));\n    assertEquals(\n        'http://www.google.com?a=1&b=2&zx=RANDOM#blob',\n        utils.makeUnique('http://www.google.com?zx=9&a=1&b=2#blob'));\n  },\n\n  testParseQuery() {\n    const result = [];\n    utils.parseQueryData(\n        'foo=bar&no&empty=&tricky%3D%26=%3D%26&=nothing&=&', (name, value) => {\n          result.push(name, value);\n        });\n    assertArrayEquals(\n        [\n          'foo',\n          'bar',\n          'no',\n          '',\n          'empty',\n          '',\n          'tricky%3D%26',\n          '=&',\n          '',\n          'nothing',\n          '',\n          '',\n          '',\n          '',\n        ],\n        result);\n\n    // Go thought buildQueryData and parseQueryData and see if we get the same\n    // result.\n    const result2 = [];\n    utils.parseQueryData(utils.buildQueryData(result), (name, value) => {\n      result2.push(name, value);\n    });\n    assertArrayEquals(result, result2);\n\n    utils.parseQueryData(\n        '', goog.partial(fail, 'Empty string should not run callback'));\n  },\n\n  testSetPath() {\n    assertEquals(\n        'http://www.google.com/bar',\n        utils.setPath('http://www.google.com', 'bar'));\n    assertEquals(\n        'http://www.google.com/bar',\n        utils.setPath('http://www.google.com', '/bar'));\n    assertEquals(\n        'http://www.google.com/bar/',\n        utils.setPath('http://www.google.com', 'bar/'));\n    assertEquals(\n        'http://www.google.com/bar/',\n        utils.setPath('http://www.google.com', '/bar/'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/?q=t', '/bar'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/?q=t', 'bar'));\n    assertEquals(\n        'http://www.google.com/bar/?q=t',\n        utils.setPath('http://www.google.com/?q=t', 'bar/'));\n    assertEquals(\n        'http://www.google.com/bar/?q=t',\n        utils.setPath('http://www.google.com/?q=t', '/bar/'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/foo?q=t', 'bar'));\n    assertEquals(\n        'http://www.google.com/bar?q=t',\n        utils.setPath('http://www.google.com/foo?q=t', '/bar'));\n    assertEquals(\n        'https://www.google.com/bar?q=t&q1=y',\n        utils.setPath('https://www.google.com/foo?q=t&q1=y', 'bar'));\n    assertEquals(\n        'https://www.google.com:8113/bar?q=t&q1=y',\n        utils.setPath('https://www.google.com:8113?q=t&q1=y', 'bar'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', 'foo/bar'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', '/foo/bar'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar/?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', 'foo/bar/'));\n    assertEquals(\n        'https://www.google.com:8113/foo/bar/?q=t&q1=y',\n        utils.setPath(\n            'https://www.google.com:8113/foobar?q=t&q1=y', '/foo/bar/'));\n    assertEquals(\n        'https://www.google.com:8113/?q=t&q1=y',\n        utils.setPath('https://www.google.com:8113/foobar?q=t&q1=y', ''));\n  },\n});\n"], "filenames": ["closure/goog/uri/utils.js", "closure/goog/uri/utils_test.js"], "buggy_code_start_loc": [175, 108], "buggy_code_end_loc": [195, 108], "fixing_code_start_loc": [176, 109], "fixing_code_end_loc": [201, 122], "type": "NVD-CWE-noinfo", "message": "A URL parsing issue in goog.uri of the Google Closure Library versions up to and including v20200224 allows an attacker to send malicious URLs to be parsed by the library and return the wrong authority. Mitigation: update your library to version v20200315.", "other": {"cve": {"id": "CVE-2020-8910", "sourceIdentifier": "cve-coordination@google.com", "published": "2020-03-26T12:15:12.060", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A URL parsing issue in goog.uri of the Google Closure Library versions up to and including v20200224 allows an attacker to send malicious URLs to be parsed by the library and return the wrong authority. Mitigation: update your library to version v20200315."}, {"lang": "es", "value": "Un problema de an\u00e1lisis de URL en goog.uri de la Google Closure Library versiones hasta v20200224 incluy\u00e9ndola, permite a un atacante enviar URLs maliciosas para que sean analizadas por la biblioteca y devuelva la autoridad errada. Mitigaci\u00f3n: actualice su biblioteca a la versi\u00f3n v20200315."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:closure_library:*:*:*:*:*:*:*:*", "versionEndExcluding": "20200315", "matchCriteriaId": "CD86BB43-BF0F-4DF8-B746-9F597D81BF3D"}]}]}], "references": [{"url": "https://github.com/google/closure-library/commit/294fc00b01d248419d8f8de37580adf2a0024fc9", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/closure-library/releases/tag/v20200315", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/closure-library/commit/294fc00b01d248419d8f8de37580adf2a0024fc9"}}