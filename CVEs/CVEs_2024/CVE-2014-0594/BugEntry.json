{"buggy_code": ["# Filters added to this controller will be run for all controllers in the application.\n# Likewise, all the methods added will be available for all controllers.\n\nrequire 'frontend_compat'\n\nclass Webui::WebuiController < ActionController::Base\n  Rails.cache.set_domain if Rails.cache.respond_to?('set_domain')\n\n  before_filter :setup_view_path\n  before_filter :instantiate_controller_and_action_names\n  before_filter :set_return_to, :reset_activexml, :authenticate\n  before_filter :check_user\n  before_filter :require_configuration\n  after_filter :clean_cache\n\n  # :notice and :alert are default, we add :success and :error\n  add_flash_types :success, :error\n\n  # FIXME: This belongs into the user controller my dear.\n  # Also it would be better, but also more complicated, to just raise\n  # HTTPPaymentRequired, UnauthorizedError or Forbidden\n  # here so the exception handler catches it but what the heck...\n  rescue_from ActiveXML::Transport::ForbiddenError do |exception|\n    if exception.code == 'unregistered_ichain_user'\n      render template: 'user/request_ichain' and return\n    elsif exception.code == 'unregistered_user'\n      render file: Rails.root.join('public/403'), formats: [:html], status: 402, layout: false and return\n    elsif exception.code == 'unconfirmed_user'\n      render file: Rails.root.join('public/402'), formats: [:html], status: 402, layout: false\n    else\n      if User.current.is_nobody?\n        render file: Rails.root.join('public/401'), formats: [:html], status: :unauthorized, layout: false\n      else\n        render file: Rails.root.join('public/403'), formats: [:html], status: :forbidden, layout: false\n      end\n    end\n  end\n  \n  rescue_from ActionController::RedirectBackError do |exception|\n    redirect_to root_path\n  end\n\n  class ValidationError < Exception\n    attr_reader :xml, :errors\n\n    def message\n      errors\n    end\n\n    def initialize( _xml, _errors )\n      @xml = _xml\n      @errors = _errors\n    end\n  end\n\n  class MissingParameterError < Exception; end\n  rescue_from MissingParameterError do |exception|\n    logger.debug \"#{exception.class.name} #{exception.message} #{exception.backtrace.join('\\n')}\"\n    render file: Rails.root.join('public/404'), status: 404, layout: false, formats: [:html]\n  end\n\n  protected\n\n  def set_return_to\n    if params['return_to_host']\n      @return_to_host = params['return_to_host']\n    else\n      # we have a proxy in front of us\n      @return_to_host = ::Configuration.first.obs_url\n      unless @return_to_host\n        # fetch old config value and store in db\n        @return_to_host = CONFIG['external_webui_protocol'] || 'http'\n        @return_to_host += '://'\n        @return_to_host += CONFIG['external_webui_host'] || request.host\n        f = ::Configuration.first\n        f.obs_url = @return_to_host\n        f.save\n      end\n    end\n    @return_to_path = params['return_to_path'] || request.env['ORIGINAL_FULLPATH']\n    logger.debug \"Setting return_to: \\\"#{@return_to_path}\\\"\"\n  end\n\n  def require_login\n    if User.current.is_nobody?\n      render :text => 'Please login' and return false if request.xhr?\n      flash[:error] = 'Please login to access the requested page.'\n      mode = CONFIG['proxy_auth_mode'] || :off\n      if mode == :off\n        redirect_to :controller => :user, :action => :login, :return_to_host => @return_to_host, :return_to_path => @return_to_path\n      else\n        redirect_to :controller => :main, :return_to_host => @return_to_host, :return_to_path => @return_to_path\n      end\n      return false\n    end\n    return true\n  end\n\n  # sets session[:login] if the user is authenticated\n  def authenticate\n    mode = CONFIG['proxy_auth_mode'] || :off\n    logger.debug \"Authenticating with iChain mode: #{mode}\"\n    if mode == :on || mode == :simulate\n      authenticate_proxy\n    else\n      authenticate_form_auth\n    end\n    if session[:login]\n      logger.info \"Authenticated request to \\\"#{@return_to_path}\\\" from #{session[:login]}\"\n    else\n      logger.info \"Anonymous request to #{@return_to_path}\"\n    end\n  end\n\n  def authenticate_proxy\n    mode = CONFIG['proxy_auth_mode'] || :off\n    proxy_user = request.env['HTTP_X_USERNAME']\n    proxy_email = request.env['HTTP_X_EMAIL']\n    if mode == :simulate\n      proxy_user ||= CONFIG['proxy_auth_test_user'] || CONFIG['proxy_test_user']\n      proxy_email ||= CONFIG['proxy_auth_test_email']\n    end \n    if proxy_user\n      session[:login] = proxy_user\n      session[:email] = proxy_email\n      # Set the headers for direct connection to the api, TODO: is this thread safe?\n      ActiveXML::api.set_additional_header( 'X-Username', proxy_user )\n      ActiveXML::api.set_additional_header( 'X-Email', proxy_email ) if proxy_email\n      # FIXME: hot fix to allow new users to login at all again\n      frontend.transport.direct_http(URI(\"/person/#{URI.escape(proxy_user)}\"), :method => 'GET')\n    else\n      session[:login] = nil\n      session[:email] = nil\n    end\n  end\n\n  def authenticate_form_auth\n    if session[:login] and session[:password]\n      # pass credentials to transport plugin, TODO: is this thread safe?\n      ActiveXML::api.login session[:login], session[:password]\n    end\n  end\n\n  def frontend\n    FrontendCompat.new\n  end\n\n  def reset_activexml\n    transport = ActiveXML::api\n    transport.delete_additional_header 'X-Username'\n    transport.delete_additional_header 'X-Email'\n    transport.delete_additional_header 'Authorization'\n  end\n\n  def required_parameters(*parameters)\n    parameters.each do |parameter|\n      unless params.include? parameter.to_s\n        raise MissingParameterError.new \"Required Parameter #{parameter} missing in #{request.url}\"\n      end\n    end\n  end\n\n  def discard_cache?\n    cc = request.headers['HTTP_CACHE_CONTROL']\n    return false if cc.blank?\n    return true if cc == 'max-age=0'\n    return false unless cc == 'no-cache'\n    return !request.xhr?\n  end\n\n  def find_hashed(classname, *args)\n    ret = classname.find( *args )\n    return Xmlhash::XMLHash.new({}) unless ret\n    ret.to_hash\n  end\n\n  def instantiate_controller_and_action_names\n    @current_action = action_name\n    @current_controller = controller_name\n  end\n\n  def check_spiders\n    @spider_bot = false\n    if defined? TREAT_USER_LIKE_BOT or request.env.has_key? 'HTTP_OBS_SPIDER'\n      @spider_bot = true\n    end\n  end\n  private :check_spiders\n\n  def lockout_spiders\n    check_spiders\n    if @spider_bot\n       render :nothing => true\n       return true\n    end\n    return false\n  end\n\n  def check_user\n    check_spiders\n    User.current = nil # reset old users hanging around\n    if session[:login]\n      User.current = User.find_by_login(session[:login])\n    end\n    # TODO: rebase on application_controller and use load_nobdy\n    User.current ||= User.find_by_login('_nobody_')\n  end\n\n  def map_to_workers(arch)\n    case arch\n    when 'i586' then 'x86_64'\n    when 'ppc' then 'ppc64'\n    when 's390' then 's390x'\n    else arch\n    end\n  end\n \n  private\n\n  def put_body_to_tempfile(xmlbody)\n    file = Tempfile.new('xml').path\n    file = File.open(file + '.xml', 'w')\n    file.write(xmlbody)\n    file.close\n    return file.path\n  end\n  private :put_body_to_tempfile\n\n  def require_configuration\n    @configuration = ::Configuration.first\n  end\n\n  # Before filter to check if current user is administrator\n  def require_admin\n    unless User.current.is_admin?\n      flash[:error] = 'Requires admin privileges'\n      redirect_back_or_to :controller => 'main', :action => 'index' and return\n    end\n  end\n\n  # After filter to clean up caches\n  def clean_cache\n  end\n\n  def require_available_architectures\n    @available_architectures = Architecture.where(available: 1)\n  end\n\n  def setup_view_path\n    if CONFIG['theme']\n      theme_path = Rails.root.join('app', 'views', 'webui', 'theme', CONFIG['theme'])\n      prepend_view_path(theme_path)\n    end\n  end\n\n  def check_ajax\n    raise ActionController::RoutingError.new('Expected AJAX call') unless request.xhr?\n  end\nend\n", "require File.expand_path('../boot', __FILE__)\n\nrequire 'rails/all'\n\n# Assets should be precompiled for production (so we don't need the gems loaded then)\nBundler.require(*Rails.groups(assets: %w(development test)))\n\nmodule OBSApi\n  class Application < Rails::Application\n    # Settings in config/environments/* take precedence over those specified here.\n    # Application configuration should go into files in config/initializers\n    # -- all .rb files in that directory are automatically loaded.\n\n    # Custom directories with classes and modules you want to be autoloadable.\n    # config.autoload_paths += %W(#{config.root}/extras)\n\n    # Only load the plugins named here, in the order given (default is alphabetical).\n    # :all can be used as a placeholder for all plugins not explicitly named.\n    # config.plugins = [ :exception_notification, :ssl_requirement, :all ]\n\n    # Activate observers that should always be running.\n    # config.active_record.observers = :cacher, :garbage_collector, :forum_observer\n\n    # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.\n    # Run \"rake -D time\" for a list of tasks for finding time zone names. Default is UTC.\n    # config.time_zone = 'Central Time (US & Canada)'\n\n    # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.\n    # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]\n    # config.i18n.default_locale = :de\n\n    # Configure the default encoding used in templates for Ruby 1.9.\n    config.encoding = \"utf-8\"\n\n    # Configure sensitive parameters which will be filtered from the log file.\n    config.filter_parameters += [:password]\n\n    # Use SQL instead of Active Record's schema dumper when creating the database.\n    # This is necessary if your schema can't be completely dumped by the schema dumper,\n    # like if you have constraints or database-specific column types\n    # config.active_record.schema_format = :sql\n\n    # Enable the asset pipeline\n    config.assets.enabled = true\n\n    # Version of your assets, change this if you want to expire all your assets\n    config.assets.version = '1.0'\n\n    # Skip frameworks you're not going to use\n    #config.frameworks -= [ :action_web_service, :active_resource ]\n\n    # Add additional load paths for your own custom dirs\n    # config.load_paths += %W( #{Rails.root}/extras )\n\n    # Rails.root is not working directory when running under lighttpd, so it has\n    # to be added to load path\n    #config.load_paths << Rails.root unless config.load_paths.include? Rails.root\n    \n    # Force all environments to use the same logger level \n    # (by default production uses :info, the others :debug)\n    # config.log_level = :debug\n    \n    config.log_tags = [:uuid]\n\n    # Use the database for sessions instead of the file system\n    # (create the session table with 'rake create_sessions_table')\n    # config.action_controller.session_store = :active_record_store\n    \n    # put the rubygem requirements here for a clean handling\n    # rake gems:install (installs the needed gems)\n    # rake gems:unpack (this unpacks the gems to vendor/gems)\n    \n    config.cache_store = :dalli_store, 'localhost:11211', {:namespace => 'obs-api', :compress => true }\n    \n    # Activate observers that should always be running\n    # config.active_record.observers = :cacher, :garbage_collector\n    \n    # Make Active Record use UTC-base instead of local time\n    # config.active_record.default_timezone = :utc\n    \n    config.active_record.schema_format = :sql\n    \n    config.action_controller.perform_caching = true\n\n    config.assets.js_compressor = :uglifier\n\n    config.assets.precompile += %w( webui/application/cm2/index.js )\n\n    config.assets.precompile +=\n      %w( dataTables/back_disabled.png\n          dataTables/back_enabled_hover.png\n          dataTables/back_enabled.png\n          dataTables/forward_disabled.png\n          dataTables/forward_enabled_hover.png\n          dataTables/forward_enabled.png\n          dataTables/sort_asc_disabled.png\n          dataTables/sort_asc.png\n          dataTables/sort_both.png\n          dataTables/sort_desc_disabled.png\n          dataTables/sort_desc.png )\n\n    config.action_controller.action_on_unpermitted_parameters = :raise\n\n    config.action_dispatch.rescue_responses.merge!('ActiveXML::Transport::UnauthorizedError' => 401)\n    config.action_dispatch.rescue_responses.merge!('ActiveXML::Transport::ConnectionError' => 503)\n    config.action_dispatch.rescue_responses.merge!('ActiveXML::Transport::Error' => 500)\n    config.action_dispatch.rescue_responses.merge!('Timeout::Error' => 408)\n\n    # avoid a warning\n    I18n.enforce_available_locales = true\n\n    # we're not threadsafe\n    config.allow_concurrency = false\n\n    config.after_initialize do\n      # See Rails::Configuration for more options\n    end unless Rails.env.test?\n  end\nend\n"], "fixing_code": ["# Filters added to this controller will be run for all controllers in the application.\n# Likewise, all the methods added will be available for all controllers.\n\nrequire 'frontend_compat'\n\nclass Webui::WebuiController < ActionController::Base\n  Rails.cache.set_domain if Rails.cache.respond_to?('set_domain')\n\n  before_filter :setup_view_path\n  before_filter :instantiate_controller_and_action_names\n  before_filter :set_return_to, :reset_activexml, :authenticate\n  before_filter :check_user\n  before_filter :require_configuration\n  after_filter :clean_cache\n\n  protect_from_forgery\n\n  # We execute both strategies here. The default rails strategy (resetting the session)\n  # and throwing an exception if the session is handled elswhere (e.g. proxy_auth_mode: :on)\n  def handle_unverified_request\n    super\n    raise ActionController::InvalidAuthenticityToken\n  end\n\n  # :notice and :alert are default, we add :success and :error\n  add_flash_types :success, :error\n\n  # FIXME: This belongs into the user controller my dear.\n  # Also it would be better, but also more complicated, to just raise\n  # HTTPPaymentRequired, UnauthorizedError or Forbidden\n  # here so the exception handler catches it but what the heck...\n  rescue_from ActiveXML::Transport::ForbiddenError do |exception|\n    if exception.code == 'unregistered_ichain_user'\n      render template: 'user/request_ichain' and return\n    elsif exception.code == 'unregistered_user'\n      render file: Rails.root.join('public/403'), formats: [:html], status: 402, layout: false and return\n    elsif exception.code == 'unconfirmed_user'\n      render file: Rails.root.join('public/402'), formats: [:html], status: 402, layout: false\n    else\n      if User.current.is_nobody?\n        render file: Rails.root.join('public/401'), formats: [:html], status: :unauthorized, layout: false\n      else\n        render file: Rails.root.join('public/403'), formats: [:html], status: :forbidden, layout: false\n      end\n    end\n  end\n  \n  rescue_from ActionController::RedirectBackError do |exception|\n    redirect_to root_path\n  end\n\n  class ValidationError < Exception\n    attr_reader :xml, :errors\n\n    def message\n      errors\n    end\n\n    def initialize( _xml, _errors )\n      @xml = _xml\n      @errors = _errors\n    end\n  end\n\n  class MissingParameterError < Exception; end\n  rescue_from MissingParameterError do |exception|\n    logger.debug \"#{exception.class.name} #{exception.message} #{exception.backtrace.join('\\n')}\"\n    render file: Rails.root.join('public/404'), status: 404, layout: false, formats: [:html]\n  end\n\n  protected\n\n  def set_return_to\n    if params['return_to_host']\n      @return_to_host = params['return_to_host']\n    else\n      # we have a proxy in front of us\n      @return_to_host = ::Configuration.first.obs_url\n      unless @return_to_host\n        # fetch old config value and store in db\n        @return_to_host = CONFIG['external_webui_protocol'] || 'http'\n        @return_to_host += '://'\n        @return_to_host += CONFIG['external_webui_host'] || request.host\n        f = ::Configuration.first\n        f.obs_url = @return_to_host\n        f.save\n      end\n    end\n    @return_to_path = params['return_to_path'] || request.env['ORIGINAL_FULLPATH']\n    logger.debug \"Setting return_to: \\\"#{@return_to_path}\\\"\"\n  end\n\n  def require_login\n    if User.current.is_nobody?\n      render :text => 'Please login' and return false if request.xhr?\n      flash[:error] = 'Please login to access the requested page.'\n      mode = CONFIG['proxy_auth_mode'] || :off\n      if mode == :off\n        redirect_to :controller => :user, :action => :login, :return_to_host => @return_to_host, :return_to_path => @return_to_path\n      else\n        redirect_to :controller => :main, :return_to_host => @return_to_host, :return_to_path => @return_to_path\n      end\n      return false\n    end\n    return true\n  end\n\n  # sets session[:login] if the user is authenticated\n  def authenticate\n    mode = CONFIG['proxy_auth_mode'] || :off\n    logger.debug \"Authenticating with iChain mode: #{mode}\"\n    if mode == :on || mode == :simulate\n      authenticate_proxy\n    else\n      authenticate_form_auth\n    end\n    if session[:login]\n      logger.info \"Authenticated request to \\\"#{@return_to_path}\\\" from #{session[:login]}\"\n    else\n      logger.info \"Anonymous request to #{@return_to_path}\"\n    end\n  end\n\n  def authenticate_proxy\n    mode = CONFIG['proxy_auth_mode'] || :off\n    proxy_user = request.env['HTTP_X_USERNAME']\n    proxy_email = request.env['HTTP_X_EMAIL']\n    if mode == :simulate\n      proxy_user ||= CONFIG['proxy_auth_test_user'] || CONFIG['proxy_test_user']\n      proxy_email ||= CONFIG['proxy_auth_test_email']\n    end \n    if proxy_user\n      session[:login] = proxy_user\n      session[:email] = proxy_email\n      # Set the headers for direct connection to the api, TODO: is this thread safe?\n      ActiveXML::api.set_additional_header( 'X-Username', proxy_user )\n      ActiveXML::api.set_additional_header( 'X-Email', proxy_email ) if proxy_email\n      # FIXME: hot fix to allow new users to login at all again\n      frontend.transport.direct_http(URI(\"/person/#{URI.escape(proxy_user)}\"), :method => 'GET')\n    else\n      session[:login] = nil\n      session[:email] = nil\n    end\n  end\n\n  def authenticate_form_auth\n    if session[:login] and session[:password]\n      # pass credentials to transport plugin, TODO: is this thread safe?\n      ActiveXML::api.login session[:login], session[:password]\n    end\n  end\n\n  def frontend\n    FrontendCompat.new\n  end\n\n  def reset_activexml\n    transport = ActiveXML::api\n    transport.delete_additional_header 'X-Username'\n    transport.delete_additional_header 'X-Email'\n    transport.delete_additional_header 'Authorization'\n  end\n\n  def required_parameters(*parameters)\n    parameters.each do |parameter|\n      unless params.include? parameter.to_s\n        raise MissingParameterError.new \"Required Parameter #{parameter} missing in #{request.url}\"\n      end\n    end\n  end\n\n  def discard_cache?\n    cc = request.headers['HTTP_CACHE_CONTROL']\n    return false if cc.blank?\n    return true if cc == 'max-age=0'\n    return false unless cc == 'no-cache'\n    return !request.xhr?\n  end\n\n  def find_hashed(classname, *args)\n    ret = classname.find( *args )\n    return Xmlhash::XMLHash.new({}) unless ret\n    ret.to_hash\n  end\n\n  def instantiate_controller_and_action_names\n    @current_action = action_name\n    @current_controller = controller_name\n  end\n\n  def check_spiders\n    @spider_bot = false\n    if defined? TREAT_USER_LIKE_BOT or request.env.has_key? 'HTTP_OBS_SPIDER'\n      @spider_bot = true\n    end\n  end\n  private :check_spiders\n\n  def lockout_spiders\n    check_spiders\n    if @spider_bot\n       render :nothing => true\n       return true\n    end\n    return false\n  end\n\n  def check_user\n    check_spiders\n    User.current = nil # reset old users hanging around\n    if session[:login]\n      User.current = User.find_by_login(session[:login])\n    end\n    # TODO: rebase on application_controller and use load_nobdy\n    User.current ||= User.find_by_login('_nobody_')\n  end\n\n  def map_to_workers(arch)\n    case arch\n    when 'i586' then 'x86_64'\n    when 'ppc' then 'ppc64'\n    when 's390' then 's390x'\n    else arch\n    end\n  end\n \n  private\n\n  def put_body_to_tempfile(xmlbody)\n    file = Tempfile.new('xml').path\n    file = File.open(file + '.xml', 'w')\n    file.write(xmlbody)\n    file.close\n    return file.path\n  end\n  private :put_body_to_tempfile\n\n  def require_configuration\n    @configuration = ::Configuration.first\n  end\n\n  # Before filter to check if current user is administrator\n  def require_admin\n    unless User.current.is_admin?\n      flash[:error] = 'Requires admin privileges'\n      redirect_back_or_to :controller => 'main', :action => 'index' and return\n    end\n  end\n\n  # After filter to clean up caches\n  def clean_cache\n  end\n\n  def require_available_architectures\n    @available_architectures = Architecture.where(available: 1)\n  end\n\n  def setup_view_path\n    if CONFIG['theme']\n      theme_path = Rails.root.join('app', 'views', 'webui', 'theme', CONFIG['theme'])\n      prepend_view_path(theme_path)\n    end\n  end\n\n  def check_ajax\n    raise ActionController::RoutingError.new('Expected AJAX call') unless request.xhr?\n  end\nend\n", "require File.expand_path('../boot', __FILE__)\n\nrequire 'rails/all'\n\n# Assets should be precompiled for production (so we don't need the gems loaded then)\nBundler.require(*Rails.groups(assets: %w(development test)))\n\nmodule OBSApi\n  class Application < Rails::Application\n    # Settings in config/environments/* take precedence over those specified here.\n    # Application configuration should go into files in config/initializers\n    # -- all .rb files in that directory are automatically loaded.\n\n    # Custom directories with classes and modules you want to be autoloadable.\n    # config.autoload_paths += %W(#{config.root}/extras)\n\n    # Only load the plugins named here, in the order given (default is alphabetical).\n    # :all can be used as a placeholder for all plugins not explicitly named.\n    # config.plugins = [ :exception_notification, :ssl_requirement, :all ]\n\n    # Activate observers that should always be running.\n    # config.active_record.observers = :cacher, :garbage_collector, :forum_observer\n\n    # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.\n    # Run \"rake -D time\" for a list of tasks for finding time zone names. Default is UTC.\n    # config.time_zone = 'Central Time (US & Canada)'\n\n    # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.\n    # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]\n    # config.i18n.default_locale = :de\n\n    # Configure the default encoding used in templates for Ruby 1.9.\n    config.encoding = \"utf-8\"\n\n    # Configure sensitive parameters which will be filtered from the log file.\n    config.filter_parameters += [:password]\n\n    # Use SQL instead of Active Record's schema dumper when creating the database.\n    # This is necessary if your schema can't be completely dumped by the schema dumper,\n    # like if you have constraints or database-specific column types\n    # config.active_record.schema_format = :sql\n\n    # Enable the asset pipeline\n    config.assets.enabled = true\n\n    # Version of your assets, change this if you want to expire all your assets\n    config.assets.version = '1.0'\n\n    # Skip frameworks you're not going to use\n    #config.frameworks -= [ :action_web_service, :active_resource ]\n\n    # Add additional load paths for your own custom dirs\n    # config.load_paths += %W( #{Rails.root}/extras )\n\n    # Rails.root is not working directory when running under lighttpd, so it has\n    # to be added to load path\n    #config.load_paths << Rails.root unless config.load_paths.include? Rails.root\n    \n    # Force all environments to use the same logger level \n    # (by default production uses :info, the others :debug)\n    # config.log_level = :debug\n    \n    config.log_tags = [:uuid]\n\n    # Use the database for sessions instead of the file system\n    # (create the session table with 'rake create_sessions_table')\n    # config.action_controller.session_store = :active_record_store\n    \n    # put the rubygem requirements here for a clean handling\n    # rake gems:install (installs the needed gems)\n    # rake gems:unpack (this unpacks the gems to vendor/gems)\n    \n    config.cache_store = :dalli_store, 'localhost:11211', {:namespace => 'obs-api', :compress => true }\n    \n    # Activate observers that should always be running\n    # config.active_record.observers = :cacher, :garbage_collector\n    \n    # Make Active Record use UTC-base instead of local time\n    # config.active_record.default_timezone = :utc\n    \n    config.active_record.schema_format = :sql\n    \n    config.action_controller.perform_caching = true\n\n    config.assets.js_compressor = :uglifier\n\n    config.assets.precompile += %w( webui/application/cm2/index.js )\n\n    config.assets.precompile +=\n      %w( dataTables/back_disabled.png\n          dataTables/back_enabled_hover.png\n          dataTables/back_enabled.png\n          dataTables/forward_disabled.png\n          dataTables/forward_enabled_hover.png\n          dataTables/forward_enabled.png\n          dataTables/sort_asc_disabled.png\n          dataTables/sort_asc.png\n          dataTables/sort_both.png\n          dataTables/sort_desc_disabled.png\n          dataTables/sort_desc.png )\n\n    config.action_controller.action_on_unpermitted_parameters = :raise\n\n    config.action_dispatch.rescue_responses.merge!('ActiveXML::Transport::UnauthorizedError' => 401)\n    config.action_dispatch.rescue_responses.merge!('ActiveXML::Transport::ConnectionError' => 503)\n    config.action_dispatch.rescue_responses.merge!('ActiveXML::Transport::Error' => 500)\n    config.action_dispatch.rescue_responses.merge!('Timeout::Error' => 408)\n    config.action_dispatch.rescue_responses.merge!('ActionController::InvalidAuthenticityToken' => 403)\n\n    # avoid a warning\n    I18n.enforce_available_locales = true\n\n    # we're not threadsafe\n    config.allow_concurrency = false\n\n    config.after_initialize do\n      # See Rails::Configuration for more options\n    end unless Rails.env.test?\n  end\nend\n"], "filenames": ["src/api/app/controllers/webui/webui_controller.rb", "src/api/config/application.rb"], "buggy_code_start_loc": [14, 107], "buggy_code_end_loc": [14, 107], "fixing_code_start_loc": [15, 108], "fixing_code_end_loc": [24, 109], "type": "CWE-352", "message": "In the Open Build Service (OBS) before version 2.4.6 the CSRF protection is incorrectly disabled in the web interface, allowing for requests without the user's consent.", "other": {"cve": {"id": "CVE-2014-0594", "sourceIdentifier": "meissner@suse.de", "published": "2018-06-08T17:29:00.443", "lastModified": "2019-10-09T23:09:34.523", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Open Build Service (OBS) before version 2.4.6 the CSRF protection is incorrectly disabled in the web interface, allowing for requests without the user's consent."}, {"lang": "es", "value": "En Open Build Service (OBS) en versiones anteriores a la 2.4.6, la protecci\u00f3n CSRF est\u00e1 incorrectamente deshabilitada en la interfaz web, lo que permite realizar peticiones sin el consentimiento del usuario."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "meissner@suse.de", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "meissner@suse.de", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_build_service:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.6", "matchCriteriaId": "90B089F2-81D0-4F82-975E-A0C812FC6560"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=870606", "source": "meissner@suse.de", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/openSUSE/open-build-service/commit/2188c059b67b82171d0e28ef59f77e62d22a09d8", "source": "meissner@suse.de", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/open-build-service/commit/2188c059b67b82171d0e28ef59f77e62d22a09d8"}}