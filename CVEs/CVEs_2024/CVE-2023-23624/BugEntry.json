{"buggy_code": ["# frozen_string_literal: true\n\n#\n# Helps us find topics.\n# Returns a TopicList object containing the topics found.\n#\n\nclass TopicQuery\n  include PrivateMessageLists\n\n  PG_MAX_INT ||= 2_147_483_647\n  DEFAULT_PER_PAGE_COUNT ||= 30\n\n  def self.validators\n    @validators ||=\n      begin\n        int = lambda { |x| Integer === x || (String === x && x.match?(/\\A-?[0-9]+\\z/)) }\n        zero_up_to_max_int = lambda { |x| int.call(x) && x.to_i.between?(0, PG_MAX_INT) }\n        array_or_string = lambda { |x| Array === x || String === x }\n\n        {\n          max_posts: zero_up_to_max_int,\n          min_posts: zero_up_to_max_int,\n          page: zero_up_to_max_int,\n          tags: array_or_string,\n        }\n      end\n  end\n\n  def self.validate?(option, value)\n    if fn = validators[option.to_sym]\n      fn.call(value)\n    else\n      true\n    end\n  end\n\n  def self.public_valid_options\n    # For these to work in Ember, add them to `controllers/discovery-sortable.js`\n    @public_valid_options ||= %i[\n      page\n      before\n      bumped_before\n      topic_ids\n      category\n      order\n      ascending\n      min_posts\n      max_posts\n      status\n      filter\n      state\n      search\n      q\n      f\n      group_name\n      tags\n      match_all_tags\n      no_subcategories\n      no_tags\n      exclude_tag\n    ]\n  end\n\n  def self.valid_options\n    @valid_options ||=\n      public_valid_options +\n        %i[\n          except_topic_ids\n          limit\n          page\n          per_page\n          visible\n          guardian\n          no_definitions\n          destination_category_id\n          include_all_pms\n          include_pms\n        ]\n  end\n\n  # Maps `order` to a columns in `topics`\n  SORTABLE_MAPPING = {\n    \"likes\" => \"like_count\",\n    \"op_likes\" => \"op_likes\",\n    \"views\" => \"views\",\n    \"posts\" => \"posts_count\",\n    \"activity\" => \"bumped_at\",\n    \"posters\" => \"participant_count\",\n    \"category\" => \"category_id\",\n    \"created\" => \"created_at\",\n  }\n\n  cattr_accessor :results_filter_callbacks\n  self.results_filter_callbacks = []\n\n  attr_accessor :options, :user, :guardian\n\n  def self.add_custom_filter(key, &blk)\n    @custom_filters ||= {}\n    valid_options << key\n    public_valid_options << key\n    @custom_filters[key] = blk\n  end\n\n  def self.remove_custom_filter(key)\n    @custom_filters.delete(key)\n    public_valid_options.delete(key)\n    valid_options.delete(key)\n    @custom_filters = nil if @custom_filters.length == 0\n  end\n\n  def self.apply_custom_filters(results, topic_query)\n    if @custom_filters\n      @custom_filters.each { |key, filter| results = filter.call(results, topic_query) }\n    end\n    results\n  end\n\n  def initialize(user = nil, options = {})\n    options.assert_valid_keys(TopicQuery.valid_options)\n    @options = options.dup\n    @user = user\n    @guardian = options[:guardian] || Guardian.new(@user)\n  end\n\n  def joined_topic_user(list = nil)\n    (list || Topic).joins(\n      \"LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i})\",\n    )\n  end\n\n  def get_pm_params(topic)\n    if topic.private_message?\n      my_group_ids =\n        topic\n          .topic_allowed_groups\n          .joins(\n            \"\n          LEFT JOIN group_users gu\n          ON topic_allowed_groups.group_id = gu.group_id\n          AND gu.user_id = #{@user.id.to_i}\n        \",\n          )\n          .where(\"gu.group_id IS NOT NULL\")\n          .pluck(:group_id)\n\n      target_group_ids = topic.topic_allowed_groups.pluck(:group_id)\n\n      target_users = topic.topic_allowed_users\n\n      if my_group_ids.present?\n        # strip out users in groups you already belong to\n        target_users =\n          target_users.joins(\n            \"LEFT JOIN group_users gu ON gu.user_id = topic_allowed_users.user_id AND #{DB.sql_fragment(\"gu.group_id IN (?)\", my_group_ids)}\",\n          ).where(\"gu.group_id IS NULL\")\n      end\n\n      target_user_ids =\n        target_users.where(\"NOT topic_allowed_users.user_id = ?\", @user.id).pluck(:user_id)\n\n      {\n        topic: topic,\n        my_group_ids: my_group_ids,\n        target_group_ids: target_group_ids,\n        target_user_ids: target_user_ids,\n      }\n    end\n  end\n\n  def list_related_for(topic, pm_params: nil)\n    return if !topic.private_message?\n    return if @user.blank?\n\n    return if !@user.in_any_groups?(SiteSetting.personal_message_enabled_groups_map)\n\n    builder = SuggestedTopicsBuilder.new(topic)\n    pm_params = pm_params || get_pm_params(topic)\n\n    if pm_params[:my_group_ids].present?\n      builder.add_results(\n        related_messages_group(\n          pm_params.merge(\n            count: [6, builder.results_left].max,\n            exclude: builder.excluded_topic_ids,\n          ),\n        ),\n      )\n    else\n      builder.add_results(\n        related_messages_user(\n          pm_params.merge(\n            count: [6, builder.results_left].max,\n            exclude: builder.excluded_topic_ids,\n          ),\n        ),\n      )\n    end\n\n    params = { unordered: true }\n    params[:preload_posters] = true\n    create_list(:suggested, params, builder.results)\n  end\n\n  # Return a list of suggested topics for a topic\n  def list_suggested_for(topic, pm_params: nil)\n    # Don't suggest messages unless we have a user, and private messages are\n    # enabled.\n    if topic.private_message? &&\n         (@user.blank? || !@user.in_any_groups?(SiteSetting.personal_message_enabled_groups_map))\n      return\n    end\n\n    builder = SuggestedTopicsBuilder.new(topic)\n\n    pm_params = pm_params || get_pm_params(topic)\n\n    # When logged in we start with different results\n    if @user\n      if topic.private_message?\n        unless builder.full?\n          builder.add_results(new_messages(pm_params.merge(count: builder.results_left)))\n        end\n\n        unless builder.full?\n          builder.add_results(unread_messages(pm_params.merge(count: builder.results_left)))\n        end\n      else\n        builder.add_results(\n          unread_results(\n            topic: topic,\n            per_page: builder.results_left,\n            max_age: SiteSetting.suggested_topics_unread_max_days_old,\n          ),\n          :high,\n        )\n\n        unless builder.full?\n          builder.add_results(new_results(topic: topic, per_page: builder.category_results_left))\n        end\n      end\n    end\n\n    if !topic.private_message?\n      unless builder.full?\n        builder.add_results(\n          random_suggested(topic, builder.results_left, builder.excluded_topic_ids),\n        )\n      end\n    end\n\n    params = { unordered: true }\n    params[:preload_posters] = true if topic.private_message?\n    create_list(:suggested, params, builder.results)\n  end\n\n  # The latest view of topics\n  def list_latest\n    create_list(:latest, {}, latest_results)\n  end\n\n  def list_read\n    create_list(:read, unordered: true) do |topics|\n      topics.where(\"tu.last_visited_at IS NOT NULL\").order(\"tu.last_visited_at DESC\")\n    end\n  end\n\n  def list_new\n    create_list(:new, { unordered: true }, new_results)\n  end\n\n  def list_unread\n    create_list(:unread, { unordered: true }, unread_results)\n  end\n\n  def list_unseen\n    create_list(:unseen, { unordered: true }, unseen_results)\n  end\n\n  def list_posted\n    create_list(:posted) { |l| l.where(\"tu.posted\") }\n  end\n\n  def list_bookmarks\n    create_list(:bookmarks) { |l| l.where(\"tu.bookmarked\") }\n  end\n\n  def list_top_for(period)\n    score_column = TopTopic.score_column_for_period(period)\n    create_list(:top, unordered: true) do |topics|\n      topics = remove_muted_categories(topics, @user)\n      topics = topics.joins(:top_topic).where(\"top_topics.#{score_column} > 0\")\n      if period == :yearly && @user.try(:trust_level) == TrustLevel[0]\n        topics.order(<<~SQL)\n          CASE WHEN (\n             COALESCE(topics.pinned_at, '1900-01-01') > COALESCE(tu.cleared_pinned_at, '1900-01-01')\n          ) THEN 0 ELSE 1 END,\n          top_topics.#{score_column} DESC,\n          topics.bumped_at DESC\n        SQL\n      else\n        topics.order(<<~SQL)\n          COALESCE(top_topics.#{score_column}, 0) DESC, topics.bumped_at DESC\n        SQL\n      end\n    end\n  end\n\n  def list_topics_by(user)\n    @options[:filtered_to_user] = user.id\n    create_list(:user_topics) { |topics| topics.where(user_id: user.id) }\n  end\n\n  def list_group_topics(group)\n    list =\n      default_results.where(\n        \"\n      topics.user_id IN (\n        SELECT user_id FROM group_users gu WHERE gu.group_id = ?\n      )\n    \",\n        group.id.to_i,\n      )\n\n    create_list(:group_topics, {}, list)\n  end\n\n  def list_category_topic_ids(category)\n    query = default_results(category: category.id)\n    pinned_ids =\n      query\n        .where(\"topics.pinned_at IS NOT NULL AND topics.category_id = ?\", category.id)\n        .limit(nil)\n        .order(\"pinned_at DESC\")\n        .pluck(:id)\n    non_pinned_ids =\n      query.where(\"topics.pinned_at IS NULL OR topics.category_id <> ?\", category.id).pluck(:id)\n    (pinned_ids + non_pinned_ids)\n  end\n\n  def list_new_in_category(category)\n    create_list(:new_in_category, unordered: true, category: category.id) do |list|\n      list.by_newest.first(25)\n    end\n  end\n\n  def self.new_filter(list, treat_as_new_topic_start_date: nil, treat_as_new_topic_clause_sql: nil)\n    if treat_as_new_topic_start_date\n      list =\n        list.where(\"topics.created_at >= :created_at\", created_at: treat_as_new_topic_start_date)\n    else\n      list = list.where(\"topics.created_at >= #{treat_as_new_topic_clause_sql}\")\n    end\n\n    list.where(\"tu.last_read_post_number IS NULL\").where(\n      \"COALESCE(tu.notification_level, :tracking) >= :tracking\",\n      tracking: TopicUser.notification_levels[:tracking],\n    )\n  end\n\n  def self.unread_filter(list, whisperer: false)\n    col_name = whisperer ? \"highest_staff_post_number\" : \"highest_post_number\"\n\n    list.where(\"tu.last_read_post_number < topics.#{col_name}\").where(\n      \"COALESCE(tu.notification_level, :regular) >= :tracking\",\n      regular: TopicUser.notification_levels[:regular],\n      tracking: TopicUser.notification_levels[:tracking],\n    )\n  end\n\n  # Any changes here will need to be reflected in `lib/topic-list-tracked-filter.js` for the `isTrackedTopic` function on\n  # the client side. The `f=tracked` query param is not heavily used so we do not want to be querying for a topic's\n  # tracked status by default. Instead, the client will handle the filtering when the `f=tracked` query params is present.\n  def self.tracked_filter(list, user_id)\n    tracked_category_ids_sql = <<~SQL\n    SELECT cd.category_id FROM category_users cd\n    WHERE cd.user_id = :user_id AND cd.notification_level >= :tracking\n    SQL\n\n    has_sub_sub_categories = SiteSetting.max_category_nesting == 3\n\n    sql = +<<~SQL\n      topics.category_id IN (\n        SELECT\n          c.id\n        FROM categories c\n        #{has_sub_sub_categories ? \"LEFT JOIN categories parent_categories ON parent_categories.id = c.parent_category_id\" : \"\"}\n        WHERE (c.id IN (#{tracked_category_ids_sql}))\n        OR c.parent_category_id IN (#{tracked_category_ids_sql})\n        #{has_sub_sub_categories ? \"OR (parent_categories.id IS NOT NULL AND parent_categories.parent_category_id IN (#{tracked_category_ids_sql}))\" : \"\"}\n      )\n    SQL\n\n    sql << <<~SQL if SiteSetting.tagging_enabled\n        OR topics.id IN (\n          SELECT tt.topic_id FROM topic_tags tt WHERE tt.tag_id IN (\n            SELECT tu.tag_id\n            FROM tag_users tu\n            WHERE tu.user_id = :user_id AND tu.notification_level >= :tracking\n          )\n        )\n      SQL\n\n    list.where(sql, user_id: user_id, tracking: NotificationLevels.all[:tracking])\n  end\n\n  def prioritize_pinned_topics(topics, options)\n    pinned_clause =\n      if options[:category_id]\n        +\"topics.category_id = #{options[:category_id].to_i} AND\"\n      else\n        +\"pinned_globally AND \"\n      end\n\n    pinned_clause << \" pinned_at IS NOT NULL \"\n\n    if @user\n      pinned_clause << \" AND (topics.pinned_at > tu.cleared_pinned_at OR tu.cleared_pinned_at IS NULL)\"\n    end\n\n    unpinned_topics = topics.where(\"NOT ( #{pinned_clause} )\")\n    pinned_topics = topics.dup.offset(nil).where(pinned_clause).reorder(pinned_at: :desc)\n\n    per_page = options[:per_page] || per_page_setting\n    limit = per_page unless options[:limit] == false\n    page = options[:page].to_i\n\n    if page == 0\n      (pinned_topics + unpinned_topics)[0...limit] if limit\n    else\n      offset = (page * per_page) - pinned_topics.length\n      offset = 0 unless offset > 0\n      unpinned_topics.offset(offset).to_a\n    end\n  end\n\n  def create_list(filter, options = {}, topics = nil)\n    options[:filter] ||= filter\n    topics ||= default_results(options)\n    topics = yield(topics) if block_given?\n\n    options = options.merge(@options)\n    if %w[activity default].include?(options[:order] || \"activity\") && !options[:unordered] &&\n         filter != :private_messages\n      topics = prioritize_pinned_topics(topics, options)\n    end\n\n    topics = topics.to_a\n\n    if options[:preload_posters]\n      user_ids = []\n      topics.each do |ft|\n        user_ids << ft.user_id << ft.last_post_user_id << ft.featured_user_ids << ft.allowed_user_ids\n      end\n\n      user_lookup = UserLookup.new(user_ids)\n\n      # memoize for loop so we don't keep looking these up\n      translations = TopicPostersSummary.translations\n\n      topics.each do |t|\n        t.posters = t.posters_summary(user_lookup: user_lookup, translations: translations)\n      end\n    end\n\n    topics.each do |t|\n      t.allowed_user_ids = filter == :private_messages ? t.allowed_users.map { |u| u.id } : []\n    end\n\n    list = TopicList.new(filter, @user, topics, options.merge(@options))\n    list.per_page = options[:per_page] || per_page_setting\n    list\n  end\n\n  def latest_results(options = {})\n    result = default_results(options)\n    result = remove_muted(result, @user, options)\n    result = apply_shared_drafts(result, get_category_id(options[:category]), options)\n\n    # plugins can remove topics here:\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:latest, result, @user, options)\n    end\n\n    result\n  end\n\n  def unseen_results(options = {})\n    result = default_results(options)\n    result = unseen_filter(result, @user.first_seen_at, @user.whisperer?) if @user\n    result = remove_muted(result, @user, options)\n    result = apply_shared_drafts(result, get_category_id(options[:category]), options)\n\n    # plugins can remove topics here:\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:latest, result, @user, options)\n    end\n\n    result\n  end\n\n  def unread_results(options = {})\n    result =\n      TopicQuery.unread_filter(\n        default_results(options.reverse_merge(unordered: true)),\n        whisperer: @user&.whisperer?,\n      ).order(\"CASE WHEN topics.user_id = tu.user_id THEN 1 ELSE 2 END\")\n\n    if @user\n      # micro optimisation so we don't load up all of user stats which we do not need\n      unread_at =\n        DB.query_single(\"select first_unread_at from user_stats where user_id = ?\", @user.id).first\n\n      if max_age = options[:max_age]\n        max_age_date = max_age.days.ago\n        unread_at ||= max_age_date\n        unread_at = unread_at > max_age_date ? unread_at : max_age_date\n      end\n\n      # perf note, in the past we tried doing this in a subquery but performance was\n      # terrible, also tried with a join and it was bad\n      result = result.where(\"topics.updated_at >= ?\", unread_at)\n    end\n\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:unread, result, @user, options)\n    end\n\n    suggested_ordering(result, options)\n  end\n\n  def new_results(options = {})\n    # TODO does this make sense or should it be ordered on created_at\n    #  it is ordering on bumped_at now\n    result =\n      TopicQuery.new_filter(\n        default_results(options.reverse_merge(unordered: true)),\n        treat_as_new_topic_start_date: @user.user_option.treat_as_new_topic_start_date,\n      )\n    result = remove_muted(result, @user, options)\n    result = remove_dismissed(result, @user)\n\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:new, result, @user, options)\n    end\n\n    suggested_ordering(result, options)\n  end\n\n  protected\n\n  def per_page_setting\n    DEFAULT_PER_PAGE_COUNT\n  end\n\n  def apply_shared_drafts(result, category_id, options)\n    # PERF: avoid any penalty if there are no shared drafts enabled\n    # on some sites the cost can be high eg: gearbox\n    return result if SiteSetting.shared_drafts_category == \"\"\n\n    drafts_category_id = SiteSetting.shared_drafts_category.to_i\n    viewing_shared = category_id && category_id == drafts_category_id\n\n    if guardian.can_see_shared_draft?\n      if options[:destination_category_id]\n        destination_category_id = get_category_id(options[:destination_category_id])\n        topic_ids = SharedDraft.where(category_id: destination_category_id).pluck(:topic_id)\n\n        return result.where(id: topic_ids)\n      end\n\n      return result.includes(:shared_draft).references(:shared_draft) if viewing_shared\n    elsif viewing_shared\n      return(\n        result.joins(\"LEFT OUTER JOIN shared_drafts sd ON sd.topic_id = topics.id\").where(\n          \"sd.id IS NULL\",\n        )\n      )\n    end\n\n    result.where(\"topics.category_id != ?\", drafts_category_id)\n  end\n\n  def apply_ordering(result, options)\n    sort_column = SORTABLE_MAPPING[options[:order]] || \"default\"\n    sort_dir = (options[:ascending] == \"true\") ? \"ASC\" : \"DESC\"\n\n    # If we are sorting in the default order desc, we should consider including pinned\n    # topics. Otherwise, just use bumped_at.\n    if sort_column == \"default\"\n      if sort_dir == \"DESC\"\n        # If something requires a custom order, for example \"unread\" which sorts the least read\n        # to the top, do nothing\n        return result if options[:unordered]\n      end\n      sort_column = \"bumped_at\"\n    end\n\n    # If we are sorting by category, actually use the name\n    if sort_column == \"category_id\"\n      # TODO forces a table scan, slow\n      return result.references(:categories).order(<<~SQL)\n        CASE WHEN categories.id = #{SiteSetting.uncategorized_category_id.to_i} THEN '' ELSE categories.name END #{sort_dir}\n      SQL\n    end\n\n    if sort_column == \"op_likes\"\n      return(\n        result.includes(:first_post).order(\n          \"(SELECT like_count FROM posts p3 WHERE p3.topic_id = topics.id AND p3.post_number = 1) #{sort_dir}\",\n        )\n      )\n    end\n\n    if sort_column.start_with?(\"custom_fields\")\n      field = sort_column.split(\".\")[1]\n      return(\n        result.order(\n          \"(SELECT CASE WHEN EXISTS (SELECT true FROM topic_custom_fields tcf WHERE tcf.topic_id::integer = topics.id::integer AND tcf.name = '#{field}') THEN (SELECT value::integer FROM topic_custom_fields tcf WHERE tcf.topic_id::integer = topics.id::integer AND tcf.name = '#{field}') ELSE 0 END) #{sort_dir}\",\n        )\n      )\n    end\n\n    result.order(\"topics.#{sort_column} #{sort_dir}\")\n  end\n\n  def get_category_id(category_id_or_slug)\n    return nil unless category_id_or_slug.present?\n    category_id = category_id_or_slug.to_i\n\n    if category_id == 0\n      category_id =\n        Category.where(slug: category_id_or_slug, parent_category_id: nil).pluck_first(:id)\n    end\n\n    category_id\n  end\n\n  # Create results based on a bunch of default options\n  def default_results(options = {})\n    options.reverse_merge!(@options)\n    options.reverse_merge!(per_page: per_page_setting) unless options[:limit] == false\n\n    # Whether to include unlisted (visible = false) topics\n    viewing_own_topics = @user && @user.id == options[:filtered_to_user]\n\n    if options[:visible].nil?\n      options[:visible] = true if @user.nil? || @user.regular?\n      options[:visible] = false if @guardian.can_see_unlisted_topics? || viewing_own_topics\n    end\n\n    # Start with a list of all topics\n    result = Topic.unscoped.includes(:category)\n\n    if @user\n      result =\n        result.joins(\n          \"LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i})\",\n        ).references(\"tu\")\n    end\n\n    category_id = get_category_id(options[:category])\n    @options[:category_id] = category_id\n    if category_id\n      if options[:no_subcategories]\n        result = result.where(\"topics.category_id = ?\", category_id)\n      else\n        result = result.where(\"topics.category_id IN (?)\", Category.subcategory_ids(category_id))\n        if !SiteSetting.show_category_definitions_in_topic_lists\n          result =\n            result.where(\"categories.topic_id <> topics.id OR topics.category_id = ?\", category_id)\n        end\n      end\n      result = result.references(:categories)\n\n      if !@options[:order]\n        filter = (options[:filter] || options[:f])\n        # category default sort order\n        sort_order, sort_ascending =\n          Category.where(id: category_id).pluck_first(:sort_order, :sort_ascending)\n        if sort_order && (filter.blank? || %i[latest unseen].include?(filter))\n          options[:order] = sort_order\n          options[:ascending] = !!sort_ascending ? \"true\" : \"false\"\n        else\n          options[:order] = \"default\"\n          options[:ascending] = \"false\"\n        end\n      end\n    end\n\n    if SiteSetting.tagging_enabled\n      result = result.preload(:tags)\n\n      tags_arg = @options[:tags]\n\n      if tags_arg && tags_arg.size > 0\n        tags_arg = tags_arg.split if String === tags_arg\n\n        tags_arg =\n          tags_arg.map do |t|\n            if String === t\n              t.downcase\n            else\n              t\n            end\n          end\n\n        tags_query = tags_arg[0].is_a?(String) ? Tag.where_name(tags_arg) : Tag.where(id: tags_arg)\n        tags = tags_query.select(:id, :target_tag_id).map { |t| t.target_tag_id || t.id }.uniq\n\n        if ActiveModel::Type::Boolean.new.cast(@options[:match_all_tags])\n          # ALL of the given tags:\n          if tags_arg.length == tags.length\n            tags.each_with_index do |tag, index|\n              sql_alias = [\"t\", index].join\n              result =\n                result.joins(\n                  \"INNER JOIN topic_tags #{sql_alias} ON #{sql_alias}.topic_id = topics.id AND #{sql_alias}.tag_id = #{tag}\",\n                )\n            end\n          else\n            result = result.none # don't return any results unless all tags exist in the database\n          end\n        else\n          # ANY of the given tags:\n          result = result.joins(:tags).where(\"tags.id in (?)\", tags)\n        end\n\n        # TODO: this is very side-effecty and should be changed\n        # It is done cause further up we expect normalized tags\n        @options[:tags] = tags\n      elsif @options[:no_tags]\n        # the following will do: (\"topics\".\"id\" NOT IN (SELECT DISTINCT \"topic_tags\".\"topic_id\" FROM \"topic_tags\"))\n        result = result.where.not(id: TopicTag.distinct.pluck(:topic_id))\n      end\n\n      result = result.where(<<~SQL, name: @options[:exclude_tag]) if @options[:exclude_tag].present?\n        topics.id NOT IN (\n          SELECT topic_tags.topic_id\n          FROM topic_tags\n          INNER JOIN tags ON tags.id = topic_tags.tag_id\n          WHERE tags.name = :name\n        )\n        SQL\n    end\n\n    result = apply_ordering(result, options)\n\n    all_listable_topics = @guardian.filter_allowed_categories(Topic.unscoped.listable_topics)\n\n    if options[:include_pms] || options[:include_all_pms]\n      all_pm_topics =\n        if options[:include_all_pms] && @guardian.is_admin?\n          Topic.unscoped.private_messages\n        else\n          Topic.unscoped.private_messages_for_user(@user)\n        end\n      result = result.merge(all_listable_topics.or(all_pm_topics))\n    else\n      result = result.merge(all_listable_topics)\n    end\n\n    # Don't include the category topics if excluded\n    if options[:no_definitions]\n      result = result.where(\"COALESCE(categories.topic_id, 0) <> topics.id\")\n    end\n\n    result = result.limit(options[:per_page]) unless options[:limit] == false\n    result = result.visible if options[:visible]\n    result =\n      result.where.not(topics: { id: options[:except_topic_ids] }).references(:topics) if options[\n      :except_topic_ids\n    ]\n\n    if options[:page]\n      offset = options[:page].to_i * options[:per_page]\n      result = result.offset(offset) if offset > 0\n    end\n\n    if options[:topic_ids]\n      result = result.where(\"topics.id in (?)\", options[:topic_ids]).references(:topics)\n    end\n\n    if search = options[:search].presence\n      result =\n        result.where(\n          \"topics.id in (select pp.topic_id from post_search_data pd join posts pp on pp.id = pd.post_id where pd.search_data @@ #{Search.ts_query(term: search.to_s)})\",\n        )\n    end\n\n    # NOTE protect against SYM attack can be removed with Ruby 2.2\n    #\n    state = options[:state]\n    if @user && state && TopicUser.notification_levels.keys.map(&:to_s).include?(state)\n      level = TopicUser.notification_levels[state.to_sym]\n      result =\n        result.where(\n          \"topics.id IN (\n                                SELECT topic_id\n                                FROM topic_users\n                                WHERE user_id = ? AND\n                                      notification_level = ?)\",\n          @user.id,\n          level,\n        )\n    end\n\n    require_deleted_clause = true\n\n    if before = options[:before]\n      if (before = before.to_i) > 0\n        result = result.where(\"topics.created_at < ?\", before.to_i.days.ago)\n      end\n    end\n\n    if bumped_before = options[:bumped_before]\n      if (bumped_before = bumped_before.to_i) > 0\n        result = result.where(\"topics.bumped_at < ?\", bumped_before.to_i.days.ago)\n      end\n    end\n\n    if status = options[:status]\n      case status\n      when \"open\"\n        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n      when \"closed\"\n        result = result.where(\"topics.closed\")\n      when \"archived\"\n        result = result.where(\"topics.archived\")\n      when \"listed\"\n        result = result.where(\"topics.visible\")\n      when \"unlisted\"\n        result = result.where(\"NOT topics.visible\")\n      when \"deleted\"\n        category = Category.find_by(id: options[:category])\n        if @guardian.can_see_deleted_topics?(category)\n          result = result.where(\"topics.deleted_at IS NOT NULL\")\n          require_deleted_clause = false\n        end\n      end\n    end\n\n    if (filter = (options[:filter] || options[:f])) && @user\n      action = (PostActionType.types[:like] if filter == \"liked\")\n      if action\n        result =\n          result.where(\n            \"topics.id IN (SELECT pp.topic_id\n                              FROM post_actions pa\n                              JOIN posts pp ON pp.id = pa.post_id\n                              WHERE pa.user_id = :user_id AND\n                                    pa.post_action_type_id = :action AND\n                                    pa.deleted_at IS NULL\n                           )\",\n            user_id: @user.id,\n            action: action,\n          )\n      end\n\n      result = TopicQuery.tracked_filter(result, @user.id) if filter == \"tracked\"\n    end\n\n    result = result.where(\"topics.deleted_at IS NULL\") if require_deleted_clause\n    result = result.where(\"topics.posts_count <= ?\", options[:max_posts]) if options[\n      :max_posts\n    ].present?\n    result = result.where(\"topics.posts_count >= ?\", options[:min_posts]) if options[\n      :min_posts\n    ].present?\n\n    result = TopicQuery.apply_custom_filters(result, self)\n\n    result\n  end\n\n  def remove_muted(list, user, options)\n    list = remove_muted_topics(list, user) unless options && options[:state] == \"muted\"\n    list = remove_muted_categories(list, user, exclude: options[:category])\n    TopicQuery.remove_muted_tags(list, user, options)\n  end\n\n  def remove_muted_topics(list, user)\n    if user\n      list =\n        list.where(\n          \"COALESCE(tu.notification_level,1) > :muted\",\n          muted: TopicUser.notification_levels[:muted],\n        )\n    end\n\n    list\n  end\n\n  def remove_muted_categories(list, user, opts = nil)\n    category_id = get_category_id(opts[:exclude]) if opts\n\n    if user\n      list =\n        list\n          .references(\"cu\")\n          .joins(\n            \"LEFT JOIN category_users ON category_users.category_id = topics.category_id AND category_users.user_id = #{user.id}\",\n          )\n          .where(\n            \"topics.category_id = :category_id\n                OR\n                (COALESCE(category_users.notification_level, :default) <> :muted AND (topics.category_id IS NULL OR topics.category_id NOT IN(:indirectly_muted_category_ids)))\n                OR tu.notification_level > :regular\",\n            category_id: category_id || -1,\n            default: CategoryUser.default_notification_level,\n            indirectly_muted_category_ids:\n              CategoryUser.indirectly_muted_category_ids(user).presence || [-1],\n            muted: CategoryUser.notification_levels[:muted],\n            regular: TopicUser.notification_levels[:regular],\n          )\n    elsif SiteSetting.mute_all_categories_by_default\n      category_ids = [\n        SiteSetting.default_categories_watching.split(\"|\"),\n        SiteSetting.default_categories_tracking.split(\"|\"),\n        SiteSetting.default_categories_watching_first_post.split(\"|\"),\n        SiteSetting.default_categories_normal.split(\"|\"),\n      ].flatten.map(&:to_i)\n      category_ids << category_id if category_id.present? && category_ids.exclude?(category_id)\n\n      list = list.where(\"topics.category_id IN (?)\", category_ids) if category_ids.present?\n    else\n      category_ids = SiteSetting.default_categories_muted.split(\"|\").map(&:to_i)\n      category_ids -= [category_id] if category_id.present? && category_ids.include?(category_id)\n\n      list = list.where(\"topics.category_id NOT IN (?)\", category_ids) if category_ids.present?\n    end\n\n    list\n  end\n\n  def self.remove_muted_tags(list, user, opts = {})\n    if !SiteSetting.tagging_enabled || SiteSetting.remove_muted_tags_from_latest == \"never\"\n      return list\n    end\n\n    muted_tag_ids = []\n\n    if user.present?\n      muted_tag_ids = TagUser.lookup(user, :muted).pluck(:tag_id)\n    else\n      muted_tag_names = SiteSetting.default_tags_muted.split(\"|\")\n\n      muted_tag_ids = Tag.where(name: muted_tag_names).pluck(:id) if muted_tag_names.present?\n    end\n\n    return list if muted_tag_ids.blank?\n\n    # if viewing the topic list for a muted tag, show all the topics\n    if !opts[:no_tags] && opts[:tags].present?\n      if TagUser\n           .lookup(user, :muted)\n           .joins(:tag)\n           .where(\"lower(tags.name) = ?\", opts[:tags].first.downcase)\n           .exists?\n        return list\n      end\n    end\n\n    if SiteSetting.remove_muted_tags_from_latest == \"always\"\n      list =\n        list.where(\n          \"\n        NOT EXISTS(\n          SELECT 1\n            FROM topic_tags tt\n           WHERE tt.tag_id IN (:tag_ids)\n             AND tt.topic_id = topics.id)\",\n          tag_ids: muted_tag_ids,\n        )\n    else\n      list =\n        list.where(\n          \"\n        EXISTS (\n          SELECT 1\n            FROM topic_tags tt\n           WHERE tt.tag_id NOT IN (:tag_ids)\n             AND tt.topic_id = topics.id\n        ) OR NOT EXISTS (SELECT 1 FROM topic_tags tt WHERE tt.topic_id = topics.id)\",\n          tag_ids: muted_tag_ids,\n        )\n    end\n  end\n\n  def remove_dismissed(list, user)\n    if user\n      list.joins(<<~SQL).where(\"dismissed_topic_users.id IS NULL\")\n        LEFT JOIN dismissed_topic_users\n        ON dismissed_topic_users.topic_id = topics.id\n        AND dismissed_topic_users.user_id = #{user.id.to_i}\n        SQL\n    else\n      list\n    end\n  end\n\n  def new_messages(params)\n    TopicQuery.new_filter(\n      messages_for_groups_or_user(params[:my_group_ids]),\n      treat_as_new_topic_start_date: Time.at(SiteSetting.min_new_topics_time).to_datetime,\n    ).limit(params[:count])\n  end\n\n  def unread_messages(params)\n    query =\n      TopicQuery.unread_filter(\n        messages_for_groups_or_user(params[:my_group_ids]),\n        whisperer: @user.whisperer?,\n      )\n\n    first_unread_pm_at =\n      if params[:my_group_ids].present?\n        GroupUser.where(user_id: @user.id, group_id: params[:my_group_ids]).minimum(\n          :first_unread_pm_at,\n        )\n      else\n        UserStat.where(user_id: @user.id).pluck_first(:first_unread_pm_at)\n      end\n\n    query = query.where(\"topics.updated_at >= ?\", first_unread_pm_at) if first_unread_pm_at\n    query = query.limit(params[:count]) if params[:count]\n    query\n  end\n\n  def related_messages_user(params)\n    messages = messages_for_user.limit(params[:count])\n    messages = allowed_messages(messages, params)\n  end\n\n  def related_messages_group(params)\n    messages = messages_for_groups_or_user(params[:my_group_ids]).limit(params[:count])\n    messages = allowed_messages(messages, params)\n  end\n\n  def allowed_messages(messages, params)\n    user_ids = (params[:target_user_ids] || [])\n    group_ids = ((params[:target_group_ids] - params[:my_group_ids]) || [])\n\n    if user_ids.present?\n      messages =\n        messages.joins(\n          \"\n          LEFT JOIN topic_allowed_users ta2\n          ON topics.id = ta2.topic_id\n          AND #{DB.sql_fragment(\"ta2.user_id IN (?)\", user_ids)}\n        \",\n        )\n    end\n\n    if group_ids.present?\n      messages =\n        messages.joins(\n          \"\n          LEFT JOIN topic_allowed_groups tg2\n          ON topics.id = tg2.topic_id\n          AND #{DB.sql_fragment(\"tg2.group_id IN (?)\", group_ids)}\n        \",\n        )\n    end\n\n    messages =\n      if user_ids.present? && group_ids.present?\n        messages.where(\"ta2.topic_id IS NOT NULL OR tg2.topic_id IS NOT NULL\")\n      elsif user_ids.present?\n        messages.where(\"ta2.topic_id IS NOT NULL\")\n      elsif group_ids.present?\n        messages.where(\"tg2.topic_id IS NOT NULL\")\n      end\n  end\n\n  def messages_for_groups_or_user(group_ids)\n    if group_ids.present?\n      base_messages.joins(\n        \"\n          LEFT JOIN (\n            SELECT * FROM topic_allowed_groups _tg\n            LEFT JOIN group_users gu\n            ON gu.user_id = #{@user.id.to_i}\n            AND gu.group_id = _tg.group_id\n            WHERE #{DB.sql_fragment(\"gu.group_id IN (?)\", group_ids)}\n          ) tg ON topics.id = tg.topic_id\n        \",\n      ).where(\"tg.topic_id IS NOT NULL\")\n    else\n      messages_for_user\n    end\n  end\n\n  def messages_for_user\n    base_messages.joins(\n      \"\n        LEFT JOIN topic_allowed_users ta\n        ON topics.id = ta.topic_id\n        AND ta.user_id = #{@user.id.to_i}\n      \",\n    ).where(\"ta.topic_id IS NOT NULL\")\n  end\n\n  def base_messages\n    query =\n      Topic.where(\"topics.archetype = ?\", Archetype.private_message).joins(\n        \"LEFT JOIN topic_users tu ON topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i}\",\n      )\n\n    query = query.includes(:tags) if SiteSetting.tagging_enabled\n    query.order(\"topics.bumped_at DESC\")\n  end\n\n  def random_suggested(topic, count, excluded_topic_ids = [])\n    result = default_results(unordered: true, per_page: count).where(closed: false, archived: false)\n\n    if SiteSetting.limit_suggested_to_category\n      excluded_topic_ids += Category.where(id: topic.category_id).pluck(:id)\n    else\n      excluded_topic_ids += Category.topic_ids.to_a\n    end\n    result =\n      result.where(\"topics.id NOT IN (?)\", excluded_topic_ids) unless excluded_topic_ids.empty?\n\n    result = remove_muted_categories(result, @user)\n    result = remove_muted_topics(result, @user)\n\n    # If we are in a category, prefer it for the random results\n    if topic.category_id\n      result =\n        result.order(\"CASE WHEN topics.category_id = #{topic.category_id.to_i} THEN 0 ELSE 1 END\")\n    end\n\n    # Best effort, it over selects, however if you have a high number\n    # of muted categories there is tiny chance we will not select enough\n    # in particular this can happen if current category is empty and tons\n    # of muted, big edge case\n    #\n    # we over select in case cache is stale\n    max = (count * 1.3).to_i\n    ids = SiteSetting.limit_suggested_to_category ? [] : RandomTopicSelector.next(max)\n    ids.concat(RandomTopicSelector.next(max, topic.category))\n\n    result.where(id: ids.uniq)\n  end\n\n  def suggested_ordering(result, options)\n    # Prefer unread in the same category\n    if options[:topic] && options[:topic].category_id\n      result =\n        result.order(\n          \"CASE WHEN topics.category_id = #{options[:topic].category_id.to_i} THEN 0 ELSE 1 END\",\n        )\n    end\n\n    result.order(\"topics.bumped_at DESC\")\n  end\n\n  private\n\n  def unseen_filter(list, user_first_seen_at, whisperer)\n    list = list.where(\"topics.bumped_at >= ?\", user_first_seen_at)\n\n    col_name = whisperer ? \"highest_staff_post_number\" : \"highest_post_number\"\n    list.where(\"tu.last_read_post_number IS NULL OR tu.last_read_post_number < topics.#{col_name}\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"topic_view\"\n\nRSpec.describe TopicQuery do\n  # TODO:\n  #   This fab! here has impact on all tests.\n  #\n  #   It happens first, but is not obvious later in the tests that we depend on\n  #   the user being created so early otherwise finding new topics does not\n  #   work.\n  #\n  #   We should use be more explicit in communicating how the clock moves\n  fab!(:user) { Fabricate(:user) }\n\n  fab!(:creator) { Fabricate(:user) }\n  let(:topic_query) { TopicQuery.new(user) }\n\n  fab!(:tl4_user) { Fabricate(:trust_level_4) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:admin) { Fabricate(:admin) }\n\n  describe \"secure category\" do\n    it \"filters categories out correctly\" do\n      category = Fabricate(:category_with_definition)\n      group = Fabricate(:group)\n      category.set_permissions(group => :full)\n      category.save\n\n      Fabricate(:topic, category: category)\n      Fabricate(:topic, visible: false)\n\n      expect(TopicQuery.new(nil).list_latest.topics.count).to eq(0)\n      expect(TopicQuery.new(user).list_latest.topics.count).to eq(0)\n\n      expect(Topic.top_viewed(10).count).to eq(0)\n      expect(Topic.recent(10).count).to eq(0)\n\n      # mods can see hidden topics\n      expect(TopicQuery.new(moderator).list_latest.topics.count).to eq(1)\n      # admins can see all the topics\n      expect(TopicQuery.new(admin).list_latest.topics.count).to eq(3)\n\n      group.add(user)\n      group.save\n\n      expect(TopicQuery.new(user).list_latest.topics.count).to eq(2)\n    end\n  end\n\n  describe \"custom filters\" do\n    it \"allows custom filters to be applied\" do\n      topic1 = Fabricate(:topic)\n      _topic2 = Fabricate(:topic)\n\n      TopicQuery.add_custom_filter(:only_topic_id) do |results, topic_query|\n        results = results.where(\"topics.id = ?\", topic_query.options[:only_topic_id])\n      end\n\n      expect(TopicQuery.new(nil, only_topic_id: topic1.id).list_latest.topics.map(&:id)).to eq(\n        [topic1.id],\n      )\n\n      TopicQuery.remove_custom_filter(:only_topic_id)\n    end\n  end\n\n  describe \"#list_topics_by\" do\n    it \"allows users to view their own invisible topics\" do\n      _topic = Fabricate(:topic, user: user)\n      _invisible_topic = Fabricate(:topic, user: user, visible: false)\n\n      expect(TopicQuery.new(nil).list_topics_by(user).topics.count).to eq(1)\n      expect(TopicQuery.new(user).list_topics_by(user).topics.count).to eq(2)\n    end\n  end\n\n  describe \"#prioritize_pinned_topics\" do\n    it \"does the pagination correctly\" do\n      num_topics = 15\n      per_page = 3\n\n      topics = []\n      (num_topics - 1)\n        .downto(0)\n        .each { |i| topics[i] = freeze_time(i.seconds.ago) { Fabricate(:topic) } }\n\n      topic_query = TopicQuery.new(user)\n      results = topic_query.send(:default_results)\n\n      expect(topic_query.prioritize_pinned_topics(results, per_page: per_page, page: 0)).to eq(\n        topics[0...per_page],\n      )\n\n      expect(topic_query.prioritize_pinned_topics(results, per_page: per_page, page: 1)).to eq(\n        topics[per_page...num_topics],\n      )\n    end\n\n    it \"orders globally pinned topics by pinned_at rather than bumped_at\" do\n      pinned1 =\n        Fabricate(\n          :topic,\n          bumped_at: 3.hour.ago,\n          pinned_at: 1.hours.ago,\n          pinned_until: 10.days.from_now,\n          pinned_globally: true,\n        )\n      pinned2 =\n        Fabricate(\n          :topic,\n          bumped_at: 2.hour.ago,\n          pinned_at: 4.hours.ago,\n          pinned_until: 10.days.from_now,\n          pinned_globally: true,\n        )\n      unpinned1 = Fabricate(:topic, bumped_at: 2.hour.ago)\n      unpinned2 = Fabricate(:topic, bumped_at: 3.hour.ago)\n\n      topic_query = TopicQuery.new(user)\n      results = topic_query.send(:default_results)\n\n      expected_order = [pinned1, pinned2, unpinned1, unpinned2].map(&:id)\n      expect(topic_query.prioritize_pinned_topics(results, per_page: 10, page: 0).pluck(:id)).to eq(\n        expected_order,\n      )\n    end\n\n    it \"orders pinned topics within a category by pinned_at rather than bumped_at\" do\n      cat = Fabricate(:category)\n      pinned1 =\n        Fabricate(\n          :topic,\n          category: cat,\n          bumped_at: 3.hour.ago,\n          pinned_at: 1.hours.ago,\n          pinned_until: 10.days.from_now,\n        )\n      pinned2 =\n        Fabricate(\n          :topic,\n          category: cat,\n          bumped_at: 2.hour.ago,\n          pinned_at: 4.hours.ago,\n          pinned_until: 10.days.from_now,\n        )\n      unpinned1 = Fabricate(:topic, category: cat, bumped_at: 2.hour.ago)\n      unpinned2 = Fabricate(:topic, category: cat, bumped_at: 3.hour.ago)\n\n      topic_query = TopicQuery.new(user)\n      results = topic_query.send(:default_results)\n\n      expected_order = [pinned1, pinned2, unpinned1, unpinned2].map(&:id)\n      expect(\n        topic_query.prioritize_pinned_topics(\n          results,\n          per_page: 10,\n          page: 0,\n          category_id: cat.id,\n        ).pluck(:id),\n      ).to eq(expected_order)\n    end\n  end\n\n  describe \"tracked\" do\n    it \"filters tracked topics correctly\" do\n      SiteSetting.tagging_enabled = true\n\n      tag = Fabricate(:tag)\n      topic = Fabricate(:topic, tags: [tag])\n      topic2 = Fabricate(:topic)\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n      expect(query.topics.length).to eq(0)\n\n      TagUser.create!(\n        tag_id: tag.id,\n        user_id: user.id,\n        notification_level: NotificationLevels.all[:watching],\n      )\n\n      cu =\n        CategoryUser.create!(\n          category_id: topic2.category_id,\n          user_id: user.id,\n          notification_level: NotificationLevels.all[:regular],\n        )\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(topic.id)\n\n      cu.update!(notification_level: NotificationLevels.all[:tracking])\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(topic.id, topic2.id)\n\n      # includes subcategories of tracked categories\n      parent_category = Fabricate(:category)\n      sub_category = Fabricate(:category, parent_category_id: parent_category.id)\n      topic3 = Fabricate(:topic, category_id: sub_category.id)\n\n      parent_category_2 = Fabricate(:category)\n      sub_category_2 = Fabricate(:category, parent_category: parent_category_2)\n      topic4 = Fabricate(:topic, category: sub_category_2)\n\n      CategoryUser.create!(\n        category_id: parent_category.id,\n        user_id: user.id,\n        notification_level: NotificationLevels.all[:tracking],\n      )\n\n      CategoryUser.create!(\n        category_id: sub_category_2.id,\n        user_id: user.id,\n        notification_level: NotificationLevels.all[:tracking],\n      )\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(topic.id, topic2.id, topic3.id, topic4.id)\n\n      # includes sub-subcategories of tracked categories\n      SiteSetting.max_category_nesting = 3\n      sub_sub_category = Fabricate(:category, parent_category_id: sub_category.id)\n      topic5 = Fabricate(:topic, category_id: sub_sub_category.id)\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(\n        topic.id,\n        topic2.id,\n        topic3.id,\n        topic4.id,\n        topic5.id,\n      )\n    end\n  end\n\n  describe \"deleted filter\" do\n    it \"filters deleted topics correctly\" do\n      SiteSetting.enable_category_group_moderation = true\n      group_moderator = Fabricate(:user)\n      group = Fabricate(:group)\n      group.add(group_moderator)\n      category = Fabricate(:category, reviewable_by_group: group)\n      topic = Fabricate(:topic, category: category, deleted_at: 1.year.ago)\n\n      expect(TopicQuery.new(admin, status: \"deleted\").list_latest.topics.size).to eq(1)\n      expect(TopicQuery.new(moderator, status: \"deleted\").list_latest.topics.size).to eq(1)\n      expect(\n        TopicQuery\n          .new(group_moderator, status: \"deleted\", category: category.id)\n          .list_latest\n          .topics\n          .size,\n      ).to eq(1)\n      expect(TopicQuery.new(user, status: \"deleted\").list_latest.topics.size).to eq(0)\n      expect(TopicQuery.new(nil, status: \"deleted\").list_latest.topics.size).to eq(0)\n    end\n  end\n\n  describe \"include_pms option\" do\n    it \"includes users own pms in regular topic lists\" do\n      topic = Fabricate(:topic)\n      own_pm = Fabricate(:private_message_topic, user: user)\n      other_pm = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      expect(TopicQuery.new(user).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(admin).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(user, include_pms: true).list_latest.topics).to contain_exactly(\n        topic,\n        own_pm,\n      )\n    end\n  end\n\n  describe \"include_all_pms option\" do\n    it \"includes all pms in regular topic lists for admins\" do\n      topic = Fabricate(:topic)\n      own_pm = Fabricate(:private_message_topic, user: user)\n      other_pm = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      expect(TopicQuery.new(user).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(admin).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(user, include_all_pms: true).list_latest.topics).to contain_exactly(\n        topic,\n        own_pm,\n      )\n      expect(TopicQuery.new(admin, include_all_pms: true).list_latest.topics).to contain_exactly(\n        topic,\n        own_pm,\n        other_pm,\n      )\n    end\n  end\n\n  describe \"category filter\" do\n    let(:category) { Fabricate(:category_with_definition) }\n    let(:diff_category) { Fabricate(:category_with_definition, name: \"Different Category\") }\n\n    it \"returns topics in the category when we filter to it\" do\n      expect(TopicQuery.new(moderator).list_latest.topics.size).to eq(0)\n\n      # Filter by slug\n      expect(TopicQuery.new(moderator, category: category.slug).list_latest.topics.size).to eq(1)\n      expect(\n        TopicQuery.new(moderator, category: \"#{category.id}-category\").list_latest.topics.size,\n      ).to eq(1)\n\n      list = TopicQuery.new(moderator, category: diff_category.slug).list_latest\n      expect(list.topics.size).to eq(1)\n      expect(list.preload_key).to eq(\"topic_list\")\n\n      # Defaults to no category filter when slug does not exist\n      expect(TopicQuery.new(moderator, category: \"made up slug\").list_latest.topics.size).to eq(2)\n    end\n\n    context \"with subcategories\" do\n      let!(:subcategory) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n      let(:subsubcategory) do\n        Fabricate(:category_with_definition, parent_category_id: subcategory.id)\n      end\n\n      # Not used in assertions but fabricated to ensure we're not leaking topics\n      # across categories\n      let!(:_category) { Fabricate(:category_with_definition) }\n      let!(:_subcategory) { Fabricate(:category_with_definition, parent_category_id: _category.id) }\n\n      it \"works with subcategories\" do\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(category.topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subcategory.id).list_latest.topics,\n        ).to contain_exactly(subcategory.topic)\n\n        expect(\n          TopicQuery\n            .new(moderator, category: category.id, no_subcategories: true)\n            .list_latest\n            .topics,\n        ).to contain_exactly(category.topic)\n      end\n\n      it \"shows a subcategory definition topic in its parent list with the right site setting\" do\n        SiteSetting.show_category_definitions_in_topic_lists = true\n\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(category.topic, subcategory.topic)\n      end\n\n      it \"works with subsubcategories\" do\n        SiteSetting.max_category_nesting = 3\n\n        category_topic = Fabricate(:topic, category: category)\n        subcategory_topic = Fabricate(:topic, category: subcategory)\n        subsubcategory_topic = Fabricate(:topic, category: subsubcategory)\n\n        SiteSetting.max_category_nesting = 2\n\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(category.topic, category_topic, subcategory_topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subcategory.id).list_latest.topics,\n        ).to contain_exactly(subcategory.topic, subcategory_topic, subsubcategory_topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subsubcategory.id).list_latest.topics,\n        ).to contain_exactly(subsubcategory.topic, subsubcategory_topic)\n\n        SiteSetting.max_category_nesting = 3\n\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(\n          category.topic,\n          category_topic,\n          subcategory_topic,\n          subsubcategory_topic,\n        )\n\n        expect(\n          TopicQuery.new(moderator, category: subcategory.id).list_latest.topics,\n        ).to contain_exactly(subcategory.topic, subcategory_topic, subsubcategory_topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subsubcategory.id).list_latest.topics,\n        ).to contain_exactly(subsubcategory.topic, subsubcategory_topic)\n      end\n    end\n  end\n\n  describe \"tag filter\" do\n    fab!(:tag) { Fabricate(:tag) }\n    fab!(:other_tag) { Fabricate(:tag) }\n    fab!(:uppercase_tag) { Fabricate(:tag, name: \"HeLlO\") }\n\n    before { SiteSetting.tagging_enabled = true }\n\n    context \"with no category filter\" do\n      fab!(:tagged_topic1) { Fabricate(:topic, tags: [tag]) }\n      fab!(:tagged_topic2) { Fabricate(:topic, tags: [other_tag]) }\n      fab!(:tagged_topic3) { Fabricate(:topic, tags: [tag, other_tag]) }\n      fab!(:tagged_topic4) { Fabricate(:topic, tags: [uppercase_tag]) }\n      fab!(:no_tags_topic) { Fabricate(:topic) }\n      let(:synonym) { Fabricate(:tag, target_tag: tag, name: \"synonym\") }\n\n      it \"excludes a tag if desired\" do\n        topics = TopicQuery.new(moderator, exclude_tag: tag.name).list_latest.topics\n        expect(topics.any? { |t| t.tags.include?(tag) }).to eq(false)\n      end\n\n      it \"returns topics with the tag when filtered to it\" do\n        expect(TopicQuery.new(moderator, tags: tag.name).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(TopicQuery.new(moderator, tags: [tag.id]).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(\n          TopicQuery.new(moderator, tags: [tag.name, other_tag.name]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(\n          TopicQuery.new(moderator, tags: [tag.id, other_tag.id]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(TopicQuery.new(moderator, tags: [\"hElLo\"]).list_latest.topics).to contain_exactly(\n          tagged_topic4,\n        )\n      end\n\n      it \"can return topics with all specified tags\" do\n        expect(\n          TopicQuery\n            .new(moderator, tags: [tag.name, other_tag.name], match_all_tags: true)\n            .list_latest\n            .topics\n            .map(&:id),\n        ).to eq([tagged_topic3.id])\n      end\n\n      it \"can return topics with tag intersections using truthy/falsey values\" do\n        expect(\n          TopicQuery\n            .new(moderator, tags: [tag.name, other_tag.name], match_all_tags: \"false\")\n            .list_latest\n            .topics\n            .map(&:id)\n            .sort,\n        ).to eq([tagged_topic1.id, tagged_topic2.id, tagged_topic3.id].sort)\n      end\n\n      it \"returns an empty relation when an invalid tag is passed\" do\n        expect(\n          TopicQuery\n            .new(moderator, tags: [tag.name, \"notatag\"], match_all_tags: true)\n            .list_latest\n            .topics,\n        ).to be_empty\n      end\n\n      it \"can return topics with no tags\" do\n        expect(TopicQuery.new(moderator, no_tags: true).list_latest.topics.map(&:id)).to eq(\n          [no_tags_topic.id],\n        )\n      end\n\n      it \"can filter using a synonym\" do\n        expect(TopicQuery.new(moderator, tags: synonym.name).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(TopicQuery.new(moderator, tags: [synonym.id]).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(\n          TopicQuery.new(moderator, tags: [synonym.name, other_tag.name]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(\n          TopicQuery.new(moderator, tags: [synonym.id, other_tag.id]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(TopicQuery.new(moderator, tags: [\"SYnonYM\"]).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n      end\n    end\n\n    context \"when remove_muted_tags is enabled\" do\n      fab!(:topic) { Fabricate(:topic, tags: [tag]) }\n\n      before do\n        SiteSetting.remove_muted_tags_from_latest = \"always\"\n        SiteSetting.default_tags_muted = tag.name\n      end\n\n      it \"removes default muted tag topics for anonymous users\" do\n        expect(TopicQuery.new(nil).list_latest.topics.map(&:id)).not_to include(topic.id)\n      end\n    end\n\n    context \"with categories too\" do\n      let(:category1) { Fabricate(:category_with_definition) }\n      let(:category2) { Fabricate(:category_with_definition) }\n\n      it \"returns topics in the given category with the given tag\" do\n        tagged_topic1 = Fabricate(:topic, category: category1, tags: [tag])\n        _tagged_topic2 = Fabricate(:topic, category: category2, tags: [tag])\n        tagged_topic3 = Fabricate(:topic, category: category1, tags: [tag, other_tag])\n        _no_tags_topic = Fabricate(:topic, category: category1)\n\n        expect(\n          TopicQuery\n            .new(moderator, category: category1.id, tags: [tag.name])\n            .list_latest\n            .topics\n            .map(&:id)\n            .sort,\n        ).to eq([tagged_topic1.id, tagged_topic3.id].sort)\n        expect(\n          TopicQuery\n            .new(moderator, category: category2.id, tags: [other_tag.name])\n            .list_latest\n            .topics\n            .size,\n        ).to eq(0)\n      end\n    end\n  end\n\n  describe \"muted categories\" do\n    it \"is removed from top, new and latest lists\" do\n      category = Fabricate(:category_with_definition)\n      topic = Fabricate(:topic, category: category)\n      CategoryUser.create!(\n        user_id: user.id,\n        category_id: category.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      )\n      expect(topic_query.list_new.topics.map(&:id)).not_to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).not_to include(topic.id)\n      TopTopic.create!(topic: topic, all_score: 1)\n      expect(topic_query.list_top_for(:all).topics.map(&:id)).not_to include(topic.id)\n    end\n  end\n\n  describe \"#list_top_for\" do\n    it \"lists top for the week\" do\n      Fabricate(:topic, like_count: 1000, posts_count: 100)\n      TopTopic.refresh!\n      expect(topic_query.list_top_for(:weekly).topics.count).to eq(1)\n    end\n\n    it \"only allows periods defined by TopTopic.periods\" do\n      expect { topic_query.list_top_for(:all) }.not_to raise_error\n      expect { topic_query.list_top_for(:yearly) }.not_to raise_error\n      expect { topic_query.list_top_for(:quarterly) }.not_to raise_error\n      expect { topic_query.list_top_for(:monthly) }.not_to raise_error\n      expect { topic_query.list_top_for(:weekly) }.not_to raise_error\n      expect { topic_query.list_top_for(:daily) }.not_to raise_error\n      expect { topic_query.list_top_for(\"some bad input\") }.to raise_error(\n        Discourse::InvalidParameters,\n      )\n    end\n  end\n\n  describe \"mute_all_categories_by_default\" do\n    fab!(:category) { Fabricate(:category_with_definition) }\n    fab!(:topic) { Fabricate(:topic, category: category) }\n\n    before { SiteSetting.mute_all_categories_by_default = true }\n\n    it \"should remove all topics from new and latest lists by default\" do\n      expect(topic_query.list_new.topics.map(&:id)).not_to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).not_to include(topic.id)\n    end\n\n    it \"should include tracked category topics in new and latest lists\" do\n      topic = Fabricate(:topic, category: category)\n      CategoryUser.create!(\n        user_id: user.id,\n        category_id: category.id,\n        notification_level: CategoryUser.notification_levels[:tracking],\n      )\n      expect(topic_query.list_new.topics.map(&:id)).to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n\n    it \"should include default watched category topics in latest list for anonymous users\" do\n      SiteSetting.default_categories_watching = category.id.to_s\n      expect(TopicQuery.new.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n\n    it \"should include default regular category topics in latest list for anonymous users\" do\n      SiteSetting.default_categories_normal = category.id.to_s\n      expect(TopicQuery.new.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n\n    it \"should include topics when filtered by category\" do\n      topic_query = TopicQuery.new(user, category: topic.category_id)\n      expect(topic_query.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n  end\n\n  describe \"already seen topics\" do\n    it \"is removed from new and visible on latest lists\" do\n      category = Fabricate(:category_with_definition)\n      topic = Fabricate(:topic, category: category)\n      DismissedTopicUser.create!(user_id: user.id, topic_id: topic.id, created_at: Time.zone.now)\n      expect(topic_query.list_new.topics.map(&:id)).not_to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n  end\n\n  describe \"muted tags\" do\n    it \"is removed from new and latest lists\" do\n      SiteSetting.tagging_enabled = true\n      SiteSetting.remove_muted_tags_from_latest = \"always\"\n\n      muted_tag, other_tag = Fabricate(:tag), Fabricate(:tag)\n\n      muted_topic = Fabricate(:topic, tags: [muted_tag])\n      tagged_topic = Fabricate(:topic, tags: [other_tag])\n      muted_tagged_topic = Fabricate(:topic, tags: [muted_tag, other_tag])\n      untagged_topic = Fabricate(:topic)\n\n      TagUser.create!(\n        user_id: user.id,\n        tag_id: muted_tag.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      )\n\n      topic_ids = topic_query.list_latest.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(tagged_topic.id, untagged_topic.id)\n\n      topic_ids = topic_query.list_new.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(tagged_topic.id, untagged_topic.id)\n\n      SiteSetting.remove_muted_tags_from_latest = \"only_muted\"\n\n      topic_ids = topic_query.list_latest.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n\n      topic_ids = topic_query.list_new.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n\n      SiteSetting.remove_muted_tags_from_latest = \"never\"\n\n      topic_ids = topic_query.list_latest.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        muted_topic.id,\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n\n      topic_ids = topic_query.list_new.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        muted_topic.id,\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n    end\n\n    it \"is not removed from the tag page itself\" do\n      muted_tag = Fabricate(:tag)\n      TagUser.create!(\n        user_id: user.id,\n        tag_id: muted_tag.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      )\n\n      muted_topic = Fabricate(:topic, tags: [muted_tag])\n\n      topic_ids = topic_query.latest_results(tags: [muted_tag.name]).map(&:id)\n      expect(topic_ids).to contain_exactly(muted_topic.id)\n\n      muted_tag.update(name: \"mixedCaseName\")\n      topic_ids = topic_query.latest_results(tags: [muted_tag.name.downcase]).map(&:id)\n      expect(topic_ids).to contain_exactly(muted_topic.id)\n    end\n  end\n\n  describe \"a bunch of topics\" do\n    fab!(:regular_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a regular topic\",\n        user: creator,\n        views: 100,\n        like_count: 66,\n        posts_count: 3,\n        participant_count: 11,\n        bumped_at: 15.minutes.ago,\n      )\n    end\n    fab!(:pinned_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a pinned topic\",\n        user: creator,\n        views: 10,\n        like_count: 100,\n        posts_count: 5,\n        participant_count: 12,\n        pinned_at: 10.minutes.ago,\n        pinned_globally: true,\n        bumped_at: 10.minutes.ago,\n      )\n    end\n    fab!(:archived_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is an archived topic\",\n        user: creator,\n        views: 50,\n        like_count: 30,\n        posts_count: 4,\n        archived: true,\n        participant_count: 1,\n        bumped_at: 6.minutes.ago,\n      )\n    end\n    fab!(:invisible_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is an invisible topic\",\n        user: creator,\n        views: 1,\n        like_count: 5,\n        posts_count: 2,\n        visible: false,\n        participant_count: 3,\n        bumped_at: 5.minutes.ago,\n      )\n    end\n    fab!(:closed_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a closed topic\",\n        user: creator,\n        views: 2,\n        like_count: 1,\n        posts_count: 1,\n        closed: true,\n        participant_count: 2,\n        bumped_at: 1.minute.ago,\n      )\n    end\n    fab!(:future_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a topic in far future\",\n        user: creator,\n        views: 30,\n        like_count: 11,\n        posts_count: 6,\n        participant_count: 5,\n        bumped_at: 1000.years.from_now,\n      )\n    end\n\n    let(:topics) { topic_query.list_latest.topics }\n\n    context \"with list_latest\" do\n      it \"returns the topics in the correct order\" do\n        expect(topics.map(&:id)).to eq(\n          [pinned_topic, future_topic, closed_topic, archived_topic, regular_topic].map(&:id),\n        )\n\n        # includes the invisible topic if you're a moderator\n        expect(TopicQuery.new(moderator).list_latest.topics.include?(invisible_topic)).to eq(true)\n\n        # includes the invisible topic if you're an admin\n        expect(TopicQuery.new(admin).list_latest.topics.include?(invisible_topic)).to eq(true)\n\n        # includes the invisible topic if you're a TL4 user\n        expect(TopicQuery.new(tl4_user).list_latest.topics.include?(invisible_topic)).to eq(true)\n      end\n\n      context \"with sort_order\" do\n        def ids_in_order(order, descending = true)\n          TopicQuery\n            .new(admin, order: order, ascending: descending ? \"false\" : \"true\")\n            .list_latest\n            .topics\n            .map(&:id)\n        end\n\n        it \"returns the topics in correct order\" do\n          # returns the topics in likes order if requested\n          expect(ids_in_order(\"posts\")).to eq(\n            [\n              future_topic,\n              pinned_topic,\n              archived_topic,\n              regular_topic,\n              invisible_topic,\n              closed_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse likes order if requested\n          expect(ids_in_order(\"posts\", false)).to eq(\n            [\n              closed_topic,\n              invisible_topic,\n              regular_topic,\n              archived_topic,\n              pinned_topic,\n              future_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in likes order if requested\n          expect(ids_in_order(\"likes\")).to eq(\n            [\n              pinned_topic,\n              regular_topic,\n              archived_topic,\n              future_topic,\n              invisible_topic,\n              closed_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse likes order if requested\n          expect(ids_in_order(\"likes\", false)).to eq(\n            [\n              closed_topic,\n              invisible_topic,\n              future_topic,\n              archived_topic,\n              regular_topic,\n              pinned_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in views order if requested\n          expect(ids_in_order(\"views\")).to eq(\n            [\n              regular_topic,\n              archived_topic,\n              future_topic,\n              pinned_topic,\n              closed_topic,\n              invisible_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse views order if requested\" do\n          expect(ids_in_order(\"views\", false)).to eq(\n            [\n              invisible_topic,\n              closed_topic,\n              pinned_topic,\n              future_topic,\n              archived_topic,\n              regular_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in posters order if requested\" do\n          expect(ids_in_order(\"posters\")).to eq(\n            [\n              pinned_topic,\n              regular_topic,\n              future_topic,\n              invisible_topic,\n              closed_topic,\n              archived_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse posters order if requested\" do\n          expect(ids_in_order(\"posters\", false)).to eq(\n            [\n              archived_topic,\n              closed_topic,\n              invisible_topic,\n              future_topic,\n              regular_topic,\n              pinned_topic,\n            ].map(&:id),\n          )\n\n          # sets a custom field for each topic to emulate a plugin\n          regular_topic.custom_fields[\"sheep\"] = 26\n          pinned_topic.custom_fields[\"sheep\"] = 47\n          archived_topic.custom_fields[\"sheep\"] = 69\n          invisible_topic.custom_fields[\"sheep\"] = 12\n          closed_topic.custom_fields[\"sheep\"] = 31\n          future_topic.custom_fields[\"sheep\"] = 53\n\n          regular_topic.save\n          pinned_topic.save\n          archived_topic.save\n          invisible_topic.save\n          closed_topic.save\n          future_topic.save\n\n          # adds the custom field as a viable sort option\n          class ::TopicQuery\n            SORTABLE_MAPPING[\"sheep\"] = \"custom_fields.sheep\"\n          end\n          # returns the topics in the sheep order if requested\" do\n          expect(ids_in_order(\"sheep\")).to eq(\n            [\n              archived_topic,\n              future_topic,\n              pinned_topic,\n              closed_topic,\n              regular_topic,\n              invisible_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse sheep order if requested\" do\n          expect(ids_in_order(\"sheep\", false)).to eq(\n            [\n              invisible_topic,\n              regular_topic,\n              closed_topic,\n              pinned_topic,\n              future_topic,\n              archived_topic,\n            ].map(&:id),\n          )\n        end\n      end\n    end\n\n    context \"after clearing a pinned topic\" do\n      before { pinned_topic.clear_pin_for(user) }\n\n      it \"no longer shows the pinned topic at the top\" do\n        expect(topics).to eq(\n          [future_topic, closed_topic, archived_topic, pinned_topic, regular_topic],\n        )\n      end\n    end\n  end\n\n  describe \"categorized\" do\n    fab!(:category) { Fabricate(:category_with_definition) }\n    let(:topic_category) { category.topic }\n    fab!(:topic_no_cat) { Fabricate(:topic) }\n    fab!(:topic_in_cat1) do\n      Fabricate(:topic, category: category, bumped_at: 10.minutes.ago, created_at: 10.minutes.ago)\n    end\n    fab!(:topic_in_cat2) { Fabricate(:topic, category: category) }\n\n    describe \"#list_new_in_category\" do\n      it \"returns the topic category and the categorized topic\" do\n        expect(topic_query.list_new_in_category(category).topics.map(&:id)).to eq(\n          [topic_in_cat2.id, topic_category.id, topic_in_cat1.id],\n        )\n      end\n    end\n\n    describe \"category default sort order\" do\n      it \"can use category's default sort order\" do\n        category.update!(sort_order: \"created\", sort_ascending: true)\n        topic_ids = TopicQuery.new(user, category: category.id).list_latest.topics.map(&:id)\n        expect(topic_ids - [topic_category.id]).to eq([topic_in_cat1.id, topic_in_cat2.id])\n      end\n\n      it \"should apply default sort order to latest and unseen filters only\" do\n        category.update!(sort_order: \"created\", sort_ascending: true)\n\n        topic1 =\n          Fabricate(\n            :topic,\n            category: category,\n            like_count: 1000,\n            posts_count: 100,\n            created_at: 1.day.ago,\n          )\n        topic2 =\n          Fabricate(\n            :topic,\n            category: category,\n            like_count: 5200,\n            posts_count: 500,\n            created_at: 1.hour.ago,\n          )\n        TopTopic.refresh!\n\n        topic_ids =\n          TopicQuery.new(user, category: category.id).list_top_for(:monthly).topics.map(&:id)\n        expect(topic_ids).to eq([topic2.id, topic1.id])\n      end\n\n      it \"ignores invalid order value\" do\n        category.update!(sort_order: \"funny\")\n        topic_ids = TopicQuery.new(user, category: category.id).list_latest.topics.map(&:id)\n        expect(topic_ids - [topic_category.id]).to eq([topic_in_cat2.id, topic_in_cat1.id])\n      end\n\n      it \"can be overridden\" do\n        category.update!(sort_order: \"created\", sort_ascending: true)\n        topic_ids =\n          TopicQuery\n            .new(user, category: category.id, order: \"activity\")\n            .list_latest\n            .topics\n            .map(&:id)\n        expect(topic_ids - [topic_category.id]).to eq([topic_in_cat2.id, topic_in_cat1.id])\n      end\n    end\n  end\n\n  describe \"unread / read topics\" do\n    context \"with no data\" do\n      it \"has no unread topics\" do\n        expect(topic_query.list_unread.topics).to be_blank\n      end\n    end\n\n    context \"with whispers\" do\n      before { SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\" }\n\n      it \"correctly shows up in unread for staff\" do\n        first = create_post(raw: \"this is the first post\", title: \"super amazing title\")\n\n        _whisper =\n          create_post(\n            topic_id: first.topic.id,\n            post_type: Post.types[:whisper],\n            raw: \"this is a whispered reply\",\n          )\n\n        topic_id = first.topic.id\n\n        TopicUser.update_last_read(user, topic_id, first.post_number, 1, 1)\n        TopicUser.update_last_read(admin, topic_id, first.post_number, 1, 1)\n\n        TopicUser.change(\n          user.id,\n          topic_id,\n          notification_level: TopicUser.notification_levels[:tracking],\n        )\n        TopicUser.change(\n          admin.id,\n          topic_id,\n          notification_level: TopicUser.notification_levels[:tracking],\n        )\n\n        expect(TopicQuery.new(user).list_unread.topics).to eq([])\n        expect(TopicQuery.new(admin).list_unread.topics).to eq([first.topic])\n      end\n    end\n\n    context \"with read data\" do\n      fab!(:partially_read) { Fabricate(:post, user: creator).topic }\n      fab!(:fully_read) { Fabricate(:post, user: creator).topic }\n\n      before do\n        TopicUser.update_last_read(user, partially_read.id, 0, 0, 0)\n        TopicUser.update_last_read(user, fully_read.id, 1, 1, 0)\n      end\n\n      context \"with list_unread\" do\n        it \"lists topics correctly\" do\n          _new_topic = Fabricate(:post, user: creator).topic\n\n          expect(topic_query.list_unread.topics).to eq([])\n          expect(topic_query.list_read.topics).to match_array([fully_read, partially_read])\n        end\n      end\n\n      context \"with user with auto_track_topics list_unread\" do\n        before do\n          user.user_option.auto_track_topics_after_msecs = 0\n          user.user_option.save\n        end\n\n        it \"only contains the partially read topic\" do\n          expect(topic_query.list_unread.topics).to eq([partially_read])\n        end\n      end\n    end\n  end\n\n  describe \"#list_new\" do\n    context \"without a new topic\" do\n      it \"has no new topics\" do\n        expect(topic_query.list_new.topics).to be_blank\n      end\n    end\n\n    context \"when preloading api\" do\n      it \"preloads data correctly\" do\n        TopicList.preloaded_custom_fields << \"tag\"\n        TopicList.preloaded_custom_fields << \"age\"\n        TopicList.preloaded_custom_fields << \"foo\"\n\n        topic = Fabricate.build(:topic, user: creator, bumped_at: 10.minutes.ago)\n        topic.custom_fields[\"tag\"] = %w[a b c]\n        topic.custom_fields[\"age\"] = 22\n        topic.save\n\n        new_topic = topic_query.list_new.topics.first\n\n        expect(new_topic.custom_fields[\"tag\"].sort).to eq(%w[a b c])\n        expect(new_topic.custom_fields[\"age\"]).to eq(\"22\")\n\n        expect(new_topic.custom_field_preloaded?(\"tag\")).to eq(true)\n        expect(new_topic.custom_field_preloaded?(\"age\")).to eq(true)\n        expect(new_topic.custom_field_preloaded?(\"foo\")).to eq(true)\n        expect(new_topic.custom_field_preloaded?(\"bar\")).to eq(false)\n\n        TopicList.preloaded_custom_fields.clear\n\n        # if we attempt to access non preloaded fields explode\n        expect { new_topic.custom_fields[\"boom\"] }.to raise_error(StandardError)\n      end\n    end\n\n    context \"when preloading associations\" do\n      it \"preloads associations\" do\n        DiscoursePluginRegistry.register_topic_preloader_association(\n          :first_post,\n          Plugin::Instance.new,\n        )\n\n        topic = Fabricate(:topic)\n        Fabricate(:post, topic: topic)\n\n        new_topic = topic_query.list_new.topics.first\n        expect(new_topic.association(:image_upload).loaded?).to eq(true) # Preloaded by default\n        expect(new_topic.association(:first_post).loaded?).to eq(true) # Testing a user-defined preloaded association\n        expect(new_topic.association(:user).loaded?).to eq(false) # Testing the negative\n\n        DiscoursePluginRegistry.reset_register!(:topic_preloader_associations)\n      end\n    end\n\n    context \"with a new topic\" do\n      let!(:new_topic) { Fabricate(:topic, user: creator, bumped_at: 10.minutes.ago) }\n      let(:topics) { topic_query.list_new.topics }\n\n      it \"contains no new topics for a user that has missed the window\" do\n        expect(topic_query.list_new.topics).to eq([new_topic])\n\n        user.user_option.new_topic_duration_minutes = 5\n        user.user_option.save\n        new_topic.created_at = 10.minutes.ago\n        new_topic.save\n        expect(topic_query.list_new.topics).to eq([])\n      end\n\n      context \"with muted topics\" do\n        before { new_topic.notify_muted!(user) }\n\n        it \"returns an empty set\" do\n          expect(topics).to be_blank\n          expect(topic_query.list_latest.topics).to be_blank\n        end\n\n        context \"when un-muted\" do\n          before { new_topic.notify_tracking!(user) }\n\n          it \"returns the topic again\" do\n            expect(topics).to eq([new_topic])\n            expect(topic_query.list_latest.topics).not_to be_blank\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#list_posted\" do\n    let(:topics) { topic_query.list_posted.topics }\n\n    it \"returns blank when there are no posted topics\" do\n      expect(topics).to be_blank\n    end\n\n    context \"with created topics\" do\n      let!(:created_topic) { create_post(user: user).topic }\n\n      it \"includes the created topic\" do\n        expect(topics.include?(created_topic)).to eq(true)\n      end\n    end\n\n    context \"with topic you've posted in\" do\n      let(:other_users_topic) { create_post(user: creator).topic }\n      let!(:your_post) { create_post(user: user, topic: other_users_topic) }\n\n      it \"includes the posted topic\" do\n        expect(topics.include?(other_users_topic)).to eq(true)\n      end\n    end\n\n    context \"with topic you haven't posted in\" do\n      let(:other_users_topic) { create_post(user: creator).topic }\n\n      it \"does not include the topic\" do\n        expect(topics).to be_blank\n      end\n\n      context \"with topic you interacted with\" do\n        it \"is not included if read\" do\n          TopicUser.update_last_read(user, other_users_topic.id, 0, 0, 0)\n\n          expect(topics).to be_blank\n        end\n\n        it \"is not included if muted\" do\n          other_users_topic.notify_muted!(user)\n\n          expect(topics).to be_blank\n        end\n\n        it \"is not included if tracking\" do\n          other_users_topic.notify_tracking!(user)\n\n          expect(topics).to be_blank\n        end\n      end\n    end\n  end\n\n  describe \"#list_unseen\" do\n    it \"returns an empty list when there aren't topics\" do\n      expect(topic_query.list_unseen.topics).to be_blank\n    end\n\n    it \"doesn't return topics that were bumped last time before user joined the forum\" do\n      user.first_seen_at = 10.minutes.ago\n      create_topic_with_three_posts(bumped_at: 15.minutes.ago)\n\n      expect(topic_query.list_unseen.topics).to be_blank\n    end\n\n    it \"returns only topics that contain unseen posts\" do\n      user.first_seen_at = 10.minutes.ago\n      topic_with_unseen_posts = create_topic_with_three_posts(bumped_at: 5.minutes.ago)\n      read_to_post(topic_with_unseen_posts, user, 1)\n\n      fully_read_topic = create_topic_with_three_posts(bumped_at: 5.minutes.ago)\n      read_to_the_end(fully_read_topic, user)\n\n      expect(topic_query.list_unseen.topics).to eq([topic_with_unseen_posts])\n    end\n\n    it \"ignores staff posts if user is not staff\" do\n      user.first_seen_at = 10.minutes.ago\n      topic = create_topic_with_three_posts(bumped_at: 5.minutes.ago)\n      read_to_the_end(topic, user)\n      create_post(topic: topic, post_type: Post.types[:whisper])\n\n      expect(topic_query.list_unseen.topics).to be_blank\n    end\n\n    def create_topic_with_three_posts(bumped_at:)\n      topic = Fabricate(:topic, bumped_at: bumped_at)\n      Fabricate(:post, topic: topic)\n      Fabricate(:post, topic: topic)\n      Fabricate(:post, topic: topic)\n      topic.highest_staff_post_number = 3\n      topic.highest_post_number = 3\n      topic\n    end\n\n    def read_to_post(topic, user, post_number)\n      TopicUser.update_last_read(user, topic.id, post_number, 0, 0)\n    end\n\n    def read_to_the_end(topic, user)\n      read_to_post topic, user, topic.highest_post_number\n    end\n  end\n\n  describe \"#list_related_for\" do\n    let(:user) { Fabricate(:user) }\n    let(:sender) { Fabricate(:user) }\n\n    let(:group_with_user) do\n      group = Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone])\n      group.add(user)\n      group.save\n      group\n    end\n\n    def create_pm(user, opts = nil)\n      unless opts\n        opts = user\n        user = nil\n      end\n\n      create_post(opts.merge(user: user, archetype: Archetype.private_message)).topic\n    end\n\n    def read(user, topic, post_number)\n      TopicUser.update_last_read(user, topic, post_number, post_number, 10_000)\n    end\n\n    before do\n      user.change_trust_level!(4)\n      sender.change_trust_level!(4)\n    end\n\n    it \"returns the correct suggestions\" do\n      pm_to_group = create_pm(sender, target_group_names: [group_with_user.name])\n      pm_to_user = create_pm(sender, target_usernames: [user.username])\n\n      other_user = Fabricate(:user)\n      other_user.change_trust_level!(1)\n      old_unrelated_pm = create_pm(other_user, target_usernames: [user.username])\n      read(user, old_unrelated_pm, 1)\n\n      related_by_user_pm = create_pm(sender, target_usernames: [user.username])\n      read(user, related_by_user_pm, 1)\n\n      related_by_group_pm = create_pm(sender, target_group_names: [group_with_user.name])\n      read(user, related_by_group_pm, 1)\n\n      expect(TopicQuery.new(user).list_related_for(pm_to_group).topics.map(&:id)).to(\n        eq([related_by_group_pm.id]),\n      )\n\n      expect(TopicQuery.new(user).list_related_for(pm_to_user).topics.map(&:id)).to(\n        eq([related_by_user_pm.id]),\n      )\n\n      SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:staff]\n      expect(TopicQuery.new(user).list_related_for(pm_to_group)).to be_blank\n      expect(TopicQuery.new(user).list_related_for(pm_to_user)).to be_blank\n    end\n  end\n\n  describe \"suggested_for\" do\n    def clear_cache!\n      Discourse.redis.keys(\"random_topic_cache*\").each { |k| Discourse.redis.del k }\n    end\n\n    before { clear_cache! }\n\n    context \"when anonymous\" do\n      let(:topic) { Fabricate(:topic) }\n      let!(:new_topic) { Fabricate(:post, user: creator).topic }\n\n      it \"should return the new topic\" do\n        expect(TopicQuery.new.list_suggested_for(topic).topics).to eq([new_topic])\n      end\n    end\n\n    context \"when anonymously browsing with invisible, closed and archived\" do\n      let!(:topic) { Fabricate(:topic) }\n      let!(:regular_topic) { Fabricate(:post, user: creator).topic }\n      let!(:closed_topic) { Fabricate(:topic, user: creator, closed: true) }\n      let!(:archived_topic) { Fabricate(:topic, user: creator, archived: true) }\n      let!(:invisible_topic) { Fabricate(:topic, user: creator, visible: false) }\n\n      it \"should omit the closed/archived/invisible topics from suggested\" do\n        expect(TopicQuery.new.list_suggested_for(topic).topics).to eq([regular_topic])\n      end\n    end\n\n    context \"when logged in\" do\n      def suggested_for(topic)\n        topic_query.list_suggested_for(topic)&.topics&.map { |t| t.id }\n      end\n\n      let(:topic) { Fabricate(:topic) }\n      let(:suggested_topics) do\n        tt = topic\n        # lets clear cache once category is created - working around caching is hard\n        clear_cache!\n        suggested_for(tt)\n      end\n\n      it \"should return empty results when there is nothing to find\" do\n        expect(suggested_topics).to be_blank\n      end\n\n      context \"with random suggested\" do\n        let!(:new_topic) { Fabricate(:topic, created_at: 2.days.ago) }\n        let!(:old_topic) { Fabricate(:topic, created_at: 3.years.ago) }\n\n        it \"respects suggested_topics_max_days_old\" do\n          SiteSetting.suggested_topics_max_days_old = 1365\n          tt = topic\n\n          clear_cache!\n          expect(topic_query.list_suggested_for(tt).topics.length).to eq(2)\n\n          SiteSetting.suggested_topics_max_days_old = 365\n          clear_cache!\n\n          expect(topic_query.list_suggested_for(tt).topics.length).to eq(1)\n        end\n\n        it \"removes muted topics\" do\n          SiteSetting.suggested_topics_max_days_old = 1365\n          tt = topic\n          TopicNotifier.new(old_topic).mute!(user)\n          clear_cache!\n\n          topics = topic_query.list_suggested_for(tt).topics\n\n          expect(topics.length).to eq(1)\n          expect(topics).not_to include(old_topic)\n        end\n      end\n\n      context \"with private messages\" do\n        let(:group_user) { Fabricate(:user) }\n        let(:group) { Fabricate(:group) }\n        let(:another_group) { Fabricate(:group) }\n\n        let!(:topic) do\n          Fabricate(\n            :private_message_topic,\n            topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: user)],\n            topic_allowed_groups: [Fabricate.build(:topic_allowed_group, group: group)],\n          )\n        end\n\n        let!(:private_message) do\n          Fabricate(\n            :private_message_topic,\n            topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: user)],\n            topic_allowed_groups: [\n              Fabricate.build(:topic_allowed_group, group: group),\n              Fabricate.build(:topic_allowed_group, group: another_group),\n            ],\n          )\n        end\n\n        let!(:private_group_topic) do\n          Fabricate(\n            :private_message_topic,\n            user: Fabricate(:user),\n            topic_allowed_groups: [Fabricate.build(:topic_allowed_group, group: group)],\n          )\n        end\n\n        before do\n          group.add(group_user)\n          another_group.add(user)\n          Group.user_trust_level_change!(user.id, user.trust_level)\n          Group.user_trust_level_change!(group_user.id, group_user.trust_level)\n        end\n\n        context \"as user not part of group\" do\n          let!(:user) { Fabricate(:user) }\n\n          it \"should not return topics by the group user\" do\n            expect(suggested_topics).to eq([private_message.id])\n          end\n        end\n\n        context \"as user part of group\" do\n          let!(:user) { group_user }\n\n          it \"should return the group topics\" do\n            expect(suggested_topics).to match_array([private_group_topic.id, private_message.id])\n          end\n\n          context \"when user is not in personal_message_enabled_groups\" do\n            before do\n              SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:trust_level_4]\n            end\n\n            it \"should not return topics by the group user\" do\n              expect(suggested_topics).to eq(nil)\n            end\n          end\n        end\n\n        context \"with tag filter\" do\n          let(:tag) { Fabricate(:tag) }\n          let!(:user) { group_user }\n\n          it \"should return only tagged topics\" do\n            Fabricate(:topic_tag, topic: private_message, tag: tag)\n            Fabricate(:topic_tag, topic: private_group_topic)\n\n            expect(\n              TopicQuery.new(user, tags: [tag.name]).list_private_messages_tag(user).topics,\n            ).to eq([private_message])\n          end\n        end\n      end\n\n      context \"with some existing topics\" do\n        let!(:old_partially_read) do\n          topic = Fabricate(:post, user: creator).topic\n          Fabricate(:post, user: creator, topic: topic)\n          topic\n        end\n\n        let!(:partially_read) do\n          topic = Fabricate(:post, user: creator).topic\n          Fabricate(:post, user: creator, topic: topic)\n          topic\n        end\n\n        let!(:new_topic) { Fabricate(:post, user: creator).topic }\n        let!(:fully_read) { Fabricate(:post, user: creator).topic }\n        let!(:closed_topic) { Fabricate(:topic, user: creator, closed: true) }\n        let!(:archived_topic) { Fabricate(:topic, user: creator, archived: true) }\n        let!(:invisible_topic) { Fabricate(:topic, user: creator, visible: false) }\n        let!(:fully_read_closed) { Fabricate(:post, user: creator).topic }\n        let!(:fully_read_archived) { Fabricate(:post, user: creator).topic }\n\n        before do\n          user.user_option.update!(\n            auto_track_topics_after_msecs: 0,\n            new_topic_duration_minutes: User::NewTopicDuration::ALWAYS,\n          )\n\n          freeze_time 3.weeks.from_now\n\n          TopicUser.update_last_read(user, old_partially_read.id, 1, 1, 0)\n          TopicUser.update_last_read(user, partially_read.id, 1, 1, 0)\n          TopicUser.update_last_read(user, fully_read.id, 1, 1, 0)\n          TopicUser.update_last_read(user, fully_read_closed.id, 1, 1, 0)\n          TopicUser.update_last_read(user, fully_read_archived.id, 1, 1, 0)\n\n          fully_read_closed.closed = true\n          fully_read_closed.save\n          fully_read_archived.archived = true\n          fully_read_archived.save\n\n          old_partially_read.update!(updated_at: 2.weeks.ago)\n          partially_read.update!(updated_at: Time.now)\n        end\n\n        it \"operates correctly\" do\n          # Note, this is a pretty slow integration test\n          # it tests that suggested is returned in the expected order\n          # hence we run suggested_for twice here to save on all the setup\n\n          SiteSetting.suggested_topics = 4\n          SiteSetting.suggested_topics_unread_max_days_old = 7\n\n          expect(suggested_topics[0]).to eq(partially_read.id)\n          expect(suggested_topics[1, 3]).to contain_exactly(\n            new_topic.id,\n            closed_topic.id,\n            archived_topic.id,\n          )\n\n          expect(suggested_topics.length).to eq(4)\n\n          SiteSetting.suggested_topics = 2\n          SiteSetting.suggested_topics_unread_max_days_old = 15\n\n          expect(suggested_for(topic)).to contain_exactly(partially_read.id, old_partially_read.id)\n        end\n      end\n    end\n  end\n\n  describe \"#list_group_topics\" do\n    fab!(:group) { Fabricate(:group) }\n\n    let(:user) do\n      user = Fabricate(:user)\n      group.add(user)\n      user\n    end\n\n    let(:user2) do\n      user = Fabricate(:user)\n      group.add(user)\n      user\n    end\n\n    fab!(:user3) { Fabricate(:user) }\n\n    fab!(:private_category) { Fabricate(:private_category_with_definition, group: group) }\n\n    let!(:private_message_topic) { Fabricate(:private_message_post, user: user).topic }\n    let!(:topic1) { Fabricate(:topic, user: user) }\n    let!(:topic2) { Fabricate(:topic, user: user, category: Fabricate(:category_with_definition)) }\n    let!(:topic3) { Fabricate(:topic, user: user, category: private_category) }\n    let!(:topic4) { Fabricate(:topic) }\n    let!(:topic5) { Fabricate(:topic, user: user, visible: false) }\n    let!(:topic6) { Fabricate(:topic, user: user2) }\n\n    it \"should return the right lists for anon user\" do\n      topics = TopicQuery.new.list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic6)\n    end\n\n    it \"should return the right list for users in the same group\" do\n      topics = TopicQuery.new(user).list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic3, topic6)\n\n      topics = TopicQuery.new(user2).list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic3, topic6)\n    end\n\n    it \"should return the right list for user no in the group\" do\n      topics = TopicQuery.new(user3).list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic6)\n    end\n  end\n\n  describe \"shared drafts\" do\n    fab!(:category) { Fabricate(:category_with_definition) }\n    fab!(:shared_drafts_category) { Fabricate(:category_with_definition) }\n    fab!(:topic) { Fabricate(:topic, category: shared_drafts_category) }\n    fab!(:shared_draft) { Fabricate(:shared_draft, topic: topic, category: category) }\n    fab!(:admin) { Fabricate(:admin) }\n    fab!(:user) { Fabricate(:user) }\n    fab!(:group) { Fabricate(:group) }\n\n    before do\n      shared_drafts_category.set_permissions(group => :full)\n      shared_drafts_category.save\n      SiteSetting.shared_drafts_category = shared_drafts_category.id\n      SiteSetting.shared_drafts_min_trust_level = TrustLevel[3]\n    end\n\n    context \"with destination_category_id\" do\n      it \"doesn't allow regular users to query destination_category_id\" do\n        list = TopicQuery.new(user, destination_category_id: category.id).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n\n      it \"allows staff users to query destination_category_id\" do\n        list = TopicQuery.new(admin, destination_category_id: category.id).list_latest\n        expect(list.topics).to include(topic)\n      end\n\n      it \"allow group members with enough trust level to query destination_category_id\" do\n        member = Fabricate(:user, trust_level: TrustLevel[3])\n        group.add(member)\n\n        list = TopicQuery.new(member, destination_category_id: category.id).list_latest\n\n        expect(list.topics).to include(topic)\n      end\n\n      it \"doesn't allow group members without enough trust level to query destination_category_id\" do\n        member = Fabricate(:user, trust_level: TrustLevel[2])\n        group.add(member)\n\n        list = TopicQuery.new(member, destination_category_id: category.id).list_latest\n\n        expect(list.topics).not_to include(topic)\n      end\n    end\n\n    context \"with latest\" do\n      it \"doesn't include shared topics unless filtering by category\" do\n        list = TopicQuery.new(moderator).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n\n      it \"doesn't include shared draft topics for regular users\" do\n        group.add(user)\n        SiteSetting.shared_drafts_category = nil\n        list = TopicQuery.new(user).list_latest\n        expect(list.topics).to include(topic)\n\n        SiteSetting.shared_drafts_category = shared_drafts_category.id\n        list = TopicQuery.new(user).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n\n      it \"doesn't include shared draft topics for group members with access to shared drafts\" do\n        member = Fabricate(:user, trust_level: TrustLevel[3])\n        group.add(member)\n\n        list = TopicQuery.new(member).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n    end\n\n    context \"with unread\" do\n      let!(:partially_read) do\n        topic = Fabricate(:topic, category: shared_drafts_category)\n        Fabricate(:post, user: creator, topic: topic).topic\n        TopicUser.update_last_read(admin, topic.id, 0, 0, 0)\n        TopicUser.change(\n          admin.id,\n          topic.id,\n          notification_level: TopicUser.notification_levels[:tracking],\n        )\n        topic\n      end\n\n      it \"does not remove topics from unread\" do\n        expect(TopicQuery.new(admin).list_latest.topics).not_to include(partially_read) # Check we set up the topic/category correctly\n        expect(TopicQuery.new(admin).list_unread.topics).to include(partially_read)\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n#\n# Helps us find topics.\n# Returns a TopicList object containing the topics found.\n#\n\nclass TopicQuery\n  include PrivateMessageLists\n\n  PG_MAX_INT ||= 2_147_483_647\n  DEFAULT_PER_PAGE_COUNT ||= 30\n\n  def self.validators\n    @validators ||=\n      begin\n        int = lambda { |x| Integer === x || (String === x && x.match?(/\\A-?[0-9]+\\z/)) }\n        zero_up_to_max_int = lambda { |x| int.call(x) && x.to_i.between?(0, PG_MAX_INT) }\n        array_or_string = lambda { |x| Array === x || String === x }\n\n        {\n          max_posts: zero_up_to_max_int,\n          min_posts: zero_up_to_max_int,\n          page: zero_up_to_max_int,\n          tags: array_or_string,\n        }\n      end\n  end\n\n  def self.validate?(option, value)\n    if fn = validators[option.to_sym]\n      fn.call(value)\n    else\n      true\n    end\n  end\n\n  def self.public_valid_options\n    # For these to work in Ember, add them to `controllers/discovery-sortable.js`\n    @public_valid_options ||= %i[\n      page\n      before\n      bumped_before\n      topic_ids\n      category\n      order\n      ascending\n      min_posts\n      max_posts\n      status\n      filter\n      state\n      search\n      q\n      f\n      group_name\n      tags\n      match_all_tags\n      no_subcategories\n      no_tags\n      exclude_tag\n    ]\n  end\n\n  def self.valid_options\n    @valid_options ||=\n      public_valid_options +\n        %i[\n          except_topic_ids\n          limit\n          page\n          per_page\n          visible\n          guardian\n          no_definitions\n          destination_category_id\n          include_all_pms\n          include_pms\n        ]\n  end\n\n  # Maps `order` to a columns in `topics`\n  SORTABLE_MAPPING = {\n    \"likes\" => \"like_count\",\n    \"op_likes\" => \"op_likes\",\n    \"views\" => \"views\",\n    \"posts\" => \"posts_count\",\n    \"activity\" => \"bumped_at\",\n    \"posters\" => \"participant_count\",\n    \"category\" => \"category_id\",\n    \"created\" => \"created_at\",\n  }\n\n  cattr_accessor :results_filter_callbacks\n  self.results_filter_callbacks = []\n\n  attr_accessor :options, :user, :guardian\n\n  def self.add_custom_filter(key, &blk)\n    @custom_filters ||= {}\n    valid_options << key\n    public_valid_options << key\n    @custom_filters[key] = blk\n  end\n\n  def self.remove_custom_filter(key)\n    @custom_filters.delete(key)\n    public_valid_options.delete(key)\n    valid_options.delete(key)\n    @custom_filters = nil if @custom_filters.length == 0\n  end\n\n  def self.apply_custom_filters(results, topic_query)\n    if @custom_filters\n      @custom_filters.each { |key, filter| results = filter.call(results, topic_query) }\n    end\n    results\n  end\n\n  def initialize(user = nil, options = {})\n    options.assert_valid_keys(TopicQuery.valid_options)\n    @options = options.dup\n    @user = user\n    @guardian = options[:guardian] || Guardian.new(@user)\n  end\n\n  def joined_topic_user(list = nil)\n    (list || Topic).joins(\n      \"LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i})\",\n    )\n  end\n\n  def get_pm_params(topic)\n    if topic.private_message?\n      my_group_ids =\n        topic\n          .topic_allowed_groups\n          .joins(\n            \"\n          LEFT JOIN group_users gu\n          ON topic_allowed_groups.group_id = gu.group_id\n          AND gu.user_id = #{@user.id.to_i}\n        \",\n          )\n          .where(\"gu.group_id IS NOT NULL\")\n          .pluck(:group_id)\n\n      target_group_ids = topic.topic_allowed_groups.pluck(:group_id)\n\n      target_users = topic.topic_allowed_users\n\n      if my_group_ids.present?\n        # strip out users in groups you already belong to\n        target_users =\n          target_users.joins(\n            \"LEFT JOIN group_users gu ON gu.user_id = topic_allowed_users.user_id AND #{DB.sql_fragment(\"gu.group_id IN (?)\", my_group_ids)}\",\n          ).where(\"gu.group_id IS NULL\")\n      end\n\n      target_user_ids =\n        target_users.where(\"NOT topic_allowed_users.user_id = ?\", @user.id).pluck(:user_id)\n\n      {\n        topic: topic,\n        my_group_ids: my_group_ids,\n        target_group_ids: target_group_ids,\n        target_user_ids: target_user_ids,\n      }\n    end\n  end\n\n  def list_related_for(topic, pm_params: nil)\n    return if !topic.private_message?\n    return if @user.blank?\n\n    return if !@user.in_any_groups?(SiteSetting.personal_message_enabled_groups_map)\n\n    builder = SuggestedTopicsBuilder.new(topic)\n    pm_params = pm_params || get_pm_params(topic)\n\n    if pm_params[:my_group_ids].present?\n      builder.add_results(\n        related_messages_group(\n          pm_params.merge(\n            count: [6, builder.results_left].max,\n            exclude: builder.excluded_topic_ids,\n          ),\n        ),\n      )\n    else\n      builder.add_results(\n        related_messages_user(\n          pm_params.merge(\n            count: [6, builder.results_left].max,\n            exclude: builder.excluded_topic_ids,\n          ),\n        ),\n      )\n    end\n\n    params = { unordered: true }\n    params[:preload_posters] = true\n    create_list(:suggested, params, builder.results)\n  end\n\n  # Return a list of suggested topics for a topic\n  def list_suggested_for(topic, pm_params: nil)\n    # Don't suggest messages unless we have a user, and private messages are\n    # enabled.\n    if topic.private_message? &&\n         (@user.blank? || !@user.in_any_groups?(SiteSetting.personal_message_enabled_groups_map))\n      return\n    end\n\n    builder = SuggestedTopicsBuilder.new(topic)\n\n    pm_params = pm_params || get_pm_params(topic)\n\n    # When logged in we start with different results\n    if @user\n      if topic.private_message?\n        unless builder.full?\n          builder.add_results(new_messages(pm_params.merge(count: builder.results_left)))\n        end\n\n        unless builder.full?\n          builder.add_results(unread_messages(pm_params.merge(count: builder.results_left)))\n        end\n      else\n        builder.add_results(\n          unread_results(\n            topic: topic,\n            per_page: builder.results_left,\n            max_age: SiteSetting.suggested_topics_unread_max_days_old,\n          ),\n          :high,\n        )\n\n        unless builder.full?\n          builder.add_results(new_results(topic: topic, per_page: builder.category_results_left))\n        end\n      end\n    end\n\n    if !topic.private_message?\n      unless builder.full?\n        builder.add_results(\n          random_suggested(topic, builder.results_left, builder.excluded_topic_ids),\n        )\n      end\n    end\n\n    params = { unordered: true }\n    params[:preload_posters] = true if topic.private_message?\n    create_list(:suggested, params, builder.results)\n  end\n\n  # The latest view of topics\n  def list_latest\n    create_list(:latest, {}, latest_results)\n  end\n\n  def list_read\n    create_list(:read, unordered: true) do |topics|\n      topics.where(\"tu.last_visited_at IS NOT NULL\").order(\"tu.last_visited_at DESC\")\n    end\n  end\n\n  def list_new\n    create_list(:new, { unordered: true }, new_results)\n  end\n\n  def list_unread\n    create_list(:unread, { unordered: true }, unread_results)\n  end\n\n  def list_unseen\n    create_list(:unseen, { unordered: true }, unseen_results)\n  end\n\n  def list_posted\n    create_list(:posted) { |l| l.where(\"tu.posted\") }\n  end\n\n  def list_bookmarks\n    create_list(:bookmarks) { |l| l.where(\"tu.bookmarked\") }\n  end\n\n  def list_top_for(period)\n    score_column = TopTopic.score_column_for_period(period)\n    create_list(:top, unordered: true) do |topics|\n      topics = remove_muted_categories(topics, @user)\n      topics = topics.joins(:top_topic).where(\"top_topics.#{score_column} > 0\")\n      if period == :yearly && @user.try(:trust_level) == TrustLevel[0]\n        topics.order(<<~SQL)\n          CASE WHEN (\n             COALESCE(topics.pinned_at, '1900-01-01') > COALESCE(tu.cleared_pinned_at, '1900-01-01')\n          ) THEN 0 ELSE 1 END,\n          top_topics.#{score_column} DESC,\n          topics.bumped_at DESC\n        SQL\n      else\n        topics.order(<<~SQL)\n          COALESCE(top_topics.#{score_column}, 0) DESC, topics.bumped_at DESC\n        SQL\n      end\n    end\n  end\n\n  def list_topics_by(user)\n    @options[:filtered_to_user] = user.id\n    create_list(:user_topics) { |topics| topics.where(user_id: user.id) }\n  end\n\n  def list_group_topics(group)\n    list =\n      default_results.where(\n        \"\n      topics.user_id IN (\n        SELECT user_id FROM group_users gu WHERE gu.group_id = ?\n      )\n    \",\n        group.id.to_i,\n      )\n\n    create_list(:group_topics, {}, list)\n  end\n\n  def list_category_topic_ids(category)\n    query = default_results(category: category.id)\n    pinned_ids =\n      query\n        .where(\"topics.pinned_at IS NOT NULL AND topics.category_id = ?\", category.id)\n        .limit(nil)\n        .order(\"pinned_at DESC\")\n        .pluck(:id)\n    non_pinned_ids =\n      query.where(\"topics.pinned_at IS NULL OR topics.category_id <> ?\", category.id).pluck(:id)\n    (pinned_ids + non_pinned_ids)\n  end\n\n  def list_new_in_category(category)\n    create_list(:new_in_category, unordered: true, category: category.id) do |list|\n      list.by_newest.first(25)\n    end\n  end\n\n  def self.new_filter(list, treat_as_new_topic_start_date: nil, treat_as_new_topic_clause_sql: nil)\n    if treat_as_new_topic_start_date\n      list =\n        list.where(\"topics.created_at >= :created_at\", created_at: treat_as_new_topic_start_date)\n    else\n      list = list.where(\"topics.created_at >= #{treat_as_new_topic_clause_sql}\")\n    end\n\n    list.where(\"tu.last_read_post_number IS NULL\").where(\n      \"COALESCE(tu.notification_level, :tracking) >= :tracking\",\n      tracking: TopicUser.notification_levels[:tracking],\n    )\n  end\n\n  def self.unread_filter(list, whisperer: false)\n    col_name = whisperer ? \"highest_staff_post_number\" : \"highest_post_number\"\n\n    list.where(\"tu.last_read_post_number < topics.#{col_name}\").where(\n      \"COALESCE(tu.notification_level, :regular) >= :tracking\",\n      regular: TopicUser.notification_levels[:regular],\n      tracking: TopicUser.notification_levels[:tracking],\n    )\n  end\n\n  # Any changes here will need to be reflected in `lib/topic-list-tracked-filter.js` for the `isTrackedTopic` function on\n  # the client side. The `f=tracked` query param is not heavily used so we do not want to be querying for a topic's\n  # tracked status by default. Instead, the client will handle the filtering when the `f=tracked` query params is present.\n  def self.tracked_filter(list, user_id)\n    tracked_category_ids_sql = <<~SQL\n    SELECT cd.category_id FROM category_users cd\n    WHERE cd.user_id = :user_id AND cd.notification_level >= :tracking\n    SQL\n\n    has_sub_sub_categories = SiteSetting.max_category_nesting == 3\n\n    sql = +<<~SQL\n      topics.category_id IN (\n        SELECT\n          c.id\n        FROM categories c\n        #{has_sub_sub_categories ? \"LEFT JOIN categories parent_categories ON parent_categories.id = c.parent_category_id\" : \"\"}\n        WHERE (c.id IN (#{tracked_category_ids_sql}))\n        OR c.parent_category_id IN (#{tracked_category_ids_sql})\n        #{has_sub_sub_categories ? \"OR (parent_categories.id IS NOT NULL AND parent_categories.parent_category_id IN (#{tracked_category_ids_sql}))\" : \"\"}\n      )\n    SQL\n\n    sql << <<~SQL if SiteSetting.tagging_enabled\n        OR topics.id IN (\n          SELECT tt.topic_id FROM topic_tags tt WHERE tt.tag_id IN (\n            SELECT tu.tag_id\n            FROM tag_users tu\n            WHERE tu.user_id = :user_id AND tu.notification_level >= :tracking\n          )\n        )\n      SQL\n\n    list.where(sql, user_id: user_id, tracking: NotificationLevels.all[:tracking])\n  end\n\n  def prioritize_pinned_topics(topics, options)\n    pinned_clause =\n      if options[:category_id]\n        +\"topics.category_id = #{options[:category_id].to_i} AND\"\n      else\n        +\"pinned_globally AND \"\n      end\n\n    pinned_clause << \" pinned_at IS NOT NULL \"\n\n    if @user\n      pinned_clause << \" AND (topics.pinned_at > tu.cleared_pinned_at OR tu.cleared_pinned_at IS NULL)\"\n    end\n\n    unpinned_topics = topics.where(\"NOT ( #{pinned_clause} )\")\n    pinned_topics = topics.dup.offset(nil).where(pinned_clause).reorder(pinned_at: :desc)\n\n    per_page = options[:per_page] || per_page_setting\n    limit = per_page unless options[:limit] == false\n    page = options[:page].to_i\n\n    if page == 0\n      (pinned_topics + unpinned_topics)[0...limit] if limit\n    else\n      offset = (page * per_page) - pinned_topics.length\n      offset = 0 unless offset > 0\n      unpinned_topics.offset(offset).to_a\n    end\n  end\n\n  def create_list(filter, options = {}, topics = nil)\n    options[:filter] ||= filter\n    topics ||= default_results(options)\n    topics = yield(topics) if block_given?\n\n    options = options.merge(@options)\n    if %w[activity default].include?(options[:order] || \"activity\") && !options[:unordered] &&\n         filter != :private_messages\n      topics = prioritize_pinned_topics(topics, options)\n    end\n\n    topics = topics.to_a\n\n    if options[:preload_posters]\n      user_ids = []\n      topics.each do |ft|\n        user_ids << ft.user_id << ft.last_post_user_id << ft.featured_user_ids << ft.allowed_user_ids\n      end\n\n      user_lookup = UserLookup.new(user_ids)\n\n      # memoize for loop so we don't keep looking these up\n      translations = TopicPostersSummary.translations\n\n      topics.each do |t|\n        t.posters = t.posters_summary(user_lookup: user_lookup, translations: translations)\n      end\n    end\n\n    topics.each do |t|\n      t.allowed_user_ids = filter == :private_messages ? t.allowed_users.map { |u| u.id } : []\n    end\n\n    list = TopicList.new(filter, @user, topics, options.merge(@options))\n    list.per_page = options[:per_page] || per_page_setting\n    list\n  end\n\n  def latest_results(options = {})\n    result = default_results(options)\n    result = remove_muted(result, @user, options)\n    result = apply_shared_drafts(result, get_category_id(options[:category]), options)\n\n    # plugins can remove topics here:\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:latest, result, @user, options)\n    end\n\n    result\n  end\n\n  def unseen_results(options = {})\n    result = default_results(options)\n    result = unseen_filter(result, @user.first_seen_at, @user.whisperer?) if @user\n    result = remove_muted(result, @user, options)\n    result = apply_shared_drafts(result, get_category_id(options[:category]), options)\n\n    # plugins can remove topics here:\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:latest, result, @user, options)\n    end\n\n    result\n  end\n\n  def unread_results(options = {})\n    result =\n      TopicQuery.unread_filter(\n        default_results(options.reverse_merge(unordered: true)),\n        whisperer: @user&.whisperer?,\n      ).order(\"CASE WHEN topics.user_id = tu.user_id THEN 1 ELSE 2 END\")\n\n    if @user\n      # micro optimisation so we don't load up all of user stats which we do not need\n      unread_at =\n        DB.query_single(\"select first_unread_at from user_stats where user_id = ?\", @user.id).first\n\n      if max_age = options[:max_age]\n        max_age_date = max_age.days.ago\n        unread_at ||= max_age_date\n        unread_at = unread_at > max_age_date ? unread_at : max_age_date\n      end\n\n      # perf note, in the past we tried doing this in a subquery but performance was\n      # terrible, also tried with a join and it was bad\n      result = result.where(\"topics.updated_at >= ?\", unread_at)\n    end\n\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:unread, result, @user, options)\n    end\n\n    suggested_ordering(result, options)\n  end\n\n  def new_results(options = {})\n    # TODO does this make sense or should it be ordered on created_at\n    #  it is ordering on bumped_at now\n    result =\n      TopicQuery.new_filter(\n        default_results(options.reverse_merge(unordered: true)),\n        treat_as_new_topic_start_date: @user.user_option.treat_as_new_topic_start_date,\n      )\n    result = remove_muted(result, @user, options)\n    result = remove_dismissed(result, @user)\n\n    self.class.results_filter_callbacks.each do |filter_callback|\n      result = filter_callback.call(:new, result, @user, options)\n    end\n\n    suggested_ordering(result, options)\n  end\n\n  protected\n\n  def per_page_setting\n    DEFAULT_PER_PAGE_COUNT\n  end\n\n  def apply_shared_drafts(result, category_id, options)\n    # PERF: avoid any penalty if there are no shared drafts enabled\n    # on some sites the cost can be high eg: gearbox\n    return result if SiteSetting.shared_drafts_category == \"\"\n\n    drafts_category_id = SiteSetting.shared_drafts_category.to_i\n    viewing_shared = category_id && category_id == drafts_category_id\n\n    if guardian.can_see_shared_draft?\n      if options[:destination_category_id]\n        destination_category_id = get_category_id(options[:destination_category_id])\n        topic_ids = SharedDraft.where(category_id: destination_category_id).pluck(:topic_id)\n\n        return result.where(id: topic_ids)\n      end\n\n      return result.includes(:shared_draft).references(:shared_draft) if viewing_shared\n    elsif viewing_shared\n      return(\n        result.joins(\"LEFT OUTER JOIN shared_drafts sd ON sd.topic_id = topics.id\").where(\n          \"sd.id IS NULL\",\n        )\n      )\n    end\n\n    result.where(\"topics.category_id != ?\", drafts_category_id)\n  end\n\n  def apply_ordering(result, options)\n    sort_column = SORTABLE_MAPPING[options[:order]] || \"default\"\n    sort_dir = (options[:ascending] == \"true\") ? \"ASC\" : \"DESC\"\n\n    # If we are sorting in the default order desc, we should consider including pinned\n    # topics. Otherwise, just use bumped_at.\n    if sort_column == \"default\"\n      if sort_dir == \"DESC\"\n        # If something requires a custom order, for example \"unread\" which sorts the least read\n        # to the top, do nothing\n        return result if options[:unordered]\n      end\n      sort_column = \"bumped_at\"\n    end\n\n    # If we are sorting by category, actually use the name\n    if sort_column == \"category_id\"\n      # TODO forces a table scan, slow\n      return result.references(:categories).order(<<~SQL)\n        CASE WHEN categories.id = #{SiteSetting.uncategorized_category_id.to_i} THEN '' ELSE categories.name END #{sort_dir}\n      SQL\n    end\n\n    if sort_column == \"op_likes\"\n      return(\n        result.includes(:first_post).order(\n          \"(SELECT like_count FROM posts p3 WHERE p3.topic_id = topics.id AND p3.post_number = 1) #{sort_dir}\",\n        )\n      )\n    end\n\n    if sort_column.start_with?(\"custom_fields\")\n      field = sort_column.split(\".\")[1]\n      return(\n        result.order(\n          \"(SELECT CASE WHEN EXISTS (SELECT true FROM topic_custom_fields tcf WHERE tcf.topic_id::integer = topics.id::integer AND tcf.name = '#{field}') THEN (SELECT value::integer FROM topic_custom_fields tcf WHERE tcf.topic_id::integer = topics.id::integer AND tcf.name = '#{field}') ELSE 0 END) #{sort_dir}\",\n        )\n      )\n    end\n\n    result.order(\"topics.#{sort_column} #{sort_dir}\")\n  end\n\n  def get_category_id(category_id_or_slug)\n    return nil unless category_id_or_slug.present?\n    category_id = category_id_or_slug.to_i\n\n    if category_id == 0\n      category_id =\n        Category.where(slug: category_id_or_slug, parent_category_id: nil).pluck_first(:id)\n    end\n\n    category_id\n  end\n\n  # Create results based on a bunch of default options\n  def default_results(options = {})\n    options.reverse_merge!(@options)\n    options.reverse_merge!(per_page: per_page_setting) unless options[:limit] == false\n\n    # Whether to include unlisted (visible = false) topics\n    viewing_own_topics = @user && @user.id == options[:filtered_to_user]\n\n    if options[:visible].nil?\n      options[:visible] = true if @user.nil? || @user.regular?\n      options[:visible] = false if @guardian.can_see_unlisted_topics? || viewing_own_topics\n    end\n\n    # Start with a list of all topics\n    result = Topic.unscoped.includes(:category)\n\n    if @user\n      result =\n        result.joins(\n          \"LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i})\",\n        ).references(\"tu\")\n    end\n\n    category_id = get_category_id(options[:category])\n    @options[:category_id] = category_id\n    if category_id\n      if options[:no_subcategories]\n        result = result.where(\"topics.category_id = ?\", category_id)\n      else\n        result = result.where(\"topics.category_id IN (?)\", Category.subcategory_ids(category_id))\n        if !SiteSetting.show_category_definitions_in_topic_lists\n          result =\n            result.where(\"categories.topic_id <> topics.id OR topics.category_id = ?\", category_id)\n        end\n      end\n      result = result.references(:categories)\n\n      if !@options[:order]\n        filter = (options[:filter] || options[:f])\n        # category default sort order\n        sort_order, sort_ascending =\n          Category.where(id: category_id).pluck_first(:sort_order, :sort_ascending)\n        if sort_order && (filter.blank? || %i[latest unseen].include?(filter))\n          options[:order] = sort_order\n          options[:ascending] = !!sort_ascending ? \"true\" : \"false\"\n        else\n          options[:order] = \"default\"\n          options[:ascending] = \"false\"\n        end\n      end\n    end\n\n    if SiteSetting.tagging_enabled\n      result = result.preload(:tags)\n\n      tags_arg = @options[:tags]\n\n      if tags_arg && tags_arg.size > 0\n        tags_arg = tags_arg.split if String === tags_arg\n\n        tags_arg =\n          tags_arg.map do |t|\n            if String === t\n              t.downcase\n            else\n              t\n            end\n          end\n\n        tags_query = tags_arg[0].is_a?(String) ? Tag.where_name(tags_arg) : Tag.where(id: tags_arg)\n        tags = tags_query.select(:id, :target_tag_id).map { |t| t.target_tag_id || t.id }.uniq\n\n        if ActiveModel::Type::Boolean.new.cast(@options[:match_all_tags])\n          # ALL of the given tags:\n          if tags_arg.length == tags.length\n            tags.each_with_index do |tag, index|\n              sql_alias = [\"t\", index].join\n              result =\n                result.joins(\n                  \"INNER JOIN topic_tags #{sql_alias} ON #{sql_alias}.topic_id = topics.id AND #{sql_alias}.tag_id = #{tag}\",\n                )\n            end\n          else\n            result = result.none # don't return any results unless all tags exist in the database\n          end\n        else\n          # ANY of the given tags:\n          result = result.joins(:tags).where(\"tags.id in (?)\", tags)\n        end\n\n        # TODO: this is very side-effecty and should be changed\n        # It is done cause further up we expect normalized tags\n        @options[:tags] = tags\n      elsif @options[:no_tags]\n        # the following will do: (\"topics\".\"id\" NOT IN (SELECT DISTINCT \"topic_tags\".\"topic_id\" FROM \"topic_tags\"))\n        result = result.where.not(id: TopicTag.distinct.pluck(:topic_id))\n      end\n\n      if @options[:exclude_tag].present? &&\n           !DiscourseTagging.hidden_tag_names(@guardian).include?(@options[:exclude_tag])\n        result = result.where(<<~SQL, name: @options[:exclude_tag])\n          topics.id NOT IN (\n            SELECT topic_tags.topic_id\n            FROM topic_tags\n            INNER JOIN tags ON tags.id = topic_tags.tag_id\n            WHERE tags.name = :name\n          )\n          SQL\n      end\n    end\n\n    result = apply_ordering(result, options)\n\n    all_listable_topics = @guardian.filter_allowed_categories(Topic.unscoped.listable_topics)\n\n    if options[:include_pms] || options[:include_all_pms]\n      all_pm_topics =\n        if options[:include_all_pms] && @guardian.is_admin?\n          Topic.unscoped.private_messages\n        else\n          Topic.unscoped.private_messages_for_user(@user)\n        end\n      result = result.merge(all_listable_topics.or(all_pm_topics))\n    else\n      result = result.merge(all_listable_topics)\n    end\n\n    # Don't include the category topics if excluded\n    if options[:no_definitions]\n      result = result.where(\"COALESCE(categories.topic_id, 0) <> topics.id\")\n    end\n\n    result = result.limit(options[:per_page]) unless options[:limit] == false\n    result = result.visible if options[:visible]\n    result =\n      result.where.not(topics: { id: options[:except_topic_ids] }).references(:topics) if options[\n      :except_topic_ids\n    ]\n\n    if options[:page]\n      offset = options[:page].to_i * options[:per_page]\n      result = result.offset(offset) if offset > 0\n    end\n\n    if options[:topic_ids]\n      result = result.where(\"topics.id in (?)\", options[:topic_ids]).references(:topics)\n    end\n\n    if search = options[:search].presence\n      result =\n        result.where(\n          \"topics.id in (select pp.topic_id from post_search_data pd join posts pp on pp.id = pd.post_id where pd.search_data @@ #{Search.ts_query(term: search.to_s)})\",\n        )\n    end\n\n    # NOTE protect against SYM attack can be removed with Ruby 2.2\n    #\n    state = options[:state]\n    if @user && state && TopicUser.notification_levels.keys.map(&:to_s).include?(state)\n      level = TopicUser.notification_levels[state.to_sym]\n      result =\n        result.where(\n          \"topics.id IN (\n                                SELECT topic_id\n                                FROM topic_users\n                                WHERE user_id = ? AND\n                                      notification_level = ?)\",\n          @user.id,\n          level,\n        )\n    end\n\n    require_deleted_clause = true\n\n    if before = options[:before]\n      if (before = before.to_i) > 0\n        result = result.where(\"topics.created_at < ?\", before.to_i.days.ago)\n      end\n    end\n\n    if bumped_before = options[:bumped_before]\n      if (bumped_before = bumped_before.to_i) > 0\n        result = result.where(\"topics.bumped_at < ?\", bumped_before.to_i.days.ago)\n      end\n    end\n\n    if status = options[:status]\n      case status\n      when \"open\"\n        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n      when \"closed\"\n        result = result.where(\"topics.closed\")\n      when \"archived\"\n        result = result.where(\"topics.archived\")\n      when \"listed\"\n        result = result.where(\"topics.visible\")\n      when \"unlisted\"\n        result = result.where(\"NOT topics.visible\")\n      when \"deleted\"\n        category = Category.find_by(id: options[:category])\n        if @guardian.can_see_deleted_topics?(category)\n          result = result.where(\"topics.deleted_at IS NOT NULL\")\n          require_deleted_clause = false\n        end\n      end\n    end\n\n    if (filter = (options[:filter] || options[:f])) && @user\n      action = (PostActionType.types[:like] if filter == \"liked\")\n      if action\n        result =\n          result.where(\n            \"topics.id IN (SELECT pp.topic_id\n                              FROM post_actions pa\n                              JOIN posts pp ON pp.id = pa.post_id\n                              WHERE pa.user_id = :user_id AND\n                                    pa.post_action_type_id = :action AND\n                                    pa.deleted_at IS NULL\n                           )\",\n            user_id: @user.id,\n            action: action,\n          )\n      end\n\n      result = TopicQuery.tracked_filter(result, @user.id) if filter == \"tracked\"\n    end\n\n    result = result.where(\"topics.deleted_at IS NULL\") if require_deleted_clause\n    result = result.where(\"topics.posts_count <= ?\", options[:max_posts]) if options[\n      :max_posts\n    ].present?\n    result = result.where(\"topics.posts_count >= ?\", options[:min_posts]) if options[\n      :min_posts\n    ].present?\n\n    result = TopicQuery.apply_custom_filters(result, self)\n\n    result\n  end\n\n  def remove_muted(list, user, options)\n    list = remove_muted_topics(list, user) unless options && options[:state] == \"muted\"\n    list = remove_muted_categories(list, user, exclude: options[:category])\n    TopicQuery.remove_muted_tags(list, user, options)\n  end\n\n  def remove_muted_topics(list, user)\n    if user\n      list =\n        list.where(\n          \"COALESCE(tu.notification_level,1) > :muted\",\n          muted: TopicUser.notification_levels[:muted],\n        )\n    end\n\n    list\n  end\n\n  def remove_muted_categories(list, user, opts = nil)\n    category_id = get_category_id(opts[:exclude]) if opts\n\n    if user\n      list =\n        list\n          .references(\"cu\")\n          .joins(\n            \"LEFT JOIN category_users ON category_users.category_id = topics.category_id AND category_users.user_id = #{user.id}\",\n          )\n          .where(\n            \"topics.category_id = :category_id\n                OR\n                (COALESCE(category_users.notification_level, :default) <> :muted AND (topics.category_id IS NULL OR topics.category_id NOT IN(:indirectly_muted_category_ids)))\n                OR tu.notification_level > :regular\",\n            category_id: category_id || -1,\n            default: CategoryUser.default_notification_level,\n            indirectly_muted_category_ids:\n              CategoryUser.indirectly_muted_category_ids(user).presence || [-1],\n            muted: CategoryUser.notification_levels[:muted],\n            regular: TopicUser.notification_levels[:regular],\n          )\n    elsif SiteSetting.mute_all_categories_by_default\n      category_ids = [\n        SiteSetting.default_categories_watching.split(\"|\"),\n        SiteSetting.default_categories_tracking.split(\"|\"),\n        SiteSetting.default_categories_watching_first_post.split(\"|\"),\n        SiteSetting.default_categories_normal.split(\"|\"),\n      ].flatten.map(&:to_i)\n      category_ids << category_id if category_id.present? && category_ids.exclude?(category_id)\n\n      list = list.where(\"topics.category_id IN (?)\", category_ids) if category_ids.present?\n    else\n      category_ids = SiteSetting.default_categories_muted.split(\"|\").map(&:to_i)\n      category_ids -= [category_id] if category_id.present? && category_ids.include?(category_id)\n\n      list = list.where(\"topics.category_id NOT IN (?)\", category_ids) if category_ids.present?\n    end\n\n    list\n  end\n\n  def self.remove_muted_tags(list, user, opts = {})\n    if !SiteSetting.tagging_enabled || SiteSetting.remove_muted_tags_from_latest == \"never\"\n      return list\n    end\n\n    muted_tag_ids = []\n\n    if user.present?\n      muted_tag_ids = TagUser.lookup(user, :muted).pluck(:tag_id)\n    else\n      muted_tag_names = SiteSetting.default_tags_muted.split(\"|\")\n\n      muted_tag_ids = Tag.where(name: muted_tag_names).pluck(:id) if muted_tag_names.present?\n    end\n\n    return list if muted_tag_ids.blank?\n\n    # if viewing the topic list for a muted tag, show all the topics\n    if !opts[:no_tags] && opts[:tags].present?\n      if TagUser\n           .lookup(user, :muted)\n           .joins(:tag)\n           .where(\"lower(tags.name) = ?\", opts[:tags].first.downcase)\n           .exists?\n        return list\n      end\n    end\n\n    if SiteSetting.remove_muted_tags_from_latest == \"always\"\n      list =\n        list.where(\n          \"\n        NOT EXISTS(\n          SELECT 1\n            FROM topic_tags tt\n           WHERE tt.tag_id IN (:tag_ids)\n             AND tt.topic_id = topics.id)\",\n          tag_ids: muted_tag_ids,\n        )\n    else\n      list =\n        list.where(\n          \"\n        EXISTS (\n          SELECT 1\n            FROM topic_tags tt\n           WHERE tt.tag_id NOT IN (:tag_ids)\n             AND tt.topic_id = topics.id\n        ) OR NOT EXISTS (SELECT 1 FROM topic_tags tt WHERE tt.topic_id = topics.id)\",\n          tag_ids: muted_tag_ids,\n        )\n    end\n  end\n\n  def remove_dismissed(list, user)\n    if user\n      list.joins(<<~SQL).where(\"dismissed_topic_users.id IS NULL\")\n        LEFT JOIN dismissed_topic_users\n        ON dismissed_topic_users.topic_id = topics.id\n        AND dismissed_topic_users.user_id = #{user.id.to_i}\n        SQL\n    else\n      list\n    end\n  end\n\n  def new_messages(params)\n    TopicQuery.new_filter(\n      messages_for_groups_or_user(params[:my_group_ids]),\n      treat_as_new_topic_start_date: Time.at(SiteSetting.min_new_topics_time).to_datetime,\n    ).limit(params[:count])\n  end\n\n  def unread_messages(params)\n    query =\n      TopicQuery.unread_filter(\n        messages_for_groups_or_user(params[:my_group_ids]),\n        whisperer: @user.whisperer?,\n      )\n\n    first_unread_pm_at =\n      if params[:my_group_ids].present?\n        GroupUser.where(user_id: @user.id, group_id: params[:my_group_ids]).minimum(\n          :first_unread_pm_at,\n        )\n      else\n        UserStat.where(user_id: @user.id).pluck_first(:first_unread_pm_at)\n      end\n\n    query = query.where(\"topics.updated_at >= ?\", first_unread_pm_at) if first_unread_pm_at\n    query = query.limit(params[:count]) if params[:count]\n    query\n  end\n\n  def related_messages_user(params)\n    messages = messages_for_user.limit(params[:count])\n    messages = allowed_messages(messages, params)\n  end\n\n  def related_messages_group(params)\n    messages = messages_for_groups_or_user(params[:my_group_ids]).limit(params[:count])\n    messages = allowed_messages(messages, params)\n  end\n\n  def allowed_messages(messages, params)\n    user_ids = (params[:target_user_ids] || [])\n    group_ids = ((params[:target_group_ids] - params[:my_group_ids]) || [])\n\n    if user_ids.present?\n      messages =\n        messages.joins(\n          \"\n          LEFT JOIN topic_allowed_users ta2\n          ON topics.id = ta2.topic_id\n          AND #{DB.sql_fragment(\"ta2.user_id IN (?)\", user_ids)}\n        \",\n        )\n    end\n\n    if group_ids.present?\n      messages =\n        messages.joins(\n          \"\n          LEFT JOIN topic_allowed_groups tg2\n          ON topics.id = tg2.topic_id\n          AND #{DB.sql_fragment(\"tg2.group_id IN (?)\", group_ids)}\n        \",\n        )\n    end\n\n    messages =\n      if user_ids.present? && group_ids.present?\n        messages.where(\"ta2.topic_id IS NOT NULL OR tg2.topic_id IS NOT NULL\")\n      elsif user_ids.present?\n        messages.where(\"ta2.topic_id IS NOT NULL\")\n      elsif group_ids.present?\n        messages.where(\"tg2.topic_id IS NOT NULL\")\n      end\n  end\n\n  def messages_for_groups_or_user(group_ids)\n    if group_ids.present?\n      base_messages.joins(\n        \"\n          LEFT JOIN (\n            SELECT * FROM topic_allowed_groups _tg\n            LEFT JOIN group_users gu\n            ON gu.user_id = #{@user.id.to_i}\n            AND gu.group_id = _tg.group_id\n            WHERE #{DB.sql_fragment(\"gu.group_id IN (?)\", group_ids)}\n          ) tg ON topics.id = tg.topic_id\n        \",\n      ).where(\"tg.topic_id IS NOT NULL\")\n    else\n      messages_for_user\n    end\n  end\n\n  def messages_for_user\n    base_messages.joins(\n      \"\n        LEFT JOIN topic_allowed_users ta\n        ON topics.id = ta.topic_id\n        AND ta.user_id = #{@user.id.to_i}\n      \",\n    ).where(\"ta.topic_id IS NOT NULL\")\n  end\n\n  def base_messages\n    query =\n      Topic.where(\"topics.archetype = ?\", Archetype.private_message).joins(\n        \"LEFT JOIN topic_users tu ON topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i}\",\n      )\n\n    query = query.includes(:tags) if SiteSetting.tagging_enabled\n    query.order(\"topics.bumped_at DESC\")\n  end\n\n  def random_suggested(topic, count, excluded_topic_ids = [])\n    result = default_results(unordered: true, per_page: count).where(closed: false, archived: false)\n\n    if SiteSetting.limit_suggested_to_category\n      excluded_topic_ids += Category.where(id: topic.category_id).pluck(:id)\n    else\n      excluded_topic_ids += Category.topic_ids.to_a\n    end\n    result =\n      result.where(\"topics.id NOT IN (?)\", excluded_topic_ids) unless excluded_topic_ids.empty?\n\n    result = remove_muted_categories(result, @user)\n    result = remove_muted_topics(result, @user)\n\n    # If we are in a category, prefer it for the random results\n    if topic.category_id\n      result =\n        result.order(\"CASE WHEN topics.category_id = #{topic.category_id.to_i} THEN 0 ELSE 1 END\")\n    end\n\n    # Best effort, it over selects, however if you have a high number\n    # of muted categories there is tiny chance we will not select enough\n    # in particular this can happen if current category is empty and tons\n    # of muted, big edge case\n    #\n    # we over select in case cache is stale\n    max = (count * 1.3).to_i\n    ids = SiteSetting.limit_suggested_to_category ? [] : RandomTopicSelector.next(max)\n    ids.concat(RandomTopicSelector.next(max, topic.category))\n\n    result.where(id: ids.uniq)\n  end\n\n  def suggested_ordering(result, options)\n    # Prefer unread in the same category\n    if options[:topic] && options[:topic].category_id\n      result =\n        result.order(\n          \"CASE WHEN topics.category_id = #{options[:topic].category_id.to_i} THEN 0 ELSE 1 END\",\n        )\n    end\n\n    result.order(\"topics.bumped_at DESC\")\n  end\n\n  private\n\n  def unseen_filter(list, user_first_seen_at, whisperer)\n    list = list.where(\"topics.bumped_at >= ?\", user_first_seen_at)\n\n    col_name = whisperer ? \"highest_staff_post_number\" : \"highest_post_number\"\n    list.where(\"tu.last_read_post_number IS NULL OR tu.last_read_post_number < topics.#{col_name}\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"topic_view\"\n\nRSpec.describe TopicQuery do\n  # TODO:\n  #   This fab! here has impact on all tests.\n  #\n  #   It happens first, but is not obvious later in the tests that we depend on\n  #   the user being created so early otherwise finding new topics does not\n  #   work.\n  #\n  #   We should use be more explicit in communicating how the clock moves\n  fab!(:user) { Fabricate(:user) }\n\n  fab!(:creator) { Fabricate(:user) }\n  let(:topic_query) { TopicQuery.new(user) }\n\n  fab!(:tl4_user) { Fabricate(:trust_level_4) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:admin) { Fabricate(:admin) }\n\n  describe \"secure category\" do\n    it \"filters categories out correctly\" do\n      category = Fabricate(:category_with_definition)\n      group = Fabricate(:group)\n      category.set_permissions(group => :full)\n      category.save\n\n      Fabricate(:topic, category: category)\n      Fabricate(:topic, visible: false)\n\n      expect(TopicQuery.new(nil).list_latest.topics.count).to eq(0)\n      expect(TopicQuery.new(user).list_latest.topics.count).to eq(0)\n\n      expect(Topic.top_viewed(10).count).to eq(0)\n      expect(Topic.recent(10).count).to eq(0)\n\n      # mods can see hidden topics\n      expect(TopicQuery.new(moderator).list_latest.topics.count).to eq(1)\n      # admins can see all the topics\n      expect(TopicQuery.new(admin).list_latest.topics.count).to eq(3)\n\n      group.add(user)\n      group.save\n\n      expect(TopicQuery.new(user).list_latest.topics.count).to eq(2)\n    end\n  end\n\n  describe \"custom filters\" do\n    it \"allows custom filters to be applied\" do\n      topic1 = Fabricate(:topic)\n      _topic2 = Fabricate(:topic)\n\n      TopicQuery.add_custom_filter(:only_topic_id) do |results, topic_query|\n        results = results.where(\"topics.id = ?\", topic_query.options[:only_topic_id])\n      end\n\n      expect(TopicQuery.new(nil, only_topic_id: topic1.id).list_latest.topics.map(&:id)).to eq(\n        [topic1.id],\n      )\n\n      TopicQuery.remove_custom_filter(:only_topic_id)\n    end\n  end\n\n  describe \"#list_topics_by\" do\n    it \"allows users to view their own invisible topics\" do\n      _topic = Fabricate(:topic, user: user)\n      _invisible_topic = Fabricate(:topic, user: user, visible: false)\n\n      expect(TopicQuery.new(nil).list_topics_by(user).topics.count).to eq(1)\n      expect(TopicQuery.new(user).list_topics_by(user).topics.count).to eq(2)\n    end\n  end\n\n  describe \"#prioritize_pinned_topics\" do\n    it \"does the pagination correctly\" do\n      num_topics = 15\n      per_page = 3\n\n      topics = []\n      (num_topics - 1)\n        .downto(0)\n        .each { |i| topics[i] = freeze_time(i.seconds.ago) { Fabricate(:topic) } }\n\n      topic_query = TopicQuery.new(user)\n      results = topic_query.send(:default_results)\n\n      expect(topic_query.prioritize_pinned_topics(results, per_page: per_page, page: 0)).to eq(\n        topics[0...per_page],\n      )\n\n      expect(topic_query.prioritize_pinned_topics(results, per_page: per_page, page: 1)).to eq(\n        topics[per_page...num_topics],\n      )\n    end\n\n    it \"orders globally pinned topics by pinned_at rather than bumped_at\" do\n      pinned1 =\n        Fabricate(\n          :topic,\n          bumped_at: 3.hour.ago,\n          pinned_at: 1.hours.ago,\n          pinned_until: 10.days.from_now,\n          pinned_globally: true,\n        )\n      pinned2 =\n        Fabricate(\n          :topic,\n          bumped_at: 2.hour.ago,\n          pinned_at: 4.hours.ago,\n          pinned_until: 10.days.from_now,\n          pinned_globally: true,\n        )\n      unpinned1 = Fabricate(:topic, bumped_at: 2.hour.ago)\n      unpinned2 = Fabricate(:topic, bumped_at: 3.hour.ago)\n\n      topic_query = TopicQuery.new(user)\n      results = topic_query.send(:default_results)\n\n      expected_order = [pinned1, pinned2, unpinned1, unpinned2].map(&:id)\n      expect(topic_query.prioritize_pinned_topics(results, per_page: 10, page: 0).pluck(:id)).to eq(\n        expected_order,\n      )\n    end\n\n    it \"orders pinned topics within a category by pinned_at rather than bumped_at\" do\n      cat = Fabricate(:category)\n      pinned1 =\n        Fabricate(\n          :topic,\n          category: cat,\n          bumped_at: 3.hour.ago,\n          pinned_at: 1.hours.ago,\n          pinned_until: 10.days.from_now,\n        )\n      pinned2 =\n        Fabricate(\n          :topic,\n          category: cat,\n          bumped_at: 2.hour.ago,\n          pinned_at: 4.hours.ago,\n          pinned_until: 10.days.from_now,\n        )\n      unpinned1 = Fabricate(:topic, category: cat, bumped_at: 2.hour.ago)\n      unpinned2 = Fabricate(:topic, category: cat, bumped_at: 3.hour.ago)\n\n      topic_query = TopicQuery.new(user)\n      results = topic_query.send(:default_results)\n\n      expected_order = [pinned1, pinned2, unpinned1, unpinned2].map(&:id)\n      expect(\n        topic_query.prioritize_pinned_topics(\n          results,\n          per_page: 10,\n          page: 0,\n          category_id: cat.id,\n        ).pluck(:id),\n      ).to eq(expected_order)\n    end\n  end\n\n  describe \"tracked\" do\n    it \"filters tracked topics correctly\" do\n      SiteSetting.tagging_enabled = true\n\n      tag = Fabricate(:tag)\n      topic = Fabricate(:topic, tags: [tag])\n      topic2 = Fabricate(:topic)\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n      expect(query.topics.length).to eq(0)\n\n      TagUser.create!(\n        tag_id: tag.id,\n        user_id: user.id,\n        notification_level: NotificationLevels.all[:watching],\n      )\n\n      cu =\n        CategoryUser.create!(\n          category_id: topic2.category_id,\n          user_id: user.id,\n          notification_level: NotificationLevels.all[:regular],\n        )\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(topic.id)\n\n      cu.update!(notification_level: NotificationLevels.all[:tracking])\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(topic.id, topic2.id)\n\n      # includes subcategories of tracked categories\n      parent_category = Fabricate(:category)\n      sub_category = Fabricate(:category, parent_category_id: parent_category.id)\n      topic3 = Fabricate(:topic, category_id: sub_category.id)\n\n      parent_category_2 = Fabricate(:category)\n      sub_category_2 = Fabricate(:category, parent_category: parent_category_2)\n      topic4 = Fabricate(:topic, category: sub_category_2)\n\n      CategoryUser.create!(\n        category_id: parent_category.id,\n        user_id: user.id,\n        notification_level: NotificationLevels.all[:tracking],\n      )\n\n      CategoryUser.create!(\n        category_id: sub_category_2.id,\n        user_id: user.id,\n        notification_level: NotificationLevels.all[:tracking],\n      )\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(topic.id, topic2.id, topic3.id, topic4.id)\n\n      # includes sub-subcategories of tracked categories\n      SiteSetting.max_category_nesting = 3\n      sub_sub_category = Fabricate(:category, parent_category_id: sub_category.id)\n      topic5 = Fabricate(:topic, category_id: sub_sub_category.id)\n\n      query = TopicQuery.new(user, filter: \"tracked\").list_latest\n\n      expect(query.topics.map(&:id)).to contain_exactly(\n        topic.id,\n        topic2.id,\n        topic3.id,\n        topic4.id,\n        topic5.id,\n      )\n    end\n  end\n\n  describe \"deleted filter\" do\n    it \"filters deleted topics correctly\" do\n      SiteSetting.enable_category_group_moderation = true\n      group_moderator = Fabricate(:user)\n      group = Fabricate(:group)\n      group.add(group_moderator)\n      category = Fabricate(:category, reviewable_by_group: group)\n      topic = Fabricate(:topic, category: category, deleted_at: 1.year.ago)\n\n      expect(TopicQuery.new(admin, status: \"deleted\").list_latest.topics.size).to eq(1)\n      expect(TopicQuery.new(moderator, status: \"deleted\").list_latest.topics.size).to eq(1)\n      expect(\n        TopicQuery\n          .new(group_moderator, status: \"deleted\", category: category.id)\n          .list_latest\n          .topics\n          .size,\n      ).to eq(1)\n      expect(TopicQuery.new(user, status: \"deleted\").list_latest.topics.size).to eq(0)\n      expect(TopicQuery.new(nil, status: \"deleted\").list_latest.topics.size).to eq(0)\n    end\n  end\n\n  describe \"include_pms option\" do\n    it \"includes users own pms in regular topic lists\" do\n      topic = Fabricate(:topic)\n      own_pm = Fabricate(:private_message_topic, user: user)\n      other_pm = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      expect(TopicQuery.new(user).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(admin).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(user, include_pms: true).list_latest.topics).to contain_exactly(\n        topic,\n        own_pm,\n      )\n    end\n  end\n\n  describe \"include_all_pms option\" do\n    it \"includes all pms in regular topic lists for admins\" do\n      topic = Fabricate(:topic)\n      own_pm = Fabricate(:private_message_topic, user: user)\n      other_pm = Fabricate(:private_message_topic, user: Fabricate(:user))\n\n      expect(TopicQuery.new(user).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(admin).list_latest.topics).to contain_exactly(topic)\n      expect(TopicQuery.new(user, include_all_pms: true).list_latest.topics).to contain_exactly(\n        topic,\n        own_pm,\n      )\n      expect(TopicQuery.new(admin, include_all_pms: true).list_latest.topics).to contain_exactly(\n        topic,\n        own_pm,\n        other_pm,\n      )\n    end\n  end\n\n  describe \"category filter\" do\n    let(:category) { Fabricate(:category_with_definition) }\n    let(:diff_category) { Fabricate(:category_with_definition, name: \"Different Category\") }\n\n    it \"returns topics in the category when we filter to it\" do\n      expect(TopicQuery.new(moderator).list_latest.topics.size).to eq(0)\n\n      # Filter by slug\n      expect(TopicQuery.new(moderator, category: category.slug).list_latest.topics.size).to eq(1)\n      expect(\n        TopicQuery.new(moderator, category: \"#{category.id}-category\").list_latest.topics.size,\n      ).to eq(1)\n\n      list = TopicQuery.new(moderator, category: diff_category.slug).list_latest\n      expect(list.topics.size).to eq(1)\n      expect(list.preload_key).to eq(\"topic_list\")\n\n      # Defaults to no category filter when slug does not exist\n      expect(TopicQuery.new(moderator, category: \"made up slug\").list_latest.topics.size).to eq(2)\n    end\n\n    context \"with subcategories\" do\n      let!(:subcategory) { Fabricate(:category_with_definition, parent_category_id: category.id) }\n      let(:subsubcategory) do\n        Fabricate(:category_with_definition, parent_category_id: subcategory.id)\n      end\n\n      # Not used in assertions but fabricated to ensure we're not leaking topics\n      # across categories\n      let!(:_category) { Fabricate(:category_with_definition) }\n      let!(:_subcategory) { Fabricate(:category_with_definition, parent_category_id: _category.id) }\n\n      it \"works with subcategories\" do\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(category.topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subcategory.id).list_latest.topics,\n        ).to contain_exactly(subcategory.topic)\n\n        expect(\n          TopicQuery\n            .new(moderator, category: category.id, no_subcategories: true)\n            .list_latest\n            .topics,\n        ).to contain_exactly(category.topic)\n      end\n\n      it \"shows a subcategory definition topic in its parent list with the right site setting\" do\n        SiteSetting.show_category_definitions_in_topic_lists = true\n\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(category.topic, subcategory.topic)\n      end\n\n      it \"works with subsubcategories\" do\n        SiteSetting.max_category_nesting = 3\n\n        category_topic = Fabricate(:topic, category: category)\n        subcategory_topic = Fabricate(:topic, category: subcategory)\n        subsubcategory_topic = Fabricate(:topic, category: subsubcategory)\n\n        SiteSetting.max_category_nesting = 2\n\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(category.topic, category_topic, subcategory_topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subcategory.id).list_latest.topics,\n        ).to contain_exactly(subcategory.topic, subcategory_topic, subsubcategory_topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subsubcategory.id).list_latest.topics,\n        ).to contain_exactly(subsubcategory.topic, subsubcategory_topic)\n\n        SiteSetting.max_category_nesting = 3\n\n        expect(\n          TopicQuery.new(moderator, category: category.id).list_latest.topics,\n        ).to contain_exactly(\n          category.topic,\n          category_topic,\n          subcategory_topic,\n          subsubcategory_topic,\n        )\n\n        expect(\n          TopicQuery.new(moderator, category: subcategory.id).list_latest.topics,\n        ).to contain_exactly(subcategory.topic, subcategory_topic, subsubcategory_topic)\n\n        expect(\n          TopicQuery.new(moderator, category: subsubcategory.id).list_latest.topics,\n        ).to contain_exactly(subsubcategory.topic, subsubcategory_topic)\n      end\n    end\n  end\n\n  describe \"tag filter\" do\n    fab!(:tag) { Fabricate(:tag) }\n    fab!(:other_tag) { Fabricate(:tag) }\n    fab!(:uppercase_tag) { Fabricate(:tag, name: \"HeLlO\") }\n\n    before { SiteSetting.tagging_enabled = true }\n\n    context \"with no category filter\" do\n      fab!(:tagged_topic1) { Fabricate(:topic, tags: [tag]) }\n      fab!(:tagged_topic2) { Fabricate(:topic, tags: [other_tag]) }\n      fab!(:tagged_topic3) { Fabricate(:topic, tags: [tag, other_tag]) }\n      fab!(:tagged_topic4) { Fabricate(:topic, tags: [uppercase_tag]) }\n      fab!(:no_tags_topic) { Fabricate(:topic) }\n      fab!(:tag_group) do\n        Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [other_tag.name])\n      end\n      let(:synonym) { Fabricate(:tag, target_tag: tag, name: \"synonym\") }\n\n      it \"excludes a tag if desired\" do\n        topics = TopicQuery.new(moderator, exclude_tag: tag.name).list_latest.topics\n        expect(topics.any? { |t| t.tags.include?(tag) }).to eq(false)\n      end\n\n      it \"does not exclude a tagged topic without permission\" do\n        topics = TopicQuery.new(user, exclude_tag: other_tag.name).list_latest.topics\n        expect(topics.map(&:id)).to include(tagged_topic2.id)\n      end\n\n      it \"returns topics with the tag when filtered to it\" do\n        expect(TopicQuery.new(moderator, tags: tag.name).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(TopicQuery.new(moderator, tags: [tag.id]).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(\n          TopicQuery.new(moderator, tags: [tag.name, other_tag.name]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(\n          TopicQuery.new(moderator, tags: [tag.id, other_tag.id]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(TopicQuery.new(moderator, tags: [\"hElLo\"]).list_latest.topics).to contain_exactly(\n          tagged_topic4,\n        )\n      end\n\n      it \"can return topics with all specified tags\" do\n        expect(\n          TopicQuery\n            .new(moderator, tags: [tag.name, other_tag.name], match_all_tags: true)\n            .list_latest\n            .topics\n            .map(&:id),\n        ).to eq([tagged_topic3.id])\n      end\n\n      it \"can return topics with tag intersections using truthy/falsey values\" do\n        expect(\n          TopicQuery\n            .new(moderator, tags: [tag.name, other_tag.name], match_all_tags: \"false\")\n            .list_latest\n            .topics\n            .map(&:id)\n            .sort,\n        ).to eq([tagged_topic1.id, tagged_topic2.id, tagged_topic3.id].sort)\n      end\n\n      it \"returns an empty relation when an invalid tag is passed\" do\n        expect(\n          TopicQuery\n            .new(moderator, tags: [tag.name, \"notatag\"], match_all_tags: true)\n            .list_latest\n            .topics,\n        ).to be_empty\n      end\n\n      it \"can return topics with no tags\" do\n        expect(TopicQuery.new(moderator, no_tags: true).list_latest.topics.map(&:id)).to eq(\n          [no_tags_topic.id],\n        )\n      end\n\n      it \"can filter using a synonym\" do\n        expect(TopicQuery.new(moderator, tags: synonym.name).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(TopicQuery.new(moderator, tags: [synonym.id]).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n\n        expect(\n          TopicQuery.new(moderator, tags: [synonym.name, other_tag.name]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(\n          TopicQuery.new(moderator, tags: [synonym.id, other_tag.id]).list_latest.topics,\n        ).to contain_exactly(tagged_topic1, tagged_topic2, tagged_topic3)\n\n        expect(TopicQuery.new(moderator, tags: [\"SYnonYM\"]).list_latest.topics).to contain_exactly(\n          tagged_topic1,\n          tagged_topic3,\n        )\n      end\n    end\n\n    context \"when remove_muted_tags is enabled\" do\n      fab!(:topic) { Fabricate(:topic, tags: [tag]) }\n\n      before do\n        SiteSetting.remove_muted_tags_from_latest = \"always\"\n        SiteSetting.default_tags_muted = tag.name\n      end\n\n      it \"removes default muted tag topics for anonymous users\" do\n        expect(TopicQuery.new(nil).list_latest.topics.map(&:id)).not_to include(topic.id)\n      end\n    end\n\n    context \"with categories too\" do\n      let(:category1) { Fabricate(:category_with_definition) }\n      let(:category2) { Fabricate(:category_with_definition) }\n\n      it \"returns topics in the given category with the given tag\" do\n        tagged_topic1 = Fabricate(:topic, category: category1, tags: [tag])\n        _tagged_topic2 = Fabricate(:topic, category: category2, tags: [tag])\n        tagged_topic3 = Fabricate(:topic, category: category1, tags: [tag, other_tag])\n        _no_tags_topic = Fabricate(:topic, category: category1)\n\n        expect(\n          TopicQuery\n            .new(moderator, category: category1.id, tags: [tag.name])\n            .list_latest\n            .topics\n            .map(&:id)\n            .sort,\n        ).to eq([tagged_topic1.id, tagged_topic3.id].sort)\n        expect(\n          TopicQuery\n            .new(moderator, category: category2.id, tags: [other_tag.name])\n            .list_latest\n            .topics\n            .size,\n        ).to eq(0)\n      end\n    end\n  end\n\n  describe \"muted categories\" do\n    it \"is removed from top, new and latest lists\" do\n      category = Fabricate(:category_with_definition)\n      topic = Fabricate(:topic, category: category)\n      CategoryUser.create!(\n        user_id: user.id,\n        category_id: category.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      )\n      expect(topic_query.list_new.topics.map(&:id)).not_to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).not_to include(topic.id)\n      TopTopic.create!(topic: topic, all_score: 1)\n      expect(topic_query.list_top_for(:all).topics.map(&:id)).not_to include(topic.id)\n    end\n  end\n\n  describe \"#list_top_for\" do\n    it \"lists top for the week\" do\n      Fabricate(:topic, like_count: 1000, posts_count: 100)\n      TopTopic.refresh!\n      expect(topic_query.list_top_for(:weekly).topics.count).to eq(1)\n    end\n\n    it \"only allows periods defined by TopTopic.periods\" do\n      expect { topic_query.list_top_for(:all) }.not_to raise_error\n      expect { topic_query.list_top_for(:yearly) }.not_to raise_error\n      expect { topic_query.list_top_for(:quarterly) }.not_to raise_error\n      expect { topic_query.list_top_for(:monthly) }.not_to raise_error\n      expect { topic_query.list_top_for(:weekly) }.not_to raise_error\n      expect { topic_query.list_top_for(:daily) }.not_to raise_error\n      expect { topic_query.list_top_for(\"some bad input\") }.to raise_error(\n        Discourse::InvalidParameters,\n      )\n    end\n  end\n\n  describe \"mute_all_categories_by_default\" do\n    fab!(:category) { Fabricate(:category_with_definition) }\n    fab!(:topic) { Fabricate(:topic, category: category) }\n\n    before { SiteSetting.mute_all_categories_by_default = true }\n\n    it \"should remove all topics from new and latest lists by default\" do\n      expect(topic_query.list_new.topics.map(&:id)).not_to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).not_to include(topic.id)\n    end\n\n    it \"should include tracked category topics in new and latest lists\" do\n      topic = Fabricate(:topic, category: category)\n      CategoryUser.create!(\n        user_id: user.id,\n        category_id: category.id,\n        notification_level: CategoryUser.notification_levels[:tracking],\n      )\n      expect(topic_query.list_new.topics.map(&:id)).to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n\n    it \"should include default watched category topics in latest list for anonymous users\" do\n      SiteSetting.default_categories_watching = category.id.to_s\n      expect(TopicQuery.new.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n\n    it \"should include default regular category topics in latest list for anonymous users\" do\n      SiteSetting.default_categories_normal = category.id.to_s\n      expect(TopicQuery.new.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n\n    it \"should include topics when filtered by category\" do\n      topic_query = TopicQuery.new(user, category: topic.category_id)\n      expect(topic_query.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n  end\n\n  describe \"already seen topics\" do\n    it \"is removed from new and visible on latest lists\" do\n      category = Fabricate(:category_with_definition)\n      topic = Fabricate(:topic, category: category)\n      DismissedTopicUser.create!(user_id: user.id, topic_id: topic.id, created_at: Time.zone.now)\n      expect(topic_query.list_new.topics.map(&:id)).not_to include(topic.id)\n      expect(topic_query.list_latest.topics.map(&:id)).to include(topic.id)\n    end\n  end\n\n  describe \"muted tags\" do\n    it \"is removed from new and latest lists\" do\n      SiteSetting.tagging_enabled = true\n      SiteSetting.remove_muted_tags_from_latest = \"always\"\n\n      muted_tag, other_tag = Fabricate(:tag), Fabricate(:tag)\n\n      muted_topic = Fabricate(:topic, tags: [muted_tag])\n      tagged_topic = Fabricate(:topic, tags: [other_tag])\n      muted_tagged_topic = Fabricate(:topic, tags: [muted_tag, other_tag])\n      untagged_topic = Fabricate(:topic)\n\n      TagUser.create!(\n        user_id: user.id,\n        tag_id: muted_tag.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      )\n\n      topic_ids = topic_query.list_latest.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(tagged_topic.id, untagged_topic.id)\n\n      topic_ids = topic_query.list_new.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(tagged_topic.id, untagged_topic.id)\n\n      SiteSetting.remove_muted_tags_from_latest = \"only_muted\"\n\n      topic_ids = topic_query.list_latest.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n\n      topic_ids = topic_query.list_new.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n\n      SiteSetting.remove_muted_tags_from_latest = \"never\"\n\n      topic_ids = topic_query.list_latest.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        muted_topic.id,\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n\n      topic_ids = topic_query.list_new.topics.map(&:id)\n      expect(topic_ids).to contain_exactly(\n        muted_topic.id,\n        tagged_topic.id,\n        muted_tagged_topic.id,\n        untagged_topic.id,\n      )\n    end\n\n    it \"is not removed from the tag page itself\" do\n      muted_tag = Fabricate(:tag)\n      TagUser.create!(\n        user_id: user.id,\n        tag_id: muted_tag.id,\n        notification_level: CategoryUser.notification_levels[:muted],\n      )\n\n      muted_topic = Fabricate(:topic, tags: [muted_tag])\n\n      topic_ids = topic_query.latest_results(tags: [muted_tag.name]).map(&:id)\n      expect(topic_ids).to contain_exactly(muted_topic.id)\n\n      muted_tag.update(name: \"mixedCaseName\")\n      topic_ids = topic_query.latest_results(tags: [muted_tag.name.downcase]).map(&:id)\n      expect(topic_ids).to contain_exactly(muted_topic.id)\n    end\n  end\n\n  describe \"a bunch of topics\" do\n    fab!(:regular_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a regular topic\",\n        user: creator,\n        views: 100,\n        like_count: 66,\n        posts_count: 3,\n        participant_count: 11,\n        bumped_at: 15.minutes.ago,\n      )\n    end\n    fab!(:pinned_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a pinned topic\",\n        user: creator,\n        views: 10,\n        like_count: 100,\n        posts_count: 5,\n        participant_count: 12,\n        pinned_at: 10.minutes.ago,\n        pinned_globally: true,\n        bumped_at: 10.minutes.ago,\n      )\n    end\n    fab!(:archived_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is an archived topic\",\n        user: creator,\n        views: 50,\n        like_count: 30,\n        posts_count: 4,\n        archived: true,\n        participant_count: 1,\n        bumped_at: 6.minutes.ago,\n      )\n    end\n    fab!(:invisible_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is an invisible topic\",\n        user: creator,\n        views: 1,\n        like_count: 5,\n        posts_count: 2,\n        visible: false,\n        participant_count: 3,\n        bumped_at: 5.minutes.ago,\n      )\n    end\n    fab!(:closed_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a closed topic\",\n        user: creator,\n        views: 2,\n        like_count: 1,\n        posts_count: 1,\n        closed: true,\n        participant_count: 2,\n        bumped_at: 1.minute.ago,\n      )\n    end\n    fab!(:future_topic) do\n      Fabricate(\n        :topic,\n        title: \"this is a topic in far future\",\n        user: creator,\n        views: 30,\n        like_count: 11,\n        posts_count: 6,\n        participant_count: 5,\n        bumped_at: 1000.years.from_now,\n      )\n    end\n\n    let(:topics) { topic_query.list_latest.topics }\n\n    context \"with list_latest\" do\n      it \"returns the topics in the correct order\" do\n        expect(topics.map(&:id)).to eq(\n          [pinned_topic, future_topic, closed_topic, archived_topic, regular_topic].map(&:id),\n        )\n\n        # includes the invisible topic if you're a moderator\n        expect(TopicQuery.new(moderator).list_latest.topics.include?(invisible_topic)).to eq(true)\n\n        # includes the invisible topic if you're an admin\n        expect(TopicQuery.new(admin).list_latest.topics.include?(invisible_topic)).to eq(true)\n\n        # includes the invisible topic if you're a TL4 user\n        expect(TopicQuery.new(tl4_user).list_latest.topics.include?(invisible_topic)).to eq(true)\n      end\n\n      context \"with sort_order\" do\n        def ids_in_order(order, descending = true)\n          TopicQuery\n            .new(admin, order: order, ascending: descending ? \"false\" : \"true\")\n            .list_latest\n            .topics\n            .map(&:id)\n        end\n\n        it \"returns the topics in correct order\" do\n          # returns the topics in likes order if requested\n          expect(ids_in_order(\"posts\")).to eq(\n            [\n              future_topic,\n              pinned_topic,\n              archived_topic,\n              regular_topic,\n              invisible_topic,\n              closed_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse likes order if requested\n          expect(ids_in_order(\"posts\", false)).to eq(\n            [\n              closed_topic,\n              invisible_topic,\n              regular_topic,\n              archived_topic,\n              pinned_topic,\n              future_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in likes order if requested\n          expect(ids_in_order(\"likes\")).to eq(\n            [\n              pinned_topic,\n              regular_topic,\n              archived_topic,\n              future_topic,\n              invisible_topic,\n              closed_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse likes order if requested\n          expect(ids_in_order(\"likes\", false)).to eq(\n            [\n              closed_topic,\n              invisible_topic,\n              future_topic,\n              archived_topic,\n              regular_topic,\n              pinned_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in views order if requested\n          expect(ids_in_order(\"views\")).to eq(\n            [\n              regular_topic,\n              archived_topic,\n              future_topic,\n              pinned_topic,\n              closed_topic,\n              invisible_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse views order if requested\" do\n          expect(ids_in_order(\"views\", false)).to eq(\n            [\n              invisible_topic,\n              closed_topic,\n              pinned_topic,\n              future_topic,\n              archived_topic,\n              regular_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in posters order if requested\" do\n          expect(ids_in_order(\"posters\")).to eq(\n            [\n              pinned_topic,\n              regular_topic,\n              future_topic,\n              invisible_topic,\n              closed_topic,\n              archived_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse posters order if requested\" do\n          expect(ids_in_order(\"posters\", false)).to eq(\n            [\n              archived_topic,\n              closed_topic,\n              invisible_topic,\n              future_topic,\n              regular_topic,\n              pinned_topic,\n            ].map(&:id),\n          )\n\n          # sets a custom field for each topic to emulate a plugin\n          regular_topic.custom_fields[\"sheep\"] = 26\n          pinned_topic.custom_fields[\"sheep\"] = 47\n          archived_topic.custom_fields[\"sheep\"] = 69\n          invisible_topic.custom_fields[\"sheep\"] = 12\n          closed_topic.custom_fields[\"sheep\"] = 31\n          future_topic.custom_fields[\"sheep\"] = 53\n\n          regular_topic.save\n          pinned_topic.save\n          archived_topic.save\n          invisible_topic.save\n          closed_topic.save\n          future_topic.save\n\n          # adds the custom field as a viable sort option\n          class ::TopicQuery\n            SORTABLE_MAPPING[\"sheep\"] = \"custom_fields.sheep\"\n          end\n          # returns the topics in the sheep order if requested\" do\n          expect(ids_in_order(\"sheep\")).to eq(\n            [\n              archived_topic,\n              future_topic,\n              pinned_topic,\n              closed_topic,\n              regular_topic,\n              invisible_topic,\n            ].map(&:id),\n          )\n\n          # returns the topics in reverse sheep order if requested\" do\n          expect(ids_in_order(\"sheep\", false)).to eq(\n            [\n              invisible_topic,\n              regular_topic,\n              closed_topic,\n              pinned_topic,\n              future_topic,\n              archived_topic,\n            ].map(&:id),\n          )\n        end\n      end\n    end\n\n    context \"after clearing a pinned topic\" do\n      before { pinned_topic.clear_pin_for(user) }\n\n      it \"no longer shows the pinned topic at the top\" do\n        expect(topics).to eq(\n          [future_topic, closed_topic, archived_topic, pinned_topic, regular_topic],\n        )\n      end\n    end\n  end\n\n  describe \"categorized\" do\n    fab!(:category) { Fabricate(:category_with_definition) }\n    let(:topic_category) { category.topic }\n    fab!(:topic_no_cat) { Fabricate(:topic) }\n    fab!(:topic_in_cat1) do\n      Fabricate(:topic, category: category, bumped_at: 10.minutes.ago, created_at: 10.minutes.ago)\n    end\n    fab!(:topic_in_cat2) { Fabricate(:topic, category: category) }\n\n    describe \"#list_new_in_category\" do\n      it \"returns the topic category and the categorized topic\" do\n        expect(topic_query.list_new_in_category(category).topics.map(&:id)).to eq(\n          [topic_in_cat2.id, topic_category.id, topic_in_cat1.id],\n        )\n      end\n    end\n\n    describe \"category default sort order\" do\n      it \"can use category's default sort order\" do\n        category.update!(sort_order: \"created\", sort_ascending: true)\n        topic_ids = TopicQuery.new(user, category: category.id).list_latest.topics.map(&:id)\n        expect(topic_ids - [topic_category.id]).to eq([topic_in_cat1.id, topic_in_cat2.id])\n      end\n\n      it \"should apply default sort order to latest and unseen filters only\" do\n        category.update!(sort_order: \"created\", sort_ascending: true)\n\n        topic1 =\n          Fabricate(\n            :topic,\n            category: category,\n            like_count: 1000,\n            posts_count: 100,\n            created_at: 1.day.ago,\n          )\n        topic2 =\n          Fabricate(\n            :topic,\n            category: category,\n            like_count: 5200,\n            posts_count: 500,\n            created_at: 1.hour.ago,\n          )\n        TopTopic.refresh!\n\n        topic_ids =\n          TopicQuery.new(user, category: category.id).list_top_for(:monthly).topics.map(&:id)\n        expect(topic_ids).to eq([topic2.id, topic1.id])\n      end\n\n      it \"ignores invalid order value\" do\n        category.update!(sort_order: \"funny\")\n        topic_ids = TopicQuery.new(user, category: category.id).list_latest.topics.map(&:id)\n        expect(topic_ids - [topic_category.id]).to eq([topic_in_cat2.id, topic_in_cat1.id])\n      end\n\n      it \"can be overridden\" do\n        category.update!(sort_order: \"created\", sort_ascending: true)\n        topic_ids =\n          TopicQuery\n            .new(user, category: category.id, order: \"activity\")\n            .list_latest\n            .topics\n            .map(&:id)\n        expect(topic_ids - [topic_category.id]).to eq([topic_in_cat2.id, topic_in_cat1.id])\n      end\n    end\n  end\n\n  describe \"unread / read topics\" do\n    context \"with no data\" do\n      it \"has no unread topics\" do\n        expect(topic_query.list_unread.topics).to be_blank\n      end\n    end\n\n    context \"with whispers\" do\n      before { SiteSetting.whispers_allowed_groups = \"#{Group::AUTO_GROUPS[:staff]}\" }\n\n      it \"correctly shows up in unread for staff\" do\n        first = create_post(raw: \"this is the first post\", title: \"super amazing title\")\n\n        _whisper =\n          create_post(\n            topic_id: first.topic.id,\n            post_type: Post.types[:whisper],\n            raw: \"this is a whispered reply\",\n          )\n\n        topic_id = first.topic.id\n\n        TopicUser.update_last_read(user, topic_id, first.post_number, 1, 1)\n        TopicUser.update_last_read(admin, topic_id, first.post_number, 1, 1)\n\n        TopicUser.change(\n          user.id,\n          topic_id,\n          notification_level: TopicUser.notification_levels[:tracking],\n        )\n        TopicUser.change(\n          admin.id,\n          topic_id,\n          notification_level: TopicUser.notification_levels[:tracking],\n        )\n\n        expect(TopicQuery.new(user).list_unread.topics).to eq([])\n        expect(TopicQuery.new(admin).list_unread.topics).to eq([first.topic])\n      end\n    end\n\n    context \"with read data\" do\n      fab!(:partially_read) { Fabricate(:post, user: creator).topic }\n      fab!(:fully_read) { Fabricate(:post, user: creator).topic }\n\n      before do\n        TopicUser.update_last_read(user, partially_read.id, 0, 0, 0)\n        TopicUser.update_last_read(user, fully_read.id, 1, 1, 0)\n      end\n\n      context \"with list_unread\" do\n        it \"lists topics correctly\" do\n          _new_topic = Fabricate(:post, user: creator).topic\n\n          expect(topic_query.list_unread.topics).to eq([])\n          expect(topic_query.list_read.topics).to match_array([fully_read, partially_read])\n        end\n      end\n\n      context \"with user with auto_track_topics list_unread\" do\n        before do\n          user.user_option.auto_track_topics_after_msecs = 0\n          user.user_option.save\n        end\n\n        it \"only contains the partially read topic\" do\n          expect(topic_query.list_unread.topics).to eq([partially_read])\n        end\n      end\n    end\n  end\n\n  describe \"#list_new\" do\n    context \"without a new topic\" do\n      it \"has no new topics\" do\n        expect(topic_query.list_new.topics).to be_blank\n      end\n    end\n\n    context \"when preloading api\" do\n      it \"preloads data correctly\" do\n        TopicList.preloaded_custom_fields << \"tag\"\n        TopicList.preloaded_custom_fields << \"age\"\n        TopicList.preloaded_custom_fields << \"foo\"\n\n        topic = Fabricate.build(:topic, user: creator, bumped_at: 10.minutes.ago)\n        topic.custom_fields[\"tag\"] = %w[a b c]\n        topic.custom_fields[\"age\"] = 22\n        topic.save\n\n        new_topic = topic_query.list_new.topics.first\n\n        expect(new_topic.custom_fields[\"tag\"].sort).to eq(%w[a b c])\n        expect(new_topic.custom_fields[\"age\"]).to eq(\"22\")\n\n        expect(new_topic.custom_field_preloaded?(\"tag\")).to eq(true)\n        expect(new_topic.custom_field_preloaded?(\"age\")).to eq(true)\n        expect(new_topic.custom_field_preloaded?(\"foo\")).to eq(true)\n        expect(new_topic.custom_field_preloaded?(\"bar\")).to eq(false)\n\n        TopicList.preloaded_custom_fields.clear\n\n        # if we attempt to access non preloaded fields explode\n        expect { new_topic.custom_fields[\"boom\"] }.to raise_error(StandardError)\n      end\n    end\n\n    context \"when preloading associations\" do\n      it \"preloads associations\" do\n        DiscoursePluginRegistry.register_topic_preloader_association(\n          :first_post,\n          Plugin::Instance.new,\n        )\n\n        topic = Fabricate(:topic)\n        Fabricate(:post, topic: topic)\n\n        new_topic = topic_query.list_new.topics.first\n        expect(new_topic.association(:image_upload).loaded?).to eq(true) # Preloaded by default\n        expect(new_topic.association(:first_post).loaded?).to eq(true) # Testing a user-defined preloaded association\n        expect(new_topic.association(:user).loaded?).to eq(false) # Testing the negative\n\n        DiscoursePluginRegistry.reset_register!(:topic_preloader_associations)\n      end\n    end\n\n    context \"with a new topic\" do\n      let!(:new_topic) { Fabricate(:topic, user: creator, bumped_at: 10.minutes.ago) }\n      let(:topics) { topic_query.list_new.topics }\n\n      it \"contains no new topics for a user that has missed the window\" do\n        expect(topic_query.list_new.topics).to eq([new_topic])\n\n        user.user_option.new_topic_duration_minutes = 5\n        user.user_option.save\n        new_topic.created_at = 10.minutes.ago\n        new_topic.save\n        expect(topic_query.list_new.topics).to eq([])\n      end\n\n      context \"with muted topics\" do\n        before { new_topic.notify_muted!(user) }\n\n        it \"returns an empty set\" do\n          expect(topics).to be_blank\n          expect(topic_query.list_latest.topics).to be_blank\n        end\n\n        context \"when un-muted\" do\n          before { new_topic.notify_tracking!(user) }\n\n          it \"returns the topic again\" do\n            expect(topics).to eq([new_topic])\n            expect(topic_query.list_latest.topics).not_to be_blank\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#list_posted\" do\n    let(:topics) { topic_query.list_posted.topics }\n\n    it \"returns blank when there are no posted topics\" do\n      expect(topics).to be_blank\n    end\n\n    context \"with created topics\" do\n      let!(:created_topic) { create_post(user: user).topic }\n\n      it \"includes the created topic\" do\n        expect(topics.include?(created_topic)).to eq(true)\n      end\n    end\n\n    context \"with topic you've posted in\" do\n      let(:other_users_topic) { create_post(user: creator).topic }\n      let!(:your_post) { create_post(user: user, topic: other_users_topic) }\n\n      it \"includes the posted topic\" do\n        expect(topics.include?(other_users_topic)).to eq(true)\n      end\n    end\n\n    context \"with topic you haven't posted in\" do\n      let(:other_users_topic) { create_post(user: creator).topic }\n\n      it \"does not include the topic\" do\n        expect(topics).to be_blank\n      end\n\n      context \"with topic you interacted with\" do\n        it \"is not included if read\" do\n          TopicUser.update_last_read(user, other_users_topic.id, 0, 0, 0)\n\n          expect(topics).to be_blank\n        end\n\n        it \"is not included if muted\" do\n          other_users_topic.notify_muted!(user)\n\n          expect(topics).to be_blank\n        end\n\n        it \"is not included if tracking\" do\n          other_users_topic.notify_tracking!(user)\n\n          expect(topics).to be_blank\n        end\n      end\n    end\n  end\n\n  describe \"#list_unseen\" do\n    it \"returns an empty list when there aren't topics\" do\n      expect(topic_query.list_unseen.topics).to be_blank\n    end\n\n    it \"doesn't return topics that were bumped last time before user joined the forum\" do\n      user.first_seen_at = 10.minutes.ago\n      create_topic_with_three_posts(bumped_at: 15.minutes.ago)\n\n      expect(topic_query.list_unseen.topics).to be_blank\n    end\n\n    it \"returns only topics that contain unseen posts\" do\n      user.first_seen_at = 10.minutes.ago\n      topic_with_unseen_posts = create_topic_with_three_posts(bumped_at: 5.minutes.ago)\n      read_to_post(topic_with_unseen_posts, user, 1)\n\n      fully_read_topic = create_topic_with_three_posts(bumped_at: 5.minutes.ago)\n      read_to_the_end(fully_read_topic, user)\n\n      expect(topic_query.list_unseen.topics).to eq([topic_with_unseen_posts])\n    end\n\n    it \"ignores staff posts if user is not staff\" do\n      user.first_seen_at = 10.minutes.ago\n      topic = create_topic_with_three_posts(bumped_at: 5.minutes.ago)\n      read_to_the_end(topic, user)\n      create_post(topic: topic, post_type: Post.types[:whisper])\n\n      expect(topic_query.list_unseen.topics).to be_blank\n    end\n\n    def create_topic_with_three_posts(bumped_at:)\n      topic = Fabricate(:topic, bumped_at: bumped_at)\n      Fabricate(:post, topic: topic)\n      Fabricate(:post, topic: topic)\n      Fabricate(:post, topic: topic)\n      topic.highest_staff_post_number = 3\n      topic.highest_post_number = 3\n      topic\n    end\n\n    def read_to_post(topic, user, post_number)\n      TopicUser.update_last_read(user, topic.id, post_number, 0, 0)\n    end\n\n    def read_to_the_end(topic, user)\n      read_to_post topic, user, topic.highest_post_number\n    end\n  end\n\n  describe \"#list_related_for\" do\n    let(:user) { Fabricate(:user) }\n    let(:sender) { Fabricate(:user) }\n\n    let(:group_with_user) do\n      group = Fabricate(:group, messageable_level: Group::ALIAS_LEVELS[:everyone])\n      group.add(user)\n      group.save\n      group\n    end\n\n    def create_pm(user, opts = nil)\n      unless opts\n        opts = user\n        user = nil\n      end\n\n      create_post(opts.merge(user: user, archetype: Archetype.private_message)).topic\n    end\n\n    def read(user, topic, post_number)\n      TopicUser.update_last_read(user, topic, post_number, post_number, 10_000)\n    end\n\n    before do\n      user.change_trust_level!(4)\n      sender.change_trust_level!(4)\n    end\n\n    it \"returns the correct suggestions\" do\n      pm_to_group = create_pm(sender, target_group_names: [group_with_user.name])\n      pm_to_user = create_pm(sender, target_usernames: [user.username])\n\n      other_user = Fabricate(:user)\n      other_user.change_trust_level!(1)\n      old_unrelated_pm = create_pm(other_user, target_usernames: [user.username])\n      read(user, old_unrelated_pm, 1)\n\n      related_by_user_pm = create_pm(sender, target_usernames: [user.username])\n      read(user, related_by_user_pm, 1)\n\n      related_by_group_pm = create_pm(sender, target_group_names: [group_with_user.name])\n      read(user, related_by_group_pm, 1)\n\n      expect(TopicQuery.new(user).list_related_for(pm_to_group).topics.map(&:id)).to(\n        eq([related_by_group_pm.id]),\n      )\n\n      expect(TopicQuery.new(user).list_related_for(pm_to_user).topics.map(&:id)).to(\n        eq([related_by_user_pm.id]),\n      )\n\n      SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:staff]\n      expect(TopicQuery.new(user).list_related_for(pm_to_group)).to be_blank\n      expect(TopicQuery.new(user).list_related_for(pm_to_user)).to be_blank\n    end\n  end\n\n  describe \"suggested_for\" do\n    def clear_cache!\n      Discourse.redis.keys(\"random_topic_cache*\").each { |k| Discourse.redis.del k }\n    end\n\n    before { clear_cache! }\n\n    context \"when anonymous\" do\n      let(:topic) { Fabricate(:topic) }\n      let!(:new_topic) { Fabricate(:post, user: creator).topic }\n\n      it \"should return the new topic\" do\n        expect(TopicQuery.new.list_suggested_for(topic).topics).to eq([new_topic])\n      end\n    end\n\n    context \"when anonymously browsing with invisible, closed and archived\" do\n      let!(:topic) { Fabricate(:topic) }\n      let!(:regular_topic) { Fabricate(:post, user: creator).topic }\n      let!(:closed_topic) { Fabricate(:topic, user: creator, closed: true) }\n      let!(:archived_topic) { Fabricate(:topic, user: creator, archived: true) }\n      let!(:invisible_topic) { Fabricate(:topic, user: creator, visible: false) }\n\n      it \"should omit the closed/archived/invisible topics from suggested\" do\n        expect(TopicQuery.new.list_suggested_for(topic).topics).to eq([regular_topic])\n      end\n    end\n\n    context \"when logged in\" do\n      def suggested_for(topic)\n        topic_query.list_suggested_for(topic)&.topics&.map { |t| t.id }\n      end\n\n      let(:topic) { Fabricate(:topic) }\n      let(:suggested_topics) do\n        tt = topic\n        # lets clear cache once category is created - working around caching is hard\n        clear_cache!\n        suggested_for(tt)\n      end\n\n      it \"should return empty results when there is nothing to find\" do\n        expect(suggested_topics).to be_blank\n      end\n\n      context \"with random suggested\" do\n        let!(:new_topic) { Fabricate(:topic, created_at: 2.days.ago) }\n        let!(:old_topic) { Fabricate(:topic, created_at: 3.years.ago) }\n\n        it \"respects suggested_topics_max_days_old\" do\n          SiteSetting.suggested_topics_max_days_old = 1365\n          tt = topic\n\n          clear_cache!\n          expect(topic_query.list_suggested_for(tt).topics.length).to eq(2)\n\n          SiteSetting.suggested_topics_max_days_old = 365\n          clear_cache!\n\n          expect(topic_query.list_suggested_for(tt).topics.length).to eq(1)\n        end\n\n        it \"removes muted topics\" do\n          SiteSetting.suggested_topics_max_days_old = 1365\n          tt = topic\n          TopicNotifier.new(old_topic).mute!(user)\n          clear_cache!\n\n          topics = topic_query.list_suggested_for(tt).topics\n\n          expect(topics.length).to eq(1)\n          expect(topics).not_to include(old_topic)\n        end\n      end\n\n      context \"with private messages\" do\n        let(:group_user) { Fabricate(:user) }\n        let(:group) { Fabricate(:group) }\n        let(:another_group) { Fabricate(:group) }\n\n        let!(:topic) do\n          Fabricate(\n            :private_message_topic,\n            topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: user)],\n            topic_allowed_groups: [Fabricate.build(:topic_allowed_group, group: group)],\n          )\n        end\n\n        let!(:private_message) do\n          Fabricate(\n            :private_message_topic,\n            topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: user)],\n            topic_allowed_groups: [\n              Fabricate.build(:topic_allowed_group, group: group),\n              Fabricate.build(:topic_allowed_group, group: another_group),\n            ],\n          )\n        end\n\n        let!(:private_group_topic) do\n          Fabricate(\n            :private_message_topic,\n            user: Fabricate(:user),\n            topic_allowed_groups: [Fabricate.build(:topic_allowed_group, group: group)],\n          )\n        end\n\n        before do\n          group.add(group_user)\n          another_group.add(user)\n          Group.user_trust_level_change!(user.id, user.trust_level)\n          Group.user_trust_level_change!(group_user.id, group_user.trust_level)\n        end\n\n        context \"as user not part of group\" do\n          let!(:user) { Fabricate(:user) }\n\n          it \"should not return topics by the group user\" do\n            expect(suggested_topics).to eq([private_message.id])\n          end\n        end\n\n        context \"as user part of group\" do\n          let!(:user) { group_user }\n\n          it \"should return the group topics\" do\n            expect(suggested_topics).to match_array([private_group_topic.id, private_message.id])\n          end\n\n          context \"when user is not in personal_message_enabled_groups\" do\n            before do\n              SiteSetting.personal_message_enabled_groups = Group::AUTO_GROUPS[:trust_level_4]\n            end\n\n            it \"should not return topics by the group user\" do\n              expect(suggested_topics).to eq(nil)\n            end\n          end\n        end\n\n        context \"with tag filter\" do\n          let(:tag) { Fabricate(:tag) }\n          let!(:user) { group_user }\n\n          it \"should return only tagged topics\" do\n            Fabricate(:topic_tag, topic: private_message, tag: tag)\n            Fabricate(:topic_tag, topic: private_group_topic)\n\n            expect(\n              TopicQuery.new(user, tags: [tag.name]).list_private_messages_tag(user).topics,\n            ).to eq([private_message])\n          end\n        end\n      end\n\n      context \"with some existing topics\" do\n        let!(:old_partially_read) do\n          topic = Fabricate(:post, user: creator).topic\n          Fabricate(:post, user: creator, topic: topic)\n          topic\n        end\n\n        let!(:partially_read) do\n          topic = Fabricate(:post, user: creator).topic\n          Fabricate(:post, user: creator, topic: topic)\n          topic\n        end\n\n        let!(:new_topic) { Fabricate(:post, user: creator).topic }\n        let!(:fully_read) { Fabricate(:post, user: creator).topic }\n        let!(:closed_topic) { Fabricate(:topic, user: creator, closed: true) }\n        let!(:archived_topic) { Fabricate(:topic, user: creator, archived: true) }\n        let!(:invisible_topic) { Fabricate(:topic, user: creator, visible: false) }\n        let!(:fully_read_closed) { Fabricate(:post, user: creator).topic }\n        let!(:fully_read_archived) { Fabricate(:post, user: creator).topic }\n\n        before do\n          user.user_option.update!(\n            auto_track_topics_after_msecs: 0,\n            new_topic_duration_minutes: User::NewTopicDuration::ALWAYS,\n          )\n\n          freeze_time 3.weeks.from_now\n\n          TopicUser.update_last_read(user, old_partially_read.id, 1, 1, 0)\n          TopicUser.update_last_read(user, partially_read.id, 1, 1, 0)\n          TopicUser.update_last_read(user, fully_read.id, 1, 1, 0)\n          TopicUser.update_last_read(user, fully_read_closed.id, 1, 1, 0)\n          TopicUser.update_last_read(user, fully_read_archived.id, 1, 1, 0)\n\n          fully_read_closed.closed = true\n          fully_read_closed.save\n          fully_read_archived.archived = true\n          fully_read_archived.save\n\n          old_partially_read.update!(updated_at: 2.weeks.ago)\n          partially_read.update!(updated_at: Time.now)\n        end\n\n        it \"operates correctly\" do\n          # Note, this is a pretty slow integration test\n          # it tests that suggested is returned in the expected order\n          # hence we run suggested_for twice here to save on all the setup\n\n          SiteSetting.suggested_topics = 4\n          SiteSetting.suggested_topics_unread_max_days_old = 7\n\n          expect(suggested_topics[0]).to eq(partially_read.id)\n          expect(suggested_topics[1, 3]).to contain_exactly(\n            new_topic.id,\n            closed_topic.id,\n            archived_topic.id,\n          )\n\n          expect(suggested_topics.length).to eq(4)\n\n          SiteSetting.suggested_topics = 2\n          SiteSetting.suggested_topics_unread_max_days_old = 15\n\n          expect(suggested_for(topic)).to contain_exactly(partially_read.id, old_partially_read.id)\n        end\n      end\n    end\n  end\n\n  describe \"#list_group_topics\" do\n    fab!(:group) { Fabricate(:group) }\n\n    let(:user) do\n      user = Fabricate(:user)\n      group.add(user)\n      user\n    end\n\n    let(:user2) do\n      user = Fabricate(:user)\n      group.add(user)\n      user\n    end\n\n    fab!(:user3) { Fabricate(:user) }\n\n    fab!(:private_category) { Fabricate(:private_category_with_definition, group: group) }\n\n    let!(:private_message_topic) { Fabricate(:private_message_post, user: user).topic }\n    let!(:topic1) { Fabricate(:topic, user: user) }\n    let!(:topic2) { Fabricate(:topic, user: user, category: Fabricate(:category_with_definition)) }\n    let!(:topic3) { Fabricate(:topic, user: user, category: private_category) }\n    let!(:topic4) { Fabricate(:topic) }\n    let!(:topic5) { Fabricate(:topic, user: user, visible: false) }\n    let!(:topic6) { Fabricate(:topic, user: user2) }\n\n    it \"should return the right lists for anon user\" do\n      topics = TopicQuery.new.list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic6)\n    end\n\n    it \"should return the right list for users in the same group\" do\n      topics = TopicQuery.new(user).list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic3, topic6)\n\n      topics = TopicQuery.new(user2).list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic3, topic6)\n    end\n\n    it \"should return the right list for user no in the group\" do\n      topics = TopicQuery.new(user3).list_group_topics(group).topics\n\n      expect(topics).to contain_exactly(topic1, topic2, topic6)\n    end\n  end\n\n  describe \"shared drafts\" do\n    fab!(:category) { Fabricate(:category_with_definition) }\n    fab!(:shared_drafts_category) { Fabricate(:category_with_definition) }\n    fab!(:topic) { Fabricate(:topic, category: shared_drafts_category) }\n    fab!(:shared_draft) { Fabricate(:shared_draft, topic: topic, category: category) }\n    fab!(:admin) { Fabricate(:admin) }\n    fab!(:user) { Fabricate(:user) }\n    fab!(:group) { Fabricate(:group) }\n\n    before do\n      shared_drafts_category.set_permissions(group => :full)\n      shared_drafts_category.save\n      SiteSetting.shared_drafts_category = shared_drafts_category.id\n      SiteSetting.shared_drafts_min_trust_level = TrustLevel[3]\n    end\n\n    context \"with destination_category_id\" do\n      it \"doesn't allow regular users to query destination_category_id\" do\n        list = TopicQuery.new(user, destination_category_id: category.id).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n\n      it \"allows staff users to query destination_category_id\" do\n        list = TopicQuery.new(admin, destination_category_id: category.id).list_latest\n        expect(list.topics).to include(topic)\n      end\n\n      it \"allow group members with enough trust level to query destination_category_id\" do\n        member = Fabricate(:user, trust_level: TrustLevel[3])\n        group.add(member)\n\n        list = TopicQuery.new(member, destination_category_id: category.id).list_latest\n\n        expect(list.topics).to include(topic)\n      end\n\n      it \"doesn't allow group members without enough trust level to query destination_category_id\" do\n        member = Fabricate(:user, trust_level: TrustLevel[2])\n        group.add(member)\n\n        list = TopicQuery.new(member, destination_category_id: category.id).list_latest\n\n        expect(list.topics).not_to include(topic)\n      end\n    end\n\n    context \"with latest\" do\n      it \"doesn't include shared topics unless filtering by category\" do\n        list = TopicQuery.new(moderator).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n\n      it \"doesn't include shared draft topics for regular users\" do\n        group.add(user)\n        SiteSetting.shared_drafts_category = nil\n        list = TopicQuery.new(user).list_latest\n        expect(list.topics).to include(topic)\n\n        SiteSetting.shared_drafts_category = shared_drafts_category.id\n        list = TopicQuery.new(user).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n\n      it \"doesn't include shared draft topics for group members with access to shared drafts\" do\n        member = Fabricate(:user, trust_level: TrustLevel[3])\n        group.add(member)\n\n        list = TopicQuery.new(member).list_latest\n        expect(list.topics).not_to include(topic)\n      end\n    end\n\n    context \"with unread\" do\n      let!(:partially_read) do\n        topic = Fabricate(:topic, category: shared_drafts_category)\n        Fabricate(:post, user: creator, topic: topic).topic\n        TopicUser.update_last_read(admin, topic.id, 0, 0, 0)\n        TopicUser.change(\n          admin.id,\n          topic.id,\n          notification_level: TopicUser.notification_levels[:tracking],\n        )\n        topic\n      end\n\n      it \"does not remove topics from unread\" do\n        expect(TopicQuery.new(admin).list_latest.topics).not_to include(partially_read) # Check we set up the topic/category correctly\n        expect(TopicQuery.new(admin).list_unread.topics).to include(partially_read)\n      end\n    end\n  end\nend\n"], "filenames": ["lib/topic_query.rb", "spec/lib/topic_query_spec.rb"], "buggy_code_start_loc": [738, 411], "buggy_code_end_loc": [746, 416], "fixing_code_start_loc": [738, 412], "fixing_code_end_loc": [749, 425], "type": "CWE-200", "message": "Discourse is an open-source discussion platform. Prior to version 3.0.1 on the `stable` branch and version 3.1.0.beta2 on the `beta` and `tests-passed` branches, someone can use the `exclude_tag param` to filter out topics and deduce which ones were using a specific hidden tag. This affects any Discourse site using hidden tags in public categories. This issue is patched in version 3.0.1 on the `stable` branch and version 3.1.0.beta2 on the `beta` and `tests-passed` branches. As a workaround, secure any categories that are using hidden tags, change any existing hidden tags to not include private data, or remove any hidden tags currently in use.", "other": {"cve": {"id": "CVE-2023-23624", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-28T00:15:09.470", "lastModified": "2023-02-14T15:57:23.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source discussion platform. Prior to version 3.0.1 on the `stable` branch and version 3.1.0.beta2 on the `beta` and `tests-passed` branches, someone can use the `exclude_tag param` to filter out topics and deduce which ones were using a specific hidden tag. This affects any Discourse site using hidden tags in public categories. This issue is patched in version 3.0.1 on the `stable` branch and version 3.1.0.beta2 on the `beta` and `tests-passed` branches. As a workaround, secure any categories that are using hidden tags, change any existing hidden tags to not include private data, or remove any hidden tags currently in use."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.0.1", "matchCriteriaId": "C19D7945-EB52-43C0-B9B7-8C250FEDC451"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BF272688-1B08-4ABC-8002-66B59690F9A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "A29A2465-B21D-4147-8292-DCF864D385B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "BBC3511E-3D68-42E2-B521-966FB429B640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "EC8B99C2-E267-4EC2-AF09-C9AD1EEE76D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "F21A22EE-081A-4489-A7F8-22E2DBC5B00E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E6C8FB3-4B19-4510-B9A8-BCF9ED8ED7C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6b:*:*:beta:*:*:*", "matchCriteriaId": "5B827291-6483-4BB7-AF76-530B669B3ED5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "551E70ED-34FF-4989-91C9-6312DE4AB4DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "204FB99A-8F11-4F04-9ED9-D94551790116"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "46A8705C-0DF6-45D7-A38C-D2AB69194C59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F59B0D8E-CFFB-4EBA-9D6A-526F9541BA17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D801A898-27D0-4076-8AF9-2B574FA11723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E7CBBD4A-4FDB-49E0-A5B6-22701C12BDF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9E7328DF-1924-4D0D-AC6B-1BA2D9CF1D4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9421CE10-F226-4F2C-9DA7-EBB44B73C304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "1E71FBB6-ECAD-4581-9982-4C330D55FEAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "1B631CCC-D456-49FF-B626-59C40BD4E167"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BE83F98D-F7AA-434B-8438-5B1FB96681B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "EB93F19B-9087-44CE-B884-45F434B7906F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5A88A5A3-EF1A-4E86-B074-CE0AC4325484"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "0650B4C7-BCFE-4180-8FEF-4170A67E8BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "388F376E-46C9-4163-992D-95E3E4548D0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D661090A-DA61-4BBE-85C3-6F48C053C84B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "4A458242-D6DD-46E3-AF09-66BC87C5D7A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A8FACCBA-0D3B-4E6F-85A0-1CBD2B367F71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F1D83D80-A0BE-4794-91A1-599AF558FB67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "BD15B6B2-BFB3-4271-A507-48E9B827FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "E0003042-9B14-4E1B-800F-3D154FFE8A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "E449EA29-81C8-4477-977E-746EACDBED86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6FC6D4DF-8686-4054-A0C1-784E194171E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "C574C37D-3D99-4430-A3D5-199883556B64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "F344E950-EFF9-4405-99D7-0B615C32873F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "0A50DE1B-29EB-4014-B5B6-46CF493485F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "638B3E17-9F0A-4A96-B8D3-DDFEA518DBE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6D3E3AEB-8CD4-4EE7-9C81-2F74512071DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "254FF9D9-E696-41C8-B15B-DA089D2C6597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "2A5001E1-E716-43AA-8093-E0EED9E07909"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "7FD16B13-516A-4D03-B1EF-A11156471A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E886D9EF-7FBD-4A24-A8B6-54E4B15403C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "369A83D1-AB7E-488D-9D74-26A69DFC1AD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "3189CAC1-8970-4A33-B1E4-EB9EC3C19A25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A8733438-7625-400E-8237-BAE3D9F147AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "E87F1ED0-FD0D-4767-8E7C-325D920B79BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "97811266-A13C-4441-A1B5-BFA4B0862DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "3D09D157-4B19-4561-AB20-952F2EA9BA0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "789087AF-0011-4E8F-A5AB-432A5F91BBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13b:*:*:beta:*:*:*", "matchCriteriaId": "8EC9DC8C-56DC-482B-8847-BD0CFACA6F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "F63B3D13-24F6-4EFA-9528-DBF59D973A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7F3A2388-18DE-46B0-BC13-7714E25D1B1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "940B11CB-053F-4D60-8BC4-81CA659D2F7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "83684DCB-B201-43B8-8B6E-6D0B13B7E437"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "DF92E1FD-9B41-4A41-8B13-9D789C5729D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "351D224A-E67C-454C-AF43-8AD6CD44C685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E058CA6D-A295-4CAD-8C85-E8C83BAFEBD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "FF99C114-1BCA-4400-BC7E-EDA1F55559CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BBA1EFBA-5A26-46A0-B2A6-53B9924253BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "FE5B90B0-B6CC-4189-9C98-CF29017A47B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A1818628-5F4E-4E5D-974A-0BEBCE821209"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "14785840-3BC0-4030-AE44-E3013DF19AD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "90444209-684C-4BF8-9BCF-6B29EA0A0593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "668E15DE-8CF2-4AF3-B13A-9080046B1E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "1191861C-1B2C-4762-805D-FCDC20F84D05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "3CB518E5-CCC0-46B8-848E-C492BCF7E9BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CA1F68FE-67EA-4408-8E0F-558B0FAFFF32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "66E9F05C-799A-43D3-9367-FCA86166BD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "85DB4097-6EFC-4017-ADFD-56EE49BB2F34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD283EA2-9026-497F-A7DE-E16CE0764ED0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "ED19DDDF-A29E-4C3F-A818-23D7E37B6974"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "508D0052-B7D7-4A08-8BB0-7D7A1EDAB96D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "3E50BFB0-67D3-4EDE-93FE-85EAF605461E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "D7EE0134-6AD7-4695-B536-1959FE3A9672"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "25DFFB5C-277F-4436-9BCE-643E98721C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "B8B80EB2-0B48-4AFA-8A09-26006CCDB022"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AC8705E0-23ED-4817-8B69-21A4963C27F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "BAA156A9-A9FB-4D03-B0EE-4AA303D7A9CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F733E585-075C-402A-9B34-1FE79DE4137E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "05C43439-C694-47AA-90AF-0AC2277E3D3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "B391F8A1-F102-4C88-864C-1386452CDAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "0BC33C93-9947-4983-96A3-7DE223929817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B46DE141-1224-499E-AAE0-6CC0D5249B2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "D8D07501-A07E-4743-A188-2E5BBC3C8F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "64FD2A30-EE33-4680-9DCF-29283DBA3C4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "B517F7A2-6FD1-4A7B-80E7-1167EC296591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "E6CA6EA5-DDAD-4882-AD1B-634C0CD741BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F14DCB07-9464-4DDE-98A1-FAE85DD60FBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6EDFD679-4710-4A62-B254-E658EED4295B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "A1B81072-08A5-4EC6-B737-E35C505C1E47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A0748A9E-5737-48F9-BB66-6576AFE16198"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "453E51D9-89A1-4A91-B218-05C45CC4E329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "51542BA7-8151-4FC9-9C86-36CEB476B912"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "5F95391C-0B75-47D2-9770-561E05414CEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "10384675-B949-4B50-AF42-B5A3EE27250B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "7C0DB1C0-5749-4508-A265-C2138F7852E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "CA9977CF-575C-4A19-84C8-EBB68EBE88C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "87C525C5-E282-4EC6-956F-0C94DC11FC69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "7F02A2A8-6312-4F6D-ABBF-952CA4C5E02E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "DE54D1A3-FC2A-40DE-9177-50332208B0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "170AE3DA-92C1-4D1D-9CAC-543C01FFF479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "2130C3C5-E4A5-41C3-89F0-C6FB4E47D096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "74248527-B884-4134-95C8-DEAF3D774A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta17:*:*:beta:*:*:*", "matchCriteriaId": "01A8AF9C-8BF6-4ADC-A85A-A5C1F9FFB2C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "B4038D09-467C-4815-A429-F0E1E3E545E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6F273237-7223-4047-83B7-16A49B7E554A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "CF26EE13-554C-4180-98A2-238D84E40927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "12688C9C-291D-4BF2-93F9-09AA323C52A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "A7F7A437-D538-4B44-AC41-C95641A11A35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "9BB61DCF-52DB-498D-8779-D565E548C285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "EE56BB77-B7F7-4BE7-AD9C-33888C5D01FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "9DB49E1D-BCC8-4984-A81D-5DAC5E3DF168"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "F775EA72-CCE3-4230-A666-EFDAA61F71FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5E65BDEE-850A-41C6-8CFB-BD8B3A105CD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "AF196429-FDED-4C3F-9F7D-0A2BF7DCAD1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "64B84326-5397-4C60-8007-F7E7D81DC661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "9A0A526A-9662-4E39-8BF6-E464BE1A2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "712DACC2-A21E-429F-8A7B-86D8F7CE3468"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E93F9F6-5B03-4F77-B8B4-AEC9E4011692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "C5B2B98E-804F-4525-B726-3F1DF2693F79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "582E339F-678A-4377-8EE0-8F4208E3EF78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "1BF1D945-6EAA-4FA7-8252-2FED079587F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9325DFF5-EA7B-4B8D-A227-4B1A59449CE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0ECB28DA-3CA1-4011-9170-BFBF2ED3E091"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "2A6399B0-471B-4B26-859C-3836F2A6B7D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "131E2AE4-E35D-495D-8907-3B899BB8AC41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "83601528-0DD9-4835-B6C0-0F341871CC15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4AEB5AAF-73EB-4356-8C53-10E22B2F910E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9EB199D6-E253-4EC2-BF0B-059F7B6662ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "94A586EB-B0E0-4190-88DF-3BCC04E5EF84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0BF27B44-9AA7-4B91-9B4B-0E84418F5632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "461744BD-3974-4C33-8514-0A917DC90C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6A86FB2B-6915-49C0-B993-0711AAECA5FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9EF3DD36-2776-4CD2-A3F1-88872024D223"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "D91D71ED-F08F-4DB5-B7DD-062E7C11435F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "62B5812A-FB52-4F4B-9A15-3AA5CD6562E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "83231EC0-E3F7-4E35-B165-487C2725B4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "A53AFFA6-7B98-47F2-9BD7-71C83A69CE26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A42D3FB9-9197-4101-A729-876C490BD572"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A5DE0C47-0C66-4EFE-AF82-1B22F4F54A44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "E587D10F-BEF8-4923-AF76-6DC3172880EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "155568EF-6A7E-423A-B5EA-D20E407B271B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "7E94B119-8C75-43DF-A2DF-A5B3E04F0778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5348F94F-F6AE-4400-8AC7-036111EF43D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "57948A73-C9C5-4C24-947D-0A4659C7002E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "3532EE37-2D0F-496C-B5A8-F9315FFB4552"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "2CAE7CC9-B91D-494C-B91A-497D6FE6B14B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "623BBBF8-4121-466A-82C8-D179B02B3E34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "648D010A-8B8D-42AA-8888-09E4E0FAA954"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "8ADC7613-25E3-4CB8-A962-2775C20E4D4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "1B0099F0-A275-4C65-9B79-041374F183DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "FE69800E-5CB5-4916-879C-51DE5E94489F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "8C64EAFE-2B60-4D95-869F-4A2FC98B99C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "AB2045F1-AC39-4738-B3F0-33F00D23C921"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E32589F8-2E87-40D2-BAD3-E6C1C088CA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "4868BAFD-BFE5-4361-855A-644B040E7233"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4B6C25BF-5B2A-43C4-8918-E32BA9DD8A22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "EB9917D3-D848-4D2B-8A44-B3723BA377DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "7046D95B-73CE-406B-ACC3-FD71F7DEC7CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "D3BA5033-2C06-42FF-962E-48EBA2EBB469"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "630D29DE-0FD7-4306-BA80-20D0791D334B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "08F94E42-07A1-480D-B6DD-D96AE38F1EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FA4B3DE5-21DA-4185-AF74-AAA6DD89FB3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E602BEF9-E89D-40F7-BC6F-5C6F9F25BA97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "C06A8627-683D-4328-BE7A-4A33A4B736F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E3EF8240-D3F5-422C-B70A-90C6CBA4E622"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "93CC792D-AE0B-498E-8374-5D09EF4E28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "093D4EA8-B002-4AB4-97C9-CEE4D70BF3C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "4C778180-E7BF-4EF2-8B19-0388E23E1424"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "0C0B2BC1-35F1-4A1D-B9B2-54426B4ADF34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6BCAB620-465A-41FF-A064-FB638DD3A557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "6AFCB802-A275-444C-8245-D0397322125F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9F9B70E2-AAAD-4E61-AEB2-E5F635F6AAD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6182074E-C467-448C-9299-B92CFE4EEBE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "09EA8F36-7647-42D0-8675-34C002E0754D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "9CE2276A-9680-4B14-9636-806F7E4C1669"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AD150166-4C8D-47E3-989A-1A71A46C36A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CF5CA6AD-FA4D-47DF-A684-5DAD7662EA13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "B94F75B8-7C84-4727-9D18-114A815E1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "4D94E03A-32EE-408F-81FA-4B9C25AA7DDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD495875-007C-4A90-B940-B62E6FA492CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "05F1B84E-8AF8-46E8-9DE9-00D1DE348C2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BCCEFDFB-61E6-4846-8093-B5CEB0D8450C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "0BC63647-B692-4BB9-9A3D-6F8DF19C3494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "05F0ED55-C8C6-47C1-859A-60046838B6F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "6A2D59BC-2EE8-4F9C-AB5B-B9D01B44F7CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "933DFEBC-5568-431B-809D-AFAEFD08E985"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "BE920E80-C02B-4EC8-982F-ADE89C936684"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CDAE3441-12BA-41F4-8A5A-B2EE844C86BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "1443EA1B-D210-4219-8452-CBFD5FACBC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "948A4B4A-A11F-477E-BEC5-0D60C7E3570C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "98B2A052-5427-4B72-9F59-82F430836CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "CB6D636E-B51F-4648-A637-62B2603BA18F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "3DA17871-7ED7-4D68-A46D-D15DC5B3235F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "705FE965-0415-4382-8CA1-A19DF3B5EF35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "BC6EDCE3-D564-434F-9A7F-D4A6D579F8F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "FB05E54B-9CF6-45A7-8D47-C98DB6D19E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "03CD1C5E-18F5-4C6D-B92C-C511C8C12D0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "FF4ABB9D-69DF-42D5-AD60-F9CEEC1B6730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7B4DCCF5-E290-4BDA-AAB9-DF362A2EB7B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "3AE1F3A2-8340-4ED7-B943-ACDA9617DF64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5E033AB7-9987-4C30-849F-2495376CA4F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "D87E9338-C7F6-43BA-886F-C30987ADBA1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E24EB90F-FE81-4746-8741-8DC9346F79C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "D237956F-FC90-467E-A493-24EFDA1A9F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "F7AA9AB8-AB6F-43E2-B3E5-685EE9BFE7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "5BC240A1-431E-4A50-88DC-7AC9BC674254"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "3F85AFD4-D397-4FDB-B762-521BD5FF14C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "D40CDCE1-3462-4D6C-A3C7-487F175264CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B9BBED17-A6BA-4F17-8814-8D8521F28375"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/f55e0fe7910149c431861c18ce407d1be0d6091a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/pull/20006", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-qgj5-g5vf-fm7q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/f55e0fe7910149c431861c18ce407d1be0d6091a"}}