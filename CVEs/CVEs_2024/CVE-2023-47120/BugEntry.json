{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"openssl\"\nrequire \"open-uri\"\nrequire \"multi_json\"\nrequire \"nokogiri\"\nrequire \"mustache\"\nrequire \"ostruct\"\nrequire \"cgi\"\nrequire \"net/http\"\nrequire \"digest\"\nrequire \"sanitize\"\nrequire_relative \"onebox/sanitize_config\"\n\nmodule Onebox\n  DEFAULTS = {\n    connect_timeout: 5,\n    timeout: 10,\n    max_download_kb: (10 * 1024), # 10MB\n    load_paths: [File.join(Rails.root, \"lib/onebox/templates\")],\n    allowed_ports: [80, 443],\n    allowed_schemes: %w[http https],\n    sanitize_config: SanitizeConfig::ONEBOX,\n    redirect_limit: 5,\n  }\n\n  @@options = DEFAULTS\n\n  def self.preview(url, options = Onebox.options)\n    Preview.new(url, options)\n  end\n\n  def self.check(url, options = Onebox.options)\n    StatusCheck.new(url, options)\n  end\n\n  def self.options\n    OpenStruct.new(@@options)\n  end\n\n  def self.has_matcher?(url)\n    !!Matcher.new(url).oneboxed\n  end\n\n  def self.options=(options)\n    @@options = DEFAULTS.merge(options)\n  end\nend\n\nrequire_relative \"onebox/preview\"\nrequire_relative \"onebox/status_check\"\nrequire_relative \"onebox/matcher\"\nrequire_relative \"onebox/engine\"\nrequire_relative \"onebox/layout\"\nrequire_relative \"onebox/view\"\n", "# frozen_string_literal: true\n\nrequire \"cgi\"\nrequire \"onebox/normalizer\"\nrequire \"onebox/open_graph\"\nrequire \"onebox/oembed\"\nrequire \"onebox/json_ld\"\n\nmodule Onebox\n  module Engine\n    module StandardEmbed\n      def self.oembed_providers\n        @@oembed_providers ||= {}\n      end\n\n      def self.add_oembed_provider(regexp, endpoint)\n        oembed_providers[regexp] = endpoint\n      end\n\n      def self.opengraph_providers\n        @@opengraph_providers ||= []\n      end\n\n      def self.add_opengraph_provider(regexp)\n        opengraph_providers << regexp\n      end\n\n      # Some oembed providers (like meetup.com) don't provide links to themselves\n      add_oembed_provider(%r{www\\.meetup\\.com/}, \"http://api.meetup.com/oembed\")\n      add_oembed_provider(%r{www\\.mixcloud\\.com/}, \"https://www.mixcloud.com/oembed/\")\n      # In order to support Private Videos\n      add_oembed_provider(%r{vimeo\\.com/}, \"https://vimeo.com/api/oembed.json\")\n      # NYT requires login so use oembed only\n      add_oembed_provider(%r{nytimes\\.com/}, \"https://www.nytimes.com/svc/oembed/json/\")\n\n      def always_https?\n        AllowlistedGenericOnebox.host_matches(uri, AllowlistedGenericOnebox.https_hosts) || super\n      end\n\n      def raw\n        return @raw if defined?(@raw)\n\n        @raw = {}\n\n        set_opengraph_data_on_raw\n        set_twitter_data_on_raw\n        set_oembed_data_on_raw\n        set_json_ld_data_on_raw\n        set_favicon_data_on_raw\n        set_description_on_raw\n\n        @raw\n      end\n\n      protected\n\n      def html_doc\n        return @html_doc if defined?(@html_doc)\n\n        headers = nil\n        headers = { \"Cookie\" => options[:cookie] } if options[:cookie]\n\n        @html_doc = Onebox::Helpers.fetch_html_doc(url, headers)\n      end\n\n      def get_oembed\n        @oembed ||= Onebox::Oembed.new(get_json_response)\n      end\n\n      def get_opengraph\n        @opengraph ||= ::Onebox::OpenGraph.new(html_doc)\n      end\n\n      def get_twitter\n        return {} unless html_doc\n\n        twitter = {}\n\n        html_doc\n          .css(\"meta\")\n          .each do |m|\n            if (m[\"property\"] && m[\"property\"][/^twitter:(.+)$/i]) ||\n                 (m[\"name\"] && m[\"name\"][/^twitter:(.+)$/i])\n              value = (m[\"content\"] || m[\"value\"]).to_s\n              twitter[$1.tr(\"-:\", \"_\").to_sym] ||= value if (value.present? && value != \"0 minutes\")\n            end\n          end\n\n        twitter\n      end\n\n      def get_favicon\n        return nil unless html_doc\n\n        favicon =\n          html_doc.css(\n            'link[rel=\"shortcut icon\"], link[rel=\"icon shortcut\"], link[rel=\"shortcut\"], link[rel=\"icon\"]',\n          ).first\n        favicon = favicon.nil? ? nil : (favicon[\"href\"].nil? ? nil : favicon[\"href\"].strip)\n\n        Onebox::Helpers.get_absolute_image_url(favicon, url)\n      end\n\n      def get_description\n        return nil unless html_doc\n\n        description = html_doc.at(\"meta[name='description']\").to_h[\"content\"]\n        description ||= html_doc.at(\"meta[name='Description']\").to_h[\"content\"]\n\n        description\n      end\n\n      def get_json_response\n        oembed_url = get_oembed_url\n\n        return \"{}\" if oembed_url.blank?\n\n        begin\n          Onebox::Helpers.fetch_response(oembed_url)\n        rescue StandardError\n          \"{}\"\n        end\n      rescue Errno::ECONNREFUSED, Net::HTTPError, Net::HTTPFatalError, MultiJson::LoadError\n        \"{}\"\n      end\n\n      def get_oembed_url\n        oembed_url = nil\n\n        StandardEmbed.oembed_providers.each do |regexp, endpoint|\n          if url =~ regexp\n            oembed_url = \"#{endpoint}?url=#{url}\"\n            break\n          end\n        end\n\n        if html_doc\n          if oembed_url.blank?\n            application_json = html_doc.at(\"//link[@type='application/json+oembed']/@href\")\n            oembed_url = application_json.value if application_json\n          end\n\n          if oembed_url.blank?\n            text_json = html_doc.at(\"//link[@type='text/json+oembed']/@href\")\n            oembed_url ||= text_json.value if text_json\n          end\n        end\n\n        oembed_url\n      end\n\n      def get_json_ld\n        @json_ld ||= Onebox::JsonLd.new(html_doc)\n      end\n\n      def set_from_normalizer_data(normalizer)\n        normalizer.data.each do |k, v|\n          v = normalizer.send(k)\n          @raw[k] ||= v unless v.nil?\n        end\n      end\n\n      def set_opengraph_data_on_raw\n        og = get_opengraph\n        set_from_normalizer_data(og)\n        @raw.except!(:title_attr)\n      end\n\n      def set_twitter_data_on_raw\n        twitter = get_twitter\n        twitter.each { |k, v| @raw[k] ||= v if v.present? }\n      end\n\n      def set_oembed_data_on_raw\n        oembed = get_oembed\n        set_from_normalizer_data(oembed)\n      end\n\n      def set_json_ld_data_on_raw\n        json_ld = get_json_ld\n        set_from_normalizer_data(json_ld)\n      end\n\n      def set_favicon_data_on_raw\n        favicon = get_favicon\n        @raw[:favicon] = favicon if favicon.present?\n      end\n\n      def set_description_on_raw\n        unless @raw[:description]\n          description = get_description\n          @raw[:description] = description if description.present?\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass UrlHelper\n  MAX_URL_LENGTH = 100_000\n\n  # At the moment this handles invalid URLs that browser address bar accepts\n  # where second # is not encoded\n  #\n  # Longer term we can add support of simpleidn and encode unicode domains\n  def self.relaxed_parse(url)\n    url, fragment = url.split(\"#\", 2)\n    uri = URI.parse(url)\n    if uri\n      # Addressable::URI::CharacterClasses::UNRESERVED is used here because without it\n      # the # in the fragment is not encoded\n      fragment =\n        Addressable::URI.encode_component(\n          fragment,\n          Addressable::URI::CharacterClasses::UNRESERVED,\n        ) if fragment&.include?(\"#\")\n      uri.fragment = fragment\n      uri\n    end\n  rescue URI::Error\n  end\n\n  def self.encode_and_parse(url)\n    URI.parse(Addressable::URI.encode(url))\n  end\n\n  def self.encode(url)\n    Addressable::URI.encode(url)\n  end\n\n  def self.unencode(url)\n    Addressable::URI.unencode(url)\n  end\n\n  def self.encode_component(url_component)\n    Addressable::URI.encode_component(url_component)\n  end\n\n  def self.is_local(url)\n    url.present? &&\n      (\n        Discourse.store.has_been_uploaded?(url) ||\n          !!(url =~ Regexp.new(\"^#{Discourse.base_path}/(assets|plugins|images)/\")) ||\n          url.start_with?(Discourse.asset_host || Discourse.base_url_no_prefix)\n      )\n  end\n\n  def self.absolute(url, cdn = Discourse.asset_host)\n    cdn = \"https:#{cdn}\" if cdn && cdn =~ %r{\\A//}\n    url =~ %r{\\A/[^/]} ? (cdn || Discourse.base_url_no_prefix) + url : url\n  end\n\n  def self.absolute_without_cdn(url)\n    self.absolute(url, nil)\n  end\n\n  def self.schemaless(url)\n    url.sub(/\\Ahttp:/i, \"\")\n  end\n\n  def self.secure_proxy_without_cdn(url)\n    self.absolute(Upload.secure_uploads_url_from_upload_url(url), nil)\n  end\n\n  def self.normalized_encode(uri)\n    url = uri.to_s\n\n    raise ArgumentError.new(:uri, \"URL is too long\") if url.length > MAX_URL_LENGTH\n\n    # Ideally we will jump straight to `Addressable::URI.normalized_encode`. However,\n    # that implementation has some edge-case issues like https://github.com/sporkmonger/addressable/issues/472.\n    # To temporaily work around those issues for the majority of cases, we try parsing with `::URI`.\n    # If that fails (e.g. due to non-ascii characters) then we will fall back to addressable.\n    # Hopefully we can simplify this back to `Addressable::URI.normalized_encode` in the future.\n\n    # edge case where we expect mailto:test%40test.com to normalize to mailto:test@test.com\n    return normalize_with_addressable(url) if url.match(/\\Amailto:/)\n\n    # If it doesn't pass the regexp, it's definitely not gonna parse with URI.parse. Skip\n    # to addressable\n    return normalize_with_addressable(url) if !url.match?(/\\A#{URI.regexp}\\z/)\n\n    begin\n      normalize_with_ruby_uri(url)\n    rescue URI::Error\n      normalize_with_addressable(url)\n    end\n  end\n\n  def self.rails_route_from_url(url)\n    path = URI.parse(encode(url)).path\n    Rails.application.routes.recognize_path(path)\n  rescue Addressable::URI::InvalidURIError, URI::InvalidComponentError\n    nil\n  end\n\n  def self.cook_url(url, secure: false, local: nil)\n    is_secure = SiteSetting.secure_uploads && secure\n    local = is_local(url) if local.nil?\n    return url if !local\n\n    url = is_secure ? secure_proxy_without_cdn(url) : absolute_without_cdn(url)\n\n    # we always want secure uploads to come from\n    # Discourse.base_url_no_prefix/secure-uploads\n    # to avoid asset_host mixups\n    return schemaless(url) if is_secure\n\n    # PERF: avoid parsing url except for extreme conditions\n    # this is a hot path used on home page\n    filename = url\n    if url.include?(\"?\")\n      uri = URI.parse(url)\n      filename = File.basename(uri.path)\n    end\n\n    # this technically requires a filename, but will work with a URL as long as it end with the\n    # extension and has no query params\n    is_attachment = !FileHelper.is_supported_media?(filename)\n\n    no_cdn = SiteSetting.login_required || SiteSetting.prevent_anons_from_downloading_files\n    unless is_attachment && no_cdn\n      url = Discourse.store.cdn_url(url)\n      url = local_cdn_url(url) if Discourse.store.external?\n    end\n\n    schemaless(url)\n  rescue URI::Error\n    url\n  end\n\n  def self.local_cdn_url(url)\n    return url if Discourse.asset_host.blank?\n    if url.start_with?(\"/#{Discourse.store.upload_path}/\")\n      \"#{Discourse.asset_host}#{url}\"\n    else\n      url.sub(Discourse.base_url_no_prefix, Discourse.asset_host)\n    end\n  end\n\n  private\n\n  def self.normalize_with_addressable(url)\n    u = Addressable::URI.normalized_encode(url, Addressable::URI)\n\n    u.host = ::Addressable::IDNA.to_ascii(u.host) if u.host && !u.host.ascii_only?\n\n    u.to_s\n  end\n\n  def self.normalize_with_ruby_uri(url)\n    u = URI.parse(url)\n\n    u.scheme = u.scheme.downcase if u.scheme && u.scheme != u.scheme.downcase\n\n    u.host = u.host.downcase if u.host && u.host != u.host.downcase\n\n    u.to_s\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe Onebox::Engine::StandardEmbed do\n  let(:host_class) do\n    Class.new do\n      include Onebox::Engine::StandardEmbed\n\n      def options\n        {}\n      end\n\n      def url\n        \"\"\n      end\n    end\n  end\n  let(:instance) { host_class.new }\n\n  describe \"#raw\" do\n    it \"does not set title_attr from opengraph data\" do\n      Onebox::Helpers.stubs(fetch_html_doc: nil)\n      Onebox::OpenGraph\n        .any_instance\n        .stubs(:data)\n        .returns({ description: \"description\", title_attr: \"should not be returned\" })\n      Onebox::Oembed.any_instance.stubs(:data).returns({})\n\n      expect(instance.raw).to eq({ description: \"description\" })\n    end\n\n    it \"sets twitter data\" do\n      html_doc = mocked_html_doc(twitter_data: { \"name\" => \"twitter:url\", \"content\" => \"cool.url\" })\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ url: \"cool.url\" })\n    end\n\n    it \"does not override data with twitter data\" do\n      html_doc =\n        mocked_html_doc(\n          twitter_data: {\n            \"name\" => \"twitter:title\",\n            \"content\" => \"i do not want to override\",\n          },\n        )\n      Onebox::OpenGraph\n        .any_instance\n        .stubs(:data)\n        .returns({ description: \"description\", title: \"do not override me\" })\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ description: \"description\", title: \"do not override me\" })\n    end\n\n    it \"does not override data with oembed data\" do\n      Onebox::Oembed.any_instance.stubs(:data).returns({ title: \"i do not want to override\" })\n      html_doc =\n        mocked_html_doc(\n          twitter_data: {\n            \"name\" => \"twitter:title\",\n            \"content\" => \"do not override me\",\n          },\n        )\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ title: \"do not override me\" })\n    end\n\n    it \"sets oembed data\" do\n      Onebox::Helpers.stubs(fetch_html_doc: nil)\n      Onebox::Oembed.any_instance.stubs(:data).returns({ description: \"description\" })\n\n      expect(instance.raw).to eq({ description: \"description\" })\n    end\n\n    it \"does not override data with json_ld data\" do\n      Onebox::Helpers.stubs(fetch_html_doc: nil)\n      Onebox::JsonLd.any_instance.stubs(:data).returns({ title: \"i do not want to override\" })\n      Onebox::Oembed.any_instance.stubs(:data).returns({ title: \"do not override me\" })\n\n      expect(instance.raw).to eq({ title: \"do not override me\" })\n    end\n  end\n\n  private\n\n  def mocked_html_doc(twitter_data: nil)\n    html_doc = mock\n    html_doc.stubs(at_css: nil, at: nil)\n    stub_twitter(html_doc, twitter_data)\n    stub_favicon(html_doc)\n    stub_json_ld\n    html_doc\n  end\n\n  def stub_twitter(html_doc, twitter_data = [])\n    html_doc.expects(:css).with(\"meta\").at_least_once.returns([twitter_data])\n  end\n\n  def stub_favicon(html_doc)\n    html_doc\n      .stubs(:css)\n      .with(\n        'link[rel=\"shortcut icon\"], link[rel=\"icon shortcut\"], link[rel=\"shortcut\"], link[rel=\"icon\"]',\n      )\n      .returns([])\n  end\n\n  def stub_json_ld\n    normalizer = mock\n    normalizer.stubs(:data).returns([])\n    Onebox::JsonLd.stubs(new: normalizer)\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe UrlHelper do\n  describe \"#relaxed parse\" do\n    it \"can handle double #\" do\n      url = UrlHelper.relaxed_parse(\"https://test.com#test#test\")\n      expect(url.to_s).to eq(\"https://test.com#test%23test\")\n    end\n  end\n\n  describe \"#is_local\" do\n    it \"is true when the file has been uploaded\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(true)\n      Discourse.stubs(:store).returns(store)\n      expect(UrlHelper.is_local(\"http://discuss.site.com/path/to/file.png\")).to eq(true)\n    end\n\n    it \"is true for relative assets\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(false)\n      Discourse.stubs(:store).returns(store)\n      expect(UrlHelper.is_local(\"/assets/javascripts/all.js\")).to eq(true)\n    end\n\n    it \"is true for relative assets for subfolders\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(false)\n      Discourse.stubs(:store).returns(store)\n\n      set_subfolder \"/subpath\"\n      expect(UrlHelper.is_local(\"/subpath/assets/javascripts/all.js\")).to eq(true)\n    end\n\n    it \"is true for plugin assets\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(false)\n      Discourse.stubs(:store).returns(store)\n      expect(UrlHelper.is_local(\"/plugins/all.js\")).to eq(true)\n    end\n  end\n\n  describe \"#absolute\" do\n    it \"returns an absolute URL for CDN\" do\n      begin\n        Rails.configuration.action_controller.asset_host = \"//cdn.awesome.com\"\n        expect(UrlHelper.absolute(\"/test.jpg\")).to eq(\"https://cdn.awesome.com/test.jpg\")\n\n        Rails.configuration.action_controller.asset_host = \"https://cdn.awesome.com\"\n        expect(UrlHelper.absolute(\"/test.jpg\")).to eq(\"https://cdn.awesome.com/test.jpg\")\n\n        Rails.configuration.action_controller.asset_host = \"http://cdn.awesome.com\"\n        expect(UrlHelper.absolute(\"/test.jpg\")).to eq(\"http://cdn.awesome.com/test.jpg\")\n      ensure\n        Rails.configuration.action_controller.asset_host = nil\n      end\n    end\n\n    it \"does not change non-relative url\" do\n      expect(UrlHelper.absolute(\"http://www.discourse.org\")).to eq(\"http://www.discourse.org\")\n    end\n\n    it \"changes a relative url to an absolute one using base url by default\" do\n      expect(UrlHelper.absolute(\"/path/to/file\")).to eq(\"http://test.localhost/path/to/file\")\n    end\n\n    it \"changes a relative url to an absolute one using the cdn when enabled\" do\n      Rails.configuration.action_controller.stubs(:asset_host).returns(\"http://my.cdn.com\")\n      expect(UrlHelper.absolute(\"/path/to/file\")).to eq(\"http://my.cdn.com/path/to/file\")\n    end\n  end\n\n  describe \"#absolute_without_cdn\" do\n    it \"changes a relative url to an absolute one using base url even when cdn is enabled\" do\n      Rails.configuration.action_controller.stubs(:asset_host).returns(\"http://my.cdn.com\")\n      expect(UrlHelper.absolute_without_cdn(\"/path/to/file\")).to eq(\n        \"http://test.localhost/path/to/file\",\n      )\n    end\n  end\n\n  describe \"#schemaless\" do\n    it \"removes http schemas only\" do\n      expect(UrlHelper.schemaless(\"http://www.discourse.org\")).to eq(\"//www.discourse.org\")\n      expect(UrlHelper.schemaless(\"https://secure.discourse.org\")).to eq(\n        \"https://secure.discourse.org\",\n      )\n      expect(UrlHelper.schemaless(\"ftp://ftp.discourse.org\")).to eq(\"ftp://ftp.discourse.org\")\n    end\n  end\n\n  describe \"#normalized_encode\" do\n    it \"does not double escape %3A (:)\" do\n      url = \"http://discourse.org/%3A/test\"\n      expect(UrlHelper.normalized_encode(url)).to eq(url)\n    end\n\n    it \"does not double escape %2F (/)\" do\n      url = \"http://discourse.org/%2F/test\"\n      expect(UrlHelper.normalized_encode(url)).to eq(url)\n    end\n\n    it \"doesn't escape simple URL\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/foo/bar\")\n      expect(url).to eq(\"http://example.com/foo/bar\")\n    end\n\n    it \"escapes unsafe chars\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/?a=\\11\\15\")\n      expect(url).to eq(\"http://example.com/?a=%09%0D\")\n    end\n\n    it \"escapes non-ascii chars\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/\u0645\u0627\u0647\u06cc\")\n      expect(url).to eq(\"http://example.com/%D9%85%D8%A7%D9%87%DB%8C\")\n    end\n\n    it \"doesn't escape already escaped chars (space)\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/foo%20bar/foo bar/\")\n      expect(url).to eq(\"http://example.com/foo%20bar/foo%20bar/\")\n    end\n\n    it \"doesn't escape already escaped chars (hash)\" do\n      url =\n        \"https://calendar.google.com/calendar/embed?src=en.uk%23holiday@group.v.calendar.google.com&ctz=Europe%2FLondon\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(url)\n    end\n\n    it \"leaves reserved chars alone in edge cases\" do\n      skip \"see: https://github.com/sporkmonger/addressable/issues/472\"\n      url = \"https://example.com/ article/id%3A1.2%2F1/bar\"\n      expected = \"https://example.com/%20article/id%3A1.2%2F1/bar\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(expected)\n    end\n\n    it \"handles emoji domain names\" do\n      url = \"https://\ud83d\udcbb.example/\ud83d\udcbb?computer=\ud83d\udcbb\"\n      expected = \"https://xn--3s8h.example/%F0%9F%92%BB?computer=%F0%9F%92%BB\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(expected)\n    end\n\n    it \"handles special-character domain names\" do\n      url = \"https://\u00e9xample.com/test\"\n      expected = \"https://xn--xample-9ua.com/test\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(expected)\n    end\n\n    it \"performs basic normalization\" do\n      url = \"http://EXAMPLE.com/a\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(\"http://example.com/a\")\n    end\n\n    it \"doesn't escape S3 presigned URLs\" do\n      # both of these were originally real presigned URLs and have had all\n      # sensitive information stripped\n      presigned_url =\n        \"https://test.com/original/3X/b/5/575bcc2886bf7a39684b57ca90be85f7d399bbc7.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AK8888999977%2F20200130%2Fus-west-1%2Fs3%2Faws4_request&X-Amz-Date=20200130T064355Z&X-Amz-Expires=15&X-Amz-SignedHeaders=host&X-Amz-Security-Token=blahblah%2Bblahblah%2Fblah%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAR&X-Amz-Signature=test\"\n      encoded_presigned_url =\n        \"https://test.com/original/3X/b/5/575bcc2886bf7a39684b57ca90be85f7d399bbc7.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AK8888999977/20200130/us-west-1/s3/aws4_request&X-Amz-Date=20200130T064355Z&X-Amz-Expires=15&X-Amz-SignedHeaders=host&X-Amz-Security-Token=blahblah+blahblah/blah//////////wEQA==&X-Amz-Signature=test\"\n      expect(UrlHelper.normalized_encode(presigned_url)).not_to eq(encoded_presigned_url)\n    end\n\n    it \"raises error if too long\" do\n      expect do UrlHelper.normalized_encode(\"https://#{\"a\" * 100_000}.com\") end.to raise_error(\n        ArgumentError,\n      )\n    end\n  end\n\n  describe \"#local_cdn_url\" do\n    let(:url) { \"/#{Discourse.store.upload_path}/1X/575bcc2886bf7a39684b57ca90be85f7d399bbc7.png\" }\n    let(:asset_host) { \"//my.awesome.cdn\" }\n\n    it \"should return correct cdn url for local relative urls\" do\n      set_cdn_url asset_host\n      cdn_url = UrlHelper.local_cdn_url(url)\n      expect(cdn_url).to eq(\"#{asset_host}#{url}\")\n    end\n  end\n\n  describe \"#rails_route_from_url\" do\n    it \"recognizes a user path\" do\n      result = UrlHelper.rails_route_from_url(\"http://example.com/u/john_smith\")\n      expect(result[:controller]).to eq(\"users\")\n      expect(result[:action]).to eq(\"show\")\n      expect(result[:username]).to eq(\"john_smith\")\n    end\n\n    it \"recognizes a user path with unicode characters in the username\" do\n      result = UrlHelper.rails_route_from_url(\"http://example.com/u/bj\u00f6rn_ulvaeus\")\n      expect(result[:controller]).to eq(\"users\")\n      expect(result[:action]).to eq(\"show\")\n      expect(result[:username].force_encoding(\"UTF-8\")).to eq(\"bj\u00f6rn_ulvaeus\")\n    end\n  end\n\n  describe \"#cook_url\" do\n    let(:url) do\n      \"//s3bucket.s3.dualstack.us-west-1.amazonaws.com/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\"\n    end\n\n    before do\n      setup_s3\n      SiteSetting.s3_upload_bucket = \"s3bucket\"\n      SiteSetting.login_required = true\n      Rails.configuration.action_controller.asset_host = \"https://test.some-cdn.com/dev\"\n\n      FileStore::S3Store.any_instance.stubs(:has_been_uploaded?).returns(true)\n\n      SiteSetting.secure_uploads = true\n    end\n\n    def cooked\n      UrlHelper.cook_url(url, secure: secure)\n    end\n\n    context \"when the upload for the url is secure\" do\n      let(:secure) { true }\n\n      it \"returns the secure_proxy_without_cdn url, with no asset host URL change\" do\n        expect(cooked).to eq(\n          \"//test.localhost/secure-uploads/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\",\n        )\n      end\n\n      context \"when secure_uploads setting is disabled\" do\n        before { SiteSetting.secure_uploads = false }\n\n        it \"returns the local_cdn_url\" do\n          expect(cooked).to eq(\n            \"//s3bucket.s3.dualstack.us-west-1.amazonaws.com/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\",\n          )\n        end\n      end\n    end\n\n    context \"when the upload for the url is not secure\" do\n      let(:secure) { false }\n\n      it \"returns the local_cdn_url\" do\n        expect(cooked).to eq(\n          \"//s3bucket.s3.dualstack.us-west-1.amazonaws.com/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\",\n        )\n      end\n    end\n\n    after { Rails.configuration.action_controller.asset_host = nil }\n  end\n\n  describe \"rails_route_from_url\" do\n    it \"returns a rails route from the path\" do\n      expect(described_class.rails_route_from_url(\"/u\")).to eq(\n        { controller: \"users\", action: \"index\" },\n      )\n    end\n\n    it \"does not raise for invalid URLs\" do\n      url = \"http://URL:%20https://google.com\"\n      expect(described_class.rails_route_from_url(url)).to eq(nil)\n    end\n\n    it \"does not raise for invalid mailtos\" do\n      url = \"mailto:eviltrout%2540example.com\"\n      expect(described_class.rails_route_from_url(url)).to eq(nil)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"openssl\"\nrequire \"open-uri\"\nrequire \"multi_json\"\nrequire \"nokogiri\"\nrequire \"mustache\"\nrequire \"ostruct\"\nrequire \"cgi\"\nrequire \"net/http\"\nrequire \"digest\"\nrequire \"sanitize\"\nrequire_relative \"onebox/sanitize_config\"\n\nmodule Onebox\n  DEFAULTS = {\n    connect_timeout: 5,\n    timeout: 10,\n    max_download_kb: 2048, # 2MB\n    load_paths: [File.join(Rails.root, \"lib/onebox/templates\")],\n    allowed_ports: [80, 443],\n    allowed_schemes: %w[http https],\n    sanitize_config: SanitizeConfig::ONEBOX,\n    redirect_limit: 5,\n  }\n\n  @@options = DEFAULTS\n\n  def self.preview(url, options = Onebox.options)\n    Preview.new(url, options)\n  end\n\n  def self.check(url, options = Onebox.options)\n    StatusCheck.new(url, options)\n  end\n\n  def self.options\n    OpenStruct.new(@@options)\n  end\n\n  def self.has_matcher?(url)\n    !!Matcher.new(url).oneboxed\n  end\n\n  def self.options=(options)\n    @@options = DEFAULTS.merge(options)\n  end\nend\n\nrequire_relative \"onebox/preview\"\nrequire_relative \"onebox/status_check\"\nrequire_relative \"onebox/matcher\"\nrequire_relative \"onebox/engine\"\nrequire_relative \"onebox/layout\"\nrequire_relative \"onebox/view\"\n", "# frozen_string_literal: true\n\nrequire \"cgi\"\nrequire \"onebox/normalizer\"\nrequire \"onebox/open_graph\"\nrequire \"onebox/oembed\"\nrequire \"onebox/json_ld\"\n\nmodule Onebox\n  module Engine\n    module StandardEmbed\n      def self.oembed_providers\n        @@oembed_providers ||= {}\n      end\n\n      def self.add_oembed_provider(regexp, endpoint)\n        oembed_providers[regexp] = endpoint\n      end\n\n      def self.opengraph_providers\n        @@opengraph_providers ||= []\n      end\n\n      def self.add_opengraph_provider(regexp)\n        opengraph_providers << regexp\n      end\n\n      # Some oembed providers (like meetup.com) don't provide links to themselves\n      add_oembed_provider(%r{www\\.meetup\\.com/}, \"http://api.meetup.com/oembed\")\n      add_oembed_provider(%r{www\\.mixcloud\\.com/}, \"https://www.mixcloud.com/oembed/\")\n      # In order to support Private Videos\n      add_oembed_provider(%r{vimeo\\.com/}, \"https://vimeo.com/api/oembed.json\")\n      # NYT requires login so use oembed only\n      add_oembed_provider(%r{nytimes\\.com/}, \"https://www.nytimes.com/svc/oembed/json/\")\n\n      def always_https?\n        AllowlistedGenericOnebox.host_matches(uri, AllowlistedGenericOnebox.https_hosts) || super\n      end\n\n      def raw\n        return @raw if defined?(@raw)\n\n        @raw = {}\n\n        set_opengraph_data_on_raw\n        set_twitter_data_on_raw\n        set_oembed_data_on_raw\n        set_json_ld_data_on_raw\n        set_favicon_data_on_raw\n        set_description_on_raw\n\n        @raw\n      end\n\n      protected\n\n      def html_doc\n        return @html_doc if defined?(@html_doc)\n\n        headers = nil\n        headers = { \"Cookie\" => options[:cookie] } if options[:cookie]\n\n        @html_doc = Onebox::Helpers.fetch_html_doc(url, headers)\n      end\n\n      def get_oembed\n        @oembed ||= Onebox::Oembed.new(get_json_response)\n      end\n\n      def get_opengraph\n        @opengraph ||= ::Onebox::OpenGraph.new(html_doc)\n      end\n\n      def get_twitter\n        return {} unless html_doc\n\n        twitter = {}\n\n        html_doc\n          .css(\"meta\")\n          .each do |m|\n            if (m[\"property\"] && m[\"property\"][/^twitter:(.+)$/i]) ||\n                 (m[\"name\"] && m[\"name\"][/^twitter:(.+)$/i])\n              value = (m[\"content\"] || m[\"value\"]).to_s\n              twitter[$1.tr(\"-:\", \"_\").to_sym] ||= value if (value.present? && value != \"0 minutes\")\n            end\n          end\n\n        twitter\n      end\n\n      def get_favicon\n        return nil unless html_doc\n\n        favicon =\n          html_doc.css(\n            'link[rel=\"shortcut icon\"], link[rel=\"icon shortcut\"], link[rel=\"shortcut\"], link[rel=\"icon\"]',\n          ).first\n        favicon = favicon.nil? ? nil : (favicon[\"href\"].nil? ? nil : favicon[\"href\"].strip)\n\n        return nil if favicon.blank?\n\n        absolute_url = Onebox::Helpers.get_absolute_image_url(favicon, url)\n\n        return nil if absolute_url.length > UrlHelper::MAX_URL_LENGTH\n\n        absolute_url\n      end\n\n      def get_description\n        return nil unless html_doc\n\n        description = html_doc.at(\"meta[name='description']\").to_h[\"content\"]\n        description ||= html_doc.at(\"meta[name='Description']\").to_h[\"content\"]\n\n        description\n      end\n\n      def get_json_response\n        oembed_url = get_oembed_url\n\n        return \"{}\" if oembed_url.blank?\n\n        begin\n          Onebox::Helpers.fetch_response(oembed_url)\n        rescue StandardError\n          \"{}\"\n        end\n      rescue Errno::ECONNREFUSED, Net::HTTPError, Net::HTTPFatalError, MultiJson::LoadError\n        \"{}\"\n      end\n\n      def get_oembed_url\n        oembed_url = nil\n\n        StandardEmbed.oembed_providers.each do |regexp, endpoint|\n          if url =~ regexp\n            oembed_url = \"#{endpoint}?url=#{url}\"\n            break\n          end\n        end\n\n        if html_doc\n          if oembed_url.blank?\n            application_json = html_doc.at(\"//link[@type='application/json+oembed']/@href\")\n            oembed_url = application_json.value if application_json\n          end\n\n          if oembed_url.blank?\n            text_json = html_doc.at(\"//link[@type='text/json+oembed']/@href\")\n            oembed_url ||= text_json.value if text_json\n          end\n        end\n\n        oembed_url\n      end\n\n      def get_json_ld\n        @json_ld ||= Onebox::JsonLd.new(html_doc)\n      end\n\n      def set_from_normalizer_data(normalizer)\n        normalizer.data.each do |k, v|\n          v = normalizer.send(k)\n          @raw[k] ||= v unless v.nil?\n        end\n      end\n\n      def set_opengraph_data_on_raw\n        og = get_opengraph\n        set_from_normalizer_data(og)\n        @raw.except!(:title_attr)\n      end\n\n      def set_twitter_data_on_raw\n        twitter = get_twitter\n        twitter.each { |k, v| @raw[k] ||= v if v.present? }\n      end\n\n      def set_oembed_data_on_raw\n        oembed = get_oembed\n        set_from_normalizer_data(oembed)\n      end\n\n      def set_json_ld_data_on_raw\n        json_ld = get_json_ld\n        set_from_normalizer_data(json_ld)\n      end\n\n      def set_favicon_data_on_raw\n        favicon = get_favicon\n        @raw[:favicon] = favicon if favicon.present?\n      end\n\n      def set_description_on_raw\n        unless @raw[:description]\n          description = get_description\n          @raw[:description] = description if description.present?\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass UrlHelper\n  MAX_URL_LENGTH = 2_000\n\n  # At the moment this handles invalid URLs that browser address bar accepts\n  # where second # is not encoded\n  #\n  # Longer term we can add support of simpleidn and encode unicode domains\n  def self.relaxed_parse(url)\n    url, fragment = url.split(\"#\", 2)\n    uri = URI.parse(url)\n    if uri\n      # Addressable::URI::CharacterClasses::UNRESERVED is used here because without it\n      # the # in the fragment is not encoded\n      fragment =\n        Addressable::URI.encode_component(\n          fragment,\n          Addressable::URI::CharacterClasses::UNRESERVED,\n        ) if fragment&.include?(\"#\")\n      uri.fragment = fragment\n      uri\n    end\n  rescue URI::Error\n  end\n\n  def self.encode_and_parse(url)\n    URI.parse(Addressable::URI.encode(url))\n  end\n\n  def self.encode(url)\n    Addressable::URI.encode(url)\n  end\n\n  def self.unencode(url)\n    Addressable::URI.unencode(url)\n  end\n\n  def self.encode_component(url_component)\n    Addressable::URI.encode_component(url_component)\n  end\n\n  def self.is_local(url)\n    url.present? &&\n      (\n        Discourse.store.has_been_uploaded?(url) ||\n          !!(url =~ Regexp.new(\"^#{Discourse.base_path}/(assets|plugins|images)/\")) ||\n          url.start_with?(Discourse.asset_host || Discourse.base_url_no_prefix)\n      )\n  end\n\n  def self.absolute(url, cdn = Discourse.asset_host)\n    cdn = \"https:#{cdn}\" if cdn && cdn =~ %r{\\A//}\n    url =~ %r{\\A/[^/]} ? (cdn || Discourse.base_url_no_prefix) + url : url\n  end\n\n  def self.absolute_without_cdn(url)\n    self.absolute(url, nil)\n  end\n\n  def self.schemaless(url)\n    url.sub(/\\Ahttp:/i, \"\")\n  end\n\n  def self.secure_proxy_without_cdn(url)\n    self.absolute(Upload.secure_uploads_url_from_upload_url(url), nil)\n  end\n\n  def self.normalized_encode(uri)\n    url = uri.to_s\n\n    raise ArgumentError.new(:uri, \"URL is too long\") if url.length > MAX_URL_LENGTH\n\n    # Ideally we will jump straight to `Addressable::URI.normalized_encode`. However,\n    # that implementation has some edge-case issues like https://github.com/sporkmonger/addressable/issues/472.\n    # To temporaily work around those issues for the majority of cases, we try parsing with `::URI`.\n    # If that fails (e.g. due to non-ascii characters) then we will fall back to addressable.\n    # Hopefully we can simplify this back to `Addressable::URI.normalized_encode` in the future.\n\n    # edge case where we expect mailto:test%40test.com to normalize to mailto:test@test.com\n    return normalize_with_addressable(url) if url.match(/\\Amailto:/)\n\n    # If it doesn't pass the regexp, it's definitely not gonna parse with URI.parse. Skip\n    # to addressable\n    return normalize_with_addressable(url) if !url.match?(/\\A#{URI.regexp}\\z/)\n\n    begin\n      normalize_with_ruby_uri(url)\n    rescue URI::Error\n      normalize_with_addressable(url)\n    end\n  end\n\n  def self.rails_route_from_url(url)\n    path = URI.parse(encode(url)).path\n    Rails.application.routes.recognize_path(path)\n  rescue Addressable::URI::InvalidURIError, URI::InvalidComponentError\n    nil\n  end\n\n  def self.cook_url(url, secure: false, local: nil)\n    is_secure = SiteSetting.secure_uploads && secure\n    local = is_local(url) if local.nil?\n    return url if !local\n\n    url = is_secure ? secure_proxy_without_cdn(url) : absolute_without_cdn(url)\n\n    # we always want secure uploads to come from\n    # Discourse.base_url_no_prefix/secure-uploads\n    # to avoid asset_host mixups\n    return schemaless(url) if is_secure\n\n    # PERF: avoid parsing url except for extreme conditions\n    # this is a hot path used on home page\n    filename = url\n    if url.include?(\"?\")\n      uri = URI.parse(url)\n      filename = File.basename(uri.path)\n    end\n\n    # this technically requires a filename, but will work with a URL as long as it end with the\n    # extension and has no query params\n    is_attachment = !FileHelper.is_supported_media?(filename)\n\n    no_cdn = SiteSetting.login_required || SiteSetting.prevent_anons_from_downloading_files\n    unless is_attachment && no_cdn\n      url = Discourse.store.cdn_url(url)\n      url = local_cdn_url(url) if Discourse.store.external?\n    end\n\n    schemaless(url)\n  rescue URI::Error\n    url\n  end\n\n  def self.local_cdn_url(url)\n    return url if Discourse.asset_host.blank?\n    if url.start_with?(\"/#{Discourse.store.upload_path}/\")\n      \"#{Discourse.asset_host}#{url}\"\n    else\n      url.sub(Discourse.base_url_no_prefix, Discourse.asset_host)\n    end\n  end\n\n  private\n\n  def self.normalize_with_addressable(url)\n    u = Addressable::URI.normalized_encode(url, Addressable::URI)\n\n    u.host = ::Addressable::IDNA.to_ascii(u.host) if u.host && !u.host.ascii_only?\n\n    u.to_s\n  end\n\n  def self.normalize_with_ruby_uri(url)\n    u = URI.parse(url)\n\n    u.scheme = u.scheme.downcase if u.scheme && u.scheme != u.scheme.downcase\n\n    u.host = u.host.downcase if u.host && u.host != u.host.downcase\n\n    u.to_s\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe Onebox::Engine::StandardEmbed do\n  let(:host_class) do\n    Class.new do\n      include Onebox::Engine::StandardEmbed\n\n      def options\n        {}\n      end\n\n      def url\n        \"\"\n      end\n    end\n  end\n  let(:instance) { host_class.new }\n\n  describe \"#raw\" do\n    it \"does not set title_attr from opengraph data\" do\n      Onebox::Helpers.stubs(fetch_html_doc: nil)\n      Onebox::OpenGraph\n        .any_instance\n        .stubs(:data)\n        .returns({ description: \"description\", title_attr: \"should not be returned\" })\n      Onebox::Oembed.any_instance.stubs(:data).returns({})\n\n      expect(instance.raw).to eq({ description: \"description\" })\n    end\n\n    it \"sets twitter data\" do\n      html_doc = mocked_html_doc(twitter_data: { \"name\" => \"twitter:url\", \"content\" => \"cool.url\" })\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ url: \"cool.url\" })\n    end\n\n    it \"does not override data with twitter data\" do\n      html_doc =\n        mocked_html_doc(\n          twitter_data: {\n            \"name\" => \"twitter:title\",\n            \"content\" => \"i do not want to override\",\n          },\n        )\n      Onebox::OpenGraph\n        .any_instance\n        .stubs(:data)\n        .returns({ description: \"description\", title: \"do not override me\" })\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ description: \"description\", title: \"do not override me\" })\n    end\n\n    it \"does not override data with oembed data\" do\n      Onebox::Oembed.any_instance.stubs(:data).returns({ title: \"i do not want to override\" })\n      html_doc =\n        mocked_html_doc(\n          twitter_data: {\n            \"name\" => \"twitter:title\",\n            \"content\" => \"do not override me\",\n          },\n        )\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ title: \"do not override me\" })\n    end\n\n    it \"sets favicon URL\" do\n      html_doc =\n        mocked_html_doc(\n          twitter_data: {\n            \"name\" => \"twitter:url\",\n            \"content\" => \"cool.url\",\n          },\n          favicon_url: \"https://favicon.co/default.ico\",\n        )\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ url: \"cool.url\", favicon: \"https://favicon.co/default.ico\" })\n    end\n\n    it \"ignores suspiciously long favicon URLs\" do\n      html_doc =\n        mocked_html_doc(\n          twitter_data: {\n            \"name\" => \"twitter:url\",\n            \"content\" => \"cool.url\",\n          },\n          favicon_url: \"https://favicon.co/#{\"a\" * 2_000}.ico\",\n        )\n      Onebox::Helpers.stubs(fetch_html_doc: html_doc)\n\n      expect(instance.raw).to eq({ url: \"cool.url\" })\n    end\n\n    it \"sets oembed data\" do\n      Onebox::Helpers.stubs(fetch_html_doc: nil)\n      Onebox::Oembed.any_instance.stubs(:data).returns({ description: \"description\" })\n\n      expect(instance.raw).to eq({ description: \"description\" })\n    end\n\n    it \"does not override data with json_ld data\" do\n      Onebox::Helpers.stubs(fetch_html_doc: nil)\n      Onebox::JsonLd.any_instance.stubs(:data).returns({ title: \"i do not want to override\" })\n      Onebox::Oembed.any_instance.stubs(:data).returns({ title: \"do not override me\" })\n\n      expect(instance.raw).to eq({ title: \"do not override me\" })\n    end\n  end\n\n  private\n\n  def mocked_html_doc(twitter_data: nil, favicon_url: nil)\n    html_doc = mock\n    html_doc.stubs(at_css: nil, at: nil)\n    stub_twitter(html_doc, twitter_data)\n    stub_favicon(html_doc, favicon_url)\n    stub_json_ld\n    html_doc\n  end\n\n  def stub_twitter(html_doc, twitter_data = [])\n    html_doc.expects(:css).with(\"meta\").at_least_once.returns([twitter_data])\n  end\n\n  def stub_favicon(html_doc, favicon_url = nil)\n    html_doc\n      .stubs(:css)\n      .with(\n        'link[rel=\"shortcut icon\"], link[rel=\"icon shortcut\"], link[rel=\"shortcut\"], link[rel=\"icon\"]',\n      )\n      .returns([{ \"href\" => favicon_url }.compact])\n  end\n\n  def stub_json_ld\n    normalizer = mock\n    normalizer.stubs(:data).returns([])\n    Onebox::JsonLd.stubs(new: normalizer)\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe UrlHelper do\n  describe \"#relaxed parse\" do\n    it \"can handle double #\" do\n      url = UrlHelper.relaxed_parse(\"https://test.com#test#test\")\n      expect(url.to_s).to eq(\"https://test.com#test%23test\")\n    end\n  end\n\n  describe \"#is_local\" do\n    it \"is true when the file has been uploaded\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(true)\n      Discourse.stubs(:store).returns(store)\n      expect(UrlHelper.is_local(\"http://discuss.site.com/path/to/file.png\")).to eq(true)\n    end\n\n    it \"is true for relative assets\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(false)\n      Discourse.stubs(:store).returns(store)\n      expect(UrlHelper.is_local(\"/assets/javascripts/all.js\")).to eq(true)\n    end\n\n    it \"is true for relative assets for subfolders\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(false)\n      Discourse.stubs(:store).returns(store)\n\n      set_subfolder \"/subpath\"\n      expect(UrlHelper.is_local(\"/subpath/assets/javascripts/all.js\")).to eq(true)\n    end\n\n    it \"is true for plugin assets\" do\n      store = stub\n      store.expects(:has_been_uploaded?).returns(false)\n      Discourse.stubs(:store).returns(store)\n      expect(UrlHelper.is_local(\"/plugins/all.js\")).to eq(true)\n    end\n  end\n\n  describe \"#absolute\" do\n    it \"returns an absolute URL for CDN\" do\n      begin\n        Rails.configuration.action_controller.asset_host = \"//cdn.awesome.com\"\n        expect(UrlHelper.absolute(\"/test.jpg\")).to eq(\"https://cdn.awesome.com/test.jpg\")\n\n        Rails.configuration.action_controller.asset_host = \"https://cdn.awesome.com\"\n        expect(UrlHelper.absolute(\"/test.jpg\")).to eq(\"https://cdn.awesome.com/test.jpg\")\n\n        Rails.configuration.action_controller.asset_host = \"http://cdn.awesome.com\"\n        expect(UrlHelper.absolute(\"/test.jpg\")).to eq(\"http://cdn.awesome.com/test.jpg\")\n      ensure\n        Rails.configuration.action_controller.asset_host = nil\n      end\n    end\n\n    it \"does not change non-relative url\" do\n      expect(UrlHelper.absolute(\"http://www.discourse.org\")).to eq(\"http://www.discourse.org\")\n    end\n\n    it \"changes a relative url to an absolute one using base url by default\" do\n      expect(UrlHelper.absolute(\"/path/to/file\")).to eq(\"http://test.localhost/path/to/file\")\n    end\n\n    it \"changes a relative url to an absolute one using the cdn when enabled\" do\n      Rails.configuration.action_controller.stubs(:asset_host).returns(\"http://my.cdn.com\")\n      expect(UrlHelper.absolute(\"/path/to/file\")).to eq(\"http://my.cdn.com/path/to/file\")\n    end\n  end\n\n  describe \"#absolute_without_cdn\" do\n    it \"changes a relative url to an absolute one using base url even when cdn is enabled\" do\n      Rails.configuration.action_controller.stubs(:asset_host).returns(\"http://my.cdn.com\")\n      expect(UrlHelper.absolute_without_cdn(\"/path/to/file\")).to eq(\n        \"http://test.localhost/path/to/file\",\n      )\n    end\n  end\n\n  describe \"#schemaless\" do\n    it \"removes http schemas only\" do\n      expect(UrlHelper.schemaless(\"http://www.discourse.org\")).to eq(\"//www.discourse.org\")\n      expect(UrlHelper.schemaless(\"https://secure.discourse.org\")).to eq(\n        \"https://secure.discourse.org\",\n      )\n      expect(UrlHelper.schemaless(\"ftp://ftp.discourse.org\")).to eq(\"ftp://ftp.discourse.org\")\n    end\n  end\n\n  describe \"#normalized_encode\" do\n    it \"does not double escape %3A (:)\" do\n      url = \"http://discourse.org/%3A/test\"\n      expect(UrlHelper.normalized_encode(url)).to eq(url)\n    end\n\n    it \"does not double escape %2F (/)\" do\n      url = \"http://discourse.org/%2F/test\"\n      expect(UrlHelper.normalized_encode(url)).to eq(url)\n    end\n\n    it \"doesn't escape simple URL\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/foo/bar\")\n      expect(url).to eq(\"http://example.com/foo/bar\")\n    end\n\n    it \"escapes unsafe chars\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/?a=\\11\\15\")\n      expect(url).to eq(\"http://example.com/?a=%09%0D\")\n    end\n\n    it \"escapes non-ascii chars\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/\u0645\u0627\u0647\u06cc\")\n      expect(url).to eq(\"http://example.com/%D9%85%D8%A7%D9%87%DB%8C\")\n    end\n\n    it \"doesn't escape already escaped chars (space)\" do\n      url = UrlHelper.normalized_encode(\"http://example.com/foo%20bar/foo bar/\")\n      expect(url).to eq(\"http://example.com/foo%20bar/foo%20bar/\")\n    end\n\n    it \"doesn't escape already escaped chars (hash)\" do\n      url =\n        \"https://calendar.google.com/calendar/embed?src=en.uk%23holiday@group.v.calendar.google.com&ctz=Europe%2FLondon\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(url)\n    end\n\n    it \"leaves reserved chars alone in edge cases\" do\n      skip \"see: https://github.com/sporkmonger/addressable/issues/472\"\n      url = \"https://example.com/ article/id%3A1.2%2F1/bar\"\n      expected = \"https://example.com/%20article/id%3A1.2%2F1/bar\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(expected)\n    end\n\n    it \"handles emoji domain names\" do\n      url = \"https://\ud83d\udcbb.example/\ud83d\udcbb?computer=\ud83d\udcbb\"\n      expected = \"https://xn--3s8h.example/%F0%9F%92%BB?computer=%F0%9F%92%BB\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(expected)\n    end\n\n    it \"handles special-character domain names\" do\n      url = \"https://\u00e9xample.com/test\"\n      expected = \"https://xn--xample-9ua.com/test\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(expected)\n    end\n\n    it \"performs basic normalization\" do\n      url = \"http://EXAMPLE.com/a\"\n      escaped = UrlHelper.normalized_encode(url)\n      expect(escaped).to eq(\"http://example.com/a\")\n    end\n\n    it \"doesn't escape S3 presigned URLs\" do\n      # both of these were originally real presigned URLs and have had all\n      # sensitive information stripped\n      presigned_url =\n        \"https://test.com/original/3X/b/5/575bcc2886bf7a39684b57ca90be85f7d399bbc7.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AK8888999977%2F20200130%2Fus-west-1%2Fs3%2Faws4_request&X-Amz-Date=20200130T064355Z&X-Amz-Expires=15&X-Amz-SignedHeaders=host&X-Amz-Security-Token=blahblah%2Bblahblah%2Fblah%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAR&X-Amz-Signature=test\"\n      encoded_presigned_url =\n        \"https://test.com/original/3X/b/5/575bcc2886bf7a39684b57ca90be85f7d399bbc7.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AK8888999977/20200130/us-west-1/s3/aws4_request&X-Amz-Date=20200130T064355Z&X-Amz-Expires=15&X-Amz-SignedHeaders=host&X-Amz-Security-Token=blahblah+blahblah/blah//////////wEQA==&X-Amz-Signature=test\"\n      expect(UrlHelper.normalized_encode(presigned_url)).not_to eq(encoded_presigned_url)\n    end\n\n    it \"raises error if too long\" do\n      expect do UrlHelper.normalized_encode(\"https://#{\"a\" * 2_000}.com\") end.to raise_error(\n        ArgumentError,\n      )\n    end\n  end\n\n  describe \"#local_cdn_url\" do\n    let(:url) { \"/#{Discourse.store.upload_path}/1X/575bcc2886bf7a39684b57ca90be85f7d399bbc7.png\" }\n    let(:asset_host) { \"//my.awesome.cdn\" }\n\n    it \"should return correct cdn url for local relative urls\" do\n      set_cdn_url asset_host\n      cdn_url = UrlHelper.local_cdn_url(url)\n      expect(cdn_url).to eq(\"#{asset_host}#{url}\")\n    end\n  end\n\n  describe \"#rails_route_from_url\" do\n    it \"recognizes a user path\" do\n      result = UrlHelper.rails_route_from_url(\"http://example.com/u/john_smith\")\n      expect(result[:controller]).to eq(\"users\")\n      expect(result[:action]).to eq(\"show\")\n      expect(result[:username]).to eq(\"john_smith\")\n    end\n\n    it \"recognizes a user path with unicode characters in the username\" do\n      result = UrlHelper.rails_route_from_url(\"http://example.com/u/bj\u00f6rn_ulvaeus\")\n      expect(result[:controller]).to eq(\"users\")\n      expect(result[:action]).to eq(\"show\")\n      expect(result[:username].force_encoding(\"UTF-8\")).to eq(\"bj\u00f6rn_ulvaeus\")\n    end\n  end\n\n  describe \"#cook_url\" do\n    let(:url) do\n      \"//s3bucket.s3.dualstack.us-west-1.amazonaws.com/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\"\n    end\n\n    before do\n      setup_s3\n      SiteSetting.s3_upload_bucket = \"s3bucket\"\n      SiteSetting.login_required = true\n      Rails.configuration.action_controller.asset_host = \"https://test.some-cdn.com/dev\"\n\n      FileStore::S3Store.any_instance.stubs(:has_been_uploaded?).returns(true)\n\n      SiteSetting.secure_uploads = true\n    end\n\n    def cooked\n      UrlHelper.cook_url(url, secure: secure)\n    end\n\n    context \"when the upload for the url is secure\" do\n      let(:secure) { true }\n\n      it \"returns the secure_proxy_without_cdn url, with no asset host URL change\" do\n        expect(cooked).to eq(\n          \"//test.localhost/secure-uploads/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\",\n        )\n      end\n\n      context \"when secure_uploads setting is disabled\" do\n        before { SiteSetting.secure_uploads = false }\n\n        it \"returns the local_cdn_url\" do\n          expect(cooked).to eq(\n            \"//s3bucket.s3.dualstack.us-west-1.amazonaws.com/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\",\n          )\n        end\n      end\n    end\n\n    context \"when the upload for the url is not secure\" do\n      let(:secure) { false }\n\n      it \"returns the local_cdn_url\" do\n        expect(cooked).to eq(\n          \"//s3bucket.s3.dualstack.us-west-1.amazonaws.com/dev/original/3X/2/e/2e6f2ef81b6910ea592cd6d21ee897cd51cf72e4.jpeg\",\n        )\n      end\n    end\n\n    after { Rails.configuration.action_controller.asset_host = nil }\n  end\n\n  describe \"rails_route_from_url\" do\n    it \"returns a rails route from the path\" do\n      expect(described_class.rails_route_from_url(\"/u\")).to eq(\n        { controller: \"users\", action: \"index\" },\n      )\n    end\n\n    it \"does not raise for invalid URLs\" do\n      url = \"http://URL:%20https://google.com\"\n      expect(described_class.rails_route_from_url(url)).to eq(nil)\n    end\n\n    it \"does not raise for invalid mailtos\" do\n      url = \"mailto:eviltrout%2540example.com\"\n      expect(described_class.rails_route_from_url(url)).to eq(nil)\n    end\n  end\nend\n"], "filenames": ["lib/onebox.rb", "lib/onebox/engine/standard_embed.rb", "lib/url_helper.rb", "spec/lib/onebox/engine/standard_embed_spec.rb", "spec/lib/url_helper_spec.rb"], "buggy_code_start_loc": [19, 101, 4, 68, 169], "buggy_code_end_loc": [20, 102, 5, 107, 170], "fixing_code_start_loc": [19, 101, 4, 69, 169], "fixing_code_end_loc": [20, 108, 5, 135, 170], "type": "CWE-770", "message": "Discourse is an open source platform for community discussion. In versions 3.1.0 through 3.1.2 of the `stable` branch and versions 3.1.0,beta6 through 3.2.0.beta2 of the `beta` and `tests-passed` branches, Redis memory can be depleted by crafting a site with an abnormally long favicon URL and drafting multiple posts which Onebox it. The issue is patched in version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-47120", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-10T16:15:33.473", "lastModified": "2023-11-17T20:29:04.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. In versions 3.1.0 through 3.1.2 of the `stable` branch and versions 3.1.0,beta6 through 3.2.0.beta2 of the `beta` and `tests-passed` branches, Redis memory can be depleted by crafting a site with an abnormally long favicon URL and drafting multiple posts which Onebox it. The issue is patched in version 3.1.3 of the `stable` branch and version 3.2.0.beta3 of the `beta` and `tests-passed` branches. There are no known workarounds."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para el debate comunitario. En las versiones 3.1.0 a 3.1.2 de la rama \"stable\" y en las versiones 3.1.0, beta6 a 3.2.0.beta2 de las ramas \"beta\" y \"tests-passed\", la memoria de Redis se puede agotar al crear un sitio con una URL de favicon anormalmente larga y redactando m\u00faltiples publicaciones en Onebox. El problema se solucion\u00f3 en la versi\u00f3n 3.1.3 de la rama \"stable\" y en la versi\u00f3n 3.2.0.beta3 de las ramas \"beta\" y \"tests-passed\". No se conocen workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.3", "matchCriteriaId": "50504A87-E983-44B1-9148-91A3F5851F6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9D797DA5-1AE5-4D49-B133-AF45D7FB0A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "4C868514-CFCE-4DA6-B15E-CB64CDF21609"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.1.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "755DE44D-B1C7-4434-824F-5544BE6DD1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "1BFF647B-6CEF-43BF-BF5E-C82B557F78E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "10D931DE-F8F5-4A34-A30A-FDD4420ABD1A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/95a82d608d6377faf68a0e2c5d9640b043557852", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/commit/e910dd09140cb4abc3a563b95af4a137ca7fa0ce", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-77cw-xhj8-hfp3", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/95a82d608d6377faf68a0e2c5d9640b043557852"}}