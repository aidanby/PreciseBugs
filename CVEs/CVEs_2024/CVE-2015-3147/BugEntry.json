{"buggy_code": ["#!/usr/bin/python -u\n# Called by abrtd when a new file is noticed in upload directory.\n# The task of this script is to unpack the file and move\n# problem data found in it to abrtd spool directory.\n\nimport sys\nimport stat\nimport os\nimport getopt\nimport tempfile\nimport shutil\nimport datetime\n\nfrom reportclient import set_verbosity, error_msg_and_die, error_msg, log\n\nGETTEXT_PROGNAME = \"abrt\"\nimport locale\nimport gettext\n\n_ = lambda x: gettext.lgettext(x)\n\ndef init_gettext():\n    try:\n        locale.setlocale(locale.LC_ALL, \"\")\n    except locale.Error:\n        os.environ['LC_ALL'] = 'C'\n        locale.setlocale(locale.LC_ALL, \"\")\n    # Defeat \"AttributeError: 'module' object has no attribute 'nl_langinfo'\"\n    try:\n        gettext.bind_textdomain_codeset(GETTEXT_PROGNAME, locale.nl_langinfo(locale.CODESET))\n    except AttributeError:\n        pass\n    gettext.bindtextdomain(GETTEXT_PROGNAME, '/usr/share/locale')\n    gettext.textdomain(GETTEXT_PROGNAME)\n\n\nimport problem\n\ndef write_str_to(filename, s):\n    fd = os.open(filename, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, @DEFAULT_DUMP_DIR_MODE@ | stat.S_IROTH)\n    if fd >= 0:\n        os.write(fd, s)\n        os.close(fd)\n\nif __name__ == \"__main__\":\n\n    # Helper: exit with cleanup\n    die_exitcode = 1\n    delete_on_exit = None\n    def print_clean_and_die(fmt, *args):\n        sys.stderr.write(\"%s\\n\" % (fmt % args))\n        if delete_on_exit:\n            shutil.rmtree(delete_on_exit, True) # True: ignore_errors\n        sys.exit(die_exitcode)\n\n    # localization\n    init_gettext()\n\n    verbose = 0\n    ABRT_VERBOSE = os.getenv(\"ABRT_VERBOSE\")\n    if ABRT_VERBOSE:\n        try:\n            verbose = int(ABRT_VERBOSE)\n        except:\n            pass\n\n    progname = os.path.basename(sys.argv[0])\n    help_text = _(\n        \"Usage: %s [-vd] ABRT_SPOOL_DIR UPLOAD_DIR FILENAME\"\n      \"\\n\"\n      \"\\n   -v             - Verbose\"\n      \"\\n   -d             - Delete uploaded archive\"\n      \"\\n   ABRT_SPOOL_DIR - Directory where valid uploaded archives are unpacked to\"\n      \"\\n   UPLOAD_DIR     - Directory where uploaded archives are stored\"\n      \"\\n   FILENAME       - Uploaded archive file name\"\n      \"\\n\"\n    ) % progname\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"vdh\", [\"help\"])\n    except getopt.GetoptError as err:\n        error_msg(err)  # prints something like \"option -a not recognized\"\n        error_msg_and_die(help_text)\n\n    delete_archive = False\n    for opt, arg in opts:\n        if opt in (\"-h\", \"--help\"):\n            print(help_text)\n            sys.exit(0)\n        if opt == \"-v\":\n            verbose += 1\n        if opt == \"-d\":\n            delete_archive = True\n\n    set_verbosity(verbose)\n\n    if len(args) < 3:\n        error_msg_and_die(help_text)\n\n    abrt_dir = args[0]\n    upload_dir = args[1]\n    archive = args[2]\n\n    if not os.path.isdir(abrt_dir):\n        error_msg_and_die(_(\"Not a directory: '{0}'\").format(abrt_dir))\n\n    if not os.path.isdir(upload_dir):\n        error_msg_and_die(_(\"Not a directory: '{0}'\").format(upload_dir))\n\n    if archive[0] == \"/\":\n        error_msg_and_die(_(\"Skipping: '{0}' (starts with slash)\").format(archive))\n\n    if archive[0] == \".\":\n        error_msg_and_die(_(\"Skipping: '{0}' (starts with dot)\").format(archive))\n\n    if \"..\" in archive:\n        error_msg_and_die(_(\"Skipping: '{0}' (contains ..)\").format(archive))\n\n    if \" \" in archive:\n        error_msg_and_die(_(\"Skipping: '{0}' (contains space)\").format(archive))\n\n    if \"\\t\" in archive:\n        error_msg_and_die(_(\"Skipping: '{0}' (contains tab)\").format(archive))\n\n    try:\n        os.chdir(upload_dir)\n    except OSError:\n        error_msg_and_die(_(\"Can't change directory to '{0}'\").format(upload_dir))\n\n    if archive.endswith(\".tar.gz\"):\n        unpacker = \"gunzip\"\n    elif archive.endswith(\".tgz\"):\n        unpacker = \"gunzip\"\n    elif archive.endswith(\".tar.bz2\"):\n        unpacker = \"bunzip2\"\n    elif archive.endswith(\".tar.xz\"):\n        unpacker = \"unxz\"\n    else:\n        error_msg_and_die(_(\"Unknown file type: '{0}'\").format(archive))\n\n    try:\n        working_dir = tempfile.mkdtemp(prefix=\"abrt_handle_upload.\", dir=\"@LARGE_DATA_TMP_DIR@\")\n    except OSError:\n        error_msg_and_die(_(\"Can't create working directory in '{0}'\").format(\"@LARGE_DATA_TMP_DIR@\"))\n    delete_on_exit = working_dir\n\n    try:\n        tempdir = working_dir + \"/remote.\" + datetime.datetime.now().strftime(\"%Y-%m-%d-%H:%M:%S.%f.\") + str(os.getpid())\n        working_archive = working_dir + \"/\" + archive\n\n        if delete_archive:\n            try:\n                shutil.move(archive, working_archive)\n            except IOError:\n                print_clean_and_die(_(\"Can't move '{0}' to '{1}'\").format(archive, working_archive))\n        else:\n            try:\n                shutil.copy(archive, working_archive)\n            except IOError:\n                print_clean_and_die(_(\"Can't copy '{0}' to '{1}'\").format(archive, working_archive))\n\n        ex = os.spawnlp(os.P_WAIT, unpacker, unpacker, \"-t\", \"--\", working_archive)\n        if ex != 0:\n            print_clean_and_die(_(\"Verification error on '{0}'\").format(archive))\n\n        log(_(\"Unpacking '{0}'\").format(archive))\n        try:\n            os.mkdir(tempdir)\n        except OSError:\n            print_clean_and_die(_(\"Can't create '{0}' directory\").format(tempdir))\n\n        ex = os.system(unpacker+\" <\"+working_archive+\" | tar xf - -C \"+tempdir)\n        if ex != 0:\n            print_clean_and_die(_(\"Can't unpack '{0}'\").format(archive))\n\n        # The archive can contain either plain dump files\n        # or one or more complete problem data directories.\n        # Checking second possibility first.\n        if (os.path.exists(tempdir+\"/analyzer\") or os.path.exists(tempdir+\"/type\")) and os.path.exists(tempdir+\"/time\"):\n            write_str_to(tempdir+\"/remote\", \"1\")\n            shutil.move(tempdir, abrt_dir)\n            problem.notify_new_path(abrt_dir+\"/\"+os.path.basename(tempdir))\n        else:\n            for d in os.listdir(tempdir):\n                if not os.path.isdir(tempdir+\"/\"+d):\n                    continue\n                write_str_to(tempdir+\"/\"+d+\"/remote\", \"1\")\n                dst = abrt_dir+\"/\"+d\n                if os.path.exists(dst):\n                    dst += \".\"+str(os.getpid())\n                if os.path.exists(dst):\n                    continue\n                shutil.move(tempdir+\"/\"+d, dst)\n                problem.notify_new_path(dst)\n\n        die_exitcode = 0\n        # This deletes working_dir (== delete_on_exit)\n        print_clean_and_die(_(\"'{0}' processed successfully\").format(archive))\n\n    except:\n        if delete_on_exit:\n            shutil.rmtree(delete_on_exit, True) # True: ignore_errors\n        raise\n"], "fixing_code": ["#!/usr/bin/python -u\n# Called by abrtd when a new file is noticed in upload directory.\n# The task of this script is to unpack the file and move\n# problem data found in it to abrtd spool directory.\n\nimport sys\nimport stat\nimport os\nimport getopt\nimport tempfile\nimport shutil\nimport datetime\nimport grp\n\nfrom reportclient import set_verbosity, error_msg_and_die, error_msg, log\n\nGETTEXT_PROGNAME = \"abrt\"\nimport locale\nimport gettext\n\n_ = lambda x: gettext.lgettext(x)\n\ndef init_gettext():\n    try:\n        locale.setlocale(locale.LC_ALL, \"\")\n    except locale.Error:\n        os.environ['LC_ALL'] = 'C'\n        locale.setlocale(locale.LC_ALL, \"\")\n    # Defeat \"AttributeError: 'module' object has no attribute 'nl_langinfo'\"\n    try:\n        gettext.bind_textdomain_codeset(GETTEXT_PROGNAME, locale.nl_langinfo(locale.CODESET))\n    except AttributeError:\n        pass\n    gettext.bindtextdomain(GETTEXT_PROGNAME, '/usr/share/locale')\n    gettext.textdomain(GETTEXT_PROGNAME)\n\n\nimport problem\n\ndef write_str_to(filename, s, uid, gid, mode):\n    fd = os.open(filename, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode)\n    if fd >= 0:\n        os.fchown(fd, uid, gid)\n        os.write(fd, s)\n        os.close(fd)\n\n\ndef validate_transform_move_and_notify(uploaded_dir_path, problem_dir_path, dest=None):\n    fsuid = 0\n    fsgid = 0\n\n    try:\n        gabrt = grp.getgrnam(\"abrt\")\n        fsgid = gabrt.gr_gid\n    except KeyError as ex:\n        error_msg(\"Failed to get GID of 'abrt' (using 0 instead): {0}'\".format(str(ex)))\n\n    try:\n        # give the uploaded directory to 'root:abrt' or 'root:root'\n        os.chown(uploaded_dir_path, fsuid, fsgid)\n        # set the right permissions for this machine\n        # (allow the owner and the group to access problem elements,\n        #  the default dump dir mode lacks x bit for both)\n        os.chmod(uploaded_dir_path, @DEFAULT_DUMP_DIR_MODE@ | stat.S_IXUSR | stat.S_IXGRP)\n\n        # sanitize problem elements\n        for item in os.listdir(uploaded_dir_path):\n            apath = os.path.join(uploaded_dir_path, item)\n            if os.path.islink(apath):\n                # remove symbolic links\n                os.remove(apath)\n            elif os.path.isdir(apath):\n                # remove directories\n                shutil.rmtree(apath)\n            elif os.path.isfile(apath):\n                # set file ownership to 'root:abrt' or 'root:root'\n                os.chown(apath, fsuid, fsgid)\n                # set the right file permissions for this machine\n                os.chmod(apath, @DEFAULT_DUMP_DIR_MODE@)\n            else:\n                # remove things that are neither files, symlinks nor directories\n                os.remove(apath)\n    except OSError as ex:\n        error_msg(\"Removing uploaded dir '{0}': '{1}'\".format(uploaded_dir_path, str(ex)))\n        try:\n            shutil.rmtree(uploaded_dir_path)\n        except OSError as ex2:\n            error_msg_and_die(\"Failed to clean up dir '{0}': '{1}'\".format(uploaded_dir_path, str(ex2)))\n        return\n\n    # overwrite remote if it exists\n    remote_path = os.path.join(uploaded_dir_path, \"remote\")\n    write_str_to(remote_path, \"1\", fsuid, fsgid, @DEFAULT_DUMP_DIR_MODE@)\n\n    # abrtd would increment count value and abrt-server refuses to process\n    # problem directories containing 'count' element when PrivateReports is on.\n    count_path = os.path.join(uploaded_dir_path, \"count\")\n    if os.path.exists(count_path):\n        # overwrite remote_count if it exists\n        remote_count_path = os.path.join(uploaded_dir_path, \"remote_count\")\n        os.rename(count_path, remote_count_path)\n\n    if not dest:\n        dest = problem_dir_path\n\n    shutil.move(uploaded_dir_path, dest)\n\n    problem.notify_new_path(problem_dir_path)\n\n\nif __name__ == \"__main__\":\n\n    # Helper: exit with cleanup\n    die_exitcode = 1\n    delete_on_exit = None\n    def print_clean_and_die(fmt, *args):\n        sys.stderr.write(\"%s\\n\" % (fmt % args))\n        if delete_on_exit:\n            shutil.rmtree(delete_on_exit, True) # True: ignore_errors\n        sys.exit(die_exitcode)\n\n    # localization\n    init_gettext()\n\n    verbose = 0\n    ABRT_VERBOSE = os.getenv(\"ABRT_VERBOSE\")\n    if ABRT_VERBOSE:\n        try:\n            verbose = int(ABRT_VERBOSE)\n        except:\n            pass\n\n    progname = os.path.basename(sys.argv[0])\n    help_text = _(\n        \"Usage: %s [-vd] ABRT_SPOOL_DIR UPLOAD_DIR FILENAME\"\n      \"\\n\"\n      \"\\n   -v             - Verbose\"\n      \"\\n   -d             - Delete uploaded archive\"\n      \"\\n   ABRT_SPOOL_DIR - Directory where valid uploaded archives are unpacked to\"\n      \"\\n   UPLOAD_DIR     - Directory where uploaded archives are stored\"\n      \"\\n   FILENAME       - Uploaded archive file name\"\n      \"\\n\"\n    ) % progname\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"vdh\", [\"help\"])\n    except getopt.GetoptError as err:\n        error_msg(err)  # prints something like \"option -a not recognized\"\n        error_msg_and_die(help_text)\n\n    delete_archive = False\n    for opt, arg in opts:\n        if opt in (\"-h\", \"--help\"):\n            print(help_text)\n            sys.exit(0)\n        if opt == \"-v\":\n            verbose += 1\n        if opt == \"-d\":\n            delete_archive = True\n\n    set_verbosity(verbose)\n\n    if len(args) < 3:\n        error_msg_and_die(help_text)\n\n    abrt_dir = args[0]\n    upload_dir = args[1]\n    archive = args[2]\n\n    if not os.path.isdir(abrt_dir):\n        error_msg_and_die(_(\"Not a directory: '{0}'\").format(abrt_dir))\n\n    if not os.path.isdir(upload_dir):\n        error_msg_and_die(_(\"Not a directory: '{0}'\").format(upload_dir))\n\n    if archive[0] == \"/\":\n        error_msg_and_die(_(\"Skipping: '{0}' (starts with slash)\").format(archive))\n\n    if archive[0] == \".\":\n        error_msg_and_die(_(\"Skipping: '{0}' (starts with dot)\").format(archive))\n\n    if \"..\" in archive:\n        error_msg_and_die(_(\"Skipping: '{0}' (contains ..)\").format(archive))\n\n    if \" \" in archive:\n        error_msg_and_die(_(\"Skipping: '{0}' (contains space)\").format(archive))\n\n    if \"\\t\" in archive:\n        error_msg_and_die(_(\"Skipping: '{0}' (contains tab)\").format(archive))\n\n    try:\n        os.chdir(upload_dir)\n    except OSError:\n        error_msg_and_die(_(\"Can't change directory to '{0}'\").format(upload_dir))\n\n    if archive.endswith(\".tar.gz\"):\n        unpacker = \"gunzip\"\n    elif archive.endswith(\".tgz\"):\n        unpacker = \"gunzip\"\n    elif archive.endswith(\".tar.bz2\"):\n        unpacker = \"bunzip2\"\n    elif archive.endswith(\".tar.xz\"):\n        unpacker = \"unxz\"\n    else:\n        error_msg_and_die(_(\"Unknown file type: '{0}'\").format(archive))\n\n    try:\n        working_dir = tempfile.mkdtemp(prefix=\"abrt_handle_upload.\", dir=\"@LARGE_DATA_TMP_DIR@\")\n    except OSError:\n        error_msg_and_die(_(\"Can't create working directory in '{0}'\").format(\"@LARGE_DATA_TMP_DIR@\"))\n    delete_on_exit = working_dir\n\n    try:\n        tempdir = working_dir + \"/remote.\" + datetime.datetime.now().strftime(\"%Y-%m-%d-%H:%M:%S.%f.\") + str(os.getpid())\n        working_archive = working_dir + \"/\" + archive\n\n        if delete_archive:\n            try:\n                shutil.move(archive, working_archive)\n            except IOError:\n                print_clean_and_die(_(\"Can't move '{0}' to '{1}'\").format(archive, working_archive))\n        else:\n            try:\n                shutil.copy(archive, working_archive)\n            except IOError:\n                print_clean_and_die(_(\"Can't copy '{0}' to '{1}'\").format(archive, working_archive))\n\n        ex = os.spawnlp(os.P_WAIT, unpacker, unpacker, \"-t\", \"--\", working_archive)\n        if ex != 0:\n            print_clean_and_die(_(\"Verification error on '{0}'\").format(archive))\n\n        log(_(\"Unpacking '{0}'\").format(archive))\n        try:\n            os.mkdir(tempdir)\n        except OSError:\n            print_clean_and_die(_(\"Can't create '{0}' directory\").format(tempdir))\n\n        ex = os.system(unpacker+\" <\"+working_archive+\" | tar xf - -C \"+tempdir)\n        if ex != 0:\n            print_clean_and_die(_(\"Can't unpack '{0}'\").format(archive))\n\n        # The archive can contain either plain dump files\n        # or one or more complete problem data directories.\n        # Checking second possibility first.\n        if (os.path.exists(tempdir+\"/analyzer\") or os.path.exists(tempdir+\"/type\")) and os.path.exists(tempdir+\"/time\"):\n            validate_transform_move_and_notify(tempdir, abrt_dir+\"/\"+os.path.basename(tempdir), dest=abrt_dir)\n        else:\n            for d in os.listdir(tempdir):\n                if not os.path.isdir(tempdir+\"/\"+d):\n                    continue\n                dst = abrt_dir+\"/\"+d\n                if os.path.exists(dst):\n                    dst += \".\"+str(os.getpid())\n                if os.path.exists(dst):\n                    continue\n                validate_transform_move_and_notify(tempdir+\"/\"+d, dst)\n\n        die_exitcode = 0\n        # This deletes working_dir (== delete_on_exit)\n        print_clean_and_die(_(\"'{0}' processed successfully\").format(archive))\n\n    except:\n        if delete_on_exit:\n            shutil.rmtree(delete_on_exit, True) # True: ignore_errors\n        raise\n"], "filenames": ["src/daemon/abrt-handle-upload.in"], "buggy_code_start_loc": [12], "buggy_code_end_loc": [195], "fixing_code_start_loc": [13], "fixing_code_end_loc": [257], "type": "CWE-59", "message": "daemon/abrt-handle-upload.in in Automatic Bug Reporting Tool (ABRT), when moving problem reports from /var/spool/abrt-upload, allows local users to write to arbitrary files or possibly have other unspecified impact via a symlink attack on (1) /var/spool/abrt or (2) /var/tmp/abrt.", "other": {"cve": {"id": "CVE-2015-3147", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-14T18:15:10.603", "lastModified": "2023-02-12T23:15:31.680", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "daemon/abrt-handle-upload.in in Automatic Bug Reporting Tool (ABRT), when moving problem reports from /var/spool/abrt-upload, allows local users to write to arbitrary files or possibly have other unspecified impact via a symlink attack on (1) /var/spool/abrt or (2) /var/tmp/abrt."}, {"lang": "es", "value": "El archivo daemon/abrt-handle-upload.in en Automatic Bug Reporting Tool (ABRT), cuando mueve reportes de problemas desde /var/spool/abrt-upload, permite a usuarios locales escribir en archivos arbitrarios o posiblemente tener otro impacto no especificado por medio de un ataque de enlace simb\u00f3lico en (1) /var/spool/abrt o (2) /var/tmp/abrt."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:automatic_bug_reporting_tool:-:*:*:*:*:*:*:*", "matchCriteriaId": "A396CA2B-75FF-4BEE-8C0A-89B7C030D1E5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "0E8CD4EF-DC90-40BB-A721-6EC087507906"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2015-1083.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/04/17/5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1212953", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/3746b7627218438ae7d781fc8b18a221454e9091", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/pull/955", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/abrt/abrt/commit/3746b7627218438ae7d781fc8b18a221454e9091"}}