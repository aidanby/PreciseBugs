{"buggy_code": ["import hashlib\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Any, Collection, Dict, Iterable, List, Mapping, Optional, Set, Tuple\n\nimport orjson\nfrom django.conf import settings\nfrom django.db import transaction\nfrom django.db.models import Q, QuerySet\nfrom django.utils.timezone import now as timezone_now\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import override as override_language\nfrom django_stubs_ext import ValuesQuerySet\n\nfrom zerver.actions.default_streams import (\n    do_remove_default_stream,\n    do_remove_streams_from_default_stream_group,\n)\nfrom zerver.actions.message_send import internal_send_stream_message\nfrom zerver.lib.cache import (\n    cache_delete,\n    cache_delete_many,\n    cache_set,\n    display_recipient_cache_key,\n    get_stream_cache_key,\n    to_dict_cache_key_id,\n)\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.mention import silent_mention_syntax_for_user\nfrom zerver.lib.message import get_last_message_id\nfrom zerver.lib.queue import queue_json_publish\nfrom zerver.lib.stream_color import pick_colors\nfrom zerver.lib.stream_subscription import (\n    SubInfo,\n    bulk_get_private_peers,\n    bulk_get_subscriber_peer_info,\n    get_active_subscriptions_for_stream_id,\n    get_bulk_stream_subscriber_info,\n    get_used_colors_for_user_ids,\n)\nfrom zerver.lib.stream_traffic import get_average_weekly_stream_traffic, get_streams_traffic\nfrom zerver.lib.streams import (\n    can_access_stream_user_ids,\n    get_occupied_streams,\n    get_stream_permission_policy_name,\n    render_stream_description,\n    send_stream_creation_event,\n)\nfrom zerver.lib.subscription_info import get_subscribers_query\nfrom zerver.lib.types import APISubscriptionDict\nfrom zerver.models import (\n    ArchivedAttachment,\n    Attachment,\n    DefaultStream,\n    DefaultStreamGroup,\n    Message,\n    Realm,\n    RealmAuditLog,\n    Recipient,\n    Stream,\n    Subscription,\n    UserGroup,\n    UserProfile,\n    active_non_guest_user_ids,\n    get_system_bot,\n)\nfrom zerver.tornado.django_api import send_event, send_event_on_commit\n\n\n@transaction.atomic(savepoint=False)\ndef do_deactivate_stream(\n    stream: Stream, log: bool = True, *, acting_user: Optional[UserProfile]\n) -> None:\n    # If the stream is already deactivated, this is a no-op\n    if stream.deactivated is True:\n        raise JsonableError(_(\"Stream is already deactivated\"))\n\n    # We want to mark all messages in the to-be-deactivated stream as\n    # read for all users; otherwise they will pollute queries like\n    # \"Get the user's first unread message\".  Since this can be an\n    # expensive operation, we do it via the deferred_work queue\n    # processor.\n    deferred_work_event = {\n        \"type\": \"mark_stream_messages_as_read_for_everyone\",\n        \"stream_recipient_id\": stream.recipient_id,\n    }\n    transaction.on_commit(lambda: queue_json_publish(\"deferred_work\", deferred_work_event))\n\n    # Get the affected user ids *before* we deactivate everybody.\n    affected_user_ids = can_access_stream_user_ids(stream)\n\n    get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=True).update(\n        active=False\n    )\n\n    was_invite_only = stream.invite_only\n    stream.deactivated = True\n    stream.invite_only = True\n    # Preserve as much as possible the original stream name while giving it a\n    # special prefix that both indicates that the stream is deactivated and\n    # frees up the original name for reuse.\n    old_name = stream.name\n\n    # Prepend a substring of the hashed stream ID to the new stream name\n    streamID = str(stream.id)\n    stream_id_hash_object = hashlib.sha512(streamID.encode())\n    hashed_stream_id = stream_id_hash_object.hexdigest()[0:7]\n\n    new_name = (hashed_stream_id + \"!DEACTIVATED:\" + old_name)[: Stream.MAX_NAME_LENGTH]\n\n    stream.name = new_name[: Stream.MAX_NAME_LENGTH]\n    stream.save(update_fields=[\"name\", \"deactivated\", \"invite_only\"])\n\n    # If this is a default stream, remove it, properly sending a\n    # notification to browser clients.\n    if DefaultStream.objects.filter(realm_id=stream.realm_id, stream_id=stream.id).exists():\n        do_remove_default_stream(stream)\n\n    default_stream_groups_for_stream = DefaultStreamGroup.objects.filter(streams__id=stream.id)\n    for group in default_stream_groups_for_stream:\n        do_remove_streams_from_default_stream_group(stream.realm, group, [stream])\n\n    # Remove the old stream information from remote cache.\n    old_cache_key = get_stream_cache_key(old_name, stream.realm_id)\n    cache_delete(old_cache_key)\n\n    stream_dict = stream.to_dict()\n    stream_dict.update(dict(name=old_name, invite_only=was_invite_only))\n    event = dict(type=\"stream\", op=\"delete\", streams=[stream_dict])\n    send_event_on_commit(stream.realm, event, affected_user_ids)\n\n    event_time = timezone_now()\n    RealmAuditLog.objects.create(\n        realm=stream.realm,\n        acting_user=acting_user,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_DEACTIVATED,\n        event_time=event_time,\n    )\n\n\ndef deactivated_streams_by_old_name(realm: Realm, stream_name: str) -> QuerySet[Stream]:\n    fixed_length_prefix = \".......!DEACTIVATED:\"\n    truncated_name = stream_name[0 : Stream.MAX_NAME_LENGTH - len(fixed_length_prefix)]\n\n    old_names: List[str] = []\n    for bang_length in range(1, 21):\n        name = \"!\" * bang_length + \"DEACTIVATED:\" + stream_name\n        old_names.append(name[0 : Stream.MAX_NAME_LENGTH])\n\n    possible_streams = Stream.objects.filter(realm=realm, deactivated=True).filter(\n        # We go looking for names as they are post-1b6f68bb59dc; 8\n        # characters, followed by `!DEACTIVATED:`, followed by at\n        # most MAX_NAME_LENGTH-(length of the prefix) of the name\n        # they provided:\n        Q(name__regex=rf\"^{fixed_length_prefix}{truncated_name}\")\n        # Finally, we go looking for the pre-1b6f68bb59dc version,\n        # which is any number of `!` followed by `DEACTIVATED:`\n        # and a prefix of the old stream name\n        | Q(name__in=old_names),\n    )\n\n    return possible_streams\n\n\n@transaction.atomic(savepoint=False)\ndef do_unarchive_stream(\n    stream: Stream, new_name: str, *, acting_user: Optional[UserProfile]\n) -> None:\n    realm = stream.realm\n    if not stream.deactivated:\n        raise JsonableError(_(\"Stream is not currently deactivated\"))\n    if Stream.objects.filter(realm=realm, name=new_name).exists():\n        raise JsonableError(\n            _(\"Stream named {stream_name} already exists\").format(stream_name=new_name)\n        )\n    assert stream.recipient_id is not None\n\n    stream.deactivated = False\n    stream.name = new_name\n\n    # We only set invite_only=True during deactivation, which can lead\n    # to the invalid state of to invite-only but also web-public\n    # streams.  Explicitly reset the access; we do not use\n    # do_change_stream_permission because no users need be notified,\n    # and it cannot handle the broken state that may currently exist.\n    stream.is_web_public = False\n    stream.invite_only = True\n    stream.history_public_to_subscribers = True\n    stream.save(\n        update_fields=[\n            \"name\",\n            \"deactivated\",\n            \"is_web_public\",\n            \"invite_only\",\n            \"history_public_to_subscribers\",\n        ]\n    )\n\n    # Update caches\n    cache_set(display_recipient_cache_key(stream.recipient_id), new_name)\n    messages = Message.objects.filter(recipient_id=stream.recipient_id).only(\"id\")\n    cache_delete_many(to_dict_cache_key_id(message.id) for message in messages)\n\n    # Unset the is_web_public cache on attachments, since the stream is now private.\n    Attachment.objects.filter(messages__recipient_id=stream.recipient_id).update(is_web_public=None)\n    ArchivedAttachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n        is_web_public=None\n    )\n\n    RealmAuditLog.objects.create(\n        realm=realm,\n        acting_user=acting_user,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_REACTIVATED,\n        event_time=timezone_now(),\n    )\n\n    # All admins always get to know about private streams' existence,\n    # but we only subscribe the realm owners.\n    send_stream_creation_event(stream, [user.id for user in realm.get_admin_users_and_bots()])\n    bulk_add_subscriptions(\n        realm=realm,\n        streams=[stream],\n        users=realm.get_human_owner_users(),\n        acting_user=acting_user,\n    )\n\n    sender = get_system_bot(settings.NOTIFICATION_BOT, stream.realm_id)\n    with override_language(stream.realm.default_language):\n        internal_send_stream_message(\n            sender,\n            stream,\n            str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC),\n            _(\"Stream {stream_name} un-archived.\").format(stream_name=new_name),\n        )\n\n\ndef bulk_delete_cache_keys(message_ids_to_clear: List[int]) -> None:\n    while len(message_ids_to_clear) > 0:\n        batch = message_ids_to_clear[0:5000]\n\n        keys_to_delete = [to_dict_cache_key_id(message_id) for message_id in batch]\n        cache_delete_many(keys_to_delete)\n\n        message_ids_to_clear = message_ids_to_clear[5000:]\n\n\ndef merge_streams(\n    realm: Realm, stream_to_keep: Stream, stream_to_destroy: Stream\n) -> Tuple[int, int, int]:\n    recipient_to_destroy = stream_to_destroy.recipient\n    recipient_to_keep = stream_to_keep.recipient\n    assert recipient_to_keep is not None\n    assert recipient_to_destroy is not None\n    if recipient_to_destroy.id == recipient_to_keep.id:\n        return (0, 0, 0)\n\n    # The high-level approach here is to move all the messages to\n    # the surviving stream, deactivate all the subscriptions on\n    # the stream to be removed and deactivate the stream, and add\n    # new subscriptions to the stream to keep for any users who\n    # were only on the now-deactivated stream.\n    #\n    # The order of operations is carefully chosen so that calling this\n    # function again is likely to be an effective way to recover if\n    # this process is interrupted by an error.\n\n    # Move the Subscription objects.  This algorithm doesn't\n    # preserve any stream settings/colors/etc. from the stream\n    # being destroyed, but it's convenient.\n    existing_subs = Subscription.objects.filter(recipient=recipient_to_keep)\n    users_already_subscribed = {sub.user_profile_id: sub.active for sub in existing_subs}\n\n    subs_to_deactivate = Subscription.objects.filter(recipient=recipient_to_destroy, active=True)\n    users_to_activate = [\n        sub.user_profile\n        for sub in subs_to_deactivate\n        if not users_already_subscribed.get(sub.user_profile_id, False)\n    ]\n\n    if len(users_to_activate) > 0:\n        bulk_add_subscriptions(realm, [stream_to_keep], users_to_activate, acting_user=None)\n\n    # Move the messages, and delete the old copies from caches. We do\n    # this before removing the subscription objects, to avoid messages\n    # \"disappearing\" if an error interrupts this function.\n    message_ids_to_clear = list(\n        Message.objects.filter(recipient=recipient_to_destroy).values_list(\"id\", flat=True)\n    )\n    count = Message.objects.filter(recipient=recipient_to_destroy).update(\n        recipient=recipient_to_keep\n    )\n    bulk_delete_cache_keys(message_ids_to_clear)\n\n    # Remove subscriptions to the old stream.\n    if len(subs_to_deactivate) > 0:\n        bulk_remove_subscriptions(\n            realm,\n            [sub.user_profile for sub in subs_to_deactivate],\n            [stream_to_destroy],\n            acting_user=None,\n        )\n\n    do_deactivate_stream(stream_to_destroy, acting_user=None)\n\n    return (len(users_to_activate), count, len(subs_to_deactivate))\n\n\ndef get_subscriber_ids(\n    stream: Stream, requesting_user: Optional[UserProfile] = None\n) -> ValuesQuerySet[Subscription, int]:\n    subscriptions_query = get_subscribers_query(stream, requesting_user)\n    return subscriptions_query.values_list(\"user_profile_id\", flat=True)\n\n\n@dataclass\nclass StreamInfo:\n    stream_weekly_traffic: Optional[int]\n    subscribers: List[int]\n\n\ndef send_subscription_add_events(\n    realm: Realm,\n    sub_info_list: List[SubInfo],\n    subscriber_dict: Dict[int, Set[int]],\n) -> None:\n    info_by_user: Dict[int, List[SubInfo]] = defaultdict(list)\n    for sub_info in sub_info_list:\n        info_by_user[sub_info.user.id].append(sub_info)\n\n    stream_ids = {sub_info.stream.id for sub_info in sub_info_list}\n    recent_traffic = get_streams_traffic(stream_ids=stream_ids)\n\n    # We generally only have a few streams, so we compute stream\n    # data in its own loop.\n    stream_info_dict: Dict[int, StreamInfo] = {}\n    for sub_info in sub_info_list:\n        stream = sub_info.stream\n        if stream.id not in stream_info_dict:\n            stream_weekly_traffic = get_average_weekly_stream_traffic(\n                stream.id, stream.date_created, recent_traffic\n            )\n            if stream.is_in_zephyr_realm and not stream.invite_only:\n                subscribers = []\n            else:\n                subscribers = list(subscriber_dict[stream.id])\n            stream_info_dict[stream.id] = StreamInfo(\n                stream_weekly_traffic=stream_weekly_traffic,\n                subscribers=subscribers,\n            )\n\n    for user_id, sub_infos in info_by_user.items():\n        sub_dicts: List[APISubscriptionDict] = []\n        for sub_info in sub_infos:\n            stream = sub_info.stream\n            stream_info = stream_info_dict[stream.id]\n            subscription = sub_info.sub\n            stream_dict = stream.to_dict()\n            # This is verbose as we cannot unpack existing TypedDict\n            # to initialize another TypedDict while making mypy happy.\n            # https://github.com/python/mypy/issues/5382\n            sub_dict = APISubscriptionDict(\n                # Fields from Subscription.API_FIELDS\n                audible_notifications=subscription.audible_notifications,\n                color=subscription.color,\n                desktop_notifications=subscription.desktop_notifications,\n                email_notifications=subscription.email_notifications,\n                is_muted=subscription.is_muted,\n                pin_to_top=subscription.pin_to_top,\n                push_notifications=subscription.push_notifications,\n                wildcard_mentions_notify=subscription.wildcard_mentions_notify,\n                # Computed fields not present in Subscription.API_FIELDS\n                in_home_view=not subscription.is_muted,\n                stream_weekly_traffic=stream_info.stream_weekly_traffic,\n                subscribers=stream_info.subscribers,\n                # Fields from Stream.API_FIELDS\n                can_remove_subscribers_group_id=stream_dict[\"can_remove_subscribers_group_id\"],\n                date_created=stream_dict[\"date_created\"],\n                description=stream_dict[\"description\"],\n                first_message_id=stream_dict[\"first_message_id\"],\n                history_public_to_subscribers=stream_dict[\"history_public_to_subscribers\"],\n                invite_only=stream_dict[\"invite_only\"],\n                is_web_public=stream_dict[\"is_web_public\"],\n                message_retention_days=stream_dict[\"message_retention_days\"],\n                name=stream_dict[\"name\"],\n                rendered_description=stream_dict[\"rendered_description\"],\n                stream_id=stream_dict[\"stream_id\"],\n                stream_post_policy=stream_dict[\"stream_post_policy\"],\n                # Computed fields not present in Stream.API_FIELDS\n                is_announcement_only=stream_dict[\"is_announcement_only\"],\n            )\n\n            sub_dicts.append(sub_dict)\n\n        # Send a notification to the user who subscribed.\n        event = dict(type=\"subscription\", op=\"add\", subscriptions=sub_dicts)\n        send_event(realm, event, [user_id])\n\n\n# This function contains all the database changes as part of\n# subscribing users to streams; we use a transaction to ensure that\n# the RealmAuditLog entries are created atomically with the\n# Subscription object creation (and updates).\n@transaction.atomic(savepoint=False)\ndef bulk_add_subs_to_db_with_logging(\n    realm: Realm,\n    acting_user: Optional[UserProfile],\n    subs_to_add: List[SubInfo],\n    subs_to_activate: List[SubInfo],\n) -> None:\n    Subscription.objects.bulk_create(info.sub for info in subs_to_add)\n    sub_ids = [info.sub.id for info in subs_to_activate]\n    Subscription.objects.filter(id__in=sub_ids).update(active=True)\n\n    # Log subscription activities in RealmAuditLog\n    event_time = timezone_now()\n    event_last_message_id = get_last_message_id()\n\n    all_subscription_logs: (List[RealmAuditLog]) = []\n    for sub_info in subs_to_add:\n        all_subscription_logs.append(\n            RealmAuditLog(\n                realm=realm,\n                acting_user=acting_user,\n                modified_user=sub_info.user,\n                modified_stream=sub_info.stream,\n                event_last_message_id=event_last_message_id,\n                event_type=RealmAuditLog.SUBSCRIPTION_CREATED,\n                event_time=event_time,\n            )\n        )\n    for sub_info in subs_to_activate:\n        all_subscription_logs.append(\n            RealmAuditLog(\n                realm=realm,\n                acting_user=acting_user,\n                modified_user=sub_info.user,\n                modified_stream=sub_info.stream,\n                event_last_message_id=event_last_message_id,\n                event_type=RealmAuditLog.SUBSCRIPTION_ACTIVATED,\n                event_time=event_time,\n            )\n        )\n    # Now since we have all log objects generated we can do a bulk insert\n    RealmAuditLog.objects.bulk_create(all_subscription_logs)\n\n\ndef send_stream_creation_events_for_private_streams(\n    realm: Realm,\n    stream_dict: Dict[int, Stream],\n    altered_user_dict: Dict[int, Set[int]],\n) -> None:\n    for stream_id, stream_users_ids in altered_user_dict.items():\n        stream = stream_dict[stream_id]\n\n        if not stream.is_public():\n            # Users newly added to invite-only streams\n            # need a `create` notification.  The former, because\n            # they need the stream to exist before\n            # they get the \"subscribe\" notification, and the latter so\n            # they can manage the new stream.\n            # Realm admins already have all created private streams.\n            realm_admin_ids = {user.id for user in realm.get_admin_users_and_bots()}\n            notify_user_ids = list(stream_users_ids - realm_admin_ids)\n\n            if notify_user_ids:\n                send_stream_creation_event(stream, notify_user_ids)\n\n\ndef send_peer_subscriber_events(\n    op: str,\n    realm: Realm,\n    stream_dict: Dict[int, Stream],\n    altered_user_dict: Dict[int, Set[int]],\n    private_peer_dict: Dict[int, Set[int]],\n) -> None:\n    # Send peer_add/peer_remove events to other users who are tracking the\n    # subscribers lists of streams in their browser; everyone for\n    # public streams and only existing subscribers for private streams.\n\n    assert op in [\"peer_add\", \"peer_remove\"]\n\n    private_stream_ids = [\n        stream_id for stream_id in altered_user_dict if stream_dict[stream_id].invite_only\n    ]\n\n    for stream_id in private_stream_ids:\n        altered_user_ids = altered_user_dict[stream_id]\n        peer_user_ids = private_peer_dict[stream_id] - altered_user_ids\n\n        if peer_user_ids and altered_user_ids:\n            event = dict(\n                type=\"subscription\",\n                op=op,\n                stream_ids=[stream_id],\n                user_ids=sorted(altered_user_ids),\n            )\n            send_event_on_commit(realm, event, peer_user_ids)\n\n    public_stream_ids = [\n        stream_id\n        for stream_id in altered_user_dict\n        if not stream_dict[stream_id].invite_only and not stream_dict[stream_id].is_in_zephyr_realm\n    ]\n\n    if public_stream_ids:\n        user_streams: Dict[int, Set[int]] = defaultdict(set)\n\n        public_peer_ids = set(active_non_guest_user_ids(realm.id))\n\n        for stream_id in public_stream_ids:\n            altered_user_ids = altered_user_dict[stream_id]\n            peer_user_ids = public_peer_ids - altered_user_ids\n\n            if peer_user_ids and altered_user_ids:\n                if len(altered_user_ids) == 1:\n                    # If we only have one user, we will try to\n                    # find other streams they have (un)subscribed to\n                    # (where it's just them).  This optimization\n                    # typically works when a single user is subscribed\n                    # to multiple default public streams during\n                    # new-user registration.\n                    #\n                    # This optimization depends on all public streams\n                    # having the same peers for any single user, which\n                    # isn't the case for private streams.\n                    [altered_user_id] = altered_user_ids\n                    user_streams[altered_user_id].add(stream_id)\n                else:\n                    event = dict(\n                        type=\"subscription\",\n                        op=op,\n                        stream_ids=[stream_id],\n                        user_ids=sorted(altered_user_ids),\n                    )\n                    send_event_on_commit(realm, event, peer_user_ids)\n\n        for user_id, stream_ids in user_streams.items():\n            peer_user_ids = public_peer_ids - {user_id}\n            event = dict(\n                type=\"subscription\",\n                op=op,\n                stream_ids=sorted(stream_ids),\n                user_ids=[user_id],\n            )\n            send_event_on_commit(realm, event, peer_user_ids)\n\n\nSubT = Tuple[List[SubInfo], List[SubInfo]]\n\n\ndef bulk_add_subscriptions(\n    realm: Realm,\n    streams: Collection[Stream],\n    users: Iterable[UserProfile],\n    color_map: Mapping[str, str] = {},\n    from_user_creation: bool = False,\n    *,\n    acting_user: Optional[UserProfile],\n) -> SubT:\n    users = list(users)\n    user_ids = [user.id for user in users]\n\n    # Sanity check out callers\n    for stream in streams:\n        assert stream.realm_id == realm.id\n\n    for user in users:\n        assert user.realm_id == realm.id\n\n    recipient_ids = [stream.recipient_id for stream in streams]\n    recipient_id_to_stream = {stream.recipient_id: stream for stream in streams}\n\n    recipient_color_map = {}\n    recipient_ids_set: Set[int] = set()\n    for stream in streams:\n        assert stream.recipient_id is not None\n        recipient_ids_set.add(stream.recipient_id)\n        color: Optional[str] = color_map.get(stream.name, None)\n        if color is not None:\n            recipient_color_map[stream.recipient_id] = color\n\n    used_colors_for_user_ids: Dict[int, Set[str]] = get_used_colors_for_user_ids(user_ids)\n\n    existing_subs = Subscription.objects.filter(\n        user_profile_id__in=user_ids,\n        recipient__type=Recipient.STREAM,\n        recipient_id__in=recipient_ids,\n    )\n\n    subs_by_user: Dict[int, List[Subscription]] = defaultdict(list)\n    for sub in existing_subs:\n        subs_by_user[sub.user_profile_id].append(sub)\n\n    already_subscribed: List[SubInfo] = []\n    subs_to_activate: List[SubInfo] = []\n    subs_to_add: List[SubInfo] = []\n    for user_profile in users:\n        my_subs = subs_by_user[user_profile.id]\n\n        # Make a fresh set of all new recipient ids, and then we will\n        # remove any for which our user already has a subscription\n        # (and we'll re-activate any subscriptions as needed).\n        new_recipient_ids: Set[int] = recipient_ids_set.copy()\n\n        for sub in my_subs:\n            if sub.recipient_id in new_recipient_ids:\n                new_recipient_ids.remove(sub.recipient_id)\n                stream = recipient_id_to_stream[sub.recipient_id]\n                sub_info = SubInfo(user_profile, sub, stream)\n                if sub.active:\n                    already_subscribed.append(sub_info)\n                else:\n                    subs_to_activate.append(sub_info)\n\n        used_colors = used_colors_for_user_ids.get(user_profile.id, set())\n        user_color_map = pick_colors(used_colors, recipient_color_map, list(new_recipient_ids))\n\n        for recipient_id in new_recipient_ids:\n            stream = recipient_id_to_stream[recipient_id]\n            color = user_color_map[recipient_id]\n\n            sub = Subscription(\n                user_profile=user_profile,\n                is_user_active=user_profile.is_active,\n                active=True,\n                color=color,\n                recipient_id=recipient_id,\n            )\n            sub_info = SubInfo(user_profile, sub, stream)\n            subs_to_add.append(sub_info)\n\n    bulk_add_subs_to_db_with_logging(\n        realm=realm,\n        acting_user=acting_user,\n        subs_to_add=subs_to_add,\n        subs_to_activate=subs_to_activate,\n    )\n\n    altered_user_dict: Dict[int, Set[int]] = defaultdict(set)\n    for sub_info in subs_to_add + subs_to_activate:\n        altered_user_dict[sub_info.stream.id].add(sub_info.user.id)\n\n    stream_dict = {stream.id: stream for stream in streams}\n\n    new_streams = [stream_dict[stream_id] for stream_id in altered_user_dict]\n\n    subscriber_peer_info = bulk_get_subscriber_peer_info(\n        realm=realm,\n        streams=new_streams,\n    )\n\n    # We now send several types of events to notify browsers.  The\n    # first batches of notifications are sent only to the user(s)\n    # being subscribed; we can skip these notifications when this is\n    # being called from the new user creation flow.\n    if not from_user_creation:\n        send_stream_creation_events_for_private_streams(\n            realm=realm,\n            stream_dict=stream_dict,\n            altered_user_dict=altered_user_dict,\n        )\n\n        send_subscription_add_events(\n            realm=realm,\n            sub_info_list=subs_to_add + subs_to_activate,\n            subscriber_dict=subscriber_peer_info.subscribed_ids,\n        )\n\n    send_peer_subscriber_events(\n        op=\"peer_add\",\n        realm=realm,\n        altered_user_dict=altered_user_dict,\n        stream_dict=stream_dict,\n        private_peer_dict=subscriber_peer_info.private_peer_dict,\n    )\n\n    return (\n        subs_to_add + subs_to_activate,\n        already_subscribed,\n    )\n\n\ndef send_peer_remove_events(\n    realm: Realm,\n    streams: List[Stream],\n    altered_user_dict: Dict[int, Set[int]],\n) -> None:\n    private_streams = [stream for stream in streams if stream.invite_only]\n\n    private_peer_dict = bulk_get_private_peers(\n        realm=realm,\n        private_streams=private_streams,\n    )\n    stream_dict = {stream.id: stream for stream in streams}\n\n    send_peer_subscriber_events(\n        op=\"peer_remove\",\n        realm=realm,\n        stream_dict=stream_dict,\n        altered_user_dict=altered_user_dict,\n        private_peer_dict=private_peer_dict,\n    )\n\n\ndef notify_subscriptions_removed(\n    realm: Realm, user_profile: UserProfile, streams: Iterable[Stream]\n) -> None:\n    payload = [dict(name=stream.name, stream_id=stream.id) for stream in streams]\n    event = dict(type=\"subscription\", op=\"remove\", subscriptions=payload)\n    send_event(realm, event, [user_profile.id])\n\n\nSubAndRemovedT = Tuple[List[Tuple[UserProfile, Stream]], List[Tuple[UserProfile, Stream]]]\n\n\ndef send_subscription_remove_events(\n    realm: Realm,\n    users: List[UserProfile],\n    streams: List[Stream],\n    removed_subs: List[Tuple[UserProfile, Stream]],\n) -> None:\n    altered_user_dict: Dict[int, Set[int]] = defaultdict(set)\n    streams_by_user: Dict[int, List[Stream]] = defaultdict(list)\n    for user, stream in removed_subs:\n        streams_by_user[user.id].append(stream)\n        altered_user_dict[stream.id].add(user.id)\n\n    for user_profile in users:\n        if len(streams_by_user[user_profile.id]) == 0:\n            continue\n        notify_subscriptions_removed(realm, user_profile, streams_by_user[user_profile.id])\n\n        event = {\n            \"type\": \"mark_stream_messages_as_read\",\n            \"user_profile_id\": user_profile.id,\n            \"stream_recipient_ids\": [\n                stream.recipient_id for stream in streams_by_user[user_profile.id]\n            ],\n        }\n        queue_json_publish(\"deferred_work\", event)\n\n    send_peer_remove_events(\n        realm=realm,\n        streams=streams,\n        altered_user_dict=altered_user_dict,\n    )\n\n\ndef bulk_remove_subscriptions(\n    realm: Realm,\n    users: Iterable[UserProfile],\n    streams: Iterable[Stream],\n    *,\n    acting_user: Optional[UserProfile],\n) -> SubAndRemovedT:\n    users = list(users)\n    streams = list(streams)\n\n    # Sanity check our callers\n    for stream in streams:\n        assert stream.realm_id == realm.id\n\n    for user in users:\n        assert user.realm_id == realm.id\n\n    stream_dict = {stream.id: stream for stream in streams}\n\n    existing_subs_by_user = get_bulk_stream_subscriber_info(users, streams)\n\n    def get_non_subscribed_subs() -> List[Tuple[UserProfile, Stream]]:\n        stream_ids = {stream.id for stream in streams}\n\n        not_subscribed: List[Tuple[UserProfile, Stream]] = []\n\n        for user_profile in users:\n            user_sub_stream_info = existing_subs_by_user[user_profile.id]\n\n            subscribed_stream_ids = {sub_info.stream.id for sub_info in user_sub_stream_info}\n            not_subscribed_stream_ids = stream_ids - subscribed_stream_ids\n\n            for stream_id in not_subscribed_stream_ids:\n                stream = stream_dict[stream_id]\n                not_subscribed.append((user_profile, stream))\n\n        return not_subscribed\n\n    not_subscribed = get_non_subscribed_subs()\n\n    subs_to_deactivate: List[SubInfo] = []\n    sub_ids_to_deactivate: List[int] = []\n\n    # This loop just flattens out our data into big lists for\n    # bulk operations.\n    for sub_infos in existing_subs_by_user.values():\n        for sub_info in sub_infos:\n            subs_to_deactivate.append(sub_info)\n            sub_ids_to_deactivate.append(sub_info.sub.id)\n\n    streams_to_unsubscribe = [sub_info.stream for sub_info in subs_to_deactivate]\n    # We do all the database changes in a transaction to ensure\n    # RealmAuditLog entries are atomically created when making changes.\n    with transaction.atomic():\n        Subscription.objects.filter(\n            id__in=sub_ids_to_deactivate,\n        ).update(active=False)\n        occupied_streams_after = list(get_occupied_streams(realm))\n\n        # Log subscription activities in RealmAuditLog\n        event_time = timezone_now()\n        event_last_message_id = get_last_message_id()\n        all_subscription_logs = [\n            RealmAuditLog(\n                realm=sub_info.user.realm,\n                acting_user=acting_user,\n                modified_user=sub_info.user,\n                modified_stream=sub_info.stream,\n                event_last_message_id=event_last_message_id,\n                event_type=RealmAuditLog.SUBSCRIPTION_DEACTIVATED,\n                event_time=event_time,\n            )\n            for sub_info in subs_to_deactivate\n        ]\n\n        # Now since we have all log objects generated we can do a bulk insert\n        RealmAuditLog.objects.bulk_create(all_subscription_logs)\n\n    removed_sub_tuples = [(sub_info.user, sub_info.stream) for sub_info in subs_to_deactivate]\n    send_subscription_remove_events(realm, users, streams, removed_sub_tuples)\n\n    new_vacant_streams = set(streams_to_unsubscribe) - set(occupied_streams_after)\n    new_vacant_private_streams = [stream for stream in new_vacant_streams if stream.invite_only]\n\n    if new_vacant_private_streams:\n        # Deactivate any newly-vacant private streams\n        for stream in new_vacant_private_streams:\n            do_deactivate_stream(stream, acting_user=acting_user)\n\n    return (\n        removed_sub_tuples,\n        not_subscribed,\n    )\n\n\ndef do_change_subscription_property(\n    user_profile: UserProfile,\n    sub: Subscription,\n    stream: Stream,\n    property_name: str,\n    value: Any,\n    *,\n    acting_user: Optional[UserProfile],\n) -> None:\n    database_property_name = property_name\n    database_value = value\n\n    # For this property, is_muted is used in the database, but\n    # in_home_view is still in the API, since we haven't fully\n    # migrated to the new name yet.\n    if property_name == \"in_home_view\":\n        database_property_name = \"is_muted\"\n        database_value = not value\n\n    old_value = getattr(sub, database_property_name)\n    setattr(sub, database_property_name, database_value)\n    sub.save(update_fields=[database_property_name])\n    event_time = timezone_now()\n    RealmAuditLog.objects.create(\n        realm=user_profile.realm,\n        event_type=RealmAuditLog.SUBSCRIPTION_PROPERTY_CHANGED,\n        event_time=event_time,\n        modified_user=user_profile,\n        acting_user=acting_user,\n        modified_stream=stream,\n        extra_data=orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: old_value,\n                RealmAuditLog.NEW_VALUE: database_value,\n                \"property\": database_property_name,\n            }\n        ).decode(),\n    )\n\n    # This first in_home_view event is deprecated and will be removed\n    # once clients are migrated to handle the subscription update event\n    # with is_muted as the property name.\n    if database_property_name == \"is_muted\":\n        event_value = not database_value\n        in_home_view_event = dict(\n            type=\"subscription\",\n            op=\"update\",\n            property=\"in_home_view\",\n            value=event_value,\n            stream_id=stream.id,\n        )\n\n        send_event(user_profile.realm, in_home_view_event, [user_profile.id])\n\n    event = dict(\n        type=\"subscription\",\n        op=\"update\",\n        property=database_property_name,\n        value=database_value,\n        stream_id=stream.id,\n    )\n    send_event(user_profile.realm, event, [user_profile.id])\n\n\ndef send_change_stream_permission_notification(\n    stream: Stream,\n    *,\n    old_policy_name: str,\n    new_policy_name: str,\n    acting_user: UserProfile,\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, acting_user.realm_id)\n    user_mention = silent_mention_syntax_for_user(acting_user)\n\n    with override_language(stream.realm.default_language):\n        notification_string = _(\n            \"{user} changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **{old_policy}** to **{new_policy}**.\"\n        )\n        notification_string = notification_string.format(\n            user=user_mention,\n            old_policy=old_policy_name,\n            new_policy=new_policy_name,\n        )\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_permission(\n    stream: Stream,\n    *,\n    invite_only: bool,\n    history_public_to_subscribers: bool,\n    is_web_public: bool,\n    acting_user: UserProfile,\n) -> None:\n    old_invite_only_value = stream.invite_only\n    old_history_public_to_subscribers_value = stream.history_public_to_subscribers\n    old_is_web_public_value = stream.is_web_public\n\n    stream.is_web_public = is_web_public\n    stream.invite_only = invite_only\n    stream.history_public_to_subscribers = history_public_to_subscribers\n\n    with transaction.atomic():\n        stream.save(update_fields=[\"invite_only\", \"history_public_to_subscribers\", \"is_web_public\"])\n\n        event_time = timezone_now()\n        if old_invite_only_value != stream.invite_only:\n            # Reset the Attachment.is_realm_public cache for all\n            # messages in the stream whose permissions were changed.\n            assert stream.recipient_id is not None\n            Attachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_realm_public=None\n            )\n            # We need to do the same for ArchivedAttachment to avoid\n            # bugs if deleted attachments are later restored.\n            ArchivedAttachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_realm_public=None\n            )\n\n            RealmAuditLog.objects.create(\n                realm=stream.realm,\n                acting_user=acting_user,\n                modified_stream=stream,\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                event_time=event_time,\n                extra_data=orjson.dumps(\n                    {\n                        RealmAuditLog.OLD_VALUE: old_invite_only_value,\n                        RealmAuditLog.NEW_VALUE: stream.invite_only,\n                        \"property\": \"invite_only\",\n                    }\n                ).decode(),\n            )\n\n        if old_history_public_to_subscribers_value != stream.history_public_to_subscribers:\n            RealmAuditLog.objects.create(\n                realm=stream.realm,\n                acting_user=acting_user,\n                modified_stream=stream,\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                event_time=event_time,\n                extra_data=orjson.dumps(\n                    {\n                        RealmAuditLog.OLD_VALUE: old_history_public_to_subscribers_value,\n                        RealmAuditLog.NEW_VALUE: stream.history_public_to_subscribers,\n                        \"property\": \"history_public_to_subscribers\",\n                    }\n                ).decode(),\n            )\n\n        if old_is_web_public_value != stream.is_web_public:\n            # Reset the Attachment.is_realm_public cache for all\n            # messages in the stream whose permissions were changed.\n            assert stream.recipient_id is not None\n            Attachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_web_public=None\n            )\n            # We need to do the same for ArchivedAttachment to avoid\n            # bugs if deleted attachments are later restored.\n            ArchivedAttachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_web_public=None\n            )\n\n            RealmAuditLog.objects.create(\n                realm=stream.realm,\n                acting_user=acting_user,\n                modified_stream=stream,\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                event_time=event_time,\n                extra_data=orjson.dumps(\n                    {\n                        RealmAuditLog.OLD_VALUE: old_is_web_public_value,\n                        RealmAuditLog.NEW_VALUE: stream.is_web_public,\n                        \"property\": \"is_web_public\",\n                    }\n                ).decode(),\n            )\n\n    notify_stream_creation_ids = set()\n    if old_invite_only_value and not stream.invite_only:\n        # We need to send stream creation event to users who can access the\n        # stream now but were not able to do so previously. So, we can exclude\n        # subscribers, users who were previously subscribed to the stream and\n        # realm admins from the non-guest user list.\n        assert stream.recipient_id is not None\n        previously_subscribed_user_ids = Subscription.objects.filter(\n            recipient_id=stream.recipient_id, active=False, is_user_active=True\n        ).values_list(\"user_profile_id\", flat=True)\n        stream_subscriber_user_ids = get_active_subscriptions_for_stream_id(\n            stream.id, include_deactivated_users=False\n        ).values_list(\"user_profile_id\", flat=True)\n\n        old_can_access_stream_user_ids = (\n            set(stream_subscriber_user_ids)\n            | set(previously_subscribed_user_ids)\n            | {user.id for user in stream.realm.get_admin_users_and_bots()}\n        )\n        non_guest_user_ids = set(active_non_guest_user_ids(stream.realm_id))\n        notify_stream_creation_ids = non_guest_user_ids - old_can_access_stream_user_ids\n        send_stream_creation_event(stream, list(notify_stream_creation_ids))\n\n        # Add subscribers info to the stream object. We need to send peer_add\n        # events to users who were previously subscribed to the streams as\n        # they did not had subscribers data.\n        old_subscribers_access_user_ids = set(stream_subscriber_user_ids) | {\n            user.id for user in stream.realm.get_admin_users_and_bots()\n        }\n        peer_notify_user_ids = non_guest_user_ids - old_subscribers_access_user_ids\n        peer_add_event = dict(\n            type=\"subscription\",\n            op=\"peer_add\",\n            stream_ids=[stream.id],\n            user_ids=sorted(stream_subscriber_user_ids),\n        )\n        send_event(stream.realm, peer_add_event, peer_notify_user_ids)\n\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"invite_only\",\n        value=stream.invite_only,\n        history_public_to_subscribers=stream.history_public_to_subscribers,\n        is_web_public=stream.is_web_public,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    # we do not need to send update events to the users who received creation event\n    # since they already have the updated stream info.\n    notify_stream_update_ids = can_access_stream_user_ids(stream) - notify_stream_creation_ids\n    send_event(stream.realm, event, notify_stream_update_ids)\n\n    old_policy_name = get_stream_permission_policy_name(\n        invite_only=old_invite_only_value,\n        history_public_to_subscribers=old_history_public_to_subscribers_value,\n        is_web_public=old_is_web_public_value,\n    )\n    new_policy_name = get_stream_permission_policy_name(\n        invite_only=stream.invite_only,\n        history_public_to_subscribers=stream.history_public_to_subscribers,\n        is_web_public=stream.is_web_public,\n    )\n    send_change_stream_permission_notification(\n        stream,\n        old_policy_name=old_policy_name,\n        new_policy_name=new_policy_name,\n        acting_user=acting_user,\n    )\n\n\ndef send_change_stream_post_policy_notification(\n    stream: Stream, *, old_post_policy: int, new_post_policy: int, acting_user: UserProfile\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, acting_user.realm_id)\n    user_mention = silent_mention_syntax_for_user(acting_user)\n\n    with override_language(stream.realm.default_language):\n        notification_string = _(\n            \"{user} changed the [posting permissions](/help/stream-sending-policy) \"\n            \"for this stream:\\n\\n\"\n            \"* **Old permissions**: {old_policy}.\\n\"\n            \"* **New permissions**: {new_policy}.\\n\"\n        )\n        notification_string = notification_string.format(\n            user=user_mention,\n            old_policy=Stream.POST_POLICIES[old_post_policy],\n            new_policy=Stream.POST_POLICIES[new_post_policy],\n        )\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_post_policy(\n    stream: Stream, stream_post_policy: int, *, acting_user: UserProfile\n) -> None:\n    old_post_policy = stream.stream_post_policy\n    with transaction.atomic():\n        stream.stream_post_policy = stream_post_policy\n        stream.save(update_fields=[\"stream_post_policy\"])\n        RealmAuditLog.objects.create(\n            realm=stream.realm,\n            acting_user=acting_user,\n            modified_stream=stream,\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            event_time=timezone_now(),\n            extra_data=orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_post_policy,\n                    RealmAuditLog.NEW_VALUE: stream_post_policy,\n                    \"property\": \"stream_post_policy\",\n                }\n            ).decode(),\n        )\n\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"stream_post_policy\",\n        value=stream_post_policy,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n\n    # Backwards-compatibility code: We removed the\n    # is_announcement_only property in early 2020, but we send a\n    # duplicate event for legacy mobile clients that might want the\n    # data.\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"is_announcement_only\",\n        value=stream.stream_post_policy == Stream.STREAM_POST_POLICY_ADMINS,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n\n    send_change_stream_post_policy_notification(\n        stream,\n        old_post_policy=old_post_policy,\n        new_post_policy=stream_post_policy,\n        acting_user=acting_user,\n    )\n\n\ndef do_rename_stream(stream: Stream, new_name: str, user_profile: UserProfile) -> None:\n    old_name = stream.name\n    stream.name = new_name\n    stream.save(update_fields=[\"name\"])\n\n    RealmAuditLog.objects.create(\n        realm=stream.realm,\n        acting_user=user_profile,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_NAME_CHANGED,\n        event_time=timezone_now(),\n        extra_data=orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: old_name,\n                RealmAuditLog.NEW_VALUE: new_name,\n            }\n        ).decode(),\n    )\n\n    assert stream.recipient_id is not None\n    recipient_id: int = stream.recipient_id\n    messages = Message.objects.filter(recipient_id=recipient_id).only(\"id\")\n\n    # Update the display recipient and stream, which are easy single\n    # items to set.\n    old_cache_key = get_stream_cache_key(old_name, stream.realm_id)\n    new_cache_key = get_stream_cache_key(stream.name, stream.realm_id)\n    if old_cache_key != new_cache_key:\n        cache_delete(old_cache_key)\n        cache_set(new_cache_key, stream)\n    cache_set(display_recipient_cache_key(recipient_id), stream.name)\n\n    # Delete cache entries for everything else, which is cheaper and\n    # clearer than trying to set them. display_recipient is the out of\n    # date field in all cases.\n    cache_delete_many(to_dict_cache_key_id(message.id) for message in messages)\n\n    # We want to key these updates by id, not name, since id is\n    # the immutable primary key, and obviously name is not.\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"name\",\n        value=new_name,\n        stream_id=stream.id,\n        name=old_name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n    sender = get_system_bot(settings.NOTIFICATION_BOT, stream.realm_id)\n    with override_language(stream.realm.default_language):\n        internal_send_stream_message(\n            sender,\n            stream,\n            str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC),\n            _(\"{user_name} renamed stream {old_stream_name} to {new_stream_name}.\").format(\n                user_name=silent_mention_syntax_for_user(user_profile),\n                old_stream_name=f\"**{old_name}**\",\n                new_stream_name=f\"**{new_name}**\",\n            ),\n        )\n\n\ndef send_change_stream_description_notification(\n    stream: Stream, *, old_description: str, new_description: str, acting_user: UserProfile\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, acting_user.realm_id)\n    user_mention = silent_mention_syntax_for_user(acting_user)\n\n    with override_language(stream.realm.default_language):\n        if new_description == \"\":\n            new_description = \"*\" + _(\"No description.\") + \"*\"\n        if old_description == \"\":\n            old_description = \"*\" + _(\"No description.\") + \"*\"\n\n        notification_string = (\n            _(\"{user} changed the description for this stream.\").format(user=user_mention)\n            + \"\\n\\n* **\"\n            + _(\"Old description\")\n            + \":**\"\n            + f\"\\n```` quote\\n{old_description}\\n````\\n\"\n            + \"* **\"\n            + _(\"New description\")\n            + \":**\"\n            + f\"\\n```` quote\\n{new_description}\\n````\"\n        )\n\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_description(\n    stream: Stream, new_description: str, *, acting_user: UserProfile\n) -> None:\n    old_description = stream.description\n\n    with transaction.atomic():\n        stream.description = new_description\n        stream.rendered_description = render_stream_description(new_description, stream.realm)\n        stream.save(update_fields=[\"description\", \"rendered_description\"])\n        RealmAuditLog.objects.create(\n            realm=stream.realm,\n            acting_user=acting_user,\n            modified_stream=stream,\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            event_time=timezone_now(),\n            extra_data=orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_description,\n                    RealmAuditLog.NEW_VALUE: new_description,\n                    \"property\": \"description\",\n                }\n            ).decode(),\n        )\n\n    event = dict(\n        type=\"stream\",\n        op=\"update\",\n        property=\"description\",\n        name=stream.name,\n        stream_id=stream.id,\n        value=new_description,\n        rendered_description=stream.rendered_description,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n\n    send_change_stream_description_notification(\n        stream,\n        old_description=old_description,\n        new_description=new_description,\n        acting_user=acting_user,\n    )\n\n\ndef send_change_stream_message_retention_days_notification(\n    user_profile: UserProfile, stream: Stream, old_value: Optional[int], new_value: Optional[int]\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, user_profile.realm_id)\n    user_mention = silent_mention_syntax_for_user(user_profile)\n\n    # If switching from or to the organization's default retention policy,\n    # we want to take the realm's default into account.\n    if old_value is None:\n        old_value = stream.realm.message_retention_days\n    if new_value is None:\n        new_value = stream.realm.message_retention_days\n\n    with override_language(stream.realm.default_language):\n        if old_value == Stream.MESSAGE_RETENTION_SPECIAL_VALUES_MAP[\"unlimited\"]:\n            old_retention_period = _(\"Forever\")\n            new_retention_period = f\"{new_value} days\"\n            summary_line = f\"Messages in this stream will now be automatically deleted {new_value} days after they are sent.\"\n        elif new_value == Stream.MESSAGE_RETENTION_SPECIAL_VALUES_MAP[\"unlimited\"]:\n            old_retention_period = f\"{old_value} days\"\n            new_retention_period = _(\"Forever\")\n            summary_line = _(\"Messages in this stream will now be retained forever.\")\n        else:\n            old_retention_period = f\"{old_value} days\"\n            new_retention_period = f\"{new_value} days\"\n            summary_line = f\"Messages in this stream will now be automatically deleted {new_value} days after they are sent.\"\n        notification_string = _(\n            \"{user} has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: {old_retention_period}\\n\"\n            \"* **New retention period**: {new_retention_period}\\n\\n\"\n            \"{summary_line}\"\n        )\n        notification_string = notification_string.format(\n            user=user_mention,\n            old_retention_period=old_retention_period,\n            new_retention_period=new_retention_period,\n            summary_line=summary_line,\n        )\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_message_retention_days(\n    stream: Stream, acting_user: UserProfile, message_retention_days: Optional[int] = None\n) -> None:\n    old_message_retention_days_value = stream.message_retention_days\n\n    with transaction.atomic():\n        stream.message_retention_days = message_retention_days\n        stream.save(update_fields=[\"message_retention_days\"])\n        RealmAuditLog.objects.create(\n            realm=stream.realm,\n            acting_user=acting_user,\n            modified_stream=stream,\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED,\n            event_time=timezone_now(),\n            extra_data=orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_message_retention_days_value,\n                    RealmAuditLog.NEW_VALUE: message_retention_days,\n                }\n            ).decode(),\n        )\n\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"message_retention_days\",\n        value=message_retention_days,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n    send_change_stream_message_retention_days_notification(\n        user_profile=acting_user,\n        stream=stream,\n        old_value=old_message_retention_days_value,\n        new_value=message_retention_days,\n    )\n\n\ndef do_change_stream_group_based_setting(\n    stream: Stream,\n    setting_name: str,\n    user_group: UserGroup,\n    *,\n    acting_user: Optional[UserProfile] = None,\n) -> None:\n    old_user_group = getattr(stream, setting_name)\n    old_user_group_id = None\n    if old_user_group is not None:\n        old_user_group_id = old_user_group.id\n\n    setattr(stream, setting_name, user_group)\n    stream.save()\n\n    RealmAuditLog.objects.create(\n        realm=stream.realm,\n        acting_user=acting_user,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_GROUP_BASED_SETTING_CHANGED,\n        event_time=timezone_now(),\n        extra_data=orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: old_user_group_id,\n                RealmAuditLog.NEW_VALUE: user_group.id,\n                \"property\": setting_name,\n            }\n        ).decode(),\n    )\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=setting_name + \"_id\",\n        value=user_group.id,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event_on_commit(stream.realm, event, can_access_stream_user_ids(stream))\n", "# See https://zulip.readthedocs.io/en/latest/subsystems/events-system.html for\n# high-level documentation on how this system works.\nimport copy\nimport time\nfrom typing import Any, Callable, Collection, Dict, Iterable, Mapping, Optional, Sequence, Set\n\nfrom django.conf import settings\nfrom django.utils.translation import gettext as _\n\nfrom version import API_FEATURE_LEVEL, ZULIP_MERGE_BASE, ZULIP_VERSION\nfrom zerver.actions.default_streams import (\n    default_stream_groups_to_dicts_sorted,\n    get_default_streams_for_realm,\n    streams_to_dicts_sorted,\n)\nfrom zerver.actions.users import get_owned_bot_dicts\nfrom zerver.lib import emoji\nfrom zerver.lib.alert_words import user_alert_words\nfrom zerver.lib.avatar import avatar_url\nfrom zerver.lib.bot_config import load_bot_config_template\nfrom zerver.lib.compatibility import is_outdated_server\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.external_accounts import get_default_external_accounts\nfrom zerver.lib.hotspots import get_next_hotspots\nfrom zerver.lib.integrations import EMBEDDED_BOTS, WEBHOOK_INTEGRATIONS\nfrom zerver.lib.message import (\n    add_message_to_unread_msgs,\n    aggregate_unread_data,\n    apply_unread_message_event,\n    extract_unread_data_from_um_rows,\n    get_raw_unread_data,\n    get_recent_conversations_recipient_id,\n    get_recent_private_conversations,\n    get_starred_message_ids,\n    remove_message_id_from_unread_mgs,\n)\nfrom zerver.lib.muted_users import get_user_mutes\nfrom zerver.lib.narrow import check_supported_events_narrow_filter, read_stop_words\nfrom zerver.lib.presence import get_presence_for_user, get_presences_for_realm\nfrom zerver.lib.push_notifications import push_notifications_enabled\nfrom zerver.lib.realm_icon import realm_icon_url\nfrom zerver.lib.realm_logo import get_realm_logo_source, get_realm_logo_url\nfrom zerver.lib.scheduled_messages import get_undelivered_scheduled_messages\nfrom zerver.lib.soft_deactivation import reactivate_user_if_soft_deactivated\nfrom zerver.lib.sounds import get_available_notification_sounds\nfrom zerver.lib.stream_subscription import handle_stream_notifications_compatibility\nfrom zerver.lib.streams import do_get_streams, get_web_public_streams\nfrom zerver.lib.subscription_info import gather_subscriptions_helper, get_web_public_subs\nfrom zerver.lib.timestamp import datetime_to_timestamp\nfrom zerver.lib.timezone import canonicalize_timezone\nfrom zerver.lib.topic import TOPIC_NAME\nfrom zerver.lib.user_groups import user_groups_in_realm_serialized\nfrom zerver.lib.user_status import get_user_status_dict\nfrom zerver.lib.user_topics import get_topic_mutes, get_user_topics\nfrom zerver.lib.users import get_cross_realm_dicts, get_raw_user_data, is_administrator_role\nfrom zerver.models import (\n    MAX_TOPIC_NAME_LENGTH,\n    Client,\n    CustomProfileField,\n    Draft,\n    Message,\n    Realm,\n    RealmUserDefault,\n    Stream,\n    UserMessage,\n    UserProfile,\n    UserStatus,\n    UserTopic,\n    custom_profile_fields_for_realm,\n    get_default_stream_groups,\n    get_realm_domains,\n    get_realm_playgrounds,\n    linkifiers_for_realm,\n)\nfrom zerver.tornado.django_api import get_user_events, request_event_queue\nfrom zproject.backends import email_auth_enabled, password_auth_enabled\n\n\nclass RestartEventError(Exception):\n    \"\"\"\n    Special error for handling restart events in apply_events.\n    \"\"\"\n\n\ndef add_realm_logo_fields(state: Dict[str, Any], realm: Realm) -> None:\n    state[\"realm_logo_url\"] = get_realm_logo_url(realm, night=False)\n    state[\"realm_logo_source\"] = get_realm_logo_source(realm, night=False)\n    state[\"realm_night_logo_url\"] = get_realm_logo_url(realm, night=True)\n    state[\"realm_night_logo_source\"] = get_realm_logo_source(realm, night=True)\n    state[\"max_logo_file_size_mib\"] = settings.MAX_LOGO_FILE_SIZE_MIB\n\n\ndef always_want(msg_type: str) -> bool:\n    \"\"\"\n    This function is used as a helper in\n    fetch_initial_state_data, when the user passes\n    in None for event_types, and we want to fetch\n    info for every event type.  Defining this at module\n    level makes it easier to mock.\n    \"\"\"\n    return True\n\n\ndef fetch_initial_state_data(\n    user_profile: Optional[UserProfile],\n    *,\n    realm: Optional[Realm] = None,\n    event_types: Optional[Iterable[str]] = None,\n    queue_id: Optional[str] = \"\",\n    client_gravatar: bool = False,\n    user_avatar_url_field_optional: bool = False,\n    user_settings_object: bool = False,\n    slim_presence: bool = False,\n    include_subscribers: bool = True,\n    include_streams: bool = True,\n    spectator_requested_language: Optional[str] = None,\n    pronouns_field_type_supported: bool = True,\n    linkifier_url_template: bool = False,\n) -> Dict[str, Any]:\n    \"\"\"When `event_types` is None, fetches the core data powering the\n    web app's `page_params` and `/api/v1/register` (for mobile/terminal\n    apps).  Can also fetch a subset as determined by `event_types`.\n\n    The user_profile=None code path is used for logged-out public\n    access to streams with is_web_public=True.\n\n    Whenever you add new code to this function, you should also add\n    corresponding events for changes in the data structures and new\n    code to apply_events (and add a test in test_events.py).\n    \"\"\"\n    if realm is None:\n        assert user_profile is not None\n        realm = user_profile.realm\n\n    state: Dict[str, Any] = {\"queue_id\": queue_id}\n\n    if event_types is None:\n        # return True always\n        want: Callable[[str], bool] = always_want\n    else:\n        want = set(event_types).__contains__\n\n    # Show the version info unconditionally.\n    state[\"zulip_version\"] = ZULIP_VERSION\n    state[\"zulip_feature_level\"] = API_FEATURE_LEVEL\n    state[\"zulip_merge_base\"] = ZULIP_MERGE_BASE\n\n    if want(\"alert_words\"):\n        state[\"alert_words\"] = [] if user_profile is None else user_alert_words(user_profile)\n\n    if want(\"custom_profile_fields\"):\n        if user_profile is None:\n            # Spectators can't access full user profiles or\n            # personal settings, so we send an empty list.\n            state[\"custom_profile_fields\"] = []\n        else:\n            fields = custom_profile_fields_for_realm(realm.id)\n            state[\"custom_profile_fields\"] = [f.as_dict() for f in fields]\n        state[\"custom_profile_field_types\"] = {\n            item[4]: {\"id\": item[0], \"name\": str(item[1])}\n            for item in CustomProfileField.ALL_FIELD_TYPES\n        }\n\n        if not pronouns_field_type_supported:\n            for field in state[\"custom_profile_fields\"]:\n                if field[\"type\"] == CustomProfileField.PRONOUNS:\n                    field[\"type\"] = CustomProfileField.SHORT_TEXT\n\n            del state[\"custom_profile_field_types\"][\"PRONOUNS\"]\n\n    if want(\"hotspots\"):\n        # Even if we offered special hotspots for guests without an\n        # account, we'd maybe need to store their state using cookies\n        # or local storage, rather than in the database.\n        state[\"hotspots\"] = [] if user_profile is None else get_next_hotspots(user_profile)\n\n    if want(\"message\"):\n        # Since the introduction of `anchor=\"latest\"` in the API,\n        # `max_message_id` is primarily used for generating `local_id`\n        # values that are higher than this.  We likely can eventually\n        # remove this parameter from the API.\n        user_messages = None\n        if user_profile is not None:\n            user_messages = (\n                UserMessage.objects.filter(user_profile=user_profile)\n                .order_by(\"-message_id\")\n                .values(\"message_id\")[:1]\n            )\n        if user_messages:\n            state[\"max_message_id\"] = user_messages[0][\"message_id\"]\n        else:\n            state[\"max_message_id\"] = -1\n\n    if want(\"drafts\"):\n        if user_profile is None:\n            state[\"drafts\"] = []\n        else:\n            # Note: if a user ever disables syncing drafts then all of\n            # their old drafts stored on the server will be deleted and\n            # simply retained in local storage. In which case user_drafts\n            # would just be an empty queryset.\n            user_draft_objects = Draft.objects.filter(user_profile=user_profile).order_by(\n                \"-last_edit_time\"\n            )[: settings.MAX_DRAFTS_IN_REGISTER_RESPONSE]\n            user_draft_dicts = [draft.to_dict() for draft in user_draft_objects]\n            state[\"drafts\"] = user_draft_dicts\n\n    if want(\"scheduled_messages\"):\n        state[\"scheduled_messages\"] = (\n            [] if user_profile is None else get_undelivered_scheduled_messages(user_profile)\n        )\n\n    if want(\"muted_topics\") and (\n        # Suppress muted_topics data for clients that explicitly\n        # support user_topic. This allows clients to request both the\n        # user_topic and muted_topics, and receive the duplicate\n        # muted_topics data only from older servers that don't yet\n        # support user_topic.\n        event_types is None\n        or not want(\"user_topic\")\n    ):\n        state[\"muted_topics\"] = [] if user_profile is None else get_topic_mutes(user_profile)\n\n    if want(\"muted_users\"):\n        state[\"muted_users\"] = [] if user_profile is None else get_user_mutes(user_profile)\n\n    if want(\"presence\"):\n        state[\"presences\"] = (\n            {} if user_profile is None else get_presences_for_realm(realm, slim_presence)\n        )\n        # Send server_timestamp, to match the format of `GET /presence` requests.\n        state[\"server_timestamp\"] = time.time()\n\n    if want(\"realm\"):\n        # The realm bundle includes both realm properties and server\n        # properties, since it's rare that one would want one and not\n        # the other. We expect most clients to want it.\n        #\n        # A note on naming: For some settings, one could imagine\n        # having a server-level value and a realm-level value (with\n        # the server value serving as the default for the realm\n        # value). For such settings, we prefer the following naming\n        # scheme:\n        #\n        # * realm_inline_image_preview (current realm setting)\n        # * server_inline_image_preview (server-level default)\n        #\n        # In situations where for backwards-compatibility reasons we\n        # have an unadorned name, we should arrange that clients using\n        # that unadorned name work correctly (i.e. that should be the\n        # currently active setting, not a server-level default).\n        #\n        # Other settings, which are just server-level settings or data\n        # about the version of Zulip, can be named without prefixes,\n        # e.g. giphy_rating_options or development_environment.\n        for property_name in Realm.property_types:\n            state[\"realm_\" + property_name] = getattr(realm, property_name)\n\n        # Most state is handled via the property_types framework;\n        # these manual entries are for those realm settings that don't\n        # fit into that framework.\n        realm_authentication_methods_dict = realm.authentication_methods_dict()\n        state[\"realm_authentication_methods\"] = realm_authentication_methods_dict\n\n        # We pretend these features are disabled because anonymous\n        # users can't access them.  In the future, we may want to move\n        # this logic to the frontends, so that we can correctly\n        # display what these fields are in the settings.\n        state[\"realm_allow_message_editing\"] = (\n            False if user_profile is None else realm.allow_message_editing\n        )\n        state[\"realm_edit_topic_policy\"] = (\n            Realm.POLICY_ADMINS_ONLY if user_profile is None else realm.edit_topic_policy\n        )\n        state[\"realm_delete_own_message_policy\"] = (\n            Realm.POLICY_ADMINS_ONLY if user_profile is None else realm.delete_own_message_policy\n        )\n\n        # This setting determines whether to send presence and also\n        # whether to display of users list in the right sidebar; we\n        # want both behaviors for logged-out users.  We may in the\n        # future choose to move this logic to the frontend.\n        state[\"realm_presence_disabled\"] = True if user_profile is None else realm.presence_disabled\n\n        # Important: Encode units in the client-facing API name.\n        state[\"max_avatar_file_size_mib\"] = settings.MAX_AVATAR_FILE_SIZE_MIB\n        state[\"max_file_upload_size_mib\"] = settings.MAX_FILE_UPLOAD_SIZE\n        state[\"max_icon_file_size_mib\"] = settings.MAX_ICON_FILE_SIZE_MIB\n        state[\"realm_upload_quota_mib\"] = realm.upload_quota_bytes()\n\n        state[\"realm_icon_url\"] = realm_icon_url(realm)\n        state[\"realm_icon_source\"] = realm.icon_source\n        add_realm_logo_fields(state, realm)\n\n        state[\"realm_uri\"] = realm.uri\n        state[\"realm_bot_domain\"] = realm.get_bot_domain()\n        state[\"realm_available_video_chat_providers\"] = realm.VIDEO_CHAT_PROVIDERS\n        state[\"settings_send_digest_emails\"] = settings.SEND_DIGEST_EMAILS\n\n        state[\"realm_digest_emails_enabled\"] = (\n            realm.digest_emails_enabled and settings.SEND_DIGEST_EMAILS\n        )\n        state[\"realm_email_auth_enabled\"] = email_auth_enabled(\n            realm, realm_authentication_methods_dict\n        )\n        state[\"realm_password_auth_enabled\"] = password_auth_enabled(\n            realm, realm_authentication_methods_dict\n        )\n\n        state[\"server_generation\"] = settings.SERVER_GENERATION\n        state[\"realm_is_zephyr_mirror_realm\"] = realm.is_zephyr_mirror_realm\n        state[\"development_environment\"] = settings.DEVELOPMENT\n        state[\"realm_org_type\"] = realm.org_type\n        state[\"realm_plan_type\"] = realm.plan_type\n        state[\"zulip_plan_is_not_limited\"] = realm.plan_type != Realm.PLAN_TYPE_LIMITED\n        state[\"upgrade_text_for_wide_organization_logo\"] = str(Realm.UPGRADE_TEXT_STANDARD)\n\n        state[\"password_min_length\"] = settings.PASSWORD_MIN_LENGTH\n        state[\"password_min_guesses\"] = settings.PASSWORD_MIN_GUESSES\n        state[\"server_inline_image_preview\"] = settings.INLINE_IMAGE_PREVIEW\n        state[\"server_inline_url_embed_preview\"] = settings.INLINE_URL_EMBED_PREVIEW\n        state[\"server_avatar_changes_disabled\"] = settings.AVATAR_CHANGES_DISABLED\n        state[\"server_name_changes_disabled\"] = settings.NAME_CHANGES_DISABLED\n        state[\"server_web_public_streams_enabled\"] = settings.WEB_PUBLIC_STREAMS_ENABLED\n        state[\"giphy_rating_options\"] = realm.get_giphy_rating_options()\n\n        state[\"server_emoji_data_url\"] = emoji.data_url()\n\n        state[\"server_needs_upgrade\"] = is_outdated_server(user_profile)\n        state[\n            \"event_queue_longpoll_timeout_seconds\"\n        ] = settings.EVENT_QUEUE_LONGPOLL_TIMEOUT_SECONDS\n\n        # TODO: Should these have the realm prefix replaced with server_?\n        state[\"realm_push_notifications_enabled\"] = push_notifications_enabled()\n        state[\"realm_default_external_accounts\"] = get_default_external_accounts()\n\n        if settings.JITSI_SERVER_URL is not None:\n            state[\"jitsi_server_url\"] = settings.JITSI_SERVER_URL.rstrip(\"/\")\n        else:  # nocoverage\n            state[\"jitsi_server_url\"] = None\n\n        if realm.notifications_stream and not realm.notifications_stream.deactivated:\n            notifications_stream = realm.notifications_stream\n            state[\"realm_notifications_stream_id\"] = notifications_stream.id\n        else:\n            state[\"realm_notifications_stream_id\"] = -1\n\n        signup_notifications_stream = realm.get_signup_notifications_stream()\n        if signup_notifications_stream:\n            state[\"realm_signup_notifications_stream_id\"] = signup_notifications_stream.id\n        else:\n            state[\"realm_signup_notifications_stream_id\"] = -1\n\n        state[\"max_stream_name_length\"] = Stream.MAX_NAME_LENGTH\n        state[\"max_stream_description_length\"] = Stream.MAX_DESCRIPTION_LENGTH\n        state[\"max_topic_length\"] = MAX_TOPIC_NAME_LENGTH\n        state[\"max_message_length\"] = settings.MAX_MESSAGE_LENGTH\n        if realm.demo_organization_scheduled_deletion_date is not None:\n            state[\"demo_organization_scheduled_deletion_date\"] = datetime_to_timestamp(\n                realm.demo_organization_scheduled_deletion_date\n            )\n\n        # Presence system parameters for client behavior.\n        state[\"server_presence_ping_interval_seconds\"] = settings.PRESENCE_PING_INTERVAL_SECS\n        state[\"server_presence_offline_threshold_seconds\"] = settings.OFFLINE_THRESHOLD_SECS\n\n    if want(\"realm_user_settings_defaults\"):\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        state[\"realm_user_settings_defaults\"] = {}\n        for property_name in RealmUserDefault.property_types:\n            state[\"realm_user_settings_defaults\"][property_name] = getattr(\n                realm_user_default, property_name\n            )\n\n        state[\"realm_user_settings_defaults\"][\n            \"emojiset_choices\"\n        ] = RealmUserDefault.emojiset_choices()\n        state[\"realm_user_settings_defaults\"][\n            \"available_notification_sounds\"\n        ] = get_available_notification_sounds()\n\n    if want(\"realm_domains\"):\n        state[\"realm_domains\"] = get_realm_domains(realm)\n\n    if want(\"realm_emoji\"):\n        state[\"realm_emoji\"] = realm.get_emoji()\n\n    if want(\"realm_linkifiers\"):\n        if linkifier_url_template:\n            state[\"realm_linkifiers\"] = linkifiers_for_realm(realm.id)\n        else:\n            # When URL template is not supported by the client, return an empty list\n            # because the new format is incompatible with the old URL format strings\n            # and the client would not render it properly.\n            state[\"realm_linkifiers\"] = []\n\n    # Backwards compatibility code.\n    if want(\"realm_filters\"):\n        # Always return an empty list because the new URL template format is incompatible\n        # with the old URL format string, because legacy clients that use the\n        # backwards-compatible `realm_filters` event would not render the it properly.\n        state[\"realm_filters\"] = []\n\n    if want(\"realm_playgrounds\"):\n        state[\"realm_playgrounds\"] = get_realm_playgrounds(realm)\n\n    if want(\"realm_user_groups\"):\n        state[\"realm_user_groups\"] = user_groups_in_realm_serialized(realm)\n\n    if user_profile is not None:\n        settings_user = user_profile\n    else:\n        assert spectator_requested_language is not None\n        # When UserProfile=None, we want to serve the values for various\n        # settings as the defaults.  Instead of copying the default values\n        # from models.py here, we access these default values from a\n        # temporary UserProfile object that will not be saved to the database.\n        #\n        # We also can set various fields to avoid duplicating code\n        # unnecessarily.\n        settings_user = UserProfile(\n            full_name=\"Anonymous User\",\n            email=\"username@example.com\",\n            delivery_email=\"username@example.com\",\n            realm=realm,\n            # We tag logged-out users as guests because most guest\n            # restrictions apply to these users as well, and it lets\n            # us avoid unnecessary conditionals.\n            role=UserProfile.ROLE_GUEST,\n            is_billing_admin=False,\n            avatar_source=UserProfile.AVATAR_FROM_GRAVATAR,\n            # ID=0 is not used in real Zulip databases, ensuring this is unique.\n            id=0,\n            default_language=spectator_requested_language,\n        )\n    if want(\"realm_user\"):\n        state[\"raw_users\"] = get_raw_user_data(\n            realm,\n            user_profile,\n            client_gravatar=client_gravatar,\n            user_avatar_url_field_optional=user_avatar_url_field_optional,\n            # Don't send custom profile field values to spectators.\n            include_custom_profile_fields=user_profile is not None,\n        )\n        state[\"cross_realm_bots\"] = list(get_cross_realm_dicts())\n\n        # For the user's own avatar URL, we force\n        # client_gravatar=False, since that saves some unnecessary\n        # client-side code for handing medium-size avatars.  See #8253\n        # for details.\n        state[\"avatar_source\"] = settings_user.avatar_source\n        state[\"avatar_url_medium\"] = avatar_url(\n            settings_user,\n            medium=True,\n            client_gravatar=False,\n        )\n        state[\"avatar_url\"] = avatar_url(\n            settings_user,\n            medium=False,\n            client_gravatar=False,\n        )\n\n        state[\"can_create_private_streams\"] = settings_user.can_create_private_streams()\n        state[\"can_create_public_streams\"] = settings_user.can_create_public_streams()\n        # TODO/compatibility: Deprecated in Zulip 5.0 (feature level\n        # 102); we can remove this once we no longer need to support\n        # legacy mobile app versions that read the old property.\n        state[\"can_create_streams\"] = (\n            settings_user.can_create_private_streams()\n            or settings_user.can_create_public_streams()\n            or settings_user.can_create_web_public_streams()\n        )\n        state[\"can_create_web_public_streams\"] = settings_user.can_create_web_public_streams()\n        state[\"can_subscribe_other_users\"] = settings_user.can_subscribe_other_users()\n        state[\"can_invite_others_to_realm\"] = settings_user.can_invite_others_to_realm()\n        state[\"is_admin\"] = settings_user.is_realm_admin\n        state[\"is_owner\"] = settings_user.is_realm_owner\n        state[\"is_moderator\"] = settings_user.is_moderator\n        state[\"is_guest\"] = settings_user.is_guest\n        state[\"is_billing_admin\"] = settings_user.is_billing_admin\n        state[\"user_id\"] = settings_user.id\n        state[\"email\"] = settings_user.email\n        state[\"delivery_email\"] = settings_user.delivery_email\n        state[\"full_name\"] = settings_user.full_name\n\n    if want(\"realm_bot\"):\n        state[\"realm_bots\"] = [] if user_profile is None else get_owned_bot_dicts(user_profile)\n\n    # This does not yet have an apply_event counterpart, since currently,\n    # new entries for EMBEDDED_BOTS can only be added directly in the codebase.\n    if want(\"realm_embedded_bots\"):\n        realm_embedded_bots = []\n        for bot in EMBEDDED_BOTS:\n            realm_embedded_bots.append(\n                {\"name\": bot.name, \"config\": load_bot_config_template(bot.name)}\n            )\n        state[\"realm_embedded_bots\"] = realm_embedded_bots\n\n    # This does not have an apply_events counterpart either since\n    # this data is mostly static.\n    if want(\"realm_incoming_webhook_bots\"):\n        realm_incoming_webhook_bots = []\n        for integration in WEBHOOK_INTEGRATIONS:\n            realm_incoming_webhook_bots.append(\n                {\n                    \"name\": integration.name,\n                    \"config\": {c[1]: c[0] for c in integration.config_options},\n                }\n            )\n        state[\"realm_incoming_webhook_bots\"] = realm_incoming_webhook_bots\n\n    if want(\"recent_private_conversations\"):\n        # A data structure containing records of this form:\n        #\n        #   [{'max_message_id': 700175, 'user_ids': [801]}]\n        #\n        # for all recent private message conversations, ordered by the\n        # highest message ID in the conversation.  The user_ids list\n        # is the list of users other than the current user in the\n        # private message conversation (so it is [] for PMs to self).\n        # Note that raw_recent_private_conversations is an\n        # intermediate form as a dictionary keyed by recipient_id,\n        # which is more efficient to update, and is rewritten to the\n        # final format in post_process_state.\n        state[\"raw_recent_private_conversations\"] = (\n            {} if user_profile is None else get_recent_private_conversations(user_profile)\n        )\n\n    if want(\"subscription\"):\n        if user_profile is not None:\n            sub_info = gather_subscriptions_helper(\n                user_profile,\n                include_subscribers=include_subscribers,\n            )\n        else:\n            sub_info = get_web_public_subs(realm)\n\n        state[\"subscriptions\"] = sub_info.subscriptions\n        state[\"unsubscribed\"] = sub_info.unsubscribed\n        state[\"never_subscribed\"] = sub_info.never_subscribed\n\n    if want(\"update_message_flags\") and want(\"message\"):\n        # Keeping unread_msgs updated requires both message flag updates and\n        # message updates. This is due to the fact that new messages will not\n        # generate a flag update so we need to use the flags field in the\n        # message event.\n\n        if user_profile is not None:\n            state[\"raw_unread_msgs\"] = get_raw_unread_data(user_profile)\n        else:\n            # For logged-out visitors, we treat all messages as read;\n            # calling this helper lets us return empty objects in the\n            # appropriate format.\n            state[\"raw_unread_msgs\"] = extract_unread_data_from_um_rows([], user_profile)\n\n    if want(\"starred_messages\"):\n        state[\"starred_messages\"] = (\n            [] if user_profile is None else get_starred_message_ids(user_profile)\n        )\n\n    if want(\"stream\") and include_streams:\n        # The web app doesn't use the data from here; instead,\n        # it uses data from state[\"subscriptions\"] and other\n        # places.\n        if user_profile is not None:\n            state[\"streams\"] = do_get_streams(\n                user_profile,\n                include_web_public=True,\n                include_all_active=user_profile.is_realm_admin,\n            )\n        else:\n            # TODO: This line isn't used by the web app because it\n            # gets these data via the `subscriptions` key; it will\n            # be used when the mobile apps support logged-out\n            # access.\n            state[\"streams\"] = get_web_public_streams(realm)  # nocoverage\n    if want(\"default_streams\"):\n        if settings_user.is_guest:\n            # Guest users and logged-out users don't have access to\n            # all default streams, so we pretend the organization\n            # doesn't have any.\n            state[\"realm_default_streams\"] = []\n        else:\n            state[\"realm_default_streams\"] = streams_to_dicts_sorted(\n                get_default_streams_for_realm(realm.id)\n            )\n    if want(\"default_stream_groups\"):\n        if settings_user.is_guest:\n            state[\"realm_default_stream_groups\"] = []\n        else:\n            state[\"realm_default_stream_groups\"] = default_stream_groups_to_dicts_sorted(\n                get_default_stream_groups(realm)\n            )\n\n    if want(\"stop_words\"):\n        state[\"stop_words\"] = read_stop_words()\n\n    if want(\"update_display_settings\") and not user_settings_object:\n        for prop in UserProfile.display_settings_legacy:\n            state[prop] = getattr(settings_user, prop)\n        state[\"emojiset_choices\"] = UserProfile.emojiset_choices()\n        state[\"timezone\"] = canonicalize_timezone(settings_user.timezone)\n\n    if want(\"update_global_notifications\") and not user_settings_object:\n        for notification in UserProfile.notification_settings_legacy:\n            state[notification] = getattr(settings_user, notification)\n        state[\"available_notification_sounds\"] = get_available_notification_sounds()\n\n    if want(\"user_settings\"):\n        state[\"user_settings\"] = {}\n\n        for prop in UserProfile.property_types:\n            state[\"user_settings\"][prop] = getattr(settings_user, prop)\n\n        state[\"user_settings\"][\"emojiset_choices\"] = UserProfile.emojiset_choices()\n        state[\"user_settings\"][\"timezone\"] = canonicalize_timezone(settings_user.timezone)\n        state[\"user_settings\"][\n            \"available_notification_sounds\"\n        ] = get_available_notification_sounds()\n\n    if want(\"user_status\"):\n        # We require creating an account to access statuses.\n        state[\"user_status\"] = (\n            {} if user_profile is None else get_user_status_dict(realm_id=realm.id)\n        )\n\n    if want(\"user_topic\"):\n        state[\"user_topics\"] = [] if user_profile is None else get_user_topics(user_profile)\n\n    if want(\"video_calls\"):\n        state[\"has_zoom_token\"] = settings_user.zoom_token is not None\n\n    if want(\"giphy\"):\n        # Normally, it would be a nasty security bug to send a\n        # server's API key to end users. However, GIPHY's API key\n        # security model is precisely to do that; every service\n        # publishes its API key (and GIPHY's client-side JS libraries\n        # require the API key to work).  This security model makes\n        # sense because GIPHY API keys are all essentially equivalent\n        # in letting one search for GIFs; GIPHY only requires API keys\n        # to exist at all so that they can deactivate them in cases of\n        # abuse.\n        state[\"giphy_api_key\"] = settings.GIPHY_API_KEY if settings.GIPHY_API_KEY else \"\"\n\n    if user_profile is None:\n        # To ensure we have the correct user state set.\n        assert state[\"is_admin\"] is False\n        assert state[\"is_owner\"] is False\n        assert state[\"is_guest\"] is True\n\n    return state\n\n\ndef apply_events(\n    user_profile: UserProfile,\n    *,\n    state: Dict[str, Any],\n    events: Iterable[Dict[str, Any]],\n    fetch_event_types: Optional[Collection[str]],\n    client_gravatar: bool,\n    slim_presence: bool,\n    include_subscribers: bool,\n    linkifier_url_template: bool,\n) -> None:\n    for event in events:\n        if event[\"type\"] == \"restart\":\n            raise RestartEventError\n        if fetch_event_types is not None and event[\"type\"] not in fetch_event_types:\n            # TODO: continuing here is not, most precisely, correct.\n            # In theory, an event of one type, e.g. `realm_user`,\n            # could modify state that doesn't come from that\n            # `fetch_event_types` value, e.g. the `our_person` part of\n            # that code path.  But it should be extremely rare, and\n            # fixing that will require a nontrivial refactor of\n            # `apply_event`.  For now, be careful in your choice of\n            # `fetch_event_types`.\n            continue\n        apply_event(\n            user_profile,\n            state=state,\n            event=event,\n            client_gravatar=client_gravatar,\n            slim_presence=slim_presence,\n            include_subscribers=include_subscribers,\n            linkifier_url_template=linkifier_url_template,\n        )\n\n\ndef apply_event(\n    user_profile: UserProfile,\n    *,\n    state: Dict[str, Any],\n    event: Dict[str, Any],\n    client_gravatar: bool,\n    slim_presence: bool,\n    include_subscribers: bool,\n    linkifier_url_template: bool,\n) -> None:\n    if event[\"type\"] == \"message\":\n        state[\"max_message_id\"] = max(state[\"max_message_id\"], event[\"message\"][\"id\"])\n        if \"raw_unread_msgs\" in state:\n            apply_unread_message_event(\n                user_profile,\n                state[\"raw_unread_msgs\"],\n                event[\"message\"],\n                event[\"flags\"],\n            )\n\n        if event[\"message\"][\"type\"] != \"stream\":\n            if \"raw_recent_private_conversations\" in state:\n                # Handle maintaining the recent_private_conversations data structure.\n                conversations = state[\"raw_recent_private_conversations\"]\n                recipient_id = get_recent_conversations_recipient_id(\n                    user_profile, event[\"message\"][\"recipient_id\"], event[\"message\"][\"sender_id\"]\n                )\n\n                if recipient_id not in conversations:\n                    conversations[recipient_id] = dict(\n                        user_ids=sorted(\n                            user_dict[\"id\"]\n                            for user_dict in event[\"message\"][\"display_recipient\"]\n                            if user_dict[\"id\"] != user_profile.id\n                        ),\n                    )\n                conversations[recipient_id][\"max_message_id\"] = event[\"message\"][\"id\"]\n            return\n\n        # Below, we handle maintaining first_message_id.\n        for sub_dict in state.get(\"subscriptions\", []):\n            if (\n                event[\"message\"][\"stream_id\"] == sub_dict[\"stream_id\"]\n                and sub_dict[\"first_message_id\"] is None\n            ):\n                sub_dict[\"first_message_id\"] = event[\"message\"][\"id\"]\n        for stream_dict in state.get(\"streams\", []):\n            if (\n                event[\"message\"][\"stream_id\"] == stream_dict[\"stream_id\"]\n                and stream_dict[\"first_message_id\"] is None\n            ):\n                stream_dict[\"first_message_id\"] = event[\"message\"][\"id\"]\n\n    elif event[\"type\"] == \"heartbeat\":\n        # It may be impossible for a heartbeat event to actually reach\n        # this code path. But in any case, they're noops.\n        pass\n\n    elif event[\"type\"] == \"drafts\":\n        if event[\"op\"] == \"add\":\n            state[\"drafts\"].extend(event[\"drafts\"])\n        else:\n            if event[\"op\"] == \"update\":\n                event_draft_idx = event[\"draft\"][\"id\"]\n\n                def _draft_update_action(i: int) -> None:\n                    state[\"drafts\"][i] = event[\"draft\"]\n\n            elif event[\"op\"] == \"remove\":\n                event_draft_idx = event[\"draft_id\"]\n\n                def _draft_update_action(i: int) -> None:\n                    del state[\"drafts\"][i]\n\n            # We have to perform a linear search for the draft that\n            # was either edited or removed since we have a list\n            # ordered by the last edited timestamp and not id.\n            state_draft_idx = None\n            for idx, draft in enumerate(state[\"drafts\"]):\n                if draft[\"id\"] == event_draft_idx:\n                    state_draft_idx = idx\n                    break\n            assert state_draft_idx is not None\n            _draft_update_action(state_draft_idx)\n\n    elif event[\"type\"] == \"scheduled_messages\":\n        if event[\"op\"] == \"add\":\n            # Since bulk addition of scheduled messages will not be used by a normal user.\n            assert len(event[\"scheduled_messages\"]) == 1\n\n            state[\"scheduled_messages\"].append(event[\"scheduled_messages\"][0])\n            # Sort in ascending order of scheduled_delivery_timestamp.\n            state[\"scheduled_messages\"].sort(\n                key=lambda scheduled_message: scheduled_message[\"scheduled_delivery_timestamp\"]\n            )\n\n        if event[\"op\"] == \"update\":\n            for idx, scheduled_message in enumerate(state[\"scheduled_messages\"]):\n                if (\n                    scheduled_message[\"scheduled_message_id\"]\n                    == event[\"scheduled_message\"][\"scheduled_message_id\"]\n                ):\n                    state[\"scheduled_messages\"][idx] = event[\"scheduled_message\"]\n                    # If scheduled_delivery_timestamp was changed, we need to sort it again.\n                    if (\n                        scheduled_message[\"scheduled_delivery_timestamp\"]\n                        != event[\"scheduled_message\"][\"scheduled_delivery_timestamp\"]\n                    ):\n                        state[\"scheduled_messages\"].sort(\n                            key=lambda scheduled_message: scheduled_message[\n                                \"scheduled_delivery_timestamp\"\n                            ]\n                        )\n                    break\n\n        if event[\"op\"] == \"remove\":\n            for idx, scheduled_message in enumerate(state[\"scheduled_messages\"]):\n                if scheduled_message[\"scheduled_message_id\"] == event[\"scheduled_message_id\"]:\n                    del state[\"scheduled_messages\"][idx]\n\n    elif event[\"type\"] == \"hotspots\":\n        state[\"hotspots\"] = event[\"hotspots\"]\n    elif event[\"type\"] == \"custom_profile_fields\":\n        state[\"custom_profile_fields\"] = event[\"fields\"]\n        custom_profile_field_ids = {field[\"id\"] for field in state[\"custom_profile_fields\"]}\n\n        if \"raw_users\" in state:\n            for user_dict in state[\"raw_users\"].values():\n                if \"profile_data\" not in user_dict:\n                    continue\n                profile_data = user_dict[\"profile_data\"]\n                for field_id, field_data in list(profile_data.items()):\n                    if int(field_id) not in custom_profile_field_ids:\n                        del profile_data[field_id]\n    elif event[\"type\"] == \"realm_user\":\n        person = event[\"person\"]\n        person_user_id = person[\"user_id\"]\n\n        if event[\"op\"] == \"add\":\n            person = copy.deepcopy(person)\n\n            if client_gravatar:\n                email_address_visibility = UserProfile.objects.get(\n                    id=person_user_id\n                ).email_address_visibility\n                if email_address_visibility != UserProfile.EMAIL_ADDRESS_VISIBILITY_EVERYONE:\n                    client_gravatar = False\n\n            if client_gravatar and person[\"avatar_url\"].startswith(\"https://secure.gravatar.com/\"):\n                person[\"avatar_url\"] = None\n            person[\"is_active\"] = True\n            if not person[\"is_bot\"]:\n                person[\"profile_data\"] = {}\n            state[\"raw_users\"][person_user_id] = person\n        elif event[\"op\"] == \"remove\":\n            state[\"raw_users\"][person_user_id][\"is_active\"] = False\n            if include_subscribers:\n                for sub in state[\"subscriptions\"]:\n                    sub[\"subscribers\"] = [\n                        user_id for user_id in sub[\"subscribers\"] if user_id != person_user_id\n                    ]\n        elif event[\"op\"] == \"update\":\n            is_me = person_user_id == user_profile.id\n\n            if is_me:\n                if \"avatar_url\" in person and \"avatar_url\" in state:\n                    state[\"avatar_source\"] = person[\"avatar_source\"]\n                    state[\"avatar_url\"] = person[\"avatar_url\"]\n                    state[\"avatar_url_medium\"] = person[\"avatar_url_medium\"]\n\n                if \"role\" in person:\n                    state[\"is_admin\"] = is_administrator_role(person[\"role\"])\n                    state[\"is_owner\"] = person[\"role\"] == UserProfile.ROLE_REALM_OWNER\n                    state[\"is_moderator\"] = person[\"role\"] == UserProfile.ROLE_MODERATOR\n                    state[\"is_guest\"] = person[\"role\"] == UserProfile.ROLE_GUEST\n                    # Recompute properties based on is_admin/is_guest\n                    state[\"can_create_private_streams\"] = user_profile.can_create_private_streams()\n                    state[\"can_create_public_streams\"] = user_profile.can_create_public_streams()\n                    state[\n                        \"can_create_web_public_streams\"\n                    ] = user_profile.can_create_web_public_streams()\n                    state[\"can_create_streams\"] = (\n                        state[\"can_create_private_streams\"]\n                        or state[\"can_create_public_streams\"]\n                        or state[\"can_create_web_public_streams\"]\n                    )\n                    state[\"can_subscribe_other_users\"] = user_profile.can_subscribe_other_users()\n                    state[\"can_invite_others_to_realm\"] = user_profile.can_invite_others_to_realm()\n\n                    # TODO: Probably rather than writing the perfect\n                    # live-update code for the case of racing with the\n                    # current user changing roles, we should just do a\n                    # full refetch.\n                    if \"never_subscribed\" in state:\n                        sub_info = gather_subscriptions_helper(\n                            user_profile,\n                            include_subscribers=include_subscribers,\n                        )\n                        state[\"subscriptions\"] = sub_info.subscriptions\n                        state[\"unsubscribed\"] = sub_info.unsubscribed\n                        state[\"never_subscribed\"] = sub_info.never_subscribed\n\n                    if \"streams\" in state:\n                        state[\"streams\"] = do_get_streams(\n                            user_profile,\n                            include_web_public=True,\n                            include_all_active=user_profile.is_realm_admin,\n                        )\n\n                    if state[\"is_guest\"]:\n                        state[\"realm_default_streams\"] = []\n                    else:\n                        state[\"realm_default_streams\"] = streams_to_dicts_sorted(\n                            get_default_streams_for_realm(user_profile.realm_id)\n                        )\n\n                for field in [\"delivery_email\", \"email\", \"full_name\", \"is_billing_admin\"]:\n                    if field in person and field in state:\n                        state[field] = person[field]\n\n                if \"new_email\" in person:\n                    state[\"email\"] = person[\"new_email\"]\n\n                # In the unlikely event that the current user\n                # just changed to/from being an admin, we need\n                # to add/remove the data on all bots in the\n                # realm.  This is ugly and probably better\n                # solved by removing the all-realm-bots data\n                # given to admin users from this flow.\n                if \"role\" in person and \"realm_bots\" in state:\n                    prev_state = state[\"raw_users\"][user_profile.id]\n                    was_admin = prev_state[\"is_admin\"]\n                    now_admin = is_administrator_role(person[\"role\"])\n\n                    if was_admin and not now_admin:\n                        state[\"realm_bots\"] = []\n                    if not was_admin and now_admin:\n                        state[\"realm_bots\"] = get_owned_bot_dicts(user_profile)\n\n            if person_user_id in state[\"raw_users\"]:\n                p = state[\"raw_users\"][person_user_id]\n\n                if \"avatar_url\" in person:\n                    # Respect the client_gravatar setting in the `users` data.\n                    if client_gravatar:\n                        email_address_visibility = UserProfile.objects.get(\n                            id=person_user_id\n                        ).email_address_visibility\n                        if (\n                            email_address_visibility\n                            != UserProfile.EMAIL_ADDRESS_VISIBILITY_EVERYONE\n                        ):\n                            client_gravatar = False\n\n                    if client_gravatar and person[\"avatar_url\"].startswith(\n                        \"https://secure.gravatar.com/\"\n                    ):\n                        person[\"avatar_url\"] = None\n                        person[\"avatar_url_medium\"] = None\n\n                for field in p:\n                    if field in person:\n                        p[field] = person[field]\n                    if \"role\" in person:\n                        p[\"is_admin\"] = is_administrator_role(person[\"role\"])\n                        p[\"is_owner\"] = person[\"role\"] == UserProfile.ROLE_REALM_OWNER\n                        p[\"is_guest\"] = person[\"role\"] == UserProfile.ROLE_GUEST\n                    if \"is_billing_admin\" in person:\n                        p[\"is_billing_admin\"] = person[\"is_billing_admin\"]\n                    if \"custom_profile_field\" in person:\n                        custom_field_id = person[\"custom_profile_field\"][\"id\"]\n                        custom_field_new_value = person[\"custom_profile_field\"][\"value\"]\n                        if \"rendered_value\" in person[\"custom_profile_field\"]:\n                            p[\"profile_data\"][str(custom_field_id)] = {\n                                \"value\": custom_field_new_value,\n                                \"rendered_value\": person[\"custom_profile_field\"][\"rendered_value\"],\n                            }\n                        else:\n                            p[\"profile_data\"][str(custom_field_id)] = {\n                                \"value\": custom_field_new_value,\n                            }\n                    if \"new_email\" in person:\n                        p[\"email\"] = person[\"new_email\"]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"realm_bot\":\n        if event[\"op\"] == \"add\":\n            state[\"realm_bots\"].append(event[\"bot\"])\n        elif event[\"op\"] == \"remove\":\n            user_id = event[\"bot\"][\"user_id\"]\n            for bot in state[\"realm_bots\"]:\n                if bot[\"user_id\"] == user_id:\n                    bot[\"is_active\"] = False\n        elif event[\"op\"] == \"delete\":\n            state[\"realm_bots\"] = [\n                item for item in state[\"realm_bots\"] if item[\"user_id\"] != event[\"bot\"][\"user_id\"]\n            ]\n        elif event[\"op\"] == \"update\":\n            for bot in state[\"realm_bots\"]:\n                if bot[\"user_id\"] == event[\"bot\"][\"user_id\"]:\n                    if \"owner_id\" in event[\"bot\"]:\n                        bot_owner_id = event[\"bot\"][\"owner_id\"]\n                        bot[\"owner_id\"] = bot_owner_id\n                    else:\n                        bot.update(event[\"bot\"])\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"stream\":\n        if event[\"op\"] == \"create\":\n            for stream in event[\"streams\"]:\n                stream_data = copy.deepcopy(stream)\n                if include_subscribers:\n                    stream_data[\"subscribers\"] = []\n\n                # We know the stream has no traffic, and this\n                # field is not present in the event.\n                #\n                # TODO: Probably this should just be added to the event.\n                stream_data[\"stream_weekly_traffic\"] = None\n\n                # Add stream to never_subscribed (if not invite_only)\n                state[\"never_subscribed\"].append(stream_data)\n                if \"streams\" in state:\n                    state[\"streams\"].append(stream)\n\n            state[\"never_subscribed\"].sort(key=lambda elt: elt[\"name\"])\n            if \"streams\" in state:\n                state[\"streams\"].sort(key=lambda elt: elt[\"name\"])\n\n        if event[\"op\"] == \"delete\":\n            deleted_stream_ids = {stream[\"stream_id\"] for stream in event[\"streams\"]}\n            if \"streams\" in state:\n                state[\"streams\"] = [\n                    s for s in state[\"streams\"] if s[\"stream_id\"] not in deleted_stream_ids\n                ]\n            state[\"never_subscribed\"] = [\n                stream\n                for stream in state[\"never_subscribed\"]\n                if stream[\"stream_id\"] not in deleted_stream_ids\n            ]\n\n        if event[\"op\"] == \"update\":\n            # For legacy reasons, we call stream data 'subscriptions' in\n            # the state var here, for the benefit of the JS code.\n            for sub_list in [\n                state[\"subscriptions\"],\n                state[\"unsubscribed\"],\n                state[\"never_subscribed\"],\n            ]:\n                for obj in sub_list:\n                    if obj[\"name\"].lower() == event[\"name\"].lower():\n                        obj[event[\"property\"]] = event[\"value\"]\n                        if event[\"property\"] == \"description\":\n                            obj[\"rendered_description\"] = event[\"rendered_description\"]\n                        if event.get(\"history_public_to_subscribers\") is not None:\n                            obj[\"history_public_to_subscribers\"] = event[\n                                \"history_public_to_subscribers\"\n                            ]\n                        if event.get(\"is_web_public\") is not None:\n                            obj[\"is_web_public\"] = event[\"is_web_public\"]\n            # Also update the pure streams data\n            if \"streams\" in state:\n                for stream in state[\"streams\"]:\n                    if stream[\"name\"].lower() == event[\"name\"].lower():\n                        prop = event[\"property\"]\n                        if prop in stream:\n                            stream[prop] = event[\"value\"]\n                            if prop == \"description\":\n                                stream[\"rendered_description\"] = event[\"rendered_description\"]\n                            if event.get(\"history_public_to_subscribers\") is not None:\n                                stream[\"history_public_to_subscribers\"] = event[\n                                    \"history_public_to_subscribers\"\n                                ]\n                            if event.get(\"is_web_public\") is not None:\n                                stream[\"is_web_public\"] = event[\"is_web_public\"]\n\n    elif event[\"type\"] == \"default_streams\":\n        state[\"realm_default_streams\"] = event[\"default_streams\"]\n    elif event[\"type\"] == \"default_stream_groups\":\n        state[\"realm_default_stream_groups\"] = event[\"default_stream_groups\"]\n    elif event[\"type\"] == \"realm\":\n        if event[\"op\"] == \"update\":\n            field = \"realm_\" + event[\"property\"]\n            state[field] = event[\"value\"]\n\n            if event[\"property\"] == \"plan_type\":\n                # Then there are some extra fields that also need to be set.\n                state[\"zulip_plan_is_not_limited\"] = event[\"value\"] != Realm.PLAN_TYPE_LIMITED\n                state[\"realm_upload_quota_mib\"] = event[\"extra_data\"][\"upload_quota\"]\n\n            policy_permission_dict = {\n                \"create_public_stream_policy\": \"can_create_public_streams\",\n                \"create_private_stream_policy\": \"can_create_private_streams\",\n                \"create_web_public_stream_policy\": \"can_create_web_public_streams\",\n                \"invite_to_stream_policy\": \"can_subscribe_other_users\",\n                \"invite_to_realm_policy\": \"can_invite_others_to_realm\",\n            }\n\n            # Tricky interaction: Whether we can create streams and can subscribe other users\n            # can get changed here.\n\n            if field == \"realm_waiting_period_threshold\":\n                for policy, permission in policy_permission_dict.items():\n                    if permission in state:\n                        state[permission] = user_profile.has_permission(policy)\n\n            if (\n                event[\"property\"] in policy_permission_dict\n                and policy_permission_dict[event[\"property\"]] in state\n            ):\n                state[policy_permission_dict[event[\"property\"]]] = user_profile.has_permission(\n                    event[\"property\"]\n                )\n\n            # Finally, we need to recompute this value from its inputs.\n            state[\"can_create_streams\"] = (\n                state[\"can_create_private_streams\"]\n                or state[\"can_create_public_streams\"]\n                or state[\"can_create_web_public_streams\"]\n            )\n        elif event[\"op\"] == \"update_dict\":\n            for key, value in event[\"data\"].items():\n                state[\"realm_\" + key] = value\n                # It's a bit messy, but this is where we need to\n                # update the state for whether password authentication\n                # is enabled on this server.\n                if key == \"authentication_methods\":\n                    state[\"realm_password_auth_enabled\"] = value[\"Email\"] or value[\"LDAP\"]\n                    state[\"realm_email_auth_enabled\"] = value[\"Email\"]\n        elif event[\"op\"] == \"deactivated\":\n            # The realm has just been deactivated.  If our request had\n            # arrived a moment later, we'd have rendered the\n            # deactivation UI; if it'd been a moment sooner, we've\n            # have rendered the app and then immediately got this\n            # event (or actually, more likely, an auth error on GET\n            # /events) and immediately reloaded into the same\n            # deactivation UI. Passing achieves the same result.\n            pass\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"realm_user_settings_defaults\":\n        if event[\"op\"] == \"update\":\n            state[\"realm_user_settings_defaults\"][event[\"property\"]] = event[\"value\"]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"subscription\":\n        if event[\"op\"] == \"add\":\n            added_stream_ids = {sub[\"stream_id\"] for sub in event[\"subscriptions\"]}\n            was_added = lambda s: s[\"stream_id\"] in added_stream_ids\n\n            existing_stream_ids = {sub[\"stream_id\"] for sub in state[\"subscriptions\"]}\n\n            # add the new subscriptions\n            for sub in event[\"subscriptions\"]:\n                if sub[\"stream_id\"] not in existing_stream_ids:\n                    if \"subscribers\" in sub and not include_subscribers:\n                        sub = copy.deepcopy(sub)\n                        del sub[\"subscribers\"]\n                    state[\"subscriptions\"].append(sub)\n\n            # remove them from unsubscribed if they had been there\n            state[\"unsubscribed\"] = [s for s in state[\"unsubscribed\"] if not was_added(s)]\n\n            # remove them from never_subscribed if they had been there\n            state[\"never_subscribed\"] = [s for s in state[\"never_subscribed\"] if not was_added(s)]\n\n        elif event[\"op\"] == \"remove\":\n            removed_stream_ids = {sub[\"stream_id\"] for sub in event[\"subscriptions\"]}\n            was_removed = lambda s: s[\"stream_id\"] in removed_stream_ids\n\n            # Find the subs we are affecting.\n            removed_subs = list(filter(was_removed, state[\"subscriptions\"]))\n\n            # Remove our user from the subscribers of the removed subscriptions.\n            if include_subscribers:\n                for sub in removed_subs:\n                    sub[\"subscribers\"].remove(user_profile.id)\n\n            state[\"unsubscribed\"] += removed_subs\n\n            # Now filter out the removed subscriptions from subscriptions.\n            state[\"subscriptions\"] = [s for s in state[\"subscriptions\"] if not was_removed(s)]\n\n        elif event[\"op\"] == \"update\":\n            for sub in state[\"subscriptions\"]:\n                if sub[\"stream_id\"] == event[\"stream_id\"]:\n                    sub[event[\"property\"]] = event[\"value\"]\n        elif event[\"op\"] == \"peer_add\":\n            if include_subscribers:\n                stream_ids = set(event[\"stream_ids\"])\n                user_ids = set(event[\"user_ids\"])\n\n                for sub_dict in [\n                    state[\"subscriptions\"],\n                    state[\"unsubscribed\"],\n                    state[\"never_subscribed\"],\n                ]:\n                    for sub in sub_dict:\n                        if sub[\"stream_id\"] in stream_ids:\n                            subscribers = set(sub[\"subscribers\"]) | user_ids\n                            sub[\"subscribers\"] = sorted(subscribers)\n        elif event[\"op\"] == \"peer_remove\":\n            if include_subscribers:\n                stream_ids = set(event[\"stream_ids\"])\n                user_ids = set(event[\"user_ids\"])\n\n                for sub_dict in [\n                    state[\"subscriptions\"],\n                    state[\"unsubscribed\"],\n                    state[\"never_subscribed\"],\n                ]:\n                    for sub in sub_dict:\n                        if sub[\"stream_id\"] in stream_ids:\n                            subscribers = set(sub[\"subscribers\"]) - user_ids\n                            sub[\"subscribers\"] = sorted(subscribers)\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"presence\":\n        if slim_presence:\n            user_key = str(event[\"user_id\"])\n        else:\n            user_key = event[\"email\"]\n        state[\"presences\"][user_key] = get_presence_for_user(event[\"user_id\"], slim_presence)[\n            user_key\n        ]\n    elif event[\"type\"] == \"update_message\":\n        # We don't return messages in /register, so we don't need to\n        # do anything for content updates, but we may need to update\n        # the unread_msgs data if the topic of an unread message changed.\n        if \"raw_unread_msgs\" in state and \"new_stream_id\" in event:\n            stream_dict = state[\"raw_unread_msgs\"][\"stream_dict\"]\n            stream_id = event[\"new_stream_id\"]\n            for message_id in event[\"message_ids\"]:\n                if message_id in stream_dict:\n                    stream_dict[message_id][\"stream_id\"] = stream_id\n\n        if \"raw_unread_msgs\" in state and TOPIC_NAME in event:\n            stream_dict = state[\"raw_unread_msgs\"][\"stream_dict\"]\n            topic = event[TOPIC_NAME]\n            for message_id in event[\"message_ids\"]:\n                if message_id in stream_dict:\n                    stream_dict[message_id][\"topic\"] = topic\n    elif event[\"type\"] == \"delete_message\":\n        if \"message_id\" in event:\n            message_ids = [event[\"message_id\"]]\n        else:\n            message_ids = event[\"message_ids\"]  # nocoverage\n        max_message = (\n            Message.objects.filter(usermessage__user_profile=user_profile).order_by(\"-id\").first()\n        )\n        if max_message:\n            state[\"max_message_id\"] = max_message.id\n        else:\n            state[\"max_message_id\"] = -1\n\n        if \"raw_unread_msgs\" in state:\n            for remove_id in message_ids:\n                remove_message_id_from_unread_mgs(state[\"raw_unread_msgs\"], remove_id)\n\n        # The remainder of this block is about maintaining recent_private_conversations\n        if \"raw_recent_private_conversations\" not in state or event[\"message_type\"] != \"private\":\n            return\n\n        # OK, we just deleted what had been the max_message_id for\n        # this recent conversation; we need to recompute that value\n        # from scratch.  Definitely don't need to re-query everything,\n        # but this case is likely rare enough that it's reasonable to do so.\n        state[\"raw_recent_private_conversations\"] = get_recent_private_conversations(user_profile)\n    elif event[\"type\"] == \"reaction\":\n        # The client will get the message with the reactions directly\n        pass\n    elif event[\"type\"] == \"submessage\":\n        # The client will get submessages with their messages\n        pass\n    elif event[\"type\"] == \"typing\":\n        # Typing notification events are transient and thus ignored\n        pass\n    elif event[\"type\"] == \"attachment\":\n        # Attachment events are just for updating the \"uploads\" UI;\n        # they are not sent directly.\n        pass\n    elif event[\"type\"] == \"update_message_flags\":\n        # We don't return messages in `/register`, so most flags we\n        # can ignore, but we do need to update the unread_msgs data if\n        # unread state is changed.\n        if \"raw_unread_msgs\" in state and event[\"flag\"] == \"read\" and event[\"op\"] == \"add\":\n            for remove_id in event[\"messages\"]:\n                remove_message_id_from_unread_mgs(state[\"raw_unread_msgs\"], remove_id)\n        if \"raw_unread_msgs\" in state and event[\"flag\"] == \"read\" and event[\"op\"] == \"remove\":\n            for message_id_str, message_details in event[\"message_details\"].items():\n                add_message_to_unread_msgs(\n                    user_profile.id,\n                    state[\"raw_unread_msgs\"],\n                    int(message_id_str),\n                    message_details,\n                )\n        if event[\"flag\"] == \"starred\" and \"starred_messages\" in state:\n            if event[\"op\"] == \"add\":\n                state[\"starred_messages\"] += event[\"messages\"]\n            if event[\"op\"] == \"remove\":\n                state[\"starred_messages\"] = [\n                    message\n                    for message in state[\"starred_messages\"]\n                    if message not in event[\"messages\"]\n                ]\n    elif event[\"type\"] == \"realm_domains\":\n        if event[\"op\"] == \"add\":\n            state[\"realm_domains\"].append(event[\"realm_domain\"])\n        elif event[\"op\"] == \"change\":\n            for realm_domain in state[\"realm_domains\"]:\n                if realm_domain[\"domain\"] == event[\"realm_domain\"][\"domain\"]:\n                    realm_domain[\"allow_subdomains\"] = event[\"realm_domain\"][\"allow_subdomains\"]\n        elif event[\"op\"] == \"remove\":\n            state[\"realm_domains\"] = [\n                realm_domain\n                for realm_domain in state[\"realm_domains\"]\n                if realm_domain[\"domain\"] != event[\"domain\"]\n            ]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"realm_emoji\":\n        state[\"realm_emoji\"] = event[\"realm_emoji\"]\n    elif event[\"type\"] == \"realm_export\":\n        # These realm export events are only available to\n        # administrators, and aren't included in page_params.\n        pass\n    elif event[\"type\"] == \"alert_words\":\n        state[\"alert_words\"] = event[\"alert_words\"]\n    elif event[\"type\"] == \"muted_topics\":\n        state[\"muted_topics\"] = event[\"muted_topics\"]\n    elif event[\"type\"] == \"muted_users\":\n        state[\"muted_users\"] = event[\"muted_users\"]\n    elif event[\"type\"] == \"realm_linkifiers\":\n        # We only send realm_linkifiers event to clients that indicate\n        # support for linkifiers with URL templates. Otherwise, silently\n        # ignore the event.\n        if linkifier_url_template:\n            state[\"realm_linkifiers\"] = event[\"realm_linkifiers\"]\n    elif event[\"type\"] == \"realm_playgrounds\":\n        state[\"realm_playgrounds\"] = event[\"realm_playgrounds\"]\n    elif event[\"type\"] == \"update_display_settings\":\n        if event[\"setting_name\"] != \"timezone\":\n            assert event[\"setting_name\"] in UserProfile.display_settings_legacy\n        state[event[\"setting_name\"]] = event[\"setting\"]\n    elif event[\"type\"] == \"update_global_notifications\":\n        assert event[\"notification_name\"] in UserProfile.notification_settings_legacy\n        state[event[\"notification_name\"]] = event[\"setting\"]\n    elif event[\"type\"] == \"user_settings\":\n        # time zone setting is not included in property_types dict because\n        # this setting is not a part of UserBaseSettings class.\n        if event[\"property\"] != \"timezone\":\n            assert event[\"property\"] in UserProfile.property_types\n        if event[\"property\"] in {\n            **UserProfile.display_settings_legacy,\n            **UserProfile.notification_settings_legacy,\n        }:\n            state[event[\"property\"]] = event[\"value\"]\n        state[\"user_settings\"][event[\"property\"]] = event[\"value\"]\n    elif event[\"type\"] == \"invites_changed\":\n        pass\n    elif event[\"type\"] == \"user_group\":\n        if event[\"op\"] == \"add\":\n            state[\"realm_user_groups\"].append(event[\"group\"])\n            state[\"realm_user_groups\"].sort(key=lambda group: group[\"id\"])\n        elif event[\"op\"] == \"update\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    user_group.update(event[\"data\"])\n        elif event[\"op\"] == \"add_members\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    user_group[\"members\"].extend(event[\"user_ids\"])\n                    user_group[\"members\"].sort()\n        elif event[\"op\"] == \"remove_members\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    members = set(user_group[\"members\"])\n                    user_group[\"members\"] = list(members - set(event[\"user_ids\"]))\n                    user_group[\"members\"].sort()\n        elif event[\"op\"] == \"add_subgroups\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    user_group[\"direct_subgroup_ids\"].extend(event[\"direct_subgroup_ids\"])\n                    user_group[\"direct_subgroup_ids\"].sort()\n        elif event[\"op\"] == \"remove_subgroups\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    subgroups = set(user_group[\"direct_subgroup_ids\"])\n                    user_group[\"direct_subgroup_ids\"] = list(\n                        subgroups - set(event[\"direct_subgroup_ids\"])\n                    )\n                    user_group[\"direct_subgroup_ids\"].sort()\n        elif event[\"op\"] == \"remove\":\n            state[\"realm_user_groups\"] = [\n                ug for ug in state[\"realm_user_groups\"] if ug[\"id\"] != event[\"group_id\"]\n            ]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"user_status\":\n        user_id_str = str(event[\"user_id\"])\n        user_status = state[\"user_status\"]\n        away = event.get(\"away\")\n        status_text = event.get(\"status_text\")\n        emoji_name = event.get(\"emoji_name\")\n        emoji_code = event.get(\"emoji_code\")\n        reaction_type = event.get(\"reaction_type\")\n\n        if user_id_str not in user_status:\n            user_status[user_id_str] = {}\n\n        if away is not None:\n            if away:\n                user_status[user_id_str][\"away\"] = True\n            else:\n                user_status[user_id_str].pop(\"away\", None)\n\n        if status_text is not None:\n            if status_text == \"\":\n                user_status[user_id_str].pop(\"status_text\", None)\n            else:\n                user_status[user_id_str][\"status_text\"] = status_text\n\n            if emoji_name is not None:\n                if emoji_name == \"\":\n                    user_status[user_id_str].pop(\"emoji_name\", None)\n                else:\n                    user_status[user_id_str][\"emoji_name\"] = emoji_name\n\n                if emoji_code is not None:\n                    if emoji_code == \"\":\n                        user_status[user_id_str].pop(\"emoji_code\", None)\n                    else:\n                        user_status[user_id_str][\"emoji_code\"] = emoji_code\n\n                if reaction_type is not None:\n                    if reaction_type == UserStatus.UNICODE_EMOJI and emoji_name == \"\":\n                        user_status[user_id_str].pop(\"reaction_type\", None)\n                    else:\n                        user_status[user_id_str][\"reaction_type\"] = reaction_type\n\n        if not user_status[user_id_str]:\n            user_status.pop(user_id_str, None)\n\n        state[\"user_status\"] = user_status\n    elif event[\"type\"] == \"user_topic\":\n        if event[\"visibility_policy\"] == UserTopic.VisibilityPolicy.INHERIT:\n            user_topics_state = state[\"user_topics\"]\n            for i in range(len(user_topics_state)):\n                if (\n                    user_topics_state[i][\"stream_id\"] == event[\"stream_id\"]\n                    and user_topics_state[i][\"topic_name\"] == event[\"topic_name\"]\n                ):\n                    del user_topics_state[i]\n                    break\n        else:\n            fields = [\"stream_id\", \"topic_name\", \"visibility_policy\", \"last_updated\"]\n            state[\"user_topics\"].append({x: event[x] for x in fields})\n    elif event[\"type\"] == \"has_zoom_token\":\n        state[\"has_zoom_token\"] = event[\"value\"]\n    else:\n        raise AssertionError(\"Unexpected event type {}\".format(event[\"type\"]))\n\n\ndef do_events_register(\n    user_profile: Optional[UserProfile],\n    realm: Realm,\n    user_client: Client,\n    apply_markdown: bool = True,\n    client_gravatar: bool = False,\n    slim_presence: bool = False,\n    event_types: Optional[Sequence[str]] = None,\n    queue_lifespan_secs: int = 0,\n    all_public_streams: bool = False,\n    include_subscribers: bool = True,\n    include_streams: bool = True,\n    client_capabilities: Mapping[str, bool] = {},\n    narrow: Collection[Sequence[str]] = [],\n    fetch_event_types: Optional[Collection[str]] = None,\n    spectator_requested_language: Optional[str] = None,\n    pronouns_field_type_supported: bool = True,\n) -> Dict[str, Any]:\n    # Technically we don't need to check this here because\n    # build_narrow_filter will check it, but it's nicer from an error\n    # handling perspective to do it before contacting Tornado\n    check_supported_events_narrow_filter(narrow)\n\n    notification_settings_null = client_capabilities.get(\"notification_settings_null\", False)\n    bulk_message_deletion = client_capabilities.get(\"bulk_message_deletion\", False)\n    user_avatar_url_field_optional = client_capabilities.get(\n        \"user_avatar_url_field_optional\", False\n    )\n    stream_typing_notifications = client_capabilities.get(\"stream_typing_notifications\", False)\n    user_settings_object = client_capabilities.get(\"user_settings_object\", False)\n    linkifier_url_template = client_capabilities.get(\"linkifier_url_template\", False)\n\n    if fetch_event_types is not None:\n        event_types_set: Optional[Set[str]] = set(fetch_event_types)\n    elif event_types is not None:\n        event_types_set = set(event_types)\n    else:\n        event_types_set = None\n\n    if user_profile is None:\n        # TODO: Unify the two fetch_initial_state_data code paths.\n        assert client_gravatar is False\n        assert include_subscribers is False\n        assert include_streams is False\n        ret = fetch_initial_state_data(\n            user_profile,\n            realm=realm,\n            event_types=event_types_set,\n            queue_id=None,\n            # Force client_gravatar=False for security reasons.\n            client_gravatar=client_gravatar,\n            linkifier_url_template=linkifier_url_template,\n            user_avatar_url_field_optional=user_avatar_url_field_optional,\n            user_settings_object=user_settings_object,\n            # slim_presence is a noop, because presence is not included.\n            slim_presence=True,\n            # Force include_subscribers=False for security reasons.\n            include_subscribers=include_subscribers,\n            # Force include_streams=False for security reasons.\n            include_streams=include_streams,\n            spectator_requested_language=spectator_requested_language,\n        )\n\n        post_process_state(user_profile, ret, notification_settings_null=False)\n        return ret\n\n    # Fill up the UserMessage rows if a soft-deactivated user has returned\n    reactivate_user_if_soft_deactivated(user_profile)\n\n    while True:\n        # Note that we pass event_types, not fetch_event_types here, since\n        # that's what controls which future events are sent.\n        queue_id = request_event_queue(\n            user_profile,\n            user_client,\n            apply_markdown,\n            client_gravatar,\n            slim_presence,\n            queue_lifespan_secs,\n            event_types,\n            all_public_streams,\n            narrow=narrow,\n            bulk_message_deletion=bulk_message_deletion,\n            stream_typing_notifications=stream_typing_notifications,\n            user_settings_object=user_settings_object,\n            pronouns_field_type_supported=pronouns_field_type_supported,\n            linkifier_url_template=linkifier_url_template,\n        )\n\n        if queue_id is None:\n            raise JsonableError(_(\"Could not allocate event queue\"))\n\n        ret = fetch_initial_state_data(\n            user_profile,\n            event_types=event_types_set,\n            queue_id=queue_id,\n            client_gravatar=client_gravatar,\n            user_avatar_url_field_optional=user_avatar_url_field_optional,\n            user_settings_object=user_settings_object,\n            slim_presence=slim_presence,\n            include_subscribers=include_subscribers,\n            include_streams=include_streams,\n            pronouns_field_type_supported=pronouns_field_type_supported,\n            linkifier_url_template=linkifier_url_template,\n        )\n\n        # Apply events that came in while we were fetching initial data\n        events = get_user_events(user_profile, queue_id, -1)\n        try:\n            apply_events(\n                user_profile,\n                state=ret,\n                events=events,\n                fetch_event_types=fetch_event_types,\n                client_gravatar=client_gravatar,\n                slim_presence=slim_presence,\n                include_subscribers=include_subscribers,\n                linkifier_url_template=linkifier_url_template,\n            )\n        except RestartEventError:\n            # This represents a rare race condition, where Tornado\n            # restarted (and sent `restart` events) while we were waiting\n            # for fetch_initial_state_data to return. To avoid the client\n            # needing to reload shortly after loading, we recursively call\n            # do_events_register here.\n            continue\n        else:\n            break\n\n    post_process_state(user_profile, ret, notification_settings_null)\n\n    if len(events) > 0:\n        ret[\"last_event_id\"] = events[-1][\"id\"]\n    else:\n        ret[\"last_event_id\"] = -1\n    return ret\n\n\ndef post_process_state(\n    user_profile: Optional[UserProfile], ret: Dict[str, Any], notification_settings_null: bool\n) -> None:\n    \"\"\"\n    NOTE:\n\n    Below is an example of post-processing initial state data AFTER we\n    apply events.  For large payloads like `unread_msgs`, it's helpful\n    to have an intermediate data structure that is easy to manipulate\n    with O(1)-type operations as we apply events.\n\n    Then, only at the end, we put it in the form that's more appropriate\n    for client.\n    \"\"\"\n    if \"raw_unread_msgs\" in ret:\n        ret[\"unread_msgs\"] = aggregate_unread_data(ret[\"raw_unread_msgs\"])\n        del ret[\"raw_unread_msgs\"]\n\n    \"\"\"\n    See the note above; the same technique applies below.\n    \"\"\"\n    if \"raw_users\" in ret:\n        user_dicts = list(ret[\"raw_users\"].values())\n        user_dicts = sorted(user_dicts, key=lambda x: x[\"user_id\"])\n\n        ret[\"realm_users\"] = [d for d in user_dicts if d[\"is_active\"]]\n        ret[\"realm_non_active_users\"] = [d for d in user_dicts if not d[\"is_active\"]]\n\n        \"\"\"\n        Be aware that we do intentional aliasing in the below code.\n        We can now safely remove the `is_active` field from all the\n        dicts that got partitioned into the two lists above.\n\n        We remove the field because it's already implied, and sending\n        it to clients makes clients prone to bugs where they \"trust\"\n        the field but don't actually update in live updates.  It also\n        wastes bandwidth.\n        \"\"\"\n        for d in user_dicts:\n            d.pop(\"is_active\")\n\n        del ret[\"raw_users\"]\n\n    if \"raw_recent_private_conversations\" in ret:\n        # Reformat recent_private_conversations to be a list of dictionaries, rather than a dict.\n        ret[\"recent_private_conversations\"] = sorted(\n            (\n                dict(\n                    **value,\n                )\n                for (recipient_id, value) in ret[\"raw_recent_private_conversations\"].items()\n            ),\n            key=lambda x: -x[\"max_message_id\"],\n        )\n        del ret[\"raw_recent_private_conversations\"]\n\n    if not notification_settings_null and \"subscriptions\" in ret:\n        for stream_dict in ret[\"subscriptions\"] + ret[\"unsubscribed\"]:\n            handle_stream_notifications_compatibility(\n                user_profile, stream_dict, notification_settings_null\n            )\n", "import itertools\nfrom operator import itemgetter\nfrom typing import Any, Callable, Collection, Dict, Iterable, List, Mapping, Optional, Set, Tuple\n\nfrom django.core.exceptions import ValidationError\nfrom django.db import connection\nfrom django.db.models import QuerySet\nfrom django.utils.translation import gettext as _\nfrom psycopg2.sql import SQL\n\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.stream_color import STREAM_ASSIGNMENT_COLORS\nfrom zerver.lib.stream_subscription import (\n    get_active_subscriptions_for_stream_id,\n    get_stream_subscriptions_for_user,\n)\nfrom zerver.lib.stream_traffic import get_average_weekly_stream_traffic, get_streams_traffic\nfrom zerver.lib.streams import get_web_public_streams_queryset, subscribed_to_stream\nfrom zerver.lib.timestamp import datetime_to_timestamp\nfrom zerver.lib.types import (\n    NeverSubscribedStreamDict,\n    RawStreamDict,\n    RawSubscriptionDict,\n    SubscriptionInfo,\n    SubscriptionStreamDict,\n)\nfrom zerver.models import Realm, Stream, Subscription, UserProfile, get_active_streams\n\n\ndef get_web_public_subs(realm: Realm) -> SubscriptionInfo:\n    color_idx = 0\n\n    def get_next_color() -> str:\n        nonlocal color_idx\n        color = STREAM_ASSIGNMENT_COLORS[color_idx]\n        color_idx = (color_idx + 1) % len(STREAM_ASSIGNMENT_COLORS)\n        return color\n\n    subscribed = []\n    for stream in get_web_public_streams_queryset(realm):\n        # Add Stream fields.\n        can_remove_subscribers_group_id = stream.can_remove_subscribers_group_id\n        date_created = datetime_to_timestamp(stream.date_created)\n        description = stream.description\n        first_message_id = stream.first_message_id\n        history_public_to_subscribers = stream.history_public_to_subscribers\n        invite_only = stream.invite_only\n        is_announcement_only = stream.stream_post_policy == Stream.STREAM_POST_POLICY_ADMINS\n        is_web_public = stream.is_web_public\n        message_retention_days = stream.message_retention_days\n        name = stream.name\n        rendered_description = stream.rendered_description\n        stream_id = stream.id\n        stream_post_policy = stream.stream_post_policy\n\n        # Add versions of the Subscription fields based on a simulated\n        # new user subscription set.\n        audible_notifications = True\n        color = get_next_color()\n        desktop_notifications = True\n        email_notifications = True\n        in_home_view = True\n        is_muted = False\n        pin_to_top = False\n        push_notifications = True\n        stream_weekly_traffic = get_average_weekly_stream_traffic(\n            stream.id, stream.date_created, {}\n        )\n        wildcard_mentions_notify = True\n\n        sub = SubscriptionStreamDict(\n            audible_notifications=audible_notifications,\n            can_remove_subscribers_group_id=can_remove_subscribers_group_id,\n            color=color,\n            date_created=date_created,\n            description=description,\n            desktop_notifications=desktop_notifications,\n            email_notifications=email_notifications,\n            first_message_id=first_message_id,\n            history_public_to_subscribers=history_public_to_subscribers,\n            in_home_view=in_home_view,\n            invite_only=invite_only,\n            is_announcement_only=is_announcement_only,\n            is_muted=is_muted,\n            is_web_public=is_web_public,\n            message_retention_days=message_retention_days,\n            name=name,\n            pin_to_top=pin_to_top,\n            push_notifications=push_notifications,\n            rendered_description=rendered_description,\n            stream_id=stream_id,\n            stream_post_policy=stream_post_policy,\n            stream_weekly_traffic=stream_weekly_traffic,\n            wildcard_mentions_notify=wildcard_mentions_notify,\n        )\n        subscribed.append(sub)\n\n    return SubscriptionInfo(\n        subscriptions=subscribed,\n        unsubscribed=[],\n        never_subscribed=[],\n    )\n\n\ndef build_stream_dict_for_sub(\n    user: UserProfile,\n    sub_dict: RawSubscriptionDict,\n    raw_stream_dict: RawStreamDict,\n    recent_traffic: Dict[int, int],\n) -> SubscriptionStreamDict:\n    # Handle Stream.API_FIELDS\n    can_remove_subscribers_group_id = raw_stream_dict[\"can_remove_subscribers_group_id\"]\n    date_created = datetime_to_timestamp(raw_stream_dict[\"date_created\"])\n    description = raw_stream_dict[\"description\"]\n    first_message_id = raw_stream_dict[\"first_message_id\"]\n    history_public_to_subscribers = raw_stream_dict[\"history_public_to_subscribers\"]\n    invite_only = raw_stream_dict[\"invite_only\"]\n    is_web_public = raw_stream_dict[\"is_web_public\"]\n    message_retention_days = raw_stream_dict[\"message_retention_days\"]\n    name = raw_stream_dict[\"name\"]\n    rendered_description = raw_stream_dict[\"rendered_description\"]\n    stream_id = raw_stream_dict[\"id\"]\n    stream_post_policy = raw_stream_dict[\"stream_post_policy\"]\n\n    # Handle Subscription.API_FIELDS.\n    color = sub_dict[\"color\"]\n    is_muted = sub_dict[\"is_muted\"]\n    pin_to_top = sub_dict[\"pin_to_top\"]\n    audible_notifications = sub_dict[\"audible_notifications\"]\n    desktop_notifications = sub_dict[\"desktop_notifications\"]\n    email_notifications = sub_dict[\"email_notifications\"]\n    push_notifications = sub_dict[\"push_notifications\"]\n    wildcard_mentions_notify = sub_dict[\"wildcard_mentions_notify\"]\n\n    # Backwards-compatibility for clients that haven't been\n    # updated for the in_home_view => is_muted API migration.\n    in_home_view = not is_muted\n\n    # Backwards-compatibility for clients that haven't been\n    # updated for the is_announcement_only -> stream_post_policy\n    # migration.\n    is_announcement_only = raw_stream_dict[\"stream_post_policy\"] == Stream.STREAM_POST_POLICY_ADMINS\n\n    # Add a few computed fields not directly from the data models.\n    stream_weekly_traffic = get_average_weekly_stream_traffic(\n        raw_stream_dict[\"id\"], raw_stream_dict[\"date_created\"], recent_traffic\n    )\n\n    # Our caller may add a subscribers field.\n    return SubscriptionStreamDict(\n        audible_notifications=audible_notifications,\n        can_remove_subscribers_group_id=can_remove_subscribers_group_id,\n        color=color,\n        date_created=date_created,\n        description=description,\n        desktop_notifications=desktop_notifications,\n        email_notifications=email_notifications,\n        first_message_id=first_message_id,\n        history_public_to_subscribers=history_public_to_subscribers,\n        in_home_view=in_home_view,\n        invite_only=invite_only,\n        is_announcement_only=is_announcement_only,\n        is_muted=is_muted,\n        is_web_public=is_web_public,\n        message_retention_days=message_retention_days,\n        name=name,\n        pin_to_top=pin_to_top,\n        push_notifications=push_notifications,\n        rendered_description=rendered_description,\n        stream_id=stream_id,\n        stream_post_policy=stream_post_policy,\n        stream_weekly_traffic=stream_weekly_traffic,\n        wildcard_mentions_notify=wildcard_mentions_notify,\n    )\n\n\ndef build_stream_dict_for_never_sub(\n    raw_stream_dict: RawStreamDict,\n    recent_traffic: Dict[int, int],\n) -> NeverSubscribedStreamDict:\n    can_remove_subscribers_group_id = raw_stream_dict[\"can_remove_subscribers_group_id\"]\n    date_created = datetime_to_timestamp(raw_stream_dict[\"date_created\"])\n    description = raw_stream_dict[\"description\"]\n    first_message_id = raw_stream_dict[\"first_message_id\"]\n    history_public_to_subscribers = raw_stream_dict[\"history_public_to_subscribers\"]\n    invite_only = raw_stream_dict[\"invite_only\"]\n    is_web_public = raw_stream_dict[\"is_web_public\"]\n    message_retention_days = raw_stream_dict[\"message_retention_days\"]\n    name = raw_stream_dict[\"name\"]\n    rendered_description = raw_stream_dict[\"rendered_description\"]\n    stream_id = raw_stream_dict[\"id\"]\n    stream_post_policy = raw_stream_dict[\"stream_post_policy\"]\n    stream_weekly_traffic = get_average_weekly_stream_traffic(\n        raw_stream_dict[\"id\"], raw_stream_dict[\"date_created\"], recent_traffic\n    )\n\n    # Backwards-compatibility addition of removed field.\n    is_announcement_only = raw_stream_dict[\"stream_post_policy\"] == Stream.STREAM_POST_POLICY_ADMINS\n\n    # Our caller may add a subscribers field.\n    return NeverSubscribedStreamDict(\n        can_remove_subscribers_group_id=can_remove_subscribers_group_id,\n        date_created=date_created,\n        description=description,\n        first_message_id=first_message_id,\n        history_public_to_subscribers=history_public_to_subscribers,\n        invite_only=invite_only,\n        is_announcement_only=is_announcement_only,\n        is_web_public=is_web_public,\n        message_retention_days=message_retention_days,\n        name=name,\n        rendered_description=rendered_description,\n        stream_id=stream_id,\n        stream_post_policy=stream_post_policy,\n        stream_weekly_traffic=stream_weekly_traffic,\n    )\n\n\ndef validate_user_access_to_subscribers(\n    user_profile: Optional[UserProfile], stream: Stream\n) -> None:\n    \"\"\"Validates whether the user can view the subscribers of a stream.  Raises a JsonableError if:\n    * The user and the stream are in different realms\n    * The realm is MIT and the stream is not invite only.\n    * The stream is invite only, requesting_user is passed, and that user\n      does not subscribe to the stream.\n    \"\"\"\n    validate_user_access_to_subscribers_helper(\n        user_profile,\n        {\n            \"realm_id\": stream.realm_id,\n            \"is_web_public\": stream.is_web_public,\n            \"invite_only\": stream.invite_only,\n        },\n        # We use a lambda here so that we only compute whether the\n        # user is subscribed if we have to\n        lambda user_profile: subscribed_to_stream(user_profile, stream.id),\n    )\n\n\ndef validate_user_access_to_subscribers_helper(\n    user_profile: Optional[UserProfile],\n    stream_dict: Mapping[str, Any],\n    check_user_subscribed: Callable[[UserProfile], bool],\n) -> None:\n    \"\"\"Helper for validate_user_access_to_subscribers that doesn't require\n    a full stream object.  This function is a bit hard to read,\n    because it is carefully optimized for performance in the two code\n    paths we call it from:\n\n    * In `bulk_get_subscriber_user_ids`, we already know whether the\n    user was subscribed via `sub_dict`, and so we want to avoid a\n    database query at all (especially since it calls this in a loop);\n    * In `validate_user_access_to_subscribers`, we want to only check\n    if the user is subscribed when we absolutely have to, since it\n    costs a database query.\n\n    The `check_user_subscribed` argument is a function that reports\n    whether the user is subscribed to the stream.\n\n    Note also that we raise a ValidationError in cases where the\n    caller is doing the wrong thing (maybe these should be\n    AssertionErrors), and JsonableError for 400 type errors.\n    \"\"\"\n    if user_profile is None:\n        raise ValidationError(\"Missing user to validate access for\")\n\n    if user_profile.realm_id != stream_dict[\"realm_id\"]:\n        raise ValidationError(\"Requesting user not in given realm\")\n\n    # Even guest users can access subscribers to web-public streams,\n    # since they can freely become subscribers to these streams.\n    if stream_dict[\"is_web_public\"]:\n        return\n\n    # With the exception of web-public streams, a guest must\n    # be subscribed to a stream (even a public one) in order\n    # to see subscribers.\n    if user_profile.is_guest and check_user_subscribed(user_profile):\n        return\n        # We could explicitly handle the case where guests aren't\n        # subscribed here in an `else` statement or we can fall\n        # through to the subsequent logic.  Tim prefers the latter.\n        # Adding an `else` would ensure better code coverage.\n\n    if not user_profile.can_access_public_streams() and not stream_dict[\"invite_only\"]:\n        raise JsonableError(_(\"Subscriber data is not available for this stream\"))\n\n    # Organization administrators can view subscribers for all streams.\n    if user_profile.is_realm_admin:\n        return\n\n    if stream_dict[\"invite_only\"] and not check_user_subscribed(user_profile):\n        raise JsonableError(_(\"Unable to retrieve subscribers for private stream\"))\n\n\ndef bulk_get_subscriber_user_ids(\n    stream_dicts: Collection[Mapping[str, Any]],\n    user_profile: UserProfile,\n    subscribed_stream_ids: Set[int],\n) -> Dict[int, List[int]]:\n    \"\"\"sub_dict maps stream_id => whether the user is subscribed to that stream.\"\"\"\n    target_stream_dicts = []\n    for stream_dict in stream_dicts:\n        stream_id = stream_dict[\"id\"]\n        is_subscribed = stream_id in subscribed_stream_ids\n\n        try:\n            validate_user_access_to_subscribers_helper(\n                user_profile,\n                stream_dict,\n                lambda user_profile: is_subscribed,\n            )\n        except JsonableError:\n            continue\n        target_stream_dicts.append(stream_dict)\n\n    recip_to_stream_id = {stream[\"recipient_id\"]: stream[\"id\"] for stream in target_stream_dicts}\n    recipient_ids = sorted(stream[\"recipient_id\"] for stream in target_stream_dicts)\n\n    result: Dict[int, List[int]] = {stream[\"id\"]: [] for stream in stream_dicts}\n    if not recipient_ids:\n        return result\n\n    \"\"\"\n    The raw SQL below leads to more than a 2x speedup when tested with\n    20k+ total subscribers.  (For large realms with lots of default\n    streams, this function deals with LOTS of data, so it is important\n    to optimize.)\n    \"\"\"\n\n    query = SQL(\n        \"\"\"\n        SELECT\n            zerver_subscription.recipient_id,\n            zerver_subscription.user_profile_id\n        FROM\n            zerver_subscription\n        WHERE\n            zerver_subscription.recipient_id in %(recipient_ids)s AND\n            zerver_subscription.active AND\n            zerver_subscription.is_user_active\n        ORDER BY\n            zerver_subscription.recipient_id,\n            zerver_subscription.user_profile_id\n        \"\"\"\n    )\n\n    cursor = connection.cursor()\n    cursor.execute(query, {\"recipient_ids\": tuple(recipient_ids)})\n    rows = cursor.fetchall()\n    cursor.close()\n\n    \"\"\"\n    Using groupby/itemgetter here is important for performance, at scale.\n    It makes it so that all interpreter overhead is just O(N) in nature.\n    \"\"\"\n    for recip_id, recip_rows in itertools.groupby(rows, itemgetter(0)):\n        user_profile_ids = [r[1] for r in recip_rows]\n        stream_id = recip_to_stream_id[recip_id]\n        result[stream_id] = list(user_profile_ids)\n\n    return result\n\n\ndef get_subscribers_query(\n    stream: Stream, requesting_user: Optional[UserProfile]\n) -> QuerySet[Subscription]:\n    \"\"\"Build a query to get the subscribers list for a stream, raising a JsonableError if:\n\n    'realm' is optional in stream.\n\n    The caller can refine this query with select_related(), values(), etc. depending\n    on whether it wants objects or just certain fields\n    \"\"\"\n    validate_user_access_to_subscribers(requesting_user, stream)\n\n    return get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=False)\n\n\n# In general, it's better to avoid using .values() because it makes\n# the code pretty ugly, but in this case, it has significant\n# performance impact for loading / for users with large numbers of\n# subscriptions, so it's worth optimizing.\ndef gather_subscriptions_helper(\n    user_profile: UserProfile,\n    include_subscribers: bool = True,\n) -> SubscriptionInfo:\n    realm = user_profile.realm\n    all_streams = get_active_streams(realm).values(\n        *Stream.API_FIELDS,\n        # The realm_id and recipient_id are generally not needed in the API.\n        \"realm_id\",\n        \"recipient_id\",\n    )\n    recip_id_to_stream_id: Dict[int, int] = {\n        stream[\"recipient_id\"]: stream[\"id\"] for stream in all_streams\n    }\n    all_streams_map: Dict[int, RawStreamDict] = {stream[\"id\"]: stream for stream in all_streams}\n\n    sub_dicts_query: Iterable[RawSubscriptionDict] = (\n        get_stream_subscriptions_for_user(user_profile)\n        .values(\n            *Subscription.API_FIELDS,\n            \"recipient_id\",\n            \"active\",\n        )\n        .order_by(\"recipient_id\")\n    )\n\n    # We only care about subscriptions for active streams.\n    sub_dicts: List[RawSubscriptionDict] = [\n        sub_dict\n        for sub_dict in sub_dicts_query\n        if recip_id_to_stream_id.get(sub_dict[\"recipient_id\"])\n    ]\n\n    def get_stream_id(sub_dict: RawSubscriptionDict) -> int:\n        return recip_id_to_stream_id[sub_dict[\"recipient_id\"]]\n\n    traffic_stream_ids = {get_stream_id(sub_dict) for sub_dict in sub_dicts}\n    recent_traffic = get_streams_traffic(stream_ids=traffic_stream_ids)\n\n    # Okay, now we finally get to populating our main results, which\n    # will be these three lists.\n    subscribed: List[SubscriptionStreamDict] = []\n    unsubscribed: List[SubscriptionStreamDict] = []\n    never_subscribed: List[NeverSubscribedStreamDict] = []\n\n    sub_unsub_stream_ids = set()\n    for sub_dict in sub_dicts:\n        stream_id = get_stream_id(sub_dict)\n        sub_unsub_stream_ids.add(stream_id)\n        raw_stream_dict = all_streams_map[stream_id]\n\n        stream_dict = build_stream_dict_for_sub(\n            user=user_profile,\n            sub_dict=sub_dict,\n            raw_stream_dict=raw_stream_dict,\n            recent_traffic=recent_traffic,\n        )\n\n        # is_active is represented in this structure by which list we include it in.\n        is_active = sub_dict[\"active\"]\n        if is_active:\n            subscribed.append(stream_dict)\n        else:\n            unsubscribed.append(stream_dict)\n\n    if user_profile.can_access_public_streams():\n        never_subscribed_stream_ids = set(all_streams_map) - sub_unsub_stream_ids\n    else:\n        web_public_stream_ids = {stream[\"id\"] for stream in all_streams if stream[\"is_web_public\"]}\n        never_subscribed_stream_ids = web_public_stream_ids - sub_unsub_stream_ids\n\n    never_subscribed_streams = [\n        all_streams_map[stream_id] for stream_id in never_subscribed_stream_ids\n    ]\n\n    for raw_stream_dict in never_subscribed_streams:\n        is_public = not raw_stream_dict[\"invite_only\"]\n        if is_public or user_profile.is_realm_admin:\n            slim_stream_dict = build_stream_dict_for_never_sub(\n                raw_stream_dict=raw_stream_dict, recent_traffic=recent_traffic\n            )\n\n            never_subscribed.append(slim_stream_dict)\n\n    if include_subscribers:\n        # The highly optimized bulk_get_subscriber_user_ids wants to know which\n        # streams we are subscribed to, for validation purposes, and it uses that\n        # info to know if it's allowed to find OTHER subscribers.\n        subscribed_stream_ids = {\n            get_stream_id(sub_dict) for sub_dict in sub_dicts if sub_dict[\"active\"]\n        }\n\n        subscriber_map = bulk_get_subscriber_user_ids(\n            all_streams,\n            user_profile,\n            subscribed_stream_ids,\n        )\n\n        for lst in [subscribed, unsubscribed]:\n            for stream_dict in lst:\n                assert isinstance(stream_dict[\"stream_id\"], int)\n                stream_id = stream_dict[\"stream_id\"]\n                stream_dict[\"subscribers\"] = subscriber_map[stream_id]\n\n        for slim_stream_dict in never_subscribed:\n            assert isinstance(slim_stream_dict[\"stream_id\"], int)\n            stream_id = slim_stream_dict[\"stream_id\"]\n            slim_stream_dict[\"subscribers\"] = subscriber_map[stream_id]\n\n    subscribed.sort(key=lambda x: x[\"name\"])\n    unsubscribed.sort(key=lambda x: x[\"name\"])\n    never_subscribed.sort(key=lambda x: x[\"name\"])\n\n    return SubscriptionInfo(\n        subscriptions=subscribed,\n        unsubscribed=unsubscribed,\n        never_subscribed=never_subscribed,\n    )\n\n\ndef gather_subscriptions(\n    user_profile: UserProfile,\n    include_subscribers: bool = False,\n) -> Tuple[List[SubscriptionStreamDict], List[SubscriptionStreamDict]]:\n    helper_result = gather_subscriptions_helper(\n        user_profile,\n        include_subscribers=include_subscribers,\n    )\n    subscribed = helper_result.subscriptions\n    unsubscribed = helper_result.unsubscribed\n    return (subscribed, unsubscribed)\n", "import hashlib\nimport random\nfrom datetime import timedelta\nfrom io import StringIO\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence, Set, Union\nfrom unittest import mock\n\nimport orjson\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse\nfrom django.utils.timezone import now as timezone_now\n\nfrom zerver.actions.bots import do_change_bot_owner\nfrom zerver.actions.create_realm import do_create_realm\nfrom zerver.actions.default_streams import (\n    do_add_default_stream,\n    do_add_streams_to_default_stream_group,\n    do_change_default_stream_group_description,\n    do_change_default_stream_group_name,\n    do_create_default_stream_group,\n    do_remove_default_stream,\n    do_remove_default_stream_group,\n    do_remove_streams_from_default_stream_group,\n    get_default_streams_for_realm,\n    lookup_default_stream_groups,\n)\nfrom zerver.actions.realm_settings import do_change_realm_plan_type, do_set_realm_property\nfrom zerver.actions.streams import (\n    bulk_add_subscriptions,\n    bulk_remove_subscriptions,\n    deactivated_streams_by_old_name,\n    do_change_stream_group_based_setting,\n    do_change_stream_permission,\n    do_change_stream_post_policy,\n    do_deactivate_stream,\n    do_unarchive_stream,\n)\nfrom zerver.actions.user_groups import add_subgroups_to_user_group, check_add_user_group\nfrom zerver.actions.users import do_change_user_role, do_deactivate_user\nfrom zerver.lib.email_mirror_helpers import encode_email_address_helper\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.message import UnreadStreamInfo, aggregate_unread_data, get_raw_unread_data\nfrom zerver.lib.response import json_success\nfrom zerver.lib.stream_color import STREAM_ASSIGNMENT_COLORS, pick_colors\nfrom zerver.lib.stream_subscription import (\n    get_active_subscriptions_for_stream_id,\n    num_subscribers_for_stream_id,\n    subscriber_ids_with_stream_history_access,\n)\nfrom zerver.lib.stream_traffic import (\n    get_average_weekly_stream_traffic,\n    round_to_2_significant_digits,\n)\nfrom zerver.lib.streams import (\n    StreamDict,\n    access_stream_by_id,\n    access_stream_by_name,\n    can_access_stream_history,\n    can_access_stream_user_ids,\n    create_stream_if_needed,\n    create_streams_if_needed,\n    do_get_streams,\n    ensure_stream,\n    filter_stream_authorization,\n    list_to_streams,\n)\nfrom zerver.lib.subscription_info import (\n    bulk_get_subscriber_user_ids,\n    gather_subscriptions,\n    gather_subscriptions_helper,\n    validate_user_access_to_subscribers_helper,\n)\nfrom zerver.lib.test_classes import ZulipTestCase, get_topic_messages\nfrom zerver.lib.test_helpers import (\n    HostRequestMock,\n    cache_tries_captured,\n    get_subscription,\n    most_recent_message,\n    most_recent_usermessage,\n    reset_email_visibility_to_everyone_in_zulip_realm,\n)\nfrom zerver.lib.types import (\n    APIStreamDict,\n    APISubscriptionDict,\n    NeverSubscribedStreamDict,\n    SubscriptionInfo,\n)\nfrom zerver.models import (\n    Attachment,\n    DefaultStream,\n    DefaultStreamGroup,\n    Message,\n    Realm,\n    RealmAuditLog,\n    Recipient,\n    Stream,\n    Subscription,\n    UserGroup,\n    UserMessage,\n    UserProfile,\n    active_non_guest_user_ids,\n    flush_per_request_caches,\n    get_default_stream_groups,\n    get_realm,\n    get_stream,\n    get_user,\n    get_user_profile_by_id_in_realm,\n    validate_attachment_request,\n    validate_attachment_request_for_spectator_access,\n)\nfrom zerver.views.streams import compose_views\n\nif TYPE_CHECKING:\n    from django.test.client import _MonkeyPatchedWSGIResponse as TestHttpResponse\n\n\nclass TestMiscStuff(ZulipTestCase):\n    def test_test_helper(self) -> None:\n        cordelia = self.example_user(\"cordelia\")\n        s = self.subscribed_stream_name_list(cordelia)\n        self.assertIn(\"* Verona\", s)\n        self.assertNotIn(\"* Denmark\", s)\n\n    def test_pick_colors(self) -> None:\n        used_colors: Set[str] = set()\n        color_map: Dict[int, str] = {}\n        recipient_ids = list(range(30))\n        user_color_map = pick_colors(used_colors, color_map, recipient_ids)\n        self.assertEqual(\n            user_color_map,\n            {\n                0: \"#76ce90\",\n                1: \"#fae589\",\n                2: \"#a6c7e5\",\n                3: \"#e79ab5\",\n                4: \"#bfd56f\",\n                5: \"#f4ae55\",\n                6: \"#b0a5fd\",\n                7: \"#addfe5\",\n                8: \"#f5ce6e\",\n                9: \"#c2726a\",\n                10: \"#94c849\",\n                11: \"#bd86e5\",\n                12: \"#ee7e4a\",\n                13: \"#a6dcbf\",\n                14: \"#95a5fd\",\n                15: \"#53a063\",\n                16: \"#9987e1\",\n                17: \"#e4523d\",\n                18: \"#c2c2c2\",\n                19: \"#4f8de4\",\n                20: \"#c6a8ad\",\n                21: \"#e7cc4d\",\n                22: \"#c8bebf\",\n                23: \"#a47462\",\n                # start repeating\n                24: \"#76ce90\",\n                25: \"#fae589\",\n                26: \"#a6c7e5\",\n                27: \"#e79ab5\",\n                28: \"#bfd56f\",\n                29: \"#f4ae55\",\n            },\n        )\n\n        color_map = {98: \"color98\", 99: \"color99\"}\n        used_colors = set(STREAM_ASSIGNMENT_COLORS) - {\"#c6a8ad\", \"#9987e1\"}\n        recipient_ids = [99, 98, 1, 2, 3, 4]\n        user_color_map = pick_colors(used_colors, color_map, recipient_ids)\n        self.assertEqual(\n            user_color_map,\n            {98: \"color98\", 99: \"color99\", 1: \"#9987e1\", 2: \"#c6a8ad\", 3: \"#e79ab5\", 4: \"#bfd56f\"},\n        )\n\n        \"\"\"\n        If we are assigning colors to a user with 24+ streams, we have to start\n        re-using old colors.  Our algorithm basically uses recipient_id % 24, so\n        the following code reflects the worse case scenario that our new\n        streams have recipient ids spaced out by exact multiples of 24.  We\n        don't try to work around this edge case, since users who really depend\n        on the stream colors can always just assign themselves custom colors\n        for the streams that they really want to stand out.\n\n        Even if recipient_ids were completely random, the odds of collisions\n        are low, but it's often the case that bulk-adds are done for streams\n        that either were or are being created at roughly the same time, so the\n        recipient_ids tend to have even fewer collisions.\n        \"\"\"\n        used_colors = set(STREAM_ASSIGNMENT_COLORS)\n        color_map = {}\n        recipient_ids = [2, 26, 50, 74]\n        user_color_map = pick_colors(used_colors, color_map, recipient_ids)\n        self.assertEqual(\n            user_color_map,\n            {2: \"#a6c7e5\", 26: \"#a6c7e5\", 50: \"#a6c7e5\", 74: \"#a6c7e5\"},\n        )\n\n    def test_empty_results(self) -> None:\n        # These are essentially just tests to ensure line\n        # coverage for codepaths that won't ever really be\n        # called in practice.\n\n        user_profile = self.example_user(\"cordelia\")\n\n        result = bulk_get_subscriber_user_ids(\n            stream_dicts=[],\n            user_profile=user_profile,\n            subscribed_stream_ids=set(),\n        )\n        self.assertEqual(result, {})\n\n        streams = do_get_streams(\n            user_profile=user_profile,\n            include_public=False,\n            include_subscribed=False,\n            include_all_active=False,\n            include_default=False,\n        )\n        self.assertEqual(streams, [])\n\n    def test_api_fields(self) -> None:\n        \"\"\"Verify that all the fields from `Stream.API_FIELDS` and `Subscription.API_FIELDS` present\n        in `APIStreamDict` and `APISubscriptionDict`, respectively.\n        \"\"\"\n        expected_fields = set(Stream.API_FIELDS) | {\"stream_id\"}\n        expected_fields -= {\"id\"}\n\n        stream_dict_fields = set(APIStreamDict.__annotations__.keys())\n        computed_fields = {\"is_announcement_only\", \"is_default\"}\n\n        self.assertEqual(stream_dict_fields - computed_fields, expected_fields)\n\n        expected_fields = set(Subscription.API_FIELDS)\n\n        subscription_dict_fields = set(APISubscriptionDict.__annotations__.keys())\n        computed_fields = {\"in_home_view\", \"email_address\", \"stream_weekly_traffic\", \"subscribers\"}\n        # `APISubscriptionDict` is a subclass of `APIStreamDict`, therefore having all the\n        # fields in addition to the computed fields and `Subscription.API_FIELDS` that\n        # need to be excluded here.\n        self.assertEqual(\n            subscription_dict_fields - computed_fields - stream_dict_fields,\n            expected_fields,\n        )\n\n\nclass TestCreateStreams(ZulipTestCase):\n    def test_creating_streams(self) -> None:\n        stream_names = [\"new1\", \"new2\", \"new3\"]\n        stream_descriptions = [\"des1\", \"des2\", \"des3\"]\n        realm = get_realm(\"zulip\")\n\n        # Test stream creation events.\n        with self.capture_send_event_calls(expected_num_events=1) as events:\n            ensure_stream(realm, \"Public stream\", invite_only=False, acting_user=None)\n\n        self.assertEqual(events[0][\"event\"][\"type\"], \"stream\")\n        self.assertEqual(events[0][\"event\"][\"op\"], \"create\")\n        # Send public stream creation event to all active users.\n        self.assertEqual(events[0][\"users\"], active_non_guest_user_ids(realm.id))\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"name\"], \"Public stream\")\n\n        with self.capture_send_event_calls(expected_num_events=1) as events:\n            ensure_stream(realm, \"Private stream\", invite_only=True, acting_user=None)\n\n        self.assertEqual(events[0][\"event\"][\"type\"], \"stream\")\n        self.assertEqual(events[0][\"event\"][\"op\"], \"create\")\n        # Send private stream creation event to only realm admins.\n        self.assert_length(events[0][\"users\"], 2)\n        self.assertTrue(self.example_user(\"iago\").id in events[0][\"users\"])\n        self.assertTrue(self.example_user(\"desdemona\").id in events[0][\"users\"])\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"name\"], \"Private stream\")\n\n        moderators_system_group = UserGroup.objects.get(\n            name=\"@role:moderators\", realm=realm, is_system_group=True\n        )\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [\n                {\n                    \"name\": stream_name,\n                    \"description\": stream_description,\n                    \"invite_only\": True,\n                    \"stream_post_policy\": Stream.STREAM_POST_POLICY_ADMINS,\n                    \"message_retention_days\": -1,\n                    \"can_remove_subscribers_group\": moderators_system_group,\n                }\n                for (stream_name, stream_description) in zip(stream_names, stream_descriptions)\n            ],\n        )\n\n        self.assert_length(new_streams, 3)\n        self.assert_length(existing_streams, 0)\n\n        actual_stream_names = {stream.name for stream in new_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in new_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in new_streams:\n            self.assertTrue(stream.invite_only)\n            self.assertTrue(stream.stream_post_policy == Stream.STREAM_POST_POLICY_ADMINS)\n            self.assertTrue(stream.message_retention_days == -1)\n            self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [\n                {\"name\": stream_name, \"description\": stream_description, \"invite_only\": True}\n                for (stream_name, stream_description) in zip(stream_names, stream_descriptions)\n            ],\n        )\n\n        self.assert_length(new_streams, 0)\n        self.assert_length(existing_streams, 3)\n\n        actual_stream_names = {stream.name for stream in existing_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in existing_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in existing_streams:\n            self.assertTrue(stream.invite_only)\n\n    def test_create_api_multiline_description(self) -> None:\n        user = self.example_user(\"hamlet\")\n        realm = user.realm\n        self.login_user(user)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream\", \"description\": \"multi\\nline\\ndescription\"}]\n            ).decode(),\n            \"invite_only\": orjson.dumps(False).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_success(result)\n        stream = get_stream(\"new_stream\", realm)\n        self.assertEqual(stream.description, \"multi line description\")\n\n    def test_history_public_to_subscribers_on_stream_creation(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream_dicts: List[StreamDict] = [\n            {\n                \"name\": \"publicstream\",\n                \"description\": \"Public stream with public history\",\n            },\n            {\"name\": \"webpublicstream\", \"description\": \"Web-public stream\", \"is_web_public\": True},\n            {\n                \"name\": \"privatestream\",\n                \"description\": \"Private stream with non-public history\",\n                \"invite_only\": True,\n            },\n            {\n                \"name\": \"privatewithhistory\",\n                \"description\": \"Private stream with public history\",\n                \"invite_only\": True,\n                \"history_public_to_subscribers\": True,\n            },\n            {\n                \"name\": \"publictrywithouthistory\",\n                \"description\": \"Public stream without public history (disallowed)\",\n                \"invite_only\": False,\n                \"history_public_to_subscribers\": False,\n            },\n        ]\n\n        created, existing = create_streams_if_needed(realm, stream_dicts)\n\n        self.assert_length(created, 5)\n        self.assert_length(existing, 0)\n        for stream in created:\n            if stream.name == \"publicstream\":\n                self.assertTrue(stream.history_public_to_subscribers)\n            if stream.name == \"webpublicstream\":\n                self.assertTrue(stream.history_public_to_subscribers)\n            if stream.name == \"privatestream\":\n                self.assertFalse(stream.history_public_to_subscribers)\n            if stream.name == \"privatewithhistory\":\n                self.assertTrue(stream.history_public_to_subscribers)\n            if stream.name == \"publictrywithouthistory\":\n                self.assertTrue(stream.history_public_to_subscribers)\n\n    def test_history_public_to_subscribers_zephyr_realm(self) -> None:\n        realm = get_realm(\"zephyr\")\n\n        stream, created = create_stream_if_needed(realm, \"private_stream\", invite_only=True)\n        self.assertTrue(created)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        stream, created = create_stream_if_needed(realm, \"public_stream\", invite_only=False)\n        self.assertTrue(created)\n        self.assertFalse(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n    def test_auto_mark_stream_created_message_as_read_for_stream_creator(self) -> None:\n        # This test relies on email == delivery_email for\n        # convenience.\n        reset_email_visibility_to_everyone_in_zulip_realm()\n\n        realm = Realm.objects.get(name=\"Zulip Dev\")\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        aaron = self.example_user(\"aaron\")\n\n        # Establish a stream for notifications.\n        announce_stream = ensure_stream(\n            realm, \"announce\", False, \"announcements here.\", acting_user=None\n        )\n        realm.notifications_stream_id = announce_stream.id\n        realm.save(update_fields=[\"notifications_stream_id\"])\n\n        self.subscribe(iago, announce_stream.name)\n        self.subscribe(hamlet, announce_stream.name)\n\n        self.login_user(iago)\n\n        initial_message_count = Message.objects.count()\n        initial_usermessage_count = UserMessage.objects.count()\n\n        data = {\n            \"subscriptions\": '[{\"name\":\"brand new stream\",\"description\":\"\"}]',\n            \"history_public_to_subscribers\": \"true\",\n            \"invite_only\": \"false\",\n            \"announce\": \"true\",\n            \"principals\": orjson.dumps([iago.id, aaron.id, cordelia.id, hamlet.id]).decode(),\n            \"stream_post_policy\": \"1\",\n        }\n\n        response = self.client_post(\"/json/users/me/subscriptions\", data)\n\n        final_message_count = Message.objects.count()\n        final_usermessage_count = UserMessage.objects.count()\n\n        expected_response = {\n            \"result\": \"success\",\n            \"msg\": \"\",\n            \"subscribed\": {\n                \"AARON@zulip.com\": [\"brand new stream\"],\n                \"cordelia@zulip.com\": [\"brand new stream\"],\n                \"hamlet@zulip.com\": [\"brand new stream\"],\n                \"iago@zulip.com\": [\"brand new stream\"],\n            },\n            \"already_subscribed\": {},\n        }\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(orjson.loads(response.content), expected_response)\n\n        # 2 messages should be created, one in announce and one in the new stream itself.\n        self.assertEqual(final_message_count - initial_message_count, 2)\n        # 4 UserMessages per subscriber: One for each of the subscribers, plus 1 for\n        # each user in the notifications stream.\n        announce_stream_subs = Subscription.objects.filter(recipient=announce_stream.recipient)\n        self.assertEqual(\n            final_usermessage_count - initial_usermessage_count, 4 + announce_stream_subs.count()\n        )\n\n        def get_unread_stream_data(user: UserProfile) -> List[UnreadStreamInfo]:\n            raw_unread_data = get_raw_unread_data(user)\n            aggregated_data = aggregate_unread_data(raw_unread_data)\n            return aggregated_data[\"streams\"]\n\n        stream_id = Stream.objects.get(name=\"brand new stream\").id\n        iago_unread_messages = get_unread_stream_data(iago)\n        hamlet_unread_messages = get_unread_stream_data(hamlet)\n\n        # The stream creation messages should be unread for Hamlet\n        self.assert_length(hamlet_unread_messages, 2)\n\n        # According to the code in zerver/views/streams/add_subscriptions_backend\n        # the notification stream message is sent first, then the new stream's message.\n        self.assertEqual(hamlet_unread_messages[1][\"stream_id\"], stream_id)\n\n        # But it should be marked as read for Iago, the stream creator.\n        self.assert_length(iago_unread_messages, 0)\n\n    def test_can_remove_subscribers_group_on_stream_creation(self) -> None:\n        user = self.example_user(\"hamlet\")\n        realm = user.realm\n        self.login_user(user)\n        moderators_system_group = UserGroup.objects.get(\n            name=\"@role:moderators\", realm=realm, is_system_group=True\n        )\n        admins_system_group = UserGroup.objects.get(\n            name=\"@role:administrators\", realm=realm, is_system_group=True\n        )\n\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream1\", \"description\": \"First new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_success(result)\n        stream = get_stream(\"new_stream1\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream2\", \"description\": \"Second new stream\"}]\n            ).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_success(result)\n        stream = get_stream(\"new_stream2\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, admins_system_group.id)\n\n        hamletcharacters_group = UserGroup.objects.get(name=\"hamletcharacters\", realm=realm)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(hamletcharacters_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result, \"'can_remove_subscribers_group' must be a system user group.\"\n        )\n\n        internet_group = UserGroup.objects.get(\n            name=\"@role:internet\", is_system_group=True, realm=realm\n        )\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(internet_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:internet' group.\",\n        )\n\n        owners_group = UserGroup.objects.get(name=\"@role:owners\", is_system_group=True, realm=realm)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(owners_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:owners' group.\",\n        )\n\n        nobody_group = UserGroup.objects.get(name=\"@role:nobody\", is_system_group=True, realm=realm)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(nobody_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:nobody' group.\",\n        )\n\n\nclass RecipientTest(ZulipTestCase):\n    def test_recipient(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream = get_stream(\"Verona\", realm)\n        recipient = Recipient.objects.get(\n            type_id=stream.id,\n            type=Recipient.STREAM,\n        )\n        self.assertEqual(repr(recipient), f\"<Recipient: Verona ({stream.id}, {Recipient.STREAM})>\")\n\n\nclass StreamAdminTest(ZulipTestCase):\n    def test_make_stream_public(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"private_stream_1\", invite_only=True)\n        self.make_stream(\"private_stream_2\", invite_only=True)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        stream_id = get_stream(\"private_stream_1\", user_profile.realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        stream = self.subscribe(user_profile, \"private_stream_1\")\n        self.assertFalse(stream.is_in_zephyr_realm)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        realm = user_profile.realm\n        stream = get_stream(\"private_stream_1\", realm)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Public**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        history_public_to_subscribers_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert history_public_to_subscribers_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(history_public_to_subscribers_log.extra_data, expected_extra_data)\n\n        invite_only_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).order_by(\"-id\")[1]\n        assert invite_only_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(invite_only_log.extra_data, expected_extra_data)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        stream = self.subscribe(user_profile, \"private_stream_2\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assertTrue(stream.invite_only)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_make_stream_private(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"public_stream_1\", realm=realm)\n        self.make_stream(\"public_stream_2\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"public_stream_1\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n        stream = get_stream(\"public_stream_1\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Public** to **Private, protected history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        history_public_to_subscribers_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert history_public_to_subscribers_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(history_public_to_subscribers_log.extra_data, expected_extra_data)\n\n        invite_only_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).order_by(\"-id\")[1]\n        assert invite_only_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(invite_only_log.extra_data, expected_extra_data)\n\n        default_stream = self.make_stream(\"default_stream\", realm=realm)\n        do_add_default_stream(default_stream)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{default_stream.id}\", params)\n        self.assert_json_error(result, \"Default streams cannot be made private.\")\n        self.assertFalse(default_stream.invite_only)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n        }\n        stream = self.subscribe(user_profile, \"public_stream_2\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assertFalse(stream.invite_only)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_create_web_public_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        owner = self.example_user(\"desdemona\")\n\n        stream_names = [\"new1\", \"new2\", \"new3\"]\n        stream_descriptions = [\"des1\", \"des2\", \"des3\"]\n        streams_raw: List[StreamDict] = [\n            {\"name\": stream_name, \"description\": stream_description, \"is_web_public\": True}\n            for (stream_name, stream_description) in zip(stream_names, stream_descriptions)\n        ]\n\n        self.assertFalse(user_profile.can_create_web_public_streams())\n        self.assertTrue(owner.can_create_web_public_streams())\n        # As per create_web_public_stream_policy, only owners can create web-public streams by default.\n        with self.assertRaisesRegex(JsonableError, \"Insufficient permission\"):\n            list_to_streams(\n                streams_raw,\n                user_profile,\n                autocreate=True,\n            )\n\n        with self.settings(WEB_PUBLIC_STREAMS_ENABLED=False):\n            self.assertFalse(user_profile.can_create_web_public_streams())\n            self.assertFalse(owner.can_create_web_public_streams())\n            with self.assertRaisesRegex(JsonableError, \"Web-public streams are not enabled.\"):\n                list_to_streams(\n                    streams_raw,\n                    owner,\n                    autocreate=True,\n                )\n\n        existing_streams, new_streams = list_to_streams(\n            streams_raw,\n            owner,\n            autocreate=True,\n        )\n\n        self.assert_length(new_streams, 3)\n        self.assert_length(existing_streams, 0)\n\n        actual_stream_names = {stream.name for stream in new_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in new_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in new_streams:\n            self.assertTrue(stream.is_web_public)\n\n    def test_make_stream_public_zephyr_mirror(self) -> None:\n        user_profile = self.mit_user(\"starnine\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"target_stream\", realm=realm, invite_only=True)\n        self.subscribe(user_profile, \"target_stream\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        stream_id = get_stream(\"target_stream\", realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params, subdomain=\"zephyr\")\n        self.assert_json_success(result)\n        stream = get_stream(\"target_stream\", realm)\n        self.assertFalse(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Public, protected history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_make_stream_private_with_public_history(self) -> None:\n        # Convert a public stream to a private stream with shared history\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"public_history_stream\", realm=realm)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"public_history_stream\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n        stream = get_stream(\"public_history_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Public** to **Private, shared history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Convert a private stream with protected history to a private stream\n        # with shared history.\n        self.make_stream(\n            \"private_protected_stream\",\n            realm=realm,\n            invite_only=True,\n            history_public_to_subscribers=False,\n        )\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"private_protected_stream\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n        stream = get_stream(\"private_protected_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Private, shared history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_make_stream_web_public(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"test_stream\", realm=realm)\n        stream_id = self.subscribe(user_profile, \"test_stream\").id\n\n        params = {\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        do_set_realm_property(\n            realm, \"create_web_public_stream_policy\", Realm.POLICY_OWNERS_ONLY, acting_user=None\n        )\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(\n            realm, \"create_web_public_stream_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(\n            realm, \"create_web_public_stream_policy\", Realm.POLICY_OWNERS_ONLY, acting_user=None\n        )\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        with self.settings(WEB_PUBLIC_STREAMS_ENABLED=False):\n            result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Web-public streams are not enabled.\")\n\n        bad_params = {\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", bad_params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        bad_params = {\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"is_private\": orjson.dumps(False).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", bad_params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        stream = get_stream(\"test_stream\", realm)\n        self.assertFalse(stream.is_web_public)\n\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        stream = get_stream(\"test_stream\", realm)\n        self.assertTrue(stream.is_web_public)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Public** to **Web-public**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"is_web_public\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_history_access_for_private_streams(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"private_stream\", realm=realm, invite_only=True)\n        stream_id = self.subscribe(user_profile, \"private_stream\").id\n\n        params = {\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        stream = get_stream(\"private_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**Iago|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Private, shared history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        params = {\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        stream = get_stream(\"private_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 2)\n        expected_notification = (\n            f\"@_**Iago|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, shared history** to **Private, protected history**.\"\n        )\n        self.assertEqual(messages[1].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_stream_permission_changes_updates_updates_attachments(self) -> None:\n        self.login(\"desdemona\")\n        fp = StringIO(\"zulip!\")\n        fp.name = \"zulip.txt\"\n\n        result = self.client_post(\"/json/user_uploads\", {\"file\": fp})\n        url = self.assert_json_success(result)[\"uri\"]\n\n        owner = self.example_user(\"desdemona\")\n        realm = owner.realm\n        stream = self.make_stream(\"test_stream\", realm=realm)\n        self.subscribe(owner, \"test_stream\")\n        body = f\"First message ...[zulip.txt](http://{realm.host}\" + url + \")\"\n        msg_id = self.send_stream_message(owner, \"test_stream\", body, \"test\")\n        attachment = Attachment.objects.get(messages__id=msg_id)\n\n        self.assertFalse(stream.is_web_public)\n        self.assertFalse(attachment.is_web_public)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(attachment.is_realm_public)\n\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assert_json_success(result)\n\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertFalse(stream.is_web_public)\n        self.assertFalse(attachment.is_web_public)\n        self.assertTrue(stream.invite_only)\n        self.assertIsNone(attachment.is_realm_public)\n\n        cordelia = self.example_user(\"cordelia\")\n        self.assertFalse(validate_attachment_request(cordelia, attachment.path_id))\n        self.assertTrue(validate_attachment_request(owner, attachment.path_id))\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_realm_public)\n        self.assertFalse(validate_attachment_request_for_spectator_access(realm, attachment))\n\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assert_json_success(result)\n\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(stream.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n        self.assertIsNone(attachment.is_web_public)\n\n        self.assertTrue(validate_attachment_request_for_spectator_access(realm, attachment))\n        attachment.refresh_from_db()\n        self.assertTrue(attachment.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n\n        self.assertTrue(validate_attachment_request(cordelia, attachment.path_id))\n        attachment.refresh_from_db()\n        self.assertTrue(attachment.is_realm_public)\n\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n            \"is_web_public\": orjson.dumps(False).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assert_json_success(result)\n\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertIsNone(attachment.is_web_public)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(attachment.is_realm_public)\n\n        self.assertFalse(validate_attachment_request_for_spectator_access(realm, attachment))\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertFalse(attachment.is_web_public)\n\n        # Verify moving a message to another public stream doesn't reset cache.\n        new_stream = self.make_stream(\"new_stream\", realm=realm)\n        self.subscribe(owner, \"new_stream\")\n        result = self.client_patch(\n            \"/json/messages/\" + str(msg_id),\n            {\n                \"stream_id\": new_stream.id,\n                \"propagate_mode\": \"change_all\",\n            },\n        )\n        self.assert_json_success(result)\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_web_public)\n        self.assertTrue(attachment.is_realm_public)\n\n        # Verify moving a message to a private stream\n        private_stream = self.make_stream(\"private_stream\", realm=realm, invite_only=True)\n        self.subscribe(owner, \"private_stream\")\n        result = self.client_patch(\n            \"/json/messages/\" + str(msg_id),\n            {\n                \"stream_id\": private_stream.id,\n                \"propagate_mode\": \"change_all\",\n            },\n        )\n        self.assert_json_success(result)\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n\n        self.assertFalse(validate_attachment_request(cordelia, attachment.path_id))\n        self.assertTrue(validate_attachment_request(owner, attachment.path_id))\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_realm_public)\n\n        # Verify moving a message to a web-public stream\n        web_public_stream = self.make_stream(\"web_public_stream\", realm=realm, is_web_public=True)\n        result = self.client_patch(\n            \"/json/messages/\" + str(msg_id),\n            {\n                \"stream_id\": web_public_stream.id,\n                \"propagate_mode\": \"change_all\",\n            },\n        )\n        self.assert_json_success(result)\n        attachment.refresh_from_db()\n        self.assertIsNone(attachment.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n\n        self.assertTrue(validate_attachment_request_for_spectator_access(realm, attachment))\n        attachment.refresh_from_db()\n        self.assertTrue(attachment.is_web_public)\n\n    def test_try_make_stream_public_with_private_history(self) -> None:\n        # We only support public streams with private history if\n        # is_zephyr_mirror_realm, and don't allow changing stream\n        # permissions in such realms.  So changing the\n        # history_public_to_subscribers property of a public stream is\n        # not possible in Zulip today\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"public_stream\", realm=realm)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"public_stream\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        params = {\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        web_public_stream = self.make_stream(\"web_public_stream\", realm=realm, is_web_public=True)\n        result = self.client_patch(f\"/json/streams/{web_public_stream.id}\", params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n    def test_subscriber_ids_with_stream_history_access(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        polonius = self.example_user(\"polonius\")\n\n        stream1 = self.make_stream(\n            \"history_private_stream\", invite_only=True, history_public_to_subscribers=False\n        )\n        self.subscribe(hamlet, stream1.name)\n        self.subscribe(polonius, stream1.name)\n        self.assertEqual(set(), subscriber_ids_with_stream_history_access(stream1))\n\n        stream2 = self.make_stream(\n            \"history_public_web_private_stream\",\n            invite_only=True,\n            is_web_public=False,\n            history_public_to_subscribers=True,\n        )\n        self.subscribe(hamlet, stream2.name)\n        self.subscribe(polonius, stream2.name)\n        self.assertEqual(\n            {hamlet.id, polonius.id}, subscriber_ids_with_stream_history_access(stream2)\n        )\n\n        stream3 = self.make_stream(\n            \"history_public_web_public_stream\",\n            is_web_public=True,\n            history_public_to_subscribers=True,\n        )\n        self.subscribe(hamlet, stream3.name)\n        self.subscribe(polonius, stream3.name)\n        self.assertEqual(\n            {hamlet.id, polonius.id}, subscriber_ids_with_stream_history_access(stream3)\n        )\n\n        stream4 = self.make_stream(\n            \"regular_public_stream\",\n        )\n        self.subscribe(hamlet, stream4.name)\n        self.subscribe(polonius, stream4.name)\n        self.assertEqual(\n            {hamlet.id, polonius.id}, subscriber_ids_with_stream_history_access(stream4)\n        )\n\n    def test_deactivate_stream_backend(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.make_stream(\"new_stream_1\")\n        self.subscribe(user_profile, stream.name)\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        result = self.client_delete(f\"/json/streams/{stream.id}\")\n        self.assert_json_success(result)\n        subscription_exists = (\n            get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=True)\n            .filter(\n                user_profile=user_profile,\n            )\n            .exists()\n        )\n        self.assertFalse(subscription_exists)\n\n    def test_deactivate_stream_removes_default_stream(self) -> None:\n        stream = self.make_stream(\"new_stream\")\n        do_add_default_stream(stream)\n        self.assertEqual(1, DefaultStream.objects.filter(stream_id=stream.id).count())\n        do_deactivate_stream(stream, acting_user=None)\n        self.assertEqual(0, DefaultStream.objects.filter(stream_id=stream.id).count())\n\n    def test_deactivate_stream_removes_stream_from_default_stream_groups(self) -> None:\n        realm = get_realm(\"zulip\")\n        streams_to_keep = []\n        for stream_name in [\"stream1\", \"stream2\"]:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams_to_keep.append(stream)\n\n        streams_to_remove = []\n        stream = ensure_stream(realm, \"stream3\", acting_user=None)\n        streams_to_remove.append(stream)\n\n        all_streams = streams_to_keep + streams_to_remove\n\n        def get_streams(group: DefaultStreamGroup) -> List[Stream]:\n            return list(group.streams.all().order_by(\"name\"))\n\n        group_name = \"group1\"\n        description = \"This is group1\"\n        do_create_default_stream_group(realm, group_name, description, all_streams)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assertEqual(get_streams(default_stream_groups[0]), all_streams)\n\n        do_deactivate_stream(streams_to_remove[0], acting_user=None)\n        self.assertEqual(get_streams(default_stream_groups[0]), streams_to_keep)\n\n    def test_deactivate_stream_marks_messages_as_read(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        stream = self.make_stream(\"new_stream\")\n        self.subscribe(hamlet, stream.name)\n        self.subscribe(cordelia, stream.name)\n        self.subscribe(hamlet, \"Denmark\")\n        self.subscribe(cordelia, \"Denmark\")\n\n        self.send_stream_message(hamlet, stream.name)\n        new_stream_usermessage = most_recent_usermessage(cordelia)\n\n        # We send a message to a different stream too, to verify that the\n        # deactivation of new_stream won't corrupt read state of UserMessage elsewhere.\n        self.send_stream_message(hamlet, \"Denmark\")\n        denmark_usermessage = most_recent_usermessage(cordelia)\n\n        self.assertFalse(new_stream_usermessage.flags.read)\n        self.assertFalse(denmark_usermessage.flags.read)\n\n        with self.captureOnCommitCallbacks(execute=True):\n            do_deactivate_stream(stream, acting_user=None)\n        new_stream_usermessage.refresh_from_db()\n        denmark_usermessage.refresh_from_db()\n        self.assertTrue(new_stream_usermessage.flags.read)\n        self.assertFalse(denmark_usermessage.flags.read)\n\n    def test_deactivated_streams_by_old_name(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream = self.make_stream(\"new_stream\")\n        do_deactivate_stream(stream, acting_user=None)\n        self.assertEqual(set(deactivated_streams_by_old_name(realm, \"new_stream\")), {stream})\n\n        second_stream = self.make_stream(\"new_stream\")\n        do_deactivate_stream(second_stream, acting_user=None)\n        self.assertEqual(\n            set(deactivated_streams_by_old_name(realm, \"new_stream\")), {stream, second_stream}\n        )\n\n        self.make_stream(\"!DEACTIVATED:old_style\")  # This is left active\n        old_style = self.make_stream(\"old_style\")\n        do_deactivate_stream(old_style, acting_user=None)\n        old_style.name = \"!!DEACTIVATED:old_style\"\n        old_style.save()\n        self.assertEqual(set(deactivated_streams_by_old_name(realm, \"old_style\")), {old_style})\n\n    def test_unarchive_stream_active_stream(self) -> None:\n        stream = self.make_stream(\"new_stream\")\n        with self.assertRaisesRegex(JsonableError, \"Stream is not currently deactivated\"):\n            do_unarchive_stream(stream, new_name=\"new_stream\", acting_user=None)\n\n    def test_unarchive_stream_existing_name(self) -> None:\n        stream = self.make_stream(\"new_stream\")\n        self.make_stream(\"existing\")\n        do_deactivate_stream(stream, acting_user=None)\n        with self.assertRaisesRegex(JsonableError, \"Stream named existing already exists\"):\n            do_unarchive_stream(stream, new_name=\"existing\", acting_user=None)\n\n    def test_unarchive_stream(self) -> None:\n        desdemona = self.example_user(\"desdemona\")\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n\n        stream = self.make_stream(\"new_stream\", is_web_public=True)\n        self.subscribe(hamlet, stream.name)\n        self.subscribe(cordelia, stream.name)\n        do_deactivate_stream(stream, acting_user=None)\n        with self.capture_send_event_calls(expected_num_events=4) as events:\n            do_unarchive_stream(stream, new_name=\"new_stream\", acting_user=None)\n\n        # Tell all admins and owners that the stream exists\n        self.assertEqual(events[0][\"event\"][\"op\"], \"create\")\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"name\"], \"new_stream\")\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"stream_id\"], stream.id)\n        self.assertEqual(set(events[0][\"users\"]), {iago.id, desdemona.id})\n\n        # Tell the owners that they're subscribed to it\n        self.assertEqual(events[1][\"event\"][\"op\"], \"add\")\n        self.assertEqual(events[1][\"event\"][\"subscriptions\"][0][\"name\"], \"new_stream\")\n        self.assertEqual(events[1][\"event\"][\"subscriptions\"][0][\"stream_id\"], stream.id)\n        self.assertEqual(events[1][\"users\"], [desdemona.id])\n\n        # Send a message there logging the reactivation\n        self.assertEqual(events[2][\"event\"][\"type\"], \"message\")\n\n        # iago (as an admin) gets to know that desdemona (the owner) is now subscribed.\n        self.assertEqual(\n            events[3],\n            {\n                \"event\": {\n                    \"op\": \"peer_add\",\n                    \"stream_ids\": [stream.id],\n                    \"type\": \"subscription\",\n                    \"user_ids\": [desdemona.id],\n                },\n                \"users\": [iago.id],\n            },\n        )\n\n        stream = Stream.objects.get(id=stream.id)\n        self.assertFalse(stream.deactivated)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.is_web_public)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        self.assertEqual(\n            [desdemona.id],\n            [\n                sub.user_profile_id\n                for sub in get_active_subscriptions_for_stream_id(\n                    stream.id, include_deactivated_users=True\n                )\n            ],\n        )\n\n    def test_vacate_private_stream_removes_default_stream(self) -> None:\n        stream = self.make_stream(\"new_stream\", invite_only=True)\n        self.subscribe(self.example_user(\"hamlet\"), stream.name)\n        do_add_default_stream(stream)\n        self.assertEqual(1, DefaultStream.objects.filter(stream_id=stream.id).count())\n        self.unsubscribe(self.example_user(\"hamlet\"), stream.name)\n        self.assertEqual(0, DefaultStream.objects.filter(stream_id=stream.id).count())\n        # Fetch stream again from database.\n        stream = Stream.objects.get(id=stream.id)\n        self.assertTrue(stream.deactivated)\n\n    def test_deactivate_stream_backend_requires_existing_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"new_stream\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        result = self.client_delete(\"/json/streams/999999999\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_deactivate_stream_backend_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.subscribe(user_profile, \"new_stream\")\n\n        result = self.client_delete(f\"/json/streams/{stream.id}\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_private_stream_live_updates(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        self.make_stream(\"private_stream\", invite_only=True)\n        self.subscribe(user_profile, \"private_stream\")\n        self.subscribe(self.example_user(\"cordelia\"), \"private_stream\")\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"private_stream\", user_profile.realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"description\": \"Test description\"},\n            )\n        self.assert_json_success(result)\n\n        cordelia = self.example_user(\"cordelia\")\n        prospero = self.example_user(\"prospero\")\n\n        notified_user_ids = set(events[0][\"users\"])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n        # Two events should be sent: a name event and a notification event\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"private_stream\", user_profile.realm).id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"whatever\"})\n        self.assert_json_success(result)\n\n        notified_user_ids = set(events[0][\"users\"])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n        notified_with_bot_users = events[-1][\"users\"]\n        notified_with_bot_user_ids = []\n        notified_with_bot_user_ids.append(notified_with_bot_users[0][\"id\"])\n        notified_with_bot_user_ids.append(notified_with_bot_users[1][\"id\"])\n        self.assertIn(user_profile.id, notified_with_bot_user_ids)\n        self.assertIn(cordelia.id, notified_with_bot_user_ids)\n        self.assertNotIn(prospero.id, notified_with_bot_user_ids)\n\n    def test_rename_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        stream = self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"stream_name1\"})\n        self.assert_json_error(result, \"Stream already has that name!\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"Denmark\"})\n        self.assert_json_error(result, \"Stream name 'Denmark' is already taken.\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"denmark \"})\n        self.assert_json_error(result, \"Stream name 'denmark' is already taken.\")\n\n        # Do a rename that is case-only--this should succeed.\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"sTREAm_name1\"})\n        self.assert_json_success(result)\n\n        # Two events should be sent: stream_name update and notification message.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"stream_name2\"})\n        self.assert_json_success(result)\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"name\",\n                value=\"stream_name2\",\n                stream_id=stream_id,\n                name=\"sTREAm_name1\",\n            ),\n        )\n        notified_user_ids = set(events[0][\"users\"])\n\n        self.assertRaises(Stream.DoesNotExist, get_stream, \"stream_name1\", realm)\n\n        stream_name2_exists = get_stream(\"stream_name2\", realm)\n        self.assertTrue(stream_name2_exists)\n\n        self.assertEqual(notified_user_ids, set(active_non_guest_user_ids(realm.id)))\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(self.example_user(\"prospero\").id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"polonius\").id, notified_user_ids)\n\n        # Test case to handle Unicode stream name change\n        # *NOTE: Here encoding is needed when Unicode string is passed as an argument*\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name2_exists.id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"\u0928\u092f\u093e \u0928\u093e\u092e\"})\n        self.assert_json_success(result)\n        # While querying, system can handle Unicode strings.\n        stream_name_uni_exists = get_stream(\"\u0928\u092f\u093e \u0928\u093e\u092e\", realm)\n        self.assertTrue(stream_name_uni_exists)\n\n        # Test case to handle changing of Unicode stream name to newer name\n        # NOTE: Unicode string being part of URL is handled cleanly\n        # by client_patch call, encoding of URL is not needed.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name_uni_exists.id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"new_name\": \"\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947\"},\n            )\n        self.assert_json_success(result)\n        # While querying, system can handle Unicode strings.\n        self.assertRaises(Stream.DoesNotExist, get_stream, \"\u0928\u092f\u093e \u0928\u093e\u092e\", realm)\n\n        stream_name_new_uni_exists = get_stream(\"\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947\", realm)\n        self.assertTrue(stream_name_new_uni_exists)\n\n        # Test case to change name from one language to other.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name_new_uni_exists.id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"fran\u00e7ais\"})\n        self.assert_json_success(result)\n        stream_name_fr_exists = get_stream(\"fran\u00e7ais\", realm)\n        self.assertTrue(stream_name_fr_exists)\n\n        # Test case to change name to mixed language name.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name_fr_exists.id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"fran\u00e7ais name\"})\n        self.assert_json_success(result)\n        stream_name_mixed_exists = get_stream(\"fran\u00e7ais name\", realm)\n        self.assertTrue(stream_name_mixed_exists)\n\n        # Test case for notified users in private streams.\n        stream_private = self.make_stream(\n            \"stream_private_name1\", realm=user_profile.realm, invite_only=True\n        )\n        self.subscribe(self.example_user(\"cordelia\"), \"stream_private_name1\")\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"stream_private_name1\", realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"new_name\": \"stream_private_name2\"},\n            )\n        self.assert_json_success(result)\n        notified_user_ids = set(events[0][\"users\"])\n        self.assertEqual(notified_user_ids, can_access_stream_user_ids(stream_private))\n        self.assertIn(self.example_user(\"cordelia\").id, notified_user_ids)\n        # An important corner case is that all organization admins are notified.\n        self.assertIn(self.example_user(\"iago\").id, notified_user_ids)\n        # The current user, Hamlet was made an admin and thus should be notified too.\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"prospero\").id, notified_user_ids)\n\n    def test_rename_stream_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"stream_name1\")\n        self.subscribe(user_profile, \"stream_name1\")\n\n        stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"stream_name2\"})\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_notify_on_stream_rename(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"stream_name1\")\n\n        stream = self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"stream_name2\"})\n        self.assert_json_success(result)\n\n        # Inspect the notification message sent\n        message = self.get_last_message()\n        actual_stream = Stream.objects.get(id=message.recipient.type_id)\n        message_content = f\"@_**King Hamlet|{user_profile.id}** renamed stream **stream_name1** to **stream_name2**.\"\n        self.assertEqual(actual_stream.name, \"stream_name2\")\n        self.assertEqual(actual_stream.realm_id, user_profile.realm_id)\n        self.assertEqual(message.recipient.type, Recipient.STREAM)\n        self.assertEqual(message.content, message_content)\n        self.assertEqual(message.sender.email, \"notification-bot@zulip.com\")\n        self.assertEqual(message.sender.realm, get_realm(settings.SYSTEM_BOT_REALM))\n\n    def test_realm_admin_can_update_unsub_private_stream(self) -> None:\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n\n        self.login_user(iago)\n        result = self.common_subscribe_to_streams(\n            iago,\n            [\"private_stream\"],\n            dict(principals=orjson.dumps([hamlet.id]).decode()),\n            invite_only=True,\n        )\n        self.assert_json_success(result)\n\n        stream_id = get_stream(\"private_stream\", iago.realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"new_private_stream\"})\n        self.assert_json_success(result)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"new description\"},\n        )\n        self.assert_json_success(result)\n\n        # But cannot change stream type.\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\n                \"is_private\": orjson.dumps(True).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_non_admin_cannot_access_unsub_private_stream(self) -> None:\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n\n        self.login_user(hamlet)\n        result = self.common_subscribe_to_streams(\n            hamlet,\n            [\"private_stream_1\"],\n            dict(principals=orjson.dumps([iago.id]).decode()),\n            invite_only=True,\n        )\n        self.assert_json_success(result)\n\n        stream_id = get_stream(\"private_stream_1\", hamlet.realm).id\n\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"private_stream_2\"})\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"new description\"},\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\n                \"is_private\": orjson.dumps(True).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        result = self.client_delete(f\"/json/streams/{stream_id}\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_change_stream_description(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.subscribe(user_profile, \"stream_name1\")\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"stream_name1\", realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"description\": \"Test description\"},\n            )\n        self.assert_json_success(result)\n\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"description\",\n                value=\"Test description\",\n                rendered_description=\"<p>Test description</p>\",\n                stream_id=stream_id,\n                name=\"stream_name1\",\n            ),\n        )\n        notified_user_ids = set(events[0][\"users\"])\n\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(notified_user_ids, set(active_non_guest_user_ids(realm.id)))\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(self.example_user(\"prospero\").id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"polonius\").id, notified_user_ids)\n        self.assertEqual(\"Test description\", stream.description)\n\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"description\": \"a\" * 1025})\n        self.assert_json_error(\n            result,\n            f\"description is too long (limit: {Stream.MAX_DESCRIPTION_LENGTH} characters)\",\n        )\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"\"},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.description, \"\")\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the description for this stream.\\n\\n\"\n            \"* **Old description:**\\n\"\n            \"```` quote\\n\"\n            \"Test description\\n\"\n            \"````\\n\"\n            \"* **New description:**\\n\"\n            \"```` quote\\n\"\n            \"*No description.*\\n\"\n            \"````\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"Test description\"},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.description, \"Test description\")\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the description for this stream.\\n\\n\"\n            \"* **Old description:**\\n\"\n            \"```` quote\\n\"\n            \"*No description.*\\n\"\n            \"````\\n\"\n            \"* **New description:**\\n\"\n            \"```` quote\\n\"\n            \"Test description\\n\"\n            \"````\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"a\\nmulti\\nline\\ndescription\"},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.description, \"a multi line description\")\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the description for this stream.\\n\\n\"\n            \"* **Old description:**\\n\"\n            \"```` quote\\n\"\n            \"Test description\\n\"\n            \"````\\n\"\n            \"* **New description:**\\n\"\n            \"```` quote\\n\"\n            \"a multi line description\\n\"\n            \"````\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: \"Test description\",\n                RealmAuditLog.NEW_VALUE: \"a multi line description\",\n                \"property\": \"description\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Verify that we don't render inline URL previews in this code path.\n        with self.settings(INLINE_URL_EMBED_PREVIEW=True):\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"description\": \"See https://zulip.com/team/\"},\n            )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(\n            stream.rendered_description,\n            '<p>See <a href=\"https://zulip.com/team/\">https://zulip.com/team/</a></p>',\n        )\n\n    def test_change_stream_description_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n\n        stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\", {\"description\": \"Test description\"}\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_change_to_stream_post_policy_admins(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\", {\"is_announcement_only\": orjson.dumps(True).decode()}\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", user_profile.realm)\n        self.assertEqual(stream.stream_post_policy, Stream.STREAM_POST_POLICY_ADMINS)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the \"\n            \"[posting permissions](/help/stream-sending-policy) for this stream:\\n\\n\"\n            \"* **Old permissions**: All stream members can post.\\n\"\n            \"* **New permissions**: Only organization administrators can post.\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: Stream.STREAM_POST_POLICY_EVERYONE,\n                RealmAuditLog.NEW_VALUE: Stream.STREAM_POST_POLICY_ADMINS,\n                \"property\": \"stream_post_policy\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_stream_post_policy_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n\n        do_set_realm_property(user_profile.realm, \"waiting_period_threshold\", 10, acting_user=None)\n\n        def test_non_admin(how_old: int, is_new: bool, policy: int) -> None:\n            user_profile.date_joined = timezone_now() - timedelta(days=how_old)\n            user_profile.save()\n            self.assertEqual(user_profile.is_provisional_member, is_new)\n            stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\", {\"stream_post_policy\": orjson.dumps(policy).decode()}\n            )\n            self.assert_json_error(result, \"Must be an organization administrator\")\n\n        policies = [\n            Stream.STREAM_POST_POLICY_ADMINS,\n            Stream.STREAM_POST_POLICY_MODERATORS,\n            Stream.STREAM_POST_POLICY_RESTRICT_NEW_MEMBERS,\n        ]\n\n        for policy in policies:\n            test_non_admin(how_old=15, is_new=False, policy=policy)\n            test_non_admin(how_old=5, is_new=True, policy=policy)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        for policy in policies:\n            stream = get_stream(\"stream_name1\", user_profile.realm)\n            old_post_policy = stream.stream_post_policy\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\", {\"stream_post_policy\": orjson.dumps(policy).decode()}\n            )\n            self.assert_json_success(result)\n            stream = get_stream(\"stream_name1\", user_profile.realm)\n            self.assertEqual(stream.stream_post_policy, policy)\n\n            messages = get_topic_messages(user_profile, stream, \"stream events\")\n            expected_notification = (\n                f\"@_**{user_profile.full_name}|{user_profile.id}** changed the \"\n                \"[posting permissions](/help/stream-sending-policy) for this stream:\\n\\n\"\n                f\"* **Old permissions**: {Stream.POST_POLICIES[old_post_policy]}.\\n\"\n                f\"* **New permissions**: {Stream.POST_POLICIES[policy]}.\"\n            )\n\n            self.assertEqual(messages[-1].content, expected_notification)\n\n            realm_audit_log = RealmAuditLog.objects.filter(\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                modified_stream=stream,\n            ).last()\n            assert realm_audit_log is not None\n            expected_extra_data = orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_post_policy,\n                    RealmAuditLog.NEW_VALUE: policy,\n                    \"property\": \"stream_post_policy\",\n                }\n            ).decode()\n            self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_stream_message_retention_days_notifications(self) -> None:\n        user_profile = self.example_user(\"desdemona\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_SELF_HOSTED, acting_user=None)\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        # Go from realm default (forever) to 2 days\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_success(result)\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**Desdemona|{user_profile.id}** has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: Forever\\n\"\n            \"* **New retention period**: 2 days\\n\\n\"\n            \"Messages in this stream will now be automatically deleted 2 days after they are sent.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {RealmAuditLog.OLD_VALUE: None, RealmAuditLog.NEW_VALUE: 2}\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Go from 2 days to 8 days\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(8).decode()}\n        )\n        self.assert_json_success(result)\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 2)\n        expected_notification = (\n            f\"@_**Desdemona|{user_profile.id}** has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: 2 days\\n\"\n            \"* **New retention period**: 8 days\\n\\n\"\n            \"Messages in this stream will now be automatically deleted 8 days after they are sent.\"\n        )\n        self.assertEqual(messages[1].content, expected_notification)\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {RealmAuditLog.OLD_VALUE: 2, RealmAuditLog.NEW_VALUE: 8}\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Go from 8 days to realm default (None on stream, forever/-1 on realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"message_retention_days\": orjson.dumps(\"realm_default\").decode()},\n        )\n        self.assert_json_success(result)\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 3)\n        expected_notification = (\n            f\"@_**Desdemona|{user_profile.id}** has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: 8 days\\n\"\n            \"* **New retention period**: Forever\\n\\n\"\n            \"Messages in this stream will now be retained forever.\"\n        )\n        self.assertEqual(messages[2].content, expected_notification)\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: 8,\n                RealmAuditLog.NEW_VALUE: None,\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_stream_message_retention_days(self) -> None:\n        user_profile = self.example_user(\"desdemona\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_LIMITED, acting_user=None)\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_error(result, \"Available on Zulip Cloud Standard. Upgrade to access.\")\n\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_SELF_HOSTED, acting_user=None)\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n            )\n        self.assert_json_success(result)\n\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"message_retention_days\",\n                value=2,\n                stream_id=stream.id,\n                name=\"stream_name1\",\n            ),\n        )\n        notified_user_ids = set(events[0][\"users\"])\n        stream = get_stream(\"stream_name1\", realm)\n\n        self.assertEqual(notified_user_ids, set(active_non_guest_user_ids(realm.id)))\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(self.example_user(\"prospero\").id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"polonius\").id, notified_user_ids)\n        self.assertEqual(stream.message_retention_days, 2)\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\",\n                {\"message_retention_days\": orjson.dumps(\"unlimited\").decode()},\n            )\n        self.assert_json_success(result)\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"message_retention_days\",\n                value=-1,\n                stream_id=stream.id,\n                name=\"stream_name1\",\n            ),\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.message_retention_days, -1)\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\",\n                {\"message_retention_days\": orjson.dumps(\"realm_default\").decode()},\n            )\n        self.assert_json_success(result)\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"message_retention_days\",\n                value=None,\n                stream_id=stream.id,\n                name=\"stream_name1\",\n            ),\n        )\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.message_retention_days, None)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"message_retention_days\": orjson.dumps(\"invalid\").decode()},\n        )\n        self.assert_json_error(result, \"Bad value for 'message_retention_days': invalid\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(-1).decode()}\n        )\n        self.assert_json_error(result, \"Bad value for 'message_retention_days': -1\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(0).decode()}\n        )\n        self.assert_json_error(result, \"Bad value for 'message_retention_days': 0\")\n\n    def test_change_stream_message_retention_days_requires_realm_owner(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.message_retention_days, 2)\n\n    def test_change_stream_can_remove_subscribers_group(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        realm = user_profile.realm\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        moderators_system_group = UserGroup.objects.get(\n            name=\"@role:moderators\", realm=realm, is_system_group=True\n        )\n        self.login(\"shiva\")\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"iago\")\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n        # This setting can only be set to system groups.\n        hamletcharacters_group = UserGroup.objects.get(name=\"hamletcharacters\", realm=realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(hamletcharacters_group.id).decode()},\n        )\n        self.assert_json_error(\n            result, \"'can_remove_subscribers_group' must be a system user group.\"\n        )\n\n        internet_group = UserGroup.objects.get(\n            name=\"@role:internet\", is_system_group=True, realm=realm\n        )\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(internet_group.id).decode()},\n        )\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:internet' group.\",\n        )\n\n        owners_group = UserGroup.objects.get(name=\"@role:owners\", is_system_group=True, realm=realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(owners_group.id).decode()},\n        )\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:owners' group.\",\n        )\n\n        nobody_group = UserGroup.objects.get(name=\"@role:nobody\", is_system_group=True, realm=realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(nobody_group.id).decode()},\n        )\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:nobody' group.\",\n        )\n\n        # For private streams, even admins must be subscribed to the stream to change\n        # can_remove_subscribers_group setting.\n        stream = self.make_stream(\"stream_name2\", invite_only=True)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.subscribe(user_profile, \"stream_name2\")\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name2\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n    def test_stream_message_retention_days_on_stream_creation(self) -> None:\n        \"\"\"\n        Only admins can create streams with message_retention_days\n        with value other than None.\n        \"\"\"\n        admin = self.example_user(\"iago\")\n\n        streams_raw: List[StreamDict] = [\n            {\n                \"name\": \"new_stream\",\n                \"message_retention_days\": 10,\n                \"is_web_public\": False,\n            }\n        ]\n        with self.assertRaisesRegex(JsonableError, \"Must be an organization owner\"):\n            list_to_streams(streams_raw, admin, autocreate=True)\n\n        streams_raw = [\n            {\n                \"name\": \"new_stream\",\n                \"message_retention_days\": -1,\n                \"is_web_public\": False,\n            }\n        ]\n        with self.assertRaisesRegex(JsonableError, \"Must be an organization owner\"):\n            list_to_streams(streams_raw, admin, autocreate=True)\n\n        streams_raw = [\n            {\n                \"name\": \"new_stream\",\n                \"message_retention_days\": None,\n                \"is_web_public\": False,\n            }\n        ]\n        result = list_to_streams(streams_raw, admin, autocreate=True)\n        self.assert_length(result[0], 0)\n        self.assert_length(result[1], 1)\n        self.assertEqual(result[1][0].name, \"new_stream\")\n        self.assertEqual(result[1][0].message_retention_days, None)\n\n        owner = self.example_user(\"desdemona\")\n        realm = owner.realm\n        streams_raw = [\n            {\n                \"name\": \"new_stream1\",\n                \"message_retention_days\": 10,\n                \"is_web_public\": False,\n            },\n            {\n                \"name\": \"new_stream2\",\n                \"message_retention_days\": -1,\n                \"is_web_public\": False,\n            },\n            {\n                \"name\": \"new_stream3\",\n                \"is_web_public\": False,\n            },\n        ]\n\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_LIMITED, acting_user=admin)\n        with self.assertRaisesRegex(\n            JsonableError, \"Available on Zulip Cloud Standard. Upgrade to access.\"\n        ):\n            list_to_streams(streams_raw, owner, autocreate=True)\n\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_SELF_HOSTED, acting_user=admin)\n        result = list_to_streams(streams_raw, owner, autocreate=True)\n        self.assert_length(result[0], 0)\n        self.assert_length(result[1], 3)\n        self.assertEqual(result[1][0].name, \"new_stream1\")\n        self.assertEqual(result[1][0].message_retention_days, 10)\n        self.assertEqual(result[1][1].name, \"new_stream2\")\n        self.assertEqual(result[1][1].message_retention_days, -1)\n        self.assertEqual(result[1][2].name, \"new_stream3\")\n        self.assertEqual(result[1][2].message_retention_days, None)\n\n    def set_up_stream_for_archiving(\n        self, stream_name: str, invite_only: bool = False, subscribed: bool = True\n    ) -> Stream:\n        \"\"\"\n        Create a stream for archiving by an administrator.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.make_stream(stream_name, invite_only=invite_only)\n\n        # For testing archiving streams you aren't on.\n        if subscribed:\n            self.subscribe(user_profile, stream_name)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        return stream\n\n    def archive_stream(self, stream: Stream) -> None:\n        \"\"\"\n        Archive the stream and assess the result.\n        \"\"\"\n        active_name = stream.name\n        realm = stream.realm\n        stream_id = stream.id\n\n        # Simulate that a stream by the same name has already been\n        # deactivated, just to exercise our renaming logic:\n        # Since we do not know the id of these simulated stream we prepend the name with a random hashed_stream_id\n        ensure_stream(realm, \"DB32B77!DEACTIVATED:\" + active_name, acting_user=None)\n\n        with self.capture_send_event_calls(expected_num_events=1) as events:\n            result = self.client_delete(\"/json/streams/\" + str(stream_id))\n        self.assert_json_success(result)\n\n        # We no longer send subscription events for stream deactivations.\n        sub_events = [e for e in events if e[\"event\"][\"type\"] == \"subscription\"]\n        self.assertEqual(sub_events, [])\n\n        stream_events = [e for e in events if e[\"event\"][\"type\"] == \"stream\"]\n        self.assert_length(stream_events, 1)\n        event = stream_events[0][\"event\"]\n        self.assertEqual(event[\"op\"], \"delete\")\n        self.assertEqual(event[\"streams\"][0][\"stream_id\"], stream.id)\n\n        with self.assertRaises(Stream.DoesNotExist):\n            Stream.objects.get(realm=get_realm(\"zulip\"), name=active_name)\n\n        # A deleted stream's name is changed, is deactivated, is invite-only,\n        # and has no subscribers.\n        hashed_stream_id = hashlib.sha512(str(stream_id).encode()).hexdigest()[0:7]\n        deactivated_stream_name = hashed_stream_id + \"!DEACTIVATED:\" + active_name\n        deactivated_stream = get_stream(deactivated_stream_name, realm)\n        self.assertTrue(deactivated_stream.deactivated)\n        self.assertTrue(deactivated_stream.invite_only)\n        self.assertEqual(deactivated_stream.name, deactivated_stream_name)\n        subscribers = self.users_subscribed_to_stream(deactivated_stream_name, realm)\n        self.assertEqual(subscribers, [])\n\n        # It doesn't show up in the list of public streams anymore.\n        result = self.client_get(\"/json/streams\", {\"include_subscribed\": \"false\"})\n        public_streams = [s[\"name\"] for s in self.assert_json_success(result)[\"streams\"]]\n        self.assertNotIn(active_name, public_streams)\n        self.assertNotIn(deactivated_stream_name, public_streams)\n\n        # Even if you could guess the new name, you can't subscribe to it.\n        result = self.client_post(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": orjson.dumps([{\"name\": deactivated_stream_name}]).decode()},\n        )\n        self.assert_json_error(result, f\"Unable to access stream ({deactivated_stream_name}).\")\n\n        # You cannot re-archive the stream\n        with self.capture_send_event_calls(expected_num_events=0) as events:\n            result = self.client_delete(\"/json/streams/\" + str(stream_id))\n        self.assert_json_error(result, \"Stream is already deactivated\")\n\n    def test_you_must_be_realm_admin(self) -> None:\n        \"\"\"\n        You must be on the realm to create a stream.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        other_realm = do_create_realm(string_id=\"other\", name=\"other\")\n        stream = self.make_stream(\"other_realm_stream\", realm=other_realm)\n\n        result = self.client_delete(\"/json/streams/\" + str(stream.id))\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # Even becoming a realm admin doesn't help us for an out-of-realm\n        # stream.\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        result = self.client_delete(\"/json/streams/\" + str(stream.id))\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_delete_public_stream(self) -> None:\n        \"\"\"\n        When an administrator deletes a public stream, that stream is not\n        visible to users at all anymore.\n        \"\"\"\n        stream = self.set_up_stream_for_archiving(\"newstream\")\n        self.archive_stream(stream)\n\n    def test_delete_private_stream(self) -> None:\n        \"\"\"\n        Administrators can delete private streams they are on.\n        \"\"\"\n        stream = self.set_up_stream_for_archiving(\"newstream\", invite_only=True)\n        self.archive_stream(stream)\n\n    def test_archive_stream_youre_not_on(self) -> None:\n        \"\"\"\n        Administrators can delete public streams they aren't on\n        \"\"\"\n        pub_stream = self.set_up_stream_for_archiving(\"pubstream\", subscribed=False)\n        self.archive_stream(pub_stream)\n\n    def test_archive_invite_only_stream_youre_not_on(self) -> None:\n        \"\"\"\n        Administrators can delete invite-only streams they aren't on\n        \"\"\"\n        priv_stream = self.set_up_stream_for_archiving(\n            \"privstream\", subscribed=False, invite_only=True\n        )\n        self.archive_stream(priv_stream)\n\n    def attempt_unsubscribe_of_principal(\n        self,\n        target_users: List[UserProfile],\n        query_count: int,\n        cache_count: Optional[int] = None,\n        is_realm_admin: bool = False,\n        is_subbed: bool = True,\n        invite_only: bool = False,\n        target_users_subbed: bool = True,\n        using_legacy_emails: bool = False,\n        other_sub_users: Sequence[UserProfile] = [],\n    ) -> \"TestHttpResponse\":\n        # Set up the main user, who is in most cases an admin.\n        if is_realm_admin:\n            user_profile = self.example_user(\"iago\")\n        else:\n            user_profile = self.example_user(\"hamlet\")\n\n        self.login_user(user_profile)\n\n        # Set up the stream.\n        stream_name = \"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name, invite_only=invite_only)\n\n        # Set up the principal to be unsubscribed.\n        principals: List[Union[str, int]] = []\n        for user in target_users:\n            if using_legacy_emails:\n                principals.append(user.email)\n            else:\n                principals.append(user.id)\n\n        # Subscribe the admin and/or principal as specified in the flags.\n        if is_subbed:\n            self.subscribe(user_profile, stream_name)\n        if target_users_subbed:\n            for user in target_users:\n                self.subscribe(user, stream_name)\n        for user in other_sub_users:\n            self.subscribe(user, stream_name)\n\n        with self.assert_database_query_count(query_count):\n            with cache_tries_captured() as cache_tries:\n                result = self.client_delete(\n                    \"/json/users/me/subscriptions\",\n                    {\n                        \"subscriptions\": orjson.dumps([stream_name]).decode(),\n                        \"principals\": orjson.dumps(principals).decode(),\n                    },\n                )\n        if cache_count is not None:\n            self.assert_length(cache_tries, cache_count)\n\n        # If the removal succeeded, assert all target users are no longer subscribed.\n        if result.status_code not in [400]:\n            subbed_users = self.users_subscribed_to_stream(stream_name, user_profile.realm)\n            for user in target_users:\n                self.assertNotIn(user, subbed_users)\n\n        return result\n\n    def test_cant_remove_other_users_from_stream(self) -> None:\n        \"\"\"\n        If you're not an admin, you can't remove other people from streams except your own bots.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=7,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_realm_admin_remove_others_from_public_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove people from public streams, even\n        those you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=15,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_realm_admin_remove_multiple_users_from_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove multiple users from a stream.\n\n        TODO: We have too many queries for this situation--each additional\n              user leads to 4 more queries.\n\n              Fortunately, some of the extra work here is in\n              do_mark_stream_messages_as_read, which gets deferred\n              using a queue.\n        \"\"\"\n        target_users = [\n            self.example_user(name)\n            for name in [\"cordelia\", \"prospero\", \"iago\", \"hamlet\", \"outgoing_webhook_bot\"]\n        ]\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=27,\n            cache_count=9,\n            target_users=target_users,\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 5)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_realm_admin_remove_others_from_subbed_private_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove other people from private streams you\n        are on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=16,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=True,\n            target_users_subbed=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_realm_admin_remove_others_from_unsubbed_private_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove people from private\n        streams you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=16,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=False,\n            invite_only=True,\n            target_users_subbed=True,\n            other_sub_users=[self.example_user(\"othello\")],\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_cant_remove_others_from_stream_legacy_emails(self) -> None:\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=7,\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users=[self.example_user(\"cordelia\")],\n            target_users_subbed=True,\n            using_legacy_emails=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_admin_remove_others_from_stream_legacy_emails(self) -> None:\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=15,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n            using_legacy_emails=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_admin_remove_multiple_users_from_stream_legacy_emails(self) -> None:\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=18,\n            target_users=[self.example_user(\"cordelia\"), self.example_user(\"prospero\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n            using_legacy_emails=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 2)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_remove_already_not_subbed(self) -> None:\n        \"\"\"\n        Trying to unsubscribe someone who already isn't subscribed to a stream\n        fails gracefully.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=10,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=False,\n            invite_only=False,\n            target_users_subbed=False,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 0)\n        self.assert_length(json[\"not_removed\"], 1)\n\n    def test_bot_owner_can_remove_bot_from_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        webhook_bot = self.example_user(\"webhook_bot\")\n        do_change_bot_owner(webhook_bot, bot_owner=user_profile, acting_user=user_profile)\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=14,\n            target_users=[webhook_bot],\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        self.assert_json_success(result)\n\n    def test_non_bot_owner_cannot_remove_bot_from_stream(self) -> None:\n        other_user = self.example_user(\"cordelia\")\n        webhook_bot = self.example_user(\"webhook_bot\")\n        do_change_bot_owner(webhook_bot, bot_owner=other_user, acting_user=other_user)\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=8,\n            target_users=[webhook_bot],\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_can_remove_subscribers_group(self) -> None:\n        realm = get_realm(\"zulip\")\n        leadership_group = check_add_user_group(\n            realm,\n            \"leadership\",\n            [self.example_user(\"iago\"), self.example_user(\"shiva\")],\n            acting_user=None,\n        )\n        managers_group = check_add_user_group(\n            realm, \"managers\", [self.example_user(\"hamlet\")], acting_user=None\n        )\n        add_subgroups_to_user_group(managers_group, [leadership_group], acting_user=None)\n        cordelia = self.example_user(\"cordelia\")\n\n        stream = self.make_stream(\"public_stream\")\n\n        def check_unsubscribing_user(\n            user: UserProfile, can_remove_subscribers_group: UserGroup, expect_fail: bool = False\n        ) -> None:\n            self.login_user(user)\n            self.subscribe(cordelia, stream.name)\n            do_change_stream_group_based_setting(\n                stream,\n                \"can_remove_subscribers_group\",\n                can_remove_subscribers_group,\n                acting_user=None,\n            )\n            result = self.client_delete(\n                \"/json/users/me/subscriptions\",\n                {\n                    \"subscriptions\": orjson.dumps([stream.name]).decode(),\n                    \"principals\": orjson.dumps([cordelia.id]).decode(),\n                },\n            )\n            if expect_fail:\n                self.assert_json_error(result, \"Insufficient permission\")\n                return\n\n            json = self.assert_json_success(result)\n            self.assert_length(json[\"removed\"], 1)\n            self.assert_length(json[\"not_removed\"], 0)\n\n        check_unsubscribing_user(self.example_user(\"hamlet\"), leadership_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"desdemona\"), leadership_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"iago\"), leadership_group)\n\n        check_unsubscribing_user(self.example_user(\"othello\"), managers_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"shiva\"), managers_group)\n        check_unsubscribing_user(self.example_user(\"hamlet\"), managers_group)\n\n        stream = self.make_stream(\"private_stream\", invite_only=True)\n        self.subscribe(self.example_user(\"hamlet\"), stream.name)\n        # Non-admins are not allowed to unsubscribe others from private streams that they\n        # are not subscribed to even if they are member of the allowed group.\n        check_unsubscribing_user(self.example_user(\"shiva\"), leadership_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"iago\"), leadership_group)\n\n        self.subscribe(self.example_user(\"shiva\"), stream.name)\n        check_unsubscribing_user(self.example_user(\"shiva\"), leadership_group)\n\n    def test_remove_invalid_user(self) -> None:\n        \"\"\"\n        Trying to unsubscribe an invalid user from a stream fails gracefully.\n        \"\"\"\n        admin = self.example_user(\"iago\")\n        self.login_user(admin)\n        self.assertTrue(admin.is_realm_admin)\n\n        stream_name = \"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name)\n\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\",\n            {\n                \"subscriptions\": orjson.dumps([stream_name]).decode(),\n                \"principals\": orjson.dumps([99]).decode(),\n            },\n        )\n        self.assert_json_error(\n            result, \"User not authorized to execute queries on behalf of '99'\", status_code=403\n        )\n\n\nclass DefaultStreamTest(ZulipTestCase):\n    def get_default_stream_names(self, realm: Realm) -> Set[str]:\n        streams = get_default_streams_for_realm(realm.id)\n        stream_names = [s.name for s in streams]\n        return set(stream_names)\n\n    def test_add_and_remove_default_stream(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream = ensure_stream(realm, \"Added stream\", acting_user=None)\n        orig_stream_names = self.get_default_stream_names(realm)\n        do_add_default_stream(stream)\n        new_stream_names = self.get_default_stream_names(realm)\n        added_stream_names = new_stream_names - orig_stream_names\n        self.assertEqual(added_stream_names, {\"Added stream\"})\n        # idempotency--2nd call to add_default_stream should be a noop\n        do_add_default_stream(stream)\n        self.assertEqual(self.get_default_stream_names(realm), new_stream_names)\n\n        # start removing\n        do_remove_default_stream(stream)\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n        # idempotency--2nd call to remove_default_stream should be a noop\n        do_remove_default_stream(stream)\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n\n    def test_api_calls(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        self.login_user(user_profile)\n\n        DefaultStream.objects.filter(realm=user_profile.realm).delete()\n\n        stream_name = \"stream ADDED via api\"\n        stream = ensure_stream(user_profile.realm, stream_name, acting_user=None)\n        result = self.client_post(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_success(result)\n        self.assertTrue(stream_name in self.get_default_stream_names(user_profile.realm))\n\n        # look for it\n        self.subscribe(user_profile, stream_name)\n        payload = dict(\n            include_public=\"true\",\n            include_default=\"true\",\n        )\n        result = self.client_get(\"/json/streams\", payload)\n        streams = self.assert_json_success(result)[\"streams\"]\n        default_streams = {stream[\"name\"] for stream in streams if stream[\"is_default\"]}\n        self.assertEqual(default_streams, {stream_name})\n\n        other_streams = {stream[\"name\"] for stream in streams if not stream[\"is_default\"]}\n        self.assertGreater(len(other_streams), 0)\n\n        # and remove it\n        result = self.client_delete(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_success(result)\n        self.assertFalse(stream_name in self.get_default_stream_names(user_profile.realm))\n\n        # Test admin can't access unsubscribed private stream for adding.\n        stream_name = \"private_stream\"\n        stream = self.make_stream(stream_name, invite_only=True)\n        self.subscribe(self.example_user(\"iago\"), stream_name)\n        result = self.client_post(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # Test admin can't add subscribed private stream also.\n        self.subscribe(user_profile, stream_name)\n        result = self.client_post(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_error(result, \"Private streams cannot be made default.\")\n\n    def test_guest_user_access_to_streams(self) -> None:\n        user_profile = self.example_user(\"polonius\")\n        self.login_user(user_profile)\n        self.assertEqual(user_profile.role, UserProfile.ROLE_GUEST)\n\n        # Get all the streams that Polonius has access to (subscribed + web-public streams)\n        result = self.client_get(\"/json/streams\", {\"include_web_public\": \"true\"})\n        streams = self.assert_json_success(result)[\"streams\"]\n        sub_info = gather_subscriptions_helper(user_profile)\n\n        subscribed = sub_info.subscriptions\n        unsubscribed = sub_info.unsubscribed\n        never_subscribed = sub_info.never_subscribed\n\n        self.assert_length(streams, len(subscribed) + len(unsubscribed) + len(never_subscribed))\n        stream_names = [stream[\"name\"] for stream in streams]\n        expected_stream_names = [stream[\"name\"] for stream in subscribed + unsubscribed]\n        expected_stream_names += [stream[\"name\"] for stream in never_subscribed]\n        self.assertEqual(set(stream_names), set(expected_stream_names))\n\n\nclass DefaultStreamGroupTest(ZulipTestCase):\n    def test_create_update_and_remove_default_stream_group(self) -> None:\n        realm = get_realm(\"zulip\")\n\n        # Test creating new default stream group\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        streams = []\n        for stream_name in [\"stream1\", \"stream2\", \"stream3\"]:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        def get_streams(group: DefaultStreamGroup) -> List[Stream]:\n            return list(group.streams.all().order_by(\"name\"))\n\n        group_name = \"group1\"\n        description = \"This is group1\"\n        do_create_default_stream_group(realm, group_name, description, streams)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(default_stream_groups[0].description, description)\n        self.assertEqual(get_streams(default_stream_groups[0]), streams)\n\n        # Test adding streams to existing default stream group\n        group = lookup_default_stream_groups([\"group1\"], realm)[0]\n        new_stream_names = [\"stream4\", \"stream5\"]\n        new_streams = []\n        for new_stream_name in new_stream_names:\n            new_stream = ensure_stream(realm, new_stream_name, acting_user=None)\n            new_streams.append(new_stream)\n            streams.append(new_stream)\n\n        do_add_streams_to_default_stream_group(realm, group, new_streams)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(get_streams(default_stream_groups[0]), streams)\n\n        # Test removing streams from existing default stream group\n        do_remove_streams_from_default_stream_group(realm, group, new_streams)\n        remaining_streams = streams[0:3]\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(get_streams(default_stream_groups[0]), remaining_streams)\n\n        # Test changing default stream group description\n        new_description = \"group1 new description\"\n        do_change_default_stream_group_description(realm, group, new_description)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assertEqual(default_stream_groups[0].description, new_description)\n        self.assert_length(default_stream_groups, 1)\n\n        # Test changing default stream group name\n        new_group_name = \"new group1\"\n        do_change_default_stream_group_name(realm, group, new_group_name)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, new_group_name)\n        self.assertEqual(get_streams(default_stream_groups[0]), remaining_streams)\n\n        # Test removing default stream group\n        do_remove_default_stream_group(realm, group)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        # Test creating a default stream group which contains a default stream\n        do_add_default_stream(remaining_streams[0])\n        with self.assertRaisesRegex(\n            JsonableError, \"'stream1' is a default stream and cannot be added to 'new group1'\"\n        ):\n            do_create_default_stream_group(\n                realm, new_group_name, \"This is group1\", remaining_streams\n            )\n\n    def test_api_calls(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        # Test creating new default stream group\n        stream_names = [\"stream1\", \"stream2\", \"stream3\"]\n        group_name = \"group1\"\n        description = \"This is group1\"\n        streams = []\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        for stream_name in stream_names:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": group_name,\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(default_stream_groups[0].description, description)\n        self.assertEqual(list(default_stream_groups[0].streams.all().order_by(\"id\")), streams)\n\n        # Try adding the same streams to the group.\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": group_name,\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Default stream group 'group1' already exists\")\n\n        # Test adding streams to existing default stream group\n        group_id = default_stream_groups[0].id\n        new_stream_names = [\"stream4\", \"stream5\"]\n        new_streams = []\n        for new_stream_name in new_stream_names:\n            new_stream = ensure_stream(realm, new_stream_name, acting_user=None)\n            new_streams.append(new_stream)\n            streams.append(new_stream)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, \"Missing 'op' argument\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"invalid\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, 'Invalid value for \"op\". Specify one of \"add\" or \"remove\".')\n\n        result = self.client_patch(\n            \"/json/default_stream_groups/12345/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, \"Default stream group with id '12345' does not exist.\")\n\n        result = self.client_patch(f\"/json/default_stream_groups/{group_id}/streams\", {\"op\": \"add\"})\n        self.assert_json_error(result, \"Missing 'stream_names' argument\")\n\n        do_add_default_stream(new_streams[0])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(\n            result, \"'stream4' is a default stream and cannot be added to 'group1'\"\n        )\n\n        do_remove_default_stream(new_streams[0])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(list(default_stream_groups[0].streams.all().order_by(\"name\")), streams)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(\n            result, \"Stream 'stream4' is already present in default stream group 'group1'\"\n        )\n\n        # Test removing streams from default stream group\n        result = self.client_patch(\n            \"/json/default_stream_groups/12345/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, \"Default stream group with id '12345' does not exist.\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps([\"random stream name\"]).decode()},\n        )\n        self.assert_json_error(result, \"Invalid stream name 'random stream name'\")\n\n        streams.remove(new_streams[0])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps([new_stream_names[0]]).decode()},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(list(default_stream_groups[0].streams.all().order_by(\"name\")), streams)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(\n            result, \"Stream 'stream4' is not present in default stream group 'group1'\"\n        )\n\n        # Test changing description of default stream group\n        new_description = \"new group1 description\"\n\n        result = self.client_patch(f\"/json/default_stream_groups/{group_id}\")\n        self.assert_json_error(result, 'You must pass \"new_description\" or \"new_group_name\".')\n\n        result = self.client_patch(\n            \"/json/default_stream_groups/12345\",\n            {\"new_description\": new_description},\n        )\n        self.assert_json_error(result, \"Default stream group with id '12345' does not exist.\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_description\": new_description},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(default_stream_groups[0].description, new_description)\n\n        # Test changing name of default stream group\n        new_group_name = \"new group1\"\n        do_create_default_stream_group(realm, \"group2\", \"\", [])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_group_name\": \"group2\"},\n        )\n        self.assert_json_error(result, \"Default stream group 'group2' already exists\")\n        new_group = lookup_default_stream_groups([\"group2\"], realm)[0]\n        do_remove_default_stream_group(realm, new_group)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_group_name\": group_name},\n        )\n        self.assert_json_error(result, \"This default stream group is already named 'group1'\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_group_name\": new_group_name},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, new_group_name)\n        self.assertEqual(default_stream_groups[0].description, new_description)\n\n        # Test deleting a default stream group\n        result = self.client_delete(f\"/json/default_stream_groups/{group_id}\")\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        result = self.client_delete(f\"/json/default_stream_groups/{group_id}\")\n        self.assert_json_error(result, f\"Default stream group with id '{group_id}' does not exist.\")\n\n    def test_invalid_default_stream_group_name(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        realm = user_profile.realm\n\n        stream_names = [\"stream1\", \"stream2\", \"stream3\"]\n        description = \"This is group1\"\n        streams = []\n\n        for stream_name in stream_names:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": \"\",\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Invalid default stream group name ''\")\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": \"x\" * 100,\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(\n            result,\n            \"Default stream group name too long (limit: {} characters)\".format(\n                DefaultStreamGroup.MAX_NAME_LENGTH\n            ),\n        )\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": \"abc\\000\",\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(\n            result, \"Default stream group name 'abc\\000' contains NULL (0x00) characters.\"\n        )\n\n        # Also test that lookup_default_stream_groups raises an\n        # error if we pass it a bad name.  This function is used\n        # during registration, but it's a bit heavy to do a full\n        # test of that.\n        with self.assertRaisesRegex(JsonableError, \"Invalid default stream group invalid-name\"):\n            lookup_default_stream_groups([\"invalid-name\"], realm)\n\n\nclass SubscriptionPropertiesTest(ZulipTestCase):\n    def test_set_stream_color(self) -> None:\n        \"\"\"\n        A POST request to /api/v1/users/me/subscriptions/properties with stream_id and\n        color data sets the stream color, and for that stream only. Also, make sure that\n        any invalid hex color codes are bounced.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        old_subs, _ = gather_subscriptions(test_user)\n        sub = old_subs[0]\n        stream_id = sub[\"stream_id\"]\n        new_color = \"#ffffff\"  # TODO: ensure that this is different from old_color\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"stream_id\": stream_id, \"value\": \"#ffffff\"}]\n                ).decode()\n            },\n        )\n        self.assert_json_success(result)\n\n        new_subs = gather_subscriptions(test_user)[0]\n        found_sub = None\n        for sub in new_subs:\n            if sub[\"stream_id\"] == stream_id:\n                found_sub = sub\n                break\n\n        assert found_sub is not None\n        self.assertEqual(found_sub[\"color\"], new_color)\n\n        new_subs.remove(found_sub)\n        for sub in old_subs:\n            if sub[\"stream_id\"] == stream_id:\n                found_sub = sub\n                break\n        old_subs.remove(found_sub)\n        self.assertEqual(old_subs, new_subs)\n\n        invalid_color = \"3ffrff\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"stream_id\": stream_id, \"value\": invalid_color}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"color is not a valid hex color code\")\n\n    def test_set_color_missing_stream_id(self) -> None:\n        \"\"\"\n        Updating the color property requires a `stream_id` key.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"value\": \"#ffffff\"}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"stream_id key is missing from subscription_data[0]\")\n\n    def test_set_color_unsubscribed_stream_id(self) -> None:\n        \"\"\"\n        Updating the color property requires a subscribed stream.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        sub_info = gather_subscriptions_helper(test_user)\n\n        not_subbed = sub_info.never_subscribed\n\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [\n                        {\n                            \"property\": \"color\",\n                            \"stream_id\": not_subbed[0][\"stream_id\"],\n                            \"value\": \"#ffffff\",\n                        }\n                    ]\n                ).decode()\n            },\n        )\n        self.assert_json_error(\n            result, \"Not subscribed to stream id {}\".format(not_subbed[0][\"stream_id\"])\n        )\n\n    def test_set_color_missing_color(self) -> None:\n        \"\"\"\n        Updating the color property requires a color.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"value key is missing from subscription_data[0]\")\n\n    def test_set_stream_wildcard_mentions_notify(self) -> None:\n        \"\"\"\n        A POST request to /api/v1/users/me/subscriptions/properties with wildcard_mentions_notify\n        sets the property.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        subs = gather_subscriptions(test_user)[0]\n        sub = subs[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [\n                        {\n                            \"property\": \"wildcard_mentions_notify\",\n                            \"stream_id\": sub[\"stream_id\"],\n                            \"value\": True,\n                        }\n                    ]\n                ).decode()\n            },\n        )\n\n        self.assert_json_success(result)\n\n        updated_sub = get_subscription(sub[\"name\"], test_user)\n        self.assertIsNotNone(updated_sub)\n        self.assertEqual(updated_sub.wildcard_mentions_notify, True)\n\n    def test_set_pin_to_top(self) -> None:\n        \"\"\"\n        A POST request to /api/v1/users/me/subscriptions/properties with stream_id and\n        pin_to_top data pins the stream.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        old_subs, _ = gather_subscriptions(user)\n        sub = old_subs[0]\n        stream_id = sub[\"stream_id\"]\n        new_pin_to_top = not sub[\"pin_to_top\"]\n        result = self.api_post(\n            user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"pin_to_top\", \"stream_id\": stream_id, \"value\": new_pin_to_top}]\n                ).decode()\n            },\n        )\n        self.assert_json_success(result)\n\n        updated_sub = get_subscription(sub[\"name\"], user)\n\n        self.assertIsNotNone(updated_sub)\n        self.assertEqual(updated_sub.pin_to_top, new_pin_to_top)\n\n    def test_change_is_muted(self) -> None:\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, False)\n\n        property_name = \"is_muted\"\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.api_post(\n                test_user,\n                \"/api/v1/users/me/subscriptions/properties\",\n                {\n                    \"subscription_data\": orjson.dumps(\n                        [\n                            {\n                                \"property\": property_name,\n                                \"value\": True,\n                                \"stream_id\": subs[0][\"stream_id\"],\n                            }\n                        ]\n                    ).decode()\n                },\n            )\n        self.assert_json_success(result)\n        self.assertEqual(events[0][\"event\"][\"property\"], \"in_home_view\")\n        self.assertEqual(events[0][\"event\"][\"value\"], False)\n        self.assertEqual(events[1][\"event\"][\"property\"], \"is_muted\")\n        self.assertEqual(events[1][\"event\"][\"value\"], True)\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, True)\n\n        legacy_property_name = \"in_home_view\"\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.api_post(\n                test_user,\n                \"/api/v1/users/me/subscriptions/properties\",\n                {\n                    \"subscription_data\": orjson.dumps(\n                        [\n                            {\n                                \"property\": legacy_property_name,\n                                \"value\": True,\n                                \"stream_id\": subs[0][\"stream_id\"],\n                            }\n                        ]\n                    ).decode()\n                },\n            )\n        self.assert_json_success(result)\n        self.assertEqual(events[0][\"event\"][\"property\"], \"in_home_view\")\n        self.assertEqual(events[0][\"event\"][\"value\"], True)\n        self.assertEqual(events[1][\"event\"][\"property\"], \"is_muted\")\n        self.assertEqual(events[1][\"event\"][\"value\"], False)\n        self.assert_json_success(result)\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, False)\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.api_post(\n                test_user,\n                \"/api/v1/users/me/subscriptions/properties\",\n                {\n                    \"subscription_data\": orjson.dumps(\n                        [\n                            {\n                                \"property\": legacy_property_name,\n                                \"value\": False,\n                                \"stream_id\": subs[0][\"stream_id\"],\n                            }\n                        ]\n                    ).decode()\n                },\n            )\n        self.assert_json_success(result)\n        self.assertEqual(events[0][\"event\"][\"property\"], \"in_home_view\")\n        self.assertEqual(events[0][\"event\"][\"value\"], False)\n        self.assertEqual(events[1][\"event\"][\"property\"], \"is_muted\")\n        self.assertEqual(events[1][\"event\"][\"value\"], True)\n\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, True)\n\n    def test_set_subscription_property_incorrect(self) -> None:\n        \"\"\"\n        Trying to set a property incorrectly returns a JSON error.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n\n        property_name = \"is_muted\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"in_home_view\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"desktop_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"audible_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"push_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"email_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"wildcard_mentions_notify\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"color\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": False, \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a string\")\n\n    def test_json_subscription_property_invalid_stream(self) -> None:\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        stream_id = 1000\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"is_muted\", \"stream_id\": stream_id, \"value\": False}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_set_invalid_property(self) -> None:\n        \"\"\"\n        Trying to set an invalid property returns a JSON error.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"bad\", \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"Unknown subscription property: bad\")\n\n    def test_ignored_parameters_in_subscriptions_properties_endpoint(self) -> None:\n        \"\"\"\n        Sending an invalid parameter with a valid parameter returns\n        an `ignored_parameters_unsupported` array.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        subs = gather_subscriptions(test_user)[0]\n        sub = subs[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [\n                        {\n                            \"property\": \"wildcard_mentions_notify\",\n                            \"stream_id\": sub[\"stream_id\"],\n                            \"value\": True,\n                        }\n                    ]\n                ).decode(),\n                \"invalid_parameter\": orjson.dumps(\n                    [{\"property\": \"pin_to_top\", \"stream_id\": sub[\"stream_id\"], \"value\": False}]\n                ).decode(),\n            },\n        )\n\n        self.assert_json_success(result, ignored_parameters=[\"invalid_parameter\"])\n\n\nclass SubscriptionRestApiTest(ZulipTestCase):\n    def test_basic_add_delete(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        # add\n        request = {\n            \"add\": orjson.dumps([{\"name\": \"my_test_stream_1\"}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_success(result)\n        streams = self.get_streams(user)\n        self.assertTrue(\"my_test_stream_1\" in streams)\n\n        # now delete the same stream\n        request = {\n            \"delete\": orjson.dumps([\"my_test_stream_1\"]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_success(result)\n        streams = self.get_streams(user)\n        self.assertTrue(\"my_test_stream_1\" not in streams)\n\n    def test_add_with_color(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        # add with color proposition\n        request = {\n            \"add\": orjson.dumps([{\"name\": \"my_test_stream_2\", \"color\": \"#afafaf\"}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_success(result)\n\n        # incorrect color format\n        request = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"my_test_stream_3\", \"color\": \"#0g0g0g\"}]\n            ).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, 'subscriptions[0][\"color\"] is not a valid hex color code')\n\n    def test_api_valid_property(self) -> None:\n        \"\"\"\n        Trying to set valid json returns success message.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n\n        self.login_user(user)\n        subs = gather_subscriptions(user)[0]\n        result = self.api_patch(\n            user,\n            \"/api/v1/users/me/subscriptions/{}\".format(subs[0][\"stream_id\"]),\n            {\"property\": \"color\", \"value\": \"#c2c2c2\"},\n        )\n        self.assert_json_success(result)\n\n    def test_api_invalid_property(self) -> None:\n        \"\"\"\n        Trying to set an invalid property returns a JSON error.\n        \"\"\"\n\n        user = self.example_user(\"hamlet\")\n\n        self.login_user(user)\n        subs = gather_subscriptions(user)[0]\n\n        result = self.api_patch(\n            user,\n            \"/api/v1/users/me/subscriptions/{}\".format(subs[0][\"stream_id\"]),\n            {\"property\": \"invalid\", \"value\": \"somevalue\"},\n        )\n        self.assert_json_error(result, \"Unknown subscription property: invalid\")\n\n    def test_api_invalid_stream_id(self) -> None:\n        \"\"\"\n        Trying to set an invalid stream id returns a JSON error.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.api_patch(\n            user,\n            \"/api/v1/users/me/subscriptions/121\",\n            {\"property\": \"is_muted\", \"value\": \"somevalue\"},\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_bad_add_parameters(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        def check_for_error(val: Any, expected_message: str) -> None:\n            request = {\n                \"add\": orjson.dumps(val).decode(),\n            }\n            result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n            self.assert_json_error(result, expected_message)\n\n        check_for_error([\"foo\"], \"add[0] is not a dict\")\n        check_for_error([{\"bogus\": \"foo\"}], \"name key is missing from add[0]\")\n        check_for_error([{\"name\": {}}], 'add[0][\"name\"] is not a string')\n\n    def test_bad_principals(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        request = {\n            \"add\": orjson.dumps([{\"name\": \"my_new_stream\"}]).decode(),\n            \"principals\": orjson.dumps([{}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"principals is not an allowed_type\")\n\n    def test_bad_delete_parameters(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        request = {\n            \"delete\": orjson.dumps([{\"name\": \"my_test_stream_1\"}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"delete[0] is not a string\")\n\n    def test_add_or_delete_not_specified(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", {})\n        self.assert_json_error(result, 'Nothing to do. Specify at least one of \"add\" or \"delete\".')\n\n    def test_patch_enforces_valid_stream_name_check(self) -> None:\n        \"\"\"\n        Only way to force an error is with a empty string.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        invalid_stream_name = \"\"\n        request = {\n            \"delete\": orjson.dumps([invalid_stream_name]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n\n    def test_stream_name_too_long(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        long_stream_name = \"a\" * 61\n        request = {\n            \"delete\": orjson.dumps([long_stream_name]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"Stream name too long (limit: 60 characters).\")\n\n    def test_stream_name_contains_null(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        stream_name = \"abc\\000\"\n        request = {\n            \"delete\": orjson.dumps([stream_name]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n    def test_compose_views_rollback(self) -> None:\n        \"\"\"\n        The compose_views function() is used under the hood by\n        update_subscriptions_backend.  It's a pretty simple method in terms of\n        control flow, but it uses a Django rollback, which may make it brittle\n        code when we upgrade Django.  We test the functions's rollback logic\n        here with a simple scenario to avoid false positives related to\n        subscription complications.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.full_name = \"Hamlet\"\n        user_profile.save()\n        request = HostRequestMock(user_profile=user_profile)\n\n        def thunk1() -> HttpResponse:\n            user_profile.full_name = \"Should not be committed\"\n            user_profile.save()\n            return json_success(request)\n\n        def thunk2() -> HttpResponse:\n            raise JsonableError(\"random failure\")\n\n        with self.assertRaises(JsonableError):\n            compose_views([thunk1, thunk2])\n\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(user_profile.full_name, \"Hamlet\")\n\n\nclass SubscriptionAPITest(ZulipTestCase):\n    def setUp(self) -> None:\n        \"\"\"\n        All tests will be logged in as hamlet. Also save various useful values\n        as attributes that tests can access.\n        \"\"\"\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.test_email = self.user_profile.email\n        self.test_user = self.user_profile\n        self.login_user(self.user_profile)\n        self.test_realm = self.user_profile.realm\n        self.streams = self.get_streams(self.user_profile)\n\n    def make_random_stream_names(self, existing_stream_names: List[str]) -> List[str]:\n        \"\"\"\n        Helper function to make up random stream names. It takes\n        existing_stream_names and randomly appends a digit to the end of each,\n        but avoids names that appear in the list names_to_avoid.\n        \"\"\"\n        random_streams = []\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.test_realm)]\n        for stream in existing_stream_names:\n            random_stream = stream + str(random.randint(0, 9))\n            if random_stream not in all_stream_names:\n                random_streams.append(random_stream)\n        return random_streams\n\n    def test_invalid_stream_name(self) -> None:\n        \"\"\"\n        Creating a stream with invalid 'Cc' and 'Cn' category of unicode characters in stream name\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        # For Cc category\n        post_data_cc = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new\\n\\rstream\", \"description\": \"this is description\"}]\n            ).decode(),\n            \"invite_only\": orjson.dumps(False).decode(),\n        }\n        result = self.api_post(\n            user, \"/api/v1/users/me/subscriptions\", post_data_cc, subdomain=\"zulip\"\n        )\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n        # For Cn category\n        post_data_cn = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new\\uFFFEstream\", \"description\": \"this is description\"}]\n            ).decode(),\n            \"invite_only\": orjson.dumps(False).decode(),\n        }\n        result = self.api_post(\n            user, \"/api/v1/users/me/subscriptions\", post_data_cn, subdomain=\"zulip\"\n        )\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n    def test_invalid_stream_rename(self) -> None:\n        \"\"\"\n        Renaming a stream with invalid characters.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        # Check for empty name\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"\"})\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n        # Check for long name\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"a\" * 61})\n        self.assert_json_error(result, \"Stream name too long (limit: 60 characters).\")\n        # Check for Cc characters\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"test\\n\\rname\"})\n        self.assert_json_error(result, \"Invalid character in stream name, at position 5!\")\n        # Check for Cn characters\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"test\\uFFFEame\"})\n        self.assert_json_error(result, \"Invalid character in stream name, at position 5!\")\n\n    def test_successful_subscriptions_list(self) -> None:\n        \"\"\"\n        Calling /api/v1/users/me/subscriptions should successfully return your subscriptions.\n        \"\"\"\n        result = self.api_get(self.test_user, \"/api/v1/users/me/subscriptions\")\n        json = self.assert_json_success(result)\n        self.assertIn(\"subscriptions\", json)\n        for stream in json[\"subscriptions\"]:\n            self.assertIsInstance(stream[\"name\"], str)\n            self.assertIsInstance(stream[\"color\"], str)\n            self.assertIsInstance(stream[\"invite_only\"], bool)\n            # check that the stream name corresponds to an actual\n            # stream; will throw Stream.DoesNotExist if it doesn't\n            get_stream(stream[\"name\"], self.test_realm)\n        list_streams = [stream[\"name\"] for stream in json[\"subscriptions\"]]\n        # also check that this matches the list of your subscriptions\n        self.assertEqual(sorted(list_streams), sorted(self.streams))\n\n    def test_successful_subscriptions_list_subscribers(self) -> None:\n        \"\"\"\n        Calling /api/v1/users/me/subscriptions should successfully return your subscriptions.\n        \"\"\"\n        result = self.api_get(\n            self.test_user,\n            \"/api/v1/users/me/subscriptions\",\n            {\"include_subscribers\": \"true\"},\n        )\n        json = self.assert_json_success(result)\n        self.assertIn(\"subscriptions\", json)\n        for stream in json[\"subscriptions\"]:\n            self.assertIsInstance(stream[\"name\"], str)\n            self.assertIsInstance(stream[\"color\"], str)\n            self.assertIsInstance(stream[\"invite_only\"], bool)\n            # check that the stream name corresponds to an actual\n            # stream; will throw Stream.DoesNotExist if it doesn't\n            get_stream(stream[\"name\"], self.test_realm)\n        list_streams = [stream[\"name\"] for stream in json[\"subscriptions\"]]\n        # also check that this matches the list of your subscriptions\n        self.assertEqual(sorted(list_streams), sorted(self.streams))\n\n    def helper_check_subs_before_and_after_add(\n        self,\n        subscriptions: List[str],\n        other_params: Dict[str, Any],\n        subscribed: List[str],\n        already_subscribed: List[str],\n        email: str,\n        new_subs: List[str],\n        realm: Realm,\n        invite_only: bool = False,\n    ) -> None:\n        \"\"\"\n        Check result of adding subscriptions.\n\n        You can add subscriptions for yourself or possibly many\n        principals, which is why e-mails map to subscriptions in the\n        result.\n\n        The result json is of the form\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"already_subscribed\": {self.example_email(\"iago\"): [\"Venice\", \"Verona\"]},\n         \"subscribed\": {self.example_email(\"iago\"): [\"Venice8\"]}}\n        \"\"\"\n        result = self.common_subscribe_to_streams(\n            self.test_user, subscriptions, other_params, invite_only=invite_only\n        )\n        json = self.assert_json_success(result)\n        self.assertEqual(sorted(subscribed), sorted(json[\"subscribed\"][email]))\n        self.assertEqual(sorted(already_subscribed), sorted(json[\"already_subscribed\"][email]))\n        user = get_user(email, realm)\n        new_streams = self.get_streams(user)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_add(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        add_streams = [\"Verona2\", \"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)  # necessary for full test coverage\n        # Three events should be sent for each stream for stream creation, subscription add and message notifications.\n        with self.capture_send_event_calls(expected_num_events=6):\n            self.helper_check_subs_before_and_after_add(\n                self.streams + add_streams,\n                {},\n                add_streams,\n                self.streams,\n                self.test_email,\n                self.streams + add_streams,\n                self.test_realm,\n            )\n\n    def test_successful_subscriptions_add_with_announce(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)\n        add_streams = [\"Verona2\", \"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)\n        other_params = {\n            \"announce\": \"true\",\n        }\n        notifications_stream = get_stream(self.streams[0], self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n\n        with self.capture_send_event_calls(expected_num_events=7) as events:\n            self.helper_check_subs_before_and_after_add(\n                self.streams + add_streams,\n                other_params,\n                add_streams,\n                self.streams,\n                self.test_email,\n                self.streams + add_streams,\n                self.test_realm,\n            )\n\n        expected_stream_ids = {get_stream(stream, self.test_realm).id for stream in add_streams}\n\n        (peer_add_event,) = (event for event in events if event[\"event\"].get(\"op\") == \"peer_add\")\n\n        self.assertEqual(set(peer_add_event[\"event\"][\"stream_ids\"]), expected_stream_ids)\n        self.assertEqual(set(peer_add_event[\"event\"][\"user_ids\"]), {self.test_user.id})\n\n    def test_successful_subscriptions_notifies_pm(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n        self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                \"announce\": \"true\",\n                \"principals\": orjson.dumps([self.user_profile.id]).decode(),\n            },\n        )\n\n    def test_successful_subscriptions_notifies_stream(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n        invitee_full_name = \"Iago\"\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n\n        notifications_stream = get_stream(current_stream, self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n\n        self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data=dict(\n                announce=\"true\",\n                principals=orjson.dumps([self.user_profile.id]).decode(),\n            ),\n        )\n        target_stream = get_stream(invite_streams[0], self.test_realm)\n\n        msg = self.get_second_to_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.recipient.type_id, notifications_stream.id)\n        self.assertEqual(msg.sender_id, self.notification_bot(self.test_realm).id)\n        expected_msg = (\n            f\"@_**{invitee_full_name}|{invitee.id}** created a new stream #**{invite_streams[0]}**.\"\n        )\n        self.assertEqual(msg.content, expected_msg)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.recipient.type_id, target_stream.id)\n        self.assertEqual(msg.sender_id, self.notification_bot(self.test_realm).id)\n        expected_msg = (\n            f\"**Public** stream created by @_**{invitee_full_name}|{invitee.id}**. **Description:**\\n\"\n            \"```` quote\\n*No description.*\\n````\"\n        )\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_successful_cross_realm_notification(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions in a new realm\n        should notify with a proper new stream link\n        \"\"\"\n        realm = do_create_realm(\"testrealm\", \"Test Realm\")\n\n        notifications_stream = Stream.objects.get(name=\"general\", realm=realm)\n        realm.notifications_stream = notifications_stream\n        realm.save()\n\n        invite_streams = [\"cross_stream\"]\n\n        user = self.example_user(\"AARON\")\n        user.realm = realm\n        user.save()\n\n        self.common_subscribe_to_streams(\n            user,\n            invite_streams,\n            extra_post_data=dict(\n                announce=\"true\",\n            ),\n            subdomain=\"testrealm\",\n        )\n\n        msg = self.get_second_to_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.recipient.type_id, notifications_stream.id)\n        self.assertEqual(msg.sender_id, self.notification_bot(realm).id)\n        stream_id = Stream.objects.latest(\"id\").id\n        expected_rendered_msg = f'<p><span class=\"user-mention silent\" data-user-id=\"{user.id}\">{user.full_name}</span> created a new stream <a class=\"stream\" data-stream-id=\"{stream_id}\" href=\"/#narrow/stream/{stream_id}-{invite_streams[0]}\">#{invite_streams[0]}</a>.</p>'\n        self.assertEqual(msg.rendered_content, expected_rendered_msg)\n\n    def test_successful_subscriptions_notifies_with_escaping(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee_full_name = \"Iago\"\n        invitee = self.example_user(\"iago\")\n\n        current_stream = self.get_streams(invitee)[0]\n        notifications_stream = get_stream(current_stream, self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n\n        invite_streams = [\"strange ) \\\\ test\"]\n        self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                \"announce\": \"true\",\n                \"principals\": orjson.dumps([self.user_profile.id]).decode(),\n            },\n        )\n\n        msg = self.get_second_to_last_message()\n        self.assertEqual(msg.sender_id, self.notification_bot(notifications_stream.realm).id)\n        expected_msg = (\n            f\"@_**{invitee_full_name}|{invitee.id}** created a new stream #**{invite_streams[0]}**.\"\n        )\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_non_ascii_stream_subscription(self) -> None:\n        \"\"\"\n        Subscribing to a stream name with non-ASCII characters succeeds.\n        \"\"\"\n        self.helper_check_subs_before_and_after_add(\n            [*self.streams, \"h\u00fcmb\u00fc\u01f5\"],\n            {},\n            [\"h\u00fcmb\u00fc\u01f5\"],\n            self.streams,\n            self.test_email,\n            [*self.streams, \"h\u00fcmb\u00fc\u01f5\"],\n            self.test_realm,\n        )\n\n    def test_subscriptions_add_too_long(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is >60\n        characters should return a JSON error.\n        \"\"\"\n        # character limit is 60 characters\n        long_stream_name = \"a\" * 61\n        result = self.common_subscribe_to_streams(\n            self.test_user, [long_stream_name], allow_fail=True\n        )\n        self.assert_json_error(result, \"Stream name too long (limit: 60 characters).\")\n\n    def test_subscriptions_add_stream_with_null(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name contains\n        null characters should return a JSON error.\n        \"\"\"\n        stream_name = \"abc\\000\"\n        result = self.common_subscribe_to_streams(self.test_user, [stream_name], allow_fail=True)\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n    def _test_user_settings_for_creating_streams(\n        self,\n        stream_policy: str,\n        *,\n        invite_only: bool,\n        is_web_public: bool,\n    ) -> None:\n        user_profile = self.example_user(\"cordelia\")\n        realm = user_profile.realm\n\n        do_set_realm_property(realm, stream_policy, Realm.POLICY_ADMINS_ONLY, acting_user=None)\n        do_change_user_role(user_profile, UserProfile.ROLE_MODERATOR, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream1\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        self.common_subscribe_to_streams(user_profile, [\"new_stream1\"], invite_only=invite_only)\n\n        do_set_realm_property(realm, stream_policy, Realm.POLICY_MODERATORS_ONLY, acting_user=None)\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        # Make sure that we are checking the permission with a full member,\n        # as full member is the user just below moderator in the role hierarchy.\n        self.assertFalse(user_profile.is_provisional_member)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream2\"],\n            allow_fail=True,\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MODERATOR, acting_user=None)\n        self.common_subscribe_to_streams(user_profile, [\"new_stream2\"], invite_only=invite_only)\n\n        do_set_realm_property(realm, stream_policy, Realm.POLICY_MEMBERS_ONLY, acting_user=None)\n        do_change_user_role(user_profile, UserProfile.ROLE_GUEST, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream3\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Not allowed for guest users\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user,\n            [\"new_stream4\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n        )\n\n        do_set_realm_property(\n            realm, stream_policy, Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 100000, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream5\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n        self.common_subscribe_to_streams(user_profile, [\"new_stream3\"], invite_only=invite_only)\n\n    def test_user_settings_for_creating_private_streams(self) -> None:\n        self._test_user_settings_for_creating_streams(\n            \"create_private_stream_policy\",\n            invite_only=True,\n            is_web_public=False,\n        )\n\n    def test_user_settings_for_creating_public_streams(self) -> None:\n        self._test_user_settings_for_creating_streams(\n            \"create_public_stream_policy\",\n            invite_only=False,\n            is_web_public=False,\n        )\n\n    def test_user_settings_for_creating_web_public_streams(self) -> None:\n        self._test_user_settings_for_creating_streams(\n            \"create_web_public_stream_policy\", invite_only=False, is_web_public=True\n        )\n\n    def _test_can_create_streams(self, stream_policy: str, invite_only: bool) -> None:\n        if invite_only:\n\n            def validation_func(user_profile: UserProfile) -> bool:\n                user_profile.refresh_from_db()\n                return user_profile.can_create_private_streams()\n\n        else:\n\n            def validation_func(user_profile: UserProfile) -> bool:\n                user_profile.refresh_from_db()\n                return user_profile.can_create_public_streams()\n\n        self.check_has_permission_policies(stream_policy, validation_func)\n\n    def test_can_create_private_streams(self) -> None:\n        self._test_can_create_streams(\"create_private_stream_policy\", invite_only=True)\n\n    def test_can_create_public_streams(self) -> None:\n        self._test_can_create_streams(\"create_public_stream_policy\", invite_only=False)\n\n    def test_can_create_web_public_streams(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_create_web_public_streams()\n\n        self.check_has_permission_policies(\"create_web_public_stream_policy\", validation_func)\n\n    def test_user_settings_for_subscribing_other_users(self) -> None:\n        \"\"\"\n        You can't subscribe other people to streams if you are a guest or your account is not old\n        enough.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        invitee_user_id = user_profile.id\n        realm = user_profile.realm\n\n        do_set_realm_property(\n            realm, \"create_public_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n        do_change_user_role(self.test_user, UserProfile.ROLE_MODERATOR, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream1\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(self.test_user, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user, [\"stream1\"], {\"principals\": orjson.dumps([invitee_user_id]).decode()}\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        do_change_user_role(self.test_user, UserProfile.ROLE_MEMBER, acting_user=None)\n        # Make sure that we are checking the permission with a full member,\n        # as full member is the user just below moderator in the role hierarchy.\n        self.assertFalse(self.test_user.is_provisional_member)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(self.test_user, UserProfile.ROLE_MODERATOR, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user, [\"stream2\"], {\"principals\": orjson.dumps([invitee_user_id]).decode()}\n        )\n        self.unsubscribe(user_profile, \"stream2\")\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        do_change_user_role(self.test_user, UserProfile.ROLE_GUEST, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Not allowed for guest users\")\n\n        do_change_user_role(self.test_user, UserProfile.ROLE_MEMBER, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([self.test_user.id, invitee_user_id]).decode()},\n        )\n        self.unsubscribe(user_profile, \"stream2\")\n\n        do_set_realm_property(\n            realm,\n            \"invite_to_stream_policy\",\n            Realm.POLICY_FULL_MEMBERS_ONLY,\n            acting_user=None,\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 100000, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user, [\"stream2\"], {\"principals\": orjson.dumps([invitee_user_id]).decode()}\n        )\n\n    def test_can_subscribe_other_users(self) -> None:\n        \"\"\"\n        You can't subscribe other people to streams if you are a guest or your account is not old\n        enough.\n        \"\"\"\n\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_subscribe_other_users()\n\n        self.check_has_permission_policies(\"invite_to_stream_policy\", validation_func)\n\n    def test_subscriptions_add_invalid_stream(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid name is the empty string\n        invalid_stream_name = \"\"\n        result = self.common_subscribe_to_streams(\n            self.test_user, [invalid_stream_name], allow_fail=True\n        )\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n\n    def assert_adding_subscriptions_for_principal(\n        self,\n        invitee_data: Union[str, int],\n        invitee_realm: Realm,\n        streams: List[str],\n        policy_name: str,\n        invite_only: bool = False,\n    ) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on behalf of another principal (for\n        whom you have permission to add subscriptions) should successfully add\n        those subscriptions and send a message to the subscribee notifying\n        them.\n        \"\"\"\n        if isinstance(invitee_data, str):\n            other_profile = get_user(invitee_data, invitee_realm)\n        else:\n            other_profile = get_user_profile_by_id_in_realm(invitee_data, invitee_realm)\n        current_streams = self.get_streams(other_profile)\n        self.assertIsInstance(other_profile, UserProfile)\n        self.assertNotEqual(len(current_streams), 0)  # necessary for full test coverage\n        self.assertNotEqual(len(streams), 0)  # necessary for full test coverage\n        streams_to_sub = streams[:1]  # just add one, to make the message easier to check\n        streams_to_sub.extend(current_streams)\n        self.helper_check_subs_before_and_after_add(\n            streams_to_sub,\n            {\"principals\": orjson.dumps([invitee_data]).decode()},\n            streams[:1],\n            current_streams,\n            other_profile.email,\n            streams_to_sub,\n            invitee_realm,\n            invite_only=invite_only,\n        )\n\n        # verify that a welcome message was sent to the stream\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, msg.recipient.STREAM)\n        self.assertEqual(msg.topic_name(), \"stream events\")\n        self.assertEqual(msg.sender.email, settings.NOTIFICATION_BOT)\n        self.assertIn(\n            f\"**{policy_name}** stream created by @_**{self.test_user.full_name}|{self.test_user.id}**. **Description:**\\n\"\n            \"```` quote\",\n            msg.content,\n        )\n\n    def test_multi_user_subscription(self) -> None:\n        user1 = self.example_user(\"cordelia\")\n        user2 = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n        streams_to_sub = [\"multi_user_stream\"]\n        flush_per_request_caches()\n        with self.capture_send_event_calls(expected_num_events=5) as events:\n            with self.assert_database_query_count(36):\n                self.common_subscribe_to_streams(\n                    self.test_user,\n                    streams_to_sub,\n                    dict(principals=orjson.dumps([user1.id, user2.id]).decode()),\n                )\n\n        for ev in [x for x in events if x[\"event\"][\"type\"] not in (\"message\", \"stream\")]:\n            if ev[\"event\"][\"op\"] == \"add\":\n                self.assertEqual(\n                    set(ev[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n                    {user1.id, user2.id},\n                )\n            else:\n                # Check \"peer_add\" events for streams users were\n                # never subscribed to, in order for the neversubscribed\n                # structure to stay up-to-date.\n                self.assertEqual(ev[\"event\"][\"op\"], \"peer_add\")\n\n        stream = get_stream(\"multi_user_stream\", realm)\n        self.assertEqual(num_subscribers_for_stream_id(stream.id), 2)\n\n        # Now add ourselves\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            with self.assert_database_query_count(12):\n                self.common_subscribe_to_streams(\n                    self.test_user,\n                    streams_to_sub,\n                    dict(principals=orjson.dumps([self.test_user.id]).decode()),\n                )\n\n        add_event, add_peer_event = events\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [get_user(self.test_email, self.test_realm).id])\n        self.assertEqual(\n            set(add_event[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n            {user1.id, user2.id, self.test_user.id},\n        )\n\n        self.assertNotIn(self.example_user(\"polonius\").id, add_peer_event[\"users\"])\n        self.assert_length(add_peer_event[\"users\"], 11)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [self.user_profile.id])\n\n        stream = get_stream(\"multi_user_stream\", realm)\n        self.assertEqual(num_subscribers_for_stream_id(stream.id), 3)\n\n        # Finally, add othello.\n        events = []\n        user_profile = self.example_user(\"othello\")\n        email3 = user_profile.email\n        user3 = user_profile\n        realm3 = user_profile.realm\n        stream = get_stream(\"multi_user_stream\", realm)\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            bulk_add_subscriptions(realm, [stream], [user_profile], acting_user=None)\n\n        add_event, add_peer_event = events\n\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [get_user(email3, realm3).id])\n        self.assertEqual(\n            set(add_event[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n            {user1.id, user2.id, user3.id, self.test_user.id},\n        )\n\n        # We don't send a peer_add event to othello\n        self.assertNotIn(user_profile.id, add_peer_event[\"users\"])\n        self.assertNotIn(self.example_user(\"polonius\").id, add_peer_event[\"users\"])\n        self.assert_length(add_peer_event[\"users\"], 11)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [user_profile.id])\n\n    def test_private_stream_subscription(self) -> None:\n        realm = get_realm(\"zulip\")\n\n        # Create a private stream with Hamlet subscribed\n        stream_name = \"private\"\n        stream = ensure_stream(realm, stream_name, invite_only=True, acting_user=None)\n\n        existing_user_profile = self.example_user(\"hamlet\")\n        bulk_add_subscriptions(realm, [stream], [existing_user_profile], acting_user=None)\n\n        # Now subscribe Cordelia to the stream, capturing events\n        user_profile = self.example_user(\"cordelia\")\n\n        with self.capture_send_event_calls(expected_num_events=3) as events:\n            bulk_add_subscriptions(realm, [stream], [user_profile], acting_user=None)\n\n        create_event, add_event, add_peer_event = events\n\n        self.assertEqual(create_event[\"event\"][\"type\"], \"stream\")\n        self.assertEqual(create_event[\"event\"][\"op\"], \"create\")\n        self.assertEqual(create_event[\"users\"], [user_profile.id])\n        self.assertEqual(create_event[\"event\"][\"streams\"][0][\"name\"], stream_name)\n\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [user_profile.id])\n        self.assertEqual(\n            set(add_event[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n            {user_profile.id, existing_user_profile.id},\n        )\n\n        # We don't send a peer_add event to othello, but we do send peer_add event to\n        # all realm admins.\n        self.assertNotIn(user_profile.id, add_peer_event[\"users\"])\n        self.assert_length(add_peer_event[\"users\"], 3)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [user_profile.id])\n\n        # Do not send stream creation event to realm admin users\n        # even if realm admin is subscribed to stream cause realm admin already get\n        # private stream creation event on stream creation.\n        new_stream = ensure_stream(realm, \"private stream\", invite_only=True, acting_user=None)\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            bulk_add_subscriptions(\n                realm, [new_stream], [self.example_user(\"iago\")], acting_user=None\n            )\n\n        # Note that since iago is an admin, he won't get a stream/create\n        # event here.\n        self.assert_length(events, 2)\n        add_event, add_peer_event = events\n\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [self.example_user(\"iago\").id])\n\n        self.assert_length(add_peer_event[\"users\"], 1)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [self.example_user(\"iago\").id])\n\n    def test_subscribe_to_stream_post_policy_admins_stream(self) -> None:\n        \"\"\"\n        Members can subscribe to streams where only admins can post\n        \"\"\"\n        member = self.example_user(\"AARON\")\n        stream = self.make_stream(\"stream1\")\n        do_change_stream_post_policy(stream, Stream.STREAM_POST_POLICY_ADMINS, acting_user=member)\n        result = self.common_subscribe_to_streams(member, [\"stream1\"])\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {member.email: [\"stream1\"]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n    def test_subscribe_to_stream_post_policy_restrict_new_members_stream(self) -> None:\n        \"\"\"\n        New members can subscribe to streams where they can not post\n        \"\"\"\n        new_member_email = self.nonreg_email(\"test\")\n        self.register(new_member_email, \"test\")\n        new_member = self.nonreg_user(\"test\")\n\n        do_set_realm_property(new_member.realm, \"waiting_period_threshold\", 10, acting_user=None)\n        self.assertTrue(new_member.is_provisional_member)\n\n        stream = self.make_stream(\"stream1\")\n        do_change_stream_post_policy(\n            stream, Stream.STREAM_POST_POLICY_RESTRICT_NEW_MEMBERS, acting_user=new_member\n        )\n        result = self.common_subscribe_to_streams(new_member, [\"stream1\"])\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {new_member.email: [\"stream1\"]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n    def test_subscribe_to_stream_post_policy_moderators_stream(self) -> None:\n        \"\"\"\n        Members can subscribe to streams where only admins and moderators can post\n        \"\"\"\n        member = self.example_user(\"AARON\")\n        stream = self.make_stream(\"stream1\")\n        # Make sure that we are testing this with full member which is just below the moderator\n        # in the role hierarchy.\n        self.assertFalse(member.is_provisional_member)\n        do_change_stream_post_policy(\n            stream, Stream.STREAM_POST_POLICY_MODERATORS, acting_user=member\n        )\n        result = self.common_subscribe_to_streams(member, [\"stream1\"])\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {member.email: [\"stream1\"]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n    def test_guest_user_subscribe(self) -> None:\n        \"\"\"Guest users cannot subscribe themselves to anything\"\"\"\n        guest_user = self.example_user(\"polonius\")\n        result = self.common_subscribe_to_streams(guest_user, [\"Denmark\"], allow_fail=True)\n        self.assert_json_error(result, \"Not allowed for guest users\")\n\n        # Verify the internal checks also block guest users.\n        stream = get_stream(\"Denmark\", guest_user.realm)\n        self.assertEqual(filter_stream_authorization(guest_user, [stream]), ([], [stream]))\n\n        stream = self.make_stream(\"private_stream\", invite_only=True)\n        result = self.common_subscribe_to_streams(guest_user, [\"private_stream\"], allow_fail=True)\n        self.assert_json_error(result, \"Not allowed for guest users\")\n        self.assertEqual(filter_stream_authorization(guest_user, [stream]), ([], [stream]))\n\n        web_public_stream = self.make_stream(\"web_public_stream\", is_web_public=True)\n        public_stream = self.make_stream(\"public_stream\", invite_only=False)\n        private_stream = self.make_stream(\"private_stream2\", invite_only=True)\n        # This test should be added as soon as the subscription endpoint allows\n        # guest users to subscribe to web-public streams. Although they are already\n        # authorized, the decorator in \"add_subscriptions_backend\" still needs to be\n        # deleted.\n        #\n        # result = self.common_subscribe_to_streams(guest_user, ['web_public_stream'],\n        #                                           is_web_public=True, allow_fail=True)\n        # self.assert_json_success(result)\n        streams_to_sub = [web_public_stream, public_stream, private_stream]\n        self.assertEqual(\n            filter_stream_authorization(guest_user, streams_to_sub),\n            ([web_public_stream], [public_stream, private_stream]),\n        )\n\n    def test_users_getting_add_peer_event(self) -> None:\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        streams_to_sub = [\"multi_user_stream\"]\n        othello = self.example_user(\"othello\")\n        cordelia = self.example_user(\"cordelia\")\n        iago = self.example_user(\"iago\")\n        orig_user_ids_to_subscribe = [self.test_user.id, othello.id]\n        self.common_subscribe_to_streams(\n            self.test_user,\n            streams_to_sub,\n            dict(principals=orjson.dumps(orig_user_ids_to_subscribe).decode()),\n        )\n\n        new_user_ids_to_subscribe = [iago.id, cordelia.id]\n        with self.capture_send_event_calls(expected_num_events=5) as events:\n            self.common_subscribe_to_streams(\n                self.test_user,\n                streams_to_sub,\n                dict(principals=orjson.dumps(new_user_ids_to_subscribe).decode()),\n            )\n\n        add_peer_events = [event for event in events if event[\"event\"].get(\"op\") == \"peer_add\"]\n        (add_peer_event,) = add_peer_events\n\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        event_sent_to_ids = add_peer_event[\"users\"]\n        for user_id in new_user_ids_to_subscribe:\n            # Make sure new users subscribed to stream is not in\n            # peer_add event recipient list\n            self.assertNotIn(user_id, event_sent_to_ids)\n        for old_user in orig_user_ids_to_subscribe:\n            # Check non-new users are in peer_add event recipient list.\n            self.assertIn(old_user, event_sent_to_ids)\n\n    def test_users_getting_remove_peer_event(self) -> None:\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        user1 = self.example_user(\"othello\")\n        user2 = self.example_user(\"cordelia\")\n        user3 = self.example_user(\"hamlet\")\n        user4 = self.example_user(\"iago\")\n        user5 = self.example_user(\"AARON\")\n        guest = self.example_user(\"polonius\")\n\n        realm = user1.realm\n\n        stream1 = self.make_stream(\"stream1\")\n        stream2 = self.make_stream(\"stream2\")\n        stream3 = self.make_stream(\"stream3\")\n        private = self.make_stream(\"private_stream\", invite_only=True)\n\n        self.subscribe(user1, \"stream1\")\n        self.subscribe(user2, \"stream1\")\n        self.subscribe(user3, \"stream1\")\n\n        self.subscribe(user2, \"stream2\")\n        self.subscribe(user2, \"stream3\")\n\n        self.subscribe(user1, \"private_stream\")\n        self.subscribe(user2, \"private_stream\")\n        self.subscribe(user3, \"private_stream\")\n\n        # Sends 3 peer-remove events and 2 unsubscribe events.\n        with self.capture_send_event_calls(expected_num_events=5) as events:\n            with self.assert_database_query_count(16):\n                with cache_tries_captured() as cache_count:\n                    bulk_remove_subscriptions(\n                        realm,\n                        [user1, user2],\n                        [stream1, stream2, stream3, private],\n                        acting_user=None,\n                    )\n\n        self.assert_length(cache_count, 3)\n\n        peer_events = [e for e in events if e[\"event\"].get(\"op\") == \"peer_remove\"]\n\n        # We only care about a subset of users when we inspect\n        # peer_remove events.\n        our_user_ids = {\n            user1.id,\n            user2.id,\n            user3.id,\n            user4.id,\n            user5.id,\n            guest.id,\n        }\n\n        notifications = []\n        for event in peer_events:\n            stream_ids = event[\"event\"][\"stream_ids\"]\n            stream_names = sorted(Stream.objects.get(id=stream_id).name for stream_id in stream_ids)\n            removed_user_ids = set(event[\"event\"][\"user_ids\"])\n            notified_user_ids = set(event[\"users\"]) & our_user_ids\n            notifications.append((\",\".join(stream_names), removed_user_ids, notified_user_ids))\n\n        notifications.sort(key=lambda tup: tup[0])\n\n        self.assertEqual(\n            notifications,\n            [\n                (\"private_stream\", {user1.id, user2.id}, {user3.id, user4.id}),\n                (\"stream1\", {user1.id, user2.id}, {user3.id, user4.id, user5.id}),\n                (\"stream2,stream3\", {user2.id}, {user1.id, user3.id, user4.id, user5.id}),\n            ],\n        )\n\n    def test_bulk_subscribe_MIT(self) -> None:\n        mit_user = self.mit_user(\"starnine\")\n        num_streams = 15\n\n        realm = get_realm(\"zephyr\")\n        stream_names = [f\"stream_{i}\" for i in range(num_streams)]\n        streams = [self.make_stream(stream_name, realm=realm) for stream_name in stream_names]\n\n        for stream in streams:\n            stream.is_in_zephyr_realm = True\n            stream.save()\n\n        # Verify that peer_event events are never sent in Zephyr\n        # realm. This does generate stream creation events from\n        # send_stream_creation_events_for_private_streams.\n        with self.capture_send_event_calls(expected_num_events=num_streams + 1) as events:\n            with self.assert_database_query_count(num_streams + 12):\n                self.common_subscribe_to_streams(\n                    mit_user,\n                    stream_names,\n                    dict(principals=orjson.dumps([mit_user.id]).decode()),\n                    subdomain=\"zephyr\",\n                )\n            # num_streams stream creation events:\n            self.assertEqual(\n                {(event[\"event\"][\"type\"], event[\"event\"][\"op\"]) for event in events[0:num_streams]},\n                {(\"stream\", \"create\")},\n            )\n            # Followed by one subscription event:\n            self.assertEqual(events[num_streams][\"event\"][\"type\"], \"subscription\")\n\n        with self.capture_send_event_calls(expected_num_events=1):\n            bulk_remove_subscriptions(\n                realm,\n                users=[mit_user],\n                streams=streams,\n                acting_user=None,\n            )\n\n    def test_subscribe_others_to_public_stream_in_zephyr_realm(self) -> None:\n        \"\"\"\n        Users cannot be subscribed to public streams by other users in zephyr realm.\n        \"\"\"\n        starnine = self.mit_user(\"starnine\")\n        espuser = self.mit_user(\"espuser\")\n\n        realm = get_realm(\"zephyr\")\n        stream = self.make_stream(\"stream_1\", realm=realm)\n        stream.is_in_zephyr_realm = True\n        stream.save()\n\n        result = self.common_subscribe_to_streams(\n            starnine,\n            [\"stream_1\"],\n            dict(principals=orjson.dumps([starnine.id, espuser.id]).decode()),\n            subdomain=\"zephyr\",\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            \"You can only invite other Zephyr mirroring users to private streams.\",\n            status_code=400,\n        )\n\n    def test_bulk_subscribe_many(self) -> None:\n        # Create a whole bunch of streams\n        streams = [f\"stream_{i}\" for i in range(30)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        desdemona = self.example_user(\"desdemona\")\n\n        test_users = [\n            desdemona,\n            self.example_user(\"cordelia\"),\n            self.example_user(\"hamlet\"),\n            self.example_user(\"othello\"),\n            self.example_user(\"iago\"),\n            self.example_user(\"prospero\"),\n        ]\n\n        # Subscribe out test users to some streams, including\n        # some that we may soon subscribe them to.\n        for stream_name in [\"Verona\", \"Denmark\", *streams[:10]]:\n            for user in test_users:\n                self.subscribe(user, stream_name)\n\n        # Now unsubscribe users from the first few streams,\n        # so they have to reactivate.\n        for stream_name in streams[:5]:\n            for user in test_users:\n                self.unsubscribe(user, stream_name)\n\n        test_user_ids = [user.id for user in test_users]\n\n        with self.assert_database_query_count(20):\n            with cache_tries_captured() as cache_tries:\n                with mock.patch(\"zerver.views.streams.send_messages_for_new_subscribers\"):\n                    self.common_subscribe_to_streams(\n                        desdemona,\n                        streams,\n                        dict(principals=orjson.dumps(test_user_ids).decode()),\n                    )\n\n        # The only known O(N) behavior here is that we call\n        # principal_to_user_profile for each of our users.\n        self.assert_length(cache_tries, 4)\n\n    def test_subscriptions_add_for_principal(self) -> None:\n        \"\"\"\n        You can subscribe other people to streams.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(\n            invitee.id, invitee.realm, invite_streams, policy_name=\"Public\"\n        )\n\n    def test_subscriptions_add_for_principal_legacy_emails(self) -> None:\n        invitee = self.example_user(\"iago\")\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(\n            invitee.email, invitee.realm, invite_streams, policy_name=\"Public\"\n        )\n\n    def test_subscriptions_add_for_principal_deactivated(self) -> None:\n        \"\"\"\n        You can't subscribe deactivated people to streams.\n        \"\"\"\n        target_profile = self.example_user(\"cordelia\")\n        post_data = dict(\n            principals=orjson.dumps([target_profile.id]).decode(),\n        )\n        self.common_subscribe_to_streams(self.test_user, \"Verona\", post_data)\n\n        do_deactivate_user(target_profile, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user, \"Denmark\", post_data, allow_fail=True\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{target_profile.id}'\",\n            status_code=403,\n        )\n\n    def test_subscriptions_add_for_principal_invite_only(self) -> None:\n        \"\"\"\n        You can subscribe other people to invite only streams.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(\n            invitee.id,\n            invitee.realm,\n            invite_streams,\n            invite_only=True,\n            policy_name=\"Private, protected history\",\n        )\n\n    def test_non_ascii_subscription_for_principal(self) -> None:\n        \"\"\"\n        You can subscribe other people to streams even if they containing\n        non-ASCII characters.\n        \"\"\"\n        iago = self.example_user(\"iago\")\n        self.assert_adding_subscriptions_for_principal(\n            iago.id, get_realm(\"zulip\"), [\"h\u00fcmb\u00fc\u01f5\"], policy_name=\"Public\"\n        )\n\n    def test_subscription_add_invalid_principal_legacy_emails(self) -> None:\n        \"\"\"\n        Calling subscribe on behalf of a principal that does not exist\n        should return a JSON error.\n        \"\"\"\n        invalid_principal = \"rosencrantz-and-guildenstern@zulip.com\"\n        invalid_principal_realm = get_realm(\"zulip\")\n        # verify that invalid_principal actually doesn't exist\n        with self.assertRaises(UserProfile.DoesNotExist):\n            get_user(invalid_principal, invalid_principal_realm)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            self.streams,\n            {\"principals\": orjson.dumps([invalid_principal]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{invalid_principal}'\",\n            status_code=403,\n        )\n\n    def test_subscription_add_invalid_principal(self) -> None:\n        invalid_principal = 999\n        invalid_principal_realm = get_realm(\"zulip\")\n        with self.assertRaises(UserProfile.DoesNotExist):\n            get_user_profile_by_id_in_realm(invalid_principal, invalid_principal_realm)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            self.streams,\n            {\"principals\": orjson.dumps([invalid_principal]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{invalid_principal}'\",\n            status_code=403,\n        )\n\n    def test_subscription_add_principal_other_realm(self) -> None:\n        \"\"\"\n        Calling subscribe on behalf of a principal in another realm\n        should return a JSON error.\n        \"\"\"\n        profile = self.mit_user(\"starnine\")\n        principal = profile.id\n        # verify that principal exists (thus, the reason for the error is the cross-realming)\n        self.assertIsInstance(profile, UserProfile)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            self.streams,\n            {\"principals\": orjson.dumps([principal]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{principal}'\",\n            status_code=403,\n        )\n\n    def helper_check_subs_before_and_after_remove(\n        self,\n        subscriptions: List[str],\n        json_dict: Dict[str, Any],\n        email: str,\n        new_subs: List[str],\n        realm: Realm,\n    ) -> None:\n        \"\"\"\n        Check result of removing subscriptions.\n\n        Unlike adding subscriptions, you can only remove subscriptions\n        for yourself, so the result format is different.\n\n        {\"msg\": \"\",\n         \"removed\": [\"Denmark\", \"Scotland\", \"Verona\"],\n         \"not_removed\": [\"Rome\"], \"result\": \"success\"}\n        \"\"\"\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\", {\"subscriptions\": orjson.dumps(subscriptions).decode()}\n        )\n        json = self.assert_json_success(result)\n        for key, val in json_dict.items():\n            # we don't care about the order of the items\n            self.assertEqual(sorted(val), sorted(json[key]))\n        user = get_user(email, realm)\n        new_streams = self.get_streams(user)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_remove(self) -> None:\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions should successfully remove streams,\n        and should determine which were removed vs which weren't subscribed to.\n        We cannot randomly generate stream names because the remove code\n        verifies whether streams exist.\n        \"\"\"\n        self.assertGreaterEqual(len(self.streams), 2)\n        streams_to_remove = self.streams[1:]\n        not_subbed = []\n        for stream in Stream.objects.filter(realm=get_realm(\"zulip\")):\n            if stream.name not in self.streams:\n                not_subbed.append(stream.name)\n        random.shuffle(not_subbed)\n        self.assertNotEqual(len(not_subbed), 0)  # necessary for full test coverage\n        try_to_remove = not_subbed[:3]  # attempt to remove up to 3 streams not already subbed to\n        streams_to_remove.extend(try_to_remove)\n        self.helper_check_subs_before_and_after_remove(\n            streams_to_remove,\n            {\"removed\": self.streams[1:], \"not_removed\": try_to_remove},\n            self.test_email,\n            [self.streams[0]],\n            self.test_realm,\n        )\n\n    def test_subscriptions_remove_fake_stream(self) -> None:\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions on a stream that doesn't exist\n        should return a JSON error.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        # pick only one fake stream, to make checking the error message easy\n        streams_to_remove = random_streams[:1]\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": orjson.dumps(streams_to_remove).decode()},\n        )\n        self.assert_json_error(result, f\"Stream(s) ({random_streams[0]}) do not exist\")\n\n    def helper_subscriptions_exists(\n        self, stream: str, expect_success: bool, subscribed: bool\n    ) -> None:\n        \"\"\"\n        Call /json/subscriptions/exists on a stream and expect a certain result.\n        \"\"\"\n        result = self.client_post(\"/json/subscriptions/exists\", {\"stream\": stream})\n        if expect_success:\n            json = self.assert_json_success(result)\n        else:\n            self.assertEqual(result.status_code, 404)\n            json = result.json()\n        if subscribed:\n            self.assertIn(\"subscribed\", json)\n            self.assertEqual(json[\"subscribed\"], subscribed)\n\n    def test_successful_subscriptions_exists_subbed(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are subbed\n        should return that it exists and that you are subbed.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(self.streams[0], True, True)\n\n    def test_successful_subscriptions_exists_not_subbed(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are not\n        subbed should return that it exists and that you are not subbed.\n        \"\"\"\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.test_realm)]\n        streams_not_subbed = list(set(all_stream_names) - set(self.streams))\n        self.assertNotEqual(len(streams_not_subbed), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(streams_not_subbed[0], True, False)\n\n    def test_subscriptions_does_not_exist(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream that doesn't exist should\n        return that it doesn't exist.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(random_streams[0], False, False)\n\n    def test_subscriptions_exist_invalid_name(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid stream name is the empty string\n        invalid_stream_name = \"\"\n        result = self.client_post(\"/json/subscriptions/exists\", {\"stream\": invalid_stream_name})\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n\n    def test_existing_subscriptions_autosubscription(self) -> None:\n        \"\"\"\n        Call /json/subscriptions/exist on an existing stream and autosubscribe to it.\n        \"\"\"\n        stream_name = \"new_public_stream\"\n        cordelia = self.example_user(\"cordelia\")\n        self.common_subscribe_to_streams(cordelia, [stream_name], invite_only=False)\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"false\"}\n        )\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribed\", response_dict)\n        self.assertFalse(response_dict[\"subscribed\"])\n\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"true\"}\n        )\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribed\", response_dict)\n        self.assertTrue(response_dict)\n\n    def test_existing_subscriptions_autosubscription_private_stream(self) -> None:\n        \"\"\"Call /json/subscriptions/exist on an existing private stream with\n        autosubscribe should fail.\n        \"\"\"\n        stream_name = \"Saxony\"\n        cordelia = self.example_user(\"cordelia\")\n        self.common_subscribe_to_streams(cordelia, [stream_name], invite_only=True)\n        stream = get_stream(stream_name, self.test_realm)\n\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"true\"}\n        )\n        # We can't see invite-only streams here\n        self.assert_json_error(result, \"Invalid stream name 'Saxony'\", status_code=404)\n        # Importantly, we are not now subscribed\n        self.assertEqual(num_subscribers_for_stream_id(stream.id), 1)\n\n        # A user who is subscribed still sees the stream exists\n        self.login(\"cordelia\")\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"false\"}\n        )\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribed\", response_dict)\n        self.assertTrue(response_dict)\n\n    def get_subscription(self, user_profile: UserProfile, stream_name: str) -> Subscription:\n        stream = get_stream(stream_name, self.test_realm)\n        return Subscription.objects.get(\n            user_profile=user_profile,\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=stream.id,\n        )\n\n    def test_subscriptions_add_notification_default_none(self) -> None:\n        \"\"\"\n        When creating a subscription, the desktop, push, and audible notification\n        settings for that stream are none. A value of None means to use the values\n        inherited from the global notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"iago\")\n        invitee_user_id = user_profile.id\n        invitee_realm = user_profile.realm\n        user_profile.enable_stream_desktop_notifications = True\n        user_profile.enable_stream_push_notifications = True\n        user_profile.enable_stream_audible_notifications = True\n        user_profile.enable_stream_email_notifications = True\n        user_profile.save()\n        current_stream = self.get_streams(user_profile)[0]\n        invite_streams = self.make_random_stream_names([current_stream])\n        self.assert_adding_subscriptions_for_principal(\n            invitee_user_id, invitee_realm, invite_streams, policy_name=\"Public\"\n        )\n        subscription = self.get_subscription(user_profile, invite_streams[0])\n\n        with mock.patch(\"zerver.models.Recipient.__repr__\", return_value=\"recip\"):\n            self.assertEqual(\n                repr(subscription),\n                \"<Subscription: \"\n                f\"<UserProfile: {user_profile.email} {user_profile.realm!r}> -> recip>\",\n            )\n\n        self.assertIsNone(subscription.desktop_notifications)\n        self.assertIsNone(subscription.push_notifications)\n        self.assertIsNone(subscription.audible_notifications)\n        self.assertIsNone(subscription.email_notifications)\n\n    def test_mark_messages_as_unread_on_unsubscribe(self) -> None:\n        realm = get_realm(\"zulip\")\n        user = self.example_user(\"iago\")\n        random_user = self.example_user(\"hamlet\")\n        stream1 = ensure_stream(realm, \"stream1\", invite_only=False, acting_user=None)\n        stream2 = ensure_stream(realm, \"stream2\", invite_only=False, acting_user=None)\n        private = ensure_stream(realm, \"private_stream\", invite_only=True, acting_user=None)\n\n        self.subscribe(user, \"stream1\")\n        self.subscribe(user, \"stream2\")\n        self.subscribe(user, \"private_stream\")\n        self.subscribe(random_user, \"stream1\")\n        self.subscribe(random_user, \"stream2\")\n        self.subscribe(random_user, \"private_stream\")\n\n        self.send_stream_message(random_user, \"stream1\", \"test\", \"test\")\n        self.send_stream_message(random_user, \"stream2\", \"test\", \"test\")\n        self.send_stream_message(random_user, \"private_stream\", \"test\", \"test\")\n\n        def get_unread_stream_data() -> List[UnreadStreamInfo]:\n            raw_unread_data = get_raw_unread_data(user)\n            aggregated_data = aggregate_unread_data(raw_unread_data)\n            return aggregated_data[\"streams\"]\n\n        result = get_unread_stream_data()\n        self.assert_length(result, 3)\n        self.assertEqual(result[0][\"stream_id\"], stream1.id)\n        self.assertEqual(result[1][\"stream_id\"], stream2.id)\n        self.assertEqual(result[2][\"stream_id\"], private.id)\n\n        # Unsubscribing should mark all the messages in stream2 as read\n        self.unsubscribe(user, \"stream2\")\n        self.unsubscribe(user, \"private_stream\")\n\n        self.subscribe(user, \"stream2\")\n        self.subscribe(user, \"private_stream\")\n        result = get_unread_stream_data()\n        self.assert_length(result, 1)\n        self.assertEqual(result[0][\"stream_id\"], stream1.id)\n\n    def test_gather_subscriptions_excludes_deactivated_streams(self) -> None:\n        \"\"\"\n        Check that gather_subscriptions_helper does not include deactivated streams in its\n        results.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        admin_user = self.example_user(\"iago\")\n        non_admin_user = self.example_user(\"cordelia\")\n\n        self.login_user(admin_user)\n\n        for stream_name in [\"stream1\", \"stream2\", \"stream3\"]:\n            self.make_stream(stream_name, realm=realm, invite_only=False)\n            self.subscribe(admin_user, stream_name)\n            self.subscribe(non_admin_user, stream_name)\n            self.subscribe(self.example_user(\"othello\"), stream_name)\n\n        def archive_stream(stream_name: str) -> None:\n            stream_id = get_stream(stream_name, realm).id\n            result = self.client_delete(f\"/json/streams/{stream_id}\")\n            self.assert_json_success(result)\n\n        # Deleted/deactivated stream should not be returned in the helper results\n        admin_before_delete = gather_subscriptions_helper(admin_user)\n        non_admin_before_delete = gather_subscriptions_helper(non_admin_user)\n\n        # Delete our stream\n        archive_stream(\"stream1\")\n\n        # Get subs after delete\n        admin_after_delete = gather_subscriptions_helper(admin_user)\n        non_admin_after_delete = gather_subscriptions_helper(non_admin_user)\n\n        # Compare results - should be 1 stream less\n        self.assertTrue(\n            len(admin_before_delete.subscriptions) == len(admin_after_delete.subscriptions) + 1,\n            \"Expected exactly 1 less stream from gather_subscriptions_helper\",\n        )\n        self.assertTrue(\n            len(non_admin_before_delete.subscriptions)\n            == len(non_admin_after_delete.subscriptions) + 1,\n            \"Expected exactly 1 less stream from gather_subscriptions_helper\",\n        )\n\n    def test_validate_user_access_to_subscribers_helper(self) -> None:\n        \"\"\"\n        Ensure the validate_user_access_to_subscribers_helper is properly raising\n        ValidationError on missing user, user not-in-realm.\n        \"\"\"\n        user_profile = self.example_user(\"othello\")\n        realm_name = \"no_othello_allowed\"\n        realm = do_create_realm(realm_name, \"Everyone but Othello is allowed\")\n        stream_dict = {\n            \"name\": \"publicstream\",\n            \"description\": \"Public stream with public history\",\n            \"realm_id\": realm.id,\n        }\n\n        # For this test to work, othello can't be in the no_othello_here realm\n        self.assertNotEqual(\n            user_profile.realm.id, realm.id, \"Expected othello user to not be in this realm.\"\n        )\n\n        # This should result in missing user\n        with self.assertRaises(ValidationError):\n            validate_user_access_to_subscribers_helper(None, stream_dict, lambda user_profile: True)\n\n        # This should result in user not in realm\n        with self.assertRaises(ValidationError):\n            validate_user_access_to_subscribers_helper(\n                user_profile, stream_dict, lambda user_profile: True\n            )\n\n    def test_subscriptions_query_count(self) -> None:\n        \"\"\"\n        Test database query count when creating stream with api/v1/users/me/subscriptions.\n        \"\"\"\n        user1 = self.example_user(\"cordelia\")\n        user2 = self.example_user(\"iago\")\n        new_streams = [\n            \"query_count_stream_1\",\n            \"query_count_stream_2\",\n            \"query_count_stream_3\",\n        ]\n\n        # Test creating a public stream when realm does not have a notification stream.\n        with self.assert_database_query_count(36):\n            self.common_subscribe_to_streams(\n                self.test_user,\n                [new_streams[0]],\n                dict(principals=orjson.dumps([user1.id, user2.id]).decode()),\n            )\n\n        # Test creating private stream.\n        with self.assert_database_query_count(35):\n            self.common_subscribe_to_streams(\n                self.test_user,\n                [new_streams[1]],\n                dict(principals=orjson.dumps([user1.id, user2.id]).decode()),\n                invite_only=True,\n            )\n\n        # Test creating a public stream with announce when realm has a notification stream.\n        notifications_stream = get_stream(self.streams[0], self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n        with self.assert_database_query_count(44):\n            self.common_subscribe_to_streams(\n                self.test_user,\n                [new_streams[2]],\n                dict(\n                    announce=\"true\",\n                    principals=orjson.dumps([user1.id, user2.id]).decode(),\n                ),\n            )\n\n\nclass GetStreamsTest(ZulipTestCase):\n    def test_streams_api_for_bot_owners(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        test_bot = self.create_test_bot(\"foo\", hamlet)\n        assert test_bot is not None\n        realm = get_realm(\"zulip\")\n        self.login_user(hamlet)\n\n        # Check it correctly lists the bot owner's subs with\n        # include_owner_subscribed=true\n        filters = dict(\n            include_owner_subscribed=\"true\",\n            include_public=\"false\",\n            include_subscribed=\"false\",\n        )\n        result = self.api_get(test_bot, \"/api/v1/streams\", filters)\n        owner_subs = self.api_get(hamlet, \"/api/v1/users/me/subscriptions\")\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        self.assert_json_success(owner_subs)\n        owner_subs_json = orjson.loads(owner_subs.content)\n\n        self.assertEqual(\n            sorted(s[\"name\"] for s in json[\"streams\"]),\n            sorted(s[\"name\"] for s in owner_subs_json[\"subscriptions\"]),\n        )\n\n        # Check it correctly lists the bot owner's subs and the\n        # bot's subs\n        self.subscribe(test_bot, \"Scotland\")\n        filters = dict(\n            include_owner_subscribed=\"true\",\n            include_public=\"false\",\n            include_subscribed=\"true\",\n        )\n        result = self.api_get(test_bot, \"/api/v1/streams\", filters)\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        actual = sorted(s[\"name\"] for s in json[\"streams\"])\n        expected = [s[\"name\"] for s in owner_subs_json[\"subscriptions\"]]\n        expected.append(\"Scotland\")\n        expected.sort()\n\n        self.assertEqual(actual, expected)\n\n        # Check it correctly lists the bot owner's subs + all public streams\n        self.make_stream(\"private_stream\", realm=realm, invite_only=True)\n        self.subscribe(test_bot, \"private_stream\")\n        result = self.api_get(\n            test_bot,\n            \"/api/v1/streams\",\n            {\n                \"include_owner_subscribed\": \"true\",\n                \"include_public\": \"true\",\n                \"include_subscribed\": \"false\",\n            },\n        )\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        actual = sorted(s[\"name\"] for s in json[\"streams\"])\n        expected = [s[\"name\"] for s in owner_subs_json[\"subscriptions\"]]\n        expected.extend([\"Rome\", \"Venice\", \"Scotland\"])\n        expected.sort()\n\n        self.assertEqual(actual, expected)\n\n        # Check it correctly lists the bot owner's subs + all public streams +\n        # the bot's subs\n        result = self.api_get(\n            test_bot,\n            \"/api/v1/streams\",\n            {\n                \"include_owner_subscribed\": \"true\",\n                \"include_public\": \"true\",\n                \"include_subscribed\": \"true\",\n            },\n        )\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        actual = sorted(s[\"name\"] for s in json[\"streams\"])\n        expected = [s[\"name\"] for s in owner_subs_json[\"subscriptions\"]]\n        expected.extend([\"Rome\", \"Venice\", \"Scotland\", \"private_stream\"])\n        expected.sort()\n\n        self.assertEqual(actual, expected)\n\n    def test_all_active_streams_api(self) -> None:\n        url = \"/api/v1/streams\"\n        data = {\"include_all_active\": \"true\"}\n\n        # Check non-superuser can't use include_all_active\n        normal_user = self.example_user(\"cordelia\")\n        result = self.api_get(normal_user, url, data)\n        self.assertEqual(result.status_code, 400)\n\n        # Realm admin users can see all active streams.\n        admin_user = self.example_user(\"iago\")\n        self.assertTrue(admin_user.is_realm_admin)\n\n        result = self.api_get(admin_user, url, data)\n        json = self.assert_json_success(result)\n\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        stream_names = {s[\"name\"] for s in json[\"streams\"]}\n\n        self.assertEqual(\n            stream_names,\n            {\"Venice\", \"Denmark\", \"Scotland\", \"Verona\", \"Rome\", \"core team\"},\n        )\n\n    def test_public_streams_api(self) -> None:\n        \"\"\"\n        Ensure that the query we use to get public streams successfully returns\n        a list of streams\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        realm = get_realm(\"zulip\")\n        self.login_user(user)\n\n        # Check it correctly lists the user's subs with include_public=false\n        result = self.api_get(user, \"/api/v1/streams\", {\"include_public\": \"false\"})\n        result2 = self.api_get(user, \"/api/v1/users/me/subscriptions\")\n\n        json = self.assert_json_success(result)\n\n        self.assertIn(\"streams\", json)\n\n        self.assertIsInstance(json[\"streams\"], list)\n\n        self.assert_json_success(result2)\n        json2 = orjson.loads(result2.content)\n\n        self.assertEqual(\n            sorted(s[\"name\"] for s in json[\"streams\"]),\n            sorted(s[\"name\"] for s in json2[\"subscriptions\"]),\n        )\n\n        # Check it correctly lists all public streams with include_subscribed=false\n        filters = dict(include_public=\"true\", include_subscribed=\"false\")\n        result = self.api_get(user, \"/api/v1/streams\", filters)\n        json = self.assert_json_success(result)\n        all_streams = [\n            stream.name for stream in Stream.objects.filter(realm=realm, invite_only=False)\n        ]\n        self.assertEqual(sorted(s[\"name\"] for s in json[\"streams\"]), sorted(all_streams))\n\n    def test_get_single_stream_api(self) -> None:\n        self.login(\"hamlet\")\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"stream\"][\"name\"], \"Denmark\")\n        self.assertEqual(json[\"stream\"][\"stream_id\"], denmark_stream.id)\n\n        result = self.client_get(\"/json/streams/9999\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        private_stream = self.make_stream(\"private_stream\", invite_only=True)\n        self.subscribe(self.example_user(\"cordelia\"), \"private_stream\")\n\n        # Non-admins cannot access unsubscribed private streams.\n        result = self.client_get(f\"/json/streams/{private_stream.id}\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.login(\"iago\")\n        result = self.client_get(f\"/json/streams/{private_stream.id}\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"stream\"][\"name\"], \"private_stream\")\n        self.assertEqual(json[\"stream\"][\"stream_id\"], private_stream.id)\n\n        self.login(\"cordelia\")\n        result = self.client_get(f\"/json/streams/{private_stream.id}\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"stream\"][\"name\"], \"private_stream\")\n        self.assertEqual(json[\"stream\"][\"stream_id\"], private_stream.id)\n\n    def test_get_stream_email_address(self) -> None:\n        self.login(\"hamlet\")\n        hamlet = self.example_user(\"hamlet\")\n        iago = self.example_user(\"iago\")\n        polonius = self.example_user(\"polonius\")\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        denmark_email = encode_email_address_helper(\n            denmark_stream.name, denmark_stream.email_token, show_sender=True\n        )\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        self.login(\"polonius\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.subscribe(polonius, \"Denmark\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        do_change_stream_permission(\n            denmark_stream,\n            invite_only=True,\n            history_public_to_subscribers=True,\n            is_web_public=False,\n            acting_user=iago,\n        )\n        self.login(\"hamlet\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        self.unsubscribe(hamlet, \"Denmark\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.login(\"iago\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        self.unsubscribe(iago, \"Denmark\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n\nclass StreamIdTest(ZulipTestCase):\n    def test_get_stream_id(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        stream = gather_subscriptions(user)[0][0]\n        result = self.client_get(\"/json/get_stream_id\", {\"stream\": stream[\"name\"]})\n        response_dict = self.assert_json_success(result)\n        self.assertEqual(response_dict[\"stream_id\"], stream[\"stream_id\"])\n\n    def test_get_stream_id_wrong_name(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.client_get(\"/json/get_stream_id\", {\"stream\": \"wrongname\"})\n        self.assert_json_error(result, \"Invalid stream name 'wrongname'\")\n\n\nclass InviteOnlyStreamTest(ZulipTestCase):\n    def test_must_be_subbed_to_send(self) -> None:\n        \"\"\"\n        If you try to send a message to an invite-only stream to which\n        you aren't subscribed, you'll get a 400.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        # Create Saxony as an invite-only stream.\n        self.assert_json_success(\n            self.common_subscribe_to_streams(user, [\"Saxony\"], invite_only=True)\n        )\n\n        cordelia = self.example_user(\"cordelia\")\n        with self.assertRaises(JsonableError):\n            self.send_stream_message(cordelia, \"Saxony\")\n\n    def test_list_respects_invite_only_bit(self) -> None:\n        \"\"\"\n        Make sure that /api/v1/users/me/subscriptions properly returns\n        the invite-only bit for streams that are invite-only\n        \"\"\"\n\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        self.common_subscribe_to_streams(user, [\"Saxony\"], invite_only=True)\n        self.common_subscribe_to_streams(user, [\"Normandy\"], invite_only=False)\n        result = self.api_get(user, \"/api/v1/users/me/subscriptions\")\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscriptions\", response_dict)\n        for sub in response_dict[\"subscriptions\"]:\n            if sub[\"name\"] == \"Normandy\":\n                self.assertEqual(\n                    sub[\"invite_only\"], False, \"Normandy was mistakenly marked private\"\n                )\n            if sub[\"name\"] == \"Saxony\":\n                self.assertEqual(sub[\"invite_only\"], True, \"Saxony was not properly marked private\")\n\n    def test_inviteonly(self) -> None:\n        # Creating an invite-only stream is allowed\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        stream_name = \"Saxony\"\n\n        result = self.common_subscribe_to_streams(hamlet, [stream_name], invite_only=True)\n\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {hamlet.email: [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Subscribing oneself to an invite-only stream is not allowed\n        self.login_user(othello)\n        result = self.common_subscribe_to_streams(othello, [stream_name], allow_fail=True)\n        self.assert_json_error(result, \"Unable to access stream (Saxony).\")\n\n        # authorization_errors_fatal=False works\n        self.login_user(othello)\n        result = self.common_subscribe_to_streams(\n            othello,\n            [stream_name],\n            extra_post_data={\"authorization_errors_fatal\": orjson.dumps(False).decode()},\n        )\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"unauthorized\"], [stream_name])\n        self.assertEqual(json[\"subscribed\"], {})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Inviting another user to an invite-only stream is allowed\n        self.login_user(hamlet)\n        result = self.common_subscribe_to_streams(\n            hamlet,\n            [stream_name],\n            extra_post_data={\"principals\": orjson.dumps([othello.id]).decode()},\n        )\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {othello.email: [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Make sure both users are subscribed to this stream\n        stream_id = get_stream(stream_name, hamlet.realm).id\n        result = self.api_get(hamlet, f\"/api/v1/streams/{stream_id}/members\")\n        json = self.assert_json_success(result)\n\n        self.assertTrue(othello.id in json[\"subscribers\"])\n        self.assertTrue(hamlet.id in json[\"subscribers\"])\n\n\nclass GetSubscribersTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.login_user(self.user_profile)\n\n    def verify_sub_fields(self, sub_data: SubscriptionInfo) -> None:\n        other_fields = {\n            \"is_announcement_only\",\n            \"in_home_view\",\n            \"stream_id\",\n            \"stream_weekly_traffic\",\n            \"subscribers\",\n        }\n\n        expected_fields = set(Stream.API_FIELDS) | set(Subscription.API_FIELDS) | other_fields\n        expected_fields -= {\"id\"}\n\n        for lst in [sub_data.subscriptions, sub_data.unsubscribed]:\n            for sub in lst:\n                self.assertEqual(set(sub), expected_fields)\n\n        other_fields = {\n            \"is_announcement_only\",\n            \"stream_id\",\n            \"stream_weekly_traffic\",\n            \"subscribers\",\n        }\n\n        expected_fields = set(Stream.API_FIELDS) | other_fields\n        expected_fields -= {\"id\"}\n\n        for never_sub in sub_data.never_subscribed:\n            self.assertEqual(set(never_sub), expected_fields)\n\n    def assert_user_got_subscription_notification(\n        self, user: UserProfile, expected_msg: str\n    ) -> None:\n        # verify that the user was sent a message informing them about the subscription\n        realm = user.realm\n        msg = most_recent_message(user)\n        self.assertEqual(msg.recipient.type, msg.recipient.PERSONAL)\n        self.assertEqual(msg.sender_id, self.notification_bot(realm).id)\n\n        def non_ws(s: str) -> str:\n            return s.replace(\"\\n\", \"\").replace(\" \", \"\")\n\n        self.assertEqual(non_ws(msg.content), non_ws(expected_msg))\n\n    def check_well_formed_result(\n        self, result: Dict[str, Any], stream_name: str, realm: Realm\n    ) -> None:\n        \"\"\"\n        A successful call to get_subscribers returns the list of subscribers in\n        the form:\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"subscribers\": [hamlet_user.id, prospero_user.id]}\n        \"\"\"\n        self.assertIn(\"subscribers\", result)\n        self.assertIsInstance(result[\"subscribers\"], list)\n        true_subscribers = [\n            user_profile.id for user_profile in self.users_subscribed_to_stream(stream_name, realm)\n        ]\n        self.assertEqual(sorted(result[\"subscribers\"]), sorted(true_subscribers))\n\n    def make_subscriber_request(\n        self, stream_id: int, user: Optional[UserProfile] = None\n    ) -> \"TestHttpResponse\":\n        if user is None:\n            user = self.user_profile\n        return self.api_get(user, f\"/api/v1/streams/{stream_id}/members\")\n\n    def make_successful_subscriber_request(self, stream_name: str) -> None:\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        result = self.make_subscriber_request(stream_id)\n        response_dict = self.assert_json_success(result)\n        self.check_well_formed_result(response_dict, stream_name, self.user_profile.realm)\n\n    def test_subscriber(self) -> None:\n        \"\"\"\n        get_subscribers returns the list of subscribers.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0][\"name\"]\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_gather_subscriptions(self) -> None:\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n\n        (We also use this test to verify subscription notifications to\n        folks who get subscribed to streams.)\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        othello = self.example_user(\"othello\")\n        polonius = self.example_user(\"polonius\")\n\n        streams = [f\"stream_{i}\" for i in range(10)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        users_to_subscribe = [\n            self.user_profile.id,\n            othello.id,\n            cordelia.id,\n            polonius.id,\n        ]\n\n        with self.assert_database_query_count(47):\n            self.common_subscribe_to_streams(\n                self.user_profile,\n                streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            )\n\n        msg = f\"\"\"\n            @**King Hamlet|{hamlet.id}** subscribed you to the following streams:\n\n            * #**stream_0**\n            * #**stream_1**\n            * #**stream_2**\n            * #**stream_3**\n            * #**stream_4**\n            * #**stream_5**\n            * #**stream_6**\n            * #**stream_7**\n            * #**stream_8**\n            * #**stream_9**\n            \"\"\"\n\n        for user in [cordelia, othello, polonius]:\n            self.assert_user_got_subscription_notification(user, msg)\n\n        # Subscribe ourself first.\n        self.common_subscribe_to_streams(\n            self.user_profile,\n            [\"stream_invite_only_1\"],\n            dict(principals=orjson.dumps([self.user_profile.id]).decode()),\n            invite_only=True,\n        )\n\n        # Now add in other users, and this should trigger messages\n        # to notify the user.\n        self.common_subscribe_to_streams(\n            self.user_profile,\n            [\"stream_invite_only_1\"],\n            dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            invite_only=True,\n        )\n\n        msg = f\"\"\"\n            @**King Hamlet|{hamlet.id}** subscribed you to the stream #**stream_invite_only_1**.\n            \"\"\"\n        for user in [cordelia, othello, polonius]:\n            self.assert_user_got_subscription_notification(user, msg)\n\n        with self.assert_database_query_count(4):\n            subscribed_streams, _ = gather_subscriptions(\n                self.user_profile, include_subscribers=True\n            )\n        self.assertGreaterEqual(len(subscribed_streams), 11)\n        for sub in subscribed_streams:\n            if not sub[\"name\"].startswith(\"stream_\"):\n                continue\n            self.assert_length(sub[\"subscribers\"], len(users_to_subscribe))\n\n    def test_never_subscribed_streams(self) -> None:\n        \"\"\"\n        Check never_subscribed streams are fetched correctly and not include invite_only streams,\n        or invite_only and public streams to guest users.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        users_to_subscribe = [\n            self.example_user(\"othello\").id,\n            self.example_user(\"cordelia\").id,\n        ]\n\n        public_streams = [\n            \"test_stream_public_1\",\n            \"test_stream_public_2\",\n            \"test_stream_public_3\",\n            \"test_stream_public_4\",\n            \"test_stream_public_5\",\n        ]\n\n        private_streams = [\n            \"test_stream_invite_only_1\",\n            \"test_stream_invite_only_2\",\n        ]\n\n        web_public_streams = [\n            \"test_stream_web_public_1\",\n            \"test_stream_web_public_2\",\n        ]\n\n        def create_public_streams() -> None:\n            for stream_name in public_streams:\n                self.make_stream(stream_name, realm=realm)\n\n            self.common_subscribe_to_streams(\n                self.user_profile,\n                public_streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            )\n\n        create_public_streams()\n\n        def create_web_public_streams() -> None:\n            for stream_name in web_public_streams:\n                self.make_stream(stream_name, realm=realm, is_web_public=True)\n\n            ret = self.common_subscribe_to_streams(\n                self.user_profile,\n                web_public_streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            )\n            self.assert_json_success(ret)\n\n        create_web_public_streams()\n\n        def create_private_streams() -> None:\n            self.common_subscribe_to_streams(\n                self.user_profile,\n                private_streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n                invite_only=True,\n            )\n\n        create_private_streams()\n\n        def get_never_subscribed() -> List[NeverSubscribedStreamDict]:\n            with self.assert_database_query_count(4):\n                sub_data = gather_subscriptions_helper(self.user_profile)\n                self.verify_sub_fields(sub_data)\n            never_subscribed = sub_data.never_subscribed\n\n            # Ignore old streams.\n            never_subscribed = [dct for dct in never_subscribed if dct[\"name\"].startswith(\"test_\")]\n            return never_subscribed\n\n        never_subscribed = get_never_subscribed()\n\n        # Invite only stream should not be there in never_subscribed streams\n        self.assert_length(never_subscribed, len(public_streams) + len(web_public_streams))\n        for stream_dict in never_subscribed:\n            name = stream_dict[\"name\"]\n            self.assertFalse(\"invite_only\" in name)\n            self.assert_length(stream_dict[\"subscribers\"], len(users_to_subscribe))\n\n        # Send private stream subscribers to all realm admins.\n        def test_admin_case() -> None:\n            self.user_profile.role = UserProfile.ROLE_REALM_ADMINISTRATOR\n            # Test realm admins can get never subscribed private stream's subscribers.\n            never_subscribed = get_never_subscribed()\n\n            self.assertEqual(\n                len(never_subscribed),\n                len(public_streams) + len(private_streams) + len(web_public_streams),\n            )\n            for stream_dict in never_subscribed:\n                self.assert_length(stream_dict[\"subscribers\"], len(users_to_subscribe))\n\n        test_admin_case()\n\n        def test_guest_user_case() -> None:\n            self.user_profile.role = UserProfile.ROLE_GUEST\n            helper_result = gather_subscriptions_helper(self.user_profile)\n            self.verify_sub_fields(helper_result)\n            sub = helper_result.subscriptions\n            unsub = helper_result.unsubscribed\n            never_sub = helper_result.never_subscribed\n\n            # It's +1 because of the stream Rome.\n            self.assert_length(never_sub, len(web_public_streams) + 1)\n            sub_ids = [stream[\"stream_id\"] for stream in sub]\n            unsub_ids = [stream[\"stream_id\"] for stream in unsub]\n\n            for stream_dict in never_sub:\n                self.assertTrue(stream_dict[\"is_web_public\"])\n                self.assertTrue(stream_dict[\"stream_id\"] not in sub_ids)\n                self.assertTrue(stream_dict[\"stream_id\"] not in unsub_ids)\n\n                # The Rome stream has is_web_public=True, with default\n                # subscribers not set up by this test, so we do the\n                # following check only for the streams we created.\n                if stream_dict[\"name\"] in web_public_streams:\n                    self.assert_length(stream_dict[\"subscribers\"], len(users_to_subscribe))\n\n        test_guest_user_case()\n\n    def test_gather_subscribed_streams_for_guest_user(self) -> None:\n        guest_user = self.example_user(\"polonius\")\n\n        stream_name_sub = \"public_stream_1\"\n        self.make_stream(stream_name_sub, realm=get_realm(\"zulip\"))\n        self.subscribe(guest_user, stream_name_sub)\n\n        stream_name_unsub = \"public_stream_2\"\n        self.make_stream(stream_name_unsub, realm=get_realm(\"zulip\"))\n        self.subscribe(guest_user, stream_name_unsub)\n        self.unsubscribe(guest_user, stream_name_unsub)\n\n        stream_name_never_sub = \"public_stream_3\"\n        self.make_stream(stream_name_never_sub, realm=get_realm(\"zulip\"))\n\n        normal_user = self.example_user(\"aaron\")\n        self.subscribe(normal_user, stream_name_sub)\n        self.subscribe(normal_user, stream_name_unsub)\n        self.subscribe(normal_user, stream_name_unsub)\n\n        helper_result = gather_subscriptions_helper(guest_user)\n        self.verify_sub_fields(helper_result)\n        subs = helper_result.subscriptions\n        neversubs = helper_result.never_subscribed\n\n        # Guest users get info about subscribed public stream's subscribers\n        expected_stream_exists = False\n        for sub in subs:\n            if sub[\"name\"] == stream_name_sub:\n                expected_stream_exists = True\n                self.assert_length(sub[\"subscribers\"], 2)\n        self.assertTrue(expected_stream_exists)\n\n        # Guest user only get data about never subscribed streams if they're\n        # web-public.\n        for stream in neversubs:\n            self.assertTrue(stream[\"is_web_public\"])\n\n        # Guest user only get data about never subscribed web-public streams\n        self.assert_length(neversubs, 1)\n\n    def test_api_fields_present(self) -> None:\n        user = self.example_user(\"cordelia\")\n\n        sub_data = gather_subscriptions_helper(user)\n        subscribed = sub_data.subscriptions\n        self.assertGreaterEqual(len(subscribed), 1)\n        self.verify_sub_fields(sub_data)\n\n    def test_previously_subscribed_private_streams(self) -> None:\n        admin_user = self.example_user(\"iago\")\n        non_admin_user = self.example_user(\"cordelia\")\n        guest_user = self.example_user(\"polonius\")\n        stream_name = \"private_stream\"\n\n        self.make_stream(stream_name, realm=get_realm(\"zulip\"), invite_only=True)\n        self.subscribe(admin_user, stream_name)\n        self.subscribe(non_admin_user, stream_name)\n        self.subscribe(guest_user, stream_name)\n        self.subscribe(self.example_user(\"othello\"), stream_name)\n\n        self.unsubscribe(admin_user, stream_name)\n        self.unsubscribe(non_admin_user, stream_name)\n        self.unsubscribe(guest_user, stream_name)\n\n        # Test admin user gets previously subscribed private stream's subscribers.\n        sub_data = gather_subscriptions_helper(admin_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 1)\n        self.assert_length(unsubscribed_streams[0][\"subscribers\"], 1)\n\n        # Test non-admin users cannot get previously subscribed private stream's subscribers.\n        sub_data = gather_subscriptions_helper(non_admin_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 1)\n        self.assertEqual(unsubscribed_streams[0][\"subscribers\"], [])\n\n        sub_data = gather_subscriptions_helper(guest_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 1)\n        self.assertEqual(unsubscribed_streams[0][\"subscribers\"], [])\n\n    def test_gather_subscriptions_mit(self) -> None:\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n        \"\"\"\n        # Subscribe only ourself because invites are disabled on mit.edu\n        mit_user_profile = self.mit_user(\"starnine\")\n        user_id = mit_user_profile.id\n        users_to_subscribe = [user_id, self.mit_user(\"espuser\").id]\n        for email in users_to_subscribe:\n            stream = self.subscribe(mit_user_profile, \"mit_stream\")\n            self.assertTrue(stream.is_in_zephyr_realm)\n\n        self.common_subscribe_to_streams(\n            mit_user_profile,\n            [\"mit_invite_only\"],\n            dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            invite_only=True,\n            subdomain=\"zephyr\",\n        )\n\n        with self.assert_database_query_count(4):\n            subscribed_streams, _ = gather_subscriptions(mit_user_profile, include_subscribers=True)\n\n        self.assertGreaterEqual(len(subscribed_streams), 2)\n        for sub in subscribed_streams:\n            if not sub[\"name\"].startswith(\"mit_\"):\n                raise AssertionError(\"Unexpected stream!\")\n            if sub[\"name\"] == \"mit_invite_only\":\n                self.assert_length(sub[\"subscribers\"], len(users_to_subscribe))\n            else:\n                self.assert_length(sub[\"subscribers\"], 0)\n\n    def test_nonsubscriber(self) -> None:\n        \"\"\"\n        Even a non-subscriber to a public stream can query a stream's membership\n        with get_subscribers.\n        \"\"\"\n        # Create a stream for which Hamlet is the only subscriber.\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.user_profile, [stream_name])\n        other_user = self.example_user(\"othello\")\n\n        # Fetch the subscriber list as a non-member.\n        self.login_user(other_user)\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_subscriber_private_stream(self) -> None:\n        \"\"\"\n        A subscriber to a private stream can query that stream's membership.\n        \"\"\"\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.user_profile, [stream_name], invite_only=True)\n        self.make_successful_subscriber_request(stream_name)\n\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        # Verify another user can't get the data.\n        self.login(\"cordelia\")\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # But an organization administrator can\n        self.login(\"iago\")\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        self.assert_json_success(result)\n\n    def test_json_get_subscribers_stream_not_exist(self) -> None:\n        \"\"\"\n        json_get_subscribers also returns the list of subscribers for a stream.\n        \"\"\"\n        stream_id = 99999999\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_json_get_subscribers(self) -> None:\n        \"\"\"\n        json_get_subscribers in zerver/views/streams.py\n        also returns the list of subscribers for a stream, when requested.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0][\"name\"]\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        expected_subscribers = gather_subscriptions(self.user_profile, include_subscribers=True)[0][\n            0\n        ][\"subscribers\"]\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        result_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribers\", result_dict)\n        self.assertIsInstance(result_dict[\"subscribers\"], list)\n        subscribers: List[int] = []\n        for subscriber in result_dict[\"subscribers\"]:\n            self.assertIsInstance(subscriber, int)\n            subscribers.append(subscriber)\n        self.assertEqual(set(subscribers), set(expected_subscribers))\n\n    def test_json_get_subscribers_for_guest_user(self) -> None:\n        \"\"\"\n        Guest users should have access to subscribers of web-public streams, even\n        if they aren't subscribed or have never subscribed to that stream.\n        \"\"\"\n        guest_user = self.example_user(\"polonius\")\n        never_subscribed = gather_subscriptions_helper(guest_user, True).never_subscribed\n\n        # A guest user can only see never subscribed streams that are web-public.\n        # For Polonius, the only web-public stream that he is not subscribed at\n        # this point is Rome.\n        self.assert_length(never_subscribed, 1)\n\n        web_public_stream_id = never_subscribed[0][\"stream_id\"]\n        result = self.client_get(f\"/json/streams/{web_public_stream_id}/members\")\n        result_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribers\", result_dict)\n        self.assertIsInstance(result_dict[\"subscribers\"], list)\n        self.assertGreater(len(result_dict[\"subscribers\"]), 0)\n\n    def test_nonsubscriber_private_stream(self) -> None:\n        \"\"\"\n        A non-subscriber non-realm-admin user to a private stream can't query that stream's membership.\n        But unsubscribed realm admin users can query private stream's membership.\n        \"\"\"\n        # Create a private stream for which Hamlet is the only subscriber.\n        stream_name = \"NewStream\"\n        self.common_subscribe_to_streams(self.user_profile, [stream_name], invite_only=True)\n        user_profile = self.example_user(\"othello\")\n\n        # Try to fetch the subscriber list as a non-member & non-realm-admin-user.\n        stream_id = get_stream(stream_name, user_profile.realm).id\n        result = self.make_subscriber_request(stream_id, user=user_profile)\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # Try to fetch the subscriber list as a non-member & realm-admin-user.\n        self.login(\"iago\")\n        self.make_successful_subscriber_request(stream_name)\n\n\nclass AccessStreamTest(ZulipTestCase):\n    def test_access_stream(self) -> None:\n        \"\"\"\n        A comprehensive security test for the access_stream_by_* API functions.\n        \"\"\"\n        # Create a private stream for which Hamlet is the only subscriber.\n        hamlet = self.example_user(\"hamlet\")\n\n        stream_name = \"new_private_stream\"\n        self.login_user(hamlet)\n        self.common_subscribe_to_streams(hamlet, [stream_name], invite_only=True)\n        stream = get_stream(stream_name, hamlet.realm)\n\n        othello = self.example_user(\"othello\")\n\n        # Nobody can access a stream that doesn't exist\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(hamlet, 501232)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'invalid stream'\"):\n            access_stream_by_name(hamlet, \"invalid stream\")\n\n        # Hamlet can access the private stream\n        (stream_ret, sub_ret) = access_stream_by_id(hamlet, stream.id)\n        self.assertEqual(stream.id, stream_ret.id)\n        assert sub_ret is not None\n        self.assertEqual(sub_ret.recipient.type_id, stream.id)\n        (stream_ret2, sub_ret2) = access_stream_by_name(hamlet, stream.name)\n        self.assertEqual(stream_ret.id, stream_ret2.id)\n        self.assertEqual(sub_ret, sub_ret2)\n\n        # Othello cannot access the private stream\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(othello, stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'new_private_stream'\"):\n            access_stream_by_name(othello, stream.name)\n\n        # Both Othello and Hamlet can access a public stream that only\n        # Hamlet is subscribed to in this realm\n        public_stream_name = \"public_stream\"\n        self.common_subscribe_to_streams(hamlet, [public_stream_name], invite_only=False)\n        public_stream = get_stream(public_stream_name, hamlet.realm)\n        access_stream_by_id(othello, public_stream.id)\n        access_stream_by_name(othello, public_stream.name)\n        access_stream_by_id(hamlet, public_stream.id)\n        access_stream_by_name(hamlet, public_stream.name)\n\n        # Nobody can access a public stream in another realm\n        mit_realm = get_realm(\"zephyr\")\n        mit_stream = ensure_stream(mit_realm, \"mit_stream\", invite_only=False, acting_user=None)\n        sipbtest = self.mit_user(\"sipbtest\")\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(hamlet, mit_stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'mit_stream'\"):\n            access_stream_by_name(hamlet, mit_stream.name)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(sipbtest, stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'new_private_stream'\"):\n            access_stream_by_name(sipbtest, stream.name)\n\n        # MIT realm users cannot access even public streams in their realm\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(sipbtest, mit_stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'mit_stream'\"):\n            access_stream_by_name(sipbtest, mit_stream.name)\n\n        # But they can access streams they are subscribed to\n        self.common_subscribe_to_streams(sipbtest, [mit_stream.name], subdomain=\"zephyr\")\n        access_stream_by_id(sipbtest, mit_stream.id)\n        access_stream_by_name(sipbtest, mit_stream.name)\n\n    def test_stream_access_by_guest(self) -> None:\n        guest_user_profile = self.example_user(\"polonius\")\n        self.login_user(guest_user_profile)\n        stream_name = \"public_stream_1\"\n        stream = self.make_stream(stream_name, guest_user_profile.realm, invite_only=False)\n\n        # Guest user don't have access to unsubscribed public streams\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(guest_user_profile, stream.id)\n\n        # Guest user have access to subscribed public streams\n        self.subscribe(guest_user_profile, stream_name)\n        (stream_ret, sub_ret) = access_stream_by_id(guest_user_profile, stream.id)\n        assert sub_ret is not None\n        self.assertEqual(stream.id, stream_ret.id)\n        self.assertEqual(sub_ret.recipient.type_id, stream.id)\n\n        stream_name = \"private_stream_1\"\n        stream = self.make_stream(stream_name, guest_user_profile.realm, invite_only=True)\n        # Obviously, a guest user doesn't have access to unsubscribed private streams either\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(guest_user_profile, stream.id)\n\n        # Guest user have access to subscribed private streams\n        self.subscribe(guest_user_profile, stream_name)\n        (stream_ret, sub_ret) = access_stream_by_id(guest_user_profile, stream.id)\n        assert sub_ret is not None\n        self.assertEqual(stream.id, stream_ret.id)\n        self.assertEqual(sub_ret.recipient.type_id, stream.id)\n\n        stream_name = \"web_public_stream\"\n        stream = self.make_stream(stream_name, guest_user_profile.realm, is_web_public=True)\n        # Guest users have access to web-public streams even if they aren't subscribed.\n        (stream_ret, sub_ret) = access_stream_by_id(guest_user_profile, stream.id)\n        self.assertTrue(can_access_stream_history(guest_user_profile, stream))\n        assert sub_ret is None\n        self.assertEqual(stream.id, stream_ret.id)\n\n\nclass StreamTrafficTest(ZulipTestCase):\n    def test_average_weekly_stream_traffic_calculation(self) -> None:\n        # No traffic data for the stream\n        self.assertEqual(\n            get_average_weekly_stream_traffic(42, timezone_now() - timedelta(days=300), {1: 4003}),\n            0,\n        )\n\n        # using high numbers here to make it more likely to catch small errors in the denominators\n        # of the calculations. That being said we don't want to go over 100, since then the 2\n        # significant digits calculation gets applied\n        # old stream\n        self.assertEqual(\n            get_average_weekly_stream_traffic(\n                42, timezone_now() - timedelta(days=300), {42: 98 * 4 + 3}\n            ),\n            98,\n        )\n        # stream between 7 and 27 days old\n        self.assertEqual(\n            get_average_weekly_stream_traffic(\n                42, timezone_now() - timedelta(days=10), {42: (98 * 10 + 9) // 7}\n            ),\n            98,\n        )\n        # stream less than 7 days old\n        self.assertEqual(\n            get_average_weekly_stream_traffic(42, timezone_now() - timedelta(days=5), {42: 100}),\n            None,\n        )\n\n        # average traffic between 0 and 1\n        self.assertEqual(\n            get_average_weekly_stream_traffic(42, timezone_now() - timedelta(days=300), {42: 1}), 1\n        )\n\n    def test_round_to_2_significant_digits(self) -> None:\n        self.assertEqual(120, round_to_2_significant_digits(116))\n\n\nclass NoRecipientIDsTest(ZulipTestCase):\n    def test_no_recipient_ids(self) -> None:\n        user_profile = self.example_user(\"cordelia\")\n\n        Subscription.objects.filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        ).delete()\n        subs = gather_subscriptions_helper(user_profile).subscriptions\n\n        # Checks that gather_subscriptions_helper will not return anything\n        # since there will not be any recipients, without crashing.\n        #\n        # This covers a rare corner case.\n        self.assert_length(subs, 0)\n"], "fixing_code": ["import hashlib\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Any, Collection, Dict, Iterable, List, Mapping, Optional, Set, Tuple\n\nimport orjson\nfrom django.conf import settings\nfrom django.db import transaction\nfrom django.db.models import Q, QuerySet\nfrom django.utils.timezone import now as timezone_now\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import override as override_language\nfrom django_stubs_ext import ValuesQuerySet\n\nfrom zerver.actions.default_streams import (\n    do_remove_default_stream,\n    do_remove_streams_from_default_stream_group,\n)\nfrom zerver.actions.message_send import internal_send_stream_message\nfrom zerver.lib.cache import (\n    cache_delete,\n    cache_delete_many,\n    cache_set,\n    display_recipient_cache_key,\n    get_stream_cache_key,\n    to_dict_cache_key_id,\n)\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.mention import silent_mention_syntax_for_user\nfrom zerver.lib.message import get_last_message_id\nfrom zerver.lib.queue import queue_json_publish\nfrom zerver.lib.stream_color import pick_colors\nfrom zerver.lib.stream_subscription import (\n    SubInfo,\n    bulk_get_private_peers,\n    bulk_get_subscriber_peer_info,\n    get_active_subscriptions_for_stream_id,\n    get_bulk_stream_subscriber_info,\n    get_used_colors_for_user_ids,\n)\nfrom zerver.lib.stream_traffic import get_average_weekly_stream_traffic, get_streams_traffic\nfrom zerver.lib.streams import (\n    can_access_stream_user_ids,\n    get_occupied_streams,\n    get_stream_permission_policy_name,\n    render_stream_description,\n    send_stream_creation_event,\n)\nfrom zerver.lib.subscription_info import get_subscribers_query\nfrom zerver.lib.types import APISubscriptionDict\nfrom zerver.models import (\n    ArchivedAttachment,\n    Attachment,\n    DefaultStream,\n    DefaultStreamGroup,\n    Message,\n    Realm,\n    RealmAuditLog,\n    Recipient,\n    Stream,\n    Subscription,\n    UserGroup,\n    UserProfile,\n    active_non_guest_user_ids,\n    get_system_bot,\n)\nfrom zerver.tornado.django_api import send_event, send_event_on_commit\n\n\n@transaction.atomic(savepoint=False)\ndef do_deactivate_stream(\n    stream: Stream, log: bool = True, *, acting_user: Optional[UserProfile]\n) -> None:\n    # If the stream is already deactivated, this is a no-op\n    if stream.deactivated is True:\n        raise JsonableError(_(\"Stream is already deactivated\"))\n\n    # We want to mark all messages in the to-be-deactivated stream as\n    # read for all users; otherwise they will pollute queries like\n    # \"Get the user's first unread message\".  Since this can be an\n    # expensive operation, we do it via the deferred_work queue\n    # processor.\n    deferred_work_event = {\n        \"type\": \"mark_stream_messages_as_read_for_everyone\",\n        \"stream_recipient_id\": stream.recipient_id,\n    }\n    transaction.on_commit(lambda: queue_json_publish(\"deferred_work\", deferred_work_event))\n\n    # Get the affected user ids *before* we deactivate everybody.\n    affected_user_ids = can_access_stream_user_ids(stream)\n\n    get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=True).update(\n        active=False\n    )\n\n    was_invite_only = stream.invite_only\n    stream.deactivated = True\n    stream.invite_only = True\n    # Preserve as much as possible the original stream name while giving it a\n    # special prefix that both indicates that the stream is deactivated and\n    # frees up the original name for reuse.\n    old_name = stream.name\n\n    # Prepend a substring of the hashed stream ID to the new stream name\n    streamID = str(stream.id)\n    stream_id_hash_object = hashlib.sha512(streamID.encode())\n    hashed_stream_id = stream_id_hash_object.hexdigest()[0:7]\n\n    new_name = (hashed_stream_id + \"!DEACTIVATED:\" + old_name)[: Stream.MAX_NAME_LENGTH]\n\n    stream.name = new_name[: Stream.MAX_NAME_LENGTH]\n    stream.save(update_fields=[\"name\", \"deactivated\", \"invite_only\"])\n\n    # If this is a default stream, remove it, properly sending a\n    # notification to browser clients.\n    if DefaultStream.objects.filter(realm_id=stream.realm_id, stream_id=stream.id).exists():\n        do_remove_default_stream(stream)\n\n    default_stream_groups_for_stream = DefaultStreamGroup.objects.filter(streams__id=stream.id)\n    for group in default_stream_groups_for_stream:\n        do_remove_streams_from_default_stream_group(stream.realm, group, [stream])\n\n    # Remove the old stream information from remote cache.\n    old_cache_key = get_stream_cache_key(old_name, stream.realm_id)\n    cache_delete(old_cache_key)\n\n    stream_dict = stream.to_dict()\n    stream_dict.update(dict(name=old_name, invite_only=was_invite_only))\n    event = dict(type=\"stream\", op=\"delete\", streams=[stream_dict])\n    send_event_on_commit(stream.realm, event, affected_user_ids)\n\n    event_time = timezone_now()\n    RealmAuditLog.objects.create(\n        realm=stream.realm,\n        acting_user=acting_user,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_DEACTIVATED,\n        event_time=event_time,\n    )\n\n\ndef deactivated_streams_by_old_name(realm: Realm, stream_name: str) -> QuerySet[Stream]:\n    fixed_length_prefix = \".......!DEACTIVATED:\"\n    truncated_name = stream_name[0 : Stream.MAX_NAME_LENGTH - len(fixed_length_prefix)]\n\n    old_names: List[str] = []\n    for bang_length in range(1, 21):\n        name = \"!\" * bang_length + \"DEACTIVATED:\" + stream_name\n        old_names.append(name[0 : Stream.MAX_NAME_LENGTH])\n\n    possible_streams = Stream.objects.filter(realm=realm, deactivated=True).filter(\n        # We go looking for names as they are post-1b6f68bb59dc; 8\n        # characters, followed by `!DEACTIVATED:`, followed by at\n        # most MAX_NAME_LENGTH-(length of the prefix) of the name\n        # they provided:\n        Q(name__regex=rf\"^{fixed_length_prefix}{truncated_name}\")\n        # Finally, we go looking for the pre-1b6f68bb59dc version,\n        # which is any number of `!` followed by `DEACTIVATED:`\n        # and a prefix of the old stream name\n        | Q(name__in=old_names),\n    )\n\n    return possible_streams\n\n\n@transaction.atomic(savepoint=False)\ndef do_unarchive_stream(\n    stream: Stream, new_name: str, *, acting_user: Optional[UserProfile]\n) -> None:\n    realm = stream.realm\n    if not stream.deactivated:\n        raise JsonableError(_(\"Stream is not currently deactivated\"))\n    if Stream.objects.filter(realm=realm, name=new_name).exists():\n        raise JsonableError(\n            _(\"Stream named {stream_name} already exists\").format(stream_name=new_name)\n        )\n    assert stream.recipient_id is not None\n\n    stream.deactivated = False\n    stream.name = new_name\n\n    # We only set invite_only=True during deactivation, which can lead\n    # to the invalid state of to invite-only but also web-public\n    # streams.  Explicitly reset the access; we do not use\n    # do_change_stream_permission because no users need be notified,\n    # and it cannot handle the broken state that may currently exist.\n    stream.is_web_public = False\n    stream.invite_only = True\n    stream.history_public_to_subscribers = True\n    stream.save(\n        update_fields=[\n            \"name\",\n            \"deactivated\",\n            \"is_web_public\",\n            \"invite_only\",\n            \"history_public_to_subscribers\",\n        ]\n    )\n\n    # Update caches\n    cache_set(display_recipient_cache_key(stream.recipient_id), new_name)\n    messages = Message.objects.filter(recipient_id=stream.recipient_id).only(\"id\")\n    cache_delete_many(to_dict_cache_key_id(message.id) for message in messages)\n\n    # Unset the is_web_public cache on attachments, since the stream is now private.\n    Attachment.objects.filter(messages__recipient_id=stream.recipient_id).update(is_web_public=None)\n    ArchivedAttachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n        is_web_public=None\n    )\n\n    RealmAuditLog.objects.create(\n        realm=realm,\n        acting_user=acting_user,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_REACTIVATED,\n        event_time=timezone_now(),\n    )\n\n    # All admins always get to know about private streams' existence,\n    # but we only subscribe the realm owners.\n    send_stream_creation_event(stream, [user.id for user in realm.get_admin_users_and_bots()])\n    bulk_add_subscriptions(\n        realm=realm,\n        streams=[stream],\n        users=realm.get_human_owner_users(),\n        acting_user=acting_user,\n    )\n\n    sender = get_system_bot(settings.NOTIFICATION_BOT, stream.realm_id)\n    with override_language(stream.realm.default_language):\n        internal_send_stream_message(\n            sender,\n            stream,\n            str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC),\n            _(\"Stream {stream_name} un-archived.\").format(stream_name=new_name),\n        )\n\n\ndef bulk_delete_cache_keys(message_ids_to_clear: List[int]) -> None:\n    while len(message_ids_to_clear) > 0:\n        batch = message_ids_to_clear[0:5000]\n\n        keys_to_delete = [to_dict_cache_key_id(message_id) for message_id in batch]\n        cache_delete_many(keys_to_delete)\n\n        message_ids_to_clear = message_ids_to_clear[5000:]\n\n\ndef merge_streams(\n    realm: Realm, stream_to_keep: Stream, stream_to_destroy: Stream\n) -> Tuple[int, int, int]:\n    recipient_to_destroy = stream_to_destroy.recipient\n    recipient_to_keep = stream_to_keep.recipient\n    assert recipient_to_keep is not None\n    assert recipient_to_destroy is not None\n    if recipient_to_destroy.id == recipient_to_keep.id:\n        return (0, 0, 0)\n\n    # The high-level approach here is to move all the messages to\n    # the surviving stream, deactivate all the subscriptions on\n    # the stream to be removed and deactivate the stream, and add\n    # new subscriptions to the stream to keep for any users who\n    # were only on the now-deactivated stream.\n    #\n    # The order of operations is carefully chosen so that calling this\n    # function again is likely to be an effective way to recover if\n    # this process is interrupted by an error.\n\n    # Move the Subscription objects.  This algorithm doesn't\n    # preserve any stream settings/colors/etc. from the stream\n    # being destroyed, but it's convenient.\n    existing_subs = Subscription.objects.filter(recipient=recipient_to_keep)\n    users_already_subscribed = {sub.user_profile_id: sub.active for sub in existing_subs}\n\n    subs_to_deactivate = Subscription.objects.filter(recipient=recipient_to_destroy, active=True)\n    users_to_activate = [\n        sub.user_profile\n        for sub in subs_to_deactivate\n        if not users_already_subscribed.get(sub.user_profile_id, False)\n    ]\n\n    if len(users_to_activate) > 0:\n        bulk_add_subscriptions(realm, [stream_to_keep], users_to_activate, acting_user=None)\n\n    # Move the messages, and delete the old copies from caches. We do\n    # this before removing the subscription objects, to avoid messages\n    # \"disappearing\" if an error interrupts this function.\n    message_ids_to_clear = list(\n        Message.objects.filter(recipient=recipient_to_destroy).values_list(\"id\", flat=True)\n    )\n    count = Message.objects.filter(recipient=recipient_to_destroy).update(\n        recipient=recipient_to_keep\n    )\n    bulk_delete_cache_keys(message_ids_to_clear)\n\n    # Remove subscriptions to the old stream.\n    if len(subs_to_deactivate) > 0:\n        bulk_remove_subscriptions(\n            realm,\n            [sub.user_profile for sub in subs_to_deactivate],\n            [stream_to_destroy],\n            acting_user=None,\n        )\n\n    do_deactivate_stream(stream_to_destroy, acting_user=None)\n\n    return (len(users_to_activate), count, len(subs_to_deactivate))\n\n\ndef get_subscriber_ids(\n    stream: Stream, requesting_user: Optional[UserProfile] = None\n) -> ValuesQuerySet[Subscription, int]:\n    subscriptions_query = get_subscribers_query(stream, requesting_user)\n    return subscriptions_query.values_list(\"user_profile_id\", flat=True)\n\n\n@dataclass\nclass StreamInfo:\n    stream_weekly_traffic: Optional[int]\n    subscribers: List[int]\n\n\ndef send_subscription_add_events(\n    realm: Realm,\n    sub_info_list: List[SubInfo],\n    subscriber_dict: Dict[int, Set[int]],\n) -> None:\n    info_by_user: Dict[int, List[SubInfo]] = defaultdict(list)\n    for sub_info in sub_info_list:\n        info_by_user[sub_info.user.id].append(sub_info)\n\n    stream_ids = {sub_info.stream.id for sub_info in sub_info_list}\n    recent_traffic = get_streams_traffic(stream_ids=stream_ids)\n\n    # We generally only have a few streams, so we compute stream\n    # data in its own loop.\n    stream_info_dict: Dict[int, StreamInfo] = {}\n    for sub_info in sub_info_list:\n        stream = sub_info.stream\n        if stream.id not in stream_info_dict:\n            stream_weekly_traffic = get_average_weekly_stream_traffic(\n                stream.id, stream.date_created, recent_traffic\n            )\n            if stream.is_in_zephyr_realm and not stream.invite_only:\n                subscribers = []\n            else:\n                subscribers = list(subscriber_dict[stream.id])\n            stream_info_dict[stream.id] = StreamInfo(\n                stream_weekly_traffic=stream_weekly_traffic,\n                subscribers=subscribers,\n            )\n\n    for user_id, sub_infos in info_by_user.items():\n        sub_dicts: List[APISubscriptionDict] = []\n        for sub_info in sub_infos:\n            stream = sub_info.stream\n            stream_info = stream_info_dict[stream.id]\n            subscription = sub_info.sub\n            stream_dict = stream.to_dict()\n            # This is verbose as we cannot unpack existing TypedDict\n            # to initialize another TypedDict while making mypy happy.\n            # https://github.com/python/mypy/issues/5382\n            sub_dict = APISubscriptionDict(\n                # Fields from Subscription.API_FIELDS\n                audible_notifications=subscription.audible_notifications,\n                color=subscription.color,\n                desktop_notifications=subscription.desktop_notifications,\n                email_notifications=subscription.email_notifications,\n                is_muted=subscription.is_muted,\n                pin_to_top=subscription.pin_to_top,\n                push_notifications=subscription.push_notifications,\n                wildcard_mentions_notify=subscription.wildcard_mentions_notify,\n                # Computed fields not present in Subscription.API_FIELDS\n                in_home_view=not subscription.is_muted,\n                stream_weekly_traffic=stream_info.stream_weekly_traffic,\n                subscribers=stream_info.subscribers,\n                # Fields from Stream.API_FIELDS\n                can_remove_subscribers_group_id=stream_dict[\"can_remove_subscribers_group_id\"],\n                date_created=stream_dict[\"date_created\"],\n                description=stream_dict[\"description\"],\n                first_message_id=stream_dict[\"first_message_id\"],\n                history_public_to_subscribers=stream_dict[\"history_public_to_subscribers\"],\n                invite_only=stream_dict[\"invite_only\"],\n                is_web_public=stream_dict[\"is_web_public\"],\n                message_retention_days=stream_dict[\"message_retention_days\"],\n                name=stream_dict[\"name\"],\n                rendered_description=stream_dict[\"rendered_description\"],\n                stream_id=stream_dict[\"stream_id\"],\n                stream_post_policy=stream_dict[\"stream_post_policy\"],\n                # Computed fields not present in Stream.API_FIELDS\n                is_announcement_only=stream_dict[\"is_announcement_only\"],\n            )\n\n            sub_dicts.append(sub_dict)\n\n        # Send a notification to the user who subscribed.\n        event = dict(type=\"subscription\", op=\"add\", subscriptions=sub_dicts)\n        send_event(realm, event, [user_id])\n\n\n# This function contains all the database changes as part of\n# subscribing users to streams; we use a transaction to ensure that\n# the RealmAuditLog entries are created atomically with the\n# Subscription object creation (and updates).\n@transaction.atomic(savepoint=False)\ndef bulk_add_subs_to_db_with_logging(\n    realm: Realm,\n    acting_user: Optional[UserProfile],\n    subs_to_add: List[SubInfo],\n    subs_to_activate: List[SubInfo],\n) -> None:\n    Subscription.objects.bulk_create(info.sub for info in subs_to_add)\n    sub_ids = [info.sub.id for info in subs_to_activate]\n    Subscription.objects.filter(id__in=sub_ids).update(active=True)\n\n    # Log subscription activities in RealmAuditLog\n    event_time = timezone_now()\n    event_last_message_id = get_last_message_id()\n\n    all_subscription_logs: (List[RealmAuditLog]) = []\n    for sub_info in subs_to_add:\n        all_subscription_logs.append(\n            RealmAuditLog(\n                realm=realm,\n                acting_user=acting_user,\n                modified_user=sub_info.user,\n                modified_stream=sub_info.stream,\n                event_last_message_id=event_last_message_id,\n                event_type=RealmAuditLog.SUBSCRIPTION_CREATED,\n                event_time=event_time,\n            )\n        )\n    for sub_info in subs_to_activate:\n        all_subscription_logs.append(\n            RealmAuditLog(\n                realm=realm,\n                acting_user=acting_user,\n                modified_user=sub_info.user,\n                modified_stream=sub_info.stream,\n                event_last_message_id=event_last_message_id,\n                event_type=RealmAuditLog.SUBSCRIPTION_ACTIVATED,\n                event_time=event_time,\n            )\n        )\n    # Now since we have all log objects generated we can do a bulk insert\n    RealmAuditLog.objects.bulk_create(all_subscription_logs)\n\n\ndef send_stream_creation_events_for_private_streams(\n    realm: Realm,\n    stream_dict: Dict[int, Stream],\n    altered_user_dict: Dict[int, Set[int]],\n) -> None:\n    for stream_id, stream_users_ids in altered_user_dict.items():\n        stream = stream_dict[stream_id]\n\n        if not stream.is_public():\n            # Users newly added to invite-only streams\n            # need a `create` notification.  The former, because\n            # they need the stream to exist before\n            # they get the \"subscribe\" notification, and the latter so\n            # they can manage the new stream.\n            # Realm admins already have all created private streams.\n            realm_admin_ids = {user.id for user in realm.get_admin_users_and_bots()}\n            notify_user_ids = list(stream_users_ids - realm_admin_ids)\n\n            if notify_user_ids:\n                send_stream_creation_event(stream, notify_user_ids)\n\n\ndef send_peer_subscriber_events(\n    op: str,\n    realm: Realm,\n    stream_dict: Dict[int, Stream],\n    altered_user_dict: Dict[int, Set[int]],\n    private_peer_dict: Dict[int, Set[int]],\n) -> None:\n    # Send peer_add/peer_remove events to other users who are tracking the\n    # subscribers lists of streams in their browser; everyone for\n    # public streams and only existing subscribers for private streams.\n\n    assert op in [\"peer_add\", \"peer_remove\"]\n\n    private_stream_ids = [\n        stream_id for stream_id in altered_user_dict if stream_dict[stream_id].invite_only\n    ]\n\n    for stream_id in private_stream_ids:\n        altered_user_ids = altered_user_dict[stream_id]\n        peer_user_ids = private_peer_dict[stream_id] - altered_user_ids\n\n        if peer_user_ids and altered_user_ids:\n            event = dict(\n                type=\"subscription\",\n                op=op,\n                stream_ids=[stream_id],\n                user_ids=sorted(altered_user_ids),\n            )\n            send_event_on_commit(realm, event, peer_user_ids)\n\n    public_stream_ids = [\n        stream_id\n        for stream_id in altered_user_dict\n        if not stream_dict[stream_id].invite_only and not stream_dict[stream_id].is_in_zephyr_realm\n    ]\n\n    if public_stream_ids:\n        user_streams: Dict[int, Set[int]] = defaultdict(set)\n\n        public_peer_ids = set(active_non_guest_user_ids(realm.id))\n\n        for stream_id in public_stream_ids:\n            altered_user_ids = altered_user_dict[stream_id]\n            peer_user_ids = public_peer_ids - altered_user_ids\n\n            if peer_user_ids and altered_user_ids:\n                if len(altered_user_ids) == 1:\n                    # If we only have one user, we will try to\n                    # find other streams they have (un)subscribed to\n                    # (where it's just them).  This optimization\n                    # typically works when a single user is subscribed\n                    # to multiple default public streams during\n                    # new-user registration.\n                    #\n                    # This optimization depends on all public streams\n                    # having the same peers for any single user, which\n                    # isn't the case for private streams.\n                    [altered_user_id] = altered_user_ids\n                    user_streams[altered_user_id].add(stream_id)\n                else:\n                    event = dict(\n                        type=\"subscription\",\n                        op=op,\n                        stream_ids=[stream_id],\n                        user_ids=sorted(altered_user_ids),\n                    )\n                    send_event_on_commit(realm, event, peer_user_ids)\n\n        for user_id, stream_ids in user_streams.items():\n            peer_user_ids = public_peer_ids - {user_id}\n            event = dict(\n                type=\"subscription\",\n                op=op,\n                stream_ids=sorted(stream_ids),\n                user_ids=[user_id],\n            )\n            send_event_on_commit(realm, event, peer_user_ids)\n\n\nSubT = Tuple[List[SubInfo], List[SubInfo]]\n\n\ndef bulk_add_subscriptions(\n    realm: Realm,\n    streams: Collection[Stream],\n    users: Iterable[UserProfile],\n    color_map: Mapping[str, str] = {},\n    from_user_creation: bool = False,\n    *,\n    acting_user: Optional[UserProfile],\n) -> SubT:\n    users = list(users)\n    user_ids = [user.id for user in users]\n\n    # Sanity check out callers\n    for stream in streams:\n        assert stream.realm_id == realm.id\n\n    for user in users:\n        assert user.realm_id == realm.id\n\n    recipient_ids = [stream.recipient_id for stream in streams]\n    recipient_id_to_stream = {stream.recipient_id: stream for stream in streams}\n\n    recipient_color_map = {}\n    recipient_ids_set: Set[int] = set()\n    for stream in streams:\n        assert stream.recipient_id is not None\n        recipient_ids_set.add(stream.recipient_id)\n        color: Optional[str] = color_map.get(stream.name, None)\n        if color is not None:\n            recipient_color_map[stream.recipient_id] = color\n\n    used_colors_for_user_ids: Dict[int, Set[str]] = get_used_colors_for_user_ids(user_ids)\n\n    existing_subs = Subscription.objects.filter(\n        user_profile_id__in=user_ids,\n        recipient__type=Recipient.STREAM,\n        recipient_id__in=recipient_ids,\n    )\n\n    subs_by_user: Dict[int, List[Subscription]] = defaultdict(list)\n    for sub in existing_subs:\n        subs_by_user[sub.user_profile_id].append(sub)\n\n    already_subscribed: List[SubInfo] = []\n    subs_to_activate: List[SubInfo] = []\n    subs_to_add: List[SubInfo] = []\n    for user_profile in users:\n        my_subs = subs_by_user[user_profile.id]\n\n        # Make a fresh set of all new recipient ids, and then we will\n        # remove any for which our user already has a subscription\n        # (and we'll re-activate any subscriptions as needed).\n        new_recipient_ids: Set[int] = recipient_ids_set.copy()\n\n        for sub in my_subs:\n            if sub.recipient_id in new_recipient_ids:\n                new_recipient_ids.remove(sub.recipient_id)\n                stream = recipient_id_to_stream[sub.recipient_id]\n                sub_info = SubInfo(user_profile, sub, stream)\n                if sub.active:\n                    already_subscribed.append(sub_info)\n                else:\n                    subs_to_activate.append(sub_info)\n\n        used_colors = used_colors_for_user_ids.get(user_profile.id, set())\n        user_color_map = pick_colors(used_colors, recipient_color_map, list(new_recipient_ids))\n\n        for recipient_id in new_recipient_ids:\n            stream = recipient_id_to_stream[recipient_id]\n            color = user_color_map[recipient_id]\n\n            sub = Subscription(\n                user_profile=user_profile,\n                is_user_active=user_profile.is_active,\n                active=True,\n                color=color,\n                recipient_id=recipient_id,\n            )\n            sub_info = SubInfo(user_profile, sub, stream)\n            subs_to_add.append(sub_info)\n\n    bulk_add_subs_to_db_with_logging(\n        realm=realm,\n        acting_user=acting_user,\n        subs_to_add=subs_to_add,\n        subs_to_activate=subs_to_activate,\n    )\n\n    altered_user_dict: Dict[int, Set[int]] = defaultdict(set)\n    for sub_info in subs_to_add + subs_to_activate:\n        altered_user_dict[sub_info.stream.id].add(sub_info.user.id)\n\n    stream_dict = {stream.id: stream for stream in streams}\n\n    new_streams = [stream_dict[stream_id] for stream_id in altered_user_dict]\n\n    subscriber_peer_info = bulk_get_subscriber_peer_info(\n        realm=realm,\n        streams=new_streams,\n    )\n\n    # We now send several types of events to notify browsers.  The\n    # first batches of notifications are sent only to the user(s)\n    # being subscribed; we can skip these notifications when this is\n    # being called from the new user creation flow.\n    if not from_user_creation:\n        send_stream_creation_events_for_private_streams(\n            realm=realm,\n            stream_dict=stream_dict,\n            altered_user_dict=altered_user_dict,\n        )\n\n        send_subscription_add_events(\n            realm=realm,\n            sub_info_list=subs_to_add + subs_to_activate,\n            subscriber_dict=subscriber_peer_info.subscribed_ids,\n        )\n\n    send_peer_subscriber_events(\n        op=\"peer_add\",\n        realm=realm,\n        altered_user_dict=altered_user_dict,\n        stream_dict=stream_dict,\n        private_peer_dict=subscriber_peer_info.private_peer_dict,\n    )\n\n    return (\n        subs_to_add + subs_to_activate,\n        already_subscribed,\n    )\n\n\ndef send_peer_remove_events(\n    realm: Realm,\n    streams: List[Stream],\n    altered_user_dict: Dict[int, Set[int]],\n) -> None:\n    private_streams = [stream for stream in streams if stream.invite_only]\n\n    private_peer_dict = bulk_get_private_peers(\n        realm=realm,\n        private_streams=private_streams,\n    )\n    stream_dict = {stream.id: stream for stream in streams}\n\n    send_peer_subscriber_events(\n        op=\"peer_remove\",\n        realm=realm,\n        stream_dict=stream_dict,\n        altered_user_dict=altered_user_dict,\n        private_peer_dict=private_peer_dict,\n    )\n\n\ndef notify_subscriptions_removed(\n    realm: Realm, user_profile: UserProfile, streams: Iterable[Stream]\n) -> None:\n    payload = [dict(name=stream.name, stream_id=stream.id) for stream in streams]\n    event = dict(type=\"subscription\", op=\"remove\", subscriptions=payload)\n    send_event(realm, event, [user_profile.id])\n\n\nSubAndRemovedT = Tuple[List[Tuple[UserProfile, Stream]], List[Tuple[UserProfile, Stream]]]\n\n\ndef send_subscription_remove_events(\n    realm: Realm,\n    users: List[UserProfile],\n    streams: List[Stream],\n    removed_subs: List[Tuple[UserProfile, Stream]],\n) -> None:\n    altered_user_dict: Dict[int, Set[int]] = defaultdict(set)\n    streams_by_user: Dict[int, List[Stream]] = defaultdict(list)\n    for user, stream in removed_subs:\n        streams_by_user[user.id].append(stream)\n        altered_user_dict[stream.id].add(user.id)\n\n    for user_profile in users:\n        if len(streams_by_user[user_profile.id]) == 0:\n            continue\n        notify_subscriptions_removed(realm, user_profile, streams_by_user[user_profile.id])\n\n        event = {\n            \"type\": \"mark_stream_messages_as_read\",\n            \"user_profile_id\": user_profile.id,\n            \"stream_recipient_ids\": [\n                stream.recipient_id for stream in streams_by_user[user_profile.id]\n            ],\n        }\n        queue_json_publish(\"deferred_work\", event)\n\n    send_peer_remove_events(\n        realm=realm,\n        streams=streams,\n        altered_user_dict=altered_user_dict,\n    )\n\n\ndef bulk_remove_subscriptions(\n    realm: Realm,\n    users: Iterable[UserProfile],\n    streams: Iterable[Stream],\n    *,\n    acting_user: Optional[UserProfile],\n) -> SubAndRemovedT:\n    users = list(users)\n    streams = list(streams)\n\n    # Sanity check our callers\n    for stream in streams:\n        assert stream.realm_id == realm.id\n\n    for user in users:\n        assert user.realm_id == realm.id\n\n    stream_dict = {stream.id: stream for stream in streams}\n\n    existing_subs_by_user = get_bulk_stream_subscriber_info(users, streams)\n\n    def get_non_subscribed_subs() -> List[Tuple[UserProfile, Stream]]:\n        stream_ids = {stream.id for stream in streams}\n\n        not_subscribed: List[Tuple[UserProfile, Stream]] = []\n\n        for user_profile in users:\n            user_sub_stream_info = existing_subs_by_user[user_profile.id]\n\n            subscribed_stream_ids = {sub_info.stream.id for sub_info in user_sub_stream_info}\n            not_subscribed_stream_ids = stream_ids - subscribed_stream_ids\n\n            for stream_id in not_subscribed_stream_ids:\n                stream = stream_dict[stream_id]\n                not_subscribed.append((user_profile, stream))\n\n        return not_subscribed\n\n    not_subscribed = get_non_subscribed_subs()\n\n    subs_to_deactivate: List[SubInfo] = []\n    sub_ids_to_deactivate: List[int] = []\n\n    # This loop just flattens out our data into big lists for\n    # bulk operations.\n    for sub_infos in existing_subs_by_user.values():\n        for sub_info in sub_infos:\n            subs_to_deactivate.append(sub_info)\n            sub_ids_to_deactivate.append(sub_info.sub.id)\n\n    streams_to_unsubscribe = [sub_info.stream for sub_info in subs_to_deactivate]\n    # We do all the database changes in a transaction to ensure\n    # RealmAuditLog entries are atomically created when making changes.\n    with transaction.atomic():\n        Subscription.objects.filter(\n            id__in=sub_ids_to_deactivate,\n        ).update(active=False)\n        occupied_streams_after = list(get_occupied_streams(realm))\n\n        # Log subscription activities in RealmAuditLog\n        event_time = timezone_now()\n        event_last_message_id = get_last_message_id()\n        all_subscription_logs = [\n            RealmAuditLog(\n                realm=sub_info.user.realm,\n                acting_user=acting_user,\n                modified_user=sub_info.user,\n                modified_stream=sub_info.stream,\n                event_last_message_id=event_last_message_id,\n                event_type=RealmAuditLog.SUBSCRIPTION_DEACTIVATED,\n                event_time=event_time,\n            )\n            for sub_info in subs_to_deactivate\n        ]\n\n        # Now since we have all log objects generated we can do a bulk insert\n        RealmAuditLog.objects.bulk_create(all_subscription_logs)\n\n    removed_sub_tuples = [(sub_info.user, sub_info.stream) for sub_info in subs_to_deactivate]\n    send_subscription_remove_events(realm, users, streams, removed_sub_tuples)\n\n    new_vacant_streams = set(streams_to_unsubscribe) - set(occupied_streams_after)\n    new_vacant_private_streams = [stream for stream in new_vacant_streams if stream.invite_only]\n\n    if new_vacant_private_streams:\n        # Deactivate any newly-vacant private streams\n        for stream in new_vacant_private_streams:\n            do_deactivate_stream(stream, acting_user=acting_user)\n\n    return (\n        removed_sub_tuples,\n        not_subscribed,\n    )\n\n\ndef do_change_subscription_property(\n    user_profile: UserProfile,\n    sub: Subscription,\n    stream: Stream,\n    property_name: str,\n    value: Any,\n    *,\n    acting_user: Optional[UserProfile],\n) -> None:\n    database_property_name = property_name\n    database_value = value\n\n    # For this property, is_muted is used in the database, but\n    # in_home_view is still in the API, since we haven't fully\n    # migrated to the new name yet.\n    if property_name == \"in_home_view\":\n        database_property_name = \"is_muted\"\n        database_value = not value\n\n    old_value = getattr(sub, database_property_name)\n    setattr(sub, database_property_name, database_value)\n    sub.save(update_fields=[database_property_name])\n    event_time = timezone_now()\n    RealmAuditLog.objects.create(\n        realm=user_profile.realm,\n        event_type=RealmAuditLog.SUBSCRIPTION_PROPERTY_CHANGED,\n        event_time=event_time,\n        modified_user=user_profile,\n        acting_user=acting_user,\n        modified_stream=stream,\n        extra_data=orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: old_value,\n                RealmAuditLog.NEW_VALUE: database_value,\n                \"property\": database_property_name,\n            }\n        ).decode(),\n    )\n\n    # This first in_home_view event is deprecated and will be removed\n    # once clients are migrated to handle the subscription update event\n    # with is_muted as the property name.\n    if database_property_name == \"is_muted\":\n        event_value = not database_value\n        in_home_view_event = dict(\n            type=\"subscription\",\n            op=\"update\",\n            property=\"in_home_view\",\n            value=event_value,\n            stream_id=stream.id,\n        )\n\n        send_event(user_profile.realm, in_home_view_event, [user_profile.id])\n\n    event = dict(\n        type=\"subscription\",\n        op=\"update\",\n        property=database_property_name,\n        value=database_value,\n        stream_id=stream.id,\n    )\n    send_event(user_profile.realm, event, [user_profile.id])\n\n\ndef send_change_stream_permission_notification(\n    stream: Stream,\n    *,\n    old_policy_name: str,\n    new_policy_name: str,\n    acting_user: UserProfile,\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, acting_user.realm_id)\n    user_mention = silent_mention_syntax_for_user(acting_user)\n\n    with override_language(stream.realm.default_language):\n        notification_string = _(\n            \"{user} changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **{old_policy}** to **{new_policy}**.\"\n        )\n        notification_string = notification_string.format(\n            user=user_mention,\n            old_policy=old_policy_name,\n            new_policy=new_policy_name,\n        )\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_permission(\n    stream: Stream,\n    *,\n    invite_only: bool,\n    history_public_to_subscribers: bool,\n    is_web_public: bool,\n    acting_user: UserProfile,\n) -> None:\n    old_invite_only_value = stream.invite_only\n    old_history_public_to_subscribers_value = stream.history_public_to_subscribers\n    old_is_web_public_value = stream.is_web_public\n\n    stream.is_web_public = is_web_public\n    stream.invite_only = invite_only\n    stream.history_public_to_subscribers = history_public_to_subscribers\n\n    with transaction.atomic():\n        stream.save(update_fields=[\"invite_only\", \"history_public_to_subscribers\", \"is_web_public\"])\n\n        event_time = timezone_now()\n        if old_invite_only_value != stream.invite_only:\n            # Reset the Attachment.is_realm_public cache for all\n            # messages in the stream whose permissions were changed.\n            assert stream.recipient_id is not None\n            Attachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_realm_public=None\n            )\n            # We need to do the same for ArchivedAttachment to avoid\n            # bugs if deleted attachments are later restored.\n            ArchivedAttachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_realm_public=None\n            )\n\n            RealmAuditLog.objects.create(\n                realm=stream.realm,\n                acting_user=acting_user,\n                modified_stream=stream,\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                event_time=event_time,\n                extra_data=orjson.dumps(\n                    {\n                        RealmAuditLog.OLD_VALUE: old_invite_only_value,\n                        RealmAuditLog.NEW_VALUE: stream.invite_only,\n                        \"property\": \"invite_only\",\n                    }\n                ).decode(),\n            )\n\n        if old_history_public_to_subscribers_value != stream.history_public_to_subscribers:\n            RealmAuditLog.objects.create(\n                realm=stream.realm,\n                acting_user=acting_user,\n                modified_stream=stream,\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                event_time=event_time,\n                extra_data=orjson.dumps(\n                    {\n                        RealmAuditLog.OLD_VALUE: old_history_public_to_subscribers_value,\n                        RealmAuditLog.NEW_VALUE: stream.history_public_to_subscribers,\n                        \"property\": \"history_public_to_subscribers\",\n                    }\n                ).decode(),\n            )\n\n        if old_is_web_public_value != stream.is_web_public:\n            # Reset the Attachment.is_realm_public cache for all\n            # messages in the stream whose permissions were changed.\n            assert stream.recipient_id is not None\n            Attachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_web_public=None\n            )\n            # We need to do the same for ArchivedAttachment to avoid\n            # bugs if deleted attachments are later restored.\n            ArchivedAttachment.objects.filter(messages__recipient_id=stream.recipient_id).update(\n                is_web_public=None\n            )\n\n            RealmAuditLog.objects.create(\n                realm=stream.realm,\n                acting_user=acting_user,\n                modified_stream=stream,\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                event_time=event_time,\n                extra_data=orjson.dumps(\n                    {\n                        RealmAuditLog.OLD_VALUE: old_is_web_public_value,\n                        RealmAuditLog.NEW_VALUE: stream.is_web_public,\n                        \"property\": \"is_web_public\",\n                    }\n                ).decode(),\n            )\n\n    notify_stream_creation_ids = set()\n    if old_invite_only_value and not stream.invite_only:\n        # We need to send stream creation event to users who can access the\n        # stream now but were not able to do so previously. So, we can exclude\n        # subscribers and realm admins from the non-guest user list.\n        stream_subscriber_user_ids = get_active_subscriptions_for_stream_id(\n            stream.id, include_deactivated_users=False\n        ).values_list(\"user_profile_id\", flat=True)\n\n        old_can_access_stream_user_ids = set(stream_subscriber_user_ids) | {\n            user.id for user in stream.realm.get_admin_users_and_bots()\n        }\n        non_guest_user_ids = set(active_non_guest_user_ids(stream.realm_id))\n        notify_stream_creation_ids = non_guest_user_ids - old_can_access_stream_user_ids\n        send_stream_creation_event(stream, list(notify_stream_creation_ids))\n\n        # Add subscribers info to the stream object. We need to send peer_add\n        # events to users who were previously subscribed to the streams as\n        # they did not had subscribers data.\n        old_subscribers_access_user_ids = set(stream_subscriber_user_ids) | {\n            user.id for user in stream.realm.get_admin_users_and_bots()\n        }\n        peer_notify_user_ids = non_guest_user_ids - old_subscribers_access_user_ids\n        peer_add_event = dict(\n            type=\"subscription\",\n            op=\"peer_add\",\n            stream_ids=[stream.id],\n            user_ids=sorted(stream_subscriber_user_ids),\n        )\n        send_event(stream.realm, peer_add_event, peer_notify_user_ids)\n\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"invite_only\",\n        value=stream.invite_only,\n        history_public_to_subscribers=stream.history_public_to_subscribers,\n        is_web_public=stream.is_web_public,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    # we do not need to send update events to the users who received creation event\n    # since they already have the updated stream info.\n    notify_stream_update_ids = can_access_stream_user_ids(stream) - notify_stream_creation_ids\n    send_event(stream.realm, event, notify_stream_update_ids)\n\n    old_policy_name = get_stream_permission_policy_name(\n        invite_only=old_invite_only_value,\n        history_public_to_subscribers=old_history_public_to_subscribers_value,\n        is_web_public=old_is_web_public_value,\n    )\n    new_policy_name = get_stream_permission_policy_name(\n        invite_only=stream.invite_only,\n        history_public_to_subscribers=stream.history_public_to_subscribers,\n        is_web_public=stream.is_web_public,\n    )\n    send_change_stream_permission_notification(\n        stream,\n        old_policy_name=old_policy_name,\n        new_policy_name=new_policy_name,\n        acting_user=acting_user,\n    )\n\n\ndef send_change_stream_post_policy_notification(\n    stream: Stream, *, old_post_policy: int, new_post_policy: int, acting_user: UserProfile\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, acting_user.realm_id)\n    user_mention = silent_mention_syntax_for_user(acting_user)\n\n    with override_language(stream.realm.default_language):\n        notification_string = _(\n            \"{user} changed the [posting permissions](/help/stream-sending-policy) \"\n            \"for this stream:\\n\\n\"\n            \"* **Old permissions**: {old_policy}.\\n\"\n            \"* **New permissions**: {new_policy}.\\n\"\n        )\n        notification_string = notification_string.format(\n            user=user_mention,\n            old_policy=Stream.POST_POLICIES[old_post_policy],\n            new_policy=Stream.POST_POLICIES[new_post_policy],\n        )\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_post_policy(\n    stream: Stream, stream_post_policy: int, *, acting_user: UserProfile\n) -> None:\n    old_post_policy = stream.stream_post_policy\n    with transaction.atomic():\n        stream.stream_post_policy = stream_post_policy\n        stream.save(update_fields=[\"stream_post_policy\"])\n        RealmAuditLog.objects.create(\n            realm=stream.realm,\n            acting_user=acting_user,\n            modified_stream=stream,\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            event_time=timezone_now(),\n            extra_data=orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_post_policy,\n                    RealmAuditLog.NEW_VALUE: stream_post_policy,\n                    \"property\": \"stream_post_policy\",\n                }\n            ).decode(),\n        )\n\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"stream_post_policy\",\n        value=stream_post_policy,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n\n    # Backwards-compatibility code: We removed the\n    # is_announcement_only property in early 2020, but we send a\n    # duplicate event for legacy mobile clients that might want the\n    # data.\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"is_announcement_only\",\n        value=stream.stream_post_policy == Stream.STREAM_POST_POLICY_ADMINS,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n\n    send_change_stream_post_policy_notification(\n        stream,\n        old_post_policy=old_post_policy,\n        new_post_policy=stream_post_policy,\n        acting_user=acting_user,\n    )\n\n\ndef do_rename_stream(stream: Stream, new_name: str, user_profile: UserProfile) -> None:\n    old_name = stream.name\n    stream.name = new_name\n    stream.save(update_fields=[\"name\"])\n\n    RealmAuditLog.objects.create(\n        realm=stream.realm,\n        acting_user=user_profile,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_NAME_CHANGED,\n        event_time=timezone_now(),\n        extra_data=orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: old_name,\n                RealmAuditLog.NEW_VALUE: new_name,\n            }\n        ).decode(),\n    )\n\n    assert stream.recipient_id is not None\n    recipient_id: int = stream.recipient_id\n    messages = Message.objects.filter(recipient_id=recipient_id).only(\"id\")\n\n    # Update the display recipient and stream, which are easy single\n    # items to set.\n    old_cache_key = get_stream_cache_key(old_name, stream.realm_id)\n    new_cache_key = get_stream_cache_key(stream.name, stream.realm_id)\n    if old_cache_key != new_cache_key:\n        cache_delete(old_cache_key)\n        cache_set(new_cache_key, stream)\n    cache_set(display_recipient_cache_key(recipient_id), stream.name)\n\n    # Delete cache entries for everything else, which is cheaper and\n    # clearer than trying to set them. display_recipient is the out of\n    # date field in all cases.\n    cache_delete_many(to_dict_cache_key_id(message.id) for message in messages)\n\n    # We want to key these updates by id, not name, since id is\n    # the immutable primary key, and obviously name is not.\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"name\",\n        value=new_name,\n        stream_id=stream.id,\n        name=old_name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n    sender = get_system_bot(settings.NOTIFICATION_BOT, stream.realm_id)\n    with override_language(stream.realm.default_language):\n        internal_send_stream_message(\n            sender,\n            stream,\n            str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC),\n            _(\"{user_name} renamed stream {old_stream_name} to {new_stream_name}.\").format(\n                user_name=silent_mention_syntax_for_user(user_profile),\n                old_stream_name=f\"**{old_name}**\",\n                new_stream_name=f\"**{new_name}**\",\n            ),\n        )\n\n\ndef send_change_stream_description_notification(\n    stream: Stream, *, old_description: str, new_description: str, acting_user: UserProfile\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, acting_user.realm_id)\n    user_mention = silent_mention_syntax_for_user(acting_user)\n\n    with override_language(stream.realm.default_language):\n        if new_description == \"\":\n            new_description = \"*\" + _(\"No description.\") + \"*\"\n        if old_description == \"\":\n            old_description = \"*\" + _(\"No description.\") + \"*\"\n\n        notification_string = (\n            _(\"{user} changed the description for this stream.\").format(user=user_mention)\n            + \"\\n\\n* **\"\n            + _(\"Old description\")\n            + \":**\"\n            + f\"\\n```` quote\\n{old_description}\\n````\\n\"\n            + \"* **\"\n            + _(\"New description\")\n            + \":**\"\n            + f\"\\n```` quote\\n{new_description}\\n````\"\n        )\n\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_description(\n    stream: Stream, new_description: str, *, acting_user: UserProfile\n) -> None:\n    old_description = stream.description\n\n    with transaction.atomic():\n        stream.description = new_description\n        stream.rendered_description = render_stream_description(new_description, stream.realm)\n        stream.save(update_fields=[\"description\", \"rendered_description\"])\n        RealmAuditLog.objects.create(\n            realm=stream.realm,\n            acting_user=acting_user,\n            modified_stream=stream,\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            event_time=timezone_now(),\n            extra_data=orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_description,\n                    RealmAuditLog.NEW_VALUE: new_description,\n                    \"property\": \"description\",\n                }\n            ).decode(),\n        )\n\n    event = dict(\n        type=\"stream\",\n        op=\"update\",\n        property=\"description\",\n        name=stream.name,\n        stream_id=stream.id,\n        value=new_description,\n        rendered_description=stream.rendered_description,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n\n    send_change_stream_description_notification(\n        stream,\n        old_description=old_description,\n        new_description=new_description,\n        acting_user=acting_user,\n    )\n\n\ndef send_change_stream_message_retention_days_notification(\n    user_profile: UserProfile, stream: Stream, old_value: Optional[int], new_value: Optional[int]\n) -> None:\n    sender = get_system_bot(settings.NOTIFICATION_BOT, user_profile.realm_id)\n    user_mention = silent_mention_syntax_for_user(user_profile)\n\n    # If switching from or to the organization's default retention policy,\n    # we want to take the realm's default into account.\n    if old_value is None:\n        old_value = stream.realm.message_retention_days\n    if new_value is None:\n        new_value = stream.realm.message_retention_days\n\n    with override_language(stream.realm.default_language):\n        if old_value == Stream.MESSAGE_RETENTION_SPECIAL_VALUES_MAP[\"unlimited\"]:\n            old_retention_period = _(\"Forever\")\n            new_retention_period = f\"{new_value} days\"\n            summary_line = f\"Messages in this stream will now be automatically deleted {new_value} days after they are sent.\"\n        elif new_value == Stream.MESSAGE_RETENTION_SPECIAL_VALUES_MAP[\"unlimited\"]:\n            old_retention_period = f\"{old_value} days\"\n            new_retention_period = _(\"Forever\")\n            summary_line = _(\"Messages in this stream will now be retained forever.\")\n        else:\n            old_retention_period = f\"{old_value} days\"\n            new_retention_period = f\"{new_value} days\"\n            summary_line = f\"Messages in this stream will now be automatically deleted {new_value} days after they are sent.\"\n        notification_string = _(\n            \"{user} has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: {old_retention_period}\\n\"\n            \"* **New retention period**: {new_retention_period}\\n\\n\"\n            \"{summary_line}\"\n        )\n        notification_string = notification_string.format(\n            user=user_mention,\n            old_retention_period=old_retention_period,\n            new_retention_period=new_retention_period,\n            summary_line=summary_line,\n        )\n        internal_send_stream_message(\n            sender, stream, str(Realm.STREAM_EVENTS_NOTIFICATION_TOPIC), notification_string\n        )\n\n\ndef do_change_stream_message_retention_days(\n    stream: Stream, acting_user: UserProfile, message_retention_days: Optional[int] = None\n) -> None:\n    old_message_retention_days_value = stream.message_retention_days\n\n    with transaction.atomic():\n        stream.message_retention_days = message_retention_days\n        stream.save(update_fields=[\"message_retention_days\"])\n        RealmAuditLog.objects.create(\n            realm=stream.realm,\n            acting_user=acting_user,\n            modified_stream=stream,\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED,\n            event_time=timezone_now(),\n            extra_data=orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_message_retention_days_value,\n                    RealmAuditLog.NEW_VALUE: message_retention_days,\n                }\n            ).decode(),\n        )\n\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=\"message_retention_days\",\n        value=message_retention_days,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event(stream.realm, event, can_access_stream_user_ids(stream))\n    send_change_stream_message_retention_days_notification(\n        user_profile=acting_user,\n        stream=stream,\n        old_value=old_message_retention_days_value,\n        new_value=message_retention_days,\n    )\n\n\ndef do_change_stream_group_based_setting(\n    stream: Stream,\n    setting_name: str,\n    user_group: UserGroup,\n    *,\n    acting_user: Optional[UserProfile] = None,\n) -> None:\n    old_user_group = getattr(stream, setting_name)\n    old_user_group_id = None\n    if old_user_group is not None:\n        old_user_group_id = old_user_group.id\n\n    setattr(stream, setting_name, user_group)\n    stream.save()\n\n    RealmAuditLog.objects.create(\n        realm=stream.realm,\n        acting_user=acting_user,\n        modified_stream=stream,\n        event_type=RealmAuditLog.STREAM_GROUP_BASED_SETTING_CHANGED,\n        event_time=timezone_now(),\n        extra_data=orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: old_user_group_id,\n                RealmAuditLog.NEW_VALUE: user_group.id,\n                \"property\": setting_name,\n            }\n        ).decode(),\n    )\n    event = dict(\n        op=\"update\",\n        type=\"stream\",\n        property=setting_name + \"_id\",\n        value=user_group.id,\n        stream_id=stream.id,\n        name=stream.name,\n    )\n    send_event_on_commit(stream.realm, event, can_access_stream_user_ids(stream))\n", "# See https://zulip.readthedocs.io/en/latest/subsystems/events-system.html for\n# high-level documentation on how this system works.\nimport copy\nimport time\nfrom typing import Any, Callable, Collection, Dict, Iterable, Mapping, Optional, Sequence, Set\n\nfrom django.conf import settings\nfrom django.utils.translation import gettext as _\n\nfrom version import API_FEATURE_LEVEL, ZULIP_MERGE_BASE, ZULIP_VERSION\nfrom zerver.actions.default_streams import (\n    default_stream_groups_to_dicts_sorted,\n    get_default_streams_for_realm,\n    streams_to_dicts_sorted,\n)\nfrom zerver.actions.users import get_owned_bot_dicts\nfrom zerver.lib import emoji\nfrom zerver.lib.alert_words import user_alert_words\nfrom zerver.lib.avatar import avatar_url\nfrom zerver.lib.bot_config import load_bot_config_template\nfrom zerver.lib.compatibility import is_outdated_server\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.external_accounts import get_default_external_accounts\nfrom zerver.lib.hotspots import get_next_hotspots\nfrom zerver.lib.integrations import EMBEDDED_BOTS, WEBHOOK_INTEGRATIONS\nfrom zerver.lib.message import (\n    add_message_to_unread_msgs,\n    aggregate_unread_data,\n    apply_unread_message_event,\n    extract_unread_data_from_um_rows,\n    get_raw_unread_data,\n    get_recent_conversations_recipient_id,\n    get_recent_private_conversations,\n    get_starred_message_ids,\n    remove_message_id_from_unread_mgs,\n)\nfrom zerver.lib.muted_users import get_user_mutes\nfrom zerver.lib.narrow import check_supported_events_narrow_filter, read_stop_words\nfrom zerver.lib.presence import get_presence_for_user, get_presences_for_realm\nfrom zerver.lib.push_notifications import push_notifications_enabled\nfrom zerver.lib.realm_icon import realm_icon_url\nfrom zerver.lib.realm_logo import get_realm_logo_source, get_realm_logo_url\nfrom zerver.lib.scheduled_messages import get_undelivered_scheduled_messages\nfrom zerver.lib.soft_deactivation import reactivate_user_if_soft_deactivated\nfrom zerver.lib.sounds import get_available_notification_sounds\nfrom zerver.lib.stream_subscription import handle_stream_notifications_compatibility\nfrom zerver.lib.streams import do_get_streams, get_web_public_streams\nfrom zerver.lib.subscription_info import (\n    build_unsubscribed_sub_from_stream_dict,\n    gather_subscriptions_helper,\n    get_web_public_subs,\n)\nfrom zerver.lib.timestamp import datetime_to_timestamp\nfrom zerver.lib.timezone import canonicalize_timezone\nfrom zerver.lib.topic import TOPIC_NAME\nfrom zerver.lib.user_groups import user_groups_in_realm_serialized\nfrom zerver.lib.user_status import get_user_status_dict\nfrom zerver.lib.user_topics import get_topic_mutes, get_user_topics\nfrom zerver.lib.users import get_cross_realm_dicts, get_raw_user_data, is_administrator_role\nfrom zerver.models import (\n    MAX_TOPIC_NAME_LENGTH,\n    Client,\n    CustomProfileField,\n    Draft,\n    Message,\n    Realm,\n    RealmUserDefault,\n    Recipient,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    UserStatus,\n    UserTopic,\n    custom_profile_fields_for_realm,\n    get_default_stream_groups,\n    get_realm_domains,\n    get_realm_playgrounds,\n    linkifiers_for_realm,\n)\nfrom zerver.tornado.django_api import get_user_events, request_event_queue\nfrom zproject.backends import email_auth_enabled, password_auth_enabled\n\n\nclass RestartEventError(Exception):\n    \"\"\"\n    Special error for handling restart events in apply_events.\n    \"\"\"\n\n\ndef add_realm_logo_fields(state: Dict[str, Any], realm: Realm) -> None:\n    state[\"realm_logo_url\"] = get_realm_logo_url(realm, night=False)\n    state[\"realm_logo_source\"] = get_realm_logo_source(realm, night=False)\n    state[\"realm_night_logo_url\"] = get_realm_logo_url(realm, night=True)\n    state[\"realm_night_logo_source\"] = get_realm_logo_source(realm, night=True)\n    state[\"max_logo_file_size_mib\"] = settings.MAX_LOGO_FILE_SIZE_MIB\n\n\ndef always_want(msg_type: str) -> bool:\n    \"\"\"\n    This function is used as a helper in\n    fetch_initial_state_data, when the user passes\n    in None for event_types, and we want to fetch\n    info for every event type.  Defining this at module\n    level makes it easier to mock.\n    \"\"\"\n    return True\n\n\ndef fetch_initial_state_data(\n    user_profile: Optional[UserProfile],\n    *,\n    realm: Optional[Realm] = None,\n    event_types: Optional[Iterable[str]] = None,\n    queue_id: Optional[str] = \"\",\n    client_gravatar: bool = False,\n    user_avatar_url_field_optional: bool = False,\n    user_settings_object: bool = False,\n    slim_presence: bool = False,\n    include_subscribers: bool = True,\n    include_streams: bool = True,\n    spectator_requested_language: Optional[str] = None,\n    pronouns_field_type_supported: bool = True,\n    linkifier_url_template: bool = False,\n) -> Dict[str, Any]:\n    \"\"\"When `event_types` is None, fetches the core data powering the\n    web app's `page_params` and `/api/v1/register` (for mobile/terminal\n    apps).  Can also fetch a subset as determined by `event_types`.\n\n    The user_profile=None code path is used for logged-out public\n    access to streams with is_web_public=True.\n\n    Whenever you add new code to this function, you should also add\n    corresponding events for changes in the data structures and new\n    code to apply_events (and add a test in test_events.py).\n    \"\"\"\n    if realm is None:\n        assert user_profile is not None\n        realm = user_profile.realm\n\n    state: Dict[str, Any] = {\"queue_id\": queue_id}\n\n    if event_types is None:\n        # return True always\n        want: Callable[[str], bool] = always_want\n    else:\n        want = set(event_types).__contains__\n\n    # Show the version info unconditionally.\n    state[\"zulip_version\"] = ZULIP_VERSION\n    state[\"zulip_feature_level\"] = API_FEATURE_LEVEL\n    state[\"zulip_merge_base\"] = ZULIP_MERGE_BASE\n\n    if want(\"alert_words\"):\n        state[\"alert_words\"] = [] if user_profile is None else user_alert_words(user_profile)\n\n    if want(\"custom_profile_fields\"):\n        if user_profile is None:\n            # Spectators can't access full user profiles or\n            # personal settings, so we send an empty list.\n            state[\"custom_profile_fields\"] = []\n        else:\n            fields = custom_profile_fields_for_realm(realm.id)\n            state[\"custom_profile_fields\"] = [f.as_dict() for f in fields]\n        state[\"custom_profile_field_types\"] = {\n            item[4]: {\"id\": item[0], \"name\": str(item[1])}\n            for item in CustomProfileField.ALL_FIELD_TYPES\n        }\n\n        if not pronouns_field_type_supported:\n            for field in state[\"custom_profile_fields\"]:\n                if field[\"type\"] == CustomProfileField.PRONOUNS:\n                    field[\"type\"] = CustomProfileField.SHORT_TEXT\n\n            del state[\"custom_profile_field_types\"][\"PRONOUNS\"]\n\n    if want(\"hotspots\"):\n        # Even if we offered special hotspots for guests without an\n        # account, we'd maybe need to store their state using cookies\n        # or local storage, rather than in the database.\n        state[\"hotspots\"] = [] if user_profile is None else get_next_hotspots(user_profile)\n\n    if want(\"message\"):\n        # Since the introduction of `anchor=\"latest\"` in the API,\n        # `max_message_id` is primarily used for generating `local_id`\n        # values that are higher than this.  We likely can eventually\n        # remove this parameter from the API.\n        user_messages = None\n        if user_profile is not None:\n            user_messages = (\n                UserMessage.objects.filter(user_profile=user_profile)\n                .order_by(\"-message_id\")\n                .values(\"message_id\")[:1]\n            )\n        if user_messages:\n            state[\"max_message_id\"] = user_messages[0][\"message_id\"]\n        else:\n            state[\"max_message_id\"] = -1\n\n    if want(\"drafts\"):\n        if user_profile is None:\n            state[\"drafts\"] = []\n        else:\n            # Note: if a user ever disables syncing drafts then all of\n            # their old drafts stored on the server will be deleted and\n            # simply retained in local storage. In which case user_drafts\n            # would just be an empty queryset.\n            user_draft_objects = Draft.objects.filter(user_profile=user_profile).order_by(\n                \"-last_edit_time\"\n            )[: settings.MAX_DRAFTS_IN_REGISTER_RESPONSE]\n            user_draft_dicts = [draft.to_dict() for draft in user_draft_objects]\n            state[\"drafts\"] = user_draft_dicts\n\n    if want(\"scheduled_messages\"):\n        state[\"scheduled_messages\"] = (\n            [] if user_profile is None else get_undelivered_scheduled_messages(user_profile)\n        )\n\n    if want(\"muted_topics\") and (\n        # Suppress muted_topics data for clients that explicitly\n        # support user_topic. This allows clients to request both the\n        # user_topic and muted_topics, and receive the duplicate\n        # muted_topics data only from older servers that don't yet\n        # support user_topic.\n        event_types is None\n        or not want(\"user_topic\")\n    ):\n        state[\"muted_topics\"] = [] if user_profile is None else get_topic_mutes(user_profile)\n\n    if want(\"muted_users\"):\n        state[\"muted_users\"] = [] if user_profile is None else get_user_mutes(user_profile)\n\n    if want(\"presence\"):\n        state[\"presences\"] = (\n            {} if user_profile is None else get_presences_for_realm(realm, slim_presence)\n        )\n        # Send server_timestamp, to match the format of `GET /presence` requests.\n        state[\"server_timestamp\"] = time.time()\n\n    if want(\"realm\"):\n        # The realm bundle includes both realm properties and server\n        # properties, since it's rare that one would want one and not\n        # the other. We expect most clients to want it.\n        #\n        # A note on naming: For some settings, one could imagine\n        # having a server-level value and a realm-level value (with\n        # the server value serving as the default for the realm\n        # value). For such settings, we prefer the following naming\n        # scheme:\n        #\n        # * realm_inline_image_preview (current realm setting)\n        # * server_inline_image_preview (server-level default)\n        #\n        # In situations where for backwards-compatibility reasons we\n        # have an unadorned name, we should arrange that clients using\n        # that unadorned name work correctly (i.e. that should be the\n        # currently active setting, not a server-level default).\n        #\n        # Other settings, which are just server-level settings or data\n        # about the version of Zulip, can be named without prefixes,\n        # e.g. giphy_rating_options or development_environment.\n        for property_name in Realm.property_types:\n            state[\"realm_\" + property_name] = getattr(realm, property_name)\n\n        # Most state is handled via the property_types framework;\n        # these manual entries are for those realm settings that don't\n        # fit into that framework.\n        realm_authentication_methods_dict = realm.authentication_methods_dict()\n        state[\"realm_authentication_methods\"] = realm_authentication_methods_dict\n\n        # We pretend these features are disabled because anonymous\n        # users can't access them.  In the future, we may want to move\n        # this logic to the frontends, so that we can correctly\n        # display what these fields are in the settings.\n        state[\"realm_allow_message_editing\"] = (\n            False if user_profile is None else realm.allow_message_editing\n        )\n        state[\"realm_edit_topic_policy\"] = (\n            Realm.POLICY_ADMINS_ONLY if user_profile is None else realm.edit_topic_policy\n        )\n        state[\"realm_delete_own_message_policy\"] = (\n            Realm.POLICY_ADMINS_ONLY if user_profile is None else realm.delete_own_message_policy\n        )\n\n        # This setting determines whether to send presence and also\n        # whether to display of users list in the right sidebar; we\n        # want both behaviors for logged-out users.  We may in the\n        # future choose to move this logic to the frontend.\n        state[\"realm_presence_disabled\"] = True if user_profile is None else realm.presence_disabled\n\n        # Important: Encode units in the client-facing API name.\n        state[\"max_avatar_file_size_mib\"] = settings.MAX_AVATAR_FILE_SIZE_MIB\n        state[\"max_file_upload_size_mib\"] = settings.MAX_FILE_UPLOAD_SIZE\n        state[\"max_icon_file_size_mib\"] = settings.MAX_ICON_FILE_SIZE_MIB\n        state[\"realm_upload_quota_mib\"] = realm.upload_quota_bytes()\n\n        state[\"realm_icon_url\"] = realm_icon_url(realm)\n        state[\"realm_icon_source\"] = realm.icon_source\n        add_realm_logo_fields(state, realm)\n\n        state[\"realm_uri\"] = realm.uri\n        state[\"realm_bot_domain\"] = realm.get_bot_domain()\n        state[\"realm_available_video_chat_providers\"] = realm.VIDEO_CHAT_PROVIDERS\n        state[\"settings_send_digest_emails\"] = settings.SEND_DIGEST_EMAILS\n\n        state[\"realm_digest_emails_enabled\"] = (\n            realm.digest_emails_enabled and settings.SEND_DIGEST_EMAILS\n        )\n        state[\"realm_email_auth_enabled\"] = email_auth_enabled(\n            realm, realm_authentication_methods_dict\n        )\n        state[\"realm_password_auth_enabled\"] = password_auth_enabled(\n            realm, realm_authentication_methods_dict\n        )\n\n        state[\"server_generation\"] = settings.SERVER_GENERATION\n        state[\"realm_is_zephyr_mirror_realm\"] = realm.is_zephyr_mirror_realm\n        state[\"development_environment\"] = settings.DEVELOPMENT\n        state[\"realm_org_type\"] = realm.org_type\n        state[\"realm_plan_type\"] = realm.plan_type\n        state[\"zulip_plan_is_not_limited\"] = realm.plan_type != Realm.PLAN_TYPE_LIMITED\n        state[\"upgrade_text_for_wide_organization_logo\"] = str(Realm.UPGRADE_TEXT_STANDARD)\n\n        state[\"password_min_length\"] = settings.PASSWORD_MIN_LENGTH\n        state[\"password_min_guesses\"] = settings.PASSWORD_MIN_GUESSES\n        state[\"server_inline_image_preview\"] = settings.INLINE_IMAGE_PREVIEW\n        state[\"server_inline_url_embed_preview\"] = settings.INLINE_URL_EMBED_PREVIEW\n        state[\"server_avatar_changes_disabled\"] = settings.AVATAR_CHANGES_DISABLED\n        state[\"server_name_changes_disabled\"] = settings.NAME_CHANGES_DISABLED\n        state[\"server_web_public_streams_enabled\"] = settings.WEB_PUBLIC_STREAMS_ENABLED\n        state[\"giphy_rating_options\"] = realm.get_giphy_rating_options()\n\n        state[\"server_emoji_data_url\"] = emoji.data_url()\n\n        state[\"server_needs_upgrade\"] = is_outdated_server(user_profile)\n        state[\n            \"event_queue_longpoll_timeout_seconds\"\n        ] = settings.EVENT_QUEUE_LONGPOLL_TIMEOUT_SECONDS\n\n        # TODO: Should these have the realm prefix replaced with server_?\n        state[\"realm_push_notifications_enabled\"] = push_notifications_enabled()\n        state[\"realm_default_external_accounts\"] = get_default_external_accounts()\n\n        if settings.JITSI_SERVER_URL is not None:\n            state[\"jitsi_server_url\"] = settings.JITSI_SERVER_URL.rstrip(\"/\")\n        else:  # nocoverage\n            state[\"jitsi_server_url\"] = None\n\n        if realm.notifications_stream and not realm.notifications_stream.deactivated:\n            notifications_stream = realm.notifications_stream\n            state[\"realm_notifications_stream_id\"] = notifications_stream.id\n        else:\n            state[\"realm_notifications_stream_id\"] = -1\n\n        signup_notifications_stream = realm.get_signup_notifications_stream()\n        if signup_notifications_stream:\n            state[\"realm_signup_notifications_stream_id\"] = signup_notifications_stream.id\n        else:\n            state[\"realm_signup_notifications_stream_id\"] = -1\n\n        state[\"max_stream_name_length\"] = Stream.MAX_NAME_LENGTH\n        state[\"max_stream_description_length\"] = Stream.MAX_DESCRIPTION_LENGTH\n        state[\"max_topic_length\"] = MAX_TOPIC_NAME_LENGTH\n        state[\"max_message_length\"] = settings.MAX_MESSAGE_LENGTH\n        if realm.demo_organization_scheduled_deletion_date is not None:\n            state[\"demo_organization_scheduled_deletion_date\"] = datetime_to_timestamp(\n                realm.demo_organization_scheduled_deletion_date\n            )\n\n        # Presence system parameters for client behavior.\n        state[\"server_presence_ping_interval_seconds\"] = settings.PRESENCE_PING_INTERVAL_SECS\n        state[\"server_presence_offline_threshold_seconds\"] = settings.OFFLINE_THRESHOLD_SECS\n\n    if want(\"realm_user_settings_defaults\"):\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        state[\"realm_user_settings_defaults\"] = {}\n        for property_name in RealmUserDefault.property_types:\n            state[\"realm_user_settings_defaults\"][property_name] = getattr(\n                realm_user_default, property_name\n            )\n\n        state[\"realm_user_settings_defaults\"][\n            \"emojiset_choices\"\n        ] = RealmUserDefault.emojiset_choices()\n        state[\"realm_user_settings_defaults\"][\n            \"available_notification_sounds\"\n        ] = get_available_notification_sounds()\n\n    if want(\"realm_domains\"):\n        state[\"realm_domains\"] = get_realm_domains(realm)\n\n    if want(\"realm_emoji\"):\n        state[\"realm_emoji\"] = realm.get_emoji()\n\n    if want(\"realm_linkifiers\"):\n        if linkifier_url_template:\n            state[\"realm_linkifiers\"] = linkifiers_for_realm(realm.id)\n        else:\n            # When URL template is not supported by the client, return an empty list\n            # because the new format is incompatible with the old URL format strings\n            # and the client would not render it properly.\n            state[\"realm_linkifiers\"] = []\n\n    # Backwards compatibility code.\n    if want(\"realm_filters\"):\n        # Always return an empty list because the new URL template format is incompatible\n        # with the old URL format string, because legacy clients that use the\n        # backwards-compatible `realm_filters` event would not render the it properly.\n        state[\"realm_filters\"] = []\n\n    if want(\"realm_playgrounds\"):\n        state[\"realm_playgrounds\"] = get_realm_playgrounds(realm)\n\n    if want(\"realm_user_groups\"):\n        state[\"realm_user_groups\"] = user_groups_in_realm_serialized(realm)\n\n    if user_profile is not None:\n        settings_user = user_profile\n    else:\n        assert spectator_requested_language is not None\n        # When UserProfile=None, we want to serve the values for various\n        # settings as the defaults.  Instead of copying the default values\n        # from models.py here, we access these default values from a\n        # temporary UserProfile object that will not be saved to the database.\n        #\n        # We also can set various fields to avoid duplicating code\n        # unnecessarily.\n        settings_user = UserProfile(\n            full_name=\"Anonymous User\",\n            email=\"username@example.com\",\n            delivery_email=\"username@example.com\",\n            realm=realm,\n            # We tag logged-out users as guests because most guest\n            # restrictions apply to these users as well, and it lets\n            # us avoid unnecessary conditionals.\n            role=UserProfile.ROLE_GUEST,\n            is_billing_admin=False,\n            avatar_source=UserProfile.AVATAR_FROM_GRAVATAR,\n            # ID=0 is not used in real Zulip databases, ensuring this is unique.\n            id=0,\n            default_language=spectator_requested_language,\n        )\n    if want(\"realm_user\"):\n        state[\"raw_users\"] = get_raw_user_data(\n            realm,\n            user_profile,\n            client_gravatar=client_gravatar,\n            user_avatar_url_field_optional=user_avatar_url_field_optional,\n            # Don't send custom profile field values to spectators.\n            include_custom_profile_fields=user_profile is not None,\n        )\n        state[\"cross_realm_bots\"] = list(get_cross_realm_dicts())\n\n        # For the user's own avatar URL, we force\n        # client_gravatar=False, since that saves some unnecessary\n        # client-side code for handing medium-size avatars.  See #8253\n        # for details.\n        state[\"avatar_source\"] = settings_user.avatar_source\n        state[\"avatar_url_medium\"] = avatar_url(\n            settings_user,\n            medium=True,\n            client_gravatar=False,\n        )\n        state[\"avatar_url\"] = avatar_url(\n            settings_user,\n            medium=False,\n            client_gravatar=False,\n        )\n\n        state[\"can_create_private_streams\"] = settings_user.can_create_private_streams()\n        state[\"can_create_public_streams\"] = settings_user.can_create_public_streams()\n        # TODO/compatibility: Deprecated in Zulip 5.0 (feature level\n        # 102); we can remove this once we no longer need to support\n        # legacy mobile app versions that read the old property.\n        state[\"can_create_streams\"] = (\n            settings_user.can_create_private_streams()\n            or settings_user.can_create_public_streams()\n            or settings_user.can_create_web_public_streams()\n        )\n        state[\"can_create_web_public_streams\"] = settings_user.can_create_web_public_streams()\n        state[\"can_subscribe_other_users\"] = settings_user.can_subscribe_other_users()\n        state[\"can_invite_others_to_realm\"] = settings_user.can_invite_others_to_realm()\n        state[\"is_admin\"] = settings_user.is_realm_admin\n        state[\"is_owner\"] = settings_user.is_realm_owner\n        state[\"is_moderator\"] = settings_user.is_moderator\n        state[\"is_guest\"] = settings_user.is_guest\n        state[\"is_billing_admin\"] = settings_user.is_billing_admin\n        state[\"user_id\"] = settings_user.id\n        state[\"email\"] = settings_user.email\n        state[\"delivery_email\"] = settings_user.delivery_email\n        state[\"full_name\"] = settings_user.full_name\n\n    if want(\"realm_bot\"):\n        state[\"realm_bots\"] = [] if user_profile is None else get_owned_bot_dicts(user_profile)\n\n    # This does not yet have an apply_event counterpart, since currently,\n    # new entries for EMBEDDED_BOTS can only be added directly in the codebase.\n    if want(\"realm_embedded_bots\"):\n        realm_embedded_bots = []\n        for bot in EMBEDDED_BOTS:\n            realm_embedded_bots.append(\n                {\"name\": bot.name, \"config\": load_bot_config_template(bot.name)}\n            )\n        state[\"realm_embedded_bots\"] = realm_embedded_bots\n\n    # This does not have an apply_events counterpart either since\n    # this data is mostly static.\n    if want(\"realm_incoming_webhook_bots\"):\n        realm_incoming_webhook_bots = []\n        for integration in WEBHOOK_INTEGRATIONS:\n            realm_incoming_webhook_bots.append(\n                {\n                    \"name\": integration.name,\n                    \"config\": {c[1]: c[0] for c in integration.config_options},\n                }\n            )\n        state[\"realm_incoming_webhook_bots\"] = realm_incoming_webhook_bots\n\n    if want(\"recent_private_conversations\"):\n        # A data structure containing records of this form:\n        #\n        #   [{'max_message_id': 700175, 'user_ids': [801]}]\n        #\n        # for all recent private message conversations, ordered by the\n        # highest message ID in the conversation.  The user_ids list\n        # is the list of users other than the current user in the\n        # private message conversation (so it is [] for PMs to self).\n        # Note that raw_recent_private_conversations is an\n        # intermediate form as a dictionary keyed by recipient_id,\n        # which is more efficient to update, and is rewritten to the\n        # final format in post_process_state.\n        state[\"raw_recent_private_conversations\"] = (\n            {} if user_profile is None else get_recent_private_conversations(user_profile)\n        )\n\n    if want(\"subscription\"):\n        if user_profile is not None:\n            sub_info = gather_subscriptions_helper(\n                user_profile,\n                include_subscribers=include_subscribers,\n            )\n        else:\n            sub_info = get_web_public_subs(realm)\n\n        state[\"subscriptions\"] = sub_info.subscriptions\n        state[\"unsubscribed\"] = sub_info.unsubscribed\n        state[\"never_subscribed\"] = sub_info.never_subscribed\n\n    if want(\"update_message_flags\") and want(\"message\"):\n        # Keeping unread_msgs updated requires both message flag updates and\n        # message updates. This is due to the fact that new messages will not\n        # generate a flag update so we need to use the flags field in the\n        # message event.\n\n        if user_profile is not None:\n            state[\"raw_unread_msgs\"] = get_raw_unread_data(user_profile)\n        else:\n            # For logged-out visitors, we treat all messages as read;\n            # calling this helper lets us return empty objects in the\n            # appropriate format.\n            state[\"raw_unread_msgs\"] = extract_unread_data_from_um_rows([], user_profile)\n\n    if want(\"starred_messages\"):\n        state[\"starred_messages\"] = (\n            [] if user_profile is None else get_starred_message_ids(user_profile)\n        )\n\n    if want(\"stream\") and include_streams:\n        # The web app doesn't use the data from here; instead,\n        # it uses data from state[\"subscriptions\"] and other\n        # places.\n        if user_profile is not None:\n            state[\"streams\"] = do_get_streams(\n                user_profile,\n                include_web_public=True,\n                include_all_active=user_profile.is_realm_admin,\n            )\n        else:\n            # TODO: This line isn't used by the web app because it\n            # gets these data via the `subscriptions` key; it will\n            # be used when the mobile apps support logged-out\n            # access.\n            state[\"streams\"] = get_web_public_streams(realm)  # nocoverage\n    if want(\"default_streams\"):\n        if settings_user.is_guest:\n            # Guest users and logged-out users don't have access to\n            # all default streams, so we pretend the organization\n            # doesn't have any.\n            state[\"realm_default_streams\"] = []\n        else:\n            state[\"realm_default_streams\"] = streams_to_dicts_sorted(\n                get_default_streams_for_realm(realm.id)\n            )\n    if want(\"default_stream_groups\"):\n        if settings_user.is_guest:\n            state[\"realm_default_stream_groups\"] = []\n        else:\n            state[\"realm_default_stream_groups\"] = default_stream_groups_to_dicts_sorted(\n                get_default_stream_groups(realm)\n            )\n\n    if want(\"stop_words\"):\n        state[\"stop_words\"] = read_stop_words()\n\n    if want(\"update_display_settings\") and not user_settings_object:\n        for prop in UserProfile.display_settings_legacy:\n            state[prop] = getattr(settings_user, prop)\n        state[\"emojiset_choices\"] = UserProfile.emojiset_choices()\n        state[\"timezone\"] = canonicalize_timezone(settings_user.timezone)\n\n    if want(\"update_global_notifications\") and not user_settings_object:\n        for notification in UserProfile.notification_settings_legacy:\n            state[notification] = getattr(settings_user, notification)\n        state[\"available_notification_sounds\"] = get_available_notification_sounds()\n\n    if want(\"user_settings\"):\n        state[\"user_settings\"] = {}\n\n        for prop in UserProfile.property_types:\n            state[\"user_settings\"][prop] = getattr(settings_user, prop)\n\n        state[\"user_settings\"][\"emojiset_choices\"] = UserProfile.emojiset_choices()\n        state[\"user_settings\"][\"timezone\"] = canonicalize_timezone(settings_user.timezone)\n        state[\"user_settings\"][\n            \"available_notification_sounds\"\n        ] = get_available_notification_sounds()\n\n    if want(\"user_status\"):\n        # We require creating an account to access statuses.\n        state[\"user_status\"] = (\n            {} if user_profile is None else get_user_status_dict(realm_id=realm.id)\n        )\n\n    if want(\"user_topic\"):\n        state[\"user_topics\"] = [] if user_profile is None else get_user_topics(user_profile)\n\n    if want(\"video_calls\"):\n        state[\"has_zoom_token\"] = settings_user.zoom_token is not None\n\n    if want(\"giphy\"):\n        # Normally, it would be a nasty security bug to send a\n        # server's API key to end users. However, GIPHY's API key\n        # security model is precisely to do that; every service\n        # publishes its API key (and GIPHY's client-side JS libraries\n        # require the API key to work).  This security model makes\n        # sense because GIPHY API keys are all essentially equivalent\n        # in letting one search for GIFs; GIPHY only requires API keys\n        # to exist at all so that they can deactivate them in cases of\n        # abuse.\n        state[\"giphy_api_key\"] = settings.GIPHY_API_KEY if settings.GIPHY_API_KEY else \"\"\n\n    if user_profile is None:\n        # To ensure we have the correct user state set.\n        assert state[\"is_admin\"] is False\n        assert state[\"is_owner\"] is False\n        assert state[\"is_guest\"] is True\n\n    return state\n\n\ndef apply_events(\n    user_profile: UserProfile,\n    *,\n    state: Dict[str, Any],\n    events: Iterable[Dict[str, Any]],\n    fetch_event_types: Optional[Collection[str]],\n    client_gravatar: bool,\n    slim_presence: bool,\n    include_subscribers: bool,\n    linkifier_url_template: bool,\n) -> None:\n    for event in events:\n        if event[\"type\"] == \"restart\":\n            raise RestartEventError\n        if fetch_event_types is not None and event[\"type\"] not in fetch_event_types:\n            # TODO: continuing here is not, most precisely, correct.\n            # In theory, an event of one type, e.g. `realm_user`,\n            # could modify state that doesn't come from that\n            # `fetch_event_types` value, e.g. the `our_person` part of\n            # that code path.  But it should be extremely rare, and\n            # fixing that will require a nontrivial refactor of\n            # `apply_event`.  For now, be careful in your choice of\n            # `fetch_event_types`.\n            continue\n        apply_event(\n            user_profile,\n            state=state,\n            event=event,\n            client_gravatar=client_gravatar,\n            slim_presence=slim_presence,\n            include_subscribers=include_subscribers,\n            linkifier_url_template=linkifier_url_template,\n        )\n\n\ndef apply_event(\n    user_profile: UserProfile,\n    *,\n    state: Dict[str, Any],\n    event: Dict[str, Any],\n    client_gravatar: bool,\n    slim_presence: bool,\n    include_subscribers: bool,\n    linkifier_url_template: bool,\n) -> None:\n    if event[\"type\"] == \"message\":\n        state[\"max_message_id\"] = max(state[\"max_message_id\"], event[\"message\"][\"id\"])\n        if \"raw_unread_msgs\" in state:\n            apply_unread_message_event(\n                user_profile,\n                state[\"raw_unread_msgs\"],\n                event[\"message\"],\n                event[\"flags\"],\n            )\n\n        if event[\"message\"][\"type\"] != \"stream\":\n            if \"raw_recent_private_conversations\" in state:\n                # Handle maintaining the recent_private_conversations data structure.\n                conversations = state[\"raw_recent_private_conversations\"]\n                recipient_id = get_recent_conversations_recipient_id(\n                    user_profile, event[\"message\"][\"recipient_id\"], event[\"message\"][\"sender_id\"]\n                )\n\n                if recipient_id not in conversations:\n                    conversations[recipient_id] = dict(\n                        user_ids=sorted(\n                            user_dict[\"id\"]\n                            for user_dict in event[\"message\"][\"display_recipient\"]\n                            if user_dict[\"id\"] != user_profile.id\n                        ),\n                    )\n                conversations[recipient_id][\"max_message_id\"] = event[\"message\"][\"id\"]\n            return\n\n        # Below, we handle maintaining first_message_id.\n        for sub_dict in state.get(\"subscriptions\", []):\n            if (\n                event[\"message\"][\"stream_id\"] == sub_dict[\"stream_id\"]\n                and sub_dict[\"first_message_id\"] is None\n            ):\n                sub_dict[\"first_message_id\"] = event[\"message\"][\"id\"]\n        for stream_dict in state.get(\"streams\", []):\n            if (\n                event[\"message\"][\"stream_id\"] == stream_dict[\"stream_id\"]\n                and stream_dict[\"first_message_id\"] is None\n            ):\n                stream_dict[\"first_message_id\"] = event[\"message\"][\"id\"]\n\n    elif event[\"type\"] == \"heartbeat\":\n        # It may be impossible for a heartbeat event to actually reach\n        # this code path. But in any case, they're noops.\n        pass\n\n    elif event[\"type\"] == \"drafts\":\n        if event[\"op\"] == \"add\":\n            state[\"drafts\"].extend(event[\"drafts\"])\n        else:\n            if event[\"op\"] == \"update\":\n                event_draft_idx = event[\"draft\"][\"id\"]\n\n                def _draft_update_action(i: int) -> None:\n                    state[\"drafts\"][i] = event[\"draft\"]\n\n            elif event[\"op\"] == \"remove\":\n                event_draft_idx = event[\"draft_id\"]\n\n                def _draft_update_action(i: int) -> None:\n                    del state[\"drafts\"][i]\n\n            # We have to perform a linear search for the draft that\n            # was either edited or removed since we have a list\n            # ordered by the last edited timestamp and not id.\n            state_draft_idx = None\n            for idx, draft in enumerate(state[\"drafts\"]):\n                if draft[\"id\"] == event_draft_idx:\n                    state_draft_idx = idx\n                    break\n            assert state_draft_idx is not None\n            _draft_update_action(state_draft_idx)\n\n    elif event[\"type\"] == \"scheduled_messages\":\n        if event[\"op\"] == \"add\":\n            # Since bulk addition of scheduled messages will not be used by a normal user.\n            assert len(event[\"scheduled_messages\"]) == 1\n\n            state[\"scheduled_messages\"].append(event[\"scheduled_messages\"][0])\n            # Sort in ascending order of scheduled_delivery_timestamp.\n            state[\"scheduled_messages\"].sort(\n                key=lambda scheduled_message: scheduled_message[\"scheduled_delivery_timestamp\"]\n            )\n\n        if event[\"op\"] == \"update\":\n            for idx, scheduled_message in enumerate(state[\"scheduled_messages\"]):\n                if (\n                    scheduled_message[\"scheduled_message_id\"]\n                    == event[\"scheduled_message\"][\"scheduled_message_id\"]\n                ):\n                    state[\"scheduled_messages\"][idx] = event[\"scheduled_message\"]\n                    # If scheduled_delivery_timestamp was changed, we need to sort it again.\n                    if (\n                        scheduled_message[\"scheduled_delivery_timestamp\"]\n                        != event[\"scheduled_message\"][\"scheduled_delivery_timestamp\"]\n                    ):\n                        state[\"scheduled_messages\"].sort(\n                            key=lambda scheduled_message: scheduled_message[\n                                \"scheduled_delivery_timestamp\"\n                            ]\n                        )\n                    break\n\n        if event[\"op\"] == \"remove\":\n            for idx, scheduled_message in enumerate(state[\"scheduled_messages\"]):\n                if scheduled_message[\"scheduled_message_id\"] == event[\"scheduled_message_id\"]:\n                    del state[\"scheduled_messages\"][idx]\n\n    elif event[\"type\"] == \"hotspots\":\n        state[\"hotspots\"] = event[\"hotspots\"]\n    elif event[\"type\"] == \"custom_profile_fields\":\n        state[\"custom_profile_fields\"] = event[\"fields\"]\n        custom_profile_field_ids = {field[\"id\"] for field in state[\"custom_profile_fields\"]}\n\n        if \"raw_users\" in state:\n            for user_dict in state[\"raw_users\"].values():\n                if \"profile_data\" not in user_dict:\n                    continue\n                profile_data = user_dict[\"profile_data\"]\n                for field_id, field_data in list(profile_data.items()):\n                    if int(field_id) not in custom_profile_field_ids:\n                        del profile_data[field_id]\n    elif event[\"type\"] == \"realm_user\":\n        person = event[\"person\"]\n        person_user_id = person[\"user_id\"]\n\n        if event[\"op\"] == \"add\":\n            person = copy.deepcopy(person)\n\n            if client_gravatar:\n                email_address_visibility = UserProfile.objects.get(\n                    id=person_user_id\n                ).email_address_visibility\n                if email_address_visibility != UserProfile.EMAIL_ADDRESS_VISIBILITY_EVERYONE:\n                    client_gravatar = False\n\n            if client_gravatar and person[\"avatar_url\"].startswith(\"https://secure.gravatar.com/\"):\n                person[\"avatar_url\"] = None\n            person[\"is_active\"] = True\n            if not person[\"is_bot\"]:\n                person[\"profile_data\"] = {}\n            state[\"raw_users\"][person_user_id] = person\n        elif event[\"op\"] == \"remove\":\n            state[\"raw_users\"][person_user_id][\"is_active\"] = False\n            if include_subscribers:\n                for sub in state[\"subscriptions\"]:\n                    sub[\"subscribers\"] = [\n                        user_id for user_id in sub[\"subscribers\"] if user_id != person_user_id\n                    ]\n        elif event[\"op\"] == \"update\":\n            is_me = person_user_id == user_profile.id\n\n            if is_me:\n                if \"avatar_url\" in person and \"avatar_url\" in state:\n                    state[\"avatar_source\"] = person[\"avatar_source\"]\n                    state[\"avatar_url\"] = person[\"avatar_url\"]\n                    state[\"avatar_url_medium\"] = person[\"avatar_url_medium\"]\n\n                if \"role\" in person:\n                    state[\"is_admin\"] = is_administrator_role(person[\"role\"])\n                    state[\"is_owner\"] = person[\"role\"] == UserProfile.ROLE_REALM_OWNER\n                    state[\"is_moderator\"] = person[\"role\"] == UserProfile.ROLE_MODERATOR\n                    state[\"is_guest\"] = person[\"role\"] == UserProfile.ROLE_GUEST\n                    # Recompute properties based on is_admin/is_guest\n                    state[\"can_create_private_streams\"] = user_profile.can_create_private_streams()\n                    state[\"can_create_public_streams\"] = user_profile.can_create_public_streams()\n                    state[\n                        \"can_create_web_public_streams\"\n                    ] = user_profile.can_create_web_public_streams()\n                    state[\"can_create_streams\"] = (\n                        state[\"can_create_private_streams\"]\n                        or state[\"can_create_public_streams\"]\n                        or state[\"can_create_web_public_streams\"]\n                    )\n                    state[\"can_subscribe_other_users\"] = user_profile.can_subscribe_other_users()\n                    state[\"can_invite_others_to_realm\"] = user_profile.can_invite_others_to_realm()\n\n                    # TODO: Probably rather than writing the perfect\n                    # live-update code for the case of racing with the\n                    # current user changing roles, we should just do a\n                    # full refetch.\n                    if \"never_subscribed\" in state:\n                        sub_info = gather_subscriptions_helper(\n                            user_profile,\n                            include_subscribers=include_subscribers,\n                        )\n                        state[\"subscriptions\"] = sub_info.subscriptions\n                        state[\"unsubscribed\"] = sub_info.unsubscribed\n                        state[\"never_subscribed\"] = sub_info.never_subscribed\n\n                    if \"streams\" in state:\n                        state[\"streams\"] = do_get_streams(\n                            user_profile,\n                            include_web_public=True,\n                            include_all_active=user_profile.is_realm_admin,\n                        )\n\n                    if state[\"is_guest\"]:\n                        state[\"realm_default_streams\"] = []\n                    else:\n                        state[\"realm_default_streams\"] = streams_to_dicts_sorted(\n                            get_default_streams_for_realm(user_profile.realm_id)\n                        )\n\n                for field in [\"delivery_email\", \"email\", \"full_name\", \"is_billing_admin\"]:\n                    if field in person and field in state:\n                        state[field] = person[field]\n\n                if \"new_email\" in person:\n                    state[\"email\"] = person[\"new_email\"]\n\n                # In the unlikely event that the current user\n                # just changed to/from being an admin, we need\n                # to add/remove the data on all bots in the\n                # realm.  This is ugly and probably better\n                # solved by removing the all-realm-bots data\n                # given to admin users from this flow.\n                if \"role\" in person and \"realm_bots\" in state:\n                    prev_state = state[\"raw_users\"][user_profile.id]\n                    was_admin = prev_state[\"is_admin\"]\n                    now_admin = is_administrator_role(person[\"role\"])\n\n                    if was_admin and not now_admin:\n                        state[\"realm_bots\"] = []\n                    if not was_admin and now_admin:\n                        state[\"realm_bots\"] = get_owned_bot_dicts(user_profile)\n\n            if person_user_id in state[\"raw_users\"]:\n                p = state[\"raw_users\"][person_user_id]\n\n                if \"avatar_url\" in person:\n                    # Respect the client_gravatar setting in the `users` data.\n                    if client_gravatar:\n                        email_address_visibility = UserProfile.objects.get(\n                            id=person_user_id\n                        ).email_address_visibility\n                        if (\n                            email_address_visibility\n                            != UserProfile.EMAIL_ADDRESS_VISIBILITY_EVERYONE\n                        ):\n                            client_gravatar = False\n\n                    if client_gravatar and person[\"avatar_url\"].startswith(\n                        \"https://secure.gravatar.com/\"\n                    ):\n                        person[\"avatar_url\"] = None\n                        person[\"avatar_url_medium\"] = None\n\n                for field in p:\n                    if field in person:\n                        p[field] = person[field]\n                    if \"role\" in person:\n                        p[\"is_admin\"] = is_administrator_role(person[\"role\"])\n                        p[\"is_owner\"] = person[\"role\"] == UserProfile.ROLE_REALM_OWNER\n                        p[\"is_guest\"] = person[\"role\"] == UserProfile.ROLE_GUEST\n                    if \"is_billing_admin\" in person:\n                        p[\"is_billing_admin\"] = person[\"is_billing_admin\"]\n                    if \"custom_profile_field\" in person:\n                        custom_field_id = person[\"custom_profile_field\"][\"id\"]\n                        custom_field_new_value = person[\"custom_profile_field\"][\"value\"]\n                        if \"rendered_value\" in person[\"custom_profile_field\"]:\n                            p[\"profile_data\"][str(custom_field_id)] = {\n                                \"value\": custom_field_new_value,\n                                \"rendered_value\": person[\"custom_profile_field\"][\"rendered_value\"],\n                            }\n                        else:\n                            p[\"profile_data\"][str(custom_field_id)] = {\n                                \"value\": custom_field_new_value,\n                            }\n                    if \"new_email\" in person:\n                        p[\"email\"] = person[\"new_email\"]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"realm_bot\":\n        if event[\"op\"] == \"add\":\n            state[\"realm_bots\"].append(event[\"bot\"])\n        elif event[\"op\"] == \"remove\":\n            user_id = event[\"bot\"][\"user_id\"]\n            for bot in state[\"realm_bots\"]:\n                if bot[\"user_id\"] == user_id:\n                    bot[\"is_active\"] = False\n        elif event[\"op\"] == \"delete\":\n            state[\"realm_bots\"] = [\n                item for item in state[\"realm_bots\"] if item[\"user_id\"] != event[\"bot\"][\"user_id\"]\n            ]\n        elif event[\"op\"] == \"update\":\n            for bot in state[\"realm_bots\"]:\n                if bot[\"user_id\"] == event[\"bot\"][\"user_id\"]:\n                    if \"owner_id\" in event[\"bot\"]:\n                        bot_owner_id = event[\"bot\"][\"owner_id\"]\n                        bot[\"owner_id\"] = bot_owner_id\n                    else:\n                        bot.update(event[\"bot\"])\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"stream\":\n        if event[\"op\"] == \"create\":\n            for stream in event[\"streams\"]:\n                stream_data = copy.deepcopy(stream)\n                if include_subscribers:\n                    stream_data[\"subscribers\"] = []\n\n                # Here we need to query the database to check whether the\n                # user was previously subscribed. If they were, we need to\n                # include the stream in the unsubscribed list after adding\n                # personal subscription metadata (such as configured stream\n                # color; most of the other personal setting have no effect\n                # when not subscribed).\n                unsubscribed_stream_sub = Subscription.objects.filter(\n                    user_profile=user_profile,\n                    recipient__type_id=stream[\"stream_id\"],\n                    recipient__type=Recipient.STREAM,\n                ).values(\n                    *Subscription.API_FIELDS,\n                    \"recipient_id\",\n                    \"active\",\n                )\n\n                if len(unsubscribed_stream_sub) == 1:\n                    unsubscribed_stream_dict = build_unsubscribed_sub_from_stream_dict(\n                        user_profile, unsubscribed_stream_sub[0], stream_data\n                    )\n                    if include_subscribers:\n                        unsubscribed_stream_dict[\"subscribers\"] = []\n\n                    # The stream might have traffic, but we do not have the\n                    # data to compute it in the event, so we just set to\n                    # \"None\" here like we would do for newly created streams.\n                    #\n                    # TODO: Probably this should just be added to the event.\n                    unsubscribed_stream_dict[\"stream_weekly_traffic\"] = None\n                    state[\"unsubscribed\"].append(unsubscribed_stream_dict)\n                else:\n                    assert len(unsubscribed_stream_sub) == 0\n                    stream_data[\"stream_weekly_traffic\"] = None\n                    state[\"never_subscribed\"].append(stream_data)\n\n                if \"streams\" in state:\n                    state[\"streams\"].append(stream)\n\n            state[\"unsubscribed\"].sort(key=lambda elt: elt[\"name\"])\n            state[\"never_subscribed\"].sort(key=lambda elt: elt[\"name\"])\n            if \"streams\" in state:\n                state[\"streams\"].sort(key=lambda elt: elt[\"name\"])\n\n        if event[\"op\"] == \"delete\":\n            deleted_stream_ids = {stream[\"stream_id\"] for stream in event[\"streams\"]}\n            if \"streams\" in state:\n                state[\"streams\"] = [\n                    s for s in state[\"streams\"] if s[\"stream_id\"] not in deleted_stream_ids\n                ]\n            state[\"never_subscribed\"] = [\n                stream\n                for stream in state[\"never_subscribed\"]\n                if stream[\"stream_id\"] not in deleted_stream_ids\n            ]\n\n        if event[\"op\"] == \"update\":\n            # For legacy reasons, we call stream data 'subscriptions' in\n            # the state var here, for the benefit of the JS code.\n            for sub_list in [\n                state[\"subscriptions\"],\n                state[\"unsubscribed\"],\n                state[\"never_subscribed\"],\n            ]:\n                for obj in sub_list:\n                    if obj[\"name\"].lower() == event[\"name\"].lower():\n                        obj[event[\"property\"]] = event[\"value\"]\n                        if event[\"property\"] == \"description\":\n                            obj[\"rendered_description\"] = event[\"rendered_description\"]\n                        if event.get(\"history_public_to_subscribers\") is not None:\n                            obj[\"history_public_to_subscribers\"] = event[\n                                \"history_public_to_subscribers\"\n                            ]\n                        if event.get(\"is_web_public\") is not None:\n                            obj[\"is_web_public\"] = event[\"is_web_public\"]\n            # Also update the pure streams data\n            if \"streams\" in state:\n                for stream in state[\"streams\"]:\n                    if stream[\"name\"].lower() == event[\"name\"].lower():\n                        prop = event[\"property\"]\n                        if prop in stream:\n                            stream[prop] = event[\"value\"]\n                            if prop == \"description\":\n                                stream[\"rendered_description\"] = event[\"rendered_description\"]\n                            if event.get(\"history_public_to_subscribers\") is not None:\n                                stream[\"history_public_to_subscribers\"] = event[\n                                    \"history_public_to_subscribers\"\n                                ]\n                            if event.get(\"is_web_public\") is not None:\n                                stream[\"is_web_public\"] = event[\"is_web_public\"]\n\n    elif event[\"type\"] == \"default_streams\":\n        state[\"realm_default_streams\"] = event[\"default_streams\"]\n    elif event[\"type\"] == \"default_stream_groups\":\n        state[\"realm_default_stream_groups\"] = event[\"default_stream_groups\"]\n    elif event[\"type\"] == \"realm\":\n        if event[\"op\"] == \"update\":\n            field = \"realm_\" + event[\"property\"]\n            state[field] = event[\"value\"]\n\n            if event[\"property\"] == \"plan_type\":\n                # Then there are some extra fields that also need to be set.\n                state[\"zulip_plan_is_not_limited\"] = event[\"value\"] != Realm.PLAN_TYPE_LIMITED\n                state[\"realm_upload_quota_mib\"] = event[\"extra_data\"][\"upload_quota\"]\n\n            policy_permission_dict = {\n                \"create_public_stream_policy\": \"can_create_public_streams\",\n                \"create_private_stream_policy\": \"can_create_private_streams\",\n                \"create_web_public_stream_policy\": \"can_create_web_public_streams\",\n                \"invite_to_stream_policy\": \"can_subscribe_other_users\",\n                \"invite_to_realm_policy\": \"can_invite_others_to_realm\",\n            }\n\n            # Tricky interaction: Whether we can create streams and can subscribe other users\n            # can get changed here.\n\n            if field == \"realm_waiting_period_threshold\":\n                for policy, permission in policy_permission_dict.items():\n                    if permission in state:\n                        state[permission] = user_profile.has_permission(policy)\n\n            if (\n                event[\"property\"] in policy_permission_dict\n                and policy_permission_dict[event[\"property\"]] in state\n            ):\n                state[policy_permission_dict[event[\"property\"]]] = user_profile.has_permission(\n                    event[\"property\"]\n                )\n\n            # Finally, we need to recompute this value from its inputs.\n            state[\"can_create_streams\"] = (\n                state[\"can_create_private_streams\"]\n                or state[\"can_create_public_streams\"]\n                or state[\"can_create_web_public_streams\"]\n            )\n        elif event[\"op\"] == \"update_dict\":\n            for key, value in event[\"data\"].items():\n                state[\"realm_\" + key] = value\n                # It's a bit messy, but this is where we need to\n                # update the state for whether password authentication\n                # is enabled on this server.\n                if key == \"authentication_methods\":\n                    state[\"realm_password_auth_enabled\"] = value[\"Email\"] or value[\"LDAP\"]\n                    state[\"realm_email_auth_enabled\"] = value[\"Email\"]\n        elif event[\"op\"] == \"deactivated\":\n            # The realm has just been deactivated.  If our request had\n            # arrived a moment later, we'd have rendered the\n            # deactivation UI; if it'd been a moment sooner, we've\n            # have rendered the app and then immediately got this\n            # event (or actually, more likely, an auth error on GET\n            # /events) and immediately reloaded into the same\n            # deactivation UI. Passing achieves the same result.\n            pass\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"realm_user_settings_defaults\":\n        if event[\"op\"] == \"update\":\n            state[\"realm_user_settings_defaults\"][event[\"property\"]] = event[\"value\"]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"subscription\":\n        if event[\"op\"] == \"add\":\n            added_stream_ids = {sub[\"stream_id\"] for sub in event[\"subscriptions\"]}\n            was_added = lambda s: s[\"stream_id\"] in added_stream_ids\n\n            existing_stream_ids = {sub[\"stream_id\"] for sub in state[\"subscriptions\"]}\n\n            # add the new subscriptions\n            for sub in event[\"subscriptions\"]:\n                if sub[\"stream_id\"] not in existing_stream_ids:\n                    if \"subscribers\" in sub and not include_subscribers:\n                        sub = copy.deepcopy(sub)\n                        del sub[\"subscribers\"]\n                    state[\"subscriptions\"].append(sub)\n\n            # remove them from unsubscribed if they had been there\n            state[\"unsubscribed\"] = [s for s in state[\"unsubscribed\"] if not was_added(s)]\n\n            # remove them from never_subscribed if they had been there\n            state[\"never_subscribed\"] = [s for s in state[\"never_subscribed\"] if not was_added(s)]\n\n        elif event[\"op\"] == \"remove\":\n            removed_stream_ids = {sub[\"stream_id\"] for sub in event[\"subscriptions\"]}\n            was_removed = lambda s: s[\"stream_id\"] in removed_stream_ids\n\n            # Find the subs we are affecting.\n            removed_subs = list(filter(was_removed, state[\"subscriptions\"]))\n\n            # Remove our user from the subscribers of the removed subscriptions.\n            if include_subscribers:\n                for sub in removed_subs:\n                    sub[\"subscribers\"].remove(user_profile.id)\n\n            state[\"unsubscribed\"] += removed_subs\n\n            # Now filter out the removed subscriptions from subscriptions.\n            state[\"subscriptions\"] = [s for s in state[\"subscriptions\"] if not was_removed(s)]\n\n        elif event[\"op\"] == \"update\":\n            for sub in state[\"subscriptions\"]:\n                if sub[\"stream_id\"] == event[\"stream_id\"]:\n                    sub[event[\"property\"]] = event[\"value\"]\n        elif event[\"op\"] == \"peer_add\":\n            if include_subscribers:\n                stream_ids = set(event[\"stream_ids\"])\n                user_ids = set(event[\"user_ids\"])\n\n                for sub_dict in [\n                    state[\"subscriptions\"],\n                    state[\"unsubscribed\"],\n                    state[\"never_subscribed\"],\n                ]:\n                    for sub in sub_dict:\n                        if sub[\"stream_id\"] in stream_ids:\n                            subscribers = set(sub[\"subscribers\"]) | user_ids\n                            sub[\"subscribers\"] = sorted(subscribers)\n        elif event[\"op\"] == \"peer_remove\":\n            if include_subscribers:\n                stream_ids = set(event[\"stream_ids\"])\n                user_ids = set(event[\"user_ids\"])\n\n                for sub_dict in [\n                    state[\"subscriptions\"],\n                    state[\"unsubscribed\"],\n                    state[\"never_subscribed\"],\n                ]:\n                    for sub in sub_dict:\n                        if sub[\"stream_id\"] in stream_ids:\n                            subscribers = set(sub[\"subscribers\"]) - user_ids\n                            sub[\"subscribers\"] = sorted(subscribers)\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"presence\":\n        if slim_presence:\n            user_key = str(event[\"user_id\"])\n        else:\n            user_key = event[\"email\"]\n        state[\"presences\"][user_key] = get_presence_for_user(event[\"user_id\"], slim_presence)[\n            user_key\n        ]\n    elif event[\"type\"] == \"update_message\":\n        # We don't return messages in /register, so we don't need to\n        # do anything for content updates, but we may need to update\n        # the unread_msgs data if the topic of an unread message changed.\n        if \"raw_unread_msgs\" in state and \"new_stream_id\" in event:\n            stream_dict = state[\"raw_unread_msgs\"][\"stream_dict\"]\n            stream_id = event[\"new_stream_id\"]\n            for message_id in event[\"message_ids\"]:\n                if message_id in stream_dict:\n                    stream_dict[message_id][\"stream_id\"] = stream_id\n\n        if \"raw_unread_msgs\" in state and TOPIC_NAME in event:\n            stream_dict = state[\"raw_unread_msgs\"][\"stream_dict\"]\n            topic = event[TOPIC_NAME]\n            for message_id in event[\"message_ids\"]:\n                if message_id in stream_dict:\n                    stream_dict[message_id][\"topic\"] = topic\n    elif event[\"type\"] == \"delete_message\":\n        if \"message_id\" in event:\n            message_ids = [event[\"message_id\"]]\n        else:\n            message_ids = event[\"message_ids\"]  # nocoverage\n        max_message = (\n            Message.objects.filter(usermessage__user_profile=user_profile).order_by(\"-id\").first()\n        )\n        if max_message:\n            state[\"max_message_id\"] = max_message.id\n        else:\n            state[\"max_message_id\"] = -1\n\n        if \"raw_unread_msgs\" in state:\n            for remove_id in message_ids:\n                remove_message_id_from_unread_mgs(state[\"raw_unread_msgs\"], remove_id)\n\n        # The remainder of this block is about maintaining recent_private_conversations\n        if \"raw_recent_private_conversations\" not in state or event[\"message_type\"] != \"private\":\n            return\n\n        # OK, we just deleted what had been the max_message_id for\n        # this recent conversation; we need to recompute that value\n        # from scratch.  Definitely don't need to re-query everything,\n        # but this case is likely rare enough that it's reasonable to do so.\n        state[\"raw_recent_private_conversations\"] = get_recent_private_conversations(user_profile)\n    elif event[\"type\"] == \"reaction\":\n        # The client will get the message with the reactions directly\n        pass\n    elif event[\"type\"] == \"submessage\":\n        # The client will get submessages with their messages\n        pass\n    elif event[\"type\"] == \"typing\":\n        # Typing notification events are transient and thus ignored\n        pass\n    elif event[\"type\"] == \"attachment\":\n        # Attachment events are just for updating the \"uploads\" UI;\n        # they are not sent directly.\n        pass\n    elif event[\"type\"] == \"update_message_flags\":\n        # We don't return messages in `/register`, so most flags we\n        # can ignore, but we do need to update the unread_msgs data if\n        # unread state is changed.\n        if \"raw_unread_msgs\" in state and event[\"flag\"] == \"read\" and event[\"op\"] == \"add\":\n            for remove_id in event[\"messages\"]:\n                remove_message_id_from_unread_mgs(state[\"raw_unread_msgs\"], remove_id)\n        if \"raw_unread_msgs\" in state and event[\"flag\"] == \"read\" and event[\"op\"] == \"remove\":\n            for message_id_str, message_details in event[\"message_details\"].items():\n                add_message_to_unread_msgs(\n                    user_profile.id,\n                    state[\"raw_unread_msgs\"],\n                    int(message_id_str),\n                    message_details,\n                )\n        if event[\"flag\"] == \"starred\" and \"starred_messages\" in state:\n            if event[\"op\"] == \"add\":\n                state[\"starred_messages\"] += event[\"messages\"]\n            if event[\"op\"] == \"remove\":\n                state[\"starred_messages\"] = [\n                    message\n                    for message in state[\"starred_messages\"]\n                    if message not in event[\"messages\"]\n                ]\n    elif event[\"type\"] == \"realm_domains\":\n        if event[\"op\"] == \"add\":\n            state[\"realm_domains\"].append(event[\"realm_domain\"])\n        elif event[\"op\"] == \"change\":\n            for realm_domain in state[\"realm_domains\"]:\n                if realm_domain[\"domain\"] == event[\"realm_domain\"][\"domain\"]:\n                    realm_domain[\"allow_subdomains\"] = event[\"realm_domain\"][\"allow_subdomains\"]\n        elif event[\"op\"] == \"remove\":\n            state[\"realm_domains\"] = [\n                realm_domain\n                for realm_domain in state[\"realm_domains\"]\n                if realm_domain[\"domain\"] != event[\"domain\"]\n            ]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"realm_emoji\":\n        state[\"realm_emoji\"] = event[\"realm_emoji\"]\n    elif event[\"type\"] == \"realm_export\":\n        # These realm export events are only available to\n        # administrators, and aren't included in page_params.\n        pass\n    elif event[\"type\"] == \"alert_words\":\n        state[\"alert_words\"] = event[\"alert_words\"]\n    elif event[\"type\"] == \"muted_topics\":\n        state[\"muted_topics\"] = event[\"muted_topics\"]\n    elif event[\"type\"] == \"muted_users\":\n        state[\"muted_users\"] = event[\"muted_users\"]\n    elif event[\"type\"] == \"realm_linkifiers\":\n        # We only send realm_linkifiers event to clients that indicate\n        # support for linkifiers with URL templates. Otherwise, silently\n        # ignore the event.\n        if linkifier_url_template:\n            state[\"realm_linkifiers\"] = event[\"realm_linkifiers\"]\n    elif event[\"type\"] == \"realm_playgrounds\":\n        state[\"realm_playgrounds\"] = event[\"realm_playgrounds\"]\n    elif event[\"type\"] == \"update_display_settings\":\n        if event[\"setting_name\"] != \"timezone\":\n            assert event[\"setting_name\"] in UserProfile.display_settings_legacy\n        state[event[\"setting_name\"]] = event[\"setting\"]\n    elif event[\"type\"] == \"update_global_notifications\":\n        assert event[\"notification_name\"] in UserProfile.notification_settings_legacy\n        state[event[\"notification_name\"]] = event[\"setting\"]\n    elif event[\"type\"] == \"user_settings\":\n        # time zone setting is not included in property_types dict because\n        # this setting is not a part of UserBaseSettings class.\n        if event[\"property\"] != \"timezone\":\n            assert event[\"property\"] in UserProfile.property_types\n        if event[\"property\"] in {\n            **UserProfile.display_settings_legacy,\n            **UserProfile.notification_settings_legacy,\n        }:\n            state[event[\"property\"]] = event[\"value\"]\n        state[\"user_settings\"][event[\"property\"]] = event[\"value\"]\n    elif event[\"type\"] == \"invites_changed\":\n        pass\n    elif event[\"type\"] == \"user_group\":\n        if event[\"op\"] == \"add\":\n            state[\"realm_user_groups\"].append(event[\"group\"])\n            state[\"realm_user_groups\"].sort(key=lambda group: group[\"id\"])\n        elif event[\"op\"] == \"update\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    user_group.update(event[\"data\"])\n        elif event[\"op\"] == \"add_members\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    user_group[\"members\"].extend(event[\"user_ids\"])\n                    user_group[\"members\"].sort()\n        elif event[\"op\"] == \"remove_members\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    members = set(user_group[\"members\"])\n                    user_group[\"members\"] = list(members - set(event[\"user_ids\"]))\n                    user_group[\"members\"].sort()\n        elif event[\"op\"] == \"add_subgroups\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    user_group[\"direct_subgroup_ids\"].extend(event[\"direct_subgroup_ids\"])\n                    user_group[\"direct_subgroup_ids\"].sort()\n        elif event[\"op\"] == \"remove_subgroups\":\n            for user_group in state[\"realm_user_groups\"]:\n                if user_group[\"id\"] == event[\"group_id\"]:\n                    subgroups = set(user_group[\"direct_subgroup_ids\"])\n                    user_group[\"direct_subgroup_ids\"] = list(\n                        subgroups - set(event[\"direct_subgroup_ids\"])\n                    )\n                    user_group[\"direct_subgroup_ids\"].sort()\n        elif event[\"op\"] == \"remove\":\n            state[\"realm_user_groups\"] = [\n                ug for ug in state[\"realm_user_groups\"] if ug[\"id\"] != event[\"group_id\"]\n            ]\n        else:\n            raise AssertionError(\"Unexpected event type {type}/{op}\".format(**event))\n    elif event[\"type\"] == \"user_status\":\n        user_id_str = str(event[\"user_id\"])\n        user_status = state[\"user_status\"]\n        away = event.get(\"away\")\n        status_text = event.get(\"status_text\")\n        emoji_name = event.get(\"emoji_name\")\n        emoji_code = event.get(\"emoji_code\")\n        reaction_type = event.get(\"reaction_type\")\n\n        if user_id_str not in user_status:\n            user_status[user_id_str] = {}\n\n        if away is not None:\n            if away:\n                user_status[user_id_str][\"away\"] = True\n            else:\n                user_status[user_id_str].pop(\"away\", None)\n\n        if status_text is not None:\n            if status_text == \"\":\n                user_status[user_id_str].pop(\"status_text\", None)\n            else:\n                user_status[user_id_str][\"status_text\"] = status_text\n\n            if emoji_name is not None:\n                if emoji_name == \"\":\n                    user_status[user_id_str].pop(\"emoji_name\", None)\n                else:\n                    user_status[user_id_str][\"emoji_name\"] = emoji_name\n\n                if emoji_code is not None:\n                    if emoji_code == \"\":\n                        user_status[user_id_str].pop(\"emoji_code\", None)\n                    else:\n                        user_status[user_id_str][\"emoji_code\"] = emoji_code\n\n                if reaction_type is not None:\n                    if reaction_type == UserStatus.UNICODE_EMOJI and emoji_name == \"\":\n                        user_status[user_id_str].pop(\"reaction_type\", None)\n                    else:\n                        user_status[user_id_str][\"reaction_type\"] = reaction_type\n\n        if not user_status[user_id_str]:\n            user_status.pop(user_id_str, None)\n\n        state[\"user_status\"] = user_status\n    elif event[\"type\"] == \"user_topic\":\n        if event[\"visibility_policy\"] == UserTopic.VisibilityPolicy.INHERIT:\n            user_topics_state = state[\"user_topics\"]\n            for i in range(len(user_topics_state)):\n                if (\n                    user_topics_state[i][\"stream_id\"] == event[\"stream_id\"]\n                    and user_topics_state[i][\"topic_name\"] == event[\"topic_name\"]\n                ):\n                    del user_topics_state[i]\n                    break\n        else:\n            fields = [\"stream_id\", \"topic_name\", \"visibility_policy\", \"last_updated\"]\n            state[\"user_topics\"].append({x: event[x] for x in fields})\n    elif event[\"type\"] == \"has_zoom_token\":\n        state[\"has_zoom_token\"] = event[\"value\"]\n    else:\n        raise AssertionError(\"Unexpected event type {}\".format(event[\"type\"]))\n\n\ndef do_events_register(\n    user_profile: Optional[UserProfile],\n    realm: Realm,\n    user_client: Client,\n    apply_markdown: bool = True,\n    client_gravatar: bool = False,\n    slim_presence: bool = False,\n    event_types: Optional[Sequence[str]] = None,\n    queue_lifespan_secs: int = 0,\n    all_public_streams: bool = False,\n    include_subscribers: bool = True,\n    include_streams: bool = True,\n    client_capabilities: Mapping[str, bool] = {},\n    narrow: Collection[Sequence[str]] = [],\n    fetch_event_types: Optional[Collection[str]] = None,\n    spectator_requested_language: Optional[str] = None,\n    pronouns_field_type_supported: bool = True,\n) -> Dict[str, Any]:\n    # Technically we don't need to check this here because\n    # build_narrow_filter will check it, but it's nicer from an error\n    # handling perspective to do it before contacting Tornado\n    check_supported_events_narrow_filter(narrow)\n\n    notification_settings_null = client_capabilities.get(\"notification_settings_null\", False)\n    bulk_message_deletion = client_capabilities.get(\"bulk_message_deletion\", False)\n    user_avatar_url_field_optional = client_capabilities.get(\n        \"user_avatar_url_field_optional\", False\n    )\n    stream_typing_notifications = client_capabilities.get(\"stream_typing_notifications\", False)\n    user_settings_object = client_capabilities.get(\"user_settings_object\", False)\n    linkifier_url_template = client_capabilities.get(\"linkifier_url_template\", False)\n\n    if fetch_event_types is not None:\n        event_types_set: Optional[Set[str]] = set(fetch_event_types)\n    elif event_types is not None:\n        event_types_set = set(event_types)\n    else:\n        event_types_set = None\n\n    if user_profile is None:\n        # TODO: Unify the two fetch_initial_state_data code paths.\n        assert client_gravatar is False\n        assert include_subscribers is False\n        assert include_streams is False\n        ret = fetch_initial_state_data(\n            user_profile,\n            realm=realm,\n            event_types=event_types_set,\n            queue_id=None,\n            # Force client_gravatar=False for security reasons.\n            client_gravatar=client_gravatar,\n            linkifier_url_template=linkifier_url_template,\n            user_avatar_url_field_optional=user_avatar_url_field_optional,\n            user_settings_object=user_settings_object,\n            # slim_presence is a noop, because presence is not included.\n            slim_presence=True,\n            # Force include_subscribers=False for security reasons.\n            include_subscribers=include_subscribers,\n            # Force include_streams=False for security reasons.\n            include_streams=include_streams,\n            spectator_requested_language=spectator_requested_language,\n        )\n\n        post_process_state(user_profile, ret, notification_settings_null=False)\n        return ret\n\n    # Fill up the UserMessage rows if a soft-deactivated user has returned\n    reactivate_user_if_soft_deactivated(user_profile)\n\n    while True:\n        # Note that we pass event_types, not fetch_event_types here, since\n        # that's what controls which future events are sent.\n        queue_id = request_event_queue(\n            user_profile,\n            user_client,\n            apply_markdown,\n            client_gravatar,\n            slim_presence,\n            queue_lifespan_secs,\n            event_types,\n            all_public_streams,\n            narrow=narrow,\n            bulk_message_deletion=bulk_message_deletion,\n            stream_typing_notifications=stream_typing_notifications,\n            user_settings_object=user_settings_object,\n            pronouns_field_type_supported=pronouns_field_type_supported,\n            linkifier_url_template=linkifier_url_template,\n        )\n\n        if queue_id is None:\n            raise JsonableError(_(\"Could not allocate event queue\"))\n\n        ret = fetch_initial_state_data(\n            user_profile,\n            event_types=event_types_set,\n            queue_id=queue_id,\n            client_gravatar=client_gravatar,\n            user_avatar_url_field_optional=user_avatar_url_field_optional,\n            user_settings_object=user_settings_object,\n            slim_presence=slim_presence,\n            include_subscribers=include_subscribers,\n            include_streams=include_streams,\n            pronouns_field_type_supported=pronouns_field_type_supported,\n            linkifier_url_template=linkifier_url_template,\n        )\n\n        # Apply events that came in while we were fetching initial data\n        events = get_user_events(user_profile, queue_id, -1)\n        try:\n            apply_events(\n                user_profile,\n                state=ret,\n                events=events,\n                fetch_event_types=fetch_event_types,\n                client_gravatar=client_gravatar,\n                slim_presence=slim_presence,\n                include_subscribers=include_subscribers,\n                linkifier_url_template=linkifier_url_template,\n            )\n        except RestartEventError:\n            # This represents a rare race condition, where Tornado\n            # restarted (and sent `restart` events) while we were waiting\n            # for fetch_initial_state_data to return. To avoid the client\n            # needing to reload shortly after loading, we recursively call\n            # do_events_register here.\n            continue\n        else:\n            break\n\n    post_process_state(user_profile, ret, notification_settings_null)\n\n    if len(events) > 0:\n        ret[\"last_event_id\"] = events[-1][\"id\"]\n    else:\n        ret[\"last_event_id\"] = -1\n    return ret\n\n\ndef post_process_state(\n    user_profile: Optional[UserProfile], ret: Dict[str, Any], notification_settings_null: bool\n) -> None:\n    \"\"\"\n    NOTE:\n\n    Below is an example of post-processing initial state data AFTER we\n    apply events.  For large payloads like `unread_msgs`, it's helpful\n    to have an intermediate data structure that is easy to manipulate\n    with O(1)-type operations as we apply events.\n\n    Then, only at the end, we put it in the form that's more appropriate\n    for client.\n    \"\"\"\n    if \"raw_unread_msgs\" in ret:\n        ret[\"unread_msgs\"] = aggregate_unread_data(ret[\"raw_unread_msgs\"])\n        del ret[\"raw_unread_msgs\"]\n\n    \"\"\"\n    See the note above; the same technique applies below.\n    \"\"\"\n    if \"raw_users\" in ret:\n        user_dicts = list(ret[\"raw_users\"].values())\n        user_dicts = sorted(user_dicts, key=lambda x: x[\"user_id\"])\n\n        ret[\"realm_users\"] = [d for d in user_dicts if d[\"is_active\"]]\n        ret[\"realm_non_active_users\"] = [d for d in user_dicts if not d[\"is_active\"]]\n\n        \"\"\"\n        Be aware that we do intentional aliasing in the below code.\n        We can now safely remove the `is_active` field from all the\n        dicts that got partitioned into the two lists above.\n\n        We remove the field because it's already implied, and sending\n        it to clients makes clients prone to bugs where they \"trust\"\n        the field but don't actually update in live updates.  It also\n        wastes bandwidth.\n        \"\"\"\n        for d in user_dicts:\n            d.pop(\"is_active\")\n\n        del ret[\"raw_users\"]\n\n    if \"raw_recent_private_conversations\" in ret:\n        # Reformat recent_private_conversations to be a list of dictionaries, rather than a dict.\n        ret[\"recent_private_conversations\"] = sorted(\n            (\n                dict(\n                    **value,\n                )\n                for (recipient_id, value) in ret[\"raw_recent_private_conversations\"].items()\n            ),\n            key=lambda x: -x[\"max_message_id\"],\n        )\n        del ret[\"raw_recent_private_conversations\"]\n\n    if not notification_settings_null and \"subscriptions\" in ret:\n        for stream_dict in ret[\"subscriptions\"] + ret[\"unsubscribed\"]:\n            handle_stream_notifications_compatibility(\n                user_profile, stream_dict, notification_settings_null\n            )\n", "import itertools\nfrom operator import itemgetter\nfrom typing import Any, Callable, Collection, Dict, Iterable, List, Mapping, Optional, Set, Tuple\n\nfrom django.core.exceptions import ValidationError\nfrom django.db import connection\nfrom django.db.models import QuerySet\nfrom django.utils.translation import gettext as _\nfrom psycopg2.sql import SQL\n\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.stream_color import STREAM_ASSIGNMENT_COLORS\nfrom zerver.lib.stream_subscription import (\n    get_active_subscriptions_for_stream_id,\n    get_stream_subscriptions_for_user,\n)\nfrom zerver.lib.stream_traffic import get_average_weekly_stream_traffic, get_streams_traffic\nfrom zerver.lib.streams import get_web_public_streams_queryset, subscribed_to_stream\nfrom zerver.lib.timestamp import datetime_to_timestamp, timestamp_to_datetime\nfrom zerver.lib.types import (\n    APIStreamDict,\n    NeverSubscribedStreamDict,\n    RawStreamDict,\n    RawSubscriptionDict,\n    SubscriptionInfo,\n    SubscriptionStreamDict,\n)\nfrom zerver.models import Realm, Stream, Subscription, UserProfile, get_active_streams\n\n\ndef get_web_public_subs(realm: Realm) -> SubscriptionInfo:\n    color_idx = 0\n\n    def get_next_color() -> str:\n        nonlocal color_idx\n        color = STREAM_ASSIGNMENT_COLORS[color_idx]\n        color_idx = (color_idx + 1) % len(STREAM_ASSIGNMENT_COLORS)\n        return color\n\n    subscribed = []\n    for stream in get_web_public_streams_queryset(realm):\n        # Add Stream fields.\n        can_remove_subscribers_group_id = stream.can_remove_subscribers_group_id\n        date_created = datetime_to_timestamp(stream.date_created)\n        description = stream.description\n        first_message_id = stream.first_message_id\n        history_public_to_subscribers = stream.history_public_to_subscribers\n        invite_only = stream.invite_only\n        is_announcement_only = stream.stream_post_policy == Stream.STREAM_POST_POLICY_ADMINS\n        is_web_public = stream.is_web_public\n        message_retention_days = stream.message_retention_days\n        name = stream.name\n        rendered_description = stream.rendered_description\n        stream_id = stream.id\n        stream_post_policy = stream.stream_post_policy\n\n        # Add versions of the Subscription fields based on a simulated\n        # new user subscription set.\n        audible_notifications = True\n        color = get_next_color()\n        desktop_notifications = True\n        email_notifications = True\n        in_home_view = True\n        is_muted = False\n        pin_to_top = False\n        push_notifications = True\n        stream_weekly_traffic = get_average_weekly_stream_traffic(\n            stream.id, stream.date_created, {}\n        )\n        wildcard_mentions_notify = True\n\n        sub = SubscriptionStreamDict(\n            audible_notifications=audible_notifications,\n            can_remove_subscribers_group_id=can_remove_subscribers_group_id,\n            color=color,\n            date_created=date_created,\n            description=description,\n            desktop_notifications=desktop_notifications,\n            email_notifications=email_notifications,\n            first_message_id=first_message_id,\n            history_public_to_subscribers=history_public_to_subscribers,\n            in_home_view=in_home_view,\n            invite_only=invite_only,\n            is_announcement_only=is_announcement_only,\n            is_muted=is_muted,\n            is_web_public=is_web_public,\n            message_retention_days=message_retention_days,\n            name=name,\n            pin_to_top=pin_to_top,\n            push_notifications=push_notifications,\n            rendered_description=rendered_description,\n            stream_id=stream_id,\n            stream_post_policy=stream_post_policy,\n            stream_weekly_traffic=stream_weekly_traffic,\n            wildcard_mentions_notify=wildcard_mentions_notify,\n        )\n        subscribed.append(sub)\n\n    return SubscriptionInfo(\n        subscriptions=subscribed,\n        unsubscribed=[],\n        never_subscribed=[],\n    )\n\n\ndef build_unsubscribed_sub_from_stream_dict(\n    user: UserProfile, sub_dict: RawSubscriptionDict, stream_dict: APIStreamDict\n) -> SubscriptionStreamDict:\n    # This function is only called from `apply_event` code.\n    raw_stream_dict = RawStreamDict(\n        can_remove_subscribers_group_id=stream_dict[\"can_remove_subscribers_group_id\"],\n        date_created=timestamp_to_datetime(stream_dict[\"date_created\"]),\n        description=stream_dict[\"description\"],\n        first_message_id=stream_dict[\"first_message_id\"],\n        history_public_to_subscribers=stream_dict[\"history_public_to_subscribers\"],\n        invite_only=stream_dict[\"invite_only\"],\n        is_web_public=stream_dict[\"is_web_public\"],\n        message_retention_days=stream_dict[\"message_retention_days\"],\n        name=stream_dict[\"name\"],\n        rendered_description=stream_dict[\"rendered_description\"],\n        id=stream_dict[\"stream_id\"],\n        stream_post_policy=stream_dict[\"stream_post_policy\"],\n    )\n\n    # We pass recent_traffic as an empty objecy and avoid extra database\n    # query since we would just set it to None later.\n    subscription_stream_dict = build_stream_dict_for_sub(\n        user, sub_dict, raw_stream_dict, recent_traffic={}\n    )\n\n    return subscription_stream_dict\n\n\ndef build_stream_dict_for_sub(\n    user: UserProfile,\n    sub_dict: RawSubscriptionDict,\n    raw_stream_dict: RawStreamDict,\n    recent_traffic: Dict[int, int],\n) -> SubscriptionStreamDict:\n    # Handle Stream.API_FIELDS\n    can_remove_subscribers_group_id = raw_stream_dict[\"can_remove_subscribers_group_id\"]\n    date_created = datetime_to_timestamp(raw_stream_dict[\"date_created\"])\n    description = raw_stream_dict[\"description\"]\n    first_message_id = raw_stream_dict[\"first_message_id\"]\n    history_public_to_subscribers = raw_stream_dict[\"history_public_to_subscribers\"]\n    invite_only = raw_stream_dict[\"invite_only\"]\n    is_web_public = raw_stream_dict[\"is_web_public\"]\n    message_retention_days = raw_stream_dict[\"message_retention_days\"]\n    name = raw_stream_dict[\"name\"]\n    rendered_description = raw_stream_dict[\"rendered_description\"]\n    stream_id = raw_stream_dict[\"id\"]\n    stream_post_policy = raw_stream_dict[\"stream_post_policy\"]\n\n    # Handle Subscription.API_FIELDS.\n    color = sub_dict[\"color\"]\n    is_muted = sub_dict[\"is_muted\"]\n    pin_to_top = sub_dict[\"pin_to_top\"]\n    audible_notifications = sub_dict[\"audible_notifications\"]\n    desktop_notifications = sub_dict[\"desktop_notifications\"]\n    email_notifications = sub_dict[\"email_notifications\"]\n    push_notifications = sub_dict[\"push_notifications\"]\n    wildcard_mentions_notify = sub_dict[\"wildcard_mentions_notify\"]\n\n    # Backwards-compatibility for clients that haven't been\n    # updated for the in_home_view => is_muted API migration.\n    in_home_view = not is_muted\n\n    # Backwards-compatibility for clients that haven't been\n    # updated for the is_announcement_only -> stream_post_policy\n    # migration.\n    is_announcement_only = raw_stream_dict[\"stream_post_policy\"] == Stream.STREAM_POST_POLICY_ADMINS\n\n    # Add a few computed fields not directly from the data models.\n    stream_weekly_traffic = get_average_weekly_stream_traffic(\n        raw_stream_dict[\"id\"], raw_stream_dict[\"date_created\"], recent_traffic\n    )\n\n    # Our caller may add a subscribers field.\n    return SubscriptionStreamDict(\n        audible_notifications=audible_notifications,\n        can_remove_subscribers_group_id=can_remove_subscribers_group_id,\n        color=color,\n        date_created=date_created,\n        description=description,\n        desktop_notifications=desktop_notifications,\n        email_notifications=email_notifications,\n        first_message_id=first_message_id,\n        history_public_to_subscribers=history_public_to_subscribers,\n        in_home_view=in_home_view,\n        invite_only=invite_only,\n        is_announcement_only=is_announcement_only,\n        is_muted=is_muted,\n        is_web_public=is_web_public,\n        message_retention_days=message_retention_days,\n        name=name,\n        pin_to_top=pin_to_top,\n        push_notifications=push_notifications,\n        rendered_description=rendered_description,\n        stream_id=stream_id,\n        stream_post_policy=stream_post_policy,\n        stream_weekly_traffic=stream_weekly_traffic,\n        wildcard_mentions_notify=wildcard_mentions_notify,\n    )\n\n\ndef build_stream_dict_for_never_sub(\n    raw_stream_dict: RawStreamDict,\n    recent_traffic: Dict[int, int],\n) -> NeverSubscribedStreamDict:\n    can_remove_subscribers_group_id = raw_stream_dict[\"can_remove_subscribers_group_id\"]\n    date_created = datetime_to_timestamp(raw_stream_dict[\"date_created\"])\n    description = raw_stream_dict[\"description\"]\n    first_message_id = raw_stream_dict[\"first_message_id\"]\n    history_public_to_subscribers = raw_stream_dict[\"history_public_to_subscribers\"]\n    invite_only = raw_stream_dict[\"invite_only\"]\n    is_web_public = raw_stream_dict[\"is_web_public\"]\n    message_retention_days = raw_stream_dict[\"message_retention_days\"]\n    name = raw_stream_dict[\"name\"]\n    rendered_description = raw_stream_dict[\"rendered_description\"]\n    stream_id = raw_stream_dict[\"id\"]\n    stream_post_policy = raw_stream_dict[\"stream_post_policy\"]\n    stream_weekly_traffic = get_average_weekly_stream_traffic(\n        raw_stream_dict[\"id\"], raw_stream_dict[\"date_created\"], recent_traffic\n    )\n\n    # Backwards-compatibility addition of removed field.\n    is_announcement_only = raw_stream_dict[\"stream_post_policy\"] == Stream.STREAM_POST_POLICY_ADMINS\n\n    # Our caller may add a subscribers field.\n    return NeverSubscribedStreamDict(\n        can_remove_subscribers_group_id=can_remove_subscribers_group_id,\n        date_created=date_created,\n        description=description,\n        first_message_id=first_message_id,\n        history_public_to_subscribers=history_public_to_subscribers,\n        invite_only=invite_only,\n        is_announcement_only=is_announcement_only,\n        is_web_public=is_web_public,\n        message_retention_days=message_retention_days,\n        name=name,\n        rendered_description=rendered_description,\n        stream_id=stream_id,\n        stream_post_policy=stream_post_policy,\n        stream_weekly_traffic=stream_weekly_traffic,\n    )\n\n\ndef validate_user_access_to_subscribers(\n    user_profile: Optional[UserProfile], stream: Stream\n) -> None:\n    \"\"\"Validates whether the user can view the subscribers of a stream.  Raises a JsonableError if:\n    * The user and the stream are in different realms\n    * The realm is MIT and the stream is not invite only.\n    * The stream is invite only, requesting_user is passed, and that user\n      does not subscribe to the stream.\n    \"\"\"\n    validate_user_access_to_subscribers_helper(\n        user_profile,\n        {\n            \"realm_id\": stream.realm_id,\n            \"is_web_public\": stream.is_web_public,\n            \"invite_only\": stream.invite_only,\n        },\n        # We use a lambda here so that we only compute whether the\n        # user is subscribed if we have to\n        lambda user_profile: subscribed_to_stream(user_profile, stream.id),\n    )\n\n\ndef validate_user_access_to_subscribers_helper(\n    user_profile: Optional[UserProfile],\n    stream_dict: Mapping[str, Any],\n    check_user_subscribed: Callable[[UserProfile], bool],\n) -> None:\n    \"\"\"Helper for validate_user_access_to_subscribers that doesn't require\n    a full stream object.  This function is a bit hard to read,\n    because it is carefully optimized for performance in the two code\n    paths we call it from:\n\n    * In `bulk_get_subscriber_user_ids`, we already know whether the\n    user was subscribed via `sub_dict`, and so we want to avoid a\n    database query at all (especially since it calls this in a loop);\n    * In `validate_user_access_to_subscribers`, we want to only check\n    if the user is subscribed when we absolutely have to, since it\n    costs a database query.\n\n    The `check_user_subscribed` argument is a function that reports\n    whether the user is subscribed to the stream.\n\n    Note also that we raise a ValidationError in cases where the\n    caller is doing the wrong thing (maybe these should be\n    AssertionErrors), and JsonableError for 400 type errors.\n    \"\"\"\n    if user_profile is None:\n        raise ValidationError(\"Missing user to validate access for\")\n\n    if user_profile.realm_id != stream_dict[\"realm_id\"]:\n        raise ValidationError(\"Requesting user not in given realm\")\n\n    # Even guest users can access subscribers to web-public streams,\n    # since they can freely become subscribers to these streams.\n    if stream_dict[\"is_web_public\"]:\n        return\n\n    # With the exception of web-public streams, a guest must\n    # be subscribed to a stream (even a public one) in order\n    # to see subscribers.\n    if user_profile.is_guest and check_user_subscribed(user_profile):\n        return\n        # We could explicitly handle the case where guests aren't\n        # subscribed here in an `else` statement or we can fall\n        # through to the subsequent logic.  Tim prefers the latter.\n        # Adding an `else` would ensure better code coverage.\n\n    if not user_profile.can_access_public_streams() and not stream_dict[\"invite_only\"]:\n        raise JsonableError(_(\"Subscriber data is not available for this stream\"))\n\n    # Organization administrators can view subscribers for all streams.\n    if user_profile.is_realm_admin:\n        return\n\n    if stream_dict[\"invite_only\"] and not check_user_subscribed(user_profile):\n        raise JsonableError(_(\"Unable to retrieve subscribers for private stream\"))\n\n\ndef bulk_get_subscriber_user_ids(\n    stream_dicts: Collection[Mapping[str, Any]],\n    user_profile: UserProfile,\n    subscribed_stream_ids: Set[int],\n) -> Dict[int, List[int]]:\n    \"\"\"sub_dict maps stream_id => whether the user is subscribed to that stream.\"\"\"\n    target_stream_dicts = []\n    for stream_dict in stream_dicts:\n        stream_id = stream_dict[\"id\"]\n        is_subscribed = stream_id in subscribed_stream_ids\n\n        try:\n            validate_user_access_to_subscribers_helper(\n                user_profile,\n                stream_dict,\n                lambda user_profile: is_subscribed,\n            )\n        except JsonableError:\n            continue\n        target_stream_dicts.append(stream_dict)\n\n    recip_to_stream_id = {stream[\"recipient_id\"]: stream[\"id\"] for stream in target_stream_dicts}\n    recipient_ids = sorted(stream[\"recipient_id\"] for stream in target_stream_dicts)\n\n    result: Dict[int, List[int]] = {stream[\"id\"]: [] for stream in stream_dicts}\n    if not recipient_ids:\n        return result\n\n    \"\"\"\n    The raw SQL below leads to more than a 2x speedup when tested with\n    20k+ total subscribers.  (For large realms with lots of default\n    streams, this function deals with LOTS of data, so it is important\n    to optimize.)\n    \"\"\"\n\n    query = SQL(\n        \"\"\"\n        SELECT\n            zerver_subscription.recipient_id,\n            zerver_subscription.user_profile_id\n        FROM\n            zerver_subscription\n        WHERE\n            zerver_subscription.recipient_id in %(recipient_ids)s AND\n            zerver_subscription.active AND\n            zerver_subscription.is_user_active\n        ORDER BY\n            zerver_subscription.recipient_id,\n            zerver_subscription.user_profile_id\n        \"\"\"\n    )\n\n    cursor = connection.cursor()\n    cursor.execute(query, {\"recipient_ids\": tuple(recipient_ids)})\n    rows = cursor.fetchall()\n    cursor.close()\n\n    \"\"\"\n    Using groupby/itemgetter here is important for performance, at scale.\n    It makes it so that all interpreter overhead is just O(N) in nature.\n    \"\"\"\n    for recip_id, recip_rows in itertools.groupby(rows, itemgetter(0)):\n        user_profile_ids = [r[1] for r in recip_rows]\n        stream_id = recip_to_stream_id[recip_id]\n        result[stream_id] = list(user_profile_ids)\n\n    return result\n\n\ndef get_subscribers_query(\n    stream: Stream, requesting_user: Optional[UserProfile]\n) -> QuerySet[Subscription]:\n    \"\"\"Build a query to get the subscribers list for a stream, raising a JsonableError if:\n\n    'realm' is optional in stream.\n\n    The caller can refine this query with select_related(), values(), etc. depending\n    on whether it wants objects or just certain fields\n    \"\"\"\n    validate_user_access_to_subscribers(requesting_user, stream)\n\n    return get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=False)\n\n\ndef has_metadata_access_to_previously_subscribed_stream(\n    user_profile: UserProfile, stream_dict: SubscriptionStreamDict\n) -> bool:\n    if stream_dict[\"is_web_public\"]:\n        return True\n\n    if not user_profile.can_access_public_streams():\n        return False\n\n    if stream_dict[\"invite_only\"]:\n        return user_profile.is_realm_admin\n\n    return True\n\n\n# In general, it's better to avoid using .values() because it makes\n# the code pretty ugly, but in this case, it has significant\n# performance impact for loading / for users with large numbers of\n# subscriptions, so it's worth optimizing.\ndef gather_subscriptions_helper(\n    user_profile: UserProfile,\n    include_subscribers: bool = True,\n) -> SubscriptionInfo:\n    realm = user_profile.realm\n    all_streams = get_active_streams(realm).values(\n        *Stream.API_FIELDS,\n        # The realm_id and recipient_id are generally not needed in the API.\n        \"realm_id\",\n        \"recipient_id\",\n    )\n    recip_id_to_stream_id: Dict[int, int] = {\n        stream[\"recipient_id\"]: stream[\"id\"] for stream in all_streams\n    }\n    all_streams_map: Dict[int, RawStreamDict] = {stream[\"id\"]: stream for stream in all_streams}\n\n    sub_dicts_query: Iterable[RawSubscriptionDict] = (\n        get_stream_subscriptions_for_user(user_profile)\n        .values(\n            *Subscription.API_FIELDS,\n            \"recipient_id\",\n            \"active\",\n        )\n        .order_by(\"recipient_id\")\n    )\n\n    # We only care about subscriptions for active streams.\n    sub_dicts: List[RawSubscriptionDict] = [\n        sub_dict\n        for sub_dict in sub_dicts_query\n        if recip_id_to_stream_id.get(sub_dict[\"recipient_id\"])\n    ]\n\n    def get_stream_id(sub_dict: RawSubscriptionDict) -> int:\n        return recip_id_to_stream_id[sub_dict[\"recipient_id\"]]\n\n    traffic_stream_ids = {get_stream_id(sub_dict) for sub_dict in sub_dicts}\n    recent_traffic = get_streams_traffic(stream_ids=traffic_stream_ids)\n\n    # Okay, now we finally get to populating our main results, which\n    # will be these three lists.\n    subscribed: List[SubscriptionStreamDict] = []\n    unsubscribed: List[SubscriptionStreamDict] = []\n    never_subscribed: List[NeverSubscribedStreamDict] = []\n\n    sub_unsub_stream_ids = set()\n    for sub_dict in sub_dicts:\n        stream_id = get_stream_id(sub_dict)\n        sub_unsub_stream_ids.add(stream_id)\n        raw_stream_dict = all_streams_map[stream_id]\n\n        stream_dict = build_stream_dict_for_sub(\n            user=user_profile,\n            sub_dict=sub_dict,\n            raw_stream_dict=raw_stream_dict,\n            recent_traffic=recent_traffic,\n        )\n\n        # is_active is represented in this structure by which list we include it in.\n        is_active = sub_dict[\"active\"]\n        if is_active:\n            subscribed.append(stream_dict)\n        else:\n            if has_metadata_access_to_previously_subscribed_stream(user_profile, stream_dict):\n                \"\"\"\n                User who are no longer subscribed to a stream that they don't have\n                metadata access to will not receive metadata related to this stream\n                and their clients will see it as an unkown stream if referenced\n                somewhere (e.g. a markdown stream link), just like they would see\n                a reference to a private stream they had never been subscribed to.\n                \"\"\"\n                unsubscribed.append(stream_dict)\n\n    if user_profile.can_access_public_streams():\n        never_subscribed_stream_ids = set(all_streams_map) - sub_unsub_stream_ids\n    else:\n        web_public_stream_ids = {stream[\"id\"] for stream in all_streams if stream[\"is_web_public\"]}\n        never_subscribed_stream_ids = web_public_stream_ids - sub_unsub_stream_ids\n\n    never_subscribed_streams = [\n        all_streams_map[stream_id] for stream_id in never_subscribed_stream_ids\n    ]\n\n    for raw_stream_dict in never_subscribed_streams:\n        is_public = not raw_stream_dict[\"invite_only\"]\n        if is_public or user_profile.is_realm_admin:\n            slim_stream_dict = build_stream_dict_for_never_sub(\n                raw_stream_dict=raw_stream_dict, recent_traffic=recent_traffic\n            )\n\n            never_subscribed.append(slim_stream_dict)\n\n    if include_subscribers:\n        # The highly optimized bulk_get_subscriber_user_ids wants to know which\n        # streams we are subscribed to, for validation purposes, and it uses that\n        # info to know if it's allowed to find OTHER subscribers.\n        subscribed_stream_ids = {\n            get_stream_id(sub_dict) for sub_dict in sub_dicts if sub_dict[\"active\"]\n        }\n\n        subscriber_map = bulk_get_subscriber_user_ids(\n            all_streams,\n            user_profile,\n            subscribed_stream_ids,\n        )\n\n        for lst in [subscribed, unsubscribed]:\n            for stream_dict in lst:\n                assert isinstance(stream_dict[\"stream_id\"], int)\n                stream_id = stream_dict[\"stream_id\"]\n                stream_dict[\"subscribers\"] = subscriber_map[stream_id]\n\n        for slim_stream_dict in never_subscribed:\n            assert isinstance(slim_stream_dict[\"stream_id\"], int)\n            stream_id = slim_stream_dict[\"stream_id\"]\n            slim_stream_dict[\"subscribers\"] = subscriber_map[stream_id]\n\n    subscribed.sort(key=lambda x: x[\"name\"])\n    unsubscribed.sort(key=lambda x: x[\"name\"])\n    never_subscribed.sort(key=lambda x: x[\"name\"])\n\n    return SubscriptionInfo(\n        subscriptions=subscribed,\n        unsubscribed=unsubscribed,\n        never_subscribed=never_subscribed,\n    )\n\n\ndef gather_subscriptions(\n    user_profile: UserProfile,\n    include_subscribers: bool = False,\n) -> Tuple[List[SubscriptionStreamDict], List[SubscriptionStreamDict]]:\n    helper_result = gather_subscriptions_helper(\n        user_profile,\n        include_subscribers=include_subscribers,\n    )\n    subscribed = helper_result.subscriptions\n    unsubscribed = helper_result.unsubscribed\n    return (subscribed, unsubscribed)\n", "import hashlib\nimport random\nfrom datetime import timedelta\nfrom io import StringIO\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence, Set, Union\nfrom unittest import mock\n\nimport orjson\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse\nfrom django.utils.timezone import now as timezone_now\n\nfrom zerver.actions.bots import do_change_bot_owner\nfrom zerver.actions.create_realm import do_create_realm\nfrom zerver.actions.default_streams import (\n    do_add_default_stream,\n    do_add_streams_to_default_stream_group,\n    do_change_default_stream_group_description,\n    do_change_default_stream_group_name,\n    do_create_default_stream_group,\n    do_remove_default_stream,\n    do_remove_default_stream_group,\n    do_remove_streams_from_default_stream_group,\n    get_default_streams_for_realm,\n    lookup_default_stream_groups,\n)\nfrom zerver.actions.realm_settings import do_change_realm_plan_type, do_set_realm_property\nfrom zerver.actions.streams import (\n    bulk_add_subscriptions,\n    bulk_remove_subscriptions,\n    deactivated_streams_by_old_name,\n    do_change_stream_group_based_setting,\n    do_change_stream_permission,\n    do_change_stream_post_policy,\n    do_deactivate_stream,\n    do_unarchive_stream,\n)\nfrom zerver.actions.user_groups import add_subgroups_to_user_group, check_add_user_group\nfrom zerver.actions.users import do_change_user_role, do_deactivate_user\nfrom zerver.lib.email_mirror_helpers import encode_email_address_helper\nfrom zerver.lib.exceptions import JsonableError\nfrom zerver.lib.message import UnreadStreamInfo, aggregate_unread_data, get_raw_unread_data\nfrom zerver.lib.response import json_success\nfrom zerver.lib.stream_color import STREAM_ASSIGNMENT_COLORS, pick_colors\nfrom zerver.lib.stream_subscription import (\n    get_active_subscriptions_for_stream_id,\n    num_subscribers_for_stream_id,\n    subscriber_ids_with_stream_history_access,\n)\nfrom zerver.lib.stream_traffic import (\n    get_average_weekly_stream_traffic,\n    round_to_2_significant_digits,\n)\nfrom zerver.lib.streams import (\n    StreamDict,\n    access_stream_by_id,\n    access_stream_by_name,\n    can_access_stream_history,\n    can_access_stream_user_ids,\n    create_stream_if_needed,\n    create_streams_if_needed,\n    do_get_streams,\n    ensure_stream,\n    filter_stream_authorization,\n    list_to_streams,\n)\nfrom zerver.lib.subscription_info import (\n    bulk_get_subscriber_user_ids,\n    gather_subscriptions,\n    gather_subscriptions_helper,\n    validate_user_access_to_subscribers_helper,\n)\nfrom zerver.lib.test_classes import ZulipTestCase, get_topic_messages\nfrom zerver.lib.test_helpers import (\n    HostRequestMock,\n    cache_tries_captured,\n    get_subscription,\n    most_recent_message,\n    most_recent_usermessage,\n    reset_email_visibility_to_everyone_in_zulip_realm,\n)\nfrom zerver.lib.types import (\n    APIStreamDict,\n    APISubscriptionDict,\n    NeverSubscribedStreamDict,\n    SubscriptionInfo,\n)\nfrom zerver.models import (\n    Attachment,\n    DefaultStream,\n    DefaultStreamGroup,\n    Message,\n    Realm,\n    RealmAuditLog,\n    Recipient,\n    Stream,\n    Subscription,\n    UserGroup,\n    UserMessage,\n    UserProfile,\n    active_non_guest_user_ids,\n    flush_per_request_caches,\n    get_default_stream_groups,\n    get_realm,\n    get_stream,\n    get_user,\n    get_user_profile_by_id_in_realm,\n    validate_attachment_request,\n    validate_attachment_request_for_spectator_access,\n)\nfrom zerver.views.streams import compose_views\n\nif TYPE_CHECKING:\n    from django.test.client import _MonkeyPatchedWSGIResponse as TestHttpResponse\n\n\nclass TestMiscStuff(ZulipTestCase):\n    def test_test_helper(self) -> None:\n        cordelia = self.example_user(\"cordelia\")\n        s = self.subscribed_stream_name_list(cordelia)\n        self.assertIn(\"* Verona\", s)\n        self.assertNotIn(\"* Denmark\", s)\n\n    def test_pick_colors(self) -> None:\n        used_colors: Set[str] = set()\n        color_map: Dict[int, str] = {}\n        recipient_ids = list(range(30))\n        user_color_map = pick_colors(used_colors, color_map, recipient_ids)\n        self.assertEqual(\n            user_color_map,\n            {\n                0: \"#76ce90\",\n                1: \"#fae589\",\n                2: \"#a6c7e5\",\n                3: \"#e79ab5\",\n                4: \"#bfd56f\",\n                5: \"#f4ae55\",\n                6: \"#b0a5fd\",\n                7: \"#addfe5\",\n                8: \"#f5ce6e\",\n                9: \"#c2726a\",\n                10: \"#94c849\",\n                11: \"#bd86e5\",\n                12: \"#ee7e4a\",\n                13: \"#a6dcbf\",\n                14: \"#95a5fd\",\n                15: \"#53a063\",\n                16: \"#9987e1\",\n                17: \"#e4523d\",\n                18: \"#c2c2c2\",\n                19: \"#4f8de4\",\n                20: \"#c6a8ad\",\n                21: \"#e7cc4d\",\n                22: \"#c8bebf\",\n                23: \"#a47462\",\n                # start repeating\n                24: \"#76ce90\",\n                25: \"#fae589\",\n                26: \"#a6c7e5\",\n                27: \"#e79ab5\",\n                28: \"#bfd56f\",\n                29: \"#f4ae55\",\n            },\n        )\n\n        color_map = {98: \"color98\", 99: \"color99\"}\n        used_colors = set(STREAM_ASSIGNMENT_COLORS) - {\"#c6a8ad\", \"#9987e1\"}\n        recipient_ids = [99, 98, 1, 2, 3, 4]\n        user_color_map = pick_colors(used_colors, color_map, recipient_ids)\n        self.assertEqual(\n            user_color_map,\n            {98: \"color98\", 99: \"color99\", 1: \"#9987e1\", 2: \"#c6a8ad\", 3: \"#e79ab5\", 4: \"#bfd56f\"},\n        )\n\n        \"\"\"\n        If we are assigning colors to a user with 24+ streams, we have to start\n        re-using old colors.  Our algorithm basically uses recipient_id % 24, so\n        the following code reflects the worse case scenario that our new\n        streams have recipient ids spaced out by exact multiples of 24.  We\n        don't try to work around this edge case, since users who really depend\n        on the stream colors can always just assign themselves custom colors\n        for the streams that they really want to stand out.\n\n        Even if recipient_ids were completely random, the odds of collisions\n        are low, but it's often the case that bulk-adds are done for streams\n        that either were or are being created at roughly the same time, so the\n        recipient_ids tend to have even fewer collisions.\n        \"\"\"\n        used_colors = set(STREAM_ASSIGNMENT_COLORS)\n        color_map = {}\n        recipient_ids = [2, 26, 50, 74]\n        user_color_map = pick_colors(used_colors, color_map, recipient_ids)\n        self.assertEqual(\n            user_color_map,\n            {2: \"#a6c7e5\", 26: \"#a6c7e5\", 50: \"#a6c7e5\", 74: \"#a6c7e5\"},\n        )\n\n    def test_empty_results(self) -> None:\n        # These are essentially just tests to ensure line\n        # coverage for codepaths that won't ever really be\n        # called in practice.\n\n        user_profile = self.example_user(\"cordelia\")\n\n        result = bulk_get_subscriber_user_ids(\n            stream_dicts=[],\n            user_profile=user_profile,\n            subscribed_stream_ids=set(),\n        )\n        self.assertEqual(result, {})\n\n        streams = do_get_streams(\n            user_profile=user_profile,\n            include_public=False,\n            include_subscribed=False,\n            include_all_active=False,\n            include_default=False,\n        )\n        self.assertEqual(streams, [])\n\n    def test_api_fields(self) -> None:\n        \"\"\"Verify that all the fields from `Stream.API_FIELDS` and `Subscription.API_FIELDS` present\n        in `APIStreamDict` and `APISubscriptionDict`, respectively.\n        \"\"\"\n        expected_fields = set(Stream.API_FIELDS) | {\"stream_id\"}\n        expected_fields -= {\"id\"}\n\n        stream_dict_fields = set(APIStreamDict.__annotations__.keys())\n        computed_fields = {\"is_announcement_only\", \"is_default\"}\n\n        self.assertEqual(stream_dict_fields - computed_fields, expected_fields)\n\n        expected_fields = set(Subscription.API_FIELDS)\n\n        subscription_dict_fields = set(APISubscriptionDict.__annotations__.keys())\n        computed_fields = {\"in_home_view\", \"email_address\", \"stream_weekly_traffic\", \"subscribers\"}\n        # `APISubscriptionDict` is a subclass of `APIStreamDict`, therefore having all the\n        # fields in addition to the computed fields and `Subscription.API_FIELDS` that\n        # need to be excluded here.\n        self.assertEqual(\n            subscription_dict_fields - computed_fields - stream_dict_fields,\n            expected_fields,\n        )\n\n\nclass TestCreateStreams(ZulipTestCase):\n    def test_creating_streams(self) -> None:\n        stream_names = [\"new1\", \"new2\", \"new3\"]\n        stream_descriptions = [\"des1\", \"des2\", \"des3\"]\n        realm = get_realm(\"zulip\")\n\n        # Test stream creation events.\n        with self.capture_send_event_calls(expected_num_events=1) as events:\n            ensure_stream(realm, \"Public stream\", invite_only=False, acting_user=None)\n\n        self.assertEqual(events[0][\"event\"][\"type\"], \"stream\")\n        self.assertEqual(events[0][\"event\"][\"op\"], \"create\")\n        # Send public stream creation event to all active users.\n        self.assertEqual(events[0][\"users\"], active_non_guest_user_ids(realm.id))\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"name\"], \"Public stream\")\n\n        with self.capture_send_event_calls(expected_num_events=1) as events:\n            ensure_stream(realm, \"Private stream\", invite_only=True, acting_user=None)\n\n        self.assertEqual(events[0][\"event\"][\"type\"], \"stream\")\n        self.assertEqual(events[0][\"event\"][\"op\"], \"create\")\n        # Send private stream creation event to only realm admins.\n        self.assert_length(events[0][\"users\"], 2)\n        self.assertTrue(self.example_user(\"iago\").id in events[0][\"users\"])\n        self.assertTrue(self.example_user(\"desdemona\").id in events[0][\"users\"])\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"name\"], \"Private stream\")\n\n        moderators_system_group = UserGroup.objects.get(\n            name=\"@role:moderators\", realm=realm, is_system_group=True\n        )\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [\n                {\n                    \"name\": stream_name,\n                    \"description\": stream_description,\n                    \"invite_only\": True,\n                    \"stream_post_policy\": Stream.STREAM_POST_POLICY_ADMINS,\n                    \"message_retention_days\": -1,\n                    \"can_remove_subscribers_group\": moderators_system_group,\n                }\n                for (stream_name, stream_description) in zip(stream_names, stream_descriptions)\n            ],\n        )\n\n        self.assert_length(new_streams, 3)\n        self.assert_length(existing_streams, 0)\n\n        actual_stream_names = {stream.name for stream in new_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in new_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in new_streams:\n            self.assertTrue(stream.invite_only)\n            self.assertTrue(stream.stream_post_policy == Stream.STREAM_POST_POLICY_ADMINS)\n            self.assertTrue(stream.message_retention_days == -1)\n            self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n        new_streams, existing_streams = create_streams_if_needed(\n            realm,\n            [\n                {\"name\": stream_name, \"description\": stream_description, \"invite_only\": True}\n                for (stream_name, stream_description) in zip(stream_names, stream_descriptions)\n            ],\n        )\n\n        self.assert_length(new_streams, 0)\n        self.assert_length(existing_streams, 3)\n\n        actual_stream_names = {stream.name for stream in existing_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in existing_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in existing_streams:\n            self.assertTrue(stream.invite_only)\n\n    def test_create_api_multiline_description(self) -> None:\n        user = self.example_user(\"hamlet\")\n        realm = user.realm\n        self.login_user(user)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream\", \"description\": \"multi\\nline\\ndescription\"}]\n            ).decode(),\n            \"invite_only\": orjson.dumps(False).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_success(result)\n        stream = get_stream(\"new_stream\", realm)\n        self.assertEqual(stream.description, \"multi line description\")\n\n    def test_history_public_to_subscribers_on_stream_creation(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream_dicts: List[StreamDict] = [\n            {\n                \"name\": \"publicstream\",\n                \"description\": \"Public stream with public history\",\n            },\n            {\"name\": \"webpublicstream\", \"description\": \"Web-public stream\", \"is_web_public\": True},\n            {\n                \"name\": \"privatestream\",\n                \"description\": \"Private stream with non-public history\",\n                \"invite_only\": True,\n            },\n            {\n                \"name\": \"privatewithhistory\",\n                \"description\": \"Private stream with public history\",\n                \"invite_only\": True,\n                \"history_public_to_subscribers\": True,\n            },\n            {\n                \"name\": \"publictrywithouthistory\",\n                \"description\": \"Public stream without public history (disallowed)\",\n                \"invite_only\": False,\n                \"history_public_to_subscribers\": False,\n            },\n        ]\n\n        created, existing = create_streams_if_needed(realm, stream_dicts)\n\n        self.assert_length(created, 5)\n        self.assert_length(existing, 0)\n        for stream in created:\n            if stream.name == \"publicstream\":\n                self.assertTrue(stream.history_public_to_subscribers)\n            if stream.name == \"webpublicstream\":\n                self.assertTrue(stream.history_public_to_subscribers)\n            if stream.name == \"privatestream\":\n                self.assertFalse(stream.history_public_to_subscribers)\n            if stream.name == \"privatewithhistory\":\n                self.assertTrue(stream.history_public_to_subscribers)\n            if stream.name == \"publictrywithouthistory\":\n                self.assertTrue(stream.history_public_to_subscribers)\n\n    def test_history_public_to_subscribers_zephyr_realm(self) -> None:\n        realm = get_realm(\"zephyr\")\n\n        stream, created = create_stream_if_needed(realm, \"private_stream\", invite_only=True)\n        self.assertTrue(created)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        stream, created = create_stream_if_needed(realm, \"public_stream\", invite_only=False)\n        self.assertTrue(created)\n        self.assertFalse(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n    def test_auto_mark_stream_created_message_as_read_for_stream_creator(self) -> None:\n        # This test relies on email == delivery_email for\n        # convenience.\n        reset_email_visibility_to_everyone_in_zulip_realm()\n\n        realm = Realm.objects.get(name=\"Zulip Dev\")\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        aaron = self.example_user(\"aaron\")\n\n        # Establish a stream for notifications.\n        announce_stream = ensure_stream(\n            realm, \"announce\", False, \"announcements here.\", acting_user=None\n        )\n        realm.notifications_stream_id = announce_stream.id\n        realm.save(update_fields=[\"notifications_stream_id\"])\n\n        self.subscribe(iago, announce_stream.name)\n        self.subscribe(hamlet, announce_stream.name)\n\n        self.login_user(iago)\n\n        initial_message_count = Message.objects.count()\n        initial_usermessage_count = UserMessage.objects.count()\n\n        data = {\n            \"subscriptions\": '[{\"name\":\"brand new stream\",\"description\":\"\"}]',\n            \"history_public_to_subscribers\": \"true\",\n            \"invite_only\": \"false\",\n            \"announce\": \"true\",\n            \"principals\": orjson.dumps([iago.id, aaron.id, cordelia.id, hamlet.id]).decode(),\n            \"stream_post_policy\": \"1\",\n        }\n\n        response = self.client_post(\"/json/users/me/subscriptions\", data)\n\n        final_message_count = Message.objects.count()\n        final_usermessage_count = UserMessage.objects.count()\n\n        expected_response = {\n            \"result\": \"success\",\n            \"msg\": \"\",\n            \"subscribed\": {\n                \"AARON@zulip.com\": [\"brand new stream\"],\n                \"cordelia@zulip.com\": [\"brand new stream\"],\n                \"hamlet@zulip.com\": [\"brand new stream\"],\n                \"iago@zulip.com\": [\"brand new stream\"],\n            },\n            \"already_subscribed\": {},\n        }\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(orjson.loads(response.content), expected_response)\n\n        # 2 messages should be created, one in announce and one in the new stream itself.\n        self.assertEqual(final_message_count - initial_message_count, 2)\n        # 4 UserMessages per subscriber: One for each of the subscribers, plus 1 for\n        # each user in the notifications stream.\n        announce_stream_subs = Subscription.objects.filter(recipient=announce_stream.recipient)\n        self.assertEqual(\n            final_usermessage_count - initial_usermessage_count, 4 + announce_stream_subs.count()\n        )\n\n        def get_unread_stream_data(user: UserProfile) -> List[UnreadStreamInfo]:\n            raw_unread_data = get_raw_unread_data(user)\n            aggregated_data = aggregate_unread_data(raw_unread_data)\n            return aggregated_data[\"streams\"]\n\n        stream_id = Stream.objects.get(name=\"brand new stream\").id\n        iago_unread_messages = get_unread_stream_data(iago)\n        hamlet_unread_messages = get_unread_stream_data(hamlet)\n\n        # The stream creation messages should be unread for Hamlet\n        self.assert_length(hamlet_unread_messages, 2)\n\n        # According to the code in zerver/views/streams/add_subscriptions_backend\n        # the notification stream message is sent first, then the new stream's message.\n        self.assertEqual(hamlet_unread_messages[1][\"stream_id\"], stream_id)\n\n        # But it should be marked as read for Iago, the stream creator.\n        self.assert_length(iago_unread_messages, 0)\n\n    def test_can_remove_subscribers_group_on_stream_creation(self) -> None:\n        user = self.example_user(\"hamlet\")\n        realm = user.realm\n        self.login_user(user)\n        moderators_system_group = UserGroup.objects.get(\n            name=\"@role:moderators\", realm=realm, is_system_group=True\n        )\n        admins_system_group = UserGroup.objects.get(\n            name=\"@role:administrators\", realm=realm, is_system_group=True\n        )\n\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream1\", \"description\": \"First new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_success(result)\n        stream = get_stream(\"new_stream1\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream2\", \"description\": \"Second new stream\"}]\n            ).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_success(result)\n        stream = get_stream(\"new_stream2\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, admins_system_group.id)\n\n        hamletcharacters_group = UserGroup.objects.get(name=\"hamletcharacters\", realm=realm)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(hamletcharacters_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result, \"'can_remove_subscribers_group' must be a system user group.\"\n        )\n\n        internet_group = UserGroup.objects.get(\n            name=\"@role:internet\", is_system_group=True, realm=realm\n        )\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(internet_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:internet' group.\",\n        )\n\n        owners_group = UserGroup.objects.get(name=\"@role:owners\", is_system_group=True, realm=realm)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(owners_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:owners' group.\",\n        )\n\n        nobody_group = UserGroup.objects.get(name=\"@role:nobody\", is_system_group=True, realm=realm)\n        post_data = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new_stream3\", \"description\": \"Third new stream\"}]\n            ).decode(),\n            \"can_remove_subscribers_group_id\": orjson.dumps(nobody_group.id).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", post_data, subdomain=\"zulip\")\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:nobody' group.\",\n        )\n\n\nclass RecipientTest(ZulipTestCase):\n    def test_recipient(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream = get_stream(\"Verona\", realm)\n        recipient = Recipient.objects.get(\n            type_id=stream.id,\n            type=Recipient.STREAM,\n        )\n        self.assertEqual(repr(recipient), f\"<Recipient: Verona ({stream.id}, {Recipient.STREAM})>\")\n\n\nclass StreamAdminTest(ZulipTestCase):\n    def test_make_stream_public(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"private_stream_1\", invite_only=True)\n        self.make_stream(\"private_stream_2\", invite_only=True)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        stream_id = get_stream(\"private_stream_1\", user_profile.realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        stream = self.subscribe(user_profile, \"private_stream_1\")\n        self.assertFalse(stream.is_in_zephyr_realm)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        realm = user_profile.realm\n        stream = get_stream(\"private_stream_1\", realm)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Public**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        history_public_to_subscribers_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert history_public_to_subscribers_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(history_public_to_subscribers_log.extra_data, expected_extra_data)\n\n        invite_only_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).order_by(\"-id\")[1]\n        assert invite_only_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(invite_only_log.extra_data, expected_extra_data)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        stream = self.subscribe(user_profile, \"private_stream_2\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assertTrue(stream.invite_only)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_make_stream_private(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"public_stream_1\", realm=realm)\n        self.make_stream(\"public_stream_2\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"public_stream_1\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n        stream = get_stream(\"public_stream_1\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Public** to **Private, protected history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        history_public_to_subscribers_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert history_public_to_subscribers_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(history_public_to_subscribers_log.extra_data, expected_extra_data)\n\n        invite_only_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).order_by(\"-id\")[1]\n        assert invite_only_log is not None\n\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(invite_only_log.extra_data, expected_extra_data)\n\n        default_stream = self.make_stream(\"default_stream\", realm=realm)\n        do_add_default_stream(default_stream)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{default_stream.id}\", params)\n        self.assert_json_error(result, \"Default streams cannot be made private.\")\n        self.assertFalse(default_stream.invite_only)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n        }\n        stream = self.subscribe(user_profile, \"public_stream_2\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assertFalse(stream.invite_only)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_create_web_public_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        owner = self.example_user(\"desdemona\")\n\n        stream_names = [\"new1\", \"new2\", \"new3\"]\n        stream_descriptions = [\"des1\", \"des2\", \"des3\"]\n        streams_raw: List[StreamDict] = [\n            {\"name\": stream_name, \"description\": stream_description, \"is_web_public\": True}\n            for (stream_name, stream_description) in zip(stream_names, stream_descriptions)\n        ]\n\n        self.assertFalse(user_profile.can_create_web_public_streams())\n        self.assertTrue(owner.can_create_web_public_streams())\n        # As per create_web_public_stream_policy, only owners can create web-public streams by default.\n        with self.assertRaisesRegex(JsonableError, \"Insufficient permission\"):\n            list_to_streams(\n                streams_raw,\n                user_profile,\n                autocreate=True,\n            )\n\n        with self.settings(WEB_PUBLIC_STREAMS_ENABLED=False):\n            self.assertFalse(user_profile.can_create_web_public_streams())\n            self.assertFalse(owner.can_create_web_public_streams())\n            with self.assertRaisesRegex(JsonableError, \"Web-public streams are not enabled.\"):\n                list_to_streams(\n                    streams_raw,\n                    owner,\n                    autocreate=True,\n                )\n\n        existing_streams, new_streams = list_to_streams(\n            streams_raw,\n            owner,\n            autocreate=True,\n        )\n\n        self.assert_length(new_streams, 3)\n        self.assert_length(existing_streams, 0)\n\n        actual_stream_names = {stream.name for stream in new_streams}\n        self.assertEqual(actual_stream_names, set(stream_names))\n        actual_stream_descriptions = {stream.description for stream in new_streams}\n        self.assertEqual(actual_stream_descriptions, set(stream_descriptions))\n        for stream in new_streams:\n            self.assertTrue(stream.is_web_public)\n\n    def test_make_stream_public_zephyr_mirror(self) -> None:\n        user_profile = self.mit_user(\"starnine\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"target_stream\", realm=realm, invite_only=True)\n        self.subscribe(user_profile, \"target_stream\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n        }\n        stream_id = get_stream(\"target_stream\", realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params, subdomain=\"zephyr\")\n        self.assert_json_success(result)\n        stream = get_stream(\"target_stream\", realm)\n        self.assertFalse(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Public, protected history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_make_stream_private_with_public_history(self) -> None:\n        # Convert a public stream to a private stream with shared history\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"public_history_stream\", realm=realm)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"public_history_stream\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n        stream = get_stream(\"public_history_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Public** to **Private, shared history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"invite_only\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Convert a private stream with protected history to a private stream\n        # with shared history.\n        self.make_stream(\n            \"private_protected_stream\",\n            realm=realm,\n            invite_only=True,\n            history_public_to_subscribers=False,\n        )\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"private_protected_stream\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n        stream = get_stream(\"private_protected_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Private, shared history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_make_stream_web_public(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"test_stream\", realm=realm)\n        stream_id = self.subscribe(user_profile, \"test_stream\").id\n\n        params = {\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        do_set_realm_property(\n            realm, \"create_web_public_stream_policy\", Realm.POLICY_OWNERS_ONLY, acting_user=None\n        )\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(\n            realm, \"create_web_public_stream_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(\n            realm, \"create_web_public_stream_policy\", Realm.POLICY_OWNERS_ONLY, acting_user=None\n        )\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        with self.settings(WEB_PUBLIC_STREAMS_ENABLED=False):\n            result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Web-public streams are not enabled.\")\n\n        bad_params = {\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", bad_params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        bad_params = {\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"is_private\": orjson.dumps(False).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", bad_params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        stream = get_stream(\"test_stream\", realm)\n        self.assertFalse(stream.is_web_public)\n\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        stream = get_stream(\"test_stream\", realm)\n        self.assertTrue(stream.is_web_public)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**King Hamlet|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Public** to **Web-public**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"is_web_public\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_history_access_for_private_streams(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"private_stream\", realm=realm, invite_only=True)\n        stream_id = self.subscribe(user_profile, \"private_stream\").id\n\n        params = {\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        stream = get_stream(\"private_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**Iago|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, protected history** to **Private, shared history**.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: False,\n                RealmAuditLog.NEW_VALUE: True,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        params = {\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_success(result)\n\n        stream = get_stream(\"private_stream\", realm)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.history_public_to_subscribers)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 2)\n        expected_notification = (\n            f\"@_**Iago|{user_profile.id}** changed the [access permissions](/help/stream-permissions) \"\n            \"for this stream from **Private, shared history** to **Private, protected history**.\"\n        )\n        self.assertEqual(messages[1].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: True,\n                RealmAuditLog.NEW_VALUE: False,\n                \"property\": \"history_public_to_subscribers\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_stream_permission_changes_updates_updates_attachments(self) -> None:\n        self.login(\"desdemona\")\n        fp = StringIO(\"zulip!\")\n        fp.name = \"zulip.txt\"\n\n        result = self.client_post(\"/json/user_uploads\", {\"file\": fp})\n        url = self.assert_json_success(result)[\"uri\"]\n\n        owner = self.example_user(\"desdemona\")\n        realm = owner.realm\n        stream = self.make_stream(\"test_stream\", realm=realm)\n        self.subscribe(owner, \"test_stream\")\n        body = f\"First message ...[zulip.txt](http://{realm.host}\" + url + \")\"\n        msg_id = self.send_stream_message(owner, \"test_stream\", body, \"test\")\n        attachment = Attachment.objects.get(messages__id=msg_id)\n\n        self.assertFalse(stream.is_web_public)\n        self.assertFalse(attachment.is_web_public)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(attachment.is_realm_public)\n\n        params = {\n            \"is_private\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assert_json_success(result)\n\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertFalse(stream.is_web_public)\n        self.assertFalse(attachment.is_web_public)\n        self.assertTrue(stream.invite_only)\n        self.assertIsNone(attachment.is_realm_public)\n\n        cordelia = self.example_user(\"cordelia\")\n        self.assertFalse(validate_attachment_request(cordelia, attachment.path_id))\n        self.assertTrue(validate_attachment_request(owner, attachment.path_id))\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_realm_public)\n        self.assertFalse(validate_attachment_request_for_spectator_access(realm, attachment))\n\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n            \"is_web_public\": orjson.dumps(True).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assert_json_success(result)\n\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(stream.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n        self.assertIsNone(attachment.is_web_public)\n\n        self.assertTrue(validate_attachment_request_for_spectator_access(realm, attachment))\n        attachment.refresh_from_db()\n        self.assertTrue(attachment.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n\n        self.assertTrue(validate_attachment_request(cordelia, attachment.path_id))\n        attachment.refresh_from_db()\n        self.assertTrue(attachment.is_realm_public)\n\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n            \"is_web_public\": orjson.dumps(False).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(True).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream.id}\", params)\n        self.assert_json_success(result)\n\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertIsNone(attachment.is_web_public)\n        self.assertFalse(stream.invite_only)\n        self.assertTrue(attachment.is_realm_public)\n\n        self.assertFalse(validate_attachment_request_for_spectator_access(realm, attachment))\n        attachment.refresh_from_db()\n        stream.refresh_from_db()\n        self.assertFalse(attachment.is_web_public)\n\n        # Verify moving a message to another public stream doesn't reset cache.\n        new_stream = self.make_stream(\"new_stream\", realm=realm)\n        self.subscribe(owner, \"new_stream\")\n        result = self.client_patch(\n            \"/json/messages/\" + str(msg_id),\n            {\n                \"stream_id\": new_stream.id,\n                \"propagate_mode\": \"change_all\",\n            },\n        )\n        self.assert_json_success(result)\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_web_public)\n        self.assertTrue(attachment.is_realm_public)\n\n        # Verify moving a message to a private stream\n        private_stream = self.make_stream(\"private_stream\", realm=realm, invite_only=True)\n        self.subscribe(owner, \"private_stream\")\n        result = self.client_patch(\n            \"/json/messages/\" + str(msg_id),\n            {\n                \"stream_id\": private_stream.id,\n                \"propagate_mode\": \"change_all\",\n            },\n        )\n        self.assert_json_success(result)\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n\n        self.assertFalse(validate_attachment_request(cordelia, attachment.path_id))\n        self.assertTrue(validate_attachment_request(owner, attachment.path_id))\n        attachment.refresh_from_db()\n        self.assertFalse(attachment.is_realm_public)\n\n        # Verify moving a message to a web-public stream\n        web_public_stream = self.make_stream(\"web_public_stream\", realm=realm, is_web_public=True)\n        result = self.client_patch(\n            \"/json/messages/\" + str(msg_id),\n            {\n                \"stream_id\": web_public_stream.id,\n                \"propagate_mode\": \"change_all\",\n            },\n        )\n        self.assert_json_success(result)\n        attachment.refresh_from_db()\n        self.assertIsNone(attachment.is_web_public)\n        self.assertIsNone(attachment.is_realm_public)\n\n        self.assertTrue(validate_attachment_request_for_spectator_access(realm, attachment))\n        attachment.refresh_from_db()\n        self.assertTrue(attachment.is_web_public)\n\n    def test_try_make_stream_public_with_private_history(self) -> None:\n        # We only support public streams with private history if\n        # is_zephyr_mirror_realm, and don't allow changing stream\n        # permissions in such realms.  So changing the\n        # history_public_to_subscribers property of a public stream is\n        # not possible in Zulip today\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.make_stream(\"public_stream\", realm=realm)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        params = {\n            \"is_private\": orjson.dumps(False).decode(),\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        stream_id = self.subscribe(user_profile, \"public_stream\").id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        params = {\n            \"history_public_to_subscribers\": orjson.dumps(False).decode(),\n        }\n        result = self.client_patch(f\"/json/streams/{stream_id}\", params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n        web_public_stream = self.make_stream(\"web_public_stream\", realm=realm, is_web_public=True)\n        result = self.client_patch(f\"/json/streams/{web_public_stream.id}\", params)\n        self.assert_json_error(result, \"Invalid parameters\")\n\n    def test_subscriber_ids_with_stream_history_access(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        polonius = self.example_user(\"polonius\")\n\n        stream1 = self.make_stream(\n            \"history_private_stream\", invite_only=True, history_public_to_subscribers=False\n        )\n        self.subscribe(hamlet, stream1.name)\n        self.subscribe(polonius, stream1.name)\n        self.assertEqual(set(), subscriber_ids_with_stream_history_access(stream1))\n\n        stream2 = self.make_stream(\n            \"history_public_web_private_stream\",\n            invite_only=True,\n            is_web_public=False,\n            history_public_to_subscribers=True,\n        )\n        self.subscribe(hamlet, stream2.name)\n        self.subscribe(polonius, stream2.name)\n        self.assertEqual(\n            {hamlet.id, polonius.id}, subscriber_ids_with_stream_history_access(stream2)\n        )\n\n        stream3 = self.make_stream(\n            \"history_public_web_public_stream\",\n            is_web_public=True,\n            history_public_to_subscribers=True,\n        )\n        self.subscribe(hamlet, stream3.name)\n        self.subscribe(polonius, stream3.name)\n        self.assertEqual(\n            {hamlet.id, polonius.id}, subscriber_ids_with_stream_history_access(stream3)\n        )\n\n        stream4 = self.make_stream(\n            \"regular_public_stream\",\n        )\n        self.subscribe(hamlet, stream4.name)\n        self.subscribe(polonius, stream4.name)\n        self.assertEqual(\n            {hamlet.id, polonius.id}, subscriber_ids_with_stream_history_access(stream4)\n        )\n\n    def test_deactivate_stream_backend(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.make_stream(\"new_stream_1\")\n        self.subscribe(user_profile, stream.name)\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        result = self.client_delete(f\"/json/streams/{stream.id}\")\n        self.assert_json_success(result)\n        subscription_exists = (\n            get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=True)\n            .filter(\n                user_profile=user_profile,\n            )\n            .exists()\n        )\n        self.assertFalse(subscription_exists)\n\n    def test_deactivate_stream_removes_default_stream(self) -> None:\n        stream = self.make_stream(\"new_stream\")\n        do_add_default_stream(stream)\n        self.assertEqual(1, DefaultStream.objects.filter(stream_id=stream.id).count())\n        do_deactivate_stream(stream, acting_user=None)\n        self.assertEqual(0, DefaultStream.objects.filter(stream_id=stream.id).count())\n\n    def test_deactivate_stream_removes_stream_from_default_stream_groups(self) -> None:\n        realm = get_realm(\"zulip\")\n        streams_to_keep = []\n        for stream_name in [\"stream1\", \"stream2\"]:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams_to_keep.append(stream)\n\n        streams_to_remove = []\n        stream = ensure_stream(realm, \"stream3\", acting_user=None)\n        streams_to_remove.append(stream)\n\n        all_streams = streams_to_keep + streams_to_remove\n\n        def get_streams(group: DefaultStreamGroup) -> List[Stream]:\n            return list(group.streams.all().order_by(\"name\"))\n\n        group_name = \"group1\"\n        description = \"This is group1\"\n        do_create_default_stream_group(realm, group_name, description, all_streams)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assertEqual(get_streams(default_stream_groups[0]), all_streams)\n\n        do_deactivate_stream(streams_to_remove[0], acting_user=None)\n        self.assertEqual(get_streams(default_stream_groups[0]), streams_to_keep)\n\n    def test_deactivate_stream_marks_messages_as_read(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        stream = self.make_stream(\"new_stream\")\n        self.subscribe(hamlet, stream.name)\n        self.subscribe(cordelia, stream.name)\n        self.subscribe(hamlet, \"Denmark\")\n        self.subscribe(cordelia, \"Denmark\")\n\n        self.send_stream_message(hamlet, stream.name)\n        new_stream_usermessage = most_recent_usermessage(cordelia)\n\n        # We send a message to a different stream too, to verify that the\n        # deactivation of new_stream won't corrupt read state of UserMessage elsewhere.\n        self.send_stream_message(hamlet, \"Denmark\")\n        denmark_usermessage = most_recent_usermessage(cordelia)\n\n        self.assertFalse(new_stream_usermessage.flags.read)\n        self.assertFalse(denmark_usermessage.flags.read)\n\n        with self.captureOnCommitCallbacks(execute=True):\n            do_deactivate_stream(stream, acting_user=None)\n        new_stream_usermessage.refresh_from_db()\n        denmark_usermessage.refresh_from_db()\n        self.assertTrue(new_stream_usermessage.flags.read)\n        self.assertFalse(denmark_usermessage.flags.read)\n\n    def test_deactivated_streams_by_old_name(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream = self.make_stream(\"new_stream\")\n        do_deactivate_stream(stream, acting_user=None)\n        self.assertEqual(set(deactivated_streams_by_old_name(realm, \"new_stream\")), {stream})\n\n        second_stream = self.make_stream(\"new_stream\")\n        do_deactivate_stream(second_stream, acting_user=None)\n        self.assertEqual(\n            set(deactivated_streams_by_old_name(realm, \"new_stream\")), {stream, second_stream}\n        )\n\n        self.make_stream(\"!DEACTIVATED:old_style\")  # This is left active\n        old_style = self.make_stream(\"old_style\")\n        do_deactivate_stream(old_style, acting_user=None)\n        old_style.name = \"!!DEACTIVATED:old_style\"\n        old_style.save()\n        self.assertEqual(set(deactivated_streams_by_old_name(realm, \"old_style\")), {old_style})\n\n    def test_unarchive_stream_active_stream(self) -> None:\n        stream = self.make_stream(\"new_stream\")\n        with self.assertRaisesRegex(JsonableError, \"Stream is not currently deactivated\"):\n            do_unarchive_stream(stream, new_name=\"new_stream\", acting_user=None)\n\n    def test_unarchive_stream_existing_name(self) -> None:\n        stream = self.make_stream(\"new_stream\")\n        self.make_stream(\"existing\")\n        do_deactivate_stream(stream, acting_user=None)\n        with self.assertRaisesRegex(JsonableError, \"Stream named existing already exists\"):\n            do_unarchive_stream(stream, new_name=\"existing\", acting_user=None)\n\n    def test_unarchive_stream(self) -> None:\n        desdemona = self.example_user(\"desdemona\")\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n\n        stream = self.make_stream(\"new_stream\", is_web_public=True)\n        self.subscribe(hamlet, stream.name)\n        self.subscribe(cordelia, stream.name)\n        do_deactivate_stream(stream, acting_user=None)\n        with self.capture_send_event_calls(expected_num_events=4) as events:\n            do_unarchive_stream(stream, new_name=\"new_stream\", acting_user=None)\n\n        # Tell all admins and owners that the stream exists\n        self.assertEqual(events[0][\"event\"][\"op\"], \"create\")\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"name\"], \"new_stream\")\n        self.assertEqual(events[0][\"event\"][\"streams\"][0][\"stream_id\"], stream.id)\n        self.assertEqual(set(events[0][\"users\"]), {iago.id, desdemona.id})\n\n        # Tell the owners that they're subscribed to it\n        self.assertEqual(events[1][\"event\"][\"op\"], \"add\")\n        self.assertEqual(events[1][\"event\"][\"subscriptions\"][0][\"name\"], \"new_stream\")\n        self.assertEqual(events[1][\"event\"][\"subscriptions\"][0][\"stream_id\"], stream.id)\n        self.assertEqual(events[1][\"users\"], [desdemona.id])\n\n        # Send a message there logging the reactivation\n        self.assertEqual(events[2][\"event\"][\"type\"], \"message\")\n\n        # iago (as an admin) gets to know that desdemona (the owner) is now subscribed.\n        self.assertEqual(\n            events[3],\n            {\n                \"event\": {\n                    \"op\": \"peer_add\",\n                    \"stream_ids\": [stream.id],\n                    \"type\": \"subscription\",\n                    \"user_ids\": [desdemona.id],\n                },\n                \"users\": [iago.id],\n            },\n        )\n\n        stream = Stream.objects.get(id=stream.id)\n        self.assertFalse(stream.deactivated)\n        self.assertTrue(stream.invite_only)\n        self.assertFalse(stream.is_web_public)\n        self.assertTrue(stream.history_public_to_subscribers)\n\n        self.assertEqual(\n            [desdemona.id],\n            [\n                sub.user_profile_id\n                for sub in get_active_subscriptions_for_stream_id(\n                    stream.id, include_deactivated_users=True\n                )\n            ],\n        )\n\n    def test_vacate_private_stream_removes_default_stream(self) -> None:\n        stream = self.make_stream(\"new_stream\", invite_only=True)\n        self.subscribe(self.example_user(\"hamlet\"), stream.name)\n        do_add_default_stream(stream)\n        self.assertEqual(1, DefaultStream.objects.filter(stream_id=stream.id).count())\n        self.unsubscribe(self.example_user(\"hamlet\"), stream.name)\n        self.assertEqual(0, DefaultStream.objects.filter(stream_id=stream.id).count())\n        # Fetch stream again from database.\n        stream = Stream.objects.get(id=stream.id)\n        self.assertTrue(stream.deactivated)\n\n    def test_deactivate_stream_backend_requires_existing_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"new_stream\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        result = self.client_delete(\"/json/streams/999999999\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_deactivate_stream_backend_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.subscribe(user_profile, \"new_stream\")\n\n        result = self.client_delete(f\"/json/streams/{stream.id}\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_private_stream_live_updates(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        self.make_stream(\"private_stream\", invite_only=True)\n        self.subscribe(user_profile, \"private_stream\")\n        self.subscribe(self.example_user(\"cordelia\"), \"private_stream\")\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"private_stream\", user_profile.realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"description\": \"Test description\"},\n            )\n        self.assert_json_success(result)\n\n        cordelia = self.example_user(\"cordelia\")\n        prospero = self.example_user(\"prospero\")\n\n        notified_user_ids = set(events[0][\"users\"])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n        # Two events should be sent: a name event and a notification event\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"private_stream\", user_profile.realm).id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"whatever\"})\n        self.assert_json_success(result)\n\n        notified_user_ids = set(events[0][\"users\"])\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(cordelia.id, notified_user_ids)\n        self.assertNotIn(prospero.id, notified_user_ids)\n\n        notified_with_bot_users = events[-1][\"users\"]\n        notified_with_bot_user_ids = []\n        notified_with_bot_user_ids.append(notified_with_bot_users[0][\"id\"])\n        notified_with_bot_user_ids.append(notified_with_bot_users[1][\"id\"])\n        self.assertIn(user_profile.id, notified_with_bot_user_ids)\n        self.assertIn(cordelia.id, notified_with_bot_user_ids)\n        self.assertNotIn(prospero.id, notified_with_bot_user_ids)\n\n    def test_rename_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        stream = self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"stream_name1\"})\n        self.assert_json_error(result, \"Stream already has that name!\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"Denmark\"})\n        self.assert_json_error(result, \"Stream name 'Denmark' is already taken.\")\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"denmark \"})\n        self.assert_json_error(result, \"Stream name 'denmark' is already taken.\")\n\n        # Do a rename that is case-only--this should succeed.\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"sTREAm_name1\"})\n        self.assert_json_success(result)\n\n        # Two events should be sent: stream_name update and notification message.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"stream_name2\"})\n        self.assert_json_success(result)\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"name\",\n                value=\"stream_name2\",\n                stream_id=stream_id,\n                name=\"sTREAm_name1\",\n            ),\n        )\n        notified_user_ids = set(events[0][\"users\"])\n\n        self.assertRaises(Stream.DoesNotExist, get_stream, \"stream_name1\", realm)\n\n        stream_name2_exists = get_stream(\"stream_name2\", realm)\n        self.assertTrue(stream_name2_exists)\n\n        self.assertEqual(notified_user_ids, set(active_non_guest_user_ids(realm.id)))\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(self.example_user(\"prospero\").id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"polonius\").id, notified_user_ids)\n\n        # Test case to handle Unicode stream name change\n        # *NOTE: Here encoding is needed when Unicode string is passed as an argument*\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name2_exists.id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"\u0928\u092f\u093e \u0928\u093e\u092e\"})\n        self.assert_json_success(result)\n        # While querying, system can handle Unicode strings.\n        stream_name_uni_exists = get_stream(\"\u0928\u092f\u093e \u0928\u093e\u092e\", realm)\n        self.assertTrue(stream_name_uni_exists)\n\n        # Test case to handle changing of Unicode stream name to newer name\n        # NOTE: Unicode string being part of URL is handled cleanly\n        # by client_patch call, encoding of URL is not needed.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name_uni_exists.id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"new_name\": \"\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947\"},\n            )\n        self.assert_json_success(result)\n        # While querying, system can handle Unicode strings.\n        self.assertRaises(Stream.DoesNotExist, get_stream, \"\u0928\u092f\u093e \u0928\u093e\u092e\", realm)\n\n        stream_name_new_uni_exists = get_stream(\"\u0928\u093e\u092e \u092e\u0947\u0902 \u0915\u094d\u092f\u093e \u0930\u0915\u094d\u0916\u093e \u0939\u0947\", realm)\n        self.assertTrue(stream_name_new_uni_exists)\n\n        # Test case to change name from one language to other.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name_new_uni_exists.id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"fran\u00e7ais\"})\n        self.assert_json_success(result)\n        stream_name_fr_exists = get_stream(\"fran\u00e7ais\", realm)\n        self.assertTrue(stream_name_fr_exists)\n\n        # Test case to change name to mixed language name.\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = stream_name_fr_exists.id\n            result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"fran\u00e7ais name\"})\n        self.assert_json_success(result)\n        stream_name_mixed_exists = get_stream(\"fran\u00e7ais name\", realm)\n        self.assertTrue(stream_name_mixed_exists)\n\n        # Test case for notified users in private streams.\n        stream_private = self.make_stream(\n            \"stream_private_name1\", realm=user_profile.realm, invite_only=True\n        )\n        self.subscribe(self.example_user(\"cordelia\"), \"stream_private_name1\")\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"stream_private_name1\", realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"new_name\": \"stream_private_name2\"},\n            )\n        self.assert_json_success(result)\n        notified_user_ids = set(events[0][\"users\"])\n        self.assertEqual(notified_user_ids, can_access_stream_user_ids(stream_private))\n        self.assertIn(self.example_user(\"cordelia\").id, notified_user_ids)\n        # An important corner case is that all organization admins are notified.\n        self.assertIn(self.example_user(\"iago\").id, notified_user_ids)\n        # The current user, Hamlet was made an admin and thus should be notified too.\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"prospero\").id, notified_user_ids)\n\n    def test_rename_stream_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"stream_name1\")\n        self.subscribe(user_profile, \"stream_name1\")\n\n        stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"stream_name2\"})\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_notify_on_stream_rename(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        self.make_stream(\"stream_name1\")\n\n        stream = self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"stream_name2\"})\n        self.assert_json_success(result)\n\n        # Inspect the notification message sent\n        message = self.get_last_message()\n        actual_stream = Stream.objects.get(id=message.recipient.type_id)\n        message_content = f\"@_**King Hamlet|{user_profile.id}** renamed stream **stream_name1** to **stream_name2**.\"\n        self.assertEqual(actual_stream.name, \"stream_name2\")\n        self.assertEqual(actual_stream.realm_id, user_profile.realm_id)\n        self.assertEqual(message.recipient.type, Recipient.STREAM)\n        self.assertEqual(message.content, message_content)\n        self.assertEqual(message.sender.email, \"notification-bot@zulip.com\")\n        self.assertEqual(message.sender.realm, get_realm(settings.SYSTEM_BOT_REALM))\n\n    def test_realm_admin_can_update_unsub_private_stream(self) -> None:\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n\n        self.login_user(iago)\n        result = self.common_subscribe_to_streams(\n            iago,\n            [\"private_stream\"],\n            dict(principals=orjson.dumps([hamlet.id]).decode()),\n            invite_only=True,\n        )\n        self.assert_json_success(result)\n\n        stream_id = get_stream(\"private_stream\", iago.realm).id\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"new_private_stream\"})\n        self.assert_json_success(result)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"new description\"},\n        )\n        self.assert_json_success(result)\n\n        # But cannot change stream type.\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\n                \"is_private\": orjson.dumps(True).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_non_admin_cannot_access_unsub_private_stream(self) -> None:\n        iago = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n\n        self.login_user(hamlet)\n        result = self.common_subscribe_to_streams(\n            hamlet,\n            [\"private_stream_1\"],\n            dict(principals=orjson.dumps([iago.id]).decode()),\n            invite_only=True,\n        )\n        self.assert_json_success(result)\n\n        stream_id = get_stream(\"private_stream_1\", hamlet.realm).id\n\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"new_name\": \"private_stream_2\"})\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"new description\"},\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\n                \"is_private\": orjson.dumps(True).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        result = self.client_delete(f\"/json/streams/{stream_id}\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_change_stream_description(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        self.subscribe(user_profile, \"stream_name1\")\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            stream_id = get_stream(\"stream_name1\", realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"description\": \"Test description\"},\n            )\n        self.assert_json_success(result)\n\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"description\",\n                value=\"Test description\",\n                rendered_description=\"<p>Test description</p>\",\n                stream_id=stream_id,\n                name=\"stream_name1\",\n            ),\n        )\n        notified_user_ids = set(events[0][\"users\"])\n\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(notified_user_ids, set(active_non_guest_user_ids(realm.id)))\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(self.example_user(\"prospero\").id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"polonius\").id, notified_user_ids)\n        self.assertEqual(\"Test description\", stream.description)\n\n        result = self.client_patch(f\"/json/streams/{stream_id}\", {\"description\": \"a\" * 1025})\n        self.assert_json_error(\n            result,\n            f\"description is too long (limit: {Stream.MAX_DESCRIPTION_LENGTH} characters)\",\n        )\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"\"},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.description, \"\")\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the description for this stream.\\n\\n\"\n            \"* **Old description:**\\n\"\n            \"```` quote\\n\"\n            \"Test description\\n\"\n            \"````\\n\"\n            \"* **New description:**\\n\"\n            \"```` quote\\n\"\n            \"*No description.*\\n\"\n            \"````\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"Test description\"},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.description, \"Test description\")\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the description for this stream.\\n\\n\"\n            \"* **Old description:**\\n\"\n            \"```` quote\\n\"\n            \"*No description.*\\n\"\n            \"````\\n\"\n            \"* **New description:**\\n\"\n            \"```` quote\\n\"\n            \"Test description\\n\"\n            \"````\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\",\n            {\"description\": \"a\\nmulti\\nline\\ndescription\"},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.description, \"a multi line description\")\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the description for this stream.\\n\\n\"\n            \"* **Old description:**\\n\"\n            \"```` quote\\n\"\n            \"Test description\\n\"\n            \"````\\n\"\n            \"* **New description:**\\n\"\n            \"```` quote\\n\"\n            \"a multi line description\\n\"\n            \"````\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: \"Test description\",\n                RealmAuditLog.NEW_VALUE: \"a multi line description\",\n                \"property\": \"description\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Verify that we don't render inline URL previews in this code path.\n        with self.settings(INLINE_URL_EMBED_PREVIEW=True):\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\",\n                {\"description\": \"See https://zulip.com/team/\"},\n            )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(\n            stream.rendered_description,\n            '<p>See <a href=\"https://zulip.com/team/\">https://zulip.com/team/</a></p>',\n        )\n\n    def test_change_stream_description_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n\n        stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\", {\"description\": \"Test description\"}\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_change_to_stream_post_policy_admins(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n        result = self.client_patch(\n            f\"/json/streams/{stream_id}\", {\"is_announcement_only\": orjson.dumps(True).decode()}\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", user_profile.realm)\n        self.assertEqual(stream.stream_post_policy, Stream.STREAM_POST_POLICY_ADMINS)\n\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        expected_notification = (\n            f\"@_**{user_profile.full_name}|{user_profile.id}** changed the \"\n            \"[posting permissions](/help/stream-sending-policy) for this stream:\\n\\n\"\n            \"* **Old permissions**: All stream members can post.\\n\"\n            \"* **New permissions**: Only organization administrators can post.\"\n        )\n        self.assertEqual(messages[-1].content, expected_notification)\n\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n            modified_stream=stream,\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: Stream.STREAM_POST_POLICY_EVERYONE,\n                RealmAuditLog.NEW_VALUE: Stream.STREAM_POST_POLICY_ADMINS,\n                \"property\": \"stream_post_policy\",\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_stream_post_policy_requires_admin(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n\n        do_set_realm_property(user_profile.realm, \"waiting_period_threshold\", 10, acting_user=None)\n\n        def test_non_admin(how_old: int, is_new: bool, policy: int) -> None:\n            user_profile.date_joined = timezone_now() - timedelta(days=how_old)\n            user_profile.save()\n            self.assertEqual(user_profile.is_provisional_member, is_new)\n            stream_id = get_stream(\"stream_name1\", user_profile.realm).id\n            result = self.client_patch(\n                f\"/json/streams/{stream_id}\", {\"stream_post_policy\": orjson.dumps(policy).decode()}\n            )\n            self.assert_json_error(result, \"Must be an organization administrator\")\n\n        policies = [\n            Stream.STREAM_POST_POLICY_ADMINS,\n            Stream.STREAM_POST_POLICY_MODERATORS,\n            Stream.STREAM_POST_POLICY_RESTRICT_NEW_MEMBERS,\n        ]\n\n        for policy in policies:\n            test_non_admin(how_old=15, is_new=False, policy=policy)\n            test_non_admin(how_old=5, is_new=True, policy=policy)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        for policy in policies:\n            stream = get_stream(\"stream_name1\", user_profile.realm)\n            old_post_policy = stream.stream_post_policy\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\", {\"stream_post_policy\": orjson.dumps(policy).decode()}\n            )\n            self.assert_json_success(result)\n            stream = get_stream(\"stream_name1\", user_profile.realm)\n            self.assertEqual(stream.stream_post_policy, policy)\n\n            messages = get_topic_messages(user_profile, stream, \"stream events\")\n            expected_notification = (\n                f\"@_**{user_profile.full_name}|{user_profile.id}** changed the \"\n                \"[posting permissions](/help/stream-sending-policy) for this stream:\\n\\n\"\n                f\"* **Old permissions**: {Stream.POST_POLICIES[old_post_policy]}.\\n\"\n                f\"* **New permissions**: {Stream.POST_POLICIES[policy]}.\"\n            )\n\n            self.assertEqual(messages[-1].content, expected_notification)\n\n            realm_audit_log = RealmAuditLog.objects.filter(\n                event_type=RealmAuditLog.STREAM_PROPERTY_CHANGED,\n                modified_stream=stream,\n            ).last()\n            assert realm_audit_log is not None\n            expected_extra_data = orjson.dumps(\n                {\n                    RealmAuditLog.OLD_VALUE: old_post_policy,\n                    RealmAuditLog.NEW_VALUE: policy,\n                    \"property\": \"stream_post_policy\",\n                }\n            ).decode()\n            self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_stream_message_retention_days_notifications(self) -> None:\n        user_profile = self.example_user(\"desdemona\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_SELF_HOSTED, acting_user=None)\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        # Go from realm default (forever) to 2 days\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_success(result)\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 1)\n        expected_notification = (\n            f\"@_**Desdemona|{user_profile.id}** has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: Forever\\n\"\n            \"* **New retention period**: 2 days\\n\\n\"\n            \"Messages in this stream will now be automatically deleted 2 days after they are sent.\"\n        )\n        self.assertEqual(messages[0].content, expected_notification)\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {RealmAuditLog.OLD_VALUE: None, RealmAuditLog.NEW_VALUE: 2}\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Go from 2 days to 8 days\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(8).decode()}\n        )\n        self.assert_json_success(result)\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 2)\n        expected_notification = (\n            f\"@_**Desdemona|{user_profile.id}** has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: 2 days\\n\"\n            \"* **New retention period**: 8 days\\n\\n\"\n            \"Messages in this stream will now be automatically deleted 8 days after they are sent.\"\n        )\n        self.assertEqual(messages[1].content, expected_notification)\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {RealmAuditLog.OLD_VALUE: 2, RealmAuditLog.NEW_VALUE: 8}\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n        # Go from 8 days to realm default (None on stream, forever/-1 on realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"message_retention_days\": orjson.dumps(\"realm_default\").decode()},\n        )\n        self.assert_json_success(result)\n        messages = get_topic_messages(user_profile, stream, \"stream events\")\n        self.assert_length(messages, 3)\n        expected_notification = (\n            f\"@_**Desdemona|{user_profile.id}** has changed the [message retention period](/help/message-retention-policy) for this stream:\\n\"\n            \"* **Old retention period**: 8 days\\n\"\n            \"* **New retention period**: Forever\\n\\n\"\n            \"Messages in this stream will now be retained forever.\"\n        )\n        self.assertEqual(messages[2].content, expected_notification)\n        realm_audit_log = RealmAuditLog.objects.filter(\n            event_type=RealmAuditLog.STREAM_MESSAGE_RETENTION_DAYS_CHANGED\n        ).last()\n        assert realm_audit_log is not None\n        expected_extra_data = orjson.dumps(\n            {\n                RealmAuditLog.OLD_VALUE: 8,\n                RealmAuditLog.NEW_VALUE: None,\n            }\n        ).decode()\n        self.assertEqual(realm_audit_log.extra_data, expected_extra_data)\n\n    def test_change_stream_message_retention_days(self) -> None:\n        user_profile = self.example_user(\"desdemona\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_LIMITED, acting_user=None)\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_error(result, \"Available on Zulip Cloud Standard. Upgrade to access.\")\n\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_SELF_HOSTED, acting_user=None)\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n            )\n        self.assert_json_success(result)\n\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"message_retention_days\",\n                value=2,\n                stream_id=stream.id,\n                name=\"stream_name1\",\n            ),\n        )\n        notified_user_ids = set(events[0][\"users\"])\n        stream = get_stream(\"stream_name1\", realm)\n\n        self.assertEqual(notified_user_ids, set(active_non_guest_user_ids(realm.id)))\n        self.assertIn(user_profile.id, notified_user_ids)\n        self.assertIn(self.example_user(\"prospero\").id, notified_user_ids)\n        self.assertNotIn(self.example_user(\"polonius\").id, notified_user_ids)\n        self.assertEqual(stream.message_retention_days, 2)\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\",\n                {\"message_retention_days\": orjson.dumps(\"unlimited\").decode()},\n            )\n        self.assert_json_success(result)\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"message_retention_days\",\n                value=-1,\n                stream_id=stream.id,\n                name=\"stream_name1\",\n            ),\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.message_retention_days, -1)\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.client_patch(\n                f\"/json/streams/{stream.id}\",\n                {\"message_retention_days\": orjson.dumps(\"realm_default\").decode()},\n            )\n        self.assert_json_success(result)\n        event = events[0][\"event\"]\n        self.assertEqual(\n            event,\n            dict(\n                op=\"update\",\n                type=\"stream\",\n                property=\"message_retention_days\",\n                value=None,\n                stream_id=stream.id,\n                name=\"stream_name1\",\n            ),\n        )\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.message_retention_days, None)\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"message_retention_days\": orjson.dumps(\"invalid\").decode()},\n        )\n        self.assert_json_error(result, \"Bad value for 'message_retention_days': invalid\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(-1).decode()}\n        )\n        self.assert_json_error(result, \"Bad value for 'message_retention_days': -1\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(0).decode()}\n        )\n        self.assert_json_error(result, \"Bad value for 'message_retention_days': 0\")\n\n    def test_change_stream_message_retention_days_requires_realm_owner(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n        realm = user_profile.realm\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\", {\"message_retention_days\": orjson.dumps(2).decode()}\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.message_retention_days, 2)\n\n    def test_change_stream_can_remove_subscribers_group(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        realm = user_profile.realm\n        stream = self.subscribe(user_profile, \"stream_name1\")\n\n        moderators_system_group = UserGroup.objects.get(\n            name=\"@role:moderators\", realm=realm, is_system_group=True\n        )\n        self.login(\"shiva\")\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"iago\")\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name1\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n        # This setting can only be set to system groups.\n        hamletcharacters_group = UserGroup.objects.get(name=\"hamletcharacters\", realm=realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(hamletcharacters_group.id).decode()},\n        )\n        self.assert_json_error(\n            result, \"'can_remove_subscribers_group' must be a system user group.\"\n        )\n\n        internet_group = UserGroup.objects.get(\n            name=\"@role:internet\", is_system_group=True, realm=realm\n        )\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(internet_group.id).decode()},\n        )\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:internet' group.\",\n        )\n\n        owners_group = UserGroup.objects.get(name=\"@role:owners\", is_system_group=True, realm=realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(owners_group.id).decode()},\n        )\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:owners' group.\",\n        )\n\n        nobody_group = UserGroup.objects.get(name=\"@role:nobody\", is_system_group=True, realm=realm)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(nobody_group.id).decode()},\n        )\n        self.assert_json_error(\n            result,\n            \"'can_remove_subscribers_group' setting cannot be set to '@role:nobody' group.\",\n        )\n\n        # For private streams, even admins must be subscribed to the stream to change\n        # can_remove_subscribers_group setting.\n        stream = self.make_stream(\"stream_name2\", invite_only=True)\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.subscribe(user_profile, \"stream_name2\")\n        result = self.client_patch(\n            f\"/json/streams/{stream.id}\",\n            {\"can_remove_subscribers_group_id\": orjson.dumps(moderators_system_group.id).decode()},\n        )\n        self.assert_json_success(result)\n        stream = get_stream(\"stream_name2\", realm)\n        self.assertEqual(stream.can_remove_subscribers_group.id, moderators_system_group.id)\n\n    def test_stream_message_retention_days_on_stream_creation(self) -> None:\n        \"\"\"\n        Only admins can create streams with message_retention_days\n        with value other than None.\n        \"\"\"\n        admin = self.example_user(\"iago\")\n\n        streams_raw: List[StreamDict] = [\n            {\n                \"name\": \"new_stream\",\n                \"message_retention_days\": 10,\n                \"is_web_public\": False,\n            }\n        ]\n        with self.assertRaisesRegex(JsonableError, \"Must be an organization owner\"):\n            list_to_streams(streams_raw, admin, autocreate=True)\n\n        streams_raw = [\n            {\n                \"name\": \"new_stream\",\n                \"message_retention_days\": -1,\n                \"is_web_public\": False,\n            }\n        ]\n        with self.assertRaisesRegex(JsonableError, \"Must be an organization owner\"):\n            list_to_streams(streams_raw, admin, autocreate=True)\n\n        streams_raw = [\n            {\n                \"name\": \"new_stream\",\n                \"message_retention_days\": None,\n                \"is_web_public\": False,\n            }\n        ]\n        result = list_to_streams(streams_raw, admin, autocreate=True)\n        self.assert_length(result[0], 0)\n        self.assert_length(result[1], 1)\n        self.assertEqual(result[1][0].name, \"new_stream\")\n        self.assertEqual(result[1][0].message_retention_days, None)\n\n        owner = self.example_user(\"desdemona\")\n        realm = owner.realm\n        streams_raw = [\n            {\n                \"name\": \"new_stream1\",\n                \"message_retention_days\": 10,\n                \"is_web_public\": False,\n            },\n            {\n                \"name\": \"new_stream2\",\n                \"message_retention_days\": -1,\n                \"is_web_public\": False,\n            },\n            {\n                \"name\": \"new_stream3\",\n                \"is_web_public\": False,\n            },\n        ]\n\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_LIMITED, acting_user=admin)\n        with self.assertRaisesRegex(\n            JsonableError, \"Available on Zulip Cloud Standard. Upgrade to access.\"\n        ):\n            list_to_streams(streams_raw, owner, autocreate=True)\n\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_SELF_HOSTED, acting_user=admin)\n        result = list_to_streams(streams_raw, owner, autocreate=True)\n        self.assert_length(result[0], 0)\n        self.assert_length(result[1], 3)\n        self.assertEqual(result[1][0].name, \"new_stream1\")\n        self.assertEqual(result[1][0].message_retention_days, 10)\n        self.assertEqual(result[1][1].name, \"new_stream2\")\n        self.assertEqual(result[1][1].message_retention_days, -1)\n        self.assertEqual(result[1][2].name, \"new_stream3\")\n        self.assertEqual(result[1][2].message_retention_days, None)\n\n    def set_up_stream_for_archiving(\n        self, stream_name: str, invite_only: bool = False, subscribed: bool = True\n    ) -> Stream:\n        \"\"\"\n        Create a stream for archiving by an administrator.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.make_stream(stream_name, invite_only=invite_only)\n\n        # For testing archiving streams you aren't on.\n        if subscribed:\n            self.subscribe(user_profile, stream_name)\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        return stream\n\n    def archive_stream(self, stream: Stream) -> None:\n        \"\"\"\n        Archive the stream and assess the result.\n        \"\"\"\n        active_name = stream.name\n        realm = stream.realm\n        stream_id = stream.id\n\n        # Simulate that a stream by the same name has already been\n        # deactivated, just to exercise our renaming logic:\n        # Since we do not know the id of these simulated stream we prepend the name with a random hashed_stream_id\n        ensure_stream(realm, \"DB32B77!DEACTIVATED:\" + active_name, acting_user=None)\n\n        with self.capture_send_event_calls(expected_num_events=1) as events:\n            result = self.client_delete(\"/json/streams/\" + str(stream_id))\n        self.assert_json_success(result)\n\n        # We no longer send subscription events for stream deactivations.\n        sub_events = [e for e in events if e[\"event\"][\"type\"] == \"subscription\"]\n        self.assertEqual(sub_events, [])\n\n        stream_events = [e for e in events if e[\"event\"][\"type\"] == \"stream\"]\n        self.assert_length(stream_events, 1)\n        event = stream_events[0][\"event\"]\n        self.assertEqual(event[\"op\"], \"delete\")\n        self.assertEqual(event[\"streams\"][0][\"stream_id\"], stream.id)\n\n        with self.assertRaises(Stream.DoesNotExist):\n            Stream.objects.get(realm=get_realm(\"zulip\"), name=active_name)\n\n        # A deleted stream's name is changed, is deactivated, is invite-only,\n        # and has no subscribers.\n        hashed_stream_id = hashlib.sha512(str(stream_id).encode()).hexdigest()[0:7]\n        deactivated_stream_name = hashed_stream_id + \"!DEACTIVATED:\" + active_name\n        deactivated_stream = get_stream(deactivated_stream_name, realm)\n        self.assertTrue(deactivated_stream.deactivated)\n        self.assertTrue(deactivated_stream.invite_only)\n        self.assertEqual(deactivated_stream.name, deactivated_stream_name)\n        subscribers = self.users_subscribed_to_stream(deactivated_stream_name, realm)\n        self.assertEqual(subscribers, [])\n\n        # It doesn't show up in the list of public streams anymore.\n        result = self.client_get(\"/json/streams\", {\"include_subscribed\": \"false\"})\n        public_streams = [s[\"name\"] for s in self.assert_json_success(result)[\"streams\"]]\n        self.assertNotIn(active_name, public_streams)\n        self.assertNotIn(deactivated_stream_name, public_streams)\n\n        # Even if you could guess the new name, you can't subscribe to it.\n        result = self.client_post(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": orjson.dumps([{\"name\": deactivated_stream_name}]).decode()},\n        )\n        self.assert_json_error(result, f\"Unable to access stream ({deactivated_stream_name}).\")\n\n        # You cannot re-archive the stream\n        with self.capture_send_event_calls(expected_num_events=0) as events:\n            result = self.client_delete(\"/json/streams/\" + str(stream_id))\n        self.assert_json_error(result, \"Stream is already deactivated\")\n\n    def test_you_must_be_realm_admin(self) -> None:\n        \"\"\"\n        You must be on the realm to create a stream.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n\n        other_realm = do_create_realm(string_id=\"other\", name=\"other\")\n        stream = self.make_stream(\"other_realm_stream\", realm=other_realm)\n\n        result = self.client_delete(\"/json/streams/\" + str(stream.id))\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # Even becoming a realm admin doesn't help us for an out-of-realm\n        # stream.\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        result = self.client_delete(\"/json/streams/\" + str(stream.id))\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_delete_public_stream(self) -> None:\n        \"\"\"\n        When an administrator deletes a public stream, that stream is not\n        visible to users at all anymore.\n        \"\"\"\n        stream = self.set_up_stream_for_archiving(\"newstream\")\n        self.archive_stream(stream)\n\n    def test_delete_private_stream(self) -> None:\n        \"\"\"\n        Administrators can delete private streams they are on.\n        \"\"\"\n        stream = self.set_up_stream_for_archiving(\"newstream\", invite_only=True)\n        self.archive_stream(stream)\n\n    def test_archive_stream_youre_not_on(self) -> None:\n        \"\"\"\n        Administrators can delete public streams they aren't on\n        \"\"\"\n        pub_stream = self.set_up_stream_for_archiving(\"pubstream\", subscribed=False)\n        self.archive_stream(pub_stream)\n\n    def test_archive_invite_only_stream_youre_not_on(self) -> None:\n        \"\"\"\n        Administrators can delete invite-only streams they aren't on\n        \"\"\"\n        priv_stream = self.set_up_stream_for_archiving(\n            \"privstream\", subscribed=False, invite_only=True\n        )\n        self.archive_stream(priv_stream)\n\n    def attempt_unsubscribe_of_principal(\n        self,\n        target_users: List[UserProfile],\n        query_count: int,\n        cache_count: Optional[int] = None,\n        is_realm_admin: bool = False,\n        is_subbed: bool = True,\n        invite_only: bool = False,\n        target_users_subbed: bool = True,\n        using_legacy_emails: bool = False,\n        other_sub_users: Sequence[UserProfile] = [],\n    ) -> \"TestHttpResponse\":\n        # Set up the main user, who is in most cases an admin.\n        if is_realm_admin:\n            user_profile = self.example_user(\"iago\")\n        else:\n            user_profile = self.example_user(\"hamlet\")\n\n        self.login_user(user_profile)\n\n        # Set up the stream.\n        stream_name = \"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name, invite_only=invite_only)\n\n        # Set up the principal to be unsubscribed.\n        principals: List[Union[str, int]] = []\n        for user in target_users:\n            if using_legacy_emails:\n                principals.append(user.email)\n            else:\n                principals.append(user.id)\n\n        # Subscribe the admin and/or principal as specified in the flags.\n        if is_subbed:\n            self.subscribe(user_profile, stream_name)\n        if target_users_subbed:\n            for user in target_users:\n                self.subscribe(user, stream_name)\n        for user in other_sub_users:\n            self.subscribe(user, stream_name)\n\n        with self.assert_database_query_count(query_count):\n            with cache_tries_captured() as cache_tries:\n                result = self.client_delete(\n                    \"/json/users/me/subscriptions\",\n                    {\n                        \"subscriptions\": orjson.dumps([stream_name]).decode(),\n                        \"principals\": orjson.dumps(principals).decode(),\n                    },\n                )\n        if cache_count is not None:\n            self.assert_length(cache_tries, cache_count)\n\n        # If the removal succeeded, assert all target users are no longer subscribed.\n        if result.status_code not in [400]:\n            subbed_users = self.users_subscribed_to_stream(stream_name, user_profile.realm)\n            for user in target_users:\n                self.assertNotIn(user, subbed_users)\n\n        return result\n\n    def test_cant_remove_other_users_from_stream(self) -> None:\n        \"\"\"\n        If you're not an admin, you can't remove other people from streams except your own bots.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=7,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_realm_admin_remove_others_from_public_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove people from public streams, even\n        those you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=15,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_realm_admin_remove_multiple_users_from_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove multiple users from a stream.\n\n        TODO: We have too many queries for this situation--each additional\n              user leads to 4 more queries.\n\n              Fortunately, some of the extra work here is in\n              do_mark_stream_messages_as_read, which gets deferred\n              using a queue.\n        \"\"\"\n        target_users = [\n            self.example_user(name)\n            for name in [\"cordelia\", \"prospero\", \"iago\", \"hamlet\", \"outgoing_webhook_bot\"]\n        ]\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=27,\n            cache_count=9,\n            target_users=target_users,\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 5)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_realm_admin_remove_others_from_subbed_private_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove other people from private streams you\n        are on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=16,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=True,\n            target_users_subbed=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_realm_admin_remove_others_from_unsubbed_private_stream(self) -> None:\n        \"\"\"\n        If you're a realm admin, you can remove people from private\n        streams you aren't on.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=16,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=False,\n            invite_only=True,\n            target_users_subbed=True,\n            other_sub_users=[self.example_user(\"othello\")],\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_cant_remove_others_from_stream_legacy_emails(self) -> None:\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=7,\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users=[self.example_user(\"cordelia\")],\n            target_users_subbed=True,\n            using_legacy_emails=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_admin_remove_others_from_stream_legacy_emails(self) -> None:\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=15,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n            using_legacy_emails=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 1)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_admin_remove_multiple_users_from_stream_legacy_emails(self) -> None:\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=18,\n            target_users=[self.example_user(\"cordelia\"), self.example_user(\"prospero\")],\n            is_realm_admin=True,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n            using_legacy_emails=True,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 2)\n        self.assert_length(json[\"not_removed\"], 0)\n\n    def test_remove_already_not_subbed(self) -> None:\n        \"\"\"\n        Trying to unsubscribe someone who already isn't subscribed to a stream\n        fails gracefully.\n        \"\"\"\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=10,\n            target_users=[self.example_user(\"cordelia\")],\n            is_realm_admin=True,\n            is_subbed=False,\n            invite_only=False,\n            target_users_subbed=False,\n        )\n        json = self.assert_json_success(result)\n        self.assert_length(json[\"removed\"], 0)\n        self.assert_length(json[\"not_removed\"], 1)\n\n    def test_bot_owner_can_remove_bot_from_stream(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        webhook_bot = self.example_user(\"webhook_bot\")\n        do_change_bot_owner(webhook_bot, bot_owner=user_profile, acting_user=user_profile)\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=14,\n            target_users=[webhook_bot],\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        self.assert_json_success(result)\n\n    def test_non_bot_owner_cannot_remove_bot_from_stream(self) -> None:\n        other_user = self.example_user(\"cordelia\")\n        webhook_bot = self.example_user(\"webhook_bot\")\n        do_change_bot_owner(webhook_bot, bot_owner=other_user, acting_user=other_user)\n        result = self.attempt_unsubscribe_of_principal(\n            query_count=8,\n            target_users=[webhook_bot],\n            is_realm_admin=False,\n            is_subbed=True,\n            invite_only=False,\n            target_users_subbed=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_can_remove_subscribers_group(self) -> None:\n        realm = get_realm(\"zulip\")\n        leadership_group = check_add_user_group(\n            realm,\n            \"leadership\",\n            [self.example_user(\"iago\"), self.example_user(\"shiva\")],\n            acting_user=None,\n        )\n        managers_group = check_add_user_group(\n            realm, \"managers\", [self.example_user(\"hamlet\")], acting_user=None\n        )\n        add_subgroups_to_user_group(managers_group, [leadership_group], acting_user=None)\n        cordelia = self.example_user(\"cordelia\")\n\n        stream = self.make_stream(\"public_stream\")\n\n        def check_unsubscribing_user(\n            user: UserProfile, can_remove_subscribers_group: UserGroup, expect_fail: bool = False\n        ) -> None:\n            self.login_user(user)\n            self.subscribe(cordelia, stream.name)\n            do_change_stream_group_based_setting(\n                stream,\n                \"can_remove_subscribers_group\",\n                can_remove_subscribers_group,\n                acting_user=None,\n            )\n            result = self.client_delete(\n                \"/json/users/me/subscriptions\",\n                {\n                    \"subscriptions\": orjson.dumps([stream.name]).decode(),\n                    \"principals\": orjson.dumps([cordelia.id]).decode(),\n                },\n            )\n            if expect_fail:\n                self.assert_json_error(result, \"Insufficient permission\")\n                return\n\n            json = self.assert_json_success(result)\n            self.assert_length(json[\"removed\"], 1)\n            self.assert_length(json[\"not_removed\"], 0)\n\n        check_unsubscribing_user(self.example_user(\"hamlet\"), leadership_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"desdemona\"), leadership_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"iago\"), leadership_group)\n\n        check_unsubscribing_user(self.example_user(\"othello\"), managers_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"shiva\"), managers_group)\n        check_unsubscribing_user(self.example_user(\"hamlet\"), managers_group)\n\n        stream = self.make_stream(\"private_stream\", invite_only=True)\n        self.subscribe(self.example_user(\"hamlet\"), stream.name)\n        # Non-admins are not allowed to unsubscribe others from private streams that they\n        # are not subscribed to even if they are member of the allowed group.\n        check_unsubscribing_user(self.example_user(\"shiva\"), leadership_group, expect_fail=True)\n        check_unsubscribing_user(self.example_user(\"iago\"), leadership_group)\n\n        self.subscribe(self.example_user(\"shiva\"), stream.name)\n        check_unsubscribing_user(self.example_user(\"shiva\"), leadership_group)\n\n    def test_remove_invalid_user(self) -> None:\n        \"\"\"\n        Trying to unsubscribe an invalid user from a stream fails gracefully.\n        \"\"\"\n        admin = self.example_user(\"iago\")\n        self.login_user(admin)\n        self.assertTrue(admin.is_realm_admin)\n\n        stream_name = \"h\u00fcmb\u00fc\u01f5\"\n        self.make_stream(stream_name)\n\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\",\n            {\n                \"subscriptions\": orjson.dumps([stream_name]).decode(),\n                \"principals\": orjson.dumps([99]).decode(),\n            },\n        )\n        self.assert_json_error(\n            result, \"User not authorized to execute queries on behalf of '99'\", status_code=403\n        )\n\n\nclass DefaultStreamTest(ZulipTestCase):\n    def get_default_stream_names(self, realm: Realm) -> Set[str]:\n        streams = get_default_streams_for_realm(realm.id)\n        stream_names = [s.name for s in streams]\n        return set(stream_names)\n\n    def test_add_and_remove_default_stream(self) -> None:\n        realm = get_realm(\"zulip\")\n        stream = ensure_stream(realm, \"Added stream\", acting_user=None)\n        orig_stream_names = self.get_default_stream_names(realm)\n        do_add_default_stream(stream)\n        new_stream_names = self.get_default_stream_names(realm)\n        added_stream_names = new_stream_names - orig_stream_names\n        self.assertEqual(added_stream_names, {\"Added stream\"})\n        # idempotency--2nd call to add_default_stream should be a noop\n        do_add_default_stream(stream)\n        self.assertEqual(self.get_default_stream_names(realm), new_stream_names)\n\n        # start removing\n        do_remove_default_stream(stream)\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n        # idempotency--2nd call to remove_default_stream should be a noop\n        do_remove_default_stream(stream)\n        self.assertEqual(self.get_default_stream_names(realm), orig_stream_names)\n\n    def test_api_calls(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        self.login_user(user_profile)\n\n        DefaultStream.objects.filter(realm=user_profile.realm).delete()\n\n        stream_name = \"stream ADDED via api\"\n        stream = ensure_stream(user_profile.realm, stream_name, acting_user=None)\n        result = self.client_post(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_success(result)\n        self.assertTrue(stream_name in self.get_default_stream_names(user_profile.realm))\n\n        # look for it\n        self.subscribe(user_profile, stream_name)\n        payload = dict(\n            include_public=\"true\",\n            include_default=\"true\",\n        )\n        result = self.client_get(\"/json/streams\", payload)\n        streams = self.assert_json_success(result)[\"streams\"]\n        default_streams = {stream[\"name\"] for stream in streams if stream[\"is_default\"]}\n        self.assertEqual(default_streams, {stream_name})\n\n        other_streams = {stream[\"name\"] for stream in streams if not stream[\"is_default\"]}\n        self.assertGreater(len(other_streams), 0)\n\n        # and remove it\n        result = self.client_delete(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_success(result)\n        self.assertFalse(stream_name in self.get_default_stream_names(user_profile.realm))\n\n        # Test admin can't access unsubscribed private stream for adding.\n        stream_name = \"private_stream\"\n        stream = self.make_stream(stream_name, invite_only=True)\n        self.subscribe(self.example_user(\"iago\"), stream_name)\n        result = self.client_post(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # Test admin can't add subscribed private stream also.\n        self.subscribe(user_profile, stream_name)\n        result = self.client_post(\"/json/default_streams\", dict(stream_id=stream.id))\n        self.assert_json_error(result, \"Private streams cannot be made default.\")\n\n    def test_guest_user_access_to_streams(self) -> None:\n        user_profile = self.example_user(\"polonius\")\n        self.login_user(user_profile)\n        self.assertEqual(user_profile.role, UserProfile.ROLE_GUEST)\n\n        # Get all the streams that Polonius has access to (subscribed + web-public streams)\n        result = self.client_get(\"/json/streams\", {\"include_web_public\": \"true\"})\n        streams = self.assert_json_success(result)[\"streams\"]\n        sub_info = gather_subscriptions_helper(user_profile)\n\n        subscribed = sub_info.subscriptions\n        unsubscribed = sub_info.unsubscribed\n        never_subscribed = sub_info.never_subscribed\n\n        self.assert_length(streams, len(subscribed) + len(unsubscribed) + len(never_subscribed))\n        stream_names = [stream[\"name\"] for stream in streams]\n        expected_stream_names = [stream[\"name\"] for stream in subscribed + unsubscribed]\n        expected_stream_names += [stream[\"name\"] for stream in never_subscribed]\n        self.assertEqual(set(stream_names), set(expected_stream_names))\n\n\nclass DefaultStreamGroupTest(ZulipTestCase):\n    def test_create_update_and_remove_default_stream_group(self) -> None:\n        realm = get_realm(\"zulip\")\n\n        # Test creating new default stream group\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        streams = []\n        for stream_name in [\"stream1\", \"stream2\", \"stream3\"]:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        def get_streams(group: DefaultStreamGroup) -> List[Stream]:\n            return list(group.streams.all().order_by(\"name\"))\n\n        group_name = \"group1\"\n        description = \"This is group1\"\n        do_create_default_stream_group(realm, group_name, description, streams)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(default_stream_groups[0].description, description)\n        self.assertEqual(get_streams(default_stream_groups[0]), streams)\n\n        # Test adding streams to existing default stream group\n        group = lookup_default_stream_groups([\"group1\"], realm)[0]\n        new_stream_names = [\"stream4\", \"stream5\"]\n        new_streams = []\n        for new_stream_name in new_stream_names:\n            new_stream = ensure_stream(realm, new_stream_name, acting_user=None)\n            new_streams.append(new_stream)\n            streams.append(new_stream)\n\n        do_add_streams_to_default_stream_group(realm, group, new_streams)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(get_streams(default_stream_groups[0]), streams)\n\n        # Test removing streams from existing default stream group\n        do_remove_streams_from_default_stream_group(realm, group, new_streams)\n        remaining_streams = streams[0:3]\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(get_streams(default_stream_groups[0]), remaining_streams)\n\n        # Test changing default stream group description\n        new_description = \"group1 new description\"\n        do_change_default_stream_group_description(realm, group, new_description)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assertEqual(default_stream_groups[0].description, new_description)\n        self.assert_length(default_stream_groups, 1)\n\n        # Test changing default stream group name\n        new_group_name = \"new group1\"\n        do_change_default_stream_group_name(realm, group, new_group_name)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, new_group_name)\n        self.assertEqual(get_streams(default_stream_groups[0]), remaining_streams)\n\n        # Test removing default stream group\n        do_remove_default_stream_group(realm, group)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        # Test creating a default stream group which contains a default stream\n        do_add_default_stream(remaining_streams[0])\n        with self.assertRaisesRegex(\n            JsonableError, \"'stream1' is a default stream and cannot be added to 'new group1'\"\n        ):\n            do_create_default_stream_group(\n                realm, new_group_name, \"This is group1\", remaining_streams\n            )\n\n    def test_api_calls(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n\n        # Test creating new default stream group\n        stream_names = [\"stream1\", \"stream2\", \"stream3\"]\n        group_name = \"group1\"\n        description = \"This is group1\"\n        streams = []\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        for stream_name in stream_names:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": group_name,\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(default_stream_groups[0].description, description)\n        self.assertEqual(list(default_stream_groups[0].streams.all().order_by(\"id\")), streams)\n\n        # Try adding the same streams to the group.\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": group_name,\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Default stream group 'group1' already exists\")\n\n        # Test adding streams to existing default stream group\n        group_id = default_stream_groups[0].id\n        new_stream_names = [\"stream4\", \"stream5\"]\n        new_streams = []\n        for new_stream_name in new_stream_names:\n            new_stream = ensure_stream(realm, new_stream_name, acting_user=None)\n            new_streams.append(new_stream)\n            streams.append(new_stream)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, \"Missing 'op' argument\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"invalid\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, 'Invalid value for \"op\". Specify one of \"add\" or \"remove\".')\n\n        result = self.client_patch(\n            \"/json/default_stream_groups/12345/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, \"Default stream group with id '12345' does not exist.\")\n\n        result = self.client_patch(f\"/json/default_stream_groups/{group_id}/streams\", {\"op\": \"add\"})\n        self.assert_json_error(result, \"Missing 'stream_names' argument\")\n\n        do_add_default_stream(new_streams[0])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(\n            result, \"'stream4' is a default stream and cannot be added to 'group1'\"\n        )\n\n        do_remove_default_stream(new_streams[0])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(list(default_stream_groups[0].streams.all().order_by(\"name\")), streams)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"add\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(\n            result, \"Stream 'stream4' is already present in default stream group 'group1'\"\n        )\n\n        # Test removing streams from default stream group\n        result = self.client_patch(\n            \"/json/default_stream_groups/12345/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(result, \"Default stream group with id '12345' does not exist.\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps([\"random stream name\"]).decode()},\n        )\n        self.assert_json_error(result, \"Invalid stream name 'random stream name'\")\n\n        streams.remove(new_streams[0])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps([new_stream_names[0]]).decode()},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(list(default_stream_groups[0].streams.all().order_by(\"name\")), streams)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}/streams\",\n            {\"op\": \"remove\", \"stream_names\": orjson.dumps(new_stream_names).decode()},\n        )\n        self.assert_json_error(\n            result, \"Stream 'stream4' is not present in default stream group 'group1'\"\n        )\n\n        # Test changing description of default stream group\n        new_description = \"new group1 description\"\n\n        result = self.client_patch(f\"/json/default_stream_groups/{group_id}\")\n        self.assert_json_error(result, 'You must pass \"new_description\" or \"new_group_name\".')\n\n        result = self.client_patch(\n            \"/json/default_stream_groups/12345\",\n            {\"new_description\": new_description},\n        )\n        self.assert_json_error(result, \"Default stream group with id '12345' does not exist.\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_description\": new_description},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, group_name)\n        self.assertEqual(default_stream_groups[0].description, new_description)\n\n        # Test changing name of default stream group\n        new_group_name = \"new group1\"\n        do_create_default_stream_group(realm, \"group2\", \"\", [])\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_group_name\": \"group2\"},\n        )\n        self.assert_json_error(result, \"Default stream group 'group2' already exists\")\n        new_group = lookup_default_stream_groups([\"group2\"], realm)[0]\n        do_remove_default_stream_group(realm, new_group)\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_group_name\": group_name},\n        )\n        self.assert_json_error(result, \"This default stream group is already named 'group1'\")\n\n        result = self.client_patch(\n            f\"/json/default_stream_groups/{group_id}\",\n            {\"new_group_name\": new_group_name},\n        )\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 1)\n        self.assertEqual(default_stream_groups[0].name, new_group_name)\n        self.assertEqual(default_stream_groups[0].description, new_description)\n\n        # Test deleting a default stream group\n        result = self.client_delete(f\"/json/default_stream_groups/{group_id}\")\n        self.assert_json_success(result)\n        default_stream_groups = get_default_stream_groups(realm)\n        self.assert_length(default_stream_groups, 0)\n\n        result = self.client_delete(f\"/json/default_stream_groups/{group_id}\")\n        self.assert_json_error(result, f\"Default stream group with id '{group_id}' does not exist.\")\n\n    def test_invalid_default_stream_group_name(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        realm = user_profile.realm\n\n        stream_names = [\"stream1\", \"stream2\", \"stream3\"]\n        description = \"This is group1\"\n        streams = []\n\n        for stream_name in stream_names:\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": \"\",\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(result, \"Invalid default stream group name ''\")\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": \"x\" * 100,\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(\n            result,\n            \"Default stream group name too long (limit: {} characters)\".format(\n                DefaultStreamGroup.MAX_NAME_LENGTH\n            ),\n        )\n\n        result = self.client_post(\n            \"/json/default_stream_groups/create\",\n            {\n                \"group_name\": \"abc\\000\",\n                \"description\": description,\n                \"stream_names\": orjson.dumps(stream_names).decode(),\n            },\n        )\n        self.assert_json_error(\n            result, \"Default stream group name 'abc\\000' contains NULL (0x00) characters.\"\n        )\n\n        # Also test that lookup_default_stream_groups raises an\n        # error if we pass it a bad name.  This function is used\n        # during registration, but it's a bit heavy to do a full\n        # test of that.\n        with self.assertRaisesRegex(JsonableError, \"Invalid default stream group invalid-name\"):\n            lookup_default_stream_groups([\"invalid-name\"], realm)\n\n\nclass SubscriptionPropertiesTest(ZulipTestCase):\n    def test_set_stream_color(self) -> None:\n        \"\"\"\n        A POST request to /api/v1/users/me/subscriptions/properties with stream_id and\n        color data sets the stream color, and for that stream only. Also, make sure that\n        any invalid hex color codes are bounced.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        old_subs, _ = gather_subscriptions(test_user)\n        sub = old_subs[0]\n        stream_id = sub[\"stream_id\"]\n        new_color = \"#ffffff\"  # TODO: ensure that this is different from old_color\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"stream_id\": stream_id, \"value\": \"#ffffff\"}]\n                ).decode()\n            },\n        )\n        self.assert_json_success(result)\n\n        new_subs = gather_subscriptions(test_user)[0]\n        found_sub = None\n        for sub in new_subs:\n            if sub[\"stream_id\"] == stream_id:\n                found_sub = sub\n                break\n\n        assert found_sub is not None\n        self.assertEqual(found_sub[\"color\"], new_color)\n\n        new_subs.remove(found_sub)\n        for sub in old_subs:\n            if sub[\"stream_id\"] == stream_id:\n                found_sub = sub\n                break\n        old_subs.remove(found_sub)\n        self.assertEqual(old_subs, new_subs)\n\n        invalid_color = \"3ffrff\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"stream_id\": stream_id, \"value\": invalid_color}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"color is not a valid hex color code\")\n\n    def test_set_color_missing_stream_id(self) -> None:\n        \"\"\"\n        Updating the color property requires a `stream_id` key.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"value\": \"#ffffff\"}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"stream_id key is missing from subscription_data[0]\")\n\n    def test_set_color_unsubscribed_stream_id(self) -> None:\n        \"\"\"\n        Updating the color property requires a subscribed stream.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        sub_info = gather_subscriptions_helper(test_user)\n\n        not_subbed = sub_info.never_subscribed\n\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [\n                        {\n                            \"property\": \"color\",\n                            \"stream_id\": not_subbed[0][\"stream_id\"],\n                            \"value\": \"#ffffff\",\n                        }\n                    ]\n                ).decode()\n            },\n        )\n        self.assert_json_error(\n            result, \"Not subscribed to stream id {}\".format(not_subbed[0][\"stream_id\"])\n        )\n\n    def test_set_color_missing_color(self) -> None:\n        \"\"\"\n        Updating the color property requires a color.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"color\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"value key is missing from subscription_data[0]\")\n\n    def test_set_stream_wildcard_mentions_notify(self) -> None:\n        \"\"\"\n        A POST request to /api/v1/users/me/subscriptions/properties with wildcard_mentions_notify\n        sets the property.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        subs = gather_subscriptions(test_user)[0]\n        sub = subs[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [\n                        {\n                            \"property\": \"wildcard_mentions_notify\",\n                            \"stream_id\": sub[\"stream_id\"],\n                            \"value\": True,\n                        }\n                    ]\n                ).decode()\n            },\n        )\n\n        self.assert_json_success(result)\n\n        updated_sub = get_subscription(sub[\"name\"], test_user)\n        self.assertIsNotNone(updated_sub)\n        self.assertEqual(updated_sub.wildcard_mentions_notify, True)\n\n    def test_set_pin_to_top(self) -> None:\n        \"\"\"\n        A POST request to /api/v1/users/me/subscriptions/properties with stream_id and\n        pin_to_top data pins the stream.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        old_subs, _ = gather_subscriptions(user)\n        sub = old_subs[0]\n        stream_id = sub[\"stream_id\"]\n        new_pin_to_top = not sub[\"pin_to_top\"]\n        result = self.api_post(\n            user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"pin_to_top\", \"stream_id\": stream_id, \"value\": new_pin_to_top}]\n                ).decode()\n            },\n        )\n        self.assert_json_success(result)\n\n        updated_sub = get_subscription(sub[\"name\"], user)\n\n        self.assertIsNotNone(updated_sub)\n        self.assertEqual(updated_sub.pin_to_top, new_pin_to_top)\n\n    def test_change_is_muted(self) -> None:\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, False)\n\n        property_name = \"is_muted\"\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.api_post(\n                test_user,\n                \"/api/v1/users/me/subscriptions/properties\",\n                {\n                    \"subscription_data\": orjson.dumps(\n                        [\n                            {\n                                \"property\": property_name,\n                                \"value\": True,\n                                \"stream_id\": subs[0][\"stream_id\"],\n                            }\n                        ]\n                    ).decode()\n                },\n            )\n        self.assert_json_success(result)\n        self.assertEqual(events[0][\"event\"][\"property\"], \"in_home_view\")\n        self.assertEqual(events[0][\"event\"][\"value\"], False)\n        self.assertEqual(events[1][\"event\"][\"property\"], \"is_muted\")\n        self.assertEqual(events[1][\"event\"][\"value\"], True)\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, True)\n\n        legacy_property_name = \"in_home_view\"\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.api_post(\n                test_user,\n                \"/api/v1/users/me/subscriptions/properties\",\n                {\n                    \"subscription_data\": orjson.dumps(\n                        [\n                            {\n                                \"property\": legacy_property_name,\n                                \"value\": True,\n                                \"stream_id\": subs[0][\"stream_id\"],\n                            }\n                        ]\n                    ).decode()\n                },\n            )\n        self.assert_json_success(result)\n        self.assertEqual(events[0][\"event\"][\"property\"], \"in_home_view\")\n        self.assertEqual(events[0][\"event\"][\"value\"], True)\n        self.assertEqual(events[1][\"event\"][\"property\"], \"is_muted\")\n        self.assertEqual(events[1][\"event\"][\"value\"], False)\n        self.assert_json_success(result)\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, False)\n\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            result = self.api_post(\n                test_user,\n                \"/api/v1/users/me/subscriptions/properties\",\n                {\n                    \"subscription_data\": orjson.dumps(\n                        [\n                            {\n                                \"property\": legacy_property_name,\n                                \"value\": False,\n                                \"stream_id\": subs[0][\"stream_id\"],\n                            }\n                        ]\n                    ).decode()\n                },\n            )\n        self.assert_json_success(result)\n        self.assertEqual(events[0][\"event\"][\"property\"], \"in_home_view\")\n        self.assertEqual(events[0][\"event\"][\"value\"], False)\n        self.assertEqual(events[1][\"event\"][\"property\"], \"is_muted\")\n        self.assertEqual(events[1][\"event\"][\"value\"], True)\n\n        sub = Subscription.objects.get(\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=subs[0][\"stream_id\"],\n            user_profile=test_user,\n        )\n        self.assertEqual(sub.is_muted, True)\n\n    def test_set_subscription_property_incorrect(self) -> None:\n        \"\"\"\n        Trying to set a property incorrectly returns a JSON error.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n\n        property_name = \"is_muted\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"in_home_view\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"desktop_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"audible_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"push_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"email_notifications\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"wildcard_mentions_notify\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n\n        self.assert_json_error(result, f\"{property_name} is not a boolean\")\n\n        property_name = \"color\"\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": property_name, \"value\": False, \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, f\"{property_name} is not a string\")\n\n    def test_json_subscription_property_invalid_stream(self) -> None:\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        stream_id = 1000\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"is_muted\", \"stream_id\": stream_id, \"value\": False}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_set_invalid_property(self) -> None:\n        \"\"\"\n        Trying to set an invalid property returns a JSON error.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n        subs = gather_subscriptions(test_user)[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [{\"property\": \"bad\", \"value\": \"bad\", \"stream_id\": subs[0][\"stream_id\"]}]\n                ).decode()\n            },\n        )\n        self.assert_json_error(result, \"Unknown subscription property: bad\")\n\n    def test_ignored_parameters_in_subscriptions_properties_endpoint(self) -> None:\n        \"\"\"\n        Sending an invalid parameter with a valid parameter returns\n        an `ignored_parameters_unsupported` array.\n        \"\"\"\n        test_user = self.example_user(\"hamlet\")\n        self.login_user(test_user)\n\n        subs = gather_subscriptions(test_user)[0]\n        sub = subs[0]\n        result = self.api_post(\n            test_user,\n            \"/api/v1/users/me/subscriptions/properties\",\n            {\n                \"subscription_data\": orjson.dumps(\n                    [\n                        {\n                            \"property\": \"wildcard_mentions_notify\",\n                            \"stream_id\": sub[\"stream_id\"],\n                            \"value\": True,\n                        }\n                    ]\n                ).decode(),\n                \"invalid_parameter\": orjson.dumps(\n                    [{\"property\": \"pin_to_top\", \"stream_id\": sub[\"stream_id\"], \"value\": False}]\n                ).decode(),\n            },\n        )\n\n        self.assert_json_success(result, ignored_parameters=[\"invalid_parameter\"])\n\n\nclass SubscriptionRestApiTest(ZulipTestCase):\n    def test_basic_add_delete(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        # add\n        request = {\n            \"add\": orjson.dumps([{\"name\": \"my_test_stream_1\"}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_success(result)\n        streams = self.get_streams(user)\n        self.assertTrue(\"my_test_stream_1\" in streams)\n\n        # now delete the same stream\n        request = {\n            \"delete\": orjson.dumps([\"my_test_stream_1\"]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_success(result)\n        streams = self.get_streams(user)\n        self.assertTrue(\"my_test_stream_1\" not in streams)\n\n    def test_add_with_color(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        # add with color proposition\n        request = {\n            \"add\": orjson.dumps([{\"name\": \"my_test_stream_2\", \"color\": \"#afafaf\"}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_success(result)\n\n        # incorrect color format\n        request = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"my_test_stream_3\", \"color\": \"#0g0g0g\"}]\n            ).decode(),\n        }\n        result = self.api_post(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, 'subscriptions[0][\"color\"] is not a valid hex color code')\n\n    def test_api_valid_property(self) -> None:\n        \"\"\"\n        Trying to set valid json returns success message.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n\n        self.login_user(user)\n        subs = gather_subscriptions(user)[0]\n        result = self.api_patch(\n            user,\n            \"/api/v1/users/me/subscriptions/{}\".format(subs[0][\"stream_id\"]),\n            {\"property\": \"color\", \"value\": \"#c2c2c2\"},\n        )\n        self.assert_json_success(result)\n\n    def test_api_invalid_property(self) -> None:\n        \"\"\"\n        Trying to set an invalid property returns a JSON error.\n        \"\"\"\n\n        user = self.example_user(\"hamlet\")\n\n        self.login_user(user)\n        subs = gather_subscriptions(user)[0]\n\n        result = self.api_patch(\n            user,\n            \"/api/v1/users/me/subscriptions/{}\".format(subs[0][\"stream_id\"]),\n            {\"property\": \"invalid\", \"value\": \"somevalue\"},\n        )\n        self.assert_json_error(result, \"Unknown subscription property: invalid\")\n\n    def test_api_invalid_stream_id(self) -> None:\n        \"\"\"\n        Trying to set an invalid stream id returns a JSON error.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.api_patch(\n            user,\n            \"/api/v1/users/me/subscriptions/121\",\n            {\"property\": \"is_muted\", \"value\": \"somevalue\"},\n        )\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_bad_add_parameters(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        def check_for_error(val: Any, expected_message: str) -> None:\n            request = {\n                \"add\": orjson.dumps(val).decode(),\n            }\n            result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n            self.assert_json_error(result, expected_message)\n\n        check_for_error([\"foo\"], \"add[0] is not a dict\")\n        check_for_error([{\"bogus\": \"foo\"}], \"name key is missing from add[0]\")\n        check_for_error([{\"name\": {}}], 'add[0][\"name\"] is not a string')\n\n    def test_bad_principals(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        request = {\n            \"add\": orjson.dumps([{\"name\": \"my_new_stream\"}]).decode(),\n            \"principals\": orjson.dumps([{}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"principals is not an allowed_type\")\n\n    def test_bad_delete_parameters(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        request = {\n            \"delete\": orjson.dumps([{\"name\": \"my_test_stream_1\"}]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"delete[0] is not a string\")\n\n    def test_add_or_delete_not_specified(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", {})\n        self.assert_json_error(result, 'Nothing to do. Specify at least one of \"add\" or \"delete\".')\n\n    def test_patch_enforces_valid_stream_name_check(self) -> None:\n        \"\"\"\n        Only way to force an error is with a empty string.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        invalid_stream_name = \"\"\n        request = {\n            \"delete\": orjson.dumps([invalid_stream_name]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n\n    def test_stream_name_too_long(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        long_stream_name = \"a\" * 61\n        request = {\n            \"delete\": orjson.dumps([long_stream_name]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"Stream name too long (limit: 60 characters).\")\n\n    def test_stream_name_contains_null(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        stream_name = \"abc\\000\"\n        request = {\n            \"delete\": orjson.dumps([stream_name]).decode(),\n        }\n        result = self.api_patch(user, \"/api/v1/users/me/subscriptions\", request)\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n    def test_compose_views_rollback(self) -> None:\n        \"\"\"\n        The compose_views function() is used under the hood by\n        update_subscriptions_backend.  It's a pretty simple method in terms of\n        control flow, but it uses a Django rollback, which may make it brittle\n        code when we upgrade Django.  We test the functions's rollback logic\n        here with a simple scenario to avoid false positives related to\n        subscription complications.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.full_name = \"Hamlet\"\n        user_profile.save()\n        request = HostRequestMock(user_profile=user_profile)\n\n        def thunk1() -> HttpResponse:\n            user_profile.full_name = \"Should not be committed\"\n            user_profile.save()\n            return json_success(request)\n\n        def thunk2() -> HttpResponse:\n            raise JsonableError(\"random failure\")\n\n        with self.assertRaises(JsonableError):\n            compose_views([thunk1, thunk2])\n\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(user_profile.full_name, \"Hamlet\")\n\n\nclass SubscriptionAPITest(ZulipTestCase):\n    def setUp(self) -> None:\n        \"\"\"\n        All tests will be logged in as hamlet. Also save various useful values\n        as attributes that tests can access.\n        \"\"\"\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.test_email = self.user_profile.email\n        self.test_user = self.user_profile\n        self.login_user(self.user_profile)\n        self.test_realm = self.user_profile.realm\n        self.streams = self.get_streams(self.user_profile)\n\n    def make_random_stream_names(self, existing_stream_names: List[str]) -> List[str]:\n        \"\"\"\n        Helper function to make up random stream names. It takes\n        existing_stream_names and randomly appends a digit to the end of each,\n        but avoids names that appear in the list names_to_avoid.\n        \"\"\"\n        random_streams = []\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.test_realm)]\n        for stream in existing_stream_names:\n            random_stream = stream + str(random.randint(0, 9))\n            if random_stream not in all_stream_names:\n                random_streams.append(random_stream)\n        return random_streams\n\n    def test_invalid_stream_name(self) -> None:\n        \"\"\"\n        Creating a stream with invalid 'Cc' and 'Cn' category of unicode characters in stream name\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        # For Cc category\n        post_data_cc = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new\\n\\rstream\", \"description\": \"this is description\"}]\n            ).decode(),\n            \"invite_only\": orjson.dumps(False).decode(),\n        }\n        result = self.api_post(\n            user, \"/api/v1/users/me/subscriptions\", post_data_cc, subdomain=\"zulip\"\n        )\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n        # For Cn category\n        post_data_cn = {\n            \"subscriptions\": orjson.dumps(\n                [{\"name\": \"new\\uFFFEstream\", \"description\": \"this is description\"}]\n            ).decode(),\n            \"invite_only\": orjson.dumps(False).decode(),\n        }\n        result = self.api_post(\n            user, \"/api/v1/users/me/subscriptions\", post_data_cn, subdomain=\"zulip\"\n        )\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n    def test_invalid_stream_rename(self) -> None:\n        \"\"\"\n        Renaming a stream with invalid characters.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        stream = self.subscribe(user_profile, \"stream_name1\")\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        # Check for empty name\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"\"})\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n        # Check for long name\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"a\" * 61})\n        self.assert_json_error(result, \"Stream name too long (limit: 60 characters).\")\n        # Check for Cc characters\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"test\\n\\rname\"})\n        self.assert_json_error(result, \"Invalid character in stream name, at position 5!\")\n        # Check for Cn characters\n        result = self.client_patch(f\"/json/streams/{stream.id}\", {\"new_name\": \"test\\uFFFEame\"})\n        self.assert_json_error(result, \"Invalid character in stream name, at position 5!\")\n\n    def test_successful_subscriptions_list(self) -> None:\n        \"\"\"\n        Calling /api/v1/users/me/subscriptions should successfully return your subscriptions.\n        \"\"\"\n        result = self.api_get(self.test_user, \"/api/v1/users/me/subscriptions\")\n        json = self.assert_json_success(result)\n        self.assertIn(\"subscriptions\", json)\n        for stream in json[\"subscriptions\"]:\n            self.assertIsInstance(stream[\"name\"], str)\n            self.assertIsInstance(stream[\"color\"], str)\n            self.assertIsInstance(stream[\"invite_only\"], bool)\n            # check that the stream name corresponds to an actual\n            # stream; will throw Stream.DoesNotExist if it doesn't\n            get_stream(stream[\"name\"], self.test_realm)\n        list_streams = [stream[\"name\"] for stream in json[\"subscriptions\"]]\n        # also check that this matches the list of your subscriptions\n        self.assertEqual(sorted(list_streams), sorted(self.streams))\n\n    def test_successful_subscriptions_list_subscribers(self) -> None:\n        \"\"\"\n        Calling /api/v1/users/me/subscriptions should successfully return your subscriptions.\n        \"\"\"\n        result = self.api_get(\n            self.test_user,\n            \"/api/v1/users/me/subscriptions\",\n            {\"include_subscribers\": \"true\"},\n        )\n        json = self.assert_json_success(result)\n        self.assertIn(\"subscriptions\", json)\n        for stream in json[\"subscriptions\"]:\n            self.assertIsInstance(stream[\"name\"], str)\n            self.assertIsInstance(stream[\"color\"], str)\n            self.assertIsInstance(stream[\"invite_only\"], bool)\n            # check that the stream name corresponds to an actual\n            # stream; will throw Stream.DoesNotExist if it doesn't\n            get_stream(stream[\"name\"], self.test_realm)\n        list_streams = [stream[\"name\"] for stream in json[\"subscriptions\"]]\n        # also check that this matches the list of your subscriptions\n        self.assertEqual(sorted(list_streams), sorted(self.streams))\n\n    def helper_check_subs_before_and_after_add(\n        self,\n        subscriptions: List[str],\n        other_params: Dict[str, Any],\n        subscribed: List[str],\n        already_subscribed: List[str],\n        email: str,\n        new_subs: List[str],\n        realm: Realm,\n        invite_only: bool = False,\n    ) -> None:\n        \"\"\"\n        Check result of adding subscriptions.\n\n        You can add subscriptions for yourself or possibly many\n        principals, which is why e-mails map to subscriptions in the\n        result.\n\n        The result json is of the form\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"already_subscribed\": {self.example_email(\"iago\"): [\"Venice\", \"Verona\"]},\n         \"subscribed\": {self.example_email(\"iago\"): [\"Venice8\"]}}\n        \"\"\"\n        result = self.common_subscribe_to_streams(\n            self.test_user, subscriptions, other_params, invite_only=invite_only\n        )\n        json = self.assert_json_success(result)\n        self.assertEqual(sorted(subscribed), sorted(json[\"subscribed\"][email]))\n        self.assertEqual(sorted(already_subscribed), sorted(json[\"already_subscribed\"][email]))\n        user = get_user(email, realm)\n        new_streams = self.get_streams(user)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_add(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        add_streams = [\"Verona2\", \"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)  # necessary for full test coverage\n        # Three events should be sent for each stream for stream creation, subscription add and message notifications.\n        with self.capture_send_event_calls(expected_num_events=6):\n            self.helper_check_subs_before_and_after_add(\n                self.streams + add_streams,\n                {},\n                add_streams,\n                self.streams,\n                self.test_email,\n                self.streams + add_streams,\n                self.test_realm,\n            )\n\n    def test_successful_subscriptions_add_with_announce(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should successfully add\n        streams, and should determine which are new subscriptions vs\n        which were already subscribed. We add 2 new streams to the\n        list of subscriptions and confirm the right number of events\n        are generated.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)\n        add_streams = [\"Verona2\", \"Denmark5\"]\n        self.assertNotEqual(len(add_streams), 0)\n        other_params = {\n            \"announce\": \"true\",\n        }\n        notifications_stream = get_stream(self.streams[0], self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n\n        with self.capture_send_event_calls(expected_num_events=7) as events:\n            self.helper_check_subs_before_and_after_add(\n                self.streams + add_streams,\n                other_params,\n                add_streams,\n                self.streams,\n                self.test_email,\n                self.streams + add_streams,\n                self.test_realm,\n            )\n\n        expected_stream_ids = {get_stream(stream, self.test_realm).id for stream in add_streams}\n\n        (peer_add_event,) = (event for event in events if event[\"event\"].get(\"op\") == \"peer_add\")\n\n        self.assertEqual(set(peer_add_event[\"event\"][\"stream_ids\"]), expected_stream_ids)\n        self.assertEqual(set(peer_add_event[\"event\"][\"user_ids\"]), {self.test_user.id})\n\n    def test_successful_subscriptions_notifies_pm(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n        self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                \"announce\": \"true\",\n                \"principals\": orjson.dumps([self.user_profile.id]).decode(),\n            },\n        )\n\n    def test_successful_subscriptions_notifies_stream(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n        invitee_full_name = \"Iago\"\n\n        current_stream = self.get_streams(invitee)[0]\n        invite_streams = self.make_random_stream_names([current_stream])[:1]\n\n        notifications_stream = get_stream(current_stream, self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n\n        self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data=dict(\n                announce=\"true\",\n                principals=orjson.dumps([self.user_profile.id]).decode(),\n            ),\n        )\n        target_stream = get_stream(invite_streams[0], self.test_realm)\n\n        msg = self.get_second_to_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.recipient.type_id, notifications_stream.id)\n        self.assertEqual(msg.sender_id, self.notification_bot(self.test_realm).id)\n        expected_msg = (\n            f\"@_**{invitee_full_name}|{invitee.id}** created a new stream #**{invite_streams[0]}**.\"\n        )\n        self.assertEqual(msg.content, expected_msg)\n\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.recipient.type_id, target_stream.id)\n        self.assertEqual(msg.sender_id, self.notification_bot(self.test_realm).id)\n        expected_msg = (\n            f\"**Public** stream created by @_**{invitee_full_name}|{invitee.id}**. **Description:**\\n\"\n            \"```` quote\\n*No description.*\\n````\"\n        )\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_successful_cross_realm_notification(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions in a new realm\n        should notify with a proper new stream link\n        \"\"\"\n        realm = do_create_realm(\"testrealm\", \"Test Realm\")\n\n        notifications_stream = Stream.objects.get(name=\"general\", realm=realm)\n        realm.notifications_stream = notifications_stream\n        realm.save()\n\n        invite_streams = [\"cross_stream\"]\n\n        user = self.example_user(\"AARON\")\n        user.realm = realm\n        user.save()\n\n        self.common_subscribe_to_streams(\n            user,\n            invite_streams,\n            extra_post_data=dict(\n                announce=\"true\",\n            ),\n            subdomain=\"testrealm\",\n        )\n\n        msg = self.get_second_to_last_message()\n        self.assertEqual(msg.recipient.type, Recipient.STREAM)\n        self.assertEqual(msg.recipient.type_id, notifications_stream.id)\n        self.assertEqual(msg.sender_id, self.notification_bot(realm).id)\n        stream_id = Stream.objects.latest(\"id\").id\n        expected_rendered_msg = f'<p><span class=\"user-mention silent\" data-user-id=\"{user.id}\">{user.full_name}</span> created a new stream <a class=\"stream\" data-stream-id=\"{stream_id}\" href=\"/#narrow/stream/{stream_id}-{invite_streams[0]}\">#{invite_streams[0]}</a>.</p>'\n        self.assertEqual(msg.rendered_content, expected_rendered_msg)\n\n    def test_successful_subscriptions_notifies_with_escaping(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions should notify when a new stream is created.\n        \"\"\"\n        invitee_full_name = \"Iago\"\n        invitee = self.example_user(\"iago\")\n\n        current_stream = self.get_streams(invitee)[0]\n        notifications_stream = get_stream(current_stream, self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n\n        invite_streams = [\"strange ) \\\\ test\"]\n        self.common_subscribe_to_streams(\n            invitee,\n            invite_streams,\n            extra_post_data={\n                \"announce\": \"true\",\n                \"principals\": orjson.dumps([self.user_profile.id]).decode(),\n            },\n        )\n\n        msg = self.get_second_to_last_message()\n        self.assertEqual(msg.sender_id, self.notification_bot(notifications_stream.realm).id)\n        expected_msg = (\n            f\"@_**{invitee_full_name}|{invitee.id}** created a new stream #**{invite_streams[0]}**.\"\n        )\n        self.assertEqual(msg.content, expected_msg)\n\n    def test_non_ascii_stream_subscription(self) -> None:\n        \"\"\"\n        Subscribing to a stream name with non-ASCII characters succeeds.\n        \"\"\"\n        self.helper_check_subs_before_and_after_add(\n            [*self.streams, \"h\u00fcmb\u00fc\u01f5\"],\n            {},\n            [\"h\u00fcmb\u00fc\u01f5\"],\n            self.streams,\n            self.test_email,\n            [*self.streams, \"h\u00fcmb\u00fc\u01f5\"],\n            self.test_realm,\n        )\n\n    def test_subscriptions_add_too_long(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is >60\n        characters should return a JSON error.\n        \"\"\"\n        # character limit is 60 characters\n        long_stream_name = \"a\" * 61\n        result = self.common_subscribe_to_streams(\n            self.test_user, [long_stream_name], allow_fail=True\n        )\n        self.assert_json_error(result, \"Stream name too long (limit: 60 characters).\")\n\n    def test_subscriptions_add_stream_with_null(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name contains\n        null characters should return a JSON error.\n        \"\"\"\n        stream_name = \"abc\\000\"\n        result = self.common_subscribe_to_streams(self.test_user, [stream_name], allow_fail=True)\n        self.assert_json_error(result, \"Invalid character in stream name, at position 4!\")\n\n    def _test_user_settings_for_creating_streams(\n        self,\n        stream_policy: str,\n        *,\n        invite_only: bool,\n        is_web_public: bool,\n    ) -> None:\n        user_profile = self.example_user(\"cordelia\")\n        realm = user_profile.realm\n\n        do_set_realm_property(realm, stream_policy, Realm.POLICY_ADMINS_ONLY, acting_user=None)\n        do_change_user_role(user_profile, UserProfile.ROLE_MODERATOR, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream1\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        self.common_subscribe_to_streams(user_profile, [\"new_stream1\"], invite_only=invite_only)\n\n        do_set_realm_property(realm, stream_policy, Realm.POLICY_MODERATORS_ONLY, acting_user=None)\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        # Make sure that we are checking the permission with a full member,\n        # as full member is the user just below moderator in the role hierarchy.\n        self.assertFalse(user_profile.is_provisional_member)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream2\"],\n            allow_fail=True,\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MODERATOR, acting_user=None)\n        self.common_subscribe_to_streams(user_profile, [\"new_stream2\"], invite_only=invite_only)\n\n        do_set_realm_property(realm, stream_policy, Realm.POLICY_MEMBERS_ONLY, acting_user=None)\n        do_change_user_role(user_profile, UserProfile.ROLE_GUEST, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream3\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Not allowed for guest users\")\n\n        do_change_user_role(user_profile, UserProfile.ROLE_MEMBER, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user,\n            [\"new_stream4\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n        )\n\n        do_set_realm_property(\n            realm, stream_policy, Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 100000, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            user_profile,\n            [\"new_stream5\"],\n            invite_only=invite_only,\n            is_web_public=is_web_public,\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n        self.common_subscribe_to_streams(user_profile, [\"new_stream3\"], invite_only=invite_only)\n\n    def test_user_settings_for_creating_private_streams(self) -> None:\n        self._test_user_settings_for_creating_streams(\n            \"create_private_stream_policy\",\n            invite_only=True,\n            is_web_public=False,\n        )\n\n    def test_user_settings_for_creating_public_streams(self) -> None:\n        self._test_user_settings_for_creating_streams(\n            \"create_public_stream_policy\",\n            invite_only=False,\n            is_web_public=False,\n        )\n\n    def test_user_settings_for_creating_web_public_streams(self) -> None:\n        self._test_user_settings_for_creating_streams(\n            \"create_web_public_stream_policy\", invite_only=False, is_web_public=True\n        )\n\n    def _test_can_create_streams(self, stream_policy: str, invite_only: bool) -> None:\n        if invite_only:\n\n            def validation_func(user_profile: UserProfile) -> bool:\n                user_profile.refresh_from_db()\n                return user_profile.can_create_private_streams()\n\n        else:\n\n            def validation_func(user_profile: UserProfile) -> bool:\n                user_profile.refresh_from_db()\n                return user_profile.can_create_public_streams()\n\n        self.check_has_permission_policies(stream_policy, validation_func)\n\n    def test_can_create_private_streams(self) -> None:\n        self._test_can_create_streams(\"create_private_stream_policy\", invite_only=True)\n\n    def test_can_create_public_streams(self) -> None:\n        self._test_can_create_streams(\"create_public_stream_policy\", invite_only=False)\n\n    def test_can_create_web_public_streams(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_create_web_public_streams()\n\n        self.check_has_permission_policies(\"create_web_public_stream_policy\", validation_func)\n\n    def test_user_settings_for_subscribing_other_users(self) -> None:\n        \"\"\"\n        You can't subscribe other people to streams if you are a guest or your account is not old\n        enough.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        invitee_user_id = user_profile.id\n        realm = user_profile.realm\n\n        do_set_realm_property(\n            realm, \"create_public_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n        do_change_user_role(self.test_user, UserProfile.ROLE_MODERATOR, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream1\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(self.test_user, UserProfile.ROLE_REALM_ADMINISTRATOR, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user, [\"stream1\"], {\"principals\": orjson.dumps([invitee_user_id]).decode()}\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        do_change_user_role(self.test_user, UserProfile.ROLE_MEMBER, acting_user=None)\n        # Make sure that we are checking the permission with a full member,\n        # as full member is the user just below moderator in the role hierarchy.\n        self.assertFalse(self.test_user.is_provisional_member)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_change_user_role(self.test_user, UserProfile.ROLE_MODERATOR, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user, [\"stream2\"], {\"principals\": orjson.dumps([invitee_user_id]).decode()}\n        )\n        self.unsubscribe(user_profile, \"stream2\")\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        do_change_user_role(self.test_user, UserProfile.ROLE_GUEST, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Not allowed for guest users\")\n\n        do_change_user_role(self.test_user, UserProfile.ROLE_MEMBER, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([self.test_user.id, invitee_user_id]).decode()},\n        )\n        self.unsubscribe(user_profile, \"stream2\")\n\n        do_set_realm_property(\n            realm,\n            \"invite_to_stream_policy\",\n            Realm.POLICY_FULL_MEMBERS_ONLY,\n            acting_user=None,\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 100000, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            [\"stream2\"],\n            {\"principals\": orjson.dumps([invitee_user_id]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n        self.common_subscribe_to_streams(\n            self.test_user, [\"stream2\"], {\"principals\": orjson.dumps([invitee_user_id]).decode()}\n        )\n\n    def test_can_subscribe_other_users(self) -> None:\n        \"\"\"\n        You can't subscribe other people to streams if you are a guest or your account is not old\n        enough.\n        \"\"\"\n\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_subscribe_other_users()\n\n        self.check_has_permission_policies(\"invite_to_stream_policy\", validation_func)\n\n    def test_subscriptions_add_invalid_stream(self) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid name is the empty string\n        invalid_stream_name = \"\"\n        result = self.common_subscribe_to_streams(\n            self.test_user, [invalid_stream_name], allow_fail=True\n        )\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n\n    def assert_adding_subscriptions_for_principal(\n        self,\n        invitee_data: Union[str, int],\n        invitee_realm: Realm,\n        streams: List[str],\n        policy_name: str,\n        invite_only: bool = False,\n    ) -> None:\n        \"\"\"\n        Calling POST /json/users/me/subscriptions on behalf of another principal (for\n        whom you have permission to add subscriptions) should successfully add\n        those subscriptions and send a message to the subscribee notifying\n        them.\n        \"\"\"\n        if isinstance(invitee_data, str):\n            other_profile = get_user(invitee_data, invitee_realm)\n        else:\n            other_profile = get_user_profile_by_id_in_realm(invitee_data, invitee_realm)\n        current_streams = self.get_streams(other_profile)\n        self.assertIsInstance(other_profile, UserProfile)\n        self.assertNotEqual(len(current_streams), 0)  # necessary for full test coverage\n        self.assertNotEqual(len(streams), 0)  # necessary for full test coverage\n        streams_to_sub = streams[:1]  # just add one, to make the message easier to check\n        streams_to_sub.extend(current_streams)\n        self.helper_check_subs_before_and_after_add(\n            streams_to_sub,\n            {\"principals\": orjson.dumps([invitee_data]).decode()},\n            streams[:1],\n            current_streams,\n            other_profile.email,\n            streams_to_sub,\n            invitee_realm,\n            invite_only=invite_only,\n        )\n\n        # verify that a welcome message was sent to the stream\n        msg = self.get_last_message()\n        self.assertEqual(msg.recipient.type, msg.recipient.STREAM)\n        self.assertEqual(msg.topic_name(), \"stream events\")\n        self.assertEqual(msg.sender.email, settings.NOTIFICATION_BOT)\n        self.assertIn(\n            f\"**{policy_name}** stream created by @_**{self.test_user.full_name}|{self.test_user.id}**. **Description:**\\n\"\n            \"```` quote\",\n            msg.content,\n        )\n\n    def test_multi_user_subscription(self) -> None:\n        user1 = self.example_user(\"cordelia\")\n        user2 = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n        streams_to_sub = [\"multi_user_stream\"]\n        flush_per_request_caches()\n        with self.capture_send_event_calls(expected_num_events=5) as events:\n            with self.assert_database_query_count(36):\n                self.common_subscribe_to_streams(\n                    self.test_user,\n                    streams_to_sub,\n                    dict(principals=orjson.dumps([user1.id, user2.id]).decode()),\n                )\n\n        for ev in [x for x in events if x[\"event\"][\"type\"] not in (\"message\", \"stream\")]:\n            if ev[\"event\"][\"op\"] == \"add\":\n                self.assertEqual(\n                    set(ev[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n                    {user1.id, user2.id},\n                )\n            else:\n                # Check \"peer_add\" events for streams users were\n                # never subscribed to, in order for the neversubscribed\n                # structure to stay up-to-date.\n                self.assertEqual(ev[\"event\"][\"op\"], \"peer_add\")\n\n        stream = get_stream(\"multi_user_stream\", realm)\n        self.assertEqual(num_subscribers_for_stream_id(stream.id), 2)\n\n        # Now add ourselves\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            with self.assert_database_query_count(12):\n                self.common_subscribe_to_streams(\n                    self.test_user,\n                    streams_to_sub,\n                    dict(principals=orjson.dumps([self.test_user.id]).decode()),\n                )\n\n        add_event, add_peer_event = events\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [get_user(self.test_email, self.test_realm).id])\n        self.assertEqual(\n            set(add_event[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n            {user1.id, user2.id, self.test_user.id},\n        )\n\n        self.assertNotIn(self.example_user(\"polonius\").id, add_peer_event[\"users\"])\n        self.assert_length(add_peer_event[\"users\"], 11)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [self.user_profile.id])\n\n        stream = get_stream(\"multi_user_stream\", realm)\n        self.assertEqual(num_subscribers_for_stream_id(stream.id), 3)\n\n        # Finally, add othello.\n        events = []\n        user_profile = self.example_user(\"othello\")\n        email3 = user_profile.email\n        user3 = user_profile\n        realm3 = user_profile.realm\n        stream = get_stream(\"multi_user_stream\", realm)\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            bulk_add_subscriptions(realm, [stream], [user_profile], acting_user=None)\n\n        add_event, add_peer_event = events\n\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [get_user(email3, realm3).id])\n        self.assertEqual(\n            set(add_event[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n            {user1.id, user2.id, user3.id, self.test_user.id},\n        )\n\n        # We don't send a peer_add event to othello\n        self.assertNotIn(user_profile.id, add_peer_event[\"users\"])\n        self.assertNotIn(self.example_user(\"polonius\").id, add_peer_event[\"users\"])\n        self.assert_length(add_peer_event[\"users\"], 11)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [user_profile.id])\n\n    def test_private_stream_subscription(self) -> None:\n        realm = get_realm(\"zulip\")\n\n        # Create a private stream with Hamlet subscribed\n        stream_name = \"private\"\n        stream = ensure_stream(realm, stream_name, invite_only=True, acting_user=None)\n\n        existing_user_profile = self.example_user(\"hamlet\")\n        bulk_add_subscriptions(realm, [stream], [existing_user_profile], acting_user=None)\n\n        # Now subscribe Cordelia to the stream, capturing events\n        user_profile = self.example_user(\"cordelia\")\n\n        with self.capture_send_event_calls(expected_num_events=3) as events:\n            bulk_add_subscriptions(realm, [stream], [user_profile], acting_user=None)\n\n        create_event, add_event, add_peer_event = events\n\n        self.assertEqual(create_event[\"event\"][\"type\"], \"stream\")\n        self.assertEqual(create_event[\"event\"][\"op\"], \"create\")\n        self.assertEqual(create_event[\"users\"], [user_profile.id])\n        self.assertEqual(create_event[\"event\"][\"streams\"][0][\"name\"], stream_name)\n\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [user_profile.id])\n        self.assertEqual(\n            set(add_event[\"event\"][\"subscriptions\"][0][\"subscribers\"]),\n            {user_profile.id, existing_user_profile.id},\n        )\n\n        # We don't send a peer_add event to othello, but we do send peer_add event to\n        # all realm admins.\n        self.assertNotIn(user_profile.id, add_peer_event[\"users\"])\n        self.assert_length(add_peer_event[\"users\"], 3)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [user_profile.id])\n\n        # Do not send stream creation event to realm admin users\n        # even if realm admin is subscribed to stream cause realm admin already get\n        # private stream creation event on stream creation.\n        new_stream = ensure_stream(realm, \"private stream\", invite_only=True, acting_user=None)\n        with self.capture_send_event_calls(expected_num_events=2) as events:\n            bulk_add_subscriptions(\n                realm, [new_stream], [self.example_user(\"iago\")], acting_user=None\n            )\n\n        # Note that since iago is an admin, he won't get a stream/create\n        # event here.\n        self.assert_length(events, 2)\n        add_event, add_peer_event = events\n\n        self.assertEqual(add_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_event[\"event\"][\"op\"], \"add\")\n        self.assertEqual(add_event[\"users\"], [self.example_user(\"iago\").id])\n\n        self.assert_length(add_peer_event[\"users\"], 1)\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        self.assertEqual(add_peer_event[\"event\"][\"user_ids\"], [self.example_user(\"iago\").id])\n\n    def test_subscribe_to_stream_post_policy_admins_stream(self) -> None:\n        \"\"\"\n        Members can subscribe to streams where only admins can post\n        \"\"\"\n        member = self.example_user(\"AARON\")\n        stream = self.make_stream(\"stream1\")\n        do_change_stream_post_policy(stream, Stream.STREAM_POST_POLICY_ADMINS, acting_user=member)\n        result = self.common_subscribe_to_streams(member, [\"stream1\"])\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {member.email: [\"stream1\"]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n    def test_subscribe_to_stream_post_policy_restrict_new_members_stream(self) -> None:\n        \"\"\"\n        New members can subscribe to streams where they can not post\n        \"\"\"\n        new_member_email = self.nonreg_email(\"test\")\n        self.register(new_member_email, \"test\")\n        new_member = self.nonreg_user(\"test\")\n\n        do_set_realm_property(new_member.realm, \"waiting_period_threshold\", 10, acting_user=None)\n        self.assertTrue(new_member.is_provisional_member)\n\n        stream = self.make_stream(\"stream1\")\n        do_change_stream_post_policy(\n            stream, Stream.STREAM_POST_POLICY_RESTRICT_NEW_MEMBERS, acting_user=new_member\n        )\n        result = self.common_subscribe_to_streams(new_member, [\"stream1\"])\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {new_member.email: [\"stream1\"]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n    def test_subscribe_to_stream_post_policy_moderators_stream(self) -> None:\n        \"\"\"\n        Members can subscribe to streams where only admins and moderators can post\n        \"\"\"\n        member = self.example_user(\"AARON\")\n        stream = self.make_stream(\"stream1\")\n        # Make sure that we are testing this with full member which is just below the moderator\n        # in the role hierarchy.\n        self.assertFalse(member.is_provisional_member)\n        do_change_stream_post_policy(\n            stream, Stream.STREAM_POST_POLICY_MODERATORS, acting_user=member\n        )\n        result = self.common_subscribe_to_streams(member, [\"stream1\"])\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {member.email: [\"stream1\"]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n    def test_guest_user_subscribe(self) -> None:\n        \"\"\"Guest users cannot subscribe themselves to anything\"\"\"\n        guest_user = self.example_user(\"polonius\")\n        result = self.common_subscribe_to_streams(guest_user, [\"Denmark\"], allow_fail=True)\n        self.assert_json_error(result, \"Not allowed for guest users\")\n\n        # Verify the internal checks also block guest users.\n        stream = get_stream(\"Denmark\", guest_user.realm)\n        self.assertEqual(filter_stream_authorization(guest_user, [stream]), ([], [stream]))\n\n        stream = self.make_stream(\"private_stream\", invite_only=True)\n        result = self.common_subscribe_to_streams(guest_user, [\"private_stream\"], allow_fail=True)\n        self.assert_json_error(result, \"Not allowed for guest users\")\n        self.assertEqual(filter_stream_authorization(guest_user, [stream]), ([], [stream]))\n\n        web_public_stream = self.make_stream(\"web_public_stream\", is_web_public=True)\n        public_stream = self.make_stream(\"public_stream\", invite_only=False)\n        private_stream = self.make_stream(\"private_stream2\", invite_only=True)\n        # This test should be added as soon as the subscription endpoint allows\n        # guest users to subscribe to web-public streams. Although they are already\n        # authorized, the decorator in \"add_subscriptions_backend\" still needs to be\n        # deleted.\n        #\n        # result = self.common_subscribe_to_streams(guest_user, ['web_public_stream'],\n        #                                           is_web_public=True, allow_fail=True)\n        # self.assert_json_success(result)\n        streams_to_sub = [web_public_stream, public_stream, private_stream]\n        self.assertEqual(\n            filter_stream_authorization(guest_user, streams_to_sub),\n            ([web_public_stream], [public_stream, private_stream]),\n        )\n\n    def test_users_getting_add_peer_event(self) -> None:\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        streams_to_sub = [\"multi_user_stream\"]\n        othello = self.example_user(\"othello\")\n        cordelia = self.example_user(\"cordelia\")\n        iago = self.example_user(\"iago\")\n        orig_user_ids_to_subscribe = [self.test_user.id, othello.id]\n        self.common_subscribe_to_streams(\n            self.test_user,\n            streams_to_sub,\n            dict(principals=orjson.dumps(orig_user_ids_to_subscribe).decode()),\n        )\n\n        new_user_ids_to_subscribe = [iago.id, cordelia.id]\n        with self.capture_send_event_calls(expected_num_events=5) as events:\n            self.common_subscribe_to_streams(\n                self.test_user,\n                streams_to_sub,\n                dict(principals=orjson.dumps(new_user_ids_to_subscribe).decode()),\n            )\n\n        add_peer_events = [event for event in events if event[\"event\"].get(\"op\") == \"peer_add\"]\n        (add_peer_event,) = add_peer_events\n\n        self.assertEqual(add_peer_event[\"event\"][\"type\"], \"subscription\")\n        self.assertEqual(add_peer_event[\"event\"][\"op\"], \"peer_add\")\n        event_sent_to_ids = add_peer_event[\"users\"]\n        for user_id in new_user_ids_to_subscribe:\n            # Make sure new users subscribed to stream is not in\n            # peer_add event recipient list\n            self.assertNotIn(user_id, event_sent_to_ids)\n        for old_user in orig_user_ids_to_subscribe:\n            # Check non-new users are in peer_add event recipient list.\n            self.assertIn(old_user, event_sent_to_ids)\n\n    def test_users_getting_remove_peer_event(self) -> None:\n        \"\"\"\n        Check users getting add_peer_event is correct\n        \"\"\"\n        user1 = self.example_user(\"othello\")\n        user2 = self.example_user(\"cordelia\")\n        user3 = self.example_user(\"hamlet\")\n        user4 = self.example_user(\"iago\")\n        user5 = self.example_user(\"AARON\")\n        guest = self.example_user(\"polonius\")\n\n        realm = user1.realm\n\n        stream1 = self.make_stream(\"stream1\")\n        stream2 = self.make_stream(\"stream2\")\n        stream3 = self.make_stream(\"stream3\")\n        private = self.make_stream(\"private_stream\", invite_only=True)\n\n        self.subscribe(user1, \"stream1\")\n        self.subscribe(user2, \"stream1\")\n        self.subscribe(user3, \"stream1\")\n\n        self.subscribe(user2, \"stream2\")\n        self.subscribe(user2, \"stream3\")\n\n        self.subscribe(user1, \"private_stream\")\n        self.subscribe(user2, \"private_stream\")\n        self.subscribe(user3, \"private_stream\")\n\n        # Sends 3 peer-remove events and 2 unsubscribe events.\n        with self.capture_send_event_calls(expected_num_events=5) as events:\n            with self.assert_database_query_count(16):\n                with cache_tries_captured() as cache_count:\n                    bulk_remove_subscriptions(\n                        realm,\n                        [user1, user2],\n                        [stream1, stream2, stream3, private],\n                        acting_user=None,\n                    )\n\n        self.assert_length(cache_count, 3)\n\n        peer_events = [e for e in events if e[\"event\"].get(\"op\") == \"peer_remove\"]\n\n        # We only care about a subset of users when we inspect\n        # peer_remove events.\n        our_user_ids = {\n            user1.id,\n            user2.id,\n            user3.id,\n            user4.id,\n            user5.id,\n            guest.id,\n        }\n\n        notifications = []\n        for event in peer_events:\n            stream_ids = event[\"event\"][\"stream_ids\"]\n            stream_names = sorted(Stream.objects.get(id=stream_id).name for stream_id in stream_ids)\n            removed_user_ids = set(event[\"event\"][\"user_ids\"])\n            notified_user_ids = set(event[\"users\"]) & our_user_ids\n            notifications.append((\",\".join(stream_names), removed_user_ids, notified_user_ids))\n\n        notifications.sort(key=lambda tup: tup[0])\n\n        self.assertEqual(\n            notifications,\n            [\n                (\"private_stream\", {user1.id, user2.id}, {user3.id, user4.id}),\n                (\"stream1\", {user1.id, user2.id}, {user3.id, user4.id, user5.id}),\n                (\"stream2,stream3\", {user2.id}, {user1.id, user3.id, user4.id, user5.id}),\n            ],\n        )\n\n    def test_bulk_subscribe_MIT(self) -> None:\n        mit_user = self.mit_user(\"starnine\")\n        num_streams = 15\n\n        realm = get_realm(\"zephyr\")\n        stream_names = [f\"stream_{i}\" for i in range(num_streams)]\n        streams = [self.make_stream(stream_name, realm=realm) for stream_name in stream_names]\n\n        for stream in streams:\n            stream.is_in_zephyr_realm = True\n            stream.save()\n\n        # Verify that peer_event events are never sent in Zephyr\n        # realm. This does generate stream creation events from\n        # send_stream_creation_events_for_private_streams.\n        with self.capture_send_event_calls(expected_num_events=num_streams + 1) as events:\n            with self.assert_database_query_count(num_streams + 12):\n                self.common_subscribe_to_streams(\n                    mit_user,\n                    stream_names,\n                    dict(principals=orjson.dumps([mit_user.id]).decode()),\n                    subdomain=\"zephyr\",\n                )\n            # num_streams stream creation events:\n            self.assertEqual(\n                {(event[\"event\"][\"type\"], event[\"event\"][\"op\"]) for event in events[0:num_streams]},\n                {(\"stream\", \"create\")},\n            )\n            # Followed by one subscription event:\n            self.assertEqual(events[num_streams][\"event\"][\"type\"], \"subscription\")\n\n        with self.capture_send_event_calls(expected_num_events=1):\n            bulk_remove_subscriptions(\n                realm,\n                users=[mit_user],\n                streams=streams,\n                acting_user=None,\n            )\n\n    def test_subscribe_others_to_public_stream_in_zephyr_realm(self) -> None:\n        \"\"\"\n        Users cannot be subscribed to public streams by other users in zephyr realm.\n        \"\"\"\n        starnine = self.mit_user(\"starnine\")\n        espuser = self.mit_user(\"espuser\")\n\n        realm = get_realm(\"zephyr\")\n        stream = self.make_stream(\"stream_1\", realm=realm)\n        stream.is_in_zephyr_realm = True\n        stream.save()\n\n        result = self.common_subscribe_to_streams(\n            starnine,\n            [\"stream_1\"],\n            dict(principals=orjson.dumps([starnine.id, espuser.id]).decode()),\n            subdomain=\"zephyr\",\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            \"You can only invite other Zephyr mirroring users to private streams.\",\n            status_code=400,\n        )\n\n    def test_bulk_subscribe_many(self) -> None:\n        # Create a whole bunch of streams\n        streams = [f\"stream_{i}\" for i in range(30)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        desdemona = self.example_user(\"desdemona\")\n\n        test_users = [\n            desdemona,\n            self.example_user(\"cordelia\"),\n            self.example_user(\"hamlet\"),\n            self.example_user(\"othello\"),\n            self.example_user(\"iago\"),\n            self.example_user(\"prospero\"),\n        ]\n\n        # Subscribe out test users to some streams, including\n        # some that we may soon subscribe them to.\n        for stream_name in [\"Verona\", \"Denmark\", *streams[:10]]:\n            for user in test_users:\n                self.subscribe(user, stream_name)\n\n        # Now unsubscribe users from the first few streams,\n        # so they have to reactivate.\n        for stream_name in streams[:5]:\n            for user in test_users:\n                self.unsubscribe(user, stream_name)\n\n        test_user_ids = [user.id for user in test_users]\n\n        with self.assert_database_query_count(20):\n            with cache_tries_captured() as cache_tries:\n                with mock.patch(\"zerver.views.streams.send_messages_for_new_subscribers\"):\n                    self.common_subscribe_to_streams(\n                        desdemona,\n                        streams,\n                        dict(principals=orjson.dumps(test_user_ids).decode()),\n                    )\n\n        # The only known O(N) behavior here is that we call\n        # principal_to_user_profile for each of our users.\n        self.assert_length(cache_tries, 4)\n\n    def test_subscriptions_add_for_principal(self) -> None:\n        \"\"\"\n        You can subscribe other people to streams.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(\n            invitee.id, invitee.realm, invite_streams, policy_name=\"Public\"\n        )\n\n    def test_subscriptions_add_for_principal_legacy_emails(self) -> None:\n        invitee = self.example_user(\"iago\")\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(\n            invitee.email, invitee.realm, invite_streams, policy_name=\"Public\"\n        )\n\n    def test_subscriptions_add_for_principal_deactivated(self) -> None:\n        \"\"\"\n        You can't subscribe deactivated people to streams.\n        \"\"\"\n        target_profile = self.example_user(\"cordelia\")\n        post_data = dict(\n            principals=orjson.dumps([target_profile.id]).decode(),\n        )\n        self.common_subscribe_to_streams(self.test_user, \"Verona\", post_data)\n\n        do_deactivate_user(target_profile, acting_user=None)\n        result = self.common_subscribe_to_streams(\n            self.test_user, \"Denmark\", post_data, allow_fail=True\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{target_profile.id}'\",\n            status_code=403,\n        )\n\n    def test_subscriptions_add_for_principal_invite_only(self) -> None:\n        \"\"\"\n        You can subscribe other people to invite only streams.\n        \"\"\"\n        invitee = self.example_user(\"iago\")\n        current_streams = self.get_streams(invitee)\n        invite_streams = self.make_random_stream_names(current_streams)\n        self.assert_adding_subscriptions_for_principal(\n            invitee.id,\n            invitee.realm,\n            invite_streams,\n            invite_only=True,\n            policy_name=\"Private, protected history\",\n        )\n\n    def test_non_ascii_subscription_for_principal(self) -> None:\n        \"\"\"\n        You can subscribe other people to streams even if they containing\n        non-ASCII characters.\n        \"\"\"\n        iago = self.example_user(\"iago\")\n        self.assert_adding_subscriptions_for_principal(\n            iago.id, get_realm(\"zulip\"), [\"h\u00fcmb\u00fc\u01f5\"], policy_name=\"Public\"\n        )\n\n    def test_subscription_add_invalid_principal_legacy_emails(self) -> None:\n        \"\"\"\n        Calling subscribe on behalf of a principal that does not exist\n        should return a JSON error.\n        \"\"\"\n        invalid_principal = \"rosencrantz-and-guildenstern@zulip.com\"\n        invalid_principal_realm = get_realm(\"zulip\")\n        # verify that invalid_principal actually doesn't exist\n        with self.assertRaises(UserProfile.DoesNotExist):\n            get_user(invalid_principal, invalid_principal_realm)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            self.streams,\n            {\"principals\": orjson.dumps([invalid_principal]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{invalid_principal}'\",\n            status_code=403,\n        )\n\n    def test_subscription_add_invalid_principal(self) -> None:\n        invalid_principal = 999\n        invalid_principal_realm = get_realm(\"zulip\")\n        with self.assertRaises(UserProfile.DoesNotExist):\n            get_user_profile_by_id_in_realm(invalid_principal, invalid_principal_realm)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            self.streams,\n            {\"principals\": orjson.dumps([invalid_principal]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{invalid_principal}'\",\n            status_code=403,\n        )\n\n    def test_subscription_add_principal_other_realm(self) -> None:\n        \"\"\"\n        Calling subscribe on behalf of a principal in another realm\n        should return a JSON error.\n        \"\"\"\n        profile = self.mit_user(\"starnine\")\n        principal = profile.id\n        # verify that principal exists (thus, the reason for the error is the cross-realming)\n        self.assertIsInstance(profile, UserProfile)\n        result = self.common_subscribe_to_streams(\n            self.test_user,\n            self.streams,\n            {\"principals\": orjson.dumps([principal]).decode()},\n            allow_fail=True,\n        )\n        self.assert_json_error(\n            result,\n            f\"User not authorized to execute queries on behalf of '{principal}'\",\n            status_code=403,\n        )\n\n    def helper_check_subs_before_and_after_remove(\n        self,\n        subscriptions: List[str],\n        json_dict: Dict[str, Any],\n        email: str,\n        new_subs: List[str],\n        realm: Realm,\n    ) -> None:\n        \"\"\"\n        Check result of removing subscriptions.\n\n        Unlike adding subscriptions, you can only remove subscriptions\n        for yourself, so the result format is different.\n\n        {\"msg\": \"\",\n         \"removed\": [\"Denmark\", \"Scotland\", \"Verona\"],\n         \"not_removed\": [\"Rome\"], \"result\": \"success\"}\n        \"\"\"\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\", {\"subscriptions\": orjson.dumps(subscriptions).decode()}\n        )\n        json = self.assert_json_success(result)\n        for key, val in json_dict.items():\n            # we don't care about the order of the items\n            self.assertEqual(sorted(val), sorted(json[key]))\n        user = get_user(email, realm)\n        new_streams = self.get_streams(user)\n        self.assertEqual(sorted(new_streams), sorted(new_subs))\n\n    def test_successful_subscriptions_remove(self) -> None:\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions should successfully remove streams,\n        and should determine which were removed vs which weren't subscribed to.\n        We cannot randomly generate stream names because the remove code\n        verifies whether streams exist.\n        \"\"\"\n        self.assertGreaterEqual(len(self.streams), 2)\n        streams_to_remove = self.streams[1:]\n        not_subbed = []\n        for stream in Stream.objects.filter(realm=get_realm(\"zulip\")):\n            if stream.name not in self.streams:\n                not_subbed.append(stream.name)\n        random.shuffle(not_subbed)\n        self.assertNotEqual(len(not_subbed), 0)  # necessary for full test coverage\n        try_to_remove = not_subbed[:3]  # attempt to remove up to 3 streams not already subbed to\n        streams_to_remove.extend(try_to_remove)\n        self.helper_check_subs_before_and_after_remove(\n            streams_to_remove,\n            {\"removed\": self.streams[1:], \"not_removed\": try_to_remove},\n            self.test_email,\n            [self.streams[0]],\n            self.test_realm,\n        )\n\n    def test_subscriptions_remove_fake_stream(self) -> None:\n        \"\"\"\n        Calling DELETE /json/users/me/subscriptions on a stream that doesn't exist\n        should return a JSON error.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        # pick only one fake stream, to make checking the error message easy\n        streams_to_remove = random_streams[:1]\n        result = self.client_delete(\n            \"/json/users/me/subscriptions\",\n            {\"subscriptions\": orjson.dumps(streams_to_remove).decode()},\n        )\n        self.assert_json_error(result, f\"Stream(s) ({random_streams[0]}) do not exist\")\n\n    def helper_subscriptions_exists(\n        self, stream: str, expect_success: bool, subscribed: bool\n    ) -> None:\n        \"\"\"\n        Call /json/subscriptions/exists on a stream and expect a certain result.\n        \"\"\"\n        result = self.client_post(\"/json/subscriptions/exists\", {\"stream\": stream})\n        if expect_success:\n            json = self.assert_json_success(result)\n        else:\n            self.assertEqual(result.status_code, 404)\n            json = result.json()\n        if subscribed:\n            self.assertIn(\"subscribed\", json)\n            self.assertEqual(json[\"subscribed\"], subscribed)\n\n    def test_successful_subscriptions_exists_subbed(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are subbed\n        should return that it exists and that you are subbed.\n        \"\"\"\n        self.assertNotEqual(len(self.streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(self.streams[0], True, True)\n\n    def test_successful_subscriptions_exists_not_subbed(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream to which you are not\n        subbed should return that it exists and that you are not subbed.\n        \"\"\"\n        all_stream_names = [stream.name for stream in Stream.objects.filter(realm=self.test_realm)]\n        streams_not_subbed = list(set(all_stream_names) - set(self.streams))\n        self.assertNotEqual(len(streams_not_subbed), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(streams_not_subbed[0], True, False)\n\n    def test_subscriptions_does_not_exist(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream that doesn't exist should\n        return that it doesn't exist.\n        \"\"\"\n        random_streams = self.make_random_stream_names(self.streams)\n        self.assertNotEqual(len(random_streams), 0)  # necessary for full test coverage\n        self.helper_subscriptions_exists(random_streams[0], False, False)\n\n    def test_subscriptions_exist_invalid_name(self) -> None:\n        \"\"\"\n        Calling /json/subscriptions/exist on a stream whose name is invalid (as\n        defined by valid_stream_name in zerver/views.py) should return a JSON\n        error.\n        \"\"\"\n        # currently, the only invalid stream name is the empty string\n        invalid_stream_name = \"\"\n        result = self.client_post(\"/json/subscriptions/exists\", {\"stream\": invalid_stream_name})\n        self.assert_json_error(result, \"Stream name can't be empty!\")\n\n    def test_existing_subscriptions_autosubscription(self) -> None:\n        \"\"\"\n        Call /json/subscriptions/exist on an existing stream and autosubscribe to it.\n        \"\"\"\n        stream_name = \"new_public_stream\"\n        cordelia = self.example_user(\"cordelia\")\n        self.common_subscribe_to_streams(cordelia, [stream_name], invite_only=False)\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"false\"}\n        )\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribed\", response_dict)\n        self.assertFalse(response_dict[\"subscribed\"])\n\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"true\"}\n        )\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribed\", response_dict)\n        self.assertTrue(response_dict)\n\n    def test_existing_subscriptions_autosubscription_private_stream(self) -> None:\n        \"\"\"Call /json/subscriptions/exist on an existing private stream with\n        autosubscribe should fail.\n        \"\"\"\n        stream_name = \"Saxony\"\n        cordelia = self.example_user(\"cordelia\")\n        self.common_subscribe_to_streams(cordelia, [stream_name], invite_only=True)\n        stream = get_stream(stream_name, self.test_realm)\n\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"true\"}\n        )\n        # We can't see invite-only streams here\n        self.assert_json_error(result, \"Invalid stream name 'Saxony'\", status_code=404)\n        # Importantly, we are not now subscribed\n        self.assertEqual(num_subscribers_for_stream_id(stream.id), 1)\n\n        # A user who is subscribed still sees the stream exists\n        self.login(\"cordelia\")\n        result = self.client_post(\n            \"/json/subscriptions/exists\", {\"stream\": stream_name, \"autosubscribe\": \"false\"}\n        )\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribed\", response_dict)\n        self.assertTrue(response_dict)\n\n    def get_subscription(self, user_profile: UserProfile, stream_name: str) -> Subscription:\n        stream = get_stream(stream_name, self.test_realm)\n        return Subscription.objects.get(\n            user_profile=user_profile,\n            recipient__type=Recipient.STREAM,\n            recipient__type_id=stream.id,\n        )\n\n    def test_subscriptions_add_notification_default_none(self) -> None:\n        \"\"\"\n        When creating a subscription, the desktop, push, and audible notification\n        settings for that stream are none. A value of None means to use the values\n        inherited from the global notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"iago\")\n        invitee_user_id = user_profile.id\n        invitee_realm = user_profile.realm\n        user_profile.enable_stream_desktop_notifications = True\n        user_profile.enable_stream_push_notifications = True\n        user_profile.enable_stream_audible_notifications = True\n        user_profile.enable_stream_email_notifications = True\n        user_profile.save()\n        current_stream = self.get_streams(user_profile)[0]\n        invite_streams = self.make_random_stream_names([current_stream])\n        self.assert_adding_subscriptions_for_principal(\n            invitee_user_id, invitee_realm, invite_streams, policy_name=\"Public\"\n        )\n        subscription = self.get_subscription(user_profile, invite_streams[0])\n\n        with mock.patch(\"zerver.models.Recipient.__repr__\", return_value=\"recip\"):\n            self.assertEqual(\n                repr(subscription),\n                \"<Subscription: \"\n                f\"<UserProfile: {user_profile.email} {user_profile.realm!r}> -> recip>\",\n            )\n\n        self.assertIsNone(subscription.desktop_notifications)\n        self.assertIsNone(subscription.push_notifications)\n        self.assertIsNone(subscription.audible_notifications)\n        self.assertIsNone(subscription.email_notifications)\n\n    def test_mark_messages_as_unread_on_unsubscribe(self) -> None:\n        realm = get_realm(\"zulip\")\n        user = self.example_user(\"iago\")\n        random_user = self.example_user(\"hamlet\")\n        stream1 = ensure_stream(realm, \"stream1\", invite_only=False, acting_user=None)\n        stream2 = ensure_stream(realm, \"stream2\", invite_only=False, acting_user=None)\n        private = ensure_stream(realm, \"private_stream\", invite_only=True, acting_user=None)\n\n        self.subscribe(user, \"stream1\")\n        self.subscribe(user, \"stream2\")\n        self.subscribe(user, \"private_stream\")\n        self.subscribe(random_user, \"stream1\")\n        self.subscribe(random_user, \"stream2\")\n        self.subscribe(random_user, \"private_stream\")\n\n        self.send_stream_message(random_user, \"stream1\", \"test\", \"test\")\n        self.send_stream_message(random_user, \"stream2\", \"test\", \"test\")\n        self.send_stream_message(random_user, \"private_stream\", \"test\", \"test\")\n\n        def get_unread_stream_data() -> List[UnreadStreamInfo]:\n            raw_unread_data = get_raw_unread_data(user)\n            aggregated_data = aggregate_unread_data(raw_unread_data)\n            return aggregated_data[\"streams\"]\n\n        result = get_unread_stream_data()\n        self.assert_length(result, 3)\n        self.assertEqual(result[0][\"stream_id\"], stream1.id)\n        self.assertEqual(result[1][\"stream_id\"], stream2.id)\n        self.assertEqual(result[2][\"stream_id\"], private.id)\n\n        # Unsubscribing should mark all the messages in stream2 as read\n        self.unsubscribe(user, \"stream2\")\n        self.unsubscribe(user, \"private_stream\")\n\n        self.subscribe(user, \"stream2\")\n        self.subscribe(user, \"private_stream\")\n        result = get_unread_stream_data()\n        self.assert_length(result, 1)\n        self.assertEqual(result[0][\"stream_id\"], stream1.id)\n\n    def test_gather_subscriptions_excludes_deactivated_streams(self) -> None:\n        \"\"\"\n        Check that gather_subscriptions_helper does not include deactivated streams in its\n        results.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        admin_user = self.example_user(\"iago\")\n        non_admin_user = self.example_user(\"cordelia\")\n\n        self.login_user(admin_user)\n\n        for stream_name in [\"stream1\", \"stream2\", \"stream3\"]:\n            self.make_stream(stream_name, realm=realm, invite_only=False)\n            self.subscribe(admin_user, stream_name)\n            self.subscribe(non_admin_user, stream_name)\n            self.subscribe(self.example_user(\"othello\"), stream_name)\n\n        def archive_stream(stream_name: str) -> None:\n            stream_id = get_stream(stream_name, realm).id\n            result = self.client_delete(f\"/json/streams/{stream_id}\")\n            self.assert_json_success(result)\n\n        # Deleted/deactivated stream should not be returned in the helper results\n        admin_before_delete = gather_subscriptions_helper(admin_user)\n        non_admin_before_delete = gather_subscriptions_helper(non_admin_user)\n\n        # Delete our stream\n        archive_stream(\"stream1\")\n\n        # Get subs after delete\n        admin_after_delete = gather_subscriptions_helper(admin_user)\n        non_admin_after_delete = gather_subscriptions_helper(non_admin_user)\n\n        # Compare results - should be 1 stream less\n        self.assertTrue(\n            len(admin_before_delete.subscriptions) == len(admin_after_delete.subscriptions) + 1,\n            \"Expected exactly 1 less stream from gather_subscriptions_helper\",\n        )\n        self.assertTrue(\n            len(non_admin_before_delete.subscriptions)\n            == len(non_admin_after_delete.subscriptions) + 1,\n            \"Expected exactly 1 less stream from gather_subscriptions_helper\",\n        )\n\n    def test_validate_user_access_to_subscribers_helper(self) -> None:\n        \"\"\"\n        Ensure the validate_user_access_to_subscribers_helper is properly raising\n        ValidationError on missing user, user not-in-realm.\n        \"\"\"\n        user_profile = self.example_user(\"othello\")\n        realm_name = \"no_othello_allowed\"\n        realm = do_create_realm(realm_name, \"Everyone but Othello is allowed\")\n        stream_dict = {\n            \"name\": \"publicstream\",\n            \"description\": \"Public stream with public history\",\n            \"realm_id\": realm.id,\n        }\n\n        # For this test to work, othello can't be in the no_othello_here realm\n        self.assertNotEqual(\n            user_profile.realm.id, realm.id, \"Expected othello user to not be in this realm.\"\n        )\n\n        # This should result in missing user\n        with self.assertRaises(ValidationError):\n            validate_user_access_to_subscribers_helper(None, stream_dict, lambda user_profile: True)\n\n        # This should result in user not in realm\n        with self.assertRaises(ValidationError):\n            validate_user_access_to_subscribers_helper(\n                user_profile, stream_dict, lambda user_profile: True\n            )\n\n    def test_subscriptions_query_count(self) -> None:\n        \"\"\"\n        Test database query count when creating stream with api/v1/users/me/subscriptions.\n        \"\"\"\n        user1 = self.example_user(\"cordelia\")\n        user2 = self.example_user(\"iago\")\n        new_streams = [\n            \"query_count_stream_1\",\n            \"query_count_stream_2\",\n            \"query_count_stream_3\",\n        ]\n\n        # Test creating a public stream when realm does not have a notification stream.\n        with self.assert_database_query_count(36):\n            self.common_subscribe_to_streams(\n                self.test_user,\n                [new_streams[0]],\n                dict(principals=orjson.dumps([user1.id, user2.id]).decode()),\n            )\n\n        # Test creating private stream.\n        with self.assert_database_query_count(35):\n            self.common_subscribe_to_streams(\n                self.test_user,\n                [new_streams[1]],\n                dict(principals=orjson.dumps([user1.id, user2.id]).decode()),\n                invite_only=True,\n            )\n\n        # Test creating a public stream with announce when realm has a notification stream.\n        notifications_stream = get_stream(self.streams[0], self.test_realm)\n        self.test_realm.notifications_stream_id = notifications_stream.id\n        self.test_realm.save()\n        with self.assert_database_query_count(44):\n            self.common_subscribe_to_streams(\n                self.test_user,\n                [new_streams[2]],\n                dict(\n                    announce=\"true\",\n                    principals=orjson.dumps([user1.id, user2.id]).decode(),\n                ),\n            )\n\n\nclass GetStreamsTest(ZulipTestCase):\n    def test_streams_api_for_bot_owners(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        test_bot = self.create_test_bot(\"foo\", hamlet)\n        assert test_bot is not None\n        realm = get_realm(\"zulip\")\n        self.login_user(hamlet)\n\n        # Check it correctly lists the bot owner's subs with\n        # include_owner_subscribed=true\n        filters = dict(\n            include_owner_subscribed=\"true\",\n            include_public=\"false\",\n            include_subscribed=\"false\",\n        )\n        result = self.api_get(test_bot, \"/api/v1/streams\", filters)\n        owner_subs = self.api_get(hamlet, \"/api/v1/users/me/subscriptions\")\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        self.assert_json_success(owner_subs)\n        owner_subs_json = orjson.loads(owner_subs.content)\n\n        self.assertEqual(\n            sorted(s[\"name\"] for s in json[\"streams\"]),\n            sorted(s[\"name\"] for s in owner_subs_json[\"subscriptions\"]),\n        )\n\n        # Check it correctly lists the bot owner's subs and the\n        # bot's subs\n        self.subscribe(test_bot, \"Scotland\")\n        filters = dict(\n            include_owner_subscribed=\"true\",\n            include_public=\"false\",\n            include_subscribed=\"true\",\n        )\n        result = self.api_get(test_bot, \"/api/v1/streams\", filters)\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        actual = sorted(s[\"name\"] for s in json[\"streams\"])\n        expected = [s[\"name\"] for s in owner_subs_json[\"subscriptions\"]]\n        expected.append(\"Scotland\")\n        expected.sort()\n\n        self.assertEqual(actual, expected)\n\n        # Check it correctly lists the bot owner's subs + all public streams\n        self.make_stream(\"private_stream\", realm=realm, invite_only=True)\n        self.subscribe(test_bot, \"private_stream\")\n        result = self.api_get(\n            test_bot,\n            \"/api/v1/streams\",\n            {\n                \"include_owner_subscribed\": \"true\",\n                \"include_public\": \"true\",\n                \"include_subscribed\": \"false\",\n            },\n        )\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        actual = sorted(s[\"name\"] for s in json[\"streams\"])\n        expected = [s[\"name\"] for s in owner_subs_json[\"subscriptions\"]]\n        expected.extend([\"Rome\", \"Venice\", \"Scotland\"])\n        expected.sort()\n\n        self.assertEqual(actual, expected)\n\n        # Check it correctly lists the bot owner's subs + all public streams +\n        # the bot's subs\n        result = self.api_get(\n            test_bot,\n            \"/api/v1/streams\",\n            {\n                \"include_owner_subscribed\": \"true\",\n                \"include_public\": \"true\",\n                \"include_subscribed\": \"true\",\n            },\n        )\n\n        json = self.assert_json_success(result)\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        actual = sorted(s[\"name\"] for s in json[\"streams\"])\n        expected = [s[\"name\"] for s in owner_subs_json[\"subscriptions\"]]\n        expected.extend([\"Rome\", \"Venice\", \"Scotland\", \"private_stream\"])\n        expected.sort()\n\n        self.assertEqual(actual, expected)\n\n    def test_all_active_streams_api(self) -> None:\n        url = \"/api/v1/streams\"\n        data = {\"include_all_active\": \"true\"}\n\n        # Check non-superuser can't use include_all_active\n        normal_user = self.example_user(\"cordelia\")\n        result = self.api_get(normal_user, url, data)\n        self.assertEqual(result.status_code, 400)\n\n        # Realm admin users can see all active streams.\n        admin_user = self.example_user(\"iago\")\n        self.assertTrue(admin_user.is_realm_admin)\n\n        result = self.api_get(admin_user, url, data)\n        json = self.assert_json_success(result)\n\n        self.assertIn(\"streams\", json)\n        self.assertIsInstance(json[\"streams\"], list)\n\n        stream_names = {s[\"name\"] for s in json[\"streams\"]}\n\n        self.assertEqual(\n            stream_names,\n            {\"Venice\", \"Denmark\", \"Scotland\", \"Verona\", \"Rome\", \"core team\"},\n        )\n\n    def test_public_streams_api(self) -> None:\n        \"\"\"\n        Ensure that the query we use to get public streams successfully returns\n        a list of streams\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        realm = get_realm(\"zulip\")\n        self.login_user(user)\n\n        # Check it correctly lists the user's subs with include_public=false\n        result = self.api_get(user, \"/api/v1/streams\", {\"include_public\": \"false\"})\n        result2 = self.api_get(user, \"/api/v1/users/me/subscriptions\")\n\n        json = self.assert_json_success(result)\n\n        self.assertIn(\"streams\", json)\n\n        self.assertIsInstance(json[\"streams\"], list)\n\n        self.assert_json_success(result2)\n        json2 = orjson.loads(result2.content)\n\n        self.assertEqual(\n            sorted(s[\"name\"] for s in json[\"streams\"]),\n            sorted(s[\"name\"] for s in json2[\"subscriptions\"]),\n        )\n\n        # Check it correctly lists all public streams with include_subscribed=false\n        filters = dict(include_public=\"true\", include_subscribed=\"false\")\n        result = self.api_get(user, \"/api/v1/streams\", filters)\n        json = self.assert_json_success(result)\n        all_streams = [\n            stream.name for stream in Stream.objects.filter(realm=realm, invite_only=False)\n        ]\n        self.assertEqual(sorted(s[\"name\"] for s in json[\"streams\"]), sorted(all_streams))\n\n    def test_get_single_stream_api(self) -> None:\n        self.login(\"hamlet\")\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"stream\"][\"name\"], \"Denmark\")\n        self.assertEqual(json[\"stream\"][\"stream_id\"], denmark_stream.id)\n\n        result = self.client_get(\"/json/streams/9999\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        private_stream = self.make_stream(\"private_stream\", invite_only=True)\n        self.subscribe(self.example_user(\"cordelia\"), \"private_stream\")\n\n        # Non-admins cannot access unsubscribed private streams.\n        result = self.client_get(f\"/json/streams/{private_stream.id}\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.login(\"iago\")\n        result = self.client_get(f\"/json/streams/{private_stream.id}\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"stream\"][\"name\"], \"private_stream\")\n        self.assertEqual(json[\"stream\"][\"stream_id\"], private_stream.id)\n\n        self.login(\"cordelia\")\n        result = self.client_get(f\"/json/streams/{private_stream.id}\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"stream\"][\"name\"], \"private_stream\")\n        self.assertEqual(json[\"stream\"][\"stream_id\"], private_stream.id)\n\n    def test_get_stream_email_address(self) -> None:\n        self.login(\"hamlet\")\n        hamlet = self.example_user(\"hamlet\")\n        iago = self.example_user(\"iago\")\n        polonius = self.example_user(\"polonius\")\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        denmark_email = encode_email_address_helper(\n            denmark_stream.name, denmark_stream.email_token, show_sender=True\n        )\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        self.login(\"polonius\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.subscribe(polonius, \"Denmark\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        do_change_stream_permission(\n            denmark_stream,\n            invite_only=True,\n            history_public_to_subscribers=True,\n            is_web_public=False,\n            acting_user=iago,\n        )\n        self.login(\"hamlet\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        self.unsubscribe(hamlet, \"Denmark\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        self.login(\"iago\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"email\"], denmark_email)\n\n        self.unsubscribe(iago, \"Denmark\")\n        result = self.client_get(f\"/json/streams/{denmark_stream.id}/email_address\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n\nclass StreamIdTest(ZulipTestCase):\n    def test_get_stream_id(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        stream = gather_subscriptions(user)[0][0]\n        result = self.client_get(\"/json/get_stream_id\", {\"stream\": stream[\"name\"]})\n        response_dict = self.assert_json_success(result)\n        self.assertEqual(response_dict[\"stream_id\"], stream[\"stream_id\"])\n\n    def test_get_stream_id_wrong_name(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.client_get(\"/json/get_stream_id\", {\"stream\": \"wrongname\"})\n        self.assert_json_error(result, \"Invalid stream name 'wrongname'\")\n\n\nclass InviteOnlyStreamTest(ZulipTestCase):\n    def test_must_be_subbed_to_send(self) -> None:\n        \"\"\"\n        If you try to send a message to an invite-only stream to which\n        you aren't subscribed, you'll get a 400.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        # Create Saxony as an invite-only stream.\n        self.assert_json_success(\n            self.common_subscribe_to_streams(user, [\"Saxony\"], invite_only=True)\n        )\n\n        cordelia = self.example_user(\"cordelia\")\n        with self.assertRaises(JsonableError):\n            self.send_stream_message(cordelia, \"Saxony\")\n\n    def test_list_respects_invite_only_bit(self) -> None:\n        \"\"\"\n        Make sure that /api/v1/users/me/subscriptions properly returns\n        the invite-only bit for streams that are invite-only\n        \"\"\"\n\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n\n        self.common_subscribe_to_streams(user, [\"Saxony\"], invite_only=True)\n        self.common_subscribe_to_streams(user, [\"Normandy\"], invite_only=False)\n        result = self.api_get(user, \"/api/v1/users/me/subscriptions\")\n        response_dict = self.assert_json_success(result)\n        self.assertIn(\"subscriptions\", response_dict)\n        for sub in response_dict[\"subscriptions\"]:\n            if sub[\"name\"] == \"Normandy\":\n                self.assertEqual(\n                    sub[\"invite_only\"], False, \"Normandy was mistakenly marked private\"\n                )\n            if sub[\"name\"] == \"Saxony\":\n                self.assertEqual(sub[\"invite_only\"], True, \"Saxony was not properly marked private\")\n\n    def test_inviteonly(self) -> None:\n        # Creating an invite-only stream is allowed\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        stream_name = \"Saxony\"\n\n        result = self.common_subscribe_to_streams(hamlet, [stream_name], invite_only=True)\n\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {hamlet.email: [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Subscribing oneself to an invite-only stream is not allowed\n        self.login_user(othello)\n        result = self.common_subscribe_to_streams(othello, [stream_name], allow_fail=True)\n        self.assert_json_error(result, \"Unable to access stream (Saxony).\")\n\n        # authorization_errors_fatal=False works\n        self.login_user(othello)\n        result = self.common_subscribe_to_streams(\n            othello,\n            [stream_name],\n            extra_post_data={\"authorization_errors_fatal\": orjson.dumps(False).decode()},\n        )\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"unauthorized\"], [stream_name])\n        self.assertEqual(json[\"subscribed\"], {})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Inviting another user to an invite-only stream is allowed\n        self.login_user(hamlet)\n        result = self.common_subscribe_to_streams(\n            hamlet,\n            [stream_name],\n            extra_post_data={\"principals\": orjson.dumps([othello.id]).decode()},\n        )\n        json = self.assert_json_success(result)\n        self.assertEqual(json[\"subscribed\"], {othello.email: [stream_name]})\n        self.assertEqual(json[\"already_subscribed\"], {})\n\n        # Make sure both users are subscribed to this stream\n        stream_id = get_stream(stream_name, hamlet.realm).id\n        result = self.api_get(hamlet, f\"/api/v1/streams/{stream_id}/members\")\n        json = self.assert_json_success(result)\n\n        self.assertTrue(othello.id in json[\"subscribers\"])\n        self.assertTrue(hamlet.id in json[\"subscribers\"])\n\n\nclass GetSubscribersTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.login_user(self.user_profile)\n\n    def verify_sub_fields(self, sub_data: SubscriptionInfo) -> None:\n        other_fields = {\n            \"is_announcement_only\",\n            \"in_home_view\",\n            \"stream_id\",\n            \"stream_weekly_traffic\",\n            \"subscribers\",\n        }\n\n        expected_fields = set(Stream.API_FIELDS) | set(Subscription.API_FIELDS) | other_fields\n        expected_fields -= {\"id\"}\n\n        for lst in [sub_data.subscriptions, sub_data.unsubscribed]:\n            for sub in lst:\n                self.assertEqual(set(sub), expected_fields)\n\n        other_fields = {\n            \"is_announcement_only\",\n            \"stream_id\",\n            \"stream_weekly_traffic\",\n            \"subscribers\",\n        }\n\n        expected_fields = set(Stream.API_FIELDS) | other_fields\n        expected_fields -= {\"id\"}\n\n        for never_sub in sub_data.never_subscribed:\n            self.assertEqual(set(never_sub), expected_fields)\n\n    def assert_user_got_subscription_notification(\n        self, user: UserProfile, expected_msg: str\n    ) -> None:\n        # verify that the user was sent a message informing them about the subscription\n        realm = user.realm\n        msg = most_recent_message(user)\n        self.assertEqual(msg.recipient.type, msg.recipient.PERSONAL)\n        self.assertEqual(msg.sender_id, self.notification_bot(realm).id)\n\n        def non_ws(s: str) -> str:\n            return s.replace(\"\\n\", \"\").replace(\" \", \"\")\n\n        self.assertEqual(non_ws(msg.content), non_ws(expected_msg))\n\n    def check_well_formed_result(\n        self, result: Dict[str, Any], stream_name: str, realm: Realm\n    ) -> None:\n        \"\"\"\n        A successful call to get_subscribers returns the list of subscribers in\n        the form:\n\n        {\"msg\": \"\",\n         \"result\": \"success\",\n         \"subscribers\": [hamlet_user.id, prospero_user.id]}\n        \"\"\"\n        self.assertIn(\"subscribers\", result)\n        self.assertIsInstance(result[\"subscribers\"], list)\n        true_subscribers = [\n            user_profile.id for user_profile in self.users_subscribed_to_stream(stream_name, realm)\n        ]\n        self.assertEqual(sorted(result[\"subscribers\"]), sorted(true_subscribers))\n\n    def make_subscriber_request(\n        self, stream_id: int, user: Optional[UserProfile] = None\n    ) -> \"TestHttpResponse\":\n        if user is None:\n            user = self.user_profile\n        return self.api_get(user, f\"/api/v1/streams/{stream_id}/members\")\n\n    def make_successful_subscriber_request(self, stream_name: str) -> None:\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        result = self.make_subscriber_request(stream_id)\n        response_dict = self.assert_json_success(result)\n        self.check_well_formed_result(response_dict, stream_name, self.user_profile.realm)\n\n    def test_subscriber(self) -> None:\n        \"\"\"\n        get_subscribers returns the list of subscribers.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0][\"name\"]\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_gather_subscriptions(self) -> None:\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n\n        (We also use this test to verify subscription notifications to\n        folks who get subscribed to streams.)\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        othello = self.example_user(\"othello\")\n        polonius = self.example_user(\"polonius\")\n\n        streams = [f\"stream_{i}\" for i in range(10)]\n        for stream_name in streams:\n            self.make_stream(stream_name)\n\n        users_to_subscribe = [\n            self.user_profile.id,\n            othello.id,\n            cordelia.id,\n            polonius.id,\n        ]\n\n        with self.assert_database_query_count(47):\n            self.common_subscribe_to_streams(\n                self.user_profile,\n                streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            )\n\n        msg = f\"\"\"\n            @**King Hamlet|{hamlet.id}** subscribed you to the following streams:\n\n            * #**stream_0**\n            * #**stream_1**\n            * #**stream_2**\n            * #**stream_3**\n            * #**stream_4**\n            * #**stream_5**\n            * #**stream_6**\n            * #**stream_7**\n            * #**stream_8**\n            * #**stream_9**\n            \"\"\"\n\n        for user in [cordelia, othello, polonius]:\n            self.assert_user_got_subscription_notification(user, msg)\n\n        # Subscribe ourself first.\n        self.common_subscribe_to_streams(\n            self.user_profile,\n            [\"stream_invite_only_1\"],\n            dict(principals=orjson.dumps([self.user_profile.id]).decode()),\n            invite_only=True,\n        )\n\n        # Now add in other users, and this should trigger messages\n        # to notify the user.\n        self.common_subscribe_to_streams(\n            self.user_profile,\n            [\"stream_invite_only_1\"],\n            dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            invite_only=True,\n        )\n\n        msg = f\"\"\"\n            @**King Hamlet|{hamlet.id}** subscribed you to the stream #**stream_invite_only_1**.\n            \"\"\"\n        for user in [cordelia, othello, polonius]:\n            self.assert_user_got_subscription_notification(user, msg)\n\n        with self.assert_database_query_count(4):\n            subscribed_streams, _ = gather_subscriptions(\n                self.user_profile, include_subscribers=True\n            )\n        self.assertGreaterEqual(len(subscribed_streams), 11)\n        for sub in subscribed_streams:\n            if not sub[\"name\"].startswith(\"stream_\"):\n                continue\n            self.assert_length(sub[\"subscribers\"], len(users_to_subscribe))\n\n    def test_never_subscribed_streams(self) -> None:\n        \"\"\"\n        Check never_subscribed streams are fetched correctly and not include invite_only streams,\n        or invite_only and public streams to guest users.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        users_to_subscribe = [\n            self.example_user(\"othello\").id,\n            self.example_user(\"cordelia\").id,\n        ]\n\n        public_streams = [\n            \"test_stream_public_1\",\n            \"test_stream_public_2\",\n            \"test_stream_public_3\",\n            \"test_stream_public_4\",\n            \"test_stream_public_5\",\n        ]\n\n        private_streams = [\n            \"test_stream_invite_only_1\",\n            \"test_stream_invite_only_2\",\n        ]\n\n        web_public_streams = [\n            \"test_stream_web_public_1\",\n            \"test_stream_web_public_2\",\n        ]\n\n        def create_public_streams() -> None:\n            for stream_name in public_streams:\n                self.make_stream(stream_name, realm=realm)\n\n            self.common_subscribe_to_streams(\n                self.user_profile,\n                public_streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            )\n\n        create_public_streams()\n\n        def create_web_public_streams() -> None:\n            for stream_name in web_public_streams:\n                self.make_stream(stream_name, realm=realm, is_web_public=True)\n\n            ret = self.common_subscribe_to_streams(\n                self.user_profile,\n                web_public_streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            )\n            self.assert_json_success(ret)\n\n        create_web_public_streams()\n\n        def create_private_streams() -> None:\n            self.common_subscribe_to_streams(\n                self.user_profile,\n                private_streams,\n                dict(principals=orjson.dumps(users_to_subscribe).decode()),\n                invite_only=True,\n            )\n\n        create_private_streams()\n\n        def get_never_subscribed() -> List[NeverSubscribedStreamDict]:\n            with self.assert_database_query_count(4):\n                sub_data = gather_subscriptions_helper(self.user_profile)\n                self.verify_sub_fields(sub_data)\n            never_subscribed = sub_data.never_subscribed\n\n            # Ignore old streams.\n            never_subscribed = [dct for dct in never_subscribed if dct[\"name\"].startswith(\"test_\")]\n            return never_subscribed\n\n        never_subscribed = get_never_subscribed()\n\n        # Invite only stream should not be there in never_subscribed streams\n        self.assert_length(never_subscribed, len(public_streams) + len(web_public_streams))\n        for stream_dict in never_subscribed:\n            name = stream_dict[\"name\"]\n            self.assertFalse(\"invite_only\" in name)\n            self.assert_length(stream_dict[\"subscribers\"], len(users_to_subscribe))\n\n        # Send private stream subscribers to all realm admins.\n        def test_admin_case() -> None:\n            self.user_profile.role = UserProfile.ROLE_REALM_ADMINISTRATOR\n            # Test realm admins can get never subscribed private stream's subscribers.\n            never_subscribed = get_never_subscribed()\n\n            self.assertEqual(\n                len(never_subscribed),\n                len(public_streams) + len(private_streams) + len(web_public_streams),\n            )\n            for stream_dict in never_subscribed:\n                self.assert_length(stream_dict[\"subscribers\"], len(users_to_subscribe))\n\n        test_admin_case()\n\n        def test_guest_user_case() -> None:\n            self.user_profile.role = UserProfile.ROLE_GUEST\n            helper_result = gather_subscriptions_helper(self.user_profile)\n            self.verify_sub_fields(helper_result)\n            sub = helper_result.subscriptions\n            unsub = helper_result.unsubscribed\n            never_sub = helper_result.never_subscribed\n\n            # It's +1 because of the stream Rome.\n            self.assert_length(never_sub, len(web_public_streams) + 1)\n            sub_ids = [stream[\"stream_id\"] for stream in sub]\n            unsub_ids = [stream[\"stream_id\"] for stream in unsub]\n\n            for stream_dict in never_sub:\n                self.assertTrue(stream_dict[\"is_web_public\"])\n                self.assertTrue(stream_dict[\"stream_id\"] not in sub_ids)\n                self.assertTrue(stream_dict[\"stream_id\"] not in unsub_ids)\n\n                # The Rome stream has is_web_public=True, with default\n                # subscribers not set up by this test, so we do the\n                # following check only for the streams we created.\n                if stream_dict[\"name\"] in web_public_streams:\n                    self.assert_length(stream_dict[\"subscribers\"], len(users_to_subscribe))\n\n        test_guest_user_case()\n\n    def test_gather_subscribed_streams_for_guest_user(self) -> None:\n        guest_user = self.example_user(\"polonius\")\n\n        stream_name_sub = \"public_stream_1\"\n        self.make_stream(stream_name_sub, realm=get_realm(\"zulip\"))\n        self.subscribe(guest_user, stream_name_sub)\n\n        stream_name_unsub = \"public_stream_2\"\n        self.make_stream(stream_name_unsub, realm=get_realm(\"zulip\"))\n        self.subscribe(guest_user, stream_name_unsub)\n        self.unsubscribe(guest_user, stream_name_unsub)\n\n        stream_name_never_sub = \"public_stream_3\"\n        self.make_stream(stream_name_never_sub, realm=get_realm(\"zulip\"))\n\n        normal_user = self.example_user(\"aaron\")\n        self.subscribe(normal_user, stream_name_sub)\n        self.subscribe(normal_user, stream_name_unsub)\n        self.subscribe(normal_user, stream_name_unsub)\n\n        helper_result = gather_subscriptions_helper(guest_user)\n        self.verify_sub_fields(helper_result)\n        subs = helper_result.subscriptions\n        neversubs = helper_result.never_subscribed\n\n        # Guest users get info about subscribed public stream's subscribers\n        expected_stream_exists = False\n        for sub in subs:\n            if sub[\"name\"] == stream_name_sub:\n                expected_stream_exists = True\n                self.assert_length(sub[\"subscribers\"], 2)\n        self.assertTrue(expected_stream_exists)\n\n        # Guest user only get data about never subscribed streams if they're\n        # web-public.\n        for stream in neversubs:\n            self.assertTrue(stream[\"is_web_public\"])\n\n        # Guest user only get data about never subscribed web-public streams\n        self.assert_length(neversubs, 1)\n\n    def test_api_fields_present(self) -> None:\n        user = self.example_user(\"cordelia\")\n\n        sub_data = gather_subscriptions_helper(user)\n        subscribed = sub_data.subscriptions\n        self.assertGreaterEqual(len(subscribed), 1)\n        self.verify_sub_fields(sub_data)\n\n    def test_previously_subscribed_private_streams(self) -> None:\n        admin_user = self.example_user(\"iago\")\n        non_admin_user = self.example_user(\"cordelia\")\n        guest_user = self.example_user(\"polonius\")\n        stream_name = \"private_stream\"\n\n        self.make_stream(stream_name, realm=get_realm(\"zulip\"), invite_only=True)\n        self.subscribe(admin_user, stream_name)\n        self.subscribe(non_admin_user, stream_name)\n        self.subscribe(guest_user, stream_name)\n        self.subscribe(self.example_user(\"othello\"), stream_name)\n\n        self.unsubscribe(admin_user, stream_name)\n        self.unsubscribe(non_admin_user, stream_name)\n        self.unsubscribe(guest_user, stream_name)\n\n        # Test admin user gets previously subscribed private stream's subscribers.\n        sub_data = gather_subscriptions_helper(admin_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 1)\n        self.assert_length(unsubscribed_streams[0][\"subscribers\"], 1)\n\n        # Test non-admin users cannot get previously subscribed private stream's subscribers.\n        sub_data = gather_subscriptions_helper(non_admin_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 0)\n\n        sub_data = gather_subscriptions_helper(guest_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 0)\n\n    def test_previously_subscribed_public_streams(self) -> None:\n        public_stream_name = \"public_stream\"\n        web_public_stream_name = \"web_public_stream\"\n        guest_user = self.example_user(\"polonius\")\n        member_user = self.example_user(\"hamlet\")\n\n        self.make_stream(public_stream_name, realm=get_realm(\"zulip\"))\n        self.make_stream(web_public_stream_name, realm=get_realm(\"zulip\"), is_web_public=True)\n\n        for stream_name in [public_stream_name, web_public_stream_name]:\n            self.subscribe(guest_user, stream_name)\n            self.subscribe(member_user, stream_name)\n            self.subscribe(self.example_user(\"othello\"), stream_name)\n\n        for stream_name in [public_stream_name, web_public_stream_name]:\n            self.unsubscribe(guest_user, stream_name)\n            self.unsubscribe(member_user, stream_name)\n\n        # Test member user gets previously subscribed public stream and its subscribers.\n        sub_data = gather_subscriptions_helper(member_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 2)\n        self.assert_length(unsubscribed_streams[0][\"subscribers\"], 1)\n        self.assert_length(unsubscribed_streams[1][\"subscribers\"], 1)\n\n        # Test guest users cannot get previously subscribed public stream but can get\n        # web-public stream and its subscribers.\n        sub_data = gather_subscriptions_helper(guest_user)\n        self.verify_sub_fields(sub_data)\n        unsubscribed_streams = sub_data.unsubscribed\n        self.assert_length(unsubscribed_streams, 1)\n        self.assertEqual(unsubscribed_streams[0][\"is_web_public\"], True)\n        self.assert_length(unsubscribed_streams[0][\"subscribers\"], 1)\n\n    def test_gather_subscriptions_mit(self) -> None:\n        \"\"\"\n        gather_subscriptions returns correct results with only 3 queries\n        \"\"\"\n        # Subscribe only ourself because invites are disabled on mit.edu\n        mit_user_profile = self.mit_user(\"starnine\")\n        user_id = mit_user_profile.id\n        users_to_subscribe = [user_id, self.mit_user(\"espuser\").id]\n        for email in users_to_subscribe:\n            stream = self.subscribe(mit_user_profile, \"mit_stream\")\n            self.assertTrue(stream.is_in_zephyr_realm)\n\n        self.common_subscribe_to_streams(\n            mit_user_profile,\n            [\"mit_invite_only\"],\n            dict(principals=orjson.dumps(users_to_subscribe).decode()),\n            invite_only=True,\n            subdomain=\"zephyr\",\n        )\n\n        with self.assert_database_query_count(4):\n            subscribed_streams, _ = gather_subscriptions(mit_user_profile, include_subscribers=True)\n\n        self.assertGreaterEqual(len(subscribed_streams), 2)\n        for sub in subscribed_streams:\n            if not sub[\"name\"].startswith(\"mit_\"):\n                raise AssertionError(\"Unexpected stream!\")\n            if sub[\"name\"] == \"mit_invite_only\":\n                self.assert_length(sub[\"subscribers\"], len(users_to_subscribe))\n            else:\n                self.assert_length(sub[\"subscribers\"], 0)\n\n    def test_nonsubscriber(self) -> None:\n        \"\"\"\n        Even a non-subscriber to a public stream can query a stream's membership\n        with get_subscribers.\n        \"\"\"\n        # Create a stream for which Hamlet is the only subscriber.\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.user_profile, [stream_name])\n        other_user = self.example_user(\"othello\")\n\n        # Fetch the subscriber list as a non-member.\n        self.login_user(other_user)\n        self.make_successful_subscriber_request(stream_name)\n\n    def test_subscriber_private_stream(self) -> None:\n        \"\"\"\n        A subscriber to a private stream can query that stream's membership.\n        \"\"\"\n        stream_name = \"Saxony\"\n        self.common_subscribe_to_streams(self.user_profile, [stream_name], invite_only=True)\n        self.make_successful_subscriber_request(stream_name)\n\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        # Verify another user can't get the data.\n        self.login(\"cordelia\")\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # But an organization administrator can\n        self.login(\"iago\")\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        self.assert_json_success(result)\n\n    def test_json_get_subscribers_stream_not_exist(self) -> None:\n        \"\"\"\n        json_get_subscribers also returns the list of subscribers for a stream.\n        \"\"\"\n        stream_id = 99999999\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n    def test_json_get_subscribers(self) -> None:\n        \"\"\"\n        json_get_subscribers in zerver/views/streams.py\n        also returns the list of subscribers for a stream, when requested.\n        \"\"\"\n        stream_name = gather_subscriptions(self.user_profile)[0][0][\"name\"]\n        stream_id = get_stream(stream_name, self.user_profile.realm).id\n        expected_subscribers = gather_subscriptions(self.user_profile, include_subscribers=True)[0][\n            0\n        ][\"subscribers\"]\n        result = self.client_get(f\"/json/streams/{stream_id}/members\")\n        result_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribers\", result_dict)\n        self.assertIsInstance(result_dict[\"subscribers\"], list)\n        subscribers: List[int] = []\n        for subscriber in result_dict[\"subscribers\"]:\n            self.assertIsInstance(subscriber, int)\n            subscribers.append(subscriber)\n        self.assertEqual(set(subscribers), set(expected_subscribers))\n\n    def test_json_get_subscribers_for_guest_user(self) -> None:\n        \"\"\"\n        Guest users should have access to subscribers of web-public streams, even\n        if they aren't subscribed or have never subscribed to that stream.\n        \"\"\"\n        guest_user = self.example_user(\"polonius\")\n        never_subscribed = gather_subscriptions_helper(guest_user, True).never_subscribed\n\n        # A guest user can only see never subscribed streams that are web-public.\n        # For Polonius, the only web-public stream that he is not subscribed at\n        # this point is Rome.\n        self.assert_length(never_subscribed, 1)\n\n        web_public_stream_id = never_subscribed[0][\"stream_id\"]\n        result = self.client_get(f\"/json/streams/{web_public_stream_id}/members\")\n        result_dict = self.assert_json_success(result)\n        self.assertIn(\"subscribers\", result_dict)\n        self.assertIsInstance(result_dict[\"subscribers\"], list)\n        self.assertGreater(len(result_dict[\"subscribers\"]), 0)\n\n    def test_nonsubscriber_private_stream(self) -> None:\n        \"\"\"\n        A non-subscriber non-realm-admin user to a private stream can't query that stream's membership.\n        But unsubscribed realm admin users can query private stream's membership.\n        \"\"\"\n        # Create a private stream for which Hamlet is the only subscriber.\n        stream_name = \"NewStream\"\n        self.common_subscribe_to_streams(self.user_profile, [stream_name], invite_only=True)\n        user_profile = self.example_user(\"othello\")\n\n        # Try to fetch the subscriber list as a non-member & non-realm-admin-user.\n        stream_id = get_stream(stream_name, user_profile.realm).id\n        result = self.make_subscriber_request(stream_id, user=user_profile)\n        self.assert_json_error(result, \"Invalid stream ID\")\n\n        # Try to fetch the subscriber list as a non-member & realm-admin-user.\n        self.login(\"iago\")\n        self.make_successful_subscriber_request(stream_name)\n\n\nclass AccessStreamTest(ZulipTestCase):\n    def test_access_stream(self) -> None:\n        \"\"\"\n        A comprehensive security test for the access_stream_by_* API functions.\n        \"\"\"\n        # Create a private stream for which Hamlet is the only subscriber.\n        hamlet = self.example_user(\"hamlet\")\n\n        stream_name = \"new_private_stream\"\n        self.login_user(hamlet)\n        self.common_subscribe_to_streams(hamlet, [stream_name], invite_only=True)\n        stream = get_stream(stream_name, hamlet.realm)\n\n        othello = self.example_user(\"othello\")\n\n        # Nobody can access a stream that doesn't exist\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(hamlet, 501232)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'invalid stream'\"):\n            access_stream_by_name(hamlet, \"invalid stream\")\n\n        # Hamlet can access the private stream\n        (stream_ret, sub_ret) = access_stream_by_id(hamlet, stream.id)\n        self.assertEqual(stream.id, stream_ret.id)\n        assert sub_ret is not None\n        self.assertEqual(sub_ret.recipient.type_id, stream.id)\n        (stream_ret2, sub_ret2) = access_stream_by_name(hamlet, stream.name)\n        self.assertEqual(stream_ret.id, stream_ret2.id)\n        self.assertEqual(sub_ret, sub_ret2)\n\n        # Othello cannot access the private stream\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(othello, stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'new_private_stream'\"):\n            access_stream_by_name(othello, stream.name)\n\n        # Both Othello and Hamlet can access a public stream that only\n        # Hamlet is subscribed to in this realm\n        public_stream_name = \"public_stream\"\n        self.common_subscribe_to_streams(hamlet, [public_stream_name], invite_only=False)\n        public_stream = get_stream(public_stream_name, hamlet.realm)\n        access_stream_by_id(othello, public_stream.id)\n        access_stream_by_name(othello, public_stream.name)\n        access_stream_by_id(hamlet, public_stream.id)\n        access_stream_by_name(hamlet, public_stream.name)\n\n        # Nobody can access a public stream in another realm\n        mit_realm = get_realm(\"zephyr\")\n        mit_stream = ensure_stream(mit_realm, \"mit_stream\", invite_only=False, acting_user=None)\n        sipbtest = self.mit_user(\"sipbtest\")\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(hamlet, mit_stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'mit_stream'\"):\n            access_stream_by_name(hamlet, mit_stream.name)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(sipbtest, stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'new_private_stream'\"):\n            access_stream_by_name(sipbtest, stream.name)\n\n        # MIT realm users cannot access even public streams in their realm\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(sipbtest, mit_stream.id)\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream name 'mit_stream'\"):\n            access_stream_by_name(sipbtest, mit_stream.name)\n\n        # But they can access streams they are subscribed to\n        self.common_subscribe_to_streams(sipbtest, [mit_stream.name], subdomain=\"zephyr\")\n        access_stream_by_id(sipbtest, mit_stream.id)\n        access_stream_by_name(sipbtest, mit_stream.name)\n\n    def test_stream_access_by_guest(self) -> None:\n        guest_user_profile = self.example_user(\"polonius\")\n        self.login_user(guest_user_profile)\n        stream_name = \"public_stream_1\"\n        stream = self.make_stream(stream_name, guest_user_profile.realm, invite_only=False)\n\n        # Guest user don't have access to unsubscribed public streams\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(guest_user_profile, stream.id)\n\n        # Guest user have access to subscribed public streams\n        self.subscribe(guest_user_profile, stream_name)\n        (stream_ret, sub_ret) = access_stream_by_id(guest_user_profile, stream.id)\n        assert sub_ret is not None\n        self.assertEqual(stream.id, stream_ret.id)\n        self.assertEqual(sub_ret.recipient.type_id, stream.id)\n\n        stream_name = \"private_stream_1\"\n        stream = self.make_stream(stream_name, guest_user_profile.realm, invite_only=True)\n        # Obviously, a guest user doesn't have access to unsubscribed private streams either\n        with self.assertRaisesRegex(JsonableError, \"Invalid stream ID\"):\n            access_stream_by_id(guest_user_profile, stream.id)\n\n        # Guest user have access to subscribed private streams\n        self.subscribe(guest_user_profile, stream_name)\n        (stream_ret, sub_ret) = access_stream_by_id(guest_user_profile, stream.id)\n        assert sub_ret is not None\n        self.assertEqual(stream.id, stream_ret.id)\n        self.assertEqual(sub_ret.recipient.type_id, stream.id)\n\n        stream_name = \"web_public_stream\"\n        stream = self.make_stream(stream_name, guest_user_profile.realm, is_web_public=True)\n        # Guest users have access to web-public streams even if they aren't subscribed.\n        (stream_ret, sub_ret) = access_stream_by_id(guest_user_profile, stream.id)\n        self.assertTrue(can_access_stream_history(guest_user_profile, stream))\n        assert sub_ret is None\n        self.assertEqual(stream.id, stream_ret.id)\n\n\nclass StreamTrafficTest(ZulipTestCase):\n    def test_average_weekly_stream_traffic_calculation(self) -> None:\n        # No traffic data for the stream\n        self.assertEqual(\n            get_average_weekly_stream_traffic(42, timezone_now() - timedelta(days=300), {1: 4003}),\n            0,\n        )\n\n        # using high numbers here to make it more likely to catch small errors in the denominators\n        # of the calculations. That being said we don't want to go over 100, since then the 2\n        # significant digits calculation gets applied\n        # old stream\n        self.assertEqual(\n            get_average_weekly_stream_traffic(\n                42, timezone_now() - timedelta(days=300), {42: 98 * 4 + 3}\n            ),\n            98,\n        )\n        # stream between 7 and 27 days old\n        self.assertEqual(\n            get_average_weekly_stream_traffic(\n                42, timezone_now() - timedelta(days=10), {42: (98 * 10 + 9) // 7}\n            ),\n            98,\n        )\n        # stream less than 7 days old\n        self.assertEqual(\n            get_average_weekly_stream_traffic(42, timezone_now() - timedelta(days=5), {42: 100}),\n            None,\n        )\n\n        # average traffic between 0 and 1\n        self.assertEqual(\n            get_average_weekly_stream_traffic(42, timezone_now() - timedelta(days=300), {42: 1}), 1\n        )\n\n    def test_round_to_2_significant_digits(self) -> None:\n        self.assertEqual(120, round_to_2_significant_digits(116))\n\n\nclass NoRecipientIDsTest(ZulipTestCase):\n    def test_no_recipient_ids(self) -> None:\n        user_profile = self.example_user(\"cordelia\")\n\n        Subscription.objects.filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        ).delete()\n        subs = gather_subscriptions_helper(user_profile).subscriptions\n\n        # Checks that gather_subscriptions_helper will not return anything\n        # since there will not be any recipients, without crashing.\n        #\n        # This covers a rare corner case.\n        self.assert_length(subs, 0)\n"], "filenames": ["zerver/actions/streams.py", "zerver/lib/events.py", "zerver/lib/subscription_info.py", "zerver/tests/test_subs.py"], "buggy_code_start_loc": [1031, 48, 19, 6138], "buggy_code_end_loc": [1046, 1014, 449, 6146], "fixing_code_start_loc": [1031, 48, 19, 6138], "fixing_code_end_loc": [1039, 1049, 501, 6179], "type": "NVD-CWE-noinfo", "message": "Zulip is an open-source team collaboration tool. It was discovered by the Zulip development team that active users who had previously been subscribed to a stream incorrectly continued being able to use the Zulip API to access metadata for that stream. As a result, users who had been removed from a stream, but still had an account in the organization, could still view metadata for that stream (including the stream name, description, settings, and an email address used to send emails into the stream via the incoming email integration). This potentially allowed users to see changes to a stream\u2019s metadata after they had lost access to the stream. This vulnerability has been addressed in version 7.5 and all users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-47642", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-16T22:15:28.353", "lastModified": "2023-11-25T02:06:17.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip is an open-source team collaboration tool. It was discovered by the Zulip development team that active users who had previously been subscribed to a stream incorrectly continued being able to use the Zulip API to access metadata for that stream. As a result, users who had been removed from a stream, but still had an account in the organization, could still view metadata for that stream (including the stream name, description, settings, and an email address used to send emails into the stream via the incoming email integration). This potentially allowed users to see changes to a stream\u2019s metadata after they had lost access to the stream. This vulnerability has been addressed in version 7.5 and all users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Zulip es una herramienta de colaboraci\u00f3n en equipo de c\u00f3digo abierto. El equipo de desarrollo de Zulip descubri\u00f3 que los usuarios activos que previamente se hab\u00edan suscrito a una transmisi\u00f3n incorrectamente segu\u00edan pudiendo usar la API de Zulip para acceder a los metadatos de esa transmisi\u00f3n. Como resultado, los usuarios que hab\u00edan sido eliminados de una transmisi\u00f3n, pero que a\u00fan ten\u00edan una cuenta en la organizaci\u00f3n, a\u00fan pod\u00edan ver los metadatos de esa transmisi\u00f3n (incluido el nombre de la transmisi\u00f3n, la descripci\u00f3n, la configuraci\u00f3n y una direcci\u00f3n de correo electr\u00f3nico utilizada para enviar correos electr\u00f3nicos a la transmisi\u00f3n). A trav\u00e9s de la integraci\u00f3n de correo electr\u00f3nico entrante). Esto potencialmente permit\u00eda a los usuarios ver cambios en los metadatos de una transmisi\u00f3n despu\u00e9s de haber perdido el acceso a la misma. Esta vulnerabilidad se solucion\u00f3 en la versi\u00f3n 7.5 y se recomienda a todos los usuarios que actualicen. No se conocen workarounds para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.0", "versionEndExcluding": "7.5", "matchCriteriaId": "90D94B75-D1FD-4045-AA53-F03EE0DFD781"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/6336322d2f9bbccaacfc80cba83a3c62eefd5737", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-c9wc-65fh-9x8p", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/6336322d2f9bbccaacfc80cba83a3c62eefd5737"}}