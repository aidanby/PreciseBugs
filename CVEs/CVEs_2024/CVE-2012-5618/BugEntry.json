{"buggy_code": ["<?php defined('SYSPATH') or die('No direct script access.');\n/**\n * This controller handles login requests.\n *\n * PHP version 5\n * LICENSE: This source file is subject to LGPL license\n * that is available through the world-wide-web at the following URI:\n * http://www.gnu.org/copyleft/lesser.html\n * @author\t   Ushahidi Team <team@ushahidi.com>\n * @package\t   Ushahidi - http://source.ushahididev.com\n * @subpackage Controllers\n * @copyright  Ushahidi - http://www.ushahidi.com\n * @license\t   http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License (LGPL)\n */\n\nclass Login_Controller extends Template_Controller {\n\n\tpublic $auto_render = TRUE;\n\t// Session Object\n\tprotected $session;\n\n\t// Main template\n\tpublic $template = 'login/main';\n\n\n\tpublic function __construct()\n\t{\n\t\tparent::__construct();\n\n\t\t$this->session = new Session();\n\t}\n\n\tpublic function index($user_id = 0)\n\t{\n\t\t// Set messages to display on the login page for the user\n\t\t$message = FALSE;\n\t\t$message_class = 'login_error';\n\n\t\t$auth = Auth::instance();\n\n\t\t// If already logged in redirect to user account page\n\n\t\t$insufficient_role = FALSE;\n\n\t\tif ($auth->logged_in())\n\t\t{\n\t\t\t// Redirect users to the relevant dashboard\n\t\t\tif ($auth->logged_in('login'))\n\t\t\t{\n\t\t\t\turl::redirect($auth->get_user()->dashboard());\n\t\t\t}\n\n\t\t\t$insufficient_role = TRUE;\n\t\t\t$message_class = 'login_error';\n\t\t\t$message = Kohana::lang('ui_main.insufficient_role');\n\t\t}\n\n\t\t// setup and initialize form field names\n\t\t$form = array(\n\t\t\t'action'\t=> '',\n\t\t\t'username'\t=> '',\n\t\t\t'password'\t=> '',\n\t\t\t'password_again'  => '',\n\t\t\t'name'\t\t=> '',\n\t\t\t'email'\t\t=> '',\n\t\t\t'resetemail' => '',\n\t\t\t'confirmation_email' => '',\n\t\t);\n\t\t//\tcopy the form as errors, so the errors will be stored with keys corresponding to the form field names\n\t\t$errors = $form;\n\t\t$form_error = FALSE;\n\t\t$openid_error = FALSE;\n\t\t$success = FALSE;\n\t\t$change_pw_success = FALSE;\n\t\t$new_confirm_email_form = FALSE;\n\n\t\t$action = (isset($_POST[\"action\"])) ? $_POST[\"action\"] : \"\";\n\n\t\t// Override success variable if change_pw_success GET var is set\n\t\tif (isset($_GET[\"change_pw_success\"]))\n\t\t{\n\t\t\t$change_pw_success = TRUE;\n\t\t\t$message_class = 'login_success';\n\t\t\t$message = Kohana::lang('ui_main.password_changed_successfully');\n\t\t}\n\n\t\t// Show send new confirm email form\n\t\tif (isset($_GET[\"new_confirm_email\"]))\n\t\t{\n\t\t\t$new_confirm_email_form = TRUE;\n\t\t\t$message_class = 'login_error';\n\t\t\t$message = Kohana::lang('ui_main.must_confirm_email_address');\n\t\t}\n\n\t\t// Show send new confirm email form\n\t\tif (isset($_GET[\"confirmation_failure\"]))\n\t\t{\n\t\t\t$new_confirm_email_form = TRUE;\n\t\t\t$message_class = 'login_error';\n\t\t\t$message = Kohana::lang('ui_main.confirm_email_failed');\n\t\t}\n\n\t\t// Show that confirming the email address was a success\n\t\tif (isset($_GET[\"confirmation_success\"]))\n\t\t{\n\t\t\t$message_class = 'login_success';\n\t\t\t$message = Kohana::lang('ui_main.confirm_email_successful');\n\t\t}\n\n\t\t// Is this a password reset request? We need to show the password reset form if it is\n\t\tif (isset($_GET[\"reset\"]))\n\t\t{\n\t\t\t$this->template->token = $this->uri->segment(4);\n\t\t\t$this->template->changeid = $this->uri->segment(3);\n\t\t}\n\n\t\t// Regular Form Post for Signin\n\t\t// check, has the form been submitted, if so, setup validation\n\t\tif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"signin\")\n\t\t{\n\n\t\t\t// START: Signin Process\n\n\t\t\t$post = Validation::factory($_POST);\n\t\t\t$post->pre_filter('trim');\n\t\t\t$post->add_rules('username', 'required');\n\t\t\t$post->add_rules('password', 'required');\n\n\t\t\tif ($post->validate(FALSE))\n\t\t\t{\n\t\t\t\t// Sanitize $_POST data removing all inputs without rules\n\t\t\t\t$postdata_array = $post->safe_array();\n\n\t\t\t\t// Flip this flag to flase to skip the login\n\t\t\t\t$valid_login = TRUE;\n\n\t\t\t\t// Load the user\n\t\t\t\t$user = ORM::factory('user', $postdata_array['username']);\n\n\t\t\t\t$remember = (isset($post->remember)) ? TRUE : FALSE;\n\n\t\t\t\t// Allow a login with username or email address, but we need to figure out which is\n\t\t\t\t// which so we can pass the appropriate variable on login. Mostly used for RiverID\n\n\t\t\t\t$email = $postdata_array['username'];\n\t\t\t\tif (valid::email($email) == FALSE)\n\t\t\t\t{\n\t\t\t\t\t// Invalid Email, we need to grab it from the user account instead\n\n\t\t\t\t\t$email = $user->email;\n\t\t\t\t\tif (valid::email($email) == FALSE AND kohana::config('riverid.enable') == TRUE)\n\t\t\t\t\t{\n\t\t\t\t\t\t// We don't have any valid email for this user.\n\t\t\t\t\t\t// Only skip login if we are authenticating with RiverID.\n\t\t\t\t\t\t$valid_login = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Auth Login requires catching exceptions to properly show errors\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t$login = $auth->login($user, $postdata_array['password'], $remember, $email);\n\n\t\t\t\t\t// Attempt a login\n\t\t\t\t\tif ($login AND $valid_login )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Action::user_login - User Logged In\n\t\t\t\t\t\tEvent::run('ushahidi_action.user_login',$user);\n\n\t\t\t\t\t\t// Exists Redirect to Dashboard\n\t\t\t\t\t\turl::redirect($user->dashboard());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// If user isn't confirmed, redirect to resend confirmation page\n\t\t\t\t\t\tif (Kohana::config('settings.require_email_confirmation') AND ORM::factory('user', $user)->confirmed == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turl::redirect(\"login?new_confirm_email\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Generic Error if exception not passed\n\t\t\t\t\t\t$post->add_error('password', 'login error');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception $e)\n\t\t\t\t{\n\t\t\t\t\t$error_message = $e->getMessage();\n\n\t\t\t\t\t// We use a \"custom\" message because of RiverID.\n\t\t\t\t\t$post->add_error('password', $error_message);\n\t\t\t\t}\n\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t// We need to already have created an error message file, for Kohana to use\n\t\t\t\t// Pass the error message file name to the errors() method\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t// We need to already have created an error message file, for Kohana to use\n\t\t\t\t// Pass the error message file name to the errors() method\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: Signin Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"new\")\n\t\t{\n\n\t\t\t// START: New User Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\n\t\t\t$post->add_rules('password','required', 'length['.kohana::config('auth.password_length').']','alpha_dash');\n\t\t\t$post->add_rules('name','required','length[3,100]');\n\t\t\t$post->add_rules('email','required','email','length[4,64]');\n\t\t\t$post->add_callbacks('username', array($this,'username_exists_chk'));\n\t\t\t$post->add_callbacks('email', array($this,'email_exists_chk'));\n\n\t\t\t// If Password field is not blank\n\t\t\tif ( ! empty($post->password))\n\t\t\t{\n\t\t\t\t$post->add_rules('password','required','length['.kohana::config('auth.password_length').']'\n\t\t\t\t\t,'alpha_dash','matches[password_again]');\t\t\t\n\t\t\t}\n\t\t\t//pass the post object to any plugins that care to know.\n\t\t\tEvent::run('ushahidi_action.users_add_login_form', $post);\n\t\t\tif ($post->validate())\n\t\t\t{\n\n\t\t\t\t$riverid_id = false;\n\t\t\t\tif (kohana::config('riverid.enable') == true)\n\t\t\t\t{\n\t\t\t\t\t$riverid = new RiverID;\n\t\t\t\t\t$riverid->email = $post->email;\n\t\t\t\t\t$riverid->password = $post->password;\n\t\t\t\t\t$riverid->register();\n\t\t\t\t\t$riverid_id = $riverid->user_id;\n\t\t\t\t}\n\n\t\t\t\t$user = User_Model::create_user($post->email,$post->password,$riverid_id,$post->name);\n\t\t\t\t//pass the new user on to any plugins that care to know\n\t\t\t\tEvent::run('ushahidi_action.user_edit', $user); \n\t\t\t\t// Send Confirmation email\n\t\t\t\t$email_sent = $this->_send_email_confirmation($user);\n\n\t\t\t\tif ($email_sent)\n\t\t\t\t{\n\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t$message = Kohana::lang('ui_main.login_confirmation_sent');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t$message = Kohana::lang('ui_main.login_account_creation_successful');\n\t\t\t\t}\n\n\t\t\t\t$success = TRUE;\n\t\t\t\t$action = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: New User Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"forgot\")\n\t\t{\n\n\t\t\t// START: Forgot Password Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\t\t\t$post->add_callbacks('resetemail', array($this,'email_exists_chk'));\n\n\t\t\tif ($post->validate())\n\t\t\t{\n\t\t\t\t$user = ORM::factory('user',$post->resetemail);\n\n\t\t\t\t// Existing User??\n\t\t\t\tif ($user->loaded)\n\t\t\t\t{\n\n\t\t\t\t\t// Determine which reset method to use. The options are to use the RiverID server\n\t\t\t\t\t//  or to use the normal method which just resets the password locally.\n\t\t\t\t\tif (Kohana::config('riverid.enable') == TRUE AND ! empty($user->riverid))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Reset on RiverID Server\n\n\t\t\t\t\t\t$secret_link = url::site('login/index/'.$user->id.'/%token%?reset');\n\t\t\t\t\t\t$message = $this->_email_resetlink_message($user->name, $secret_link);\n\n\t\t\t\t\t\t$riverid = new RiverID;\n\t\t\t\t\t\t$riverid->email = $post->resetemail;\n\t\t\t\t\t\t$riverid->requestpassword($message);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Reset locally\n\n\t\t\t\t\t\t// Secret consists of email and the last_login field.\n\t\t\t\t\t\t// So as soon as the user logs in again,\n\t\t\t\t\t\t// the reset link expires automatically.\n\t\t\t\t\t\t$secret = $auth->hash_password($user->email.$user->last_login);\n\t\t\t\t\t\t$secret_link = url::site('login/index/'.$user->id.'/'.$secret.'?reset');\n\t\t\t\t\t\t$email_sent = $this->_email_resetlink($post->resetemail,$user->name,$secret_link);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($email_sent == TRUE)\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.login_confirmation_sent');\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.unable_send_email');\n\t\t\t\t\t}\n\n\t\t\t\t\t$success = TRUE;\n\t\t\t\t\t$action = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: Forgot Password Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"changepass\")\n\t\t{\n\n\t\t\t// START: Password Change Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\t\t\t$post->add_rules('token','required');\n\t\t\t$post->add_rules('changeid','required');\n\t\t\t$post->add_rules('password','required','length['.Kohana::config('auth.password_length').']','alpha_dash');\n\t\t\t$post->add_rules('password','required','length['.Kohana::config('auth.password_length').']','alpha_dash','matches[password_again]');\n\n\t\t\tif ($post->validate())\n\t\t\t{\n\t\t\t\t$success = $this->_new_password($post->changeid, $post->password, $post->token);\n\n\t\t\t\tif ($success == TRUE)\n\t\t\t\t{\n\t\t\t\t\t// We don't need to see this page anymore if we were successful. We want to go\n\t\t\t\t\t//   to the login form and let the user know that they were successful at\n\t\t\t\t\t//   changing their password\n\n\t\t\t\t\turl::redirect(\"login?change_pw_success\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: Password Change Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"resend_confirmation\")\n\t\t{\n\t\t\t// START: Confirmation Email Resend Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\t\t\t$post->add_callbacks('confirmation_email', array($this,'email_exists_chk'));\n\n\t\t\tif ($post->validate())\n\t\t\t{\n\t\t\t\t$user = ORM::factory('user',$post->confirmation_email);\n\n\t\t\t\tif ($user->loaded)\n\t\t\t\t{\n\t\t\t\t\t// Send Confirmation email\n\t\t\t\t\t$email_sent = $this->_send_email_confirmation($user);\n\n\t\t\t\t\tif ($email_sent)\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.login_confirmation_sent');\n\t\t\t\t\t\t$success = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.unable_send_email');\n\t\t\t\t\t\t$success = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// ERROR: User doesn't exist\n\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t$message = Kohana::lang('ui_main.login_email_doesnt_exist');\n\t\t\t\t\t$success = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\t\t}\n\n\t\t// Only if we allow OpenID, should we even try this\n\t\tif (Kohana::config('config.allow_openid') == TRUE)\n\t\t{\n\n\t\t\t// START: OpenID Shenanigans\n\n\t\t\t// OpenID Post\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$openid = new OpenID;\n\n\t\t\t\t// Retrieve the Name (if available) and Email\n\t\t\t\t$openid->required = array(\"namePerson\", \"contact/email\");\n\n\t\t\t\tif( ! $openid->mode)\n\t\t\t\t{\n\t\t\t\t\tif(isset($_POST[\"openid_identifier\"]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$openid->identity = $_POST[\"openid_identifier\"];\n\t\t\t\t\t\theader(\"Location: \" . $openid->authUrl());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($openid->mode == \"cancel\")\n\t\t\t\t{\n\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t$message = \"You have canceled authentication!\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ($openid->validate())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Does User Exist?\n\t\t\t\t\t\t$openid_user = ORM::factory(\"openid\")\n\t\t\t\t\t\t\t->where(\"openid\", $openid->identity)\n\t\t\t\t\t\t\t->find();\n\n\t\t\t\t\t\tif ($openid_user->loaded AND $openid_user->user)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// First log all other sessions out\n\t\t\t\t\t\t\t$auth->logout();\n\n\t\t\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t\t\t$auth->force_login($openid_user->user->username);\n\n\t\t\t\t\t\t\t// Exists Redirect to Dashboard\n\t\t\t\t\t\t\turl::redirect($user->dashboard());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Does this openid have the required email??\n\t\t\t\t\t\t\t$new_openid = $openid->getAttributes();\n\t\t\t\t\t\t\tif ( ! isset($new_openid[\"contact/email\"]) OR\n\t\t\t\t\t\t\t\tempty($new_openid[\"contact/email\"]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t\t\t$message = $openid->identity . \" has not been logged in. No Email Address Found.\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Create new User and save OpenID\n\t\t\t\t\t\t\t\t$user = ORM::factory(\"user\");\n\n\t\t\t\t\t\t\t\t// But first... does this email address already exist\n\t\t\t\t\t\t\t\t// in the system?\n\t\t\t\t\t\t\t\tif ($user->email_exists($new_openid[\"contact/email\"]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t\t\t\t$message = $new_openid[\"contact/email\"] . \" is already registered in our system.\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$username = \"user\".time(); // Random User Name from TimeStamp - can be changed later\n\t\t\t\t\t\t\t\t\t$password = text::random(\"alnum\", 16); // Create Random Strong Password\n\n\t\t\t\t\t\t\t\t\t// Name Available?\n\t\t\t\t\t\t\t\t\t$user->name = (isset($new_openid[\"namePerson\"]) AND ! empty($new_openid[\"namePerson\"]))\n\t\t\t\t\t\t\t\t\t\t? $new_openid[\"namePerson\"]\n\t\t\t\t\t\t\t\t\t\t: $username;\n\t\t\t\t\t\t\t\t\t$user->username = $username;\n\t\t\t\t\t\t\t\t\t$user->password = $password;\n\t\t\t\t\t\t\t\t\t$user->email = $new_openid[\"contact/email\"];\n\n\t\t\t\t\t\t\t\t\t// Add New Roles\n\t\t\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'member'));\n\n\t\t\t\t\t\t\t\t\t$user->save();\n\n\t\t\t\t\t\t\t\t\t// Save OpenID and Association\n\t\t\t\t\t\t\t\t\t$openid_user->user_id = $user->id;\n\t\t\t\t\t\t\t\t\t$openid_user->openid = $openid->identity;\n\t\t\t\t\t\t\t\t\t$openid_user->openid_email = $new_openid[\"contact/email\"];\n\t\t\t\t\t\t\t\t\t$openid_user->openid_server = $openid->server;\n\t\t\t\t\t\t\t\t\t$openid_user->openid_date = date(\"Y-m-d H:i:s\");\n\t\t\t\t\t\t\t\t\t$openid_user->save();\n\n\t\t\t\t\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t\t\t\t\t$auth->login($username, $password, TRUE);\n\n\t\t\t\t\t\t\t\t\t// Redirect to Dashboard\n\t\t\t\t\t\t\t\t\turl::redirect($user->dashboard());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t$message = $openid->identity . \"has not been logged in.\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ErrorException $e)\n\t\t\t{\n\t\t\t\t$openid_error = TRUE;\n\t\t\t\t$message_class = 'login_error';\n\t\t\t\t$message = $e->getMessage();\n\t\t\t}\n\n\t\t\t// END: OpenID Shenanigans\n\n\t\t}\n\n\t\t// Set the little badge under the form informing users that their logins are being managed\n\t\t//   by an external service.\n\t\t$this->template->riverid_information = '';\n\t\tif (kohana::config('riverid.enable') == TRUE)\n\t\t{\n\t\t\t$riverid = new RiverID;\n\t\t\t$this->template->riverid_information = Kohana::lang('ui_main.riverid_information',$riverid->name);\n\t\t\t$this->template->riverid_url = $riverid->url;\n\t\t}\n\n\t\t$this->template->errors = $errors;\n\t\t$this->template->success = $success;\n\t\t$this->template->change_pw_success = $change_pw_success;\n\t\t$this->template->form = $form;\n\t\t$this->template->form_error = $form_error;\n\t\t$this->template->new_confirm_email_form = $new_confirm_email_form;\n\n\t\t// Message to user\n\t\t$this->template->message_class = $message_class;\n\t\t$this->template->message = $message;\n\n\t\t// This just means the user isn't a member or an admin, so they have nowhere to go, but they are logged in.\n\t\t$this->template->insufficient_role = $insufficient_role;\n\n\t\t$this->template->site_name = Kohana::config('settings.site_name');\n\t\t$this->template->site_tagline = Kohana::config('settings.site_tagline');\n\n\t\t// Javascript Header\n\t\t$this->template->js = new View('login/login_js');\n\t\t$this->template->js->action = $action;\n\n\t\t// Header Nav\n\t\t$header_nav = new View('header_nav');\n\t\t$this->template->header_nav = $header_nav;\n\t\t$this->template->header_nav->loggedin_user = FALSE;\n\t\tif ( isset(Auth::instance()->get_user()->id) )\n\t\t{\n\t\t\t// Load User\n\t\t\t$this->template->header_nav->loggedin_role = Auth::instance()->get_user()->dashboard();\n\t\t\t$this->template->header_nav->loggedin_user = Auth::instance()->get_user();\n\t\t}\n\t\t$this->template->header_nav->site_name = Kohana::config('settings.site_name');\n\t}\n\n\t/**\n\t * Confirms user registration\n\t */\n\tpublic function verify()\n\t{\n\t\t$auth = Auth::instance();\n\n\t\t$code = (isset($_GET['c']) AND ! empty($_GET['c'])) ? $_GET['c'] : \"\";\n\t\t$email = (isset($_GET['e']) AND ! empty($_GET['e'])) ? $_GET['e'] : \"\";\n\n\t\t$user = ORM::factory(\"user\")\n\t\t\t->where(\"code\", $code)\n\t\t\t->where(\"email\", $email)\n\t\t\t->where(\"confirmed != 1\")\n\t\t\t->find();\n\n\t\tif ($user->loaded)\n\t\t{\n\t\t\t$user->confirmed = 1;\n\n\t\t\t// Give the user the appropriate roles if the admin doesn't need to verify accounts\n\t\t\t//   and if they don't already have role assigned.\n\t\t\tif (Kohana::config('settings.manually_approve_users') == 0\n\t\t\t\tAND ! $user->has(ORM::factory('role', 'login')))\n\t\t\t{\n\t\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t\t$user->add(ORM::factory('role', 'member'));\n\t\t\t}\n\n\t\t\t$user->save();\n\n\t\t\t// Log all other sessions out so they can log in nicely on the login page\n\t\t\t$auth->logout();\n\n\t\t\t// Redirect to login\n\t\t\turl::redirect(\"login?confirmation_success\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Redirect to Login which will log themin if they are already logged in\n\t\t\turl::redirect(\"login?confirmation_failure\");\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Facebook connect function\n\t */\n\tpublic function facebook()\n\t{\n\t\t$auth = Auth::instance();\n\n\t\t$this->template = \"\";\n\t\t$this->auto_render = FALSE;\n\n\t\t$settings = ORM::factory(\"settings\")->find(1);\n\n\t\t$appid = $settings->facebook_appid;\n\t\t$appsecret = $settings->facebook_appsecret;\n\t\t$next_url = url::site().\"members/login/facebook\";\n\t\t$cancel_url = url::site().\"members/login\";\n\n\t\t// Create our Application instance.\n\t\t$facebook = new Facebook(array(\n\t\t\t'appId'  => $appid,\n\t\t\t'secret' => $appsecret,\n\t\t\t'cookie' => true\n\t\t));\n\n\t\t// Get User ID\n\t\t$fb_user = $facebook->getUser();\n\t\tif ($fb_user)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t    \t// Proceed knowing you have a logged in user who's authenticated.\n\t\t\t\t$new_openid = $facebook->api('/me');\n\n\t\t\t\t// Does User Exist?\n\t\t\t\t$openid_user = ORM::factory(\"openid\")\n\t\t\t\t\t->where(\"openid\", \"facebook_\".$new_openid[\"id\"])\n\t\t\t\t\t->find();\n\n\t\t\t\tif ($openid_user->loaded AND $openid_user->user)\n\t\t\t\t{\n\t\t\t\t\t// First log all other sessions out\n\t\t\t\t\t$auth->logout();\n\n\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t$auth->force_login($openid_user->user->username);\n\n\t\t\t\t\t// Exists Redirect to Dashboard\n\t\t\t\t\turl::redirect($auth->get_user()->dashboard());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Does this login have the required email??\n\t\t\t\t\tif ( ! isset($new_openid[\"email\"]) OR empty($new_openid[\"email\"]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$openid_error = \"User has not been logged in. No Email Address Found.\";\n\n\t\t\t\t\t\t// Redirect back to login\n\t\t\t\t\t\turl::redirect(\"login\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Create new User and save OpenID\n\t\t\t\t\t\t$user = ORM::factory(\"user\");\n\n\t\t\t\t\t\t// But first... does this email address already exist\n\t\t\t\t\t\t// in the system?\n\t\t\t\t\t\tif ($user->email_exists($new_openid[\"email\"]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$openid_error = $new_openid[\"email\"] . \" is already registered in our system.\";\n\n\t\t\t\t\t\t\t// Redirect back to login\n\t\t\t\t\t\t\turl::redirect(\"login\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$username = \"user\".time(); // Random User Name from TimeStamp - can be changed later\n\t\t\t\t\t\t\t$password = text::random(\"alnum\", 16); // Create Random Strong Password\n\n\t\t\t\t\t\t\t// Name Available?\n\t\t\t\t\t\t\t$user->name = (isset($new_openid[\"name\"]) AND ! empty($new_openid[\"name\"]))\n\t\t\t\t\t\t\t\t? $new_openid[\"name\"]\n\t\t\t\t\t\t\t\t: $username;\n\t\t\t\t\t\t\t$user->username = $username;\n\t\t\t\t\t\t\t$user->password = $password;\n\t\t\t\t\t\t\t$user->email = $new_openid[\"email\"];\n\n\t\t\t\t\t\t\t// Add New Roles\n\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'member'));\n\n\t\t\t\t\t\t\t$user->save();\n\n\t\t\t\t\t\t\t// Save OpenID and Association\n\t\t\t\t\t\t\t$openid_user->user_id = $user->id;\n\t\t\t\t\t\t\t$openid_user->openid = \"facebook_\".$new_openid[\"id\"];\n\t\t\t\t\t\t\t$openid_user->openid_email = $new_openid[\"email\"];\n\t\t\t\t\t\t\t$openid_user->openid_server = \"http://www.facebook.com\";\n\t\t\t\t\t\t\t$openid_user->openid_date = date(\"Y-m-d H:i:s\");\n\t\t\t\t\t\t\t$openid_user->save();\n\n\t\t\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t\t\t$auth->login($username, $password, TRUE);\n\n\t\t\t\t\t\t\t// Redirect to Dashboard\n\t\t\t\t\t\t\turl::redirect($auth->get_user()->dashboard());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (FacebookApiException $e)\n\t\t\t{\n\t\t\t\terror_log($e);\n\t\t\t\t$user = null;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$login_url = $facebook->getLoginUrl(\n\t\t\t\tarray(\n\t\t\t\t\t'canvas' => 1,\n\t\t\t\t\t'fbconnect' => 0,\n\t\t\t\t\t'scope' => \"email,publish_stream\",\n\t\t\t\t\t'next' => $next_url,\n\t\t\t\t\t'cancel' => $cancel_url\n\t\t\t\t)\n\t\t\t);\n\n\t\t\turl::redirect($login_url);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if username already exists.\n\t * @param Validation $post $_POST variable with validation rules\n\t */\n\tpublic function username_exists_chk(Validation $post)\n\t{\n\t\t$users = ORM::factory('user');\n\t\t// If add->rules validation found any errors, get me out of here!\n\t\tif (array_key_exists('username', $post->errors()))\n\t\t\treturn;\n\n\t\tif ($users->username_exists($post->username))\n\t\t\t$post->add_error( 'username', 'exists');\n\t}\n\n\t/**\n\t * Checks if email address is associated with an account.\n\t * @param Validation $post $_POST variable with validation rules\n\t */\n\tpublic function email_exists_chk( Validation $post )\n\t{\n\t\t$users = ORM::factory('user');\n\t\tif ($post->action == \"new\")\n\t\t{\n\t\t\tif (array_key_exists('email',$post->errors()))\n\t\t\t\treturn;\n\n\t\t\tif ($users->email_exists( $post->email ) )\n\t\t\t\t$post->add_error('email','exists');\n\t\t}\n\t\telseif($post->action == \"forgot\")\n\t\t{\n\t\t\tif (array_key_exists('resetemail',$post->errors()))\n\t\t\t\treturn;\n\n\t\t\tif ( ! $users->email_exists( $post->resetemail ) )\n\t\t\t\t$post->add_error('resetemail','invalid');\n\t\t}\n\t}\n\n    /**\n     * Create New password upon user request.\n     */\n    private function _new_password($user_id = 0, $password, $token)\n    {\n    \t$auth = Auth::instance();\n\t\t$user = ORM::factory('user',$user_id);\n\t\tif ($user->loaded == true)\n\t\t{\n\t\t\t// Determine Method (RiverID or standard)\n\n\t\t\tif (kohana::config('riverid.enable') == TRUE AND ! empty($user->riverid))\n\t\t\t{\n\t\t\t\t// Use RiverID\n\n\t\t\t\t// We don't really have to save the password locally but if a deployer\n\t\t\t\t//   ever wants to switch back locally, it's nice to have the pw there\n\t\t\t\t$user->password = $password;\n\t\t\t\t$user->save();\n\n\t\t\t\t// Relay the password change back to the RiverID server\n\t\t\t\t$riverid = new RiverID;\n\t\t\t\t$riverid->email = $user->email;\n\t\t\t\t$riverid->token = $token;\n\t\t\t\t$riverid->new_password = $password;\n\t\t\t\tif ($riverid->setpassword() == FALSE)\n\t\t\t\t{\n\t\t\t\t\t// TODO: Something went wrong. Tell the user.\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Use Standard\n\n\t\t\t\tif($auth->hash_password($user->email.$user->last_login, $auth->find_salt($token)) == $token)\n\t\t\t\t{\n\t\t\t\t\t$user->password = $password;\n\t\t\t\t\t$user->save();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO: Something went wrong, tell the user.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn TRUE;\n\t\t}\n\n\t\t// TODO: User doesn't exist, tell the user (meta, I know).\n\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t * Sends an email confirmation\n\t */\n\tprivate function _send_email_confirmation($user)\n\t{\n\t\t$settings = Kohana::config('settings');\n\n\t\t// Check if we require users to go through this process\n\t\tif ($settings['require_email_confirmation'] == 0)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t$email = $user->email;\n\t\t$code = text::random('alnum', 20);\n\t\t$user->code = $code;\n\t\t$user->save();\n\n\t\t$url = url::site().\"login/verify/?c=\".urlencode($code).\"&e=\".urlencode($email);\n\n\t\t$to = $email;\n\t\t$from = array($settings['site_email'], $settings['site_name']);\n\t\t$subject = $settings['site_name'].' '.Kohana::lang('ui_main.login_signup_confirmation_subject');\n\t\t$message = Kohana::lang('ui_main.login_signup_confirmation_message',\n\t\t\tarray($settings['site_name'], $url));\n\n\t\temail::send($to, $from, $subject, $message, FALSE);\n\n\t\treturn TRUE;\n\t}\n\n\t/**\n\t * Email reset link to the user.\n\t *\n\t * @param the email address of the user requesting a password reset.\n\t * @param the username of the user requesting a password reset.\n\t * @param the new generated password.\n\t *\n\t * @return void.\n\t */\n\tprivate function _email_resetlink( $email, $name, $secret_url )\n\t{\n\t\t$to = $email;\n\t\t$from = array(Kohana::config('settings.site_email'), Kohana::config('settings.site_name'));\n\t\t$subject = Kohana::lang('ui_admin.password_reset_subject');\n\t\t$message = $this->_email_resetlink_message($name, $secret_url);\n\n\t\ttry {\n\t\t\t$recipients = email::send( $to, $from, $subject, $message, FALSE );\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tKohana::log('warning', Swift_LogContainer::getLog()->dump(true));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treturn TRUE;\n\t}\n\n\t/**\n\t * Generate the email message body that goes out to the user when a password is reset\n\t *\n\t * @param the username of the user requesting a password reset.\n\t * @param the new generated password.\n\t *\n\t * @return void.\n\t */\n\tprivate function _email_resetlink_message( $name, $secret_url )\n\t{\n\t\t$message = Kohana::lang('ui_admin.password_reset_message_line_1').' '.$name.\",\\n\";\n\t\t$message .= Kohana::lang('ui_admin.password_reset_message_line_2').' '.$name.\". \";\n\t\t$message .= Kohana::lang('ui_admin.password_reset_message_line_3').\"\\n\\n\";\n\t\t$message .= $secret_url.\"\\n\\n\";\n\n\t\treturn $message;\n\n\t}\n\n}\n", "<?php defined('SYSPATH') or die('No direct script access.');\n\n/**\n* Default Settings From Database\n*/\n\n// Retrieve Cached Settings\n\n$cache = Cache::instance();\n$subdomain = Kohana::config('settings.subdomain');\n$settings = $cache->get($subdomain.'_settings');\nif ( ! $settings OR ! is_array($settings))\n{ // Cache is Empty so Re-Cache\n\t$settings = Settings_Model::get_array();\n\t$cache->set($subdomain.'_settings', $settings, array('settings'), 60); // 1 Day\n}\n\n// Set Site Language\nKohana::config_set('locale.language', $settings['site_language']);\nush_locale::detect_language();\n\n// Copy everything into kohana config settings.XYZ\nforeach($settings as $key => $setting)\n{\n\tKohana::config_set('settings.'.$key, $setting);\n}\n\n// Set Site Timezone\nif (function_exists('date_default_timezone_set'))\n{\n\t$timezone = $settings['site_timezone'];\n\t// Set default timezone, due to increased validation of date settings\n\t// which cause massive amounts of E_NOTICEs to be generated in PHP 5.2+\n\tdate_default_timezone_set(empty($timezone) ? date_default_timezone_get() : $timezone);\n\tKohana::config_set('settings.site_timezone', $timezone);\n}\n\n// Cache Settings\n$cache_pages = ($settings['cache_pages']) ? TRUE : FALSE;\nKohana::config_set('cache.cache_pages', $cache_pages);\nKohana::config_set('cache.default.lifetime', $settings['cache_pages_lifetime']);\n\n$default_map = $settings['default_map'];\n$map_layer = map::base($default_map);\nif (isset($map_layer->api_url) AND $map_layer->api_url != '')\n{\n\tKohana::config_set('settings.api_url', \n\t\t\"<script type=\\\"text/javascript\\\" src=\\\"\".$map_layer->api_url.\"\\\"></script>\");\n}\n\n// And in case you want to display all maps on one page...\n$api_google = $settings['api_google'];\n$api_live = $settings['api_live'];\nKohana::config_set('settings.api_url_all', \n\t\"<script type=\\\"text/javascript\\\" src=\\\"https://dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=6\\\"></script>\\n\"\n\t.\"<script type=\\\"text/javascript\\\" src=\\\"https://maps.google.com/maps/api/js?v=3.7&amp;sensor=false\\\"></script>\\n\"\n\t. html::script('https://www.openstreetmap.org/openlayers/OpenStreetMap.js')\n);\n\n// Additional Mime Types (KMZ/KML)\nKohana::config_set('mimes.kml', array('text/xml'));\nKohana::config_set('mimes.kmz', array('text/xml'));\n", "<?php\n/**\n * Model for users for the Auth Module\n *\n * $Id: user.php 3352 2008-08-18 09:43:56BST atomless $\n *\n * PHP version 5\n * LICENSE: This source file is subject to LGPL license\n * that is available through the world-wide-web at the following URI:\n * http://www.gnu.org/copyleft/lesser.html\n * @author     Ushahidi Team <team@ushahidi.com>\n * @package    Ushahidi - http://source.ushahididev.com\n * @subpackage Models\n * @copyright  Ushahidi - http://www.ushahidi.com\n * @license    http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License (LGPL)\n */\n\nclass User_Model extends Auth_User_Model {\n\n\tprotected $has_many = array('alert', 'comment', 'openid', 'private_message', 'rating');\n\t\n\t/**\n\t * Creates a basic user and assigns to login and member roles\n\t * \n\t * @param   string  email\n\t * @param   string  password\n\t * @param   string  riverid user id\n\t * @return  object  ORM object from saving the user\n\t */\n\tpublic static function create_user($email,$password,$riverid=false,$name=false)\n\t{\n\t\t$user = ORM::factory('user');\n\n\t\t$user->email = $email;\n\t\t$user->username = User_Model::random_username();\n\t\t$user->password = $password;\n\n\t\tif ($name != false)\n\t\t{\n\t\t\t$user->name = $name;\n\t\t}\n\n\t\tif ($riverid != false)\n\t\t{\n\t\t\t$user->riverid = $riverid;\n\t\t}\n\n\t\t// Add New Roles if:\n\t\t//    1. We don't require admin to approve users (will be added when admin approves)\n\t\t//    2. We don't require users to first confirm their email address (will be added\n\t\t//       when user confirms if the admin doesn't have to first approve the user)\n\t\tif (Kohana::config('settings.manually_approve_users') == 0\n\t\t\tAND Kohana::config('settings.require_email_confirmation') == 0)\n\t\t{\n\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t$user->add(ORM::factory('role', 'member'));\n\t\t}\n\n\t\treturn $user->save();\n\t}\n\n\t/**\n\t * Gets the email address of a user\n\t * @return string\n\t */\n\tpublic static function get_email($user_id)\n\t{\n\t\t$user = ORM::factory('user')->find($user_id);\n\t\treturn $user->email;\n\t}\n\n\t/**\n\t * Returns data for a user based on username\n\t * @return object\n\t */\n\tpublic static function get_user_by_username($username)\n\t{\n\t\t$user = ORM::factory('user')->where(array('username'=>$username))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns data for a user based on email\n\t * @return object\n\t */\n\tpublic static function get_user_by_email($email)\n\t{\n\t\t$user = ORM::factory('user')->where(array('email'=>$email))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns data for a user based on user id\n\t * @return object\n\t */\n\tpublic static function get_user_by_id($user_id)\n\t{\n\t\t$user = ORM::factory('user')->where(array('id'=>$user_id))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns data for a user based on river id\n\t * @return object\n\t */\n\tpublic static function get_user_by_river_id($river_id)\n\t{\n\t\t$user = ORM::factory('user')->where(array('riverid'=>$river_id))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns all users with public profiles\n\t * @return object\n\t */\n\tpublic static function get_public_users()\n\t{\n\t\t$users = ORM::factory('user')\n\t\t\t->where(array('public_profile'=>1)) // Only show public profiles\n\t\t\t->notlike(array('username'=>'@')) // We only want to show profiles that don't have email addresses as usernames\n\t\t\t->find_all();\n\t\treturn $users;\n\t}\n\n\t/**\n\t * Custom validation for this model - complements the default validate()\n\t *\n\t * @param   array  array to validate\n\t * @param   Auth   instance of Auth class; used for testing purposes\n\t * @return bool TRUE if validation succeeds, FALSE otherwise\n\t */\n\tpublic static function custom_validate(array & $post, Auth $auth = NULL)\n\t{\n\t\t// Initalize validation\n\t\t$post = Validation::factory($post)\n\t\t\t\t->pre_filter('trim', TRUE);\n\t\t\n\t\tif ($auth === NULL)\n\t\t{\n\t\t\t$auth = new Auth;\n\t\t}\n\n\t\t$post->add_rules('username','required','length[3,100]', 'alpha_numeric');\n\t\t$post->add_rules('name','required','length[3,100]');\n        $post->add_rules('email','required','email','length[4,64]');\n\n\t\t// If user id is not specified, check if the username already exists\n\t\tif (empty($post->user_id))\n\t\t{\n\t\t\t$post->add_callbacks('username', array('User_Model', 'unique_value_exists'));\n\t\t\t$post->add_callbacks('email', array('User_Model', 'unique_value_exists'));\n\t\t}\n\t\t\n\t\t// Make sure we have a value for password length to avoid PHP error for missing length[] function\n\t\t$password_length = Kohana::config('auth.password_length');\n\t\t$password_length = ( ! empty($password_length)) ? $password_length : '1,127';\n\n\t\t// Only check for the password if the user id has been specified and we are passing a pw\n\t\tif (isset($post->user_id) AND isset($post->password))\n\t\t{\n\t\t\t$post->add_rules('password','required', 'alpha_dash', 'length['.$password_length.']');\n\t\t\t$post->add_callbacks('password' ,'User_Model::validate_password');\n\t\t}\n\n\t\t// If Password field is not blank and is being passed\n\t\tif ( isset($post->password) AND\n\t\t\t(! empty($post->password) OR (empty($post->password) AND ! empty($post->password_again))))\n\t\t{\n\t\t\t$post->add_rules('password','required', 'alpha_dash','length['.$password_length.']', 'matches[password_again]');\n\t\t\t$post->add_callbacks('password' ,'User_Model::validate_password');\n\t\t}\n\n\t\t$post->add_rules('role','required','length[3,30]', 'alpha_numeric');\n\t\t$post->add_rules('notify','between[0,1]');\n\n\t\tif ( ! $auth->logged_in('superadmin'))\n\t\t{\n\t\t\t$post->add_callbacks('role', array('User_Model', 'prevent_superadmin_modification'));\n\t\t}\n\n\t\t// Additional validation checks\n\t\tEvent::run('ushahidi_action.user_submit_admin', $post);\n\n\t\t// Return\n\t\treturn $post->validate();\n\t}\n\n\t/**\n\t * Checks if a password is correct\n\t *\n\t * @param   int  user id\n\t * @param   string   password to check\n\t * @return bool TRUE if the password matches, FALSE otherwise\n\t */\n\tpublic static function check_password($user_id,$password,$force_standard_method=FALSE)\n\t{\n\t\t$user = ORM::factory('user',$user_id);\n\n\t\t// RiverID or Standard method?\n\t\tif (kohana::config('riverid.enable') == TRUE\n        \tAND ! empty($user->riverid)\n        \tAND ! $force_standard_method)\n\t\t{\n\t\t\t// RiverID\n\t\t\t$riverid = new RiverID;\n\t\t\t$riverid->email = $user->email;\n\t\t\t$riverid->password = $password;\n\t\t\tif ($riverid->checkpassword() != FALSE)\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO: Maybe return the error message?\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Standard Local\n\t\t\t$auth = Auth::instance();\n\t\t\treturn $auth->check_password($user_id,$password);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the value in the specified field exists in database\n\t */\n\tpublic static function unique_value_exists(Validation $post, $field)\n\t{\n\t\t$exists = (bool) ORM::factory('user')->where($field, $post[$field])->count_all();\n\t\tif ($exists)\n\t\t{\n\t\t\t$post->add_error($field, 'exists');\n\t\t}\n\t}\n\n\t/**\n\t * Ensures that only a superadmin can modify superadmin users, or upgrade a user to superadmin\n\t * @note this assumes the currently logged-in user isn't a superadmin\n\t */\n\tpublic static function prevent_superadmin_modification(Validation $post, $field)\n\t{\n\t\tif ($post[$field] == 'superadmin')\n\t\t{\n\t\t\t$post->add_error($field, 'superadmin_modify');\n\t\t}\n\t}\n\n\tpublic static function validate_password(Validation $post, $field)\n\t{\n\t\t$_is_valid = User_Model::password_rule($post[$field]);\n\t\tif (! $_is_valid)\n\t\t{\n\t\t\t$post->add_error($field,'alpha_dash');\n\t\t}\n\t}\n\n\tpublic static function password_rule($password, $utf8 = FALSE)\n\t{\n\t\treturn ($utf8 === TRUE)\n\t\t\t? (bool) preg_match('/^[-\\pL\\pN#@_]++$/uD', (string) $password)\n\t\t\t: (bool) preg_match('/^[-a-z0-9#@_]++$/iD', (string) $password);\n\t}\n\n\t/*\n\t* Creates a random int value for a username that isn't already represented in the database\n\t*/\n\tpublic function random_username()\n\t{\n\t\twhile ($random = mt_rand(1000,mt_getrandmax()))\n\t\t{\n\t\t\t$find_username = ORM::factory('user')->where('username',$random)->count_all();\n\t\t\tif ($find_username == 0)\n\t\t\t{\n\t\t\t\treturn $random;\n\t\t\t}\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\n\t/**\n\t * Overrides the default delete method for the ORM.\n\t * Deletes roles associated with the user before user is removed from DB.\n\t */\n\tpublic function delete()\n\t{\n\t\t$table_prefix = Kohana::config('database.default.table_prefix');\n\t\t\n\t\t// Remove assigned roles\n\t\t// Have to use db->query() since we don't have an ORM model for roles_users\n\t\t$this->db->query('DELETE FROM `'.$table_prefix.'roles_users` WHERE user_id = ?',$this->id);\n\t\t\n\t\t// Remove assigned badges\n\t\t$this->db->query('DELETE FROM `'.$table_prefix.'badge_users` WHERE user_id = ?',$this->id);\n\n\t\t// Delete alerts\n\t\tORM::factory('alert')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\t\t\n\t\t// Delete user_token\n\t\tORM::factory('user_token')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\t\t\n\t\t// Delete openid\n\t\tORM::factory('openid')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\n\t\t// Delete user_devices\n\t\tORM::factory('user_devices')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\t\t\n\t\tparent::delete();\n\t}\n\t\n\t/**\n\t * Check if user has specified permission\n\t * @param $permission String permission name\n\t **/\n\tpublic function has_permission($permission)\n\t{\n\t\t// Special case - superadmin ALWAYS has all permissions\n\t\tif ($this->has(ORM::factory('role','superadmin')))\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t\t\n\t\tforeach ($this->roles as $user_role)\n\t\t{\n\t\t\tif ($user_role->has(ORM::factory('permission',$permission)))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn FALSE;\n\t}\n\t\n\t/**\n\t * Get user's dashboard\n\t */\n\tpublic function dashboard()\n\t{\n\t\tif ($this->has_permission('admin_ui'))\n\t\t\treturn 'admin';\n\t\t\n\t\tif ($this->has_permission('member_ui'))\n\t\t\treturn 'members';\n\t\t\n\t\t// Just in case someone has a login only role\n\t\tif ($this->has(ORM::factory('role','login')))\n\t\t\treturn '';\n\t\t\n\t\t// Send anyone else to login\n\t\treturn 'login';\n\t}\n\n} // End User_Model\n"], "fixing_code": ["<?php defined('SYSPATH') or die('No direct script access.');\n/**\n * This controller handles login requests.\n *\n * PHP version 5\n * LICENSE: This source file is subject to LGPL license\n * that is available through the world-wide-web at the following URI:\n * http://www.gnu.org/copyleft/lesser.html\n * @author\t   Ushahidi Team <team@ushahidi.com>\n * @package\t   Ushahidi - http://source.ushahididev.com\n * @subpackage Controllers\n * @copyright  Ushahidi - http://www.ushahidi.com\n * @license\t   http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License (LGPL)\n */\n\nclass Login_Controller extends Template_Controller {\n\n\tpublic $auto_render = TRUE;\n\t// Session Object\n\tprotected $session;\n\n\t// Main template\n\tpublic $template = 'login/main';\n\n\n\tpublic function __construct()\n\t{\n\t\tparent::__construct();\n\n\t\t$this->session = new Session();\n\t}\n\n\tpublic function index($user_id = 0)\n\t{\n\t\t// Set messages to display on the login page for the user\n\t\t$message = FALSE;\n\t\t$message_class = 'login_error';\n\n\t\t$auth = Auth::instance();\n\n\t\t// If already logged in redirect to user account page\n\n\t\t$insufficient_role = FALSE;\n\n\t\tif ($auth->logged_in())\n\t\t{\n\t\t\t// Redirect users to the relevant dashboard\n\t\t\tif ($auth->logged_in('login'))\n\t\t\t{\n\t\t\t\turl::redirect($auth->get_user()->dashboard());\n\t\t\t}\n\n\t\t\t$insufficient_role = TRUE;\n\t\t\t$message_class = 'login_error';\n\t\t\t$message = Kohana::lang('ui_main.insufficient_role');\n\t\t}\n\n\t\t// setup and initialize form field names\n\t\t$form = array(\n\t\t\t'action'\t=> '',\n\t\t\t'username'\t=> '',\n\t\t\t'password'\t=> '',\n\t\t\t'password_again'  => '',\n\t\t\t'name'\t\t=> '',\n\t\t\t'email'\t\t=> '',\n\t\t\t'resetemail' => '',\n\t\t\t'confirmation_email' => '',\n\t\t);\n\t\t//\tcopy the form as errors, so the errors will be stored with keys corresponding to the form field names\n\t\t$errors = $form;\n\t\t$form_error = FALSE;\n\t\t$openid_error = FALSE;\n\t\t$success = FALSE;\n\t\t$change_pw_success = FALSE;\n\t\t$new_confirm_email_form = FALSE;\n\n\t\t$action = (isset($_POST[\"action\"])) ? $_POST[\"action\"] : \"\";\n\n\t\t// Override success variable if change_pw_success GET var is set\n\t\tif (isset($_GET[\"change_pw_success\"]))\n\t\t{\n\t\t\t$change_pw_success = TRUE;\n\t\t\t$message_class = 'login_success';\n\t\t\t$message = Kohana::lang('ui_main.password_changed_successfully');\n\t\t}\n\n\t\t// Show send new confirm email form\n\t\tif (isset($_GET[\"new_confirm_email\"]))\n\t\t{\n\t\t\t$new_confirm_email_form = TRUE;\n\t\t\t$message_class = 'login_error';\n\t\t\t$message = Kohana::lang('ui_main.must_confirm_email_address');\n\t\t}\n\n\t\t// Show send new confirm email form\n\t\tif (isset($_GET[\"confirmation_failure\"]))\n\t\t{\n\t\t\t$new_confirm_email_form = TRUE;\n\t\t\t$message_class = 'login_error';\n\t\t\t$message = Kohana::lang('ui_main.confirm_email_failed');\n\t\t}\n\n\t\t// Show that confirming the email address was a success\n\t\tif (isset($_GET[\"confirmation_success\"]))\n\t\t{\n\t\t\t$message_class = 'login_success';\n\t\t\t$message = Kohana::lang('ui_main.confirm_email_successful');\n\t\t}\n\n\t\t// Is this a password reset request? We need to show the password reset form if it is\n\t\tif (isset($_GET[\"reset\"]))\n\t\t{\n\t\t\t$this->template->token = $this->uri->segment(4);\n\t\t\t$this->template->changeid = $this->uri->segment(3);\n\t\t}\n\n\t\t// Regular Form Post for Signin\n\t\t// check, has the form been submitted, if so, setup validation\n\t\tif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"signin\")\n\t\t{\n\n\t\t\t// START: Signin Process\n\n\t\t\t$post = Validation::factory($_POST);\n\t\t\t$post->pre_filter('trim');\n\t\t\t$post->add_rules('username', 'required');\n\t\t\t$post->add_rules('password', 'required');\n\n\t\t\tif ($post->validate(FALSE))\n\t\t\t{\n\t\t\t\t// Sanitize $_POST data removing all inputs without rules\n\t\t\t\t$postdata_array = $post->safe_array();\n\n\t\t\t\t// Flip this flag to flase to skip the login\n\t\t\t\t$valid_login = TRUE;\n\n\t\t\t\t// Load the user\n\t\t\t\t$user = ORM::factory('user', $postdata_array['username']);\n\n\t\t\t\t$remember = (isset($post->remember)) ? TRUE : FALSE;\n\n\t\t\t\t// Allow a login with username or email address, but we need to figure out which is\n\t\t\t\t// which so we can pass the appropriate variable on login. Mostly used for RiverID\n\n\t\t\t\t$email = $postdata_array['username'];\n\t\t\t\tif (valid::email($email) == FALSE)\n\t\t\t\t{\n\t\t\t\t\t// Invalid Email, we need to grab it from the user account instead\n\n\t\t\t\t\t$email = $user->email;\n\t\t\t\t\tif (valid::email($email) == FALSE AND kohana::config('riverid.enable') == TRUE)\n\t\t\t\t\t{\n\t\t\t\t\t\t// We don't have any valid email for this user.\n\t\t\t\t\t\t// Only skip login if we are authenticating with RiverID.\n\t\t\t\t\t\t$valid_login = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Auth Login requires catching exceptions to properly show errors\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t$login = $auth->login($user, $postdata_array['password'], $remember, $email);\n\n\t\t\t\t\t// Attempt a login\n\t\t\t\t\tif ($login AND $valid_login )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Action::user_login - User Logged In\n\t\t\t\t\t\tEvent::run('ushahidi_action.user_login',$user);\n\n\t\t\t\t\t\t// Exists Redirect to Dashboard\n\t\t\t\t\t\turl::redirect($user->dashboard());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// If user isn't confirmed, redirect to resend confirmation page\n\t\t\t\t\t\tif (Kohana::config('settings.require_email_confirmation') AND ORM::factory('user', $user)->confirmed == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turl::redirect(\"login?new_confirm_email\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Generic Error if exception not passed\n\t\t\t\t\t\t$post->add_error('password', 'login error');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception $e)\n\t\t\t\t{\n\t\t\t\t\t$error_message = $e->getMessage();\n\n\t\t\t\t\t// We use a \"custom\" message because of RiverID.\n\t\t\t\t\t$post->add_error('password', $error_message);\n\t\t\t\t}\n\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t// We need to already have created an error message file, for Kohana to use\n\t\t\t\t// Pass the error message file name to the errors() method\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t// We need to already have created an error message file, for Kohana to use\n\t\t\t\t// Pass the error message file name to the errors() method\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: Signin Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"new\")\n\t\t{\n\n\t\t\t// START: New User Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\n\t\t\t$post->add_rules('password','required', 'length['.kohana::config('auth.password_length').']','alpha_dash');\n\t\t\t$post->add_rules('name','required','length[3,100]');\n\t\t\t$post->add_rules('email','required','email','length[4,64]');\n\t\t\t$post->add_callbacks('username', array($this,'username_exists_chk'));\n\t\t\t$post->add_callbacks('email', array($this,'email_exists_chk'));\n\n\t\t\t// If Password field is not blank\n\t\t\tif ( ! empty($post->password))\n\t\t\t{\n\t\t\t\t$post->add_rules('password','required','length['.kohana::config('auth.password_length').']'\n\t\t\t\t\t,'alpha_dash','matches[password_again]');\t\t\t\n\t\t\t}\n\t\t\t//pass the post object to any plugins that care to know.\n\t\t\tEvent::run('ushahidi_action.users_add_login_form', $post);\n\t\t\tif ($post->validate())\n\t\t\t{\n\n\t\t\t\t$riverid_id = false;\n\t\t\t\tif (kohana::config('riverid.enable') == true)\n\t\t\t\t{\n\t\t\t\t\t$riverid = new RiverID;\n\t\t\t\t\t$riverid->email = $post->email;\n\t\t\t\t\t$riverid->password = $post->password;\n\t\t\t\t\t$riverid->register();\n\t\t\t\t\t$riverid_id = $riverid->user_id;\n\t\t\t\t}\n\n\t\t\t\t$user = User_Model::create_user($post->email,$post->password,$riverid_id,$post->name);\n\t\t\t\t//pass the new user on to any plugins that care to know\n\t\t\t\tEvent::run('ushahidi_action.user_edit', $user); \n\t\t\t\t// Send Confirmation email\n\t\t\t\t$email_sent = $this->_send_email_confirmation($user);\n\n\t\t\t\tif ($email_sent)\n\t\t\t\t{\n\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t$message = Kohana::lang('ui_main.login_confirmation_sent');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t$message = Kohana::lang('ui_main.login_account_creation_successful');\n\t\t\t\t}\n\n\t\t\t\t$success = TRUE;\n\t\t\t\t$action = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: New User Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"forgot\")\n\t\t{\n\n\t\t\t// START: Forgot Password Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\t\t\t$post->add_callbacks('resetemail', array($this,'email_exists_chk'));\n\n\t\t\tif ($post->validate())\n\t\t\t{\n\t\t\t\t$user = ORM::factory('user',$post->resetemail);\n\n\t\t\t\t// Existing User??\n\t\t\t\tif ($user->loaded)\n\t\t\t\t{\n\n\t\t\t\t\t// Determine which reset method to use. The options are to use the RiverID server\n\t\t\t\t\t//  or to use the normal method which just resets the password locally.\n\t\t\t\t\tif (Kohana::config('riverid.enable') == TRUE AND ! empty($user->riverid))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Reset on RiverID Server\n\n\t\t\t\t\t\t$secret_link = url::site('login/index/'.$user->id.'/%token%?reset');\n\t\t\t\t\t\t$message = $this->_email_resetlink_message($user->name, $secret_link);\n\n\t\t\t\t\t\t$riverid = new RiverID;\n\t\t\t\t\t\t$riverid->email = $post->resetemail;\n\t\t\t\t\t\t$riverid->requestpassword($message);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Reset locally\n\t\t\t\t\t\t$secret = $user->forgot_password_token();\n\t\t\t\t\t\t$secret_link = url::site('login/index/'.$user->id.'/'.urlencode($secret).'?reset');\n\t\t\t\t\t\t$email_sent = $this->_email_resetlink($post->resetemail, $user->name, $secret_link);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($email_sent == TRUE)\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.login_confirmation_sent');\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.unable_send_email');\n\t\t\t\t\t}\n\n\t\t\t\t\t$success = TRUE;\n\t\t\t\t\t$action = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: Forgot Password Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"changepass\")\n\t\t{\n\n\t\t\t// START: Password Change Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\t\t\t$post->add_rules('token','required');\n\t\t\t$post->add_rules('changeid','required');\n\t\t\t$post->add_rules('password','required','length['.Kohana::config('auth.password_length').']','alpha_dash');\n\t\t\t$post->add_rules('password','required','length['.Kohana::config('auth.password_length').']','alpha_dash','matches[password_again]');\n\n\t\t\tif ($post->validate())\n\t\t\t{\n\t\t\t\t$success = $this->_new_password($post->changeid, $post->password, $post->token);\n\n\t\t\t\tif ($success == TRUE)\n\t\t\t\t{\n\t\t\t\t\t// We don't need to see this page anymore if we were successful. We want to go\n\t\t\t\t\t//   to the login form and let the user know that they were successful at\n\t\t\t\t\t//   changing their password\n\n\t\t\t\t\turl::redirect(\"login?change_pw_success\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\n\t\t\t// END: Password Change Process\n\n\t\t}\n\t\telseif ($_POST AND isset($_POST[\"action\"]) AND $_POST[\"action\"] == \"resend_confirmation\")\n\t\t{\n\t\t\t// START: Confirmation Email Resend Process\n\n\t\t\t$post = Validation::factory($_POST);\n\n\t\t\t//\tAdd some filters\n\t\t\t$post->pre_filter('trim', TRUE);\n\t\t\t$post->add_callbacks('confirmation_email', array($this,'email_exists_chk'));\n\n\t\t\tif ($post->validate())\n\t\t\t{\n\t\t\t\t$user = ORM::factory('user',$post->confirmation_email);\n\n\t\t\t\tif ($user->loaded)\n\t\t\t\t{\n\t\t\t\t\t// Send Confirmation email\n\t\t\t\t\t$email_sent = $this->_send_email_confirmation($user);\n\n\t\t\t\t\tif ($email_sent)\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_success';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.login_confirmation_sent');\n\t\t\t\t\t\t$success = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t$message = Kohana::lang('ui_main.unable_send_email');\n\t\t\t\t\t\t$success = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// ERROR: User doesn't exist\n\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t$message = Kohana::lang('ui_main.login_email_doesnt_exist');\n\t\t\t\t\t$success = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// repopulate the form fields\n\t\t\t\t$form = arr::overwrite($form, $post->as_array());\n\n\t\t\t\t// populate the error fields, if any\n\t\t\t\t$errors = arr::merge($errors, $post->errors('auth'));\n\t\t\t\t$form_error = TRUE;\n\t\t\t}\n\t\t}\n\n\t\t// Only if we allow OpenID, should we even try this\n\t\tif (Kohana::config('config.allow_openid') == TRUE)\n\t\t{\n\n\t\t\t// START: OpenID Shenanigans\n\n\t\t\t// OpenID Post\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$openid = new OpenID;\n\n\t\t\t\t// Retrieve the Name (if available) and Email\n\t\t\t\t$openid->required = array(\"namePerson\", \"contact/email\");\n\n\t\t\t\tif( ! $openid->mode)\n\t\t\t\t{\n\t\t\t\t\tif(isset($_POST[\"openid_identifier\"]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$openid->identity = $_POST[\"openid_identifier\"];\n\t\t\t\t\t\theader(\"Location: \" . $openid->authUrl());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telseif ($openid->mode == \"cancel\")\n\t\t\t\t{\n\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t$message = \"You have canceled authentication!\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ($openid->validate())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Does User Exist?\n\t\t\t\t\t\t$openid_user = ORM::factory(\"openid\")\n\t\t\t\t\t\t\t->where(\"openid\", $openid->identity)\n\t\t\t\t\t\t\t->find();\n\n\t\t\t\t\t\tif ($openid_user->loaded AND $openid_user->user)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// First log all other sessions out\n\t\t\t\t\t\t\t$auth->logout();\n\n\t\t\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t\t\t$auth->force_login($openid_user->user->username);\n\n\t\t\t\t\t\t\t// Exists Redirect to Dashboard\n\t\t\t\t\t\t\turl::redirect($user->dashboard());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Does this openid have the required email??\n\t\t\t\t\t\t\t$new_openid = $openid->getAttributes();\n\t\t\t\t\t\t\tif ( ! isset($new_openid[\"contact/email\"]) OR\n\t\t\t\t\t\t\t\tempty($new_openid[\"contact/email\"]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t\t\t$message = $openid->identity . \" has not been logged in. No Email Address Found.\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Create new User and save OpenID\n\t\t\t\t\t\t\t\t$user = ORM::factory(\"user\");\n\n\t\t\t\t\t\t\t\t// But first... does this email address already exist\n\t\t\t\t\t\t\t\t// in the system?\n\t\t\t\t\t\t\t\tif ($user->email_exists($new_openid[\"contact/email\"]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t\t\t\t$message = $new_openid[\"contact/email\"] . \" is already registered in our system.\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$username = \"user\".time(); // Random User Name from TimeStamp - can be changed later\n\t\t\t\t\t\t\t\t\t$password = text::random(\"alnum\", 16); // Create Random Strong Password\n\n\t\t\t\t\t\t\t\t\t// Name Available?\n\t\t\t\t\t\t\t\t\t$user->name = (isset($new_openid[\"namePerson\"]) AND ! empty($new_openid[\"namePerson\"]))\n\t\t\t\t\t\t\t\t\t\t? $new_openid[\"namePerson\"]\n\t\t\t\t\t\t\t\t\t\t: $username;\n\t\t\t\t\t\t\t\t\t$user->username = $username;\n\t\t\t\t\t\t\t\t\t$user->password = $password;\n\t\t\t\t\t\t\t\t\t$user->email = $new_openid[\"contact/email\"];\n\n\t\t\t\t\t\t\t\t\t// Add New Roles\n\t\t\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'member'));\n\n\t\t\t\t\t\t\t\t\t$user->save();\n\n\t\t\t\t\t\t\t\t\t// Save OpenID and Association\n\t\t\t\t\t\t\t\t\t$openid_user->user_id = $user->id;\n\t\t\t\t\t\t\t\t\t$openid_user->openid = $openid->identity;\n\t\t\t\t\t\t\t\t\t$openid_user->openid_email = $new_openid[\"contact/email\"];\n\t\t\t\t\t\t\t\t\t$openid_user->openid_server = $openid->server;\n\t\t\t\t\t\t\t\t\t$openid_user->openid_date = date(\"Y-m-d H:i:s\");\n\t\t\t\t\t\t\t\t\t$openid_user->save();\n\n\t\t\t\t\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t\t\t\t\t$auth->login($username, $password, TRUE);\n\n\t\t\t\t\t\t\t\t\t// Redirect to Dashboard\n\t\t\t\t\t\t\t\t\turl::redirect($user->dashboard());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$openid_error = TRUE;\n\t\t\t\t\t\t$message_class = 'login_error';\n\t\t\t\t\t\t$message = $openid->identity . \"has not been logged in.\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ErrorException $e)\n\t\t\t{\n\t\t\t\t$openid_error = TRUE;\n\t\t\t\t$message_class = 'login_error';\n\t\t\t\t$message = $e->getMessage();\n\t\t\t}\n\n\t\t\t// END: OpenID Shenanigans\n\n\t\t}\n\n\t\t// Set the little badge under the form informing users that their logins are being managed\n\t\t//   by an external service.\n\t\t$this->template->riverid_information = '';\n\t\tif (kohana::config('riverid.enable') == TRUE)\n\t\t{\n\t\t\t$riverid = new RiverID;\n\t\t\t$this->template->riverid_information = Kohana::lang('ui_main.riverid_information',$riverid->name);\n\t\t\t$this->template->riverid_url = $riverid->url;\n\t\t}\n\n\t\t$this->template->errors = $errors;\n\t\t$this->template->success = $success;\n\t\t$this->template->change_pw_success = $change_pw_success;\n\t\t$this->template->form = $form;\n\t\t$this->template->form_error = $form_error;\n\t\t$this->template->new_confirm_email_form = $new_confirm_email_form;\n\n\t\t// Message to user\n\t\t$this->template->message_class = $message_class;\n\t\t$this->template->message = $message;\n\n\t\t// This just means the user isn't a member or an admin, so they have nowhere to go, but they are logged in.\n\t\t$this->template->insufficient_role = $insufficient_role;\n\n\t\t$this->template->site_name = Kohana::config('settings.site_name');\n\t\t$this->template->site_tagline = Kohana::config('settings.site_tagline');\n\n\t\t// Javascript Header\n\t\t$this->template->js = new View('login/login_js');\n\t\t$this->template->js->action = $action;\n\n\t\t// Header Nav\n\t\t$header_nav = new View('header_nav');\n\t\t$this->template->header_nav = $header_nav;\n\t\t$this->template->header_nav->loggedin_user = FALSE;\n\t\tif ( isset(Auth::instance()->get_user()->id) )\n\t\t{\n\t\t\t// Load User\n\t\t\t$this->template->header_nav->loggedin_role = Auth::instance()->get_user()->dashboard();\n\t\t\t$this->template->header_nav->loggedin_user = Auth::instance()->get_user();\n\t\t}\n\t\t$this->template->header_nav->site_name = Kohana::config('settings.site_name');\n\t}\n\n\t/**\n\t * Confirms user registration\n\t */\n\tpublic function verify()\n\t{\n\t\t$auth = Auth::instance();\n\n\t\t$code = (isset($_GET['c']) AND ! empty($_GET['c'])) ? $_GET['c'] : \"\";\n\t\t$email = (isset($_GET['e']) AND ! empty($_GET['e'])) ? $_GET['e'] : \"\";\n\n\t\t$user = ORM::factory(\"user\")\n\t\t\t->where(\"code\", $code)\n\t\t\t->where(\"email\", $email)\n\t\t\t->where(\"confirmed != 1\")\n\t\t\t->find();\n\n\t\tif ($user->loaded)\n\t\t{\n\t\t\t$user->confirmed = 1;\n\n\t\t\t// Give the user the appropriate roles if the admin doesn't need to verify accounts\n\t\t\t//   and if they don't already have role assigned.\n\t\t\tif (Kohana::config('settings.manually_approve_users') == 0\n\t\t\t\tAND ! $user->has(ORM::factory('role', 'login')))\n\t\t\t{\n\t\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t\t$user->add(ORM::factory('role', 'member'));\n\t\t\t}\n\n\t\t\t$user->save();\n\n\t\t\t// Log all other sessions out so they can log in nicely on the login page\n\t\t\t$auth->logout();\n\n\t\t\t// Redirect to login\n\t\t\turl::redirect(\"login?confirmation_success\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Redirect to Login which will log themin if they are already logged in\n\t\t\turl::redirect(\"login?confirmation_failure\");\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Facebook connect function\n\t */\n\tpublic function facebook()\n\t{\n\t\t$auth = Auth::instance();\n\n\t\t$this->template = \"\";\n\t\t$this->auto_render = FALSE;\n\n\t\t$settings = ORM::factory(\"settings\")->find(1);\n\n\t\t$appid = $settings->facebook_appid;\n\t\t$appsecret = $settings->facebook_appsecret;\n\t\t$next_url = url::site().\"members/login/facebook\";\n\t\t$cancel_url = url::site().\"members/login\";\n\n\t\t// Create our Application instance.\n\t\t$facebook = new Facebook(array(\n\t\t\t'appId'  => $appid,\n\t\t\t'secret' => $appsecret,\n\t\t\t'cookie' => true\n\t\t));\n\n\t\t// Get User ID\n\t\t$fb_user = $facebook->getUser();\n\t\tif ($fb_user)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t    \t// Proceed knowing you have a logged in user who's authenticated.\n\t\t\t\t$new_openid = $facebook->api('/me');\n\n\t\t\t\t// Does User Exist?\n\t\t\t\t$openid_user = ORM::factory(\"openid\")\n\t\t\t\t\t->where(\"openid\", \"facebook_\".$new_openid[\"id\"])\n\t\t\t\t\t->find();\n\n\t\t\t\tif ($openid_user->loaded AND $openid_user->user)\n\t\t\t\t{\n\t\t\t\t\t// First log all other sessions out\n\t\t\t\t\t$auth->logout();\n\n\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t$auth->force_login($openid_user->user->username);\n\n\t\t\t\t\t// Exists Redirect to Dashboard\n\t\t\t\t\turl::redirect($auth->get_user()->dashboard());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Does this login have the required email??\n\t\t\t\t\tif ( ! isset($new_openid[\"email\"]) OR empty($new_openid[\"email\"]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$openid_error = \"User has not been logged in. No Email Address Found.\";\n\n\t\t\t\t\t\t// Redirect back to login\n\t\t\t\t\t\turl::redirect(\"login\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Create new User and save OpenID\n\t\t\t\t\t\t$user = ORM::factory(\"user\");\n\n\t\t\t\t\t\t// But first... does this email address already exist\n\t\t\t\t\t\t// in the system?\n\t\t\t\t\t\tif ($user->email_exists($new_openid[\"email\"]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$openid_error = $new_openid[\"email\"] . \" is already registered in our system.\";\n\n\t\t\t\t\t\t\t// Redirect back to login\n\t\t\t\t\t\t\turl::redirect(\"login\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$username = \"user\".time(); // Random User Name from TimeStamp - can be changed later\n\t\t\t\t\t\t\t$password = text::random(\"alnum\", 16); // Create Random Strong Password\n\n\t\t\t\t\t\t\t// Name Available?\n\t\t\t\t\t\t\t$user->name = (isset($new_openid[\"name\"]) AND ! empty($new_openid[\"name\"]))\n\t\t\t\t\t\t\t\t? $new_openid[\"name\"]\n\t\t\t\t\t\t\t\t: $username;\n\t\t\t\t\t\t\t$user->username = $username;\n\t\t\t\t\t\t\t$user->password = $password;\n\t\t\t\t\t\t\t$user->email = $new_openid[\"email\"];\n\n\t\t\t\t\t\t\t// Add New Roles\n\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t\t\t\t\t$user->add(ORM::factory('role', 'member'));\n\n\t\t\t\t\t\t\t$user->save();\n\n\t\t\t\t\t\t\t// Save OpenID and Association\n\t\t\t\t\t\t\t$openid_user->user_id = $user->id;\n\t\t\t\t\t\t\t$openid_user->openid = \"facebook_\".$new_openid[\"id\"];\n\t\t\t\t\t\t\t$openid_user->openid_email = $new_openid[\"email\"];\n\t\t\t\t\t\t\t$openid_user->openid_server = \"http://www.facebook.com\";\n\t\t\t\t\t\t\t$openid_user->openid_date = date(\"Y-m-d H:i:s\");\n\t\t\t\t\t\t\t$openid_user->save();\n\n\t\t\t\t\t\t\t// Initiate Ushahidi side login + AutoLogin\n\t\t\t\t\t\t\t$auth->login($username, $password, TRUE);\n\n\t\t\t\t\t\t\t// Redirect to Dashboard\n\t\t\t\t\t\t\turl::redirect($auth->get_user()->dashboard());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (FacebookApiException $e)\n\t\t\t{\n\t\t\t\terror_log($e);\n\t\t\t\t$user = null;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$login_url = $facebook->getLoginUrl(\n\t\t\t\tarray(\n\t\t\t\t\t'canvas' => 1,\n\t\t\t\t\t'fbconnect' => 0,\n\t\t\t\t\t'scope' => \"email,publish_stream\",\n\t\t\t\t\t'next' => $next_url,\n\t\t\t\t\t'cancel' => $cancel_url\n\t\t\t\t)\n\t\t\t);\n\n\t\t\turl::redirect($login_url);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if username already exists.\n\t * @param Validation $post $_POST variable with validation rules\n\t */\n\tpublic function username_exists_chk(Validation $post)\n\t{\n\t\t$users = ORM::factory('user');\n\t\t// If add->rules validation found any errors, get me out of here!\n\t\tif (array_key_exists('username', $post->errors()))\n\t\t\treturn;\n\n\t\tif ($users->username_exists($post->username))\n\t\t\t$post->add_error( 'username', 'exists');\n\t}\n\n\t/**\n\t * Checks if email address is associated with an account.\n\t * @param Validation $post $_POST variable with validation rules\n\t */\n\tpublic function email_exists_chk( Validation $post )\n\t{\n\t\t$users = ORM::factory('user');\n\t\tif ($post->action == \"new\")\n\t\t{\n\t\t\tif (array_key_exists('email',$post->errors()))\n\t\t\t\treturn;\n\n\t\t\tif ($users->email_exists( $post->email ) )\n\t\t\t\t$post->add_error('email','exists');\n\t\t}\n\t\telseif($post->action == \"forgot\")\n\t\t{\n\t\t\tif (array_key_exists('resetemail',$post->errors()))\n\t\t\t\treturn;\n\n\t\t\tif ( ! $users->email_exists( $post->resetemail ) )\n\t\t\t\t$post->add_error('resetemail','invalid');\n\t\t}\n\t}\n\n    /**\n     * Create New password upon user request.\n     */\n    private function _new_password($user_id = 0, $password, $token)\n    {\n    \t$auth = Auth::instance();\n\t\t$user = ORM::factory('user',$user_id);\n\t\tif ($user->loaded == true)\n\t\t{\n\t\t\t// Determine Method (RiverID or standard)\n\n\t\t\tif (kohana::config('riverid.enable') == TRUE AND ! empty($user->riverid))\n\t\t\t{\n\t\t\t\t// Use RiverID\n\n\t\t\t\t// We don't really have to save the password locally but if a deployer\n\t\t\t\t//   ever wants to switch back locally, it's nice to have the pw there\n\t\t\t\t$user->password = $password;\n\t\t\t\t$user->save();\n\n\t\t\t\t// Relay the password change back to the RiverID server\n\t\t\t\t$riverid = new RiverID;\n\t\t\t\t$riverid->email = $user->email;\n\t\t\t\t$riverid->token = $token;\n\t\t\t\t$riverid->new_password = $password;\n\t\t\t\tif ($riverid->setpassword() == FALSE)\n\t\t\t\t{\n\t\t\t\t\t// TODO: Something went wrong. Tell the user.\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Use Standard\n\t\t\t\tif($user->check_forgot_password_token($token))\n\t\t\t\t{\n\t\t\t\t\t$user->password = $password;\n\t\t\t\t\t$user->save();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO: Something went wrong, tell the user.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn TRUE;\n\t\t}\n\n\t\t// TODO: User doesn't exist, tell the user (meta, I know).\n\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t * Sends an email confirmation\n\t */\n\tprivate function _send_email_confirmation($user)\n\t{\n\t\t$settings = Kohana::config('settings');\n\n\t\t// Check if we require users to go through this process\n\t\tif ($settings['require_email_confirmation'] == 0)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t$email = $user->email;\n\t\t$code = text::random('alnum', 20);\n\t\t$user->code = $code;\n\t\t$user->save();\n\n\t\t$url = url::site().\"login/verify/?c=\".urlencode($code).\"&e=\".urlencode($email);\n\n\t\t$to = $email;\n\t\t$from = array($settings['site_email'], $settings['site_name']);\n\t\t$subject = $settings['site_name'].' '.Kohana::lang('ui_main.login_signup_confirmation_subject');\n\t\t$message = Kohana::lang('ui_main.login_signup_confirmation_message',\n\t\t\tarray($settings['site_name'], $url));\n\n\t\temail::send($to, $from, $subject, $message, FALSE);\n\n\t\treturn TRUE;\n\t}\n\n\t/**\n\t * Email reset link to the user.\n\t *\n\t * @param the email address of the user requesting a password reset.\n\t * @param the username of the user requesting a password reset.\n\t * @param the new generated password.\n\t *\n\t * @return void.\n\t */\n\tprivate function _email_resetlink( $email, $name, $secret_url )\n\t{\n\t\t$to = $email;\n\t\t$from = array(Kohana::config('settings.site_email'), Kohana::config('settings.site_name'));\n\t\t$subject = Kohana::lang('ui_admin.password_reset_subject');\n\t\t$message = $this->_email_resetlink_message($name, $secret_url);\n\n\t\ttry {\n\t\t\t$recipients = email::send( $to, $from, $subject, $message, FALSE );\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\tKohana::log('warning', Swift_LogContainer::getLog()->dump(true));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treturn TRUE;\n\t}\n\n\t/**\n\t * Generate the email message body that goes out to the user when a password is reset\n\t *\n\t * @param the username of the user requesting a password reset.\n\t * @param the new generated password.\n\t *\n\t * @return void.\n\t */\n\tprivate function _email_resetlink_message( $name, $secret_url )\n\t{\n\t\t$message = Kohana::lang('ui_admin.password_reset_message_line_1').' '.$name.\",\\n\";\n\t\t$message .= Kohana::lang('ui_admin.password_reset_message_line_2').' '.$name.\". \";\n\t\t$message .= Kohana::lang('ui_admin.password_reset_message_line_3').\"\\n\\n\";\n\t\t$message .= $secret_url.\"\\n\\n\";\n\n\t\treturn $message;\n\n\t}\n\n}\n", "<?php defined('SYSPATH') or die('No direct script access.');\n\n/**\n* Default Settings From Database\n*/\n\n// Retrieve Cached Settings\n\n$cache = Cache::instance();\n$subdomain = Kohana::config('settings.subdomain');\n$settings = $cache->get($subdomain.'_settings');\nif ( ! $settings OR ! is_array($settings))\n{ // Cache is Empty so Re-Cache\n\t$settings = Settings_Model::get_array();\n\t$cache->set($subdomain.'_settings', $settings, array('settings'), 60); // 1 Day\n}\n\n// Set Site Language\nKohana::config_set('locale.language', $settings['site_language']);\nush_locale::detect_language();\n\n// Copy everything into kohana config settings.XYZ\nforeach($settings as $key => $setting)\n{\n\tKohana::config_set('settings.'.$key, $setting);\n}\n\n// Set Site Timezone\nif (function_exists('date_default_timezone_set'))\n{\n\t$timezone = $settings['site_timezone'];\n\t// Set default timezone, due to increased validation of date settings\n\t// which cause massive amounts of E_NOTICEs to be generated in PHP 5.2+\n\tdate_default_timezone_set(empty($timezone) ? date_default_timezone_get() : $timezone);\n\tKohana::config_set('settings.site_timezone', $timezone);\n}\n\n// Cache Settings\n$cache_pages = ($settings['cache_pages']) ? TRUE : FALSE;\nKohana::config_set('cache.cache_pages', $cache_pages);\nKohana::config_set('cache.default.lifetime', $settings['cache_pages_lifetime']);\n\n$default_map = $settings['default_map'];\n$map_layer = map::base($default_map);\nif (isset($map_layer->api_url) AND $map_layer->api_url != '')\n{\n\tKohana::config_set('settings.api_url', \n\t\t\"<script type=\\\"text/javascript\\\" src=\\\"\".$map_layer->api_url.\"\\\"></script>\");\n}\n\n// And in case you want to display all maps on one page...\n$api_google = $settings['api_google'];\n$api_live = $settings['api_live'];\nKohana::config_set('settings.api_url_all', \n\t\"<script type=\\\"text/javascript\\\" src=\\\"https://dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=6\\\"></script>\\n\"\n\t.\"<script type=\\\"text/javascript\\\" src=\\\"https://maps.google.com/maps/api/js?v=3.7&amp;sensor=false\\\"></script>\\n\"\n\t. html::script('https://www.openstreetmap.org/openlayers/OpenStreetMap.js')\n);\n\n// Additional Mime Types (KMZ/KML)\nKohana::config_set('mimes.kml', array('text/xml'));\nKohana::config_set('mimes.kmz', array('text/xml'));\n\n// Set 'settings.forgot_password_key' if not set already\nif ( ! Kohana::config('settings.forgot_password_secret'))\n{\n\t$pool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+[]{};:,.?`~';\n\t$key = text::random($pool, 64);\n\tSettings_Model::save_setting('forgot_password_secret', $key);\n\tKohana::config_set('settings.forgot_password_secret', $key);\n}\n", "<?php\n/**\n * Model for users for the Auth Module\n *\n * $Id: user.php 3352 2008-08-18 09:43:56BST atomless $\n *\n * PHP version 5\n * LICENSE: This source file is subject to LGPL license\n * that is available through the world-wide-web at the following URI:\n * http://www.gnu.org/copyleft/lesser.html\n * @author     Ushahidi Team <team@ushahidi.com>\n * @package    Ushahidi - http://source.ushahididev.com\n * @subpackage Models\n * @copyright  Ushahidi - http://www.ushahidi.com\n * @license    http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License (LGPL)\n */\n\nclass User_Model extends Auth_User_Model {\n\n\tprotected $has_many = array('alert', 'comment', 'openid', 'private_message', 'rating');\n\t\n\t/**\n\t * Creates a basic user and assigns to login and member roles\n\t * \n\t * @param   string  email\n\t * @param   string  password\n\t * @param   string  riverid user id\n\t * @return  object  ORM object from saving the user\n\t */\n\tpublic static function create_user($email,$password,$riverid=false,$name=false)\n\t{\n\t\t$user = ORM::factory('user');\n\n\t\t$user->email = $email;\n\t\t$user->username = User_Model::random_username();\n\t\t$user->password = $password;\n\n\t\tif ($name != false)\n\t\t{\n\t\t\t$user->name = $name;\n\t\t}\n\n\t\tif ($riverid != false)\n\t\t{\n\t\t\t$user->riverid = $riverid;\n\t\t}\n\n\t\t// Add New Roles if:\n\t\t//    1. We don't require admin to approve users (will be added when admin approves)\n\t\t//    2. We don't require users to first confirm their email address (will be added\n\t\t//       when user confirms if the admin doesn't have to first approve the user)\n\t\tif (Kohana::config('settings.manually_approve_users') == 0\n\t\t\tAND Kohana::config('settings.require_email_confirmation') == 0)\n\t\t{\n\t\t\t$user->add(ORM::factory('role', 'login'));\n\t\t\t$user->add(ORM::factory('role', 'member'));\n\t\t}\n\n\t\treturn $user->save();\n\t}\n\n\t/**\n\t * Gets the email address of a user\n\t * @return string\n\t */\n\tpublic static function get_email($user_id)\n\t{\n\t\t$user = ORM::factory('user')->find($user_id);\n\t\treturn $user->email;\n\t}\n\n\t/**\n\t * Returns data for a user based on username\n\t * @return object\n\t */\n\tpublic static function get_user_by_username($username)\n\t{\n\t\t$user = ORM::factory('user')->where(array('username'=>$username))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns data for a user based on email\n\t * @return object\n\t */\n\tpublic static function get_user_by_email($email)\n\t{\n\t\t$user = ORM::factory('user')->where(array('email'=>$email))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns data for a user based on user id\n\t * @return object\n\t */\n\tpublic static function get_user_by_id($user_id)\n\t{\n\t\t$user = ORM::factory('user')->where(array('id'=>$user_id))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns data for a user based on river id\n\t * @return object\n\t */\n\tpublic static function get_user_by_river_id($river_id)\n\t{\n\t\t$user = ORM::factory('user')->where(array('riverid'=>$river_id))->find();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns all users with public profiles\n\t * @return object\n\t */\n\tpublic static function get_public_users()\n\t{\n\t\t$users = ORM::factory('user')\n\t\t\t->where(array('public_profile'=>1)) // Only show public profiles\n\t\t\t->notlike(array('username'=>'@')) // We only want to show profiles that don't have email addresses as usernames\n\t\t\t->find_all();\n\t\treturn $users;\n\t}\n\n\t/**\n\t * Custom validation for this model - complements the default validate()\n\t *\n\t * @param   array  array to validate\n\t * @param   Auth   instance of Auth class; used for testing purposes\n\t * @return bool TRUE if validation succeeds, FALSE otherwise\n\t */\n\tpublic static function custom_validate(array & $post, Auth $auth = NULL)\n\t{\n\t\t// Initalize validation\n\t\t$post = Validation::factory($post)\n\t\t\t\t->pre_filter('trim', TRUE);\n\t\t\n\t\tif ($auth === NULL)\n\t\t{\n\t\t\t$auth = new Auth;\n\t\t}\n\n\t\t$post->add_rules('username','required','length[3,100]', 'alpha_numeric');\n\t\t$post->add_rules('name','required','length[3,100]');\n        $post->add_rules('email','required','email','length[4,64]');\n\n\t\t// If user id is not specified, check if the username already exists\n\t\tif (empty($post->user_id))\n\t\t{\n\t\t\t$post->add_callbacks('username', array('User_Model', 'unique_value_exists'));\n\t\t\t$post->add_callbacks('email', array('User_Model', 'unique_value_exists'));\n\t\t}\n\t\t\n\t\t// Make sure we have a value for password length to avoid PHP error for missing length[] function\n\t\t$password_length = Kohana::config('auth.password_length');\n\t\t$password_length = ( ! empty($password_length)) ? $password_length : '1,127';\n\n\t\t// Only check for the password if the user id has been specified and we are passing a pw\n\t\tif (isset($post->user_id) AND isset($post->password))\n\t\t{\n\t\t\t$post->add_rules('password','required', 'alpha_dash', 'length['.$password_length.']');\n\t\t\t$post->add_callbacks('password' ,'User_Model::validate_password');\n\t\t}\n\n\t\t// If Password field is not blank and is being passed\n\t\tif ( isset($post->password) AND\n\t\t\t(! empty($post->password) OR (empty($post->password) AND ! empty($post->password_again))))\n\t\t{\n\t\t\t$post->add_rules('password','required', 'alpha_dash','length['.$password_length.']', 'matches[password_again]');\n\t\t\t$post->add_callbacks('password' ,'User_Model::validate_password');\n\t\t}\n\n\t\t$post->add_rules('role','required','length[3,30]', 'alpha_numeric');\n\t\t$post->add_rules('notify','between[0,1]');\n\n\t\tif ( ! $auth->logged_in('superadmin'))\n\t\t{\n\t\t\t$post->add_callbacks('role', array('User_Model', 'prevent_superadmin_modification'));\n\t\t}\n\n\t\t// Additional validation checks\n\t\tEvent::run('ushahidi_action.user_submit_admin', $post);\n\n\t\t// Return\n\t\treturn $post->validate();\n\t}\n\n\t/**\n\t * Checks if a password is correct\n\t *\n\t * @param   int  user id\n\t * @param   string   password to check\n\t * @return bool TRUE if the password matches, FALSE otherwise\n\t */\n\tpublic static function check_password($user_id,$password,$force_standard_method=FALSE)\n\t{\n\t\t$user = ORM::factory('user',$user_id);\n\n\t\t// RiverID or Standard method?\n\t\tif (kohana::config('riverid.enable') == TRUE\n        \tAND ! empty($user->riverid)\n        \tAND ! $force_standard_method)\n\t\t{\n\t\t\t// RiverID\n\t\t\t$riverid = new RiverID;\n\t\t\t$riverid->email = $user->email;\n\t\t\t$riverid->password = $password;\n\t\t\tif ($riverid->checkpassword() != FALSE)\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO: Maybe return the error message?\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Standard Local\n\t\t\t$auth = Auth::instance();\n\t\t\treturn $auth->check_password($user_id,$password);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the value in the specified field exists in database\n\t */\n\tpublic static function unique_value_exists(Validation $post, $field)\n\t{\n\t\t$exists = (bool) ORM::factory('user')->where($field, $post[$field])->count_all();\n\t\tif ($exists)\n\t\t{\n\t\t\t$post->add_error($field, 'exists');\n\t\t}\n\t}\n\n\t/**\n\t * Ensures that only a superadmin can modify superadmin users, or upgrade a user to superadmin\n\t * @note this assumes the currently logged-in user isn't a superadmin\n\t */\n\tpublic static function prevent_superadmin_modification(Validation $post, $field)\n\t{\n\t\tif ($post[$field] == 'superadmin')\n\t\t{\n\t\t\t$post->add_error($field, 'superadmin_modify');\n\t\t}\n\t}\n\n\tpublic static function validate_password(Validation $post, $field)\n\t{\n\t\t$_is_valid = User_Model::password_rule($post[$field]);\n\t\tif (! $_is_valid)\n\t\t{\n\t\t\t$post->add_error($field,'alpha_dash');\n\t\t}\n\t}\n\n\tpublic static function password_rule($password, $utf8 = FALSE)\n\t{\n\t\treturn ($utf8 === TRUE)\n\t\t\t? (bool) preg_match('/^[-\\pL\\pN#@_]++$/uD', (string) $password)\n\t\t\t: (bool) preg_match('/^[-a-z0-9#@_]++$/iD', (string) $password);\n\t}\n\n\t/*\n\t* Creates a random int value for a username that isn't already represented in the database\n\t*/\n\tpublic function random_username()\n\t{\n\t\twhile ($random = mt_rand(1000,mt_getrandmax()))\n\t\t{\n\t\t\t$find_username = ORM::factory('user')->where('username',$random)->count_all();\n\t\t\tif ($find_username == 0)\n\t\t\t{\n\t\t\t\treturn $random;\n\t\t\t}\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\n\t/**\n\t * Overrides the default delete method for the ORM.\n\t * Deletes roles associated with the user before user is removed from DB.\n\t */\n\tpublic function delete()\n\t{\n\t\t$table_prefix = Kohana::config('database.default.table_prefix');\n\t\t\n\t\t// Remove assigned roles\n\t\t// Have to use db->query() since we don't have an ORM model for roles_users\n\t\t$this->db->query('DELETE FROM `'.$table_prefix.'roles_users` WHERE user_id = ?',$this->id);\n\t\t\n\t\t// Remove assigned badges\n\t\t$this->db->query('DELETE FROM `'.$table_prefix.'badge_users` WHERE user_id = ?',$this->id);\n\n\t\t// Delete alerts\n\t\tORM::factory('alert')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\t\t\n\t\t// Delete user_token\n\t\tORM::factory('user_token')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\t\t\n\t\t// Delete openid\n\t\tORM::factory('openid')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\n\t\t// Delete user_devices\n\t\tORM::factory('user_devices')\n\t\t    ->where('user_id', $this->id)\n\t\t    ->delete_all();\n\t\t\n\t\tparent::delete();\n\t}\n\t\n\t/**\n\t * Check if user has specified permission\n\t * @param $permission String permission name\n\t **/\n\tpublic function has_permission($permission)\n\t{\n\t\t// Special case - superadmin ALWAYS has all permissions\n\t\tif ($this->has(ORM::factory('role','superadmin')))\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t\t\n\t\tforeach ($this->roles as $user_role)\n\t\t{\n\t\t\tif ($user_role->has(ORM::factory('permission',$permission)))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn FALSE;\n\t}\n\t\n\t/**\n\t * Get user's dashboard\n\t */\n\tpublic function dashboard()\n\t{\n\t\tif ($this->has_permission('admin_ui'))\n\t\t\treturn 'admin';\n\t\t\n\t\tif ($this->has_permission('member_ui'))\n\t\t\treturn 'members';\n\t\t\n\t\t// Just in case someone has a login only role\n\t\tif ($this->has(ORM::factory('role','login')))\n\t\t\treturn '';\n\t\t\n\t\t// Send anyone else to login\n\t\treturn 'login';\n\t}\n\t\n\t/**\n\t * Get a new forgotten password challenge token for this user\n\t * @param string $salt Optional salt for token generation (use this)\n\t * @return string\n\t */\n\tpublic function forgot_password_token()\n\t{\n\t\treturn $this->_forgot_password_token();\n\t}\n\n\t/**\n\t * Check to see if forgotten password token is valid\n\t * @param string $token token to check\n\t * @return boolean is token valid\n\t **/\n\tpublic function check_forgot_password_token($token)\n\t{\n\t\t$salt = substr($token, 0, 32);\n\t\treturn $this->_forgot_password_token($salt) == $token;\n\t}\n\n\t/**\n\t * Generate a forgotten password challenge token for this user\n\t * @param string $salt Optional salt for token generation (only use this for checking a token in URL)\n\t * @return string token\n\t */\n\tprivate function _forgot_password_token($salt = FALSE)\n\t{\n\t\t// Secret consists of email and the last_login field.\n\t\t// So as soon as the user logs in again, the reset link expires automatically.\n\t\t$salt = $salt ? $salt : text::random('alnum', 32); // Limited charset to keep it URL friendly\n\t\t$key = Kohana::config('settings.forgot_password_secret');\n\t\treturn $salt . hash_hmac('sha1', $this->last_login . $this->email, $salt . $key);\n\t}\n\n} // End User_Model\n"], "filenames": ["application/controllers/login.php", "application/hooks/2_settings.php", "application/models/user.php"], "buggy_code_start_loc": [323, 62, 362], "buggy_code_end_loc": [875, 62, 362], "fixing_code_start_loc": [323, 63, 363], "fixing_code_end_loc": [870, 72, 398], "type": "CWE-640", "message": "Ushahidi before 2.6.1 has insufficient entropy for forgot-password tokens.", "other": {"cve": {"id": "CVE-2012-5618", "sourceIdentifier": "secalert@redhat.com", "published": "2020-02-04T14:15:11.090", "lastModified": "2020-02-12T15:52:27.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ushahidi before 2.6.1 has insufficient entropy for forgot-password tokens."}, {"lang": "es", "value": "Ushahidi versiones anteriores a 2.6.1, presenta una entrop\u00eda insuficiente para los tokens de contrase\u00f1a olvidada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-640"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ushahidi:ushahidi:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.1", "matchCriteriaId": "406146FD-FD78-425E-8C83-EC8DCD83AA85"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2012/12/04/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ushahidi/Ushahidi_Web/commit/e8c7ecd42818c331db8945d20f8b1865bc6d157e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ushahidi/Ushahidi_Web/commit/e8c7ecd42818c331db8945d20f8b1865bc6d157e"}}