{"buggy_code": ["<?php\n\n/**\n * The Log class provides logging facilities.\n * Usually, a default logger is instantiated at initialization:\n *   <pre>Log::$usuallogger = new Logger('/var/log/php_log', Log::INFO, Log::NEVER);</pre>\nwhich can then be used through the static methods (fail, warn, backtrace, info, message, debug):\n *   <pre>Log::message(\"Fasten seatbelts!\");</pre>\n *\n * The logger can log to two places:\n *   - A log file\n *   - Print as HTML comment \n * The three constructor parameters give (1) the logfile location, (2) the threshold for logging to the logfile and (3) the threshold for logging to the output.   \n *   \n * Instead of a string message, the log methods accept exception objects as well. In this case, the backtrace of the exception will be shown in the log. So you can do:\n *    <pre>\n *    try {\n *        // Something\n *    } catch (Exception $e) {\n *        Log::fail($e);\n *        die(\":-(\");\n *    }\n *    </pre>\n * To get the exception and its trace in the log.\n*/\nclass Log {\n    /** This never happens */\n    const NEVER = 1000;\n    /** Something's extremely wrong */\n    const FAIL = 100;       \n    /** Unusual state */\n    const WARN = 90;\n    /** Informational messages (Logging usually stops a this level) */        \n    const INFO = 50;\n    /** Messages shown to user */\n    const MESSAGE = 40;     \n    /** Output useful in debugging */\n    const DEBUG = 20;\n    /** SQL queries */\n    const SQL = 15;\n    /** Generate a backtrace */\n    const BACKTRACE = 10;  \n    /** Everything goes */\n    const ALL = 0;         \n    \n    static $usuallogger = false; // Assign a logger here so that Log::info(\"Seatbelts fastened.\") works too.\n\n    static function fail($msg) { if (self::$usuallogger) self::$usuallogger->fail($msg); }\n    static function warn($msg) { if (self::$usuallogger)self::$usuallogger->warn($msg); }\n    static function backtrace($msg) { if (self::$usuallogger)self::$usuallogger->backtrace($msg); }\n    static function info($msg) { if (self::$usuallogger)self::$usuallogger->info($msg); }\n    static function message($msg) { if (self::$usuallogger)self::$usuallogger->message($msg); }\n    static function debug($msg) { if (self::$usuallogger)self::$usuallogger->debug($msg); }\n    static function sql($msg) {if (self::$usuallogger) self::$usuallogger->sql($msg); }\n    \n    static function disable() {self::$usuallogger->disable();}\n    static function enable() {self::$usuallogger->enable();}\n    \n    // backtrace function shamelessly ripped off of a php.net comment\n    static function prettybacktrace($backtrace = false) {\n        // Get a backtrace from here if none was given\n        if (!$backtrace) {\n            $backtrace = debug_backtrace();\n            // Ignore the call to this function in the backtrace\n            $backtrace = array_slice($backtrace, 1);\n        }\n\n        $output = \"\";\n        \n        foreach ($backtrace as $bt) {\n            $args = '';\n            if (@is_array($bt['args'])) {\n                foreach ($bt['args'] as $a) {\n                    if (!empty($args)) {\n                        $args .= ', ';\n                    }\n                    switch (gettype($a)) {\n                    case 'integer':\n                    case 'double':\n                        $args .= $a;\n                        break;\n                    case 'string':\n                        $a = htmlspecialchars(substr($a, 0, 64)).((strlen($a) > 64) ? '...' : '');\n                        $args .= \"\\\"$a\\\"\";\n                        break;\n                    case 'array':\n                        $args .= 'Array(#'.count($a).')';\n                        break;\n                    case 'object':\n                        $args .= 'Object('.get_class($a).')';\n                        break;\n                    case 'resource':\n                        $args .= 'Resource('.strstr($a, '#').')';\n                        break;\n                    case 'boolean':\n                        $args .= $a ? 'True' : 'False';\n                        break;\n                    case 'NULL':\n                        $args .= 'NULL';\n                        break;\n                    default:\n                        $args .= 'Unknown($a)';\n                    }\n                }\n            }\n            @$output .= \" === {$bt['class']}{$bt['type']}{$bt['function']}($args) in file '{$bt['file']}' on line {$bt['line']}\\n\";\n        }\n        \n        $output .= \" ### {$_SERVER['REMOTE_ADDR']} requested {$_SERVER['REQUEST_URI']}\\n\";\n        \n        return $output;\n    }\n}\n\nclass Logger {\n\n    /** Write log messages to this file */\n    var $file;\n\n    /** Log messages to file only if they're at least this level of severity */\n    var $loglevel;\n\n    /** echo output in HTML comments from this level */\n    var $echolevel;\n\n    /** Log to FirePHP from this level */\n    var $firelevel;\n\n    var $enabled = true;\n\n    function fail($msg) { $this->log(Log::FAIL, \"FAIL\", $msg); }\n    function warn($msg) { $this->log(Log::WARN, \"WARN\", $msg); }\n    function info($msg) { $this->log(Log::INFO, \"INFO\", $msg); }\n    function message($msg) { $this->log(Log::MESSAGE, \"MESSAGE\", $msg); }\n    function debug($msg) { $this->log(Log::DEBUG, \"DEBUG\", $msg); }\n    function sql($msg) { $this->log(Log::SQL, \"SQL\", $msg); }\n    function backtrace($msg) { $this->log(Log::BACKTRACE, \"BACKTRACE\", $msg); }\n\n    function __construct($file = false, $loglevel = Log::INFO, $echolevel = Log::NEVER, $firelevel = Log::NEVER) {\n        if (is_string($loglevel)) $loglevel = constant(\"Log::$loglevel\");\n        if (is_string($echolevel)) $echolevel = constant(\"Log::$echolevel\");\n        if (is_string($firelevel)) $firelevel = constant(\"Log::$firelevel\");\n\n        $this->loglevel = $loglevel;\n        $this->echolevel = $echolevel;\n        $this->firelevel = $firelevel;\n        $this->file = $file;\n        $this->debug(\"Initialized logging (file: $file, loglevel: $loglevel, echolevel: $echolevel)\");\n    }\n\n    function disable() {\n        $this->enabled = false;\n    }\n\n    function enable() {\n        $this->enabled = true;\n    }\n\n    function log($level, $leveltext, $msg) {\n        // Run only if output will be used\n        if ($level >= min($this->loglevel, $this->echolevel, $this->firelevel) && $this->enabled) {\n            $logmessage = \"\";\n            $backtrace = \"\";\n            $showrequest = false; // Maybe show _REQUEST array\n            // Process exceptions\n            if ($msg instanceof Exception || $msg instanceof Error) {\n                $excmessage = method_exists($msg, 'getDetailMessage') ? $msg->getDetailMessage() : $msg->getMessage();\n                $logmessage = $leveltext.\": \".$excmessage.\"\\n\".Log::prettybacktrace($msg->getTrace());\n                $showrequest = true;\n            } else {\n                $logmessage = $leveltext.\": \". print_r($msg,true).\"\\n\";\n                // Generate a backtrace if it was requested or in severe cases\n                if ($level == Log::BACKTRACE || $level >= Log::FAIL) {\n                    $backtrace = \"\\n\".Log::prettybacktrace();\n                    $showrequest = true;\n                }\n            }\n\n            if (!headers_sent() && $level >= $this->firelevel) {\n                $this->log_firephp($msg,$level);\n            }\n            \n            // Append request variables to log message if so desired\n            if ($showrequest && count($_REQUEST) > 0) $logmessage .= \"REQUEST \".print_r($_REQUEST, true);\n\n            // Write to logfile\n            if ($this->file && $level >= $this->loglevel) {\n                $logfile = fopen($this->file, 'a');\n                if ($logfile) {\n                    fwrite($logfile, date(\"d.m.Y-H:i:s\").\": $logmessage$backtrace\");\n                    fclose($logfile);\n                }\n            }\n\n            // Print message as HTML comment\n            if ($level >= $this->echolevel) {\n                // Some messages contain double dashes which terminate HTML comments, insert zero width space\n                $zeroed = '-\u200b-'; // three chars, one you don't see\n                $esc = str_replace('--', $zeroed, str_replace('--', $zeroed, \"$logmessage$backtrace\")); \n                echo \"<!--\\n\".$esc.\" -->\";\n            }\n        }\n    }\n    \n    function log_firephp($msg, $level) {\n        if (!isset($this->firephp)) {\n            require_once \"lib/FirePHP.class.php\";\n            $this->firephp = FirePHP::getInstance(true);\n            $this->firephp->setOptions(array(\n                'maxObjectDepth' => 5,\n                'maxArrayDepth' => 5,\n                'maxDepth' => 10,\n                'useNativeJsonEncode' => false, // Using native json_encode() lead to recursion warnings when logging traces\n                'includeLineNumbers' => true\n            ));\n        }\n\n        $firebug_level = get(array(\n            Log::FAIL      => FirePHP::ERROR,\n            Log::WARN      => FirePHP::WARN,\n            Log::INFO      => FirePHP::INFO,\n            Log::MESSAGE   => FirePHP::INFO,\n            Log::DEBUG     => FirePHP::LOG,\n            Log::SQL       => FirePHP::DUMP,\n            Log::BACKTRACE => FirePHP::TRACE,\n        ), $level, FirePHP::LOG);\n        $this->firephp->fb($msg, $firebug_level);\n    }\n}\n\n"], "fixing_code": ["<?php\n\n/**\n * The Log class provides logging facilities.\n * Usually, a default logger is instantiated at initialization:\n *   <pre>Log::$usuallogger = new Logger('/var/log/php_log', Log::INFO, Log::NEVER);</pre>\nwhich can then be used through the static methods (fail, warn, backtrace, info, message, debug):\n *   <pre>Log::message(\"Fasten seatbelts!\");</pre>\n *\n * The logger can log to two places:\n *   - A log file\n *   - Print as HTML comment \n * The three constructor parameters give (1) the logfile location, (2) the threshold for logging to the logfile and (3) the threshold for logging to the output.   \n *   \n * Instead of a string message, the log methods accept exception objects as well. In this case, the backtrace of the exception will be shown in the log. So you can do:\n *    <pre>\n *    try {\n *        // Something\n *    } catch (Exception $e) {\n *        Log::fail($e);\n *        die(\":-(\");\n *    }\n *    </pre>\n * To get the exception and its trace in the log.\n*/\nclass Log {\n    /** This never happens */\n    const NEVER = 1000;\n    /** Something's extremely wrong */\n    const FAIL = 100;       \n    /** Unusual state */\n    const WARN = 90;\n    /** Informational messages (Logging usually stops a this level) */        \n    const INFO = 50;\n    /** Messages shown to user */\n    const MESSAGE = 40;     \n    /** Output useful in debugging */\n    const DEBUG = 20;\n    /** SQL queries */\n    const SQL = 15;\n    /** Generate a backtrace */\n    const BACKTRACE = 10;  \n    /** Everything goes */\n    const ALL = 0;         \n    \n    static $usuallogger = false; // Assign a logger here so that Log::info(\"Seatbelts fastened.\") works too.\n\n    static function fail($msg) { if (self::$usuallogger) self::$usuallogger->fail($msg); }\n    static function warn($msg) { if (self::$usuallogger)self::$usuallogger->warn($msg); }\n    static function backtrace($msg) { if (self::$usuallogger)self::$usuallogger->backtrace($msg); }\n    static function info($msg) { if (self::$usuallogger)self::$usuallogger->info($msg); }\n    static function message($msg) { if (self::$usuallogger)self::$usuallogger->message($msg); }\n    static function debug($msg) { if (self::$usuallogger)self::$usuallogger->debug($msg); }\n    static function sql($msg) {if (self::$usuallogger) self::$usuallogger->sql($msg); }\n    \n    static function disable() {self::$usuallogger->disable();}\n    static function enable() {self::$usuallogger->enable();}\n    \n    // backtrace function shamelessly ripped off of a php.net comment\n    static function prettybacktrace($backtrace = false) {\n        // Get a backtrace from here if none was given\n        if (!$backtrace) {\n            $backtrace = debug_backtrace();\n            // Ignore the call to this function in the backtrace\n            $backtrace = array_slice($backtrace, 1);\n        }\n\n        $output = \"\";\n        \n        foreach ($backtrace as $bt) {\n            $args = '';\n            if (@is_array($bt['args'])) {\n                foreach ($bt['args'] as $a) {\n                    if (!empty($args)) {\n                        $args .= ', ';\n                    }\n                    switch (gettype($a)) {\n                    case 'integer':\n                    case 'double':\n                        $args .= $a;\n                        break;\n                    case 'string':\n                        $a = htmlspecialchars(substr($a, 0, 64)).((strlen($a) > 64) ? '...' : '');\n                        $args .= \"\\\"$a\\\"\";\n                        break;\n                    case 'array':\n                        $args .= 'Array(#'.count($a).')';\n                        break;\n                    case 'object':\n                        $args .= 'Object('.get_class($a).')';\n                        break;\n                    case 'resource':\n                        $args .= 'Resource('.strstr($a, '#').')';\n                        break;\n                    case 'boolean':\n                        $args .= $a ? 'True' : 'False';\n                        break;\n                    case 'NULL':\n                        $args .= 'NULL';\n                        break;\n                    default:\n                        $args .= 'Unknown($a)';\n                    }\n                }\n            }\n            @$output .= \" === {$bt['class']}{$bt['type']}{$bt['function']}($args) in file '{$bt['file']}' on line {$bt['line']}\\n\";\n        }\n        \n        $output .= \" ### {$_SERVER['REMOTE_ADDR']} requested {$_SERVER['REQUEST_URI']}\\n\";\n        \n        return $output;\n    }\n}\n\nclass Logger {\n\n    /** Write log messages to this file */\n    var $file;\n\n    /** Log messages to file only if they're at least this level of severity */\n    var $loglevel;\n\n    /** echo output in HTML comments from this level */\n    var $echolevel;\n\n    /** Log to FirePHP from this level */\n    var $firelevel;\n\n    var $enabled = true;\n\n    function fail($msg) { $this->log(Log::FAIL, \"FAIL\", $msg); }\n    function warn($msg) { $this->log(Log::WARN, \"WARN\", $msg); }\n    function info($msg) { $this->log(Log::INFO, \"INFO\", $msg); }\n    function message($msg) { $this->log(Log::MESSAGE, \"MESSAGE\", $msg); }\n    function debug($msg) { $this->log(Log::DEBUG, \"DEBUG\", $msg); }\n    function sql($msg) { $this->log(Log::SQL, \"SQL\", $msg); }\n    function backtrace($msg) { $this->log(Log::BACKTRACE, \"BACKTRACE\", $msg); }\n\n    function __construct($file = false, $loglevel = Log::INFO, $echolevel = Log::NEVER, $firelevel = Log::NEVER) {\n        if (is_string($loglevel)) $loglevel = constant(\"Log::$loglevel\");\n        if (is_string($echolevel)) $echolevel = constant(\"Log::$echolevel\");\n        if (is_string($firelevel)) $firelevel = constant(\"Log::$firelevel\");\n\n        $this->loglevel = $loglevel;\n        $this->echolevel = $echolevel;\n        $this->firelevel = $firelevel;\n        $this->file = $file;\n        $this->debug(\"Initialized logging (file: $file, loglevel: $loglevel, echolevel: $echolevel)\");\n    }\n\n    function disable() {\n        $this->enabled = false;\n    }\n\n    function enable() {\n        $this->enabled = true;\n    }\n\n    function log($level, $leveltext, $msg) {\n        // Run only if output will be used\n        if ($level >= min($this->loglevel, $this->echolevel, $this->firelevel) && $this->enabled) {\n            $logmessage = \"\";\n            $backtrace = \"\";\n            $showrequest = false; // Maybe show _REQUEST array\n            // Process exceptions\n            if ($msg instanceof Exception || $msg instanceof Error) {\n                $excmessage = method_exists($msg, 'getDetailMessage') ? $msg->getDetailMessage() : $msg->getMessage();\n                $logmessage = $leveltext.\": \".$excmessage.\"\\n\".Log::prettybacktrace($msg->getTrace());\n            } else {\n                $logmessage = $leveltext.\": \". print_r($msg,true).\"\\n\";\n                // Generate a backtrace if it was requested or in severe cases\n                if ($level == Log::BACKTRACE || $level >= Log::FAIL) {\n                    $backtrace = \"\\n\".Log::prettybacktrace();\n                }\n            }\n\n            if (!headers_sent() && $level >= $this->firelevel) {\n                $this->log_firephp($msg,$level);\n            }\n            \n            // Append request variables to log message if so desired\n            if ($showrequest && count($_REQUEST) > 0) $logmessage .= \"REQUEST \".print_r($_REQUEST, true);\n\n            // Write to logfile\n            if ($this->file && $level >= $this->loglevel) {\n                $logfile = fopen($this->file, 'a');\n                if ($logfile) {\n                    fwrite($logfile, date(\"d.m.Y-H:i:s\").\": $logmessage$backtrace\");\n                    fclose($logfile);\n                }\n            }\n\n            // Print message as HTML comment\n            if ($level >= $this->echolevel) {\n                // Some messages contain double dashes which terminate HTML comments, insert zero width space\n                $zeroed = '-\u200b-'; // three chars, one you don't see\n                $esc = str_replace('--', $zeroed, str_replace('--', $zeroed, \"$logmessage$backtrace\")); \n                echo \"<!--\\n\".$esc.\" -->\";\n            }\n        }\n    }\n    \n    function log_firephp($msg, $level) {\n        if (!isset($this->firephp)) {\n            require_once \"lib/FirePHP.class.php\";\n            $this->firephp = FirePHP::getInstance(true);\n            $this->firephp->setOptions(array(\n                'maxObjectDepth' => 5,\n                'maxArrayDepth' => 5,\n                'maxDepth' => 10,\n                'useNativeJsonEncode' => false, // Using native json_encode() lead to recursion warnings when logging traces\n                'includeLineNumbers' => true\n            ));\n        }\n\n        $firebug_level = get(array(\n            Log::FAIL      => FirePHP::ERROR,\n            Log::WARN      => FirePHP::WARN,\n            Log::INFO      => FirePHP::INFO,\n            Log::MESSAGE   => FirePHP::INFO,\n            Log::DEBUG     => FirePHP::LOG,\n            Log::SQL       => FirePHP::DUMP,\n            Log::BACKTRACE => FirePHP::TRACE,\n        ), $level, FirePHP::LOG);\n        $this->firephp->fb($msg, $firebug_level);\n    }\n}\n\n"], "filenames": ["lib/log.php"], "buggy_code_start_loc": [169], "buggy_code_end_loc": [176], "fixing_code_start_loc": [168], "fixing_code_end_loc": [173], "type": "CWE-532", "message": "Aquarius CMS through 4.3.5 writes POST and GET parameters (including passwords) to a log file due to an overwriting of configuration parameters under certain circumstances.", "other": {"cve": {"id": "CVE-2019-9734", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-24T15:29:02.200", "lastModified": "2019-07-19T14:15:12.450", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Aquarius CMS through 4.3.5 writes POST and GET parameters (including passwords) to a log file due to an overwriting of configuration parameters under certain circumstances."}, {"lang": "es", "value": "Aquarius CMS hasta la versi\u00f3n 4.3.5 escribe los par\u00e1metros POST y GET (incluidas las contrase\u00f1as) en un archivo de registro debido a la sobrescritura de los par\u00e1metros de configuraci\u00f3n en ciertas circunstancias."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aquaverde:aquarius_cms:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.5", "matchCriteriaId": "FDB53276-2758-4A2C-BE1A-322845F981F9"}]}]}], "references": [{"url": "https://github.com/aquaverde/aquarius-core/commit/d1dfa5b8280388a0b6f2f341f0681522dbea03b0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.tryption.ch/2019/04/19/cve-2019-9734-password-leakage-im-aquarius-cms/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aquaverde/aquarius-core/commit/d1dfa5b8280388a0b6f2f341f0681522dbea03b0"}}