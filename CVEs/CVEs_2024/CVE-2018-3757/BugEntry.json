{"buggy_code": ["// node-pdf\n\nvar Promise = require(\"es6-promise\").Promise;\n\nvar path = require(\"path\");\nvar fs   = require(\"fs\");\nvar util = require(\"util\");\nvar exec = require(\"child_process\").exec;\n\nfunction PDFImage(pdfFilePath, options) {\n  if (!options) options = {};\n\n  this.pdfFilePath = pdfFilePath;\n\n  this.setPdfFileBaseName(options.pdfFileBaseName);\n  this.setConvertOptions(options.convertOptions);\n  this.setConvertExtension(options.convertExtension);\n  this.useGM = options.graphicsMagick || false;\n  this.combinedImage = options.combinedImage || false;\n\n  this.outputDirectory = options.outputDirectory || path.dirname(pdfFilePath);\n}\n\nPDFImage.prototype = {\n  constructGetInfoCommand: function () {\n    return util.format(\n      \"pdfinfo \\\"%s\\\"\",\n      this.pdfFilePath\n    );\n  },\n  parseGetInfoCommandOutput: function (output) {\n    var info = {};\n    output.split(\"\\n\").forEach(function (line) {\n      if (line.match(/^(.*?):[ \\t]*(.*)$/)) {\n        info[RegExp.$1] = RegExp.$2;\n      }\n    });\n    return info;\n  },\n  getInfo: function () {\n    var self = this;\n    var getInfoCommand = this.constructGetInfoCommand();\n    var promise = new Promise(function (resolve, reject) {\n      exec(getInfoCommand, function (err, stdout, stderr) {\n        if (err) {\n          return reject({\n            message: \"Failed to get PDF'S information\",\n            error: err,\n            stdout: stdout,\n            stderr: stderr\n          });\n        }\n        return resolve(self.parseGetInfoCommandOutput(stdout));\n      });\n    });\n    return promise;\n  },\n  numberOfPages: function () {\n    return this.getInfo().then(function (info) {\n      return info[\"Pages\"];\n    });\n  },\n  getOutputImagePathForPage: function (pageNumber) {\n    return path.join(\n      this.outputDirectory,\n      this.pdfFileBaseName + \"-\" + pageNumber + \".\" + this.convertExtension\n    );\n  },\n  getOutputImagePathForFile: function () {\n    return path.join(\n      this.outputDirectory,\n      this.pdfFileBaseName + \".\" + this.convertExtension\n    );\n  },\n  setConvertOptions: function (convertOptions) {\n    this.convertOptions = convertOptions || {};\n  },\n  setPdfFileBaseName: function(pdfFileBaseName) {\n    this.pdfFileBaseName = pdfFileBaseName || path.basename(this.pdfFilePath, \".pdf\");\n  },\n  setConvertExtension: function (convertExtension) {\n    this.convertExtension = convertExtension || \"png\";\n  },\n  constructConvertCommandForPage: function (pageNumber) {\n    var pdfFilePath = this.pdfFilePath;\n    var outputImagePath = this.getOutputImagePathForPage(pageNumber);\n    var convertOptionsString = this.constructConvertOptions();\n    return util.format(\n      \"%s %s\\\"%s[%d]\\\" \\\"%s\\\"\",\n      this.useGM ? \"gm convert\" : \"convert\",\n      convertOptionsString ? convertOptionsString + \" \" : \"\",\n      pdfFilePath, pageNumber, outputImagePath\n    );\n  },\n  constructCombineCommandForFile: function (imagePaths) {\n    return util.format(\n      \"%s -append %s \\\"%s\\\"\",\n      this.useGM ? \"gm convert\" : \"convert\",\n      imagePaths.join(' '),\n      this.getOutputImagePathForFile()\n    );\n  },\n  constructConvertOptions: function () {\n    return Object.keys(this.convertOptions).sort().map(function (optionName) {\n      if (this.convertOptions[optionName] !== null) {\n        return optionName + \" \" + this.convertOptions[optionName];\n      } else {\n        return optionName;\n      }\n    }, this).join(\" \");\n  },\n  combineImages: function(imagePaths) {\n    var pdfImage = this;\n    var combineCommand = pdfImage.constructCombineCommandForFile(imagePaths);\n    return new Promise(function (resolve, reject) {\n      exec(combineCommand, function (err, stdout, stderr) {\n        if (err) {\n          return reject({\n            message: \"Failed to combine images\",\n            error: err,\n            stdout: stdout,\n            stderr: stderr\n          });\n        }\n        exec(\"rm \"+imagePaths.join(' ')); //cleanUp\n        return resolve(pdfImage.getOutputImagePathForFile());\n      });\n    });\n  },\n  convertFile: function () {\n    var pdfImage = this;\n    return new Promise(function (resolve, reject) {\n      pdfImage.numberOfPages().then(function (totalPages) {\n        var convertPromise = new Promise(function (resolve, reject){\n          var imagePaths = [];\n          for (var i = 0; i < totalPages; i++) {\n            pdfImage.convertPage(i).then(function(imagePath){\n              imagePaths.push(imagePath);\n              if (imagePaths.length === parseInt(totalPages)){\n                imagePaths.sort(); //because of asyc pages we have to reSort pages\n                resolve(imagePaths);\n              }\n            }).catch(function(error){\n              reject(error);\n            });\n          }\n        });\n\n        convertPromise.then(function(imagePaths){\n          if (pdfImage.combinedImage){\n            pdfImage.combineImages(imagePaths).then(function(imagePath){\n              resolve(imagePath);\n            });\n          } else {\n            resolve(imagePaths);\n          }\n        }).catch(function(error){\n          reject(error);\n        });\n      });\n    });\n  },\n  convertPage: function (pageNumber) {\n    var pdfFilePath     = this.pdfFilePath;\n    var outputImagePath = this.getOutputImagePathForPage(pageNumber);\n    var convertCommand  = this.constructConvertCommandForPage(pageNumber);\n\n    var promise = new Promise(function (resolve, reject) {\n      function convertPageToImage() {\n        exec(convertCommand, function (err, stdout, stderr) {\n          if (err) {\n            return reject({\n              message: \"Failed to convert page to image\",\n              error: err,\n              stdout: stdout,\n              stderr: stderr\n            });\n          }\n          return resolve(outputImagePath);\n        });\n      }\n\n      fs.stat(outputImagePath, function (err, imageFileStat) {\n        var imageNotExists = err && err.code === \"ENOENT\";\n        if (!imageNotExists && err) {\n          return reject({\n            message: \"Failed to stat image file\",\n            error: err\n          });\n        }\n\n        // convert when (1) image doesn't exits or (2) image exists\n        // but its timestamp is older than pdf's one\n\n        if (imageNotExists) {\n          // (1)\n          convertPageToImage();\n          return;\n        }\n\n        // image exist. check timestamp.\n        fs.stat(pdfFilePath, function (err, pdfFileStat) {\n          if (err) {\n            return reject({\n              message: \"Failed to stat PDF file\",\n              error: err\n            });\n          }\n\n          if (imageFileStat.mtime < pdfFileStat.mtime) {\n            // (2)\n            convertPageToImage();\n            return;\n          }\n\n          return resolve(outputImagePath);\n        });\n      });\n    });\n    return promise;\n  }\n};\n\nexports.PDFImage = PDFImage;\n", "{\n  \"name\": \"pdf-image\",\n  \"version\": \"2.0.0\",\n  \"main\": \"index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mooz/node-pdf-image.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/mooz/node-pdf-image/issues\"\n  },\n  \"homepage\": \"https://github.com/mooz/node-pdf-image#readme\",\n  \"dependencies\": {\n    \"es6-promise\": \"~4.2.4\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"~4.1.2\",\n    \"mocha\": \"~5.1.1\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha tests/*\"\n  }\n}\n", "let expect = require(\"chai\").expect;\nlet fs     = require(\"fs\");\n\nlet PDFImage = require(\"../\").PDFImage;\n\ndescribe(\"PDFImage\", function () {\n  let pdfPath = \"/tmp/test.pdf\";\n  let pdfImage;\n  let generatedFiles = [];\n  this.timeout(7000);\n\n  before(function(done){\n    fs.createReadStream('tests/test.pdf').pipe(fs.createWriteStream(pdfPath));\n    if (fs.existsSync(pdfPath)){\n      done();\n    } else {\n      throw new Error({\n        message: 'File missing at: '+ pdfPath + '. Copy task was not a success'\n      });\n    }\n  });\n\n  beforeEach(function() {\n     pdfImage = new PDFImage(pdfPath)\n  });\n\n  it(\"should have correct basename\", function () {\n    expect(pdfImage.pdfFileBaseName).equal(\"test\");\n  });\n  \n  it(\"should set custom basename\", function() {\n    pdfImage.setPdfFileBaseName('custom-basename');\n    expect(pdfImage.pdfFileBaseName).equal(\"custom-basename\");\n  });\n\n  it(\"should return correct page path\", function () {\n    expect(pdfImage.getOutputImagePathForPage(1))\n      .equal(\"/tmp/test-1.png\");\n    expect(pdfImage.getOutputImagePathForPage(2))\n      .equal(\"/tmp/test-2.png\");\n    expect(pdfImage.getOutputImagePathForPage(1000))\n      .equal(\"/tmp/test-1000.png\");\n    expect(pdfImage.getOutputImagePathForFile())\n      .equal(\"/tmp/test.png\");\n  });\n\n  it(\"should return correct convert command\", function () {\n    expect(pdfImage.constructConvertCommandForPage(1))\n      .equal('convert \"/tmp/test.pdf[1]\" \"/tmp/test-1.png\"');\n  });\n\n  it(\"should return correct convert command to combine images\", function () {\n    expect(pdfImage.constructCombineCommandForFile(['/tmp/test-0.png', '/tmp/test-1.png']))\n      .equal('convert -append /tmp/test-0.png /tmp/test-1.png \"/tmp/test.png\"');\n  });\n\n  it(\"should use gm when you ask it to\", function () {\n    pdfImage = new PDFImage(pdfPath, {graphicsMagick: true});\n    expect(pdfImage.constructConvertCommandForPage(1))\n      .equal('gm convert \"/tmp/test.pdf[1]\" \"/tmp/test-1.png\"');\n  });\n\n  // TODO: Do page updating test\n  it(\"should convert PDF's page to a file with the default extension\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.convertPage(1).then(function (imagePath) {\n        expect(imagePath).equal(\"/tmp/test-1.png\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should convert PDF's page 10 to a file with the default extension\", function () {\n    return new Promise(function(resolve, reject){\n      pdfImage.convertPage(9).then(function (imagePath) {\n        expect(imagePath).equal(\"/tmp/test-9.png\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    })\n  });\n\n  it(\"should convert PDF's page to file with a specified extension\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.setConvertExtension(\"jpeg\");\n      pdfImage.convertPage(1).then(function (imagePath) {\n        expect(imagePath).equal(\"/tmp/test-1.jpeg\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should convert all PDF's pages to files\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.convertFile().then(function (imagePaths) {\n        imagePaths.forEach(function(imagePath){\n          expect(fs.existsSync(imagePath)).to.be.true;\n          generatedFiles.push(imagePath);\n        });\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should convert all PDF's pages to single image\", function () {\n    return new Promise(function(resolve, reject){\n      let pdfImageCombined = new PDFImage(pdfPath, {\n        combinedImage: true,\n      });\n\n      pdfImageCombined.convertFile().then(function (imagePath) {\n        expect(imagePath).to.equal(\"/tmp/test.png\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function (error) {\n        reject(error);\n      });\n    })\n  });\n\n  it(\"should return # of pages\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.numberOfPages().then(function (numberOfPages) {\n        expect(parseInt(numberOfPages)).to.be.equal(10);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should construct convert options correctly\", function () {\n    pdfImage.setConvertOptions({\n      \"-density\": 300,\n      \"-trim\": null\n    });\n    expect(pdfImage.constructConvertOptions()).equal(\"-density 300 -trim\");\n  });\n\n  afterEach(function(done){\n    //cleanUp files generated during test\n    let i = generatedFiles.length;\n    if (i > 0 ){\n      generatedFiles.forEach(function(filepath, index){\n        fs.unlink(filepath, function(err) {\n          i--;\n          if (err) {\n            done(err);\n          } else if (i <= 0) {\n            done();\n          }\n        });\n      });\n      generatedFiles = []; //clear after delete\n    } else {\n      done();\n    }\n  });\n\n  after(function(done){\n    //finaly - remove test.pdf from /tmp/\n    fs.unlink(pdfPath, function(err) {\n      if (err) {\n        done(err);\n      }\n      done();\n    });\n  });\n});\n"], "fixing_code": ["// node-pdf\n\nvar Promise = require(\"es6-promise\").Promise;\n\nvar path = require(\"path\");\nvar fs   = require(\"fs\");\nvar util = require(\"util\");\nvar spawn = require(\"child-process-promise\").spawn;\n\nfunction PDFImage(pdfFilePath, options) {\n  if (!options) options = {};\n\n  this.pdfFilePath = pdfFilePath;\n\n  this.setPdfFileBaseName(options.pdfFileBaseName);\n  this.setConvertOptions(options.convertOptions);\n  this.setConvertExtension(options.convertExtension);\n  this.useGM = options.graphicsMagick || false;\n  this.combinedImage = options.combinedImage || false;\n\n  this.outputDirectory = options.outputDirectory || path.dirname(pdfFilePath);\n}\n\nPDFImage.prototype = {\n  constructGetInfoCommand: function () {\n    return {\n      cmd: \"pdfinfo\",\n      args: [this.pdfFilePath]\n    };\n  },\n  parseGetInfoCommandOutput: function (output) {\n    var info = {};\n    output.split(\"\\n\").forEach(function (line) {\n      if (line.match(/^(.*?):[ \\t]*(.*)$/)) {\n        info[RegExp.$1] = RegExp.$2;\n      }\n    });\n    return info;\n  },\n  getInfo: function () {\n    var self = this;\n    var getInfoCommand = this.constructGetInfoCommand();\n    return new Promise(function (resolve, reject) {\n      spawn(getInfoCommand.cmd, getInfoCommand.args, { capture: [ 'stdout', 'stderr' ]})\n        .then(function (cmdResult) {\n          resolve(self.parseGetInfoCommandOutput(cmdResult.stdout.toString()));\n        }).catch(reject);\n    });\n  },\n  numberOfPages: function () {\n    return this.getInfo().then(function (info) {\n      return info[\"Pages\"];\n    });\n  },\n  getOutputImagePathForPage: function (pageNumber) {\n    return path.join(\n      this.outputDirectory,\n      this.pdfFileBaseName + \"-\" + pageNumber + \".\" + this.convertExtension\n    );\n  },\n  getOutputImagePathForFile: function () {\n    return path.join(\n      this.outputDirectory,\n      this.pdfFileBaseName + \".\" + this.convertExtension\n    );\n  },\n  setConvertOptions: function (convertOptions) {\n    this.convertOptions = convertOptions || {};\n  },\n  setPdfFileBaseName: function(pdfFileBaseName) {\n    this.pdfFileBaseName = pdfFileBaseName || path.basename(this.pdfFilePath, \".pdf\");\n  },\n  setConvertExtension: function (convertExtension) {\n    this.convertExtension = convertExtension || \"png\";\n  },\n  constructConvertCommandForPage: function (pageNumber) {\n    var pdfFilePath = this.pdfFilePath;\n    var outputImagePath = this.getOutputImagePathForPage(pageNumber);\n    var convertOptions = this.constructConvertOptions();\n    var args = [];\n    if (convertOptions) args = convertOptions.slice();\n    args.push(pdfFilePath+\"[\"+pageNumber+\"]\");\n    args.push(outputImagePath);\n\n    return {\n      cmd: this.useGM ? \"gm convert\" : \"convert\",\n      args: args\n    };\n  },\n  constructCombineCommandForFile: function (imagePaths) {\n    var args = imagePaths.slice();\n    args.push(this.getOutputImagePathForFile());\n    args.unshift(\"-append\");\n    return {\n      cmd: this.useGM ? \"gm convert\" : \"convert\",\n      args: args\n    };\n  },\n  constructConvertOptions: function () {\n    var convertOptions = [];\n    Object.keys(this.convertOptions).sort().map(function (optionName) {\n      if (this.convertOptions[optionName] !== null) {\n        convertOptions.push(optionName);\n        convertOptions.push(this.convertOptions[optionName]);\n      } else {\n        convertOptions.push(optionName);\n      }\n    }, this);\n    return convertOptions;\n  },\n  combineImages: function(imagePaths) {\n    var pdfImage = this;\n    var combineCommand = pdfImage.constructCombineCommandForFile(imagePaths);\n    return new Promise(function (resolve, reject) {\n      spawn(combineCommand.cmd, combineCommand.args, { capture: [ 'stdout', 'stderr' ]})\n        .then(function () {\n          spawn(\"rm\", imagePaths); //cleanUp\n          resolve(pdfImage.getOutputImagePathForFile());\n        }).catch(function(error){\n          reject({\n            message: \"Failed to combine images\",\n            error: error.message,\n            stdout: error.stdout,\n            stderr: error.stderr\n          });\n      });\n    });\n  },\n  convertFile: function () {\n    var pdfImage = this;\n    return new Promise(function (resolve, reject) {\n      pdfImage.numberOfPages().then(function (totalPages) {\n        var convertPromise = new Promise(function (resolve, reject){\n          var imagePaths = [];\n          for (var i = 0; i < totalPages; i++) {\n            pdfImage.convertPage(i).then(function(imagePath){\n              imagePaths.push(imagePath);\n              if (imagePaths.length === parseInt(totalPages)){\n                imagePaths.sort(); //because of asyc pages we have to reSort pages\n                resolve(imagePaths);\n              }\n            }).catch(function(error){\n              reject(error);\n            });\n          }\n        });\n\n        convertPromise.then(function(imagePaths){\n          if (pdfImage.combinedImage){\n            pdfImage.combineImages(imagePaths).then(function(imagePath){\n              resolve(imagePath);\n            });\n          } else {\n            resolve(imagePaths);\n          }\n        }).catch(function(error){\n          reject(error);\n        });\n      });\n    });\n  },\n  convertPage: function (pageNumber) {\n    var pdfFilePath     = this.pdfFilePath;\n    var outputImagePath = this.getOutputImagePathForPage(pageNumber);\n    var convertCommand  = this.constructConvertCommandForPage(pageNumber);\n\n    var promise = new Promise(function (resolve, reject) {\n      function convertPageToImage() {\n        return new Promise(function (resolve, reject) {\n          spawn(convertCommand.cmd, convertCommand.args, { capture: [ 'stdout', 'stderr' ]})\n            .then(function () {\n              resolve(outputImagePath);\n            }).catch(function(error){\n            reject({\n              message: \"Failed to convert page to image\",\n              error: error.message,\n              stdout: error.stdout,\n              stderr: error.stderr\n            });\n          });\n        });\n      }\n\n      fs.stat(outputImagePath, function (err, imageFileStat) {\n        var imageNotExists = err && err.code === \"ENOENT\";\n        if (!imageNotExists && err) {\n          return reject({\n            message: \"Failed to stat image file\",\n            error: err\n          });\n        }\n\n        // convert when (1) image doesn't exits or (2) image exists\n        // but its timestamp is older than pdf's one\n\n        if (imageNotExists) {\n          // (1)\n          convertPageToImage().then(function(result){\n            resolve(result);\n          }).catch(reject);\n          return;\n        }\n\n        // image exist. check timestamp.\n        fs.stat(pdfFilePath, function (err, pdfFileStat) {\n          if (err) {\n            return reject({\n              message: \"Failed to stat PDF file\",\n              error: err\n            });\n          }\n\n          if (imageFileStat.mtime < pdfFileStat.mtime) {\n            // (2)\n            convertPageToImage().then(function(result){\n              resolve(result);\n            }).catch(reject);\n          }\n        });\n      });\n    });\n    return promise;\n  }\n};\n\nexports.PDFImage = PDFImage;\n", "{\n  \"name\": \"pdf-image\",\n  \"version\": \"2.0.0\",\n  \"main\": \"index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mooz/node-pdf-image.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/mooz/node-pdf-image/issues\"\n  },\n  \"homepage\": \"https://github.com/mooz/node-pdf-image#readme\",\n  \"dependencies\": {\n    \"es6-promise\": \"~4.2.4\",\n    \"child-process-promise\": \"^2.2.1\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"~4.1.2\",\n    \"mocha\": \"~5.1.1\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha tests/*\"\n  }\n}\n", "let expect = require(\"chai\").expect;\nlet fs     = require(\"fs\");\n\nlet PDFImage = require(\"../\").PDFImage;\n\ndescribe(\"PDFImage\", function () {\n  let pdfPath = \"/tmp/test.pdf\";\n  let pdfImage;\n  let generatedFiles = [];\n  this.timeout(7000);\n\n  before(function(done){\n    fs.createReadStream('tests/test.pdf').pipe(fs.createWriteStream(pdfPath));\n    if (fs.existsSync(pdfPath)){\n      done();\n    } else {\n      throw new Error({\n        message: 'File missing at: '+ pdfPath + '. Copy task was not a success'\n      });\n    }\n  });\n\n  beforeEach(function() {\n     pdfImage = new PDFImage(pdfPath)\n  });\n\n  it(\"should have correct basename\", function () {\n    expect(pdfImage.pdfFileBaseName).equal(\"test\");\n  });\n  \n  it(\"should set custom basename\", function() {\n    pdfImage.setPdfFileBaseName('custom-basename');\n    expect(pdfImage.pdfFileBaseName).equal(\"custom-basename\");\n  });\n\n  it(\"should return correct page path\", function () {\n    expect(pdfImage.getOutputImagePathForPage(1))\n      .equal(\"/tmp/test-1.png\");\n    expect(pdfImage.getOutputImagePathForPage(2))\n      .equal(\"/tmp/test-2.png\");\n    expect(pdfImage.getOutputImagePathForPage(1000))\n      .equal(\"/tmp/test-1000.png\");\n    expect(pdfImage.getOutputImagePathForFile())\n      .equal(\"/tmp/test.png\");\n  });\n\n  it(\"should return correct convert command\", function () {\n    var convertCommand = pdfImage.constructConvertCommandForPage(1);\n    expect(convertCommand.cmd).equal(\"convert\");\n    expect(convertCommand.args.length).equal(2);\n  });\n\n  it(\"should return correct convert command to combine images\", function () {\n    var cmdConfig = pdfImage.constructCombineCommandForFile(['/tmp/test-0.png', '/tmp/test-1.png']);\n    expect(cmdConfig.cmd).equal('convert');\n    expect(cmdConfig.args.length).equal(4);\n  });\n\n  it(\"should use gm when you ask it to\", function () {\n    pdfImage = new PDFImage(pdfPath, {graphicsMagick: true});\n    var cmdConfig = pdfImage.constructConvertCommandForPage(1);\n    expect(cmdConfig.cmd).equal('gm convert');\n    expect(cmdConfig.args.length).equal(2);\n  });\n\n  // TODO: Do page updating test\n  it(\"should convert PDF's page to a file with the default extension\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.convertPage(1).then(function (imagePath) {\n        expect(imagePath).equal(\"/tmp/test-1.png\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should convert PDF's page 10 to a file with the default extension\", function () {\n    return new Promise(function(resolve, reject){\n      pdfImage.convertPage(9).then(function (imagePath) {\n        expect(imagePath).equal(\"/tmp/test-9.png\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    })\n  });\n\n  it(\"should convert PDF's page to file with a specified extension\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.setConvertExtension(\"jpeg\");\n      pdfImage.convertPage(1).then(function (imagePath) {\n        expect(imagePath).equal(\"/tmp/test-1.jpeg\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should convert all PDF's pages to files\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.convertFile().then(function (imagePaths) {\n        imagePaths.forEach(function(imagePath){\n          expect(fs.existsSync(imagePath)).to.be.true;\n          generatedFiles.push(imagePath);\n        });\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should convert all PDF's pages to single image\", function () {\n    return new Promise(function(resolve, reject){\n      let pdfImageCombined = new PDFImage(pdfPath, {\n        combinedImage: true,\n      });\n\n      pdfImageCombined.convertFile().then(function (imagePath) {\n        expect(imagePath).to.equal(\"/tmp/test.png\");\n        expect(fs.existsSync(imagePath)).to.be.true;\n        generatedFiles.push(imagePath);\n        resolve();\n      }).catch(function (error) {\n        reject(error);\n      });\n    })\n  });\n\n  it(\"should return # of pages\", function () {\n    return new Promise(function(resolve, reject) {\n      pdfImage.numberOfPages().then(function (numberOfPages) {\n        expect(parseInt(numberOfPages)).to.be.equal(10);\n        resolve();\n      }).catch(function(err){\n        reject(err);\n      });\n    });\n  });\n\n  it(\"should construct convert options correctly\", function () {\n    pdfImage.setConvertOptions({\n      \"-density\": 300,\n      \"-trim\": null\n    });\n    expect(pdfImage.constructConvertOptions()[0]).equal(\"-density 300\");\n    expect(pdfImage.constructConvertOptions()[1]).equal(\"-trim\");\n  });\n\n  it(\"should convert all PDF's pages with convertOptions\", function () {\n    return new Promise(function(resolve, reject){\n      pdfImage.setConvertOptions({\n        \"-quality\": 100,\n        \"-trim\": null\n      });\n\n      pdfImage.convertFile().then(function (images) {\n        images.forEach(function(image){\n          expect(fs.existsSync(image)).to.be.true;\n        });\n        generatedFiles = images;\n        resolve();\n      }).catch(function (error) {\n        reject(error.message + \" \" + error.stderr);\n      });\n    })\n  });\n\n  afterEach(function(done){\n    //cleanUp files generated during test\n    let i = generatedFiles.length;\n    if (i > 0 ){\n      generatedFiles.forEach(function(filepath, index){\n        fs.unlink(filepath, function(err) {\n          i--;\n          if (err) {\n            done(err);\n          } else if (i <= 0) {\n            done();\n          }\n        });\n      });\n      generatedFiles = []; //clear after delete\n    } else {\n      done();\n    }\n  });\n\n  after(function(done){\n    //finaly - remove test.pdf from /tmp/\n    fs.unlink(pdfPath, function(err) {\n      if (err) {\n        done(err);\n      }\n      done();\n    });\n  });\n});\n"], "filenames": ["index.js", "package.json", "tests/test-main.js"], "buggy_code_start_loc": [8, 14, 48], "buggy_code_end_loc": [217, 15, 152], "fixing_code_start_loc": [8, 14, 48], "fixing_code_end_loc": [219, 16, 175], "type": "CWE-78", "message": "Command injection exists in pdf-image v2.0.0 due to an unescaped string parameter.", "other": {"cve": {"id": "CVE-2018-3757", "sourceIdentifier": "support@hackerone.com", "published": "2018-06-01T19:29:00.393", "lastModified": "2020-03-13T12:37:01.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Command injection exists in pdf-image v2.0.0 due to an unescaped string parameter."}, {"lang": "es", "value": "Existe inyecci\u00f3n de comandos en pdf-image v2.0.0 debido a un par\u00e1metro string no escapado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pdf-image_project:pdf-image:2.0.0:*:*:*:*:node.js:*:*", "matchCriteriaId": "5281ED21-63D3-4A31-B6A3-B8ACA733D4B0"}]}]}], "references": [{"url": "https://github.com/roest01/node-pdf-image/commit/54679496a89738443917608c2bbe2f6e5dd20e83", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/340208", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/roest01/node-pdf-image/commit/54679496a89738443917608c2bbe2f6e5dd20e83"}}