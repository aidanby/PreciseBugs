{"buggy_code": ["/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Support for splitting captures into multiple files with a maximum\n * file size:\n *\n * Copyright (c) 2001\n *\tSeth Webster <swebster@sst.ll.mit.edu>\n */\n\n#ifndef lint\nstatic const char copyright[] _U_ =\n    \"@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\\n\\\nThe Regents of the University of California.  All rights reserved.\\n\";\n#endif\n\n/*\n * tcpdump - dump traffic on a network\n *\n * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.\n * Mercilessly hacked and occasionally improved since then via the\n * combined efforts of Van, Steve McCanne and Craig Leres of LBL.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n/*\n * Mac OS X may ship pcap.h from libpcap 0.6 with a libpcap based on\n * 0.8.  That means it has pcap_findalldevs() but the header doesn't\n * define pcap_if_t, meaning that we can't actually *use* pcap_findalldevs().\n */\n#ifdef HAVE_PCAP_FINDALLDEVS\n#ifndef HAVE_PCAP_IF_T\n#undef HAVE_PCAP_FINDALLDEVS\n#endif\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include <sys/stat.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef HAVE_LIBCRYPTO\n#include <openssl/crypto.h>\n#endif\n\n#ifdef HAVE_GETOPT_LONG\n#include <getopt.h>\n#else\n#include \"getopt_long.h\"\n#endif\n/* Capsicum-specific code requires macros from <net/bpf.h>, which will fail\n * to compile if <pcap.h> has already been included; including the headers\n * in the opposite order works fine.\n */\n#ifdef HAVE_CAPSICUM\n#include <sys/capability.h>\n#include <sys/ioccom.h>\n#include <net/bpf.h>\n#include <libgen.h>\n#endif\t/* HAVE_CAPSICUM */\n#include <pcap.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifndef _WIN32\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <pwd.h>\n#include <grp.h>\n#endif /* _WIN32 */\n\n/* capabilities convenience library */\n/* If a code depends on HAVE_LIBCAP_NG, it depends also on HAVE_CAP_NG_H.\n * If HAVE_CAP_NG_H is not defined, undefine HAVE_LIBCAP_NG.\n * Thus, the later tests are done only on HAVE_LIBCAP_NG.\n */\n#ifdef HAVE_LIBCAP_NG\n#ifdef HAVE_CAP_NG_H\n#include <cap-ng.h>\n#else\n#undef HAVE_LIBCAP_NG\n#endif /* HAVE_CAP_NG_H */\n#endif /* HAVE_LIBCAP_NG */\n\n#include \"netdissect.h\"\n#include \"interface.h\"\n#include \"addrtoname.h\"\n#include \"machdep.h\"\n#include \"setsignal.h\"\n#include \"gmt2local.h\"\n#include \"pcap-missing.h\"\n#include \"ascii_strcasecmp.h\"\n\n#include \"print.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#ifdef SIGINFO\n#define SIGNAL_REQ_INFO SIGINFO\n#elif SIGUSR1\n#define SIGNAL_REQ_INFO SIGUSR1\n#endif\n\nstatic int Bflag;\t\t\t/* buffer size */\nstatic long Cflag;\t\t\t/* rotate dump files after this many bytes */\nstatic int Cflag_count;\t\t\t/* Keep track of which file number we're writing */\nstatic int Dflag;\t\t\t/* list available devices and exit */\n/*\n * This is exported because, in some versions of libpcap, if libpcap\n * is built with optimizer debugging code (which is *NOT* the default\n * configuration!), the library *imports*(!) a variable named dflag,\n * under the expectation that tcpdump is exporting it, to govern\n * how much debugging information to print when optimizing\n * the generated BPF code.\n *\n * This is a horrible hack; newer versions of libpcap don't import\n * dflag but, instead, *if* built with optimizer debugging code,\n * *export* a routine to set that flag.\n */\nint dflag;\t\t\t\t/* print filter code */\nstatic int Gflag;\t\t\t/* rotate dump files after this many seconds */\nstatic int Gflag_count;\t\t\t/* number of files created with Gflag rotation */\nstatic time_t Gflag_time;\t\t/* The last time_t the dump file was rotated. */\nstatic int Lflag;\t\t\t/* list available data link types and exit */\nstatic int Iflag;\t\t\t/* rfmon (monitor) mode */\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic int Jflag;\t\t\t/* list available time stamp types */\n#endif\nstatic int jflag = -1;\t\t\t/* packet time stamp source */\nstatic int pflag;\t\t\t/* don't go promiscuous */\n#ifdef HAVE_PCAP_SETDIRECTION\nstatic int Qflag = -1;\t\t\t/* restrict captured packet by send/receive direction */\n#endif\nstatic int Uflag;\t\t\t/* \"unbuffered\" output of dump files */\nstatic int Wflag;\t\t\t/* recycle output files after this number of files */\nstatic int WflagChars;\nstatic char *zflag = NULL;\t\t/* compress each savefile using a specified command (like gzip or bzip2) */\nstatic int immediate_mode;\n\nstatic int infodelay;\nstatic int infoprint;\n\nchar *program_name;\n\n/* Forwards */\nstatic void error(FORMAT_STRING(const char *), ...) NORETURN PRINTFLIKE(1, 2);\nstatic void warning(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);\nstatic void exit_tcpdump(int) NORETURN;\nstatic RETSIGTYPE cleanup(int);\nstatic RETSIGTYPE child_cleanup(int);\nstatic void print_version(void);\nstatic void print_usage(void);\nstatic void show_tstamp_types_and_exit(pcap_t *, const char *device) NORETURN;\nstatic void show_dlts_and_exit(pcap_t *, const char *device) NORETURN;\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic void show_devices_and_exit (void) NORETURN;\n#endif\n\nstatic void print_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet_and_trunc(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void droproot(const char *, const char *);\n\n#ifdef SIGNAL_REQ_INFO\nRETSIGTYPE requestinfo(int);\n#endif\n\n#if defined(USE_WIN32_MM_TIMER)\n  #include <MMsystem.h>\n  static UINT timer_id;\n  static void CALLBACK verbose_stats_dump(UINT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR);\n#elif defined(HAVE_ALARM)\n  static void verbose_stats_dump(int sig);\n#endif\n\nstatic void info(int);\nstatic u_int packets_captured;\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic const struct tok status_flags[] = {\n#ifdef PCAP_IF_UP\n\t{ PCAP_IF_UP,       \"Up\"       },\n#endif\n#ifdef PCAP_IF_RUNNING\n\t{ PCAP_IF_RUNNING,  \"Running\"  },\n#endif\n\t{ PCAP_IF_LOOPBACK, \"Loopback\" },\n\t{ 0, NULL }\n};\n#endif\n\nstatic pcap_t *pd;\n\nstatic int supports_monitor_mode;\n\nextern int optind;\nextern int opterr;\nextern char *optarg;\n\nstruct dump_info {\n\tchar\t*WFileName;\n\tchar\t*CurrentFileName;\n\tpcap_t\t*pd;\n\tpcap_dumper_t *p;\n#ifdef HAVE_CAPSICUM\n\tint\tdirfd;\n#endif\n};\n\n#if defined(HAVE_PCAP_SET_PARSER_DEBUG)\n/*\n * We have pcap_set_parser_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the parser for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_parser_debug(int);\n#elif defined(HAVE_PCAP_DEBUG) || defined(HAVE_YYDEBUG)\n/*\n * We don't have pcap_set_parser_debug() in libpcap, but we do have\n * pcap_debug or yydebug.  Make a local version of pcap_set_parser_debug()\n * to set the flag, and define HAVE_PCAP_SET_PARSER_DEBUG.\n */\nstatic void\npcap_set_parser_debug(int value)\n{\n#ifdef HAVE_PCAP_DEBUG\n\textern int pcap_debug;\n\n\tpcap_debug = value;\n#else /* HAVE_PCAP_DEBUG */\n\textern int yydebug;\n\n\tyydebug = value;\n#endif /* HAVE_PCAP_DEBUG */\n}\n\n#define HAVE_PCAP_SET_PARSER_DEBUG\n#endif\n\n#if defined(HAVE_PCAP_SET_OPTIMIZER_DEBUG)\n/*\n * We have pcap_set_optimizer_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the optimizer for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_optimizer_debug(int);\n#endif\n\n/* VARARGS */\nstatic void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit_tcpdump(1);\n\t/* NOTREACHED */\n}\n\n/* VARARGS */\nstatic void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}\n\nstatic void\nexit_tcpdump(int status)\n{\n\tnd_cleanup();\n\texit(status);\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic void\nshow_tstamp_types_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_tstamp_types;\n\tint *tstamp_types = 0;\n\tconst char *tstamp_type_name;\n\tint i;\n\n\tn_tstamp_types = pcap_list_tstamp_types(pc, &tstamp_types);\n\tif (n_tstamp_types < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\n\tif (n_tstamp_types == 0) {\n\t\tfprintf(stderr, \"Time stamp type cannot be set for %s\\n\",\n\t\t    device);\n\t\texit_tcpdump(0);\n\t}\n\tfprintf(stderr, \"Time stamp types for %s (use option -j to set):\\n\",\n\t    device);\n\tfor (i = 0; i < n_tstamp_types; i++) {\n\t\ttstamp_type_name = pcap_tstamp_type_val_to_name(tstamp_types[i]);\n\t\tif (tstamp_type_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\\n\", tstamp_type_name,\n\t\t\t    pcap_tstamp_type_val_to_description(tstamp_types[i]));\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  %d\\n\", tstamp_types[i]);\n\t\t}\n\t}\n\tpcap_free_tstamp_types(tstamp_types);\n\texit_tcpdump(0);\n}\n#endif\n\nstatic void\nshow_dlts_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_dlts, i;\n\tint *dlts = 0;\n\tconst char *dlt_name;\n\n\tn_dlts = pcap_list_datalinks(pc, &dlts);\n\tif (n_dlts < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\telse if (n_dlts == 0 || !dlts)\n\t\terror(\"No data link types.\");\n\n\t/*\n\t * If the interface is known to support monitor mode, indicate\n\t * whether these are the data link types available when not in\n\t * monitor mode, if -I wasn't specified, or when in monitor mode,\n\t * when -I was specified (the link-layer types available in\n\t * monitor mode might be different from the ones available when\n\t * not in monitor mode).\n\t */\n\tif (supports_monitor_mode)\n\t\t(void) fprintf(stderr, \"Data link types for %s %s (use option -y to set):\\n\",\n\t\t    device,\n\t\t    Iflag ? \"when in monitor mode\" : \"when not in monitor mode\");\n\telse\n\t\t(void) fprintf(stderr, \"Data link types for %s (use option -y to set):\\n\",\n\t\t    device);\n\n\tfor (i = 0; i < n_dlts; i++) {\n\t\tdlt_name = pcap_datalink_val_to_name(dlts[i]);\n\t\tif (dlt_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\", dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlts[i]));\n\n\t\t\t/*\n\t\t\t * OK, does tcpdump handle that type?\n\t\t\t */\n\t\t\tif (!has_printer(dlts[i]))\n\t\t\t\t(void) fprintf(stderr, \" (printing not supported)\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  DLT %d (printing not supported)\\n\",\n\t\t\t    dlts[i]);\n\t\t}\n\t}\n#ifdef HAVE_PCAP_FREE_DATALINKS\n\tpcap_free_datalinks(dlts);\n#endif\n\texit_tcpdump(0);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic void\nshow_devices_and_exit (void)\n{\n\tpcap_if_t *dev, *devlist;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint i;\n\n\tif (pcap_findalldevs(&devlist, ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\tfor (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {\n\t\tprintf(\"%d.%s\", i+1, dev->name);\n\t\tif (dev->description != NULL)\n\t\t\tprintf(\" (%s)\", dev->description);\n\t\tif (dev->flags != 0)\n\t\t\tprintf(\" [%s]\", bittok2str(status_flags, \"none\", dev->flags));\n\t\tprintf(\"\\n\");\n\t}\n\tpcap_freealldevs(devlist);\n\texit_tcpdump(0);\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n/*\n * Short options.\n *\n * Note that there we use all letters for short options except for g, k,\n * o, and P, and those are used by other versions of tcpdump, and we should\n * only use them for the same purposes that the other versions of tcpdump\n * use them:\n *\n * OS X tcpdump uses -g to force non--v output for IP to be on one\n * line, making it more \"g\"repable;\n *\n * OS X tcpdump uses -k to specify that packet comments in pcap-ng files\n * should be printed;\n *\n * OpenBSD tcpdump uses -o to indicate that OS fingerprinting should be done\n * for hosts sending TCP SYN packets;\n *\n * OS X tcpdump uses -P to indicate that -w should write pcap-ng rather\n * than pcap files.\n *\n * OS X tcpdump also uses -Q to specify expressions that match packet\n * metadata, including but not limited to the packet direction.\n * The expression syntax is different from a simple \"in|out|inout\",\n * and those expressions aren't accepted by OS X tcpdump, but the\n * equivalents would be \"in\" = \"dir=in\", \"out\" = \"dir=out\", and\n * \"inout\" = \"dir=in or dir=out\", and the parser could conceivably\n * special-case \"in\", \"out\", and \"inout\" as expressions for backwards\n * compatibility, so all is not (yet) lost.\n */\n\n/*\n * Set up flags that might or might not be supported depending on the\n * version of libpcap we're using.\n */\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n#define B_FLAG\t\t\"B:\"\n#define B_FLAG_USAGE\t\" [ -B size ]\"\n#else /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n#define B_FLAG\n#define B_FLAG_USAGE\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n#ifdef HAVE_PCAP_CREATE\n#define I_FLAG\t\t\"I\"\n#else /* HAVE_PCAP_CREATE */\n#define I_FLAG\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n#define j_FLAG\t\t\"j:\"\n#define j_FLAG_USAGE\t\" [ -j tstamptype ]\"\n#define J_FLAG\t\t\"J\"\n#else /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n#define j_FLAG\n#define j_FLAG_USAGE\n#define J_FLAG\n#endif /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n#define D_FLAG\t\"D\"\n#else\n#define D_FLAG\n#endif\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n#define U_FLAG\t\"U\"\n#else\n#define U_FLAG\n#endif\n\n#ifdef HAVE_PCAP_SETDIRECTION\n#define Q_FLAG \"Q:\"\n#else\n#define Q_FLAG\n#endif\n\n#define SHORTOPTS \"aAb\" B_FLAG \"c:C:d\" D_FLAG \"eE:fF:G:hHi:\" I_FLAG j_FLAG J_FLAG \"KlLm:M:nNOpq\" Q_FLAG \"r:s:StT:u\" U_FLAG \"vV:w:W:xXy:Yz:Z:#\"\n\n/*\n * Long options.\n *\n * We do not currently have long options corresponding to all short\n * options; we should probably pick appropriate option names for them.\n *\n * However, the short options where the number of times the option is\n * specified matters, such as -v and -d and -t, should probably not\n * just map to a long option, as saying\n *\n *  tcpdump --verbose --verbose\n *\n * doesn't make sense; it should be --verbosity={N} or something such\n * as that.\n *\n * For long options with no corresponding short options, we define values\n * outside the range of ASCII graphic characters, make that the last\n * component of the entry for the long option, and have a case for that\n * option in the switch statement.\n */\n#define OPTION_VERSION\t\t128\n#define OPTION_TSTAMP_PRECISION\t129\n#define OPTION_IMMEDIATE_MODE\t130\n\nstatic const struct option longopts[] = {\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t{ \"buffer-size\", required_argument, NULL, 'B' },\n#endif\n\t{ \"list-interfaces\", no_argument, NULL, 'D' },\n\t{ \"help\", no_argument, NULL, 'h' },\n\t{ \"interface\", required_argument, NULL, 'i' },\n#ifdef HAVE_PCAP_CREATE\n\t{ \"monitor-mode\", no_argument, NULL, 'I' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t{ \"time-stamp-type\", required_argument, NULL, 'j' },\n\t{ \"list-time-stamp-types\", no_argument, NULL, 'J' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t{ \"time-stamp-precision\", required_argument, NULL, OPTION_TSTAMP_PRECISION},\n#endif\n\t{ \"dont-verify-checksums\", no_argument, NULL, 'K' },\n\t{ \"list-data-link-types\", no_argument, NULL, 'L' },\n\t{ \"no-optimize\", no_argument, NULL, 'O' },\n\t{ \"no-promiscuous-mode\", no_argument, NULL, 'p' },\n#ifdef HAVE_PCAP_SETDIRECTION\n\t{ \"direction\", required_argument, NULL, 'Q' },\n#endif\n\t{ \"snapshot-length\", required_argument, NULL, 's' },\n\t{ \"absolute-tcp-sequence-numbers\", no_argument, NULL, 'S' },\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t{ \"packet-buffered\", no_argument, NULL, 'U' },\n#endif\n\t{ \"linktype\", required_argument, NULL, 'y' },\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t{ \"immediate-mode\", no_argument, NULL, OPTION_IMMEDIATE_MODE },\n#endif\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t{ \"debug-filter-parser\", no_argument, NULL, 'Y' },\n#endif\n\t{ \"relinquish-privileges\", required_argument, NULL, 'Z' },\n\t{ \"number\", no_argument, NULL, '#' },\n\t{ \"version\", no_argument, NULL, OPTION_VERSION },\n\t{ NULL, 0, NULL, 0 }\n};\n\n#ifndef _WIN32\n/* Drop root privileges and chroot if necessary */\nstatic void\ndroproot(const char *username, const char *chroot_dir)\n{\n\tstruct passwd *pw = NULL;\n\n\tif (chroot_dir && !username) {\n\t\tfprintf(stderr, \"%s: Chroot without dropping root is insecure\\n\",\n\t\t\tprogram_name);\n\t\texit_tcpdump(1);\n\t}\n\n\tpw = getpwnam(username);\n\tif (pw) {\n\t\tif (chroot_dir) {\n\t\t\tif (chroot(chroot_dir) != 0 || chdir (\"/\") != 0) {\n\t\t\t\tfprintf(stderr, \"%s: Couldn't chroot/chdir to '%.64s': %s\\n\",\n\t\t\t\t\tprogram_name, chroot_dir, pcap_strerror(errno));\n\t\t\t\texit_tcpdump(1);\n\t\t\t}\n\t\t}\n#ifdef HAVE_LIBCAP_NG\n\t\t{\n\t\t\tint ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);\n\t\t\tif (ret < 0)\n\t\t\t\terror(\"capng_change_id(): return %d\\n\", ret);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#else\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) != 0 ||\n\t\t    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0) {\n\t\t\tfprintf(stderr, \"%s: Couldn't change to '%.32s' uid=%lu gid=%lu: %s\\n\",\n\t\t\t\tprogram_name, username,\n\t\t\t\t(unsigned long)pw->pw_uid,\n\t\t\t\t(unsigned long)pw->pw_gid,\n\t\t\t\tpcap_strerror(errno));\n\t\t\texit_tcpdump(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#endif /* HAVE_LIBCAP_NG */\n\t}\n\telse {\n\t\tfprintf(stderr, \"%s: Couldn't find user '%.32s'\\n\",\n\t\t\tprogram_name, username);\n\t\texit_tcpdump(1);\n\t}\n#ifdef HAVE_LIBCAP_NG\n\t/* We don't need CAP_SETUID, CAP_SETGID and CAP_SYS_CHROOT any more. */\n\tcapng_updatev(\n\t\tCAPNG_DROP,\n\t\tCAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t\tCAP_SETUID,\n\t\tCAP_SETGID,\n\t\tCAP_SYS_CHROOT,\n\t\t-1);\n\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\n}\n#endif /* _WIN32 */\n\nstatic int\ngetWflagChars(int x)\n{\n\tint c = 0;\n\n\tx -= 1;\n\twhile (x > 0) {\n\t\tc += 1;\n\t\tx /= 10;\n\t}\n\n\treturn c;\n}\n\n\nstatic void\nMakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"Makefilename: malloc\");\n\n        /* Process with strftime if Gflag is set. */\n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          /* Convert Gflag_time to a usable format */\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"MakeTimedFilename: localtime\");\n          }\n\n          /* There's no good way to detect an error in strftime since a return\n           * value of 0 isn't necessarily failure.\n           */\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  /* Report an error if the filename is too large */\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}\n\nstatic char *\nget_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n\n\treturn ret;\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\nstatic int\ntstamp_precision_from_string(const char *precision)\n{\n\tif (strncmp(precision, \"nano\", strlen(\"nano\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_NANO;\n\n\tif (strncmp(precision, \"micro\", strlen(\"micro\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn -EINVAL;\n}\n\nstatic const char *\ntstamp_precision_to_string(int precision)\n{\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\treturn \"micro\";\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\treturn \"nano\";\n\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n#endif\n\n#ifdef HAVE_CAPSICUM\n/*\n * Ensure that, on a dump file's descriptor, we have all the rights\n * necessary to make the standard I/O library work with an fdopen()ed\n * FILE * from that descriptor.\n *\n * A long time ago, in a galaxy far far away, AT&T decided that, instead\n * of providing separate APIs for getting and setting the FD_ flags on a\n * descriptor, getting and setting the O_ flags on a descriptor, and\n * locking files, they'd throw them all into a kitchen-sink fcntl() call\n * along the lines of ioctl(), the fact that ioctl() operations are\n * largely specific to particular character devices but fcntl() operations\n * are either generic to all descriptors or generic to all descriptors for\n * regular files nonwithstanding.\n *\n * The Capsicum people decided that fine-grained control of descriptor\n * operations was required, so that you need to grant permission for\n * reading, writing, seeking, and fcntl-ing.  The latter, courtesy of\n * AT&T's decision, means that \"fcntl-ing\" isn't a thing, but a motley\n * collection of things, so there are *individual* fcntls for which\n * permission needs to be granted.\n *\n * The FreeBSD standard I/O people implemented some optimizations that\n * requires that the standard I/O routines be able to determine whether\n * the descriptor for the FILE * is open append-only or not; as that\n * descriptor could have come from an open() rather than an fopen(),\n * that requires that it be able to do an F_GETFL fcntl() to read\n * the O_ flags.\n *\n * Tcpdump uses ftell() to determine how much data has been written\n * to a file in order to, when used with -C, determine when it's time\n * to rotate capture files.  ftell() therefore needs to do an lseek()\n * to find out the file offset and must, thanks to the aforementioned\n * optimization, also know whether the descriptor is open append-only\n * or not.\n *\n * The net result of all the above is that we need to grant CAP_SEEK,\n * CAP_WRITE, and CAP_FCNTL with the CAP_FCNTL_GETFL subcapability.\n *\n * Perhaps this is the universe's way of saying that either\n *\n *\t1) there needs to be an fopenat() call and a pcap_dump_openat() call\n *\t   using it, so that Capsicum-capable tcpdump wouldn't need to do\n *\t   an fdopen()\n *\n * or\n *\n *\t2) there needs to be a cap_fdopen() call in the FreeBSD standard\n *\t   I/O library that knows what rights are needed by the standard\n *\t   I/O library, based on the open mode, and assigns them, perhaps\n *\t   with an additional argument indicating, for example, whether\n *\t   seeking should be allowed, so that tcpdump doesn't need to know\n *\t   what the standard I/O library happens to require this week.\n */\nstatic void\nset_dumper_capsicum_rights(pcap_dumper_t *p)\n{\n\tint fd = fileno(pcap_dump_file(p));\n\tcap_rights_t rights;\n\n\tcap_rights_init(&rights, CAP_SEEK, CAP_WRITE, CAP_FCNTL);\n\tif (cap_rights_limit(fd, &rights) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor\");\n\t}\n\tif (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor fcntls\");\n\t}\n}\n#endif\n\n/*\n * Copy arg vector into a new buffer, concatenating arguments with spaces.\n */\nstatic char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister u_int len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == NULL)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}\n\n/*\n * On Windows, we need to open the file in binary mode, so that\n * we get all the bytes specified by the size we get from \"fstat()\".\n * On UNIX, that's not necessary.  O_BINARY is defined on Windows;\n * we define it as 0 if it's not defined, so it does nothing.\n */\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\nstatic char *\nread_infile(char *fname)\n{\n\tregister int i, fd, cc;\n\tregister char *cp;\n\tstruct stat buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, cc, (int)buf.st_size);\n\n\tclose(fd);\n\t/* replace \"# comment\" with spaces */\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic long\nparse_interface_number(const char *device)\n{\n\tlong devnum;\n\tchar *end;\n\n\tdevnum = strtol(device, &end, 10);\n\tif (device != end && *end == '\\0') {\n\t\t/*\n\t\t * It's all-numeric, but is it a valid number?\n\t\t */\n\t\tif (devnum <= 0) {\n\t\t\t/*\n\t\t\t * No, it's not an ordinal.\n\t\t\t */\n\t\t\terror(\"Invalid adapter index\");\n\t\t}\n\t\treturn (devnum);\n\t} else {\n\t\t/*\n\t\t * It's not all-numeric; return -1, so our caller\n\t\t * knows that.\n\t\t */\n\t\treturn (-1);\n\t}\n}\n\nstatic char *\nfind_interface_by_number(long devnum)\n{\n\tpcap_if_t *dev, *devlist;\n\tlong i;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar *device;\n\n\tif (pcap_findalldevs(&devlist, ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\t/*\n\t * Look for the devnum-th entry in the list of devices (1-based).\n\t */\n\tfor (i = 0, dev = devlist; i < devnum-1 && dev != NULL;\n\t    i++, dev = dev->next)\n\t\t;\n\tif (dev == NULL)\n\t\terror(\"Invalid adapter index\");\n\tdevice = strdup(dev->name);\n\tpcap_freealldevs(devlist);\n\treturn (device);\n}\n#endif\n\nstatic pcap_t *\nopen_interface(const char *device, netdissect_options *ndo, char *ebuf)\n{\n\tpcap_t *pc;\n#ifdef HAVE_PCAP_CREATE\n\tint status;\n\tchar *cp;\n#endif\n\n#ifdef HAVE_PCAP_CREATE\n\tpc = pcap_create(device, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (Jflag)\n\t\tshow_tstamp_types_and_exit(pc, device);\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tstatus = pcap_set_tstamp_precision(pc, ndo->ndo_tstamp_precision);\n\tif (status != 0)\n\t\terror(\"%s: Can't set %ssecond time stamp precision: %s\",\n\t\t\tdevice,\n\t\t\ttstamp_precision_to_string(ndo->ndo_tstamp_precision),\n\t\t\tpcap_statustostr(status));\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\tif (immediate_mode) {\n\t\tstatus = pcap_set_immediate_mode(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set immediate mode: %s\",\n\t\t\tdevice,\n\t\t\tpcap_statustostr(status));\n\t}\n#endif\n\t/*\n\t * Is this an interface that supports monitor mode?\n\t */\n\tif (pcap_can_set_rfmon(pc) == 1)\n\t\tsupports_monitor_mode = 1;\n\telse\n\t\tsupports_monitor_mode = 0;\n\tstatus = pcap_set_snaplen(pc, ndo->ndo_snaplen);\n\tif (status != 0)\n\t\terror(\"%s: Can't set snapshot length: %s\",\n\t\t    device, pcap_statustostr(status));\n\tstatus = pcap_set_promisc(pc, !pflag);\n\tif (status != 0)\n\t\terror(\"%s: Can't set promiscuous mode: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Iflag) {\n\t\tstatus = pcap_set_rfmon(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set monitor mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pc, 1000);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Bflag != 0) {\n\t\tstatus = pcap_set_buffer_size(pc, Bflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set buffer size: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (jflag != -1) {\n\t\tstatus = pcap_set_tstamp_type(pc, jflag);\n\t\tif (status < 0)\n\t\t\terror(\"%s: Can't set time stamp type: %s\",\n\t\t              device, pcap_statustostr(status));\n\t\telse if (status > 0)\n\t\t\twarning(\"When trying to set timestamp type '%s' on %s: %s\",\n\t\t\t\tpcap_tstamp_type_val_to_name(jflag), device,\n\t\t\t\tpcap_statustostr(status));\n\t}\n#endif\n\tstatus = pcap_activate(pc);\n\tif (status < 0) {\n\t\t/*\n\t\t * pcap_activate() failed.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_ERROR)\n\t\t\terror(\"%s\", cp);\n\t\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Return an error for our caller to handle.\n\t\t\t */\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s: %s\\n(%s)\",\n\t\t\t    device, pcap_statustostr(status), cp);\n\t\t\tpcap_close(pc);\n\t\t\treturn (NULL);\n\t\t} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\\0')\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\terror(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t} else if (status > 0) {\n\t\t/*\n\t\t * pcap_activate() succeeded, but it's warning us\n\t\t * of a problem it had.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_WARNING)\n\t\t\twarning(\"%s\", cp);\n\t\telse if (status == PCAP_WARNING_PROMISC_NOTSUP &&\n\t\t         *cp != '\\0')\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\twarning(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SETDIRECTION\n\tif (Qflag != -1) {\n\t\tstatus = pcap_setdirection(pc, Qflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_setdirection() failed: %s\",\n\t\t\t      device,  pcap_geterr(pc));\n\t\t}\n#endif /* HAVE_PCAP_SETDIRECTION */\n#else /* HAVE_PCAP_CREATE */\n\t*ebuf = '\\0';\n\tpc = pcap_open_live(device, ndo->ndo_snaplen, !pflag, 1000, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n\tif (*ebuf)\n\t\twarning(\"%s\", ebuf);\n#endif /* HAVE_PCAP_CREATE */\n\n\treturn (pc);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tregister int cnt, op, i;\n\tbpf_u_int32 localnet =0 , netmask = 0;\n\tint timezone_offset = 0;\n\tregister char *cp, *infile, *cmdbuf, *device, *RFileName, *VFileName, *WFileName;\n\tpcap_handler callback;\n\tint dlt;\n\tconst char *dlt_name;\n\tstruct bpf_program fcode;\n#ifndef _WIN32\n\tRETSIGTYPE (*oldhandler)(int);\n#endif\n\tstruct dump_info dumpinfo;\n\tu_char *pcap_userdata;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar VFileLine[PATH_MAX + 1];\n\tchar *username = NULL;\n\tchar *chroot_dir = NULL;\n\tchar *ret = NULL;\n\tchar *end;\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tpcap_if_t *devlist;\n\tlong devnum;\n#endif\n\tint status;\n\tFILE *VFile;\n#ifdef HAVE_CAPSICUM\n\tcap_rights_t rights;\n\tint cansandbox;\n#endif\t/* HAVE_CAPSICUM */\n\tint Oflag = 1;\t\t\t/* run filter code optimizer */\n\tint yflag_dlt = -1;\n\tconst char *yflag_dlt_name = NULL;\n\n\tnetdissect_options Ndo;\n\tnetdissect_options *ndo = &Ndo;\n\n\t/*\n\t * Initialize the netdissect code.\n\t */\n\tif (nd_init(ebuf, sizeof ebuf) == -1)\n\t\terror(\"%s\", ebuf);\n\n\tmemset(ndo, 0, sizeof(*ndo));\n\tndo_set_function_pointers(ndo);\n\tndo->ndo_snaplen = DEFAULT_SNAPLEN;\n\n\tcnt = -1;\n\tdevice = NULL;\n\tinfile = NULL;\n\tRFileName = NULL;\n\tVFileName = NULL;\n\tVFile = NULL;\n\tWFileName = NULL;\n\tdlt = -1;\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tndo->program_name = program_name = cp + 1;\n\telse\n\t\tndo->program_name = program_name = argv[0];\n\n#ifdef _WIN32\n\tif (pcap_wsockinit() != 0)\n\t\terror(\"Attempting to initialize Winsock failed\");\n#endif /* _WIN32 */\n\n\t/*\n\t * On platforms where the CPU doesn't support unaligned loads,\n\t * force unaligned accesses to abort with SIGBUS, rather than\n\t * being fixed up (slowly) by the OS kernel; on those platforms,\n\t * misaligned accesses are bugs, and we want tcpdump to crash so\n\t * that the bugs are reported.\n\t */\n\tif (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)\n\t\terror(\"%s\", ebuf);\n\n\twhile (\n\t    (op = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != -1)\n\t\tswitch (op) {\n\n\t\tcase 'a':\n\t\t\t/* compatibility for old -a */\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t\t++ndo->ndo_Aflag;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\t++ndo->ndo_bflag;\n\t\t\tbreak;\n\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t\tcase 'B':\n\t\t\tBflag = atoi(optarg)*1024;\n\t\t\tif (Bflag <= 0)\n\t\t\t\terror(\"invalid packet buffer size %s\", optarg);\n\t\t\tbreak;\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n\t\tcase 'c':\n\t\t\tcnt = atoi(optarg);\n\t\t\tif (cnt <= 0)\n\t\t\t\terror(\"invalid packet count %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tCflag = atoi(optarg) * 1000000;\n\t\t\tif (Cflag <= 0)\n\t\t\t\terror(\"invalid file size %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\t++dflag;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tDflag++;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tLflag++;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\t++ndo->ndo_eflag;\n\t\t\tbreak;\n\n\t\tcase 'E':\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_espsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\t++ndo->ndo_fflag;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'G':\n\t\t\tGflag = atoi(optarg);\n\t\t\tif (Gflag < 0)\n\t\t\t\terror(\"invalid number of seconds %s\", optarg);\n\n                        /* We will create one file initially. */\n                        Gflag_count = 0;\n\n\t\t\t/* Grab the current time for rotation use. */\n\t\t\tif ((Gflag_time = time(NULL)) == (time_t)-1) {\n\t\t\t\terror(\"main: can't get current time: %s\",\n\t\t\t\t    pcap_strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tprint_usage();\n\t\t\texit_tcpdump(0);\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\t++ndo->ndo_Hflag;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_CREATE\n\t\tcase 'I':\n\t\t\t++Iflag;\n\t\t\tbreak;\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t\tcase 'j':\n\t\t\tjflag = pcap_tstamp_type_name_to_val(optarg);\n\t\t\tif (jflag < 0)\n\t\t\t\terror(\"invalid time stamp type %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'J':\n\t\t\tJflag++;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'l':\n#ifdef _WIN32\n\t\t\t/*\n\t\t\t * _IOLBF is the same as _IOFBF in Microsoft's C\n\t\t\t * libraries; the only alternative they offer\n\t\t\t * is _IONBF.\n\t\t\t *\n\t\t\t * XXX - this should really be checking for MSVC++,\n\t\t\t * not _WIN32, if, for example, MinGW has its own\n\t\t\t * C library that is more UNIX-compatible.\n\t\t\t */\n\t\t\tsetvbuf(stdout, NULL, _IONBF, 0);\n#else /* _WIN32 */\n#ifdef HAVE_SETLINEBUF\n\t\t\tsetlinebuf(stdout);\n#else\n\t\t\tsetvbuf(stdout, NULL, _IOLBF, 0);\n#endif\n#endif /* _WIN32 */\n\t\t\tbreak;\n\n\t\tcase 'K':\n\t\t\t++ndo->ndo_Kflag;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (nd_have_smi_support()) {\n\t\t\t\tif (nd_load_smi_module(optarg, ebuf, sizeof ebuf) == -1)\n\t\t\t\t\terror(\"%s\", ebuf);\n\t\t\t} else {\n\t\t\t\t(void)fprintf(stderr, \"%s: ignoring option `-m %s' \",\n\t\t\t\t\t      program_name, optarg);\n\t\t\t\t(void)fprintf(stderr, \"(no libsmi support)\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\t/* TCP-MD5 shared secret */\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_sigsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\t++ndo->ndo_nflag;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\t++ndo->ndo_Nflag;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tOflag = 0;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t++pflag;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\t++ndo->ndo_qflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SETDIRECTION\n\t\tcase 'Q':\n\t\t\tif (ascii_strcasecmp(optarg, \"in\") == 0)\n\t\t\t\tQflag = PCAP_D_IN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"out\") == 0)\n\t\t\t\tQflag = PCAP_D_OUT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"inout\") == 0)\n\t\t\t\tQflag = PCAP_D_INOUT;\n\t\t\telse\n\t\t\t\terror(\"unknown capture direction `%s'\", optarg);\n\t\t\tbreak;\n#endif /* HAVE_PCAP_SETDIRECTION */\n\n\t\tcase 'r':\n\t\t\tRFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tndo->ndo_snaplen = strtol(optarg, &end, 0);\n\t\t\tif (optarg == end || *end != '\\0'\n\t\t\t    || ndo->ndo_snaplen < 0 || ndo->ndo_snaplen > MAXIMUM_SNAPLEN)\n\t\t\t\terror(\"invalid snaplen %s\", optarg);\n\t\t\telse if (ndo->ndo_snaplen == 0)\n\t\t\t\tndo->ndo_snaplen = MAXIMUM_SNAPLEN;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t++ndo->ndo_Sflag;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t++ndo->ndo_tflag;\n\t\t\tbreak;\n\n\t\tcase 'T':\n\t\t\tif (ascii_strcasecmp(optarg, \"vat\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VAT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"wb\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_WB;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rpc\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RPC;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtcp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTCP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"snmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_SNMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"cnfp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CNFP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"tftp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_TFTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"aodv\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_AODV;\n\t\t\telse if (ascii_strcasecmp(optarg, \"carp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CARP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"radius\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RADIUS;\n\t\t\telse if (ascii_strcasecmp(optarg, \"zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"vxlan\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VXLAN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm_zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"lmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_LMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"resp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RESP;\n\t\t\telse\n\t\t\t\terror(\"unknown packet type `%s'\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t\t++ndo->ndo_uflag;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tcase 'U':\n\t\t\t++Uflag;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'v':\n\t\t\t++ndo->ndo_vflag;\n\t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tVFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tWFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'W':\n\t\t\tWflag = atoi(optarg);\n\t\t\tif (Wflag <= 0)\n\t\t\t\terror(\"invalid number of output files %s\", optarg);\n\t\t\tWflagChars = getWflagChars(Wflag);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\t++ndo->ndo_xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\t++ndo->ndo_Xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tyflag_dlt_name = optarg;\n\t\t\tyflag_dlt =\n\t\t\t\tpcap_datalink_name_to_val(yflag_dlt_name);\n\t\t\tif (yflag_dlt < 0)\n\t\t\t\terror(\"invalid data link type %s\", yflag_dlt_name);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t\tcase 'Y':\n\t\t\t{\n\t\t\t/* Undocumented flag */\n\t\t\tpcap_set_parser_debug(1);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tcase 'z':\n\t\t\tzflag = optarg;\n\t\t\tbreak;\n\n\t\tcase 'Z':\n\t\t\tusername = optarg;\n\t\t\tbreak;\n\n\t\tcase '#':\n\t\t\tndo->ndo_packet_number = 1;\n\t\t\tbreak;\n\n\t\tcase OPTION_VERSION:\n\t\t\tprint_version();\n\t\t\texit_tcpdump(0);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tcase OPTION_TSTAMP_PRECISION:\n\t\t\tndo->ndo_tstamp_precision = tstamp_precision_from_string(optarg);\n\t\t\tif (ndo->ndo_tstamp_precision < 0)\n\t\t\t\terror(\"unsupported time stamp precision\");\n\t\t\tbreak;\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t\tcase OPTION_IMMEDIATE_MODE:\n\t\t\timmediate_mode = 1;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tprint_usage();\n\t\t\texit_tcpdump(1);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tif (Dflag)\n\t\tshow_devices_and_exit();\n#endif\n\n\tswitch (ndo->ndo_tflag) {\n\n\tcase 0: /* Default */\n\tcase 4: /* Default + Date*/\n\t\ttimezone_offset = gmt2local(0);\n\t\tbreak;\n\n\tcase 1: /* No time stamp */\n\tcase 2: /* Unix timeval style */\n\tcase 3: /* Microseconds since previous packet */\n        case 5: /* Microseconds since first packet */\n\t\tbreak;\n\n\tdefault: /* Not supported */\n\t\terror(\"only -t, -tt, -ttt, -tttt and -ttttt are supported\");\n\t\tbreak;\n\t}\n\n\tif (ndo->ndo_fflag != 0 && (VFileName != NULL || RFileName != NULL))\n\t\terror(\"-f can not be used with -V or -r\");\n\n\tif (VFileName != NULL && RFileName != NULL)\n\t\terror(\"-V and -r are mutually exclusive.\");\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t/*\n\t * If we're printing dissected packets to the standard output\n\t * rather than saving raw packets to a file, and the standard\n\t * output is a terminal, use immediate mode, as the user's\n\t * probably expecting to see packets pop up immediately.\n\t */\n\tif (WFileName == NULL && isatty(1))\n\t\timmediate_mode = 1;\n#endif\n\n#ifdef WITH_CHROOT\n\t/* if run as root, prepare for chrooting */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* future extensibility for cmd-line arguments */\n\t\tif (!chroot_dir)\n\t\t\tchroot_dir = WITH_CHROOT;\n\t}\n#endif\n\n#ifdef WITH_USER\n\t/* if run as root, prepare for dropping root privileges */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* Run with '-Z root' to restore old behaviour */\n\t\tif (!username)\n\t\t\tusername = WITH_USER;\n\t}\n#endif\n\n\tif (RFileName != NULL || VFileName != NULL) {\n\t\t/*\n\t\t * If RFileName is non-null, it's the pathname of a\n\t\t * savefile to read.  If VFileName is non-null, it's\n\t\t * the pathname of a file containing a list of pathnames\n\t\t * (one per line) of savefiles to read.\n\t\t *\n\t\t * In either case, we're reading a savefile, not doing\n\t\t * a live capture.\n\t\t */\n#ifndef _WIN32\n\t\t/*\n\t\t * We don't need network access, so relinquish any set-UID\n\t\t * or set-GID privileges we have (if any).\n\t\t *\n\t\t * We do *not* want set-UID privileges when opening a\n\t\t * trace file, as that might let the user read other\n\t\t * people's trace files (especially if we're set-UID\n\t\t * root).\n\t\t */\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0 )\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n\t\tif (VFileName != NULL) {\n\t\t\tif (VFileName[0] == '-' && VFileName[1] == '\\0')\n\t\t\t\tVFile = stdin;\n\t\t\telse\n\t\t\t\tVFile = fopen(VFileName, \"r\");\n\n\t\t\tif (VFile == NULL)\n\t\t\t\terror(\"Unable to open file: %s\\n\", pcap_strerror(errno));\n\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (!ret)\n\t\t\t\terror(\"Nothing in %s\\n\", VFileName);\n\t\t\tRFileName = VFileLine;\n\t\t}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tpd = pcap_open_offline_with_tstamp_precision(RFileName,\n\t\t    ndo->ndo_tstamp_precision, ebuf);\n#else\n\t\tpd = pcap_open_offline(RFileName, ebuf);\n#endif\n\n\t\tif (pd == NULL)\n\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\tcap_rights_init(&rights, CAP_READ);\n\t\tif (cap_rights_limit(fileno(pcap_file(pd)), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n#endif\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\tif (dlt_name == NULL) {\n\t\t\tfprintf(stderr, \"reading from file %s, link-type %u\\n\",\n\t\t\t    RFileName, dlt);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"reading from file %s, link-type %s (%s)\\n\",\n\t\t\t    RFileName, dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlt));\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're doing a live capture.\n\t\t */\n\t\tif (device == NULL) {\n\t\t\t/*\n\t\t\t * No interface was specified.  Pick one.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\t/*\n\t\t\t * Find the list of interfaces, and pick\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tif (pcap_findalldevs(&devlist, ebuf) >= 0 &&\n\t\t\t    devlist != NULL) {\n\t\t\t\tdevice = strdup(devlist->name);\n\t\t\t\tpcap_freealldevs(devlist);\n\t\t\t}\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * Use whatever interface pcap_lookupdev()\n\t\t\t * chooses.\n\t\t\t */\n\t\t\tdevice = pcap_lookupdev(ebuf);\n#endif\n\t\t\tif (device == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n\t\t}\n\n\t\t/*\n\t\t * Try to open the interface with the specified name.\n\t\t */\n\t\tpd = open_interface(device, ndo, ebuf);\n\t\tif (pd == NULL) {\n\t\t\t/*\n\t\t\t * That failed.  If we can get a list of\n\t\t\t * interfaces, and the interface name\n\t\t\t * is purely numeric, try to use it as\n\t\t\t * a 1-based index in the list of\n\t\t\t * interfaces.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\tdevnum = parse_interface_number(device);\n\t\t\tif (devnum == -1) {\n\t\t\t\t/*\n\t\t\t\t * It's not a number; just report\n\t\t\t\t * the open error and fail.\n\t\t\t\t */\n\t\t\t\terror(\"%s\", ebuf);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, it's a number; try to find the\n\t\t\t * interface with that index, and try\n\t\t\t * to open it.\n\t\t\t *\n\t\t\t * find_interface_by_number() exits if it\n\t\t\t * couldn't be found.\n\t\t\t */\n\t\t\tdevice = find_interface_by_number(devnum);\n\t\t\tpd = open_interface(device, ndo, ebuf);\n\t\t\tif (pd == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * We can't get a list of interfaces; just\n\t\t\t * fail.\n\t\t\t */\n\t\t\terror(\"%s\", ebuf);\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\t\t}\n\n\t\t/*\n\t\t * Let user own process after socket has been opened.\n\t\t */\n#ifndef _WIN32\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0)\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n#if !defined(HAVE_PCAP_CREATE) && defined(_WIN32)\n\t\tif(Bflag != 0)\n\t\t\tif(pcap_setbuff(pd, Bflag)==-1){\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t}\n#endif /* !defined(HAVE_PCAP_CREATE) && defined(_WIN32) */\n\t\tif (Lflag)\n\t\t\tshow_dlts_and_exit(pd, device);\n\t\tif (yflag_dlt >= 0) {\n#ifdef HAVE_PCAP_SET_DATALINK\n\t\t\tif (pcap_set_datalink(pd, yflag_dlt) < 0)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#else\n\t\t\t/*\n\t\t\t * We don't actually support changing the\n\t\t\t * data link type, so we only let them\n\t\t\t * set it to what it already is.\n\t\t\t */\n\t\t\tif (yflag_dlt != pcap_datalink(pd)) {\n\t\t\t\terror(\"%s is not one of the DLTs supported by this device\\n\",\n\t\t\t\t      yflag_dlt_name);\n\t\t\t}\n#endif\n\t\t\t(void)fprintf(stderr, \"%s: data link type %s\\n\",\n\t\t\t\t      program_name, yflag_dlt_name);\n\t\t\t(void)fflush(stderr);\n\t\t}\n\t\ti = pcap_snapshot(pd);\n\t\tif (ndo->ndo_snaplen < i) {\n\t\t\twarning(\"snaplen raised from %d to %d\", ndo->ndo_snaplen, i);\n\t\t\tndo->ndo_snaplen = i;\n\t\t}\n                if(ndo->ndo_fflag != 0) {\n                        if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n                                warning(\"foreign (-f) flag used but: %s\", ebuf);\n                        }\n                }\n\n\t}\n\tif (infile)\n\t\tcmdbuf = read_infile(infile);\n\telse\n\t\tcmdbuf = copy_argv(&argv[optind]);\n\n#ifdef HAVE_PCAP_SET_OPTIMIZER_DEBUG\n\tpcap_set_optimizer_debug(dflag);\n#endif\n\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\tif (dflag) {\n\t\tbpf_dump(&fcode, dflag);\n\t\tpcap_close(pd);\n\t\tfree(cmdbuf);\n\t\tpcap_freecode(&fcode);\n\t\texit_tcpdump(0);\n\t}\n\tinit_print(ndo, localnet, netmask, timezone_offset);\n\n#ifndef _WIN32\n\t(void)setsignal(SIGPIPE, cleanup);\n\t(void)setsignal(SIGTERM, cleanup);\n\t(void)setsignal(SIGINT, cleanup);\n#endif /* _WIN32 */\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n\t(void)setsignal(SIGCHLD, child_cleanup);\n#endif\n\t/* Cooperate with nohup(1) */\n#ifndef _WIN32\n\tif ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)\n\t\t(void)setsignal(SIGHUP, oldhandler);\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\t/*\n\t * If a user name was specified with \"-Z\", attempt to switch to\n\t * that user's UID.  This would probably be used with sudo,\n\t * to allow tcpdump to be run in a special restricted\n\t * account (if you just want to allow users to open capture\n\t * devices, and can't just give users that permission,\n\t * you'd make tcpdump set-UID or set-GID).\n\t *\n\t * Tcpdump doesn't necessarily write only to one savefile;\n\t * the general only way to allow a -Z instance to write to\n\t * savefiles as the user under whose UID it's run, rather\n\t * than as the user specified with -Z, would thus be to switch\n\t * to the original user ID before opening a capture file and\n\t * then switch back to the -Z user ID after opening the savefile.\n\t * Switching to the -Z user ID only after opening the first\n\t * savefile doesn't handle the general case.\n\t */\n\n\tif (getuid() == 0 || geteuid() == 0) {\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Initialize capng */\n\t\tcapng_clear(CAPNG_SELECT_BOTH);\n\t\tif (username) {\n\t\t\tcapng_updatev(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SETUID,\n\t\t\t\tCAP_SETGID,\n\t\t\t\t-1);\n\t\t}\n\t\tif (chroot_dir) {\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SYS_CHROOT\n\t\t\t\t);\n\t\t}\n\n\t\tif (WFileName) {\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_DAC_OVERRIDE\n\t\t\t\t);\n\t\t}\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (username || chroot_dir)\n\t\t\tdroproot(username, chroot_dir);\n\n\t}\n#endif /* _WIN32 */\n\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\tif (RFileName == NULL && VFileName == NULL) {\n\t\tstatic const unsigned long cmds[] = { BIOCGSTATS, BIOCROTZBUF };\n\n\t\t/*\n\t\t * The various libpcap devices use a combination of\n\t\t * read (bpf), ioctl (bpf, netmap), poll (netmap)\n\t\t * so we add the relevant access rights.\n\t\t */\n\t\tcap_rights_init(&rights, CAP_IOCTL, CAP_READ, CAP_EVENT);\n\t\tif (cap_rights_limit(pcap_fileno(pd), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n\t\tif (cap_ioctls_limit(pcap_fileno(pd), cmds,\n\t\t    sizeof(cmds) / sizeof(cmds[0])) < 0 && errno != ENOSYS) {\n\t\t\terror(\"unable to limit ioctls on pcap descriptor\");\n\t\t}\n\t}\n#endif\n\tif (WFileName) {\n\t\tpcap_dumper_t *p;\n\t\t/* Do not exceed the default PATH_MAX for files. */\n\t\tdumpinfo.CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\n\t\tif (dumpinfo.CurrentFileName == NULL)\n\t\t\terror(\"malloc of dumpinfo.CurrentFileName\");\n\n\t\t/* We do not need numbering for dumpfiles if Cflag isn't set. */\n\t\tif (Cflag != 0)\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, WflagChars);\n\t\telse\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, 0);\n\n\t\tp = pcap_dump_open(pd, dumpinfo.CurrentFileName);\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Give up CAP_DAC_OVERRIDE capability.\n\t\t * Only allow it to be restored if the -C or -G flag have been\n\t\t * set since we may need to create more files later on.\n\t\t */\n\t\tcapng_update(\n\t\t\tCAPNG_DROP,\n\t\t\t(Cflag || Gflag ? 0 : CAPNG_PERMITTED)\n\t\t\t\t| CAPNG_EFFECTIVE,\n\t\t\tCAP_DAC_OVERRIDE\n\t\t\t);\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (p == NULL)\n\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\tset_dumper_capsicum_rights(p);\n#endif\n\t\tif (Cflag != 0 || Gflag != 0) {\n#ifdef HAVE_CAPSICUM\n\t\t\tdumpinfo.WFileName = strdup(basename(WFileName));\n\t\t\tif (dumpinfo.WFileName == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tdumpinfo.dirfd = open(dirname(WFileName),\n\t\t\t    O_DIRECTORY | O_RDONLY);\n\t\t\tif (dumpinfo.dirfd < 0) {\n\t\t\t\terror(\"unable to open directory %s\",\n\t\t\t\t    dirname(WFileName));\n\t\t\t}\n\t\t\tcap_rights_init(&rights, CAP_CREATE, CAP_FCNTL,\n\t\t\t    CAP_FTRUNCATE, CAP_LOOKUP, CAP_SEEK, CAP_WRITE);\n\t\t\tif (cap_rights_limit(dumpinfo.dirfd, &rights) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit directory rights\");\n\t\t\t}\n\t\t\tif (cap_fcntls_limit(dumpinfo.dirfd, CAP_FCNTL_GETFL) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit dump descriptor fcntls\");\n\t\t\t}\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdumpinfo.WFileName = WFileName;\n#endif\n\t\t\tcallback = dump_packet_and_trunc;\n\t\t\tdumpinfo.pd = pd;\n\t\t\tdumpinfo.p = p;\n\t\t\tpcap_userdata = (u_char *)&dumpinfo;\n\t\t} else {\n\t\t\tcallback = dump_packet;\n\t\t\tpcap_userdata = (u_char *)p;\n\t\t}\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tif (Uflag)\n\t\t\tpcap_dump_flush(p);\n#endif\n\t} else {\n\t\tdlt = pcap_datalink(pd);\n\t\tndo->ndo_if_printer = get_if_printer(ndo, dlt);\n\t\tcallback = print_packet;\n\t\tpcap_userdata = (u_char *)ndo;\n\t}\n\n#ifdef SIGNAL_REQ_INFO\n\t/*\n\t * We can't get statistics when reading from a file rather\n\t * than capturing from a device.\n\t */\n\tif (RFileName == NULL)\n\t\t(void)setsignal(SIGNAL_REQ_INFO, requestinfo);\n#endif\n\n\tif (ndo->ndo_vflag > 0 && WFileName) {\n\t\t/*\n\t\t * When capturing to a file, \"-v\" means tcpdump should,\n\t\t * every 10 seconds, \"v\"erbosely report the number of\n\t\t * packets captured.\n\t\t */\n#ifdef USE_WIN32_MM_TIMER\n\t\t/* call verbose_stats_dump() each 1000 +/-100msec */\n\t\ttimer_id = timeSetEvent(1000, 100, verbose_stats_dump, 0, TIME_PERIODIC);\n\t\tsetvbuf(stderr, NULL, _IONBF, 0);\n#elif defined(HAVE_ALARM)\n\t\t(void)setsignal(SIGALRM, verbose_stats_dump);\n\t\talarm(1);\n#endif\n\t}\n\n\tif (RFileName == NULL) {\n\t\t/*\n\t\t * Live capture (if -V was specified, we set RFileName\n\t\t * to a file from the -V file).  Print a message to\n\t\t * the standard error on UN*X.\n\t\t */\n\t\tif (!ndo->ndo_vflag && !WFileName) {\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"%s: verbose output suppressed, use -v or -vv for full protocol decode\\n\",\n\t\t\t    program_name);\n\t\t} else\n\t\t\t(void)fprintf(stderr, \"%s: \", program_name);\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\tif (dlt_name == NULL) {\n\t\t\t(void)fprintf(stderr, \"listening on %s, link-type %u, capture size %u bytes\\n\",\n\t\t\t    device, dlt, ndo->ndo_snaplen);\n\t\t} else {\n\t\t\t(void)fprintf(stderr, \"listening on %s, link-type %s (%s), capture size %u bytes\\n\",\n\t\t\t    device, dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlt), ndo->ndo_snaplen);\n\t\t}\n\t\t(void)fflush(stderr);\n\t}\n\n#ifdef HAVE_CAPSICUM\n\tcansandbox = (ndo->ndo_nflag && VFileName == NULL && zflag == NULL);\n\tif (cansandbox && cap_enter() < 0 && errno != ENOSYS)\n\t\terror(\"unable to enter the capability mode\");\n#endif\t/* HAVE_CAPSICUM */\n\n\tdo {\n\t\tstatus = pcap_loop(pd, cnt, callback, pcap_userdata);\n\t\tif (WFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're printing packets.  Flush the printed output,\n\t\t\t * so it doesn't get intermingled with error output.\n\t\t\t */\n\t\t\tif (status == -2) {\n\t\t\t\t/*\n\t\t\t\t * We got interrupted, so perhaps we didn't\n\t\t\t\t * manage to finish a line we were printing.\n\t\t\t\t * Print an extra newline, just in case.\n\t\t\t\t */\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t\t(void)fflush(stdout);\n\t\t}\n                if (status == -2) {\n\t\t\t/*\n\t\t\t * We got interrupted. If we are reading multiple\n\t\t\t * files (via -V) set these so that we stop.\n\t\t\t */\n\t\t\tVFileName = NULL;\n\t\t\tret = NULL;\n\t\t}\n\t\tif (status == -1) {\n\t\t\t/*\n\t\t\t * Error.  Report it.\n\t\t\t */\n\t\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t\t    program_name, pcap_geterr(pd));\n\t\t}\n\t\tif (RFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're doing a live capture.  Report the capture\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tinfo(1);\n\t\t}\n\t\tpcap_close(pd);\n\t\tif (VFileName != NULL) {\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (ret) {\n\t\t\t\tint new_dlt;\n\n\t\t\t\tRFileName = VFileLine;\n\t\t\t\tpd = pcap_open_offline(RFileName, ebuf);\n\t\t\t\tif (pd == NULL)\n\t\t\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\t\t\tcap_rights_init(&rights, CAP_READ);\n\t\t\t\tif (cap_rights_limit(fileno(pcap_file(pd)),\n\t\t\t\t    &rights) < 0 && errno != ENOSYS) {\n\t\t\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t\t\t}\n#endif\n\t\t\t\tnew_dlt = pcap_datalink(pd);\n\t\t\t\tif (new_dlt != dlt) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The new file has a different\n\t\t\t\t\t * link-layer header type from the\n\t\t\t\t\t * previous one.\n\t\t\t\t\t */\n\t\t\t\t\tif (WFileName != NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We're writing raw packets\n\t\t\t\t\t\t * that match the filter to\n\t\t\t\t\t\t * a pcap file.  pcap files\n\t\t\t\t\t\t * don't support multiple\n\t\t\t\t\t\t * different link-layer\n\t\t\t\t\t\t * header types, so we fail\n\t\t\t\t\t\t * here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\terror(\"%s: new dlt does not match original\", RFileName);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We're printing the decoded packets;\n\t\t\t\t\t * switch to the new DLT.\n\t\t\t\t\t *\n\t\t\t\t\t * To do that, we need to change\n\t\t\t\t\t * the printer, change the DLT name,\n\t\t\t\t\t * and recompile the filter with\n\t\t\t\t\t * the new DLT.\n\t\t\t\t\t */\n\t\t\t\t\tdlt = new_dlt;\n\t\t\t\t\tndo->ndo_if_printer = get_if_printer(ndo, dlt);\n\t\t\t\t\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the filter on the new file.\n\t\t\t\t */\n\t\t\t\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\n\t\t\t\t/*\n\t\t\t\t * Report the new file.\n\t\t\t\t */\n\t\t\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\t\t\tif (dlt_name == NULL) {\n\t\t\t\t\tfprintf(stderr, \"reading from file %s, link-type %u\\n\",\n\t\t\t\t\t    RFileName, dlt);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"reading from file %s, link-type %s (%s)\\n\",\n\t\t\t\t\t    RFileName, dlt_name,\n\t\t\t\t\t    pcap_datalink_val_to_description(dlt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (ret != NULL);\n\n\tfree(cmdbuf);\n\tpcap_freecode(&fcode);\n\texit_tcpdump(status == -1 ? 1 : 0);\n}\n\n/* make a clean exit on interrupts */\nstatic RETSIGTYPE\ncleanup(int signo _U_)\n{\n#ifdef USE_WIN32_MM_TIMER\n\tif (timer_id)\n\t\ttimeKillEvent(timer_id);\n\ttimer_id = 0;\n#elif defined(HAVE_ALARM)\n\talarm(0);\n#endif\n\n#ifdef HAVE_PCAP_BREAKLOOP\n\t/*\n\t * We have \"pcap_breakloop()\"; use it, so that we do as little\n\t * as possible in the signal handler (it's probably not safe\n\t * to do anything with standard I/O streams in a signal handler -\n\t * the ANSI C standard doesn't say it is).\n\t */\n\tpcap_breakloop(pd);\n#else\n\t/*\n\t * We don't have \"pcap_breakloop()\"; this isn't safe, but\n\t * it's the best we can do.  Print the summary if we're\n\t * not reading from a savefile - i.e., if we're doing a\n\t * live capture - and exit.\n\t */\n\tif (pd != NULL && pcap_file(pd) == NULL) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t\t(void)fflush(stdout);\n\t\tinfo(1);\n\t}\n\texit_tcpdump(0);\n#endif\n}\n\n/*\n  On windows, we do not use a fork, so we do not care less about\n  waiting a child processes to die\n */\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\nstatic RETSIGTYPE\nchild_cleanup(int signo _U_)\n{\n  wait(NULL);\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ninfo(register int verbose)\n{\n\tstruct pcap_stat stats;\n\n\t/*\n\t * Older versions of libpcap didn't set ps_ifdrop on some\n\t * platforms; initialize it to 0 to handle that.\n\t */\n\tstats.ps_ifdrop = 0;\n\tif (pcap_stats(pd, &stats) < 0) {\n\t\t(void)fprintf(stderr, \"pcap_stats: %s\\n\", pcap_geterr(pd));\n\t\tinfoprint = 0;\n\t\treturn;\n\t}\n\n\tif (!verbose)\n\t\tfprintf(stderr, \"%s: \", program_name);\n\n\t(void)fprintf(stderr, \"%u packet%s captured\", packets_captured,\n\t    PLURAL_SUFFIX(packets_captured));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s received by filter\", stats.ps_recv,\n\t    PLURAL_SUFFIX(stats.ps_recv));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s dropped by kernel\", stats.ps_drop,\n\t    PLURAL_SUFFIX(stats.ps_drop));\n\tif (stats.ps_ifdrop != 0) {\n\t\tif (!verbose)\n\t\t\tfputs(\", \", stderr);\n\t\telse\n\t\t\tputc('\\n', stderr);\n\t\t(void)fprintf(stderr, \"%u packet%s dropped by interface\\n\",\n\t\t    stats.ps_ifdrop, PLURAL_SUFFIX(stats.ps_ifdrop));\n\t} else\n\t\tputc('\\n', stderr);\n\tinfoprint = 0;\n}\n\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n#ifdef HAVE_FORK\n#define fork_subprocess() fork()\n#else\n#define fork_subprocess() vfork()\n#endif\nstatic void\ncompress_savefile(const char *filename)\n{\n\tpid_t child;\n\n\tchild = fork_subprocess();\n\tif (child == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: fork failed: %s\\n\",\n\t\t\tpcap_strerror(errno));\n\t\treturn;\n\t}\n\tif (child != 0) {\n\t\t/* Parent process. */\n\t\treturn;\n\t}\n\n\t/*\n\t * Child process.\n\t * Set to lowest priority so that this doesn't disturb the capture.\n\t */\n#ifdef NZERO\n\tsetpriority(PRIO_PROCESS, 0, NZERO - 1);\n#else\n\tsetpriority(PRIO_PROCESS, 0, 19);\n#endif\n\tif (execlp(zflag, zflag, filename, (char *)NULL) == -1)\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: execlp(%s, %s) failed: %s\\n\",\n\t\t\tzflag,\n\t\t\tfilename,\n\t\t\tpcap_strerror(errno));\n#ifdef HAVE_FORK\n\texit(1);\n#else\n\t_exit(1);\n#endif\n}\n#else  /* HAVE_FORK && HAVE_VFORK */\nstatic void\ncompress_savefile(const char *filename)\n{\n\tfprintf(stderr,\n\t\t\"compress_savefile failed. Functionality not implemented under your system\\n\");\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ndump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\t/*\n\t * XXX - this won't force the file to rotate on the specified time\n\t * boundary, but it will rotate on the first packet received after the\n\t * specified Gflag number of seconds. Note: if a Gflag time boundary\n\t * and a Cflag size boundary coincide, the time rotation will occur\n\t * first thereby cancelling the Cflag boundary (since the file should\n\t * be 0).\n\t */\n\tif (Gflag != 0) {\n\t\t/* Check if it is time to rotate */\n\t\ttime_t t;\n\n\t\t/* Get the current time */\n\t\tif ((t = time(NULL)) == (time_t)-1) {\n\t\t\terror(\"dump_and_trunc_packet: can't get current_time: %s\",\n\t\t\t    pcap_strerror(errno));\n\t\t}\n\n\n\t\t/* If the time is greater than the specified window, rotate */\n\t\tif (t - Gflag_time >= Gflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/* Update the Gflag_time */\n\t\t\tGflag_time = t;\n\t\t\t/* Update Gflag_count */\n\t\t\tGflag_count++;\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user asked for it\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\t/*\n\t\t\t * Check to see if we've exceeded the Wflag (when\n\t\t\t * not using Cflag).\n\t\t\t */\n\t\t\tif (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {\n\t\t\t\t(void)fprintf(stderr, \"Maximum file limit reached: %d\\n\",\n\t\t\t\t    Wflag);\n\t\t\t\tinfo(1);\n\t\t\t\texit_tcpdump(0);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\t/* Allocate space for max filename + \\0. */\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\t/*\n\t\t\t * Gflag was set otherwise we wouldn't be here. Reset the count\n\t\t\t * so multiple files would end with 1,2,3 in the filename.\n\t\t\t * The counting is handled with the -C flow after this.\n\t\t\t */\n\t\t\tCflag_count = 0;\n\n\t\t\t/*\n\t\t\t * This is always the first file in the Cflag\n\t\t\t * rotation: e.g. 0\n\t\t\t * We also don't need numbering if Cflag is not set.\n\t\t\t */\n\t\t\tif (Cflag != 0)\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,\n\t\t\t\t    WflagChars);\n\t\t\telse\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);\n\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd,\n\t\t\t    dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * XXX - this won't prevent capture files from getting\n\t * larger than Cflag - the last packet written to the\n\t * file could put it over Cflag.\n\t */\n\tif (Cflag != 0) {\n\t\tlong size = pcap_dump_ftell(dump_info->p);\n\n\t\tif (size == -1)\n\t\t\terror(\"ftell fails on output file\");\n\t\tif (size > Cflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user\n\t\t\t * asked for it.\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\tCflag_count++;\n\t\t\tif (Wflag > 0) {\n\t\t\t\tif (Cflag_count >= Wflag)\n\t\t\t\t\tCflag_count = 0;\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd, dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\tpcap_dump((u_char *)dump_info->p, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->p);\n#endif\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\ndump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\t++packets_captured;\n\n\t++infodelay;\n\n\tpcap_dump(user, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush((pcap_dumper_t *)user);\n#endif\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\nprint_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\t++packets_captured;\n\n\t++infodelay;\n\n\tpretty_print_packet((netdissect_options *)user, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\n#ifdef _WIN32\n\t/*\n\t * XXX - there should really be libpcap calls to get the version\n\t * number as a string (the string would be generated from #defines\n\t * at run time, so that it's not generated from string constants\n\t * in the library, as, on many UNIX systems, those constants would\n\t * be statically linked into the application executable image, and\n\t * would thus reflect the version of libpcap on the system on\n\t * which the application was *linked*, not the system on which it's\n\t * *running*.\n\t *\n\t * That routine should be documented, unlike the \"version[]\"\n\t * string, so that UNIX vendors providing their own libpcaps\n\t * don't omit it (as a couple of vendors have...).\n\t *\n\t * Packet.dll should perhaps also export a routine to return the\n\t * version number of the Packet.dll code, to supply the\n\t * \"Wpcap_version\" information on Windows.\n\t */\n\tchar WDversion[]=\"current-git.tcpdump.org\";\n#if !defined(HAVE_GENERATED_VERSION)\n\tchar version[]=\"current-git.tcpdump.org\";\n#endif\n\tchar pcap_version[]=\"current-git.tcpdump.org\";\n\tchar Wpcap_version[]=\"3.1\";\n#endif\n\n#ifdef SIGNAL_REQ_INFO\nRETSIGTYPE requestinfo(int signo _U_)\n{\n\tif (infodelay)\n\t\t++infoprint;\n\telse\n\t\tinfo(0);\n}\n#endif\n\n/*\n * Called once each second in verbose mode while dumping to file\n */\n#ifdef USE_WIN32_MM_TIMER\nvoid CALLBACK verbose_stats_dump (UINT timer_id _U_, UINT msg _U_, DWORD_PTR arg _U_,\n\t\t\t\t  DWORD_PTR dw1 _U_, DWORD_PTR dw2 _U_)\n{\n\tif (infodelay == 0)\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n}\n#elif defined(HAVE_ALARM)\nstatic void verbose_stats_dump(int sig _U_)\n{\n\tif (infodelay == 0)\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n\talarm(1);\n}\n#endif\n\nUSES_APPLE_DEPRECATED_API\nstatic void\nprint_version(void)\n{\n\textern char version[];\n#ifndef HAVE_PCAP_LIB_VERSION\n#if defined(_WIN32) || defined(HAVE_PCAP_VERSION)\n\textern char pcap_version[];\n#else /* defined(_WIN32) || defined(HAVE_PCAP_VERSION) */\n\tstatic char pcap_version[] = \"unknown\";\n#endif /* defined(_WIN32) || defined(HAVE_PCAP_VERSION) */\n#endif /* HAVE_PCAP_LIB_VERSION */\n\tconst char *smi_version_string;\n\n#ifdef HAVE_PCAP_LIB_VERSION\n#ifdef _WIN32\n\t(void)fprintf(stderr, \"%s version %s, based on tcpdump version %s\\n\", program_name, WDversion, version);\n#else /* _WIN32 */\n\t(void)fprintf(stderr, \"%s version %s\\n\", program_name, version);\n#endif /* _WIN32 */\n\t(void)fprintf(stderr, \"%s\\n\",pcap_lib_version());\n#else /* HAVE_PCAP_LIB_VERSION */\n#ifdef _WIN32\n\t(void)fprintf(stderr, \"%s version %s, based on tcpdump version %s\\n\", program_name, WDversion, version);\n\t(void)fprintf(stderr, \"WinPcap version %s, based on libpcap version %s\\n\",Wpcap_version, pcap_version);\n#else /* _WIN32 */\n\t(void)fprintf(stderr, \"%s version %s\\n\", program_name, version);\n\t(void)fprintf(stderr, \"libpcap version %s\\n\", pcap_version);\n#endif /* _WIN32 */\n#endif /* HAVE_PCAP_LIB_VERSION */\n\n#if defined(HAVE_LIBCRYPTO) && defined(SSLEAY_VERSION)\n\t(void)fprintf (stderr, \"%s\\n\", SSLeay_version(SSLEAY_VERSION));\n#endif\n\n\tsmi_version_string = nd_smi_version_string();\n\tif (smi_version_string != NULL)\n\t\t(void)fprintf (stderr, \"SMI-library: %s\\n\", smi_version_string);\n\n#if defined(__SANITIZE_ADDRESS__)\n\t(void)fprintf (stderr, \"Compiled with AddressSanitizer/GCC.\\n\");\n#elif defined(__has_feature)\n#  if __has_feature(address_sanitizer)\n\t(void)fprintf (stderr, \"Compiled with AddressSanitizer/CLang.\\n\");\n#  endif\n#endif /* __SANITIZE_ADDRESS__ or __has_feature */\n}\nUSES_APPLE_RST\n\nstatic void\nprint_usage(void)\n{\n\tprint_version();\n\t(void)fprintf(stderr,\n\"Usage: %s [-aAbd\" D_FLAG \"efhH\" I_FLAG J_FLAG \"KlLnNOpqStu\" U_FLAG \"vxX#]\" B_FLAG_USAGE \" [ -c count ]\\n\", program_name);\n\t(void)fprintf(stderr,\n\"\\t\\t[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t[ -i interface ]\" j_FLAG_USAGE \" [ -M secret ] [ --number ]\\n\");\n#ifdef HAVE_PCAP_SETDIRECTION\n\t(void)fprintf(stderr,\n\"\\t\\t[ -Q in|out|inout ]\\n\");\n#endif\n\t(void)fprintf(stderr,\n\"\\t\\t[ -r file ] [ -s snaplen ] \");\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t(void)fprintf(stderr, \"[ --time-stamp-precision precision ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t\");\n#endif\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t(void)fprintf(stderr, \"[ --immediate-mode ] \");\n#endif\n\t(void)fprintf(stderr, \"[ -T type ] [ --version ] [ -V file ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t[ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t[ -Z user ] [ expression ]\\n\");\n}\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Support for splitting captures into multiple files with a maximum\n * file size:\n *\n * Copyright (c) 2001\n *\tSeth Webster <swebster@sst.ll.mit.edu>\n */\n\n#ifndef lint\nstatic const char copyright[] _U_ =\n    \"@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\\n\\\nThe Regents of the University of California.  All rights reserved.\\n\";\n#endif\n\n/*\n * tcpdump - dump traffic on a network\n *\n * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.\n * Mercilessly hacked and occasionally improved since then via the\n * combined efforts of Van, Steve McCanne and Craig Leres of LBL.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n/*\n * Mac OS X may ship pcap.h from libpcap 0.6 with a libpcap based on\n * 0.8.  That means it has pcap_findalldevs() but the header doesn't\n * define pcap_if_t, meaning that we can't actually *use* pcap_findalldevs().\n */\n#ifdef HAVE_PCAP_FINDALLDEVS\n#ifndef HAVE_PCAP_IF_T\n#undef HAVE_PCAP_FINDALLDEVS\n#endif\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include <sys/stat.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef HAVE_LIBCRYPTO\n#include <openssl/crypto.h>\n#endif\n\n#ifdef HAVE_GETOPT_LONG\n#include <getopt.h>\n#else\n#include \"getopt_long.h\"\n#endif\n/* Capsicum-specific code requires macros from <net/bpf.h>, which will fail\n * to compile if <pcap.h> has already been included; including the headers\n * in the opposite order works fine.\n */\n#ifdef HAVE_CAPSICUM\n#include <sys/capability.h>\n#include <sys/ioccom.h>\n#include <net/bpf.h>\n#include <libgen.h>\n#endif\t/* HAVE_CAPSICUM */\n#include <pcap.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifndef _WIN32\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <pwd.h>\n#include <grp.h>\n#endif /* _WIN32 */\n\n/* capabilities convenience library */\n/* If a code depends on HAVE_LIBCAP_NG, it depends also on HAVE_CAP_NG_H.\n * If HAVE_CAP_NG_H is not defined, undefine HAVE_LIBCAP_NG.\n * Thus, the later tests are done only on HAVE_LIBCAP_NG.\n */\n#ifdef HAVE_LIBCAP_NG\n#ifdef HAVE_CAP_NG_H\n#include <cap-ng.h>\n#else\n#undef HAVE_LIBCAP_NG\n#endif /* HAVE_CAP_NG_H */\n#endif /* HAVE_LIBCAP_NG */\n\n#include \"netdissect.h\"\n#include \"interface.h\"\n#include \"addrtoname.h\"\n#include \"machdep.h\"\n#include \"setsignal.h\"\n#include \"gmt2local.h\"\n#include \"pcap-missing.h\"\n#include \"ascii_strcasecmp.h\"\n\n#include \"print.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#ifdef SIGINFO\n#define SIGNAL_REQ_INFO SIGINFO\n#elif SIGUSR1\n#define SIGNAL_REQ_INFO SIGUSR1\n#endif\n\nstatic int Bflag;\t\t\t/* buffer size */\nstatic long Cflag;\t\t\t/* rotate dump files after this many bytes */\nstatic int Cflag_count;\t\t\t/* Keep track of which file number we're writing */\nstatic int Dflag;\t\t\t/* list available devices and exit */\n/*\n * This is exported because, in some versions of libpcap, if libpcap\n * is built with optimizer debugging code (which is *NOT* the default\n * configuration!), the library *imports*(!) a variable named dflag,\n * under the expectation that tcpdump is exporting it, to govern\n * how much debugging information to print when optimizing\n * the generated BPF code.\n *\n * This is a horrible hack; newer versions of libpcap don't import\n * dflag but, instead, *if* built with optimizer debugging code,\n * *export* a routine to set that flag.\n */\nint dflag;\t\t\t\t/* print filter code */\nstatic int Gflag;\t\t\t/* rotate dump files after this many seconds */\nstatic int Gflag_count;\t\t\t/* number of files created with Gflag rotation */\nstatic time_t Gflag_time;\t\t/* The last time_t the dump file was rotated. */\nstatic int Lflag;\t\t\t/* list available data link types and exit */\nstatic int Iflag;\t\t\t/* rfmon (monitor) mode */\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic int Jflag;\t\t\t/* list available time stamp types */\n#endif\nstatic int jflag = -1;\t\t\t/* packet time stamp source */\nstatic int pflag;\t\t\t/* don't go promiscuous */\n#ifdef HAVE_PCAP_SETDIRECTION\nstatic int Qflag = -1;\t\t\t/* restrict captured packet by send/receive direction */\n#endif\nstatic int Uflag;\t\t\t/* \"unbuffered\" output of dump files */\nstatic int Wflag;\t\t\t/* recycle output files after this number of files */\nstatic int WflagChars;\nstatic char *zflag = NULL;\t\t/* compress each savefile using a specified command (like gzip or bzip2) */\nstatic int immediate_mode;\n\nstatic int infodelay;\nstatic int infoprint;\n\nchar *program_name;\n\n/* Forwards */\nstatic void error(FORMAT_STRING(const char *), ...) NORETURN PRINTFLIKE(1, 2);\nstatic void warning(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);\nstatic void exit_tcpdump(int) NORETURN;\nstatic RETSIGTYPE cleanup(int);\nstatic RETSIGTYPE child_cleanup(int);\nstatic void print_version(void);\nstatic void print_usage(void);\nstatic void show_tstamp_types_and_exit(pcap_t *, const char *device) NORETURN;\nstatic void show_dlts_and_exit(pcap_t *, const char *device) NORETURN;\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic void show_devices_and_exit (void) NORETURN;\n#endif\n\nstatic void print_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet_and_trunc(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void droproot(const char *, const char *);\n\n#ifdef SIGNAL_REQ_INFO\nRETSIGTYPE requestinfo(int);\n#endif\n\n#if defined(USE_WIN32_MM_TIMER)\n  #include <MMsystem.h>\n  static UINT timer_id;\n  static void CALLBACK verbose_stats_dump(UINT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR);\n#elif defined(HAVE_ALARM)\n  static void verbose_stats_dump(int sig);\n#endif\n\nstatic void info(int);\nstatic u_int packets_captured;\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic const struct tok status_flags[] = {\n#ifdef PCAP_IF_UP\n\t{ PCAP_IF_UP,       \"Up\"       },\n#endif\n#ifdef PCAP_IF_RUNNING\n\t{ PCAP_IF_RUNNING,  \"Running\"  },\n#endif\n\t{ PCAP_IF_LOOPBACK, \"Loopback\" },\n\t{ 0, NULL }\n};\n#endif\n\nstatic pcap_t *pd;\n\nstatic int supports_monitor_mode;\n\nextern int optind;\nextern int opterr;\nextern char *optarg;\n\nstruct dump_info {\n\tchar\t*WFileName;\n\tchar\t*CurrentFileName;\n\tpcap_t\t*pd;\n\tpcap_dumper_t *p;\n#ifdef HAVE_CAPSICUM\n\tint\tdirfd;\n#endif\n};\n\n#if defined(HAVE_PCAP_SET_PARSER_DEBUG)\n/*\n * We have pcap_set_parser_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the parser for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_parser_debug(int);\n#elif defined(HAVE_PCAP_DEBUG) || defined(HAVE_YYDEBUG)\n/*\n * We don't have pcap_set_parser_debug() in libpcap, but we do have\n * pcap_debug or yydebug.  Make a local version of pcap_set_parser_debug()\n * to set the flag, and define HAVE_PCAP_SET_PARSER_DEBUG.\n */\nstatic void\npcap_set_parser_debug(int value)\n{\n#ifdef HAVE_PCAP_DEBUG\n\textern int pcap_debug;\n\n\tpcap_debug = value;\n#else /* HAVE_PCAP_DEBUG */\n\textern int yydebug;\n\n\tyydebug = value;\n#endif /* HAVE_PCAP_DEBUG */\n}\n\n#define HAVE_PCAP_SET_PARSER_DEBUG\n#endif\n\n#if defined(HAVE_PCAP_SET_OPTIMIZER_DEBUG)\n/*\n * We have pcap_set_optimizer_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the optimizer for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_optimizer_debug(int);\n#endif\n\n/* VARARGS */\nstatic void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit_tcpdump(1);\n\t/* NOTREACHED */\n}\n\n/* VARARGS */\nstatic void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}\n\nstatic void\nexit_tcpdump(int status)\n{\n\tnd_cleanup();\n\texit(status);\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic void\nshow_tstamp_types_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_tstamp_types;\n\tint *tstamp_types = 0;\n\tconst char *tstamp_type_name;\n\tint i;\n\n\tn_tstamp_types = pcap_list_tstamp_types(pc, &tstamp_types);\n\tif (n_tstamp_types < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\n\tif (n_tstamp_types == 0) {\n\t\tfprintf(stderr, \"Time stamp type cannot be set for %s\\n\",\n\t\t    device);\n\t\texit_tcpdump(0);\n\t}\n\tfprintf(stderr, \"Time stamp types for %s (use option -j to set):\\n\",\n\t    device);\n\tfor (i = 0; i < n_tstamp_types; i++) {\n\t\ttstamp_type_name = pcap_tstamp_type_val_to_name(tstamp_types[i]);\n\t\tif (tstamp_type_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\\n\", tstamp_type_name,\n\t\t\t    pcap_tstamp_type_val_to_description(tstamp_types[i]));\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  %d\\n\", tstamp_types[i]);\n\t\t}\n\t}\n\tpcap_free_tstamp_types(tstamp_types);\n\texit_tcpdump(0);\n}\n#endif\n\nstatic void\nshow_dlts_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_dlts, i;\n\tint *dlts = 0;\n\tconst char *dlt_name;\n\n\tn_dlts = pcap_list_datalinks(pc, &dlts);\n\tif (n_dlts < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\telse if (n_dlts == 0 || !dlts)\n\t\terror(\"No data link types.\");\n\n\t/*\n\t * If the interface is known to support monitor mode, indicate\n\t * whether these are the data link types available when not in\n\t * monitor mode, if -I wasn't specified, or when in monitor mode,\n\t * when -I was specified (the link-layer types available in\n\t * monitor mode might be different from the ones available when\n\t * not in monitor mode).\n\t */\n\tif (supports_monitor_mode)\n\t\t(void) fprintf(stderr, \"Data link types for %s %s (use option -y to set):\\n\",\n\t\t    device,\n\t\t    Iflag ? \"when in monitor mode\" : \"when not in monitor mode\");\n\telse\n\t\t(void) fprintf(stderr, \"Data link types for %s (use option -y to set):\\n\",\n\t\t    device);\n\n\tfor (i = 0; i < n_dlts; i++) {\n\t\tdlt_name = pcap_datalink_val_to_name(dlts[i]);\n\t\tif (dlt_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\", dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlts[i]));\n\n\t\t\t/*\n\t\t\t * OK, does tcpdump handle that type?\n\t\t\t */\n\t\t\tif (!has_printer(dlts[i]))\n\t\t\t\t(void) fprintf(stderr, \" (printing not supported)\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  DLT %d (printing not supported)\\n\",\n\t\t\t    dlts[i]);\n\t\t}\n\t}\n#ifdef HAVE_PCAP_FREE_DATALINKS\n\tpcap_free_datalinks(dlts);\n#endif\n\texit_tcpdump(0);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic void\nshow_devices_and_exit (void)\n{\n\tpcap_if_t *dev, *devlist;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint i;\n\n\tif (pcap_findalldevs(&devlist, ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\tfor (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {\n\t\tprintf(\"%d.%s\", i+1, dev->name);\n\t\tif (dev->description != NULL)\n\t\t\tprintf(\" (%s)\", dev->description);\n\t\tif (dev->flags != 0)\n\t\t\tprintf(\" [%s]\", bittok2str(status_flags, \"none\", dev->flags));\n\t\tprintf(\"\\n\");\n\t}\n\tpcap_freealldevs(devlist);\n\texit_tcpdump(0);\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n/*\n * Short options.\n *\n * Note that there we use all letters for short options except for g, k,\n * o, and P, and those are used by other versions of tcpdump, and we should\n * only use them for the same purposes that the other versions of tcpdump\n * use them:\n *\n * OS X tcpdump uses -g to force non--v output for IP to be on one\n * line, making it more \"g\"repable;\n *\n * OS X tcpdump uses -k to specify that packet comments in pcap-ng files\n * should be printed;\n *\n * OpenBSD tcpdump uses -o to indicate that OS fingerprinting should be done\n * for hosts sending TCP SYN packets;\n *\n * OS X tcpdump uses -P to indicate that -w should write pcap-ng rather\n * than pcap files.\n *\n * OS X tcpdump also uses -Q to specify expressions that match packet\n * metadata, including but not limited to the packet direction.\n * The expression syntax is different from a simple \"in|out|inout\",\n * and those expressions aren't accepted by OS X tcpdump, but the\n * equivalents would be \"in\" = \"dir=in\", \"out\" = \"dir=out\", and\n * \"inout\" = \"dir=in or dir=out\", and the parser could conceivably\n * special-case \"in\", \"out\", and \"inout\" as expressions for backwards\n * compatibility, so all is not (yet) lost.\n */\n\n/*\n * Set up flags that might or might not be supported depending on the\n * version of libpcap we're using.\n */\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n#define B_FLAG\t\t\"B:\"\n#define B_FLAG_USAGE\t\" [ -B size ]\"\n#else /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n#define B_FLAG\n#define B_FLAG_USAGE\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n#ifdef HAVE_PCAP_CREATE\n#define I_FLAG\t\t\"I\"\n#else /* HAVE_PCAP_CREATE */\n#define I_FLAG\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n#define j_FLAG\t\t\"j:\"\n#define j_FLAG_USAGE\t\" [ -j tstamptype ]\"\n#define J_FLAG\t\t\"J\"\n#else /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n#define j_FLAG\n#define j_FLAG_USAGE\n#define J_FLAG\n#endif /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n#define D_FLAG\t\"D\"\n#else\n#define D_FLAG\n#endif\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n#define U_FLAG\t\"U\"\n#else\n#define U_FLAG\n#endif\n\n#ifdef HAVE_PCAP_SETDIRECTION\n#define Q_FLAG \"Q:\"\n#else\n#define Q_FLAG\n#endif\n\n#define SHORTOPTS \"aAb\" B_FLAG \"c:C:d\" D_FLAG \"eE:fF:G:hHi:\" I_FLAG j_FLAG J_FLAG \"KlLm:M:nNOpq\" Q_FLAG \"r:s:StT:u\" U_FLAG \"vV:w:W:xXy:Yz:Z:#\"\n\n/*\n * Long options.\n *\n * We do not currently have long options corresponding to all short\n * options; we should probably pick appropriate option names for them.\n *\n * However, the short options where the number of times the option is\n * specified matters, such as -v and -d and -t, should probably not\n * just map to a long option, as saying\n *\n *  tcpdump --verbose --verbose\n *\n * doesn't make sense; it should be --verbosity={N} or something such\n * as that.\n *\n * For long options with no corresponding short options, we define values\n * outside the range of ASCII graphic characters, make that the last\n * component of the entry for the long option, and have a case for that\n * option in the switch statement.\n */\n#define OPTION_VERSION\t\t128\n#define OPTION_TSTAMP_PRECISION\t129\n#define OPTION_IMMEDIATE_MODE\t130\n\nstatic const struct option longopts[] = {\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t{ \"buffer-size\", required_argument, NULL, 'B' },\n#endif\n\t{ \"list-interfaces\", no_argument, NULL, 'D' },\n\t{ \"help\", no_argument, NULL, 'h' },\n\t{ \"interface\", required_argument, NULL, 'i' },\n#ifdef HAVE_PCAP_CREATE\n\t{ \"monitor-mode\", no_argument, NULL, 'I' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t{ \"time-stamp-type\", required_argument, NULL, 'j' },\n\t{ \"list-time-stamp-types\", no_argument, NULL, 'J' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t{ \"time-stamp-precision\", required_argument, NULL, OPTION_TSTAMP_PRECISION},\n#endif\n\t{ \"dont-verify-checksums\", no_argument, NULL, 'K' },\n\t{ \"list-data-link-types\", no_argument, NULL, 'L' },\n\t{ \"no-optimize\", no_argument, NULL, 'O' },\n\t{ \"no-promiscuous-mode\", no_argument, NULL, 'p' },\n#ifdef HAVE_PCAP_SETDIRECTION\n\t{ \"direction\", required_argument, NULL, 'Q' },\n#endif\n\t{ \"snapshot-length\", required_argument, NULL, 's' },\n\t{ \"absolute-tcp-sequence-numbers\", no_argument, NULL, 'S' },\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t{ \"packet-buffered\", no_argument, NULL, 'U' },\n#endif\n\t{ \"linktype\", required_argument, NULL, 'y' },\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t{ \"immediate-mode\", no_argument, NULL, OPTION_IMMEDIATE_MODE },\n#endif\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t{ \"debug-filter-parser\", no_argument, NULL, 'Y' },\n#endif\n\t{ \"relinquish-privileges\", required_argument, NULL, 'Z' },\n\t{ \"number\", no_argument, NULL, '#' },\n\t{ \"version\", no_argument, NULL, OPTION_VERSION },\n\t{ NULL, 0, NULL, 0 }\n};\n\n#ifndef _WIN32\n/* Drop root privileges and chroot if necessary */\nstatic void\ndroproot(const char *username, const char *chroot_dir)\n{\n\tstruct passwd *pw = NULL;\n\n\tif (chroot_dir && !username) {\n\t\tfprintf(stderr, \"%s: Chroot without dropping root is insecure\\n\",\n\t\t\tprogram_name);\n\t\texit_tcpdump(1);\n\t}\n\n\tpw = getpwnam(username);\n\tif (pw) {\n\t\tif (chroot_dir) {\n\t\t\tif (chroot(chroot_dir) != 0 || chdir (\"/\") != 0) {\n\t\t\t\tfprintf(stderr, \"%s: Couldn't chroot/chdir to '%.64s': %s\\n\",\n\t\t\t\t\tprogram_name, chroot_dir, pcap_strerror(errno));\n\t\t\t\texit_tcpdump(1);\n\t\t\t}\n\t\t}\n#ifdef HAVE_LIBCAP_NG\n\t\t{\n\t\t\tint ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);\n\t\t\tif (ret < 0)\n\t\t\t\terror(\"capng_change_id(): return %d\\n\", ret);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#else\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) != 0 ||\n\t\t    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0) {\n\t\t\tfprintf(stderr, \"%s: Couldn't change to '%.32s' uid=%lu gid=%lu: %s\\n\",\n\t\t\t\tprogram_name, username,\n\t\t\t\t(unsigned long)pw->pw_uid,\n\t\t\t\t(unsigned long)pw->pw_gid,\n\t\t\t\tpcap_strerror(errno));\n\t\t\texit_tcpdump(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#endif /* HAVE_LIBCAP_NG */\n\t}\n\telse {\n\t\tfprintf(stderr, \"%s: Couldn't find user '%.32s'\\n\",\n\t\t\tprogram_name, username);\n\t\texit_tcpdump(1);\n\t}\n#ifdef HAVE_LIBCAP_NG\n\t/* We don't need CAP_SETUID, CAP_SETGID and CAP_SYS_CHROOT any more. */\n\tcapng_updatev(\n\t\tCAPNG_DROP,\n\t\tCAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t\tCAP_SETUID,\n\t\tCAP_SETGID,\n\t\tCAP_SYS_CHROOT,\n\t\t-1);\n\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\n}\n#endif /* _WIN32 */\n\nstatic int\ngetWflagChars(int x)\n{\n\tint c = 0;\n\n\tx -= 1;\n\twhile (x > 0) {\n\t\tc += 1;\n\t\tx /= 10;\n\t}\n\n\treturn c;\n}\n\n\nstatic void\nMakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"Makefilename: malloc\");\n\n        /* Process with strftime if Gflag is set. */\n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          /* Convert Gflag_time to a usable format */\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"MakeTimedFilename: localtime\");\n          }\n\n          /* There's no good way to detect an error in strftime since a return\n           * value of 0 isn't necessarily failure.\n           */\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  /* Report an error if the filename is too large */\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}\n\nstatic char *\nget_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tsize_t len;\n\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\n\tlen = strlen (ptr);\n\tif (len > 0 && ptr[len - 1] == '\\n')\n\t\tptr[len - 1] = '\\0';\n\n\treturn ret;\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\nstatic int\ntstamp_precision_from_string(const char *precision)\n{\n\tif (strncmp(precision, \"nano\", strlen(\"nano\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_NANO;\n\n\tif (strncmp(precision, \"micro\", strlen(\"micro\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn -EINVAL;\n}\n\nstatic const char *\ntstamp_precision_to_string(int precision)\n{\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\treturn \"micro\";\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\treturn \"nano\";\n\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n#endif\n\n#ifdef HAVE_CAPSICUM\n/*\n * Ensure that, on a dump file's descriptor, we have all the rights\n * necessary to make the standard I/O library work with an fdopen()ed\n * FILE * from that descriptor.\n *\n * A long time ago, in a galaxy far far away, AT&T decided that, instead\n * of providing separate APIs for getting and setting the FD_ flags on a\n * descriptor, getting and setting the O_ flags on a descriptor, and\n * locking files, they'd throw them all into a kitchen-sink fcntl() call\n * along the lines of ioctl(), the fact that ioctl() operations are\n * largely specific to particular character devices but fcntl() operations\n * are either generic to all descriptors or generic to all descriptors for\n * regular files nonwithstanding.\n *\n * The Capsicum people decided that fine-grained control of descriptor\n * operations was required, so that you need to grant permission for\n * reading, writing, seeking, and fcntl-ing.  The latter, courtesy of\n * AT&T's decision, means that \"fcntl-ing\" isn't a thing, but a motley\n * collection of things, so there are *individual* fcntls for which\n * permission needs to be granted.\n *\n * The FreeBSD standard I/O people implemented some optimizations that\n * requires that the standard I/O routines be able to determine whether\n * the descriptor for the FILE * is open append-only or not; as that\n * descriptor could have come from an open() rather than an fopen(),\n * that requires that it be able to do an F_GETFL fcntl() to read\n * the O_ flags.\n *\n * Tcpdump uses ftell() to determine how much data has been written\n * to a file in order to, when used with -C, determine when it's time\n * to rotate capture files.  ftell() therefore needs to do an lseek()\n * to find out the file offset and must, thanks to the aforementioned\n * optimization, also know whether the descriptor is open append-only\n * or not.\n *\n * The net result of all the above is that we need to grant CAP_SEEK,\n * CAP_WRITE, and CAP_FCNTL with the CAP_FCNTL_GETFL subcapability.\n *\n * Perhaps this is the universe's way of saying that either\n *\n *\t1) there needs to be an fopenat() call and a pcap_dump_openat() call\n *\t   using it, so that Capsicum-capable tcpdump wouldn't need to do\n *\t   an fdopen()\n *\n * or\n *\n *\t2) there needs to be a cap_fdopen() call in the FreeBSD standard\n *\t   I/O library that knows what rights are needed by the standard\n *\t   I/O library, based on the open mode, and assigns them, perhaps\n *\t   with an additional argument indicating, for example, whether\n *\t   seeking should be allowed, so that tcpdump doesn't need to know\n *\t   what the standard I/O library happens to require this week.\n */\nstatic void\nset_dumper_capsicum_rights(pcap_dumper_t *p)\n{\n\tint fd = fileno(pcap_dump_file(p));\n\tcap_rights_t rights;\n\n\tcap_rights_init(&rights, CAP_SEEK, CAP_WRITE, CAP_FCNTL);\n\tif (cap_rights_limit(fd, &rights) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor\");\n\t}\n\tif (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor fcntls\");\n\t}\n}\n#endif\n\n/*\n * Copy arg vector into a new buffer, concatenating arguments with spaces.\n */\nstatic char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister u_int len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == NULL)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}\n\n/*\n * On Windows, we need to open the file in binary mode, so that\n * we get all the bytes specified by the size we get from \"fstat()\".\n * On UNIX, that's not necessary.  O_BINARY is defined on Windows;\n * we define it as 0 if it's not defined, so it does nothing.\n */\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\nstatic char *\nread_infile(char *fname)\n{\n\tregister int i, fd, cc;\n\tregister char *cp;\n\tstruct stat buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, cc, (int)buf.st_size);\n\n\tclose(fd);\n\t/* replace \"# comment\" with spaces */\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic long\nparse_interface_number(const char *device)\n{\n\tlong devnum;\n\tchar *end;\n\n\tdevnum = strtol(device, &end, 10);\n\tif (device != end && *end == '\\0') {\n\t\t/*\n\t\t * It's all-numeric, but is it a valid number?\n\t\t */\n\t\tif (devnum <= 0) {\n\t\t\t/*\n\t\t\t * No, it's not an ordinal.\n\t\t\t */\n\t\t\terror(\"Invalid adapter index\");\n\t\t}\n\t\treturn (devnum);\n\t} else {\n\t\t/*\n\t\t * It's not all-numeric; return -1, so our caller\n\t\t * knows that.\n\t\t */\n\t\treturn (-1);\n\t}\n}\n\nstatic char *\nfind_interface_by_number(long devnum)\n{\n\tpcap_if_t *dev, *devlist;\n\tlong i;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar *device;\n\n\tif (pcap_findalldevs(&devlist, ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\t/*\n\t * Look for the devnum-th entry in the list of devices (1-based).\n\t */\n\tfor (i = 0, dev = devlist; i < devnum-1 && dev != NULL;\n\t    i++, dev = dev->next)\n\t\t;\n\tif (dev == NULL)\n\t\terror(\"Invalid adapter index\");\n\tdevice = strdup(dev->name);\n\tpcap_freealldevs(devlist);\n\treturn (device);\n}\n#endif\n\nstatic pcap_t *\nopen_interface(const char *device, netdissect_options *ndo, char *ebuf)\n{\n\tpcap_t *pc;\n#ifdef HAVE_PCAP_CREATE\n\tint status;\n\tchar *cp;\n#endif\n\n#ifdef HAVE_PCAP_CREATE\n\tpc = pcap_create(device, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (Jflag)\n\t\tshow_tstamp_types_and_exit(pc, device);\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tstatus = pcap_set_tstamp_precision(pc, ndo->ndo_tstamp_precision);\n\tif (status != 0)\n\t\terror(\"%s: Can't set %ssecond time stamp precision: %s\",\n\t\t\tdevice,\n\t\t\ttstamp_precision_to_string(ndo->ndo_tstamp_precision),\n\t\t\tpcap_statustostr(status));\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\tif (immediate_mode) {\n\t\tstatus = pcap_set_immediate_mode(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set immediate mode: %s\",\n\t\t\tdevice,\n\t\t\tpcap_statustostr(status));\n\t}\n#endif\n\t/*\n\t * Is this an interface that supports monitor mode?\n\t */\n\tif (pcap_can_set_rfmon(pc) == 1)\n\t\tsupports_monitor_mode = 1;\n\telse\n\t\tsupports_monitor_mode = 0;\n\tstatus = pcap_set_snaplen(pc, ndo->ndo_snaplen);\n\tif (status != 0)\n\t\terror(\"%s: Can't set snapshot length: %s\",\n\t\t    device, pcap_statustostr(status));\n\tstatus = pcap_set_promisc(pc, !pflag);\n\tif (status != 0)\n\t\terror(\"%s: Can't set promiscuous mode: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Iflag) {\n\t\tstatus = pcap_set_rfmon(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set monitor mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pc, 1000);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Bflag != 0) {\n\t\tstatus = pcap_set_buffer_size(pc, Bflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set buffer size: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (jflag != -1) {\n\t\tstatus = pcap_set_tstamp_type(pc, jflag);\n\t\tif (status < 0)\n\t\t\terror(\"%s: Can't set time stamp type: %s\",\n\t\t              device, pcap_statustostr(status));\n\t\telse if (status > 0)\n\t\t\twarning(\"When trying to set timestamp type '%s' on %s: %s\",\n\t\t\t\tpcap_tstamp_type_val_to_name(jflag), device,\n\t\t\t\tpcap_statustostr(status));\n\t}\n#endif\n\tstatus = pcap_activate(pc);\n\tif (status < 0) {\n\t\t/*\n\t\t * pcap_activate() failed.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_ERROR)\n\t\t\terror(\"%s\", cp);\n\t\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Return an error for our caller to handle.\n\t\t\t */\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s: %s\\n(%s)\",\n\t\t\t    device, pcap_statustostr(status), cp);\n\t\t\tpcap_close(pc);\n\t\t\treturn (NULL);\n\t\t} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\\0')\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\terror(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t} else if (status > 0) {\n\t\t/*\n\t\t * pcap_activate() succeeded, but it's warning us\n\t\t * of a problem it had.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_WARNING)\n\t\t\twarning(\"%s\", cp);\n\t\telse if (status == PCAP_WARNING_PROMISC_NOTSUP &&\n\t\t         *cp != '\\0')\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\twarning(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SETDIRECTION\n\tif (Qflag != -1) {\n\t\tstatus = pcap_setdirection(pc, Qflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_setdirection() failed: %s\",\n\t\t\t      device,  pcap_geterr(pc));\n\t\t}\n#endif /* HAVE_PCAP_SETDIRECTION */\n#else /* HAVE_PCAP_CREATE */\n\t*ebuf = '\\0';\n\tpc = pcap_open_live(device, ndo->ndo_snaplen, !pflag, 1000, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n\tif (*ebuf)\n\t\twarning(\"%s\", ebuf);\n#endif /* HAVE_PCAP_CREATE */\n\n\treturn (pc);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tregister int cnt, op, i;\n\tbpf_u_int32 localnet =0 , netmask = 0;\n\tint timezone_offset = 0;\n\tregister char *cp, *infile, *cmdbuf, *device, *RFileName, *VFileName, *WFileName;\n\tpcap_handler callback;\n\tint dlt;\n\tconst char *dlt_name;\n\tstruct bpf_program fcode;\n#ifndef _WIN32\n\tRETSIGTYPE (*oldhandler)(int);\n#endif\n\tstruct dump_info dumpinfo;\n\tu_char *pcap_userdata;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar VFileLine[PATH_MAX + 1];\n\tchar *username = NULL;\n\tchar *chroot_dir = NULL;\n\tchar *ret = NULL;\n\tchar *end;\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tpcap_if_t *devlist;\n\tlong devnum;\n#endif\n\tint status;\n\tFILE *VFile;\n#ifdef HAVE_CAPSICUM\n\tcap_rights_t rights;\n\tint cansandbox;\n#endif\t/* HAVE_CAPSICUM */\n\tint Oflag = 1;\t\t\t/* run filter code optimizer */\n\tint yflag_dlt = -1;\n\tconst char *yflag_dlt_name = NULL;\n\n\tnetdissect_options Ndo;\n\tnetdissect_options *ndo = &Ndo;\n\n\t/*\n\t * Initialize the netdissect code.\n\t */\n\tif (nd_init(ebuf, sizeof ebuf) == -1)\n\t\terror(\"%s\", ebuf);\n\n\tmemset(ndo, 0, sizeof(*ndo));\n\tndo_set_function_pointers(ndo);\n\tndo->ndo_snaplen = DEFAULT_SNAPLEN;\n\n\tcnt = -1;\n\tdevice = NULL;\n\tinfile = NULL;\n\tRFileName = NULL;\n\tVFileName = NULL;\n\tVFile = NULL;\n\tWFileName = NULL;\n\tdlt = -1;\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tndo->program_name = program_name = cp + 1;\n\telse\n\t\tndo->program_name = program_name = argv[0];\n\n#ifdef _WIN32\n\tif (pcap_wsockinit() != 0)\n\t\terror(\"Attempting to initialize Winsock failed\");\n#endif /* _WIN32 */\n\n\t/*\n\t * On platforms where the CPU doesn't support unaligned loads,\n\t * force unaligned accesses to abort with SIGBUS, rather than\n\t * being fixed up (slowly) by the OS kernel; on those platforms,\n\t * misaligned accesses are bugs, and we want tcpdump to crash so\n\t * that the bugs are reported.\n\t */\n\tif (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)\n\t\terror(\"%s\", ebuf);\n\n\twhile (\n\t    (op = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != -1)\n\t\tswitch (op) {\n\n\t\tcase 'a':\n\t\t\t/* compatibility for old -a */\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t\t++ndo->ndo_Aflag;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\t++ndo->ndo_bflag;\n\t\t\tbreak;\n\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t\tcase 'B':\n\t\t\tBflag = atoi(optarg)*1024;\n\t\t\tif (Bflag <= 0)\n\t\t\t\terror(\"invalid packet buffer size %s\", optarg);\n\t\t\tbreak;\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n\t\tcase 'c':\n\t\t\tcnt = atoi(optarg);\n\t\t\tif (cnt <= 0)\n\t\t\t\terror(\"invalid packet count %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tCflag = atoi(optarg) * 1000000;\n\t\t\tif (Cflag <= 0)\n\t\t\t\terror(\"invalid file size %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\t++dflag;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tDflag++;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tLflag++;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\t++ndo->ndo_eflag;\n\t\t\tbreak;\n\n\t\tcase 'E':\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_espsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\t++ndo->ndo_fflag;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'G':\n\t\t\tGflag = atoi(optarg);\n\t\t\tif (Gflag < 0)\n\t\t\t\terror(\"invalid number of seconds %s\", optarg);\n\n                        /* We will create one file initially. */\n                        Gflag_count = 0;\n\n\t\t\t/* Grab the current time for rotation use. */\n\t\t\tif ((Gflag_time = time(NULL)) == (time_t)-1) {\n\t\t\t\terror(\"main: can't get current time: %s\",\n\t\t\t\t    pcap_strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tprint_usage();\n\t\t\texit_tcpdump(0);\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\t++ndo->ndo_Hflag;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_CREATE\n\t\tcase 'I':\n\t\t\t++Iflag;\n\t\t\tbreak;\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t\tcase 'j':\n\t\t\tjflag = pcap_tstamp_type_name_to_val(optarg);\n\t\t\tif (jflag < 0)\n\t\t\t\terror(\"invalid time stamp type %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'J':\n\t\t\tJflag++;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'l':\n#ifdef _WIN32\n\t\t\t/*\n\t\t\t * _IOLBF is the same as _IOFBF in Microsoft's C\n\t\t\t * libraries; the only alternative they offer\n\t\t\t * is _IONBF.\n\t\t\t *\n\t\t\t * XXX - this should really be checking for MSVC++,\n\t\t\t * not _WIN32, if, for example, MinGW has its own\n\t\t\t * C library that is more UNIX-compatible.\n\t\t\t */\n\t\t\tsetvbuf(stdout, NULL, _IONBF, 0);\n#else /* _WIN32 */\n#ifdef HAVE_SETLINEBUF\n\t\t\tsetlinebuf(stdout);\n#else\n\t\t\tsetvbuf(stdout, NULL, _IOLBF, 0);\n#endif\n#endif /* _WIN32 */\n\t\t\tbreak;\n\n\t\tcase 'K':\n\t\t\t++ndo->ndo_Kflag;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (nd_have_smi_support()) {\n\t\t\t\tif (nd_load_smi_module(optarg, ebuf, sizeof ebuf) == -1)\n\t\t\t\t\terror(\"%s\", ebuf);\n\t\t\t} else {\n\t\t\t\t(void)fprintf(stderr, \"%s: ignoring option `-m %s' \",\n\t\t\t\t\t      program_name, optarg);\n\t\t\t\t(void)fprintf(stderr, \"(no libsmi support)\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\t/* TCP-MD5 shared secret */\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_sigsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\t++ndo->ndo_nflag;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\t++ndo->ndo_Nflag;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tOflag = 0;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t++pflag;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\t++ndo->ndo_qflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SETDIRECTION\n\t\tcase 'Q':\n\t\t\tif (ascii_strcasecmp(optarg, \"in\") == 0)\n\t\t\t\tQflag = PCAP_D_IN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"out\") == 0)\n\t\t\t\tQflag = PCAP_D_OUT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"inout\") == 0)\n\t\t\t\tQflag = PCAP_D_INOUT;\n\t\t\telse\n\t\t\t\terror(\"unknown capture direction `%s'\", optarg);\n\t\t\tbreak;\n#endif /* HAVE_PCAP_SETDIRECTION */\n\n\t\tcase 'r':\n\t\t\tRFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tndo->ndo_snaplen = strtol(optarg, &end, 0);\n\t\t\tif (optarg == end || *end != '\\0'\n\t\t\t    || ndo->ndo_snaplen < 0 || ndo->ndo_snaplen > MAXIMUM_SNAPLEN)\n\t\t\t\terror(\"invalid snaplen %s\", optarg);\n\t\t\telse if (ndo->ndo_snaplen == 0)\n\t\t\t\tndo->ndo_snaplen = MAXIMUM_SNAPLEN;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t++ndo->ndo_Sflag;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t++ndo->ndo_tflag;\n\t\t\tbreak;\n\n\t\tcase 'T':\n\t\t\tif (ascii_strcasecmp(optarg, \"vat\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VAT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"wb\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_WB;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rpc\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RPC;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtcp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTCP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"snmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_SNMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"cnfp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CNFP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"tftp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_TFTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"aodv\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_AODV;\n\t\t\telse if (ascii_strcasecmp(optarg, \"carp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CARP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"radius\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RADIUS;\n\t\t\telse if (ascii_strcasecmp(optarg, \"zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"vxlan\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VXLAN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm_zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"lmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_LMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"resp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RESP;\n\t\t\telse\n\t\t\t\terror(\"unknown packet type `%s'\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t\t++ndo->ndo_uflag;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tcase 'U':\n\t\t\t++Uflag;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'v':\n\t\t\t++ndo->ndo_vflag;\n\t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tVFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tWFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'W':\n\t\t\tWflag = atoi(optarg);\n\t\t\tif (Wflag <= 0)\n\t\t\t\terror(\"invalid number of output files %s\", optarg);\n\t\t\tWflagChars = getWflagChars(Wflag);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\t++ndo->ndo_xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\t++ndo->ndo_Xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tyflag_dlt_name = optarg;\n\t\t\tyflag_dlt =\n\t\t\t\tpcap_datalink_name_to_val(yflag_dlt_name);\n\t\t\tif (yflag_dlt < 0)\n\t\t\t\terror(\"invalid data link type %s\", yflag_dlt_name);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t\tcase 'Y':\n\t\t\t{\n\t\t\t/* Undocumented flag */\n\t\t\tpcap_set_parser_debug(1);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tcase 'z':\n\t\t\tzflag = optarg;\n\t\t\tbreak;\n\n\t\tcase 'Z':\n\t\t\tusername = optarg;\n\t\t\tbreak;\n\n\t\tcase '#':\n\t\t\tndo->ndo_packet_number = 1;\n\t\t\tbreak;\n\n\t\tcase OPTION_VERSION:\n\t\t\tprint_version();\n\t\t\texit_tcpdump(0);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tcase OPTION_TSTAMP_PRECISION:\n\t\t\tndo->ndo_tstamp_precision = tstamp_precision_from_string(optarg);\n\t\t\tif (ndo->ndo_tstamp_precision < 0)\n\t\t\t\terror(\"unsupported time stamp precision\");\n\t\t\tbreak;\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t\tcase OPTION_IMMEDIATE_MODE:\n\t\t\timmediate_mode = 1;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tprint_usage();\n\t\t\texit_tcpdump(1);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tif (Dflag)\n\t\tshow_devices_and_exit();\n#endif\n\n\tswitch (ndo->ndo_tflag) {\n\n\tcase 0: /* Default */\n\tcase 4: /* Default + Date*/\n\t\ttimezone_offset = gmt2local(0);\n\t\tbreak;\n\n\tcase 1: /* No time stamp */\n\tcase 2: /* Unix timeval style */\n\tcase 3: /* Microseconds since previous packet */\n        case 5: /* Microseconds since first packet */\n\t\tbreak;\n\n\tdefault: /* Not supported */\n\t\terror(\"only -t, -tt, -ttt, -tttt and -ttttt are supported\");\n\t\tbreak;\n\t}\n\n\tif (ndo->ndo_fflag != 0 && (VFileName != NULL || RFileName != NULL))\n\t\terror(\"-f can not be used with -V or -r\");\n\n\tif (VFileName != NULL && RFileName != NULL)\n\t\terror(\"-V and -r are mutually exclusive.\");\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t/*\n\t * If we're printing dissected packets to the standard output\n\t * rather than saving raw packets to a file, and the standard\n\t * output is a terminal, use immediate mode, as the user's\n\t * probably expecting to see packets pop up immediately.\n\t */\n\tif (WFileName == NULL && isatty(1))\n\t\timmediate_mode = 1;\n#endif\n\n#ifdef WITH_CHROOT\n\t/* if run as root, prepare for chrooting */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* future extensibility for cmd-line arguments */\n\t\tif (!chroot_dir)\n\t\t\tchroot_dir = WITH_CHROOT;\n\t}\n#endif\n\n#ifdef WITH_USER\n\t/* if run as root, prepare for dropping root privileges */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* Run with '-Z root' to restore old behaviour */\n\t\tif (!username)\n\t\t\tusername = WITH_USER;\n\t}\n#endif\n\n\tif (RFileName != NULL || VFileName != NULL) {\n\t\t/*\n\t\t * If RFileName is non-null, it's the pathname of a\n\t\t * savefile to read.  If VFileName is non-null, it's\n\t\t * the pathname of a file containing a list of pathnames\n\t\t * (one per line) of savefiles to read.\n\t\t *\n\t\t * In either case, we're reading a savefile, not doing\n\t\t * a live capture.\n\t\t */\n#ifndef _WIN32\n\t\t/*\n\t\t * We don't need network access, so relinquish any set-UID\n\t\t * or set-GID privileges we have (if any).\n\t\t *\n\t\t * We do *not* want set-UID privileges when opening a\n\t\t * trace file, as that might let the user read other\n\t\t * people's trace files (especially if we're set-UID\n\t\t * root).\n\t\t */\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0 )\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n\t\tif (VFileName != NULL) {\n\t\t\tif (VFileName[0] == '-' && VFileName[1] == '\\0')\n\t\t\t\tVFile = stdin;\n\t\t\telse\n\t\t\t\tVFile = fopen(VFileName, \"r\");\n\n\t\t\tif (VFile == NULL)\n\t\t\t\terror(\"Unable to open file: %s\\n\", pcap_strerror(errno));\n\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (!ret)\n\t\t\t\terror(\"Nothing in %s\\n\", VFileName);\n\t\t\tRFileName = VFileLine;\n\t\t}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tpd = pcap_open_offline_with_tstamp_precision(RFileName,\n\t\t    ndo->ndo_tstamp_precision, ebuf);\n#else\n\t\tpd = pcap_open_offline(RFileName, ebuf);\n#endif\n\n\t\tif (pd == NULL)\n\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\tcap_rights_init(&rights, CAP_READ);\n\t\tif (cap_rights_limit(fileno(pcap_file(pd)), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n#endif\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\tif (dlt_name == NULL) {\n\t\t\tfprintf(stderr, \"reading from file %s, link-type %u\\n\",\n\t\t\t    RFileName, dlt);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"reading from file %s, link-type %s (%s)\\n\",\n\t\t\t    RFileName, dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlt));\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We're doing a live capture.\n\t\t */\n\t\tif (device == NULL) {\n\t\t\t/*\n\t\t\t * No interface was specified.  Pick one.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\t/*\n\t\t\t * Find the list of interfaces, and pick\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tif (pcap_findalldevs(&devlist, ebuf) >= 0 &&\n\t\t\t    devlist != NULL) {\n\t\t\t\tdevice = strdup(devlist->name);\n\t\t\t\tpcap_freealldevs(devlist);\n\t\t\t}\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * Use whatever interface pcap_lookupdev()\n\t\t\t * chooses.\n\t\t\t */\n\t\t\tdevice = pcap_lookupdev(ebuf);\n#endif\n\t\t\tif (device == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n\t\t}\n\n\t\t/*\n\t\t * Try to open the interface with the specified name.\n\t\t */\n\t\tpd = open_interface(device, ndo, ebuf);\n\t\tif (pd == NULL) {\n\t\t\t/*\n\t\t\t * That failed.  If we can get a list of\n\t\t\t * interfaces, and the interface name\n\t\t\t * is purely numeric, try to use it as\n\t\t\t * a 1-based index in the list of\n\t\t\t * interfaces.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\tdevnum = parse_interface_number(device);\n\t\t\tif (devnum == -1) {\n\t\t\t\t/*\n\t\t\t\t * It's not a number; just report\n\t\t\t\t * the open error and fail.\n\t\t\t\t */\n\t\t\t\terror(\"%s\", ebuf);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, it's a number; try to find the\n\t\t\t * interface with that index, and try\n\t\t\t * to open it.\n\t\t\t *\n\t\t\t * find_interface_by_number() exits if it\n\t\t\t * couldn't be found.\n\t\t\t */\n\t\t\tdevice = find_interface_by_number(devnum);\n\t\t\tpd = open_interface(device, ndo, ebuf);\n\t\t\tif (pd == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * We can't get a list of interfaces; just\n\t\t\t * fail.\n\t\t\t */\n\t\t\terror(\"%s\", ebuf);\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\t\t}\n\n\t\t/*\n\t\t * Let user own process after socket has been opened.\n\t\t */\n#ifndef _WIN32\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0)\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n#if !defined(HAVE_PCAP_CREATE) && defined(_WIN32)\n\t\tif(Bflag != 0)\n\t\t\tif(pcap_setbuff(pd, Bflag)==-1){\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t}\n#endif /* !defined(HAVE_PCAP_CREATE) && defined(_WIN32) */\n\t\tif (Lflag)\n\t\t\tshow_dlts_and_exit(pd, device);\n\t\tif (yflag_dlt >= 0) {\n#ifdef HAVE_PCAP_SET_DATALINK\n\t\t\tif (pcap_set_datalink(pd, yflag_dlt) < 0)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#else\n\t\t\t/*\n\t\t\t * We don't actually support changing the\n\t\t\t * data link type, so we only let them\n\t\t\t * set it to what it already is.\n\t\t\t */\n\t\t\tif (yflag_dlt != pcap_datalink(pd)) {\n\t\t\t\terror(\"%s is not one of the DLTs supported by this device\\n\",\n\t\t\t\t      yflag_dlt_name);\n\t\t\t}\n#endif\n\t\t\t(void)fprintf(stderr, \"%s: data link type %s\\n\",\n\t\t\t\t      program_name, yflag_dlt_name);\n\t\t\t(void)fflush(stderr);\n\t\t}\n\t\ti = pcap_snapshot(pd);\n\t\tif (ndo->ndo_snaplen < i) {\n\t\t\twarning(\"snaplen raised from %d to %d\", ndo->ndo_snaplen, i);\n\t\t\tndo->ndo_snaplen = i;\n\t\t}\n                if(ndo->ndo_fflag != 0) {\n                        if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n                                warning(\"foreign (-f) flag used but: %s\", ebuf);\n                        }\n                }\n\n\t}\n\tif (infile)\n\t\tcmdbuf = read_infile(infile);\n\telse\n\t\tcmdbuf = copy_argv(&argv[optind]);\n\n#ifdef HAVE_PCAP_SET_OPTIMIZER_DEBUG\n\tpcap_set_optimizer_debug(dflag);\n#endif\n\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\tif (dflag) {\n\t\tbpf_dump(&fcode, dflag);\n\t\tpcap_close(pd);\n\t\tfree(cmdbuf);\n\t\tpcap_freecode(&fcode);\n\t\texit_tcpdump(0);\n\t}\n\tinit_print(ndo, localnet, netmask, timezone_offset);\n\n#ifndef _WIN32\n\t(void)setsignal(SIGPIPE, cleanup);\n\t(void)setsignal(SIGTERM, cleanup);\n\t(void)setsignal(SIGINT, cleanup);\n#endif /* _WIN32 */\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n\t(void)setsignal(SIGCHLD, child_cleanup);\n#endif\n\t/* Cooperate with nohup(1) */\n#ifndef _WIN32\n\tif ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)\n\t\t(void)setsignal(SIGHUP, oldhandler);\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\t/*\n\t * If a user name was specified with \"-Z\", attempt to switch to\n\t * that user's UID.  This would probably be used with sudo,\n\t * to allow tcpdump to be run in a special restricted\n\t * account (if you just want to allow users to open capture\n\t * devices, and can't just give users that permission,\n\t * you'd make tcpdump set-UID or set-GID).\n\t *\n\t * Tcpdump doesn't necessarily write only to one savefile;\n\t * the general only way to allow a -Z instance to write to\n\t * savefiles as the user under whose UID it's run, rather\n\t * than as the user specified with -Z, would thus be to switch\n\t * to the original user ID before opening a capture file and\n\t * then switch back to the -Z user ID after opening the savefile.\n\t * Switching to the -Z user ID only after opening the first\n\t * savefile doesn't handle the general case.\n\t */\n\n\tif (getuid() == 0 || geteuid() == 0) {\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Initialize capng */\n\t\tcapng_clear(CAPNG_SELECT_BOTH);\n\t\tif (username) {\n\t\t\tcapng_updatev(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SETUID,\n\t\t\t\tCAP_SETGID,\n\t\t\t\t-1);\n\t\t}\n\t\tif (chroot_dir) {\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SYS_CHROOT\n\t\t\t\t);\n\t\t}\n\n\t\tif (WFileName) {\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_DAC_OVERRIDE\n\t\t\t\t);\n\t\t}\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (username || chroot_dir)\n\t\t\tdroproot(username, chroot_dir);\n\n\t}\n#endif /* _WIN32 */\n\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\tif (RFileName == NULL && VFileName == NULL) {\n\t\tstatic const unsigned long cmds[] = { BIOCGSTATS, BIOCROTZBUF };\n\n\t\t/*\n\t\t * The various libpcap devices use a combination of\n\t\t * read (bpf), ioctl (bpf, netmap), poll (netmap)\n\t\t * so we add the relevant access rights.\n\t\t */\n\t\tcap_rights_init(&rights, CAP_IOCTL, CAP_READ, CAP_EVENT);\n\t\tif (cap_rights_limit(pcap_fileno(pd), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n\t\tif (cap_ioctls_limit(pcap_fileno(pd), cmds,\n\t\t    sizeof(cmds) / sizeof(cmds[0])) < 0 && errno != ENOSYS) {\n\t\t\terror(\"unable to limit ioctls on pcap descriptor\");\n\t\t}\n\t}\n#endif\n\tif (WFileName) {\n\t\tpcap_dumper_t *p;\n\t\t/* Do not exceed the default PATH_MAX for files. */\n\t\tdumpinfo.CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\n\t\tif (dumpinfo.CurrentFileName == NULL)\n\t\t\terror(\"malloc of dumpinfo.CurrentFileName\");\n\n\t\t/* We do not need numbering for dumpfiles if Cflag isn't set. */\n\t\tif (Cflag != 0)\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, WflagChars);\n\t\telse\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, 0);\n\n\t\tp = pcap_dump_open(pd, dumpinfo.CurrentFileName);\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Give up CAP_DAC_OVERRIDE capability.\n\t\t * Only allow it to be restored if the -C or -G flag have been\n\t\t * set since we may need to create more files later on.\n\t\t */\n\t\tcapng_update(\n\t\t\tCAPNG_DROP,\n\t\t\t(Cflag || Gflag ? 0 : CAPNG_PERMITTED)\n\t\t\t\t| CAPNG_EFFECTIVE,\n\t\t\tCAP_DAC_OVERRIDE\n\t\t\t);\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (p == NULL)\n\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\tset_dumper_capsicum_rights(p);\n#endif\n\t\tif (Cflag != 0 || Gflag != 0) {\n#ifdef HAVE_CAPSICUM\n\t\t\tdumpinfo.WFileName = strdup(basename(WFileName));\n\t\t\tif (dumpinfo.WFileName == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tdumpinfo.dirfd = open(dirname(WFileName),\n\t\t\t    O_DIRECTORY | O_RDONLY);\n\t\t\tif (dumpinfo.dirfd < 0) {\n\t\t\t\terror(\"unable to open directory %s\",\n\t\t\t\t    dirname(WFileName));\n\t\t\t}\n\t\t\tcap_rights_init(&rights, CAP_CREATE, CAP_FCNTL,\n\t\t\t    CAP_FTRUNCATE, CAP_LOOKUP, CAP_SEEK, CAP_WRITE);\n\t\t\tif (cap_rights_limit(dumpinfo.dirfd, &rights) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit directory rights\");\n\t\t\t}\n\t\t\tif (cap_fcntls_limit(dumpinfo.dirfd, CAP_FCNTL_GETFL) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit dump descriptor fcntls\");\n\t\t\t}\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdumpinfo.WFileName = WFileName;\n#endif\n\t\t\tcallback = dump_packet_and_trunc;\n\t\t\tdumpinfo.pd = pd;\n\t\t\tdumpinfo.p = p;\n\t\t\tpcap_userdata = (u_char *)&dumpinfo;\n\t\t} else {\n\t\t\tcallback = dump_packet;\n\t\t\tpcap_userdata = (u_char *)p;\n\t\t}\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tif (Uflag)\n\t\t\tpcap_dump_flush(p);\n#endif\n\t} else {\n\t\tdlt = pcap_datalink(pd);\n\t\tndo->ndo_if_printer = get_if_printer(ndo, dlt);\n\t\tcallback = print_packet;\n\t\tpcap_userdata = (u_char *)ndo;\n\t}\n\n#ifdef SIGNAL_REQ_INFO\n\t/*\n\t * We can't get statistics when reading from a file rather\n\t * than capturing from a device.\n\t */\n\tif (RFileName == NULL)\n\t\t(void)setsignal(SIGNAL_REQ_INFO, requestinfo);\n#endif\n\n\tif (ndo->ndo_vflag > 0 && WFileName) {\n\t\t/*\n\t\t * When capturing to a file, \"-v\" means tcpdump should,\n\t\t * every 10 seconds, \"v\"erbosely report the number of\n\t\t * packets captured.\n\t\t */\n#ifdef USE_WIN32_MM_TIMER\n\t\t/* call verbose_stats_dump() each 1000 +/-100msec */\n\t\ttimer_id = timeSetEvent(1000, 100, verbose_stats_dump, 0, TIME_PERIODIC);\n\t\tsetvbuf(stderr, NULL, _IONBF, 0);\n#elif defined(HAVE_ALARM)\n\t\t(void)setsignal(SIGALRM, verbose_stats_dump);\n\t\talarm(1);\n#endif\n\t}\n\n\tif (RFileName == NULL) {\n\t\t/*\n\t\t * Live capture (if -V was specified, we set RFileName\n\t\t * to a file from the -V file).  Print a message to\n\t\t * the standard error on UN*X.\n\t\t */\n\t\tif (!ndo->ndo_vflag && !WFileName) {\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"%s: verbose output suppressed, use -v or -vv for full protocol decode\\n\",\n\t\t\t    program_name);\n\t\t} else\n\t\t\t(void)fprintf(stderr, \"%s: \", program_name);\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\tif (dlt_name == NULL) {\n\t\t\t(void)fprintf(stderr, \"listening on %s, link-type %u, capture size %u bytes\\n\",\n\t\t\t    device, dlt, ndo->ndo_snaplen);\n\t\t} else {\n\t\t\t(void)fprintf(stderr, \"listening on %s, link-type %s (%s), capture size %u bytes\\n\",\n\t\t\t    device, dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlt), ndo->ndo_snaplen);\n\t\t}\n\t\t(void)fflush(stderr);\n\t}\n\n#ifdef HAVE_CAPSICUM\n\tcansandbox = (ndo->ndo_nflag && VFileName == NULL && zflag == NULL);\n\tif (cansandbox && cap_enter() < 0 && errno != ENOSYS)\n\t\terror(\"unable to enter the capability mode\");\n#endif\t/* HAVE_CAPSICUM */\n\n\tdo {\n\t\tstatus = pcap_loop(pd, cnt, callback, pcap_userdata);\n\t\tif (WFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're printing packets.  Flush the printed output,\n\t\t\t * so it doesn't get intermingled with error output.\n\t\t\t */\n\t\t\tif (status == -2) {\n\t\t\t\t/*\n\t\t\t\t * We got interrupted, so perhaps we didn't\n\t\t\t\t * manage to finish a line we were printing.\n\t\t\t\t * Print an extra newline, just in case.\n\t\t\t\t */\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t\t(void)fflush(stdout);\n\t\t}\n                if (status == -2) {\n\t\t\t/*\n\t\t\t * We got interrupted. If we are reading multiple\n\t\t\t * files (via -V) set these so that we stop.\n\t\t\t */\n\t\t\tVFileName = NULL;\n\t\t\tret = NULL;\n\t\t}\n\t\tif (status == -1) {\n\t\t\t/*\n\t\t\t * Error.  Report it.\n\t\t\t */\n\t\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t\t    program_name, pcap_geterr(pd));\n\t\t}\n\t\tif (RFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're doing a live capture.  Report the capture\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tinfo(1);\n\t\t}\n\t\tpcap_close(pd);\n\t\tif (VFileName != NULL) {\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (ret) {\n\t\t\t\tint new_dlt;\n\n\t\t\t\tRFileName = VFileLine;\n\t\t\t\tpd = pcap_open_offline(RFileName, ebuf);\n\t\t\t\tif (pd == NULL)\n\t\t\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\t\t\tcap_rights_init(&rights, CAP_READ);\n\t\t\t\tif (cap_rights_limit(fileno(pcap_file(pd)),\n\t\t\t\t    &rights) < 0 && errno != ENOSYS) {\n\t\t\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t\t\t}\n#endif\n\t\t\t\tnew_dlt = pcap_datalink(pd);\n\t\t\t\tif (new_dlt != dlt) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The new file has a different\n\t\t\t\t\t * link-layer header type from the\n\t\t\t\t\t * previous one.\n\t\t\t\t\t */\n\t\t\t\t\tif (WFileName != NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We're writing raw packets\n\t\t\t\t\t\t * that match the filter to\n\t\t\t\t\t\t * a pcap file.  pcap files\n\t\t\t\t\t\t * don't support multiple\n\t\t\t\t\t\t * different link-layer\n\t\t\t\t\t\t * header types, so we fail\n\t\t\t\t\t\t * here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\terror(\"%s: new dlt does not match original\", RFileName);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We're printing the decoded packets;\n\t\t\t\t\t * switch to the new DLT.\n\t\t\t\t\t *\n\t\t\t\t\t * To do that, we need to change\n\t\t\t\t\t * the printer, change the DLT name,\n\t\t\t\t\t * and recompile the filter with\n\t\t\t\t\t * the new DLT.\n\t\t\t\t\t */\n\t\t\t\t\tdlt = new_dlt;\n\t\t\t\t\tndo->ndo_if_printer = get_if_printer(ndo, dlt);\n\t\t\t\t\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the filter on the new file.\n\t\t\t\t */\n\t\t\t\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\n\t\t\t\t/*\n\t\t\t\t * Report the new file.\n\t\t\t\t */\n\t\t\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\t\t\tif (dlt_name == NULL) {\n\t\t\t\t\tfprintf(stderr, \"reading from file %s, link-type %u\\n\",\n\t\t\t\t\t    RFileName, dlt);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"reading from file %s, link-type %s (%s)\\n\",\n\t\t\t\t\t    RFileName, dlt_name,\n\t\t\t\t\t    pcap_datalink_val_to_description(dlt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (ret != NULL);\n\n\tfree(cmdbuf);\n\tpcap_freecode(&fcode);\n\texit_tcpdump(status == -1 ? 1 : 0);\n}\n\n/* make a clean exit on interrupts */\nstatic RETSIGTYPE\ncleanup(int signo _U_)\n{\n#ifdef USE_WIN32_MM_TIMER\n\tif (timer_id)\n\t\ttimeKillEvent(timer_id);\n\ttimer_id = 0;\n#elif defined(HAVE_ALARM)\n\talarm(0);\n#endif\n\n#ifdef HAVE_PCAP_BREAKLOOP\n\t/*\n\t * We have \"pcap_breakloop()\"; use it, so that we do as little\n\t * as possible in the signal handler (it's probably not safe\n\t * to do anything with standard I/O streams in a signal handler -\n\t * the ANSI C standard doesn't say it is).\n\t */\n\tpcap_breakloop(pd);\n#else\n\t/*\n\t * We don't have \"pcap_breakloop()\"; this isn't safe, but\n\t * it's the best we can do.  Print the summary if we're\n\t * not reading from a savefile - i.e., if we're doing a\n\t * live capture - and exit.\n\t */\n\tif (pd != NULL && pcap_file(pd) == NULL) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t\t(void)fflush(stdout);\n\t\tinfo(1);\n\t}\n\texit_tcpdump(0);\n#endif\n}\n\n/*\n  On windows, we do not use a fork, so we do not care less about\n  waiting a child processes to die\n */\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\nstatic RETSIGTYPE\nchild_cleanup(int signo _U_)\n{\n  wait(NULL);\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ninfo(register int verbose)\n{\n\tstruct pcap_stat stats;\n\n\t/*\n\t * Older versions of libpcap didn't set ps_ifdrop on some\n\t * platforms; initialize it to 0 to handle that.\n\t */\n\tstats.ps_ifdrop = 0;\n\tif (pcap_stats(pd, &stats) < 0) {\n\t\t(void)fprintf(stderr, \"pcap_stats: %s\\n\", pcap_geterr(pd));\n\t\tinfoprint = 0;\n\t\treturn;\n\t}\n\n\tif (!verbose)\n\t\tfprintf(stderr, \"%s: \", program_name);\n\n\t(void)fprintf(stderr, \"%u packet%s captured\", packets_captured,\n\t    PLURAL_SUFFIX(packets_captured));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s received by filter\", stats.ps_recv,\n\t    PLURAL_SUFFIX(stats.ps_recv));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s dropped by kernel\", stats.ps_drop,\n\t    PLURAL_SUFFIX(stats.ps_drop));\n\tif (stats.ps_ifdrop != 0) {\n\t\tif (!verbose)\n\t\t\tfputs(\", \", stderr);\n\t\telse\n\t\t\tputc('\\n', stderr);\n\t\t(void)fprintf(stderr, \"%u packet%s dropped by interface\\n\",\n\t\t    stats.ps_ifdrop, PLURAL_SUFFIX(stats.ps_ifdrop));\n\t} else\n\t\tputc('\\n', stderr);\n\tinfoprint = 0;\n}\n\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n#ifdef HAVE_FORK\n#define fork_subprocess() fork()\n#else\n#define fork_subprocess() vfork()\n#endif\nstatic void\ncompress_savefile(const char *filename)\n{\n\tpid_t child;\n\n\tchild = fork_subprocess();\n\tif (child == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: fork failed: %s\\n\",\n\t\t\tpcap_strerror(errno));\n\t\treturn;\n\t}\n\tif (child != 0) {\n\t\t/* Parent process. */\n\t\treturn;\n\t}\n\n\t/*\n\t * Child process.\n\t * Set to lowest priority so that this doesn't disturb the capture.\n\t */\n#ifdef NZERO\n\tsetpriority(PRIO_PROCESS, 0, NZERO - 1);\n#else\n\tsetpriority(PRIO_PROCESS, 0, 19);\n#endif\n\tif (execlp(zflag, zflag, filename, (char *)NULL) == -1)\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: execlp(%s, %s) failed: %s\\n\",\n\t\t\tzflag,\n\t\t\tfilename,\n\t\t\tpcap_strerror(errno));\n#ifdef HAVE_FORK\n\texit(1);\n#else\n\t_exit(1);\n#endif\n}\n#else  /* HAVE_FORK && HAVE_VFORK */\nstatic void\ncompress_savefile(const char *filename)\n{\n\tfprintf(stderr,\n\t\t\"compress_savefile failed. Functionality not implemented under your system\\n\");\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ndump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\t/*\n\t * XXX - this won't force the file to rotate on the specified time\n\t * boundary, but it will rotate on the first packet received after the\n\t * specified Gflag number of seconds. Note: if a Gflag time boundary\n\t * and a Cflag size boundary coincide, the time rotation will occur\n\t * first thereby cancelling the Cflag boundary (since the file should\n\t * be 0).\n\t */\n\tif (Gflag != 0) {\n\t\t/* Check if it is time to rotate */\n\t\ttime_t t;\n\n\t\t/* Get the current time */\n\t\tif ((t = time(NULL)) == (time_t)-1) {\n\t\t\terror(\"dump_and_trunc_packet: can't get current_time: %s\",\n\t\t\t    pcap_strerror(errno));\n\t\t}\n\n\n\t\t/* If the time is greater than the specified window, rotate */\n\t\tif (t - Gflag_time >= Gflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/* Update the Gflag_time */\n\t\t\tGflag_time = t;\n\t\t\t/* Update Gflag_count */\n\t\t\tGflag_count++;\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user asked for it\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\t/*\n\t\t\t * Check to see if we've exceeded the Wflag (when\n\t\t\t * not using Cflag).\n\t\t\t */\n\t\t\tif (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {\n\t\t\t\t(void)fprintf(stderr, \"Maximum file limit reached: %d\\n\",\n\t\t\t\t    Wflag);\n\t\t\t\tinfo(1);\n\t\t\t\texit_tcpdump(0);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\t/* Allocate space for max filename + \\0. */\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\t/*\n\t\t\t * Gflag was set otherwise we wouldn't be here. Reset the count\n\t\t\t * so multiple files would end with 1,2,3 in the filename.\n\t\t\t * The counting is handled with the -C flow after this.\n\t\t\t */\n\t\t\tCflag_count = 0;\n\n\t\t\t/*\n\t\t\t * This is always the first file in the Cflag\n\t\t\t * rotation: e.g. 0\n\t\t\t * We also don't need numbering if Cflag is not set.\n\t\t\t */\n\t\t\tif (Cflag != 0)\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,\n\t\t\t\t    WflagChars);\n\t\t\telse\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);\n\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd,\n\t\t\t    dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * XXX - this won't prevent capture files from getting\n\t * larger than Cflag - the last packet written to the\n\t * file could put it over Cflag.\n\t */\n\tif (Cflag != 0) {\n\t\tlong size = pcap_dump_ftell(dump_info->p);\n\n\t\tif (size == -1)\n\t\t\terror(\"ftell fails on output file\");\n\t\tif (size > Cflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user\n\t\t\t * asked for it.\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\tCflag_count++;\n\t\t\tif (Wflag > 0) {\n\t\t\t\tif (Cflag_count >= Wflag)\n\t\t\t\t\tCflag_count = 0;\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd, dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\tpcap_dump((u_char *)dump_info->p, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->p);\n#endif\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\ndump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\t++packets_captured;\n\n\t++infodelay;\n\n\tpcap_dump(user, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush((pcap_dumper_t *)user);\n#endif\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\nprint_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\t++packets_captured;\n\n\t++infodelay;\n\n\tpretty_print_packet((netdissect_options *)user, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\n#ifdef _WIN32\n\t/*\n\t * XXX - there should really be libpcap calls to get the version\n\t * number as a string (the string would be generated from #defines\n\t * at run time, so that it's not generated from string constants\n\t * in the library, as, on many UNIX systems, those constants would\n\t * be statically linked into the application executable image, and\n\t * would thus reflect the version of libpcap on the system on\n\t * which the application was *linked*, not the system on which it's\n\t * *running*.\n\t *\n\t * That routine should be documented, unlike the \"version[]\"\n\t * string, so that UNIX vendors providing their own libpcaps\n\t * don't omit it (as a couple of vendors have...).\n\t *\n\t * Packet.dll should perhaps also export a routine to return the\n\t * version number of the Packet.dll code, to supply the\n\t * \"Wpcap_version\" information on Windows.\n\t */\n\tchar WDversion[]=\"current-git.tcpdump.org\";\n#if !defined(HAVE_GENERATED_VERSION)\n\tchar version[]=\"current-git.tcpdump.org\";\n#endif\n\tchar pcap_version[]=\"current-git.tcpdump.org\";\n\tchar Wpcap_version[]=\"3.1\";\n#endif\n\n#ifdef SIGNAL_REQ_INFO\nRETSIGTYPE requestinfo(int signo _U_)\n{\n\tif (infodelay)\n\t\t++infoprint;\n\telse\n\t\tinfo(0);\n}\n#endif\n\n/*\n * Called once each second in verbose mode while dumping to file\n */\n#ifdef USE_WIN32_MM_TIMER\nvoid CALLBACK verbose_stats_dump (UINT timer_id _U_, UINT msg _U_, DWORD_PTR arg _U_,\n\t\t\t\t  DWORD_PTR dw1 _U_, DWORD_PTR dw2 _U_)\n{\n\tif (infodelay == 0)\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n}\n#elif defined(HAVE_ALARM)\nstatic void verbose_stats_dump(int sig _U_)\n{\n\tif (infodelay == 0)\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n\talarm(1);\n}\n#endif\n\nUSES_APPLE_DEPRECATED_API\nstatic void\nprint_version(void)\n{\n\textern char version[];\n#ifndef HAVE_PCAP_LIB_VERSION\n#if defined(_WIN32) || defined(HAVE_PCAP_VERSION)\n\textern char pcap_version[];\n#else /* defined(_WIN32) || defined(HAVE_PCAP_VERSION) */\n\tstatic char pcap_version[] = \"unknown\";\n#endif /* defined(_WIN32) || defined(HAVE_PCAP_VERSION) */\n#endif /* HAVE_PCAP_LIB_VERSION */\n\tconst char *smi_version_string;\n\n#ifdef HAVE_PCAP_LIB_VERSION\n#ifdef _WIN32\n\t(void)fprintf(stderr, \"%s version %s, based on tcpdump version %s\\n\", program_name, WDversion, version);\n#else /* _WIN32 */\n\t(void)fprintf(stderr, \"%s version %s\\n\", program_name, version);\n#endif /* _WIN32 */\n\t(void)fprintf(stderr, \"%s\\n\",pcap_lib_version());\n#else /* HAVE_PCAP_LIB_VERSION */\n#ifdef _WIN32\n\t(void)fprintf(stderr, \"%s version %s, based on tcpdump version %s\\n\", program_name, WDversion, version);\n\t(void)fprintf(stderr, \"WinPcap version %s, based on libpcap version %s\\n\",Wpcap_version, pcap_version);\n#else /* _WIN32 */\n\t(void)fprintf(stderr, \"%s version %s\\n\", program_name, version);\n\t(void)fprintf(stderr, \"libpcap version %s\\n\", pcap_version);\n#endif /* _WIN32 */\n#endif /* HAVE_PCAP_LIB_VERSION */\n\n#if defined(HAVE_LIBCRYPTO) && defined(SSLEAY_VERSION)\n\t(void)fprintf (stderr, \"%s\\n\", SSLeay_version(SSLEAY_VERSION));\n#endif\n\n\tsmi_version_string = nd_smi_version_string();\n\tif (smi_version_string != NULL)\n\t\t(void)fprintf (stderr, \"SMI-library: %s\\n\", smi_version_string);\n\n#if defined(__SANITIZE_ADDRESS__)\n\t(void)fprintf (stderr, \"Compiled with AddressSanitizer/GCC.\\n\");\n#elif defined(__has_feature)\n#  if __has_feature(address_sanitizer)\n\t(void)fprintf (stderr, \"Compiled with AddressSanitizer/CLang.\\n\");\n#  endif\n#endif /* __SANITIZE_ADDRESS__ or __has_feature */\n}\nUSES_APPLE_RST\n\nstatic void\nprint_usage(void)\n{\n\tprint_version();\n\t(void)fprintf(stderr,\n\"Usage: %s [-aAbd\" D_FLAG \"efhH\" I_FLAG J_FLAG \"KlLnNOpqStu\" U_FLAG \"vxX#]\" B_FLAG_USAGE \" [ -c count ]\\n\", program_name);\n\t(void)fprintf(stderr,\n\"\\t\\t[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t[ -i interface ]\" j_FLAG_USAGE \" [ -M secret ] [ --number ]\\n\");\n#ifdef HAVE_PCAP_SETDIRECTION\n\t(void)fprintf(stderr,\n\"\\t\\t[ -Q in|out|inout ]\\n\");\n#endif\n\t(void)fprintf(stderr,\n\"\\t\\t[ -r file ] [ -s snaplen ] \");\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t(void)fprintf(stderr, \"[ --time-stamp-precision precision ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t\");\n#endif\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t(void)fprintf(stderr, \"[ --immediate-mode ] \");\n#endif\n\t(void)fprintf(stderr, \"[ -T type ] [ --version ] [ -V file ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t[ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]\\n\");\n\t(void)fprintf(stderr,\n\"\\t\\t[ -Z user ] [ expression ]\\n\");\n}\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n"], "filenames": ["tcpdump.c"], "buggy_code_start_loc": [701], "buggy_code_end_loc": [709], "fixing_code_start_loc": [702], "fixing_code_end_loc": [711], "type": "CWE-120", "message": "The command-line argument parser in tcpdump before 4.9.3 has a buffer overflow in tcpdump.c:get_next_file().", "other": {"cve": {"id": "CVE-2018-14879", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-03T16:15:12.133", "lastModified": "2020-01-20T13:15:14.280", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The command-line argument parser in tcpdump before 4.9.3 has a buffer overflow in tcpdump.c:get_next_file()."}, {"lang": "es", "value": "El analizador de argumentos de la l\u00ednea de comandos en tcpdump versiones anteriores a 4.9.3, presenta un desbordamiento de b\u00fafer en tcpdump.c:get_next_file()."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:f5:traffix_sdc:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndIncluding": "5.1.0", "matchCriteriaId": "7243F50D-6EF8-4702-92C2-F512DC8E5C00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.3", "matchCriteriaId": "CA59BD9C-6C0C-4584-A8CC-8C652E9D36AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.15.2", "matchCriteriaId": "F15588EA-D854-4694-97C6-53D9AA8B6F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00050.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00053.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2019/Dec/26", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/blob/tcpdump-4.9/CHANGES", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/62XY42U6HY3H2APR5EHNWCZ7SAQNMMJN/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNYXF3IY2X65IOD422SA6EQUULSGW7FN/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R2UDPOSGVJQIYC33SQBXMDXHH4QDSDMU/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Dec/23", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Oct/28", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200120-0001/", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210788", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K51512510?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4252-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4252-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4547", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6"}}