{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.oidc.auth.internal;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.joda.time.LocalDateTime;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.Session;\nimport org.xwiki.container.servlet.ServletSession;\nimport org.xwiki.contrib.oidc.OIDCIdToken;\nimport org.xwiki.contrib.oidc.OIDCUserInfo;\nimport org.xwiki.contrib.oidc.internal.OIDCConfiguration;\nimport org.xwiki.contrib.oidc.provider.internal.OIDCManager;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.AuthorizationOIDCEndpoint;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.LogoutOIDCEndpoint;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.TokenOIDCEndpoint;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.UserInfoOIDCEndpoint;\nimport org.xwiki.instance.InstanceIdManager;\nimport org.xwiki.properties.ConverterManager;\n\nimport com.nimbusds.oauth2.sdk.Scope;\nimport com.nimbusds.oauth2.sdk.auth.ClientAuthenticationMethod;\nimport com.nimbusds.oauth2.sdk.auth.Secret;\nimport com.nimbusds.oauth2.sdk.http.HTTPRequest;\nimport com.nimbusds.oauth2.sdk.id.ClientID;\nimport com.nimbusds.oauth2.sdk.token.BearerAccessToken;\nimport com.nimbusds.openid.connect.sdk.OIDCClaimsRequest;\nimport com.nimbusds.openid.connect.sdk.OIDCScopeValue;\nimport com.nimbusds.openid.connect.sdk.claims.ClaimsSetRequest;\nimport com.nimbusds.openid.connect.sdk.claims.IDTokenClaimsSet;\n\n/**\n * Various OpenID Connect authenticator configurations.\n * \n * @version $Id$\n */\n@Component(roles = OIDCClientConfiguration.class)\n@Singleton\npublic class OIDCClientConfiguration extends OIDCConfiguration\n{\n    public class GroupMapping\n    {\n        private final Map<String, Set<String>> xwikiMapping;\n\n        private final Map<String, Set<String>> providerMapping;\n\n        public GroupMapping(int size)\n        {\n            this.xwikiMapping = new HashMap<>(size);\n            this.providerMapping = new HashMap<>(size);\n        }\n\n        public Set<String> fromXWiki(String xwikiGroup)\n        {\n            return this.xwikiMapping.get(xwikiGroup);\n        }\n\n        public Set<String> fromProvider(String providerGroup)\n        {\n            return this.providerMapping.get(providerGroup);\n        }\n\n        public Map<String, Set<String>> getXWikiMapping()\n        {\n            return this.xwikiMapping;\n        }\n\n        public Map<String, Set<String>> getProviderMapping()\n        {\n            return this.providerMapping;\n        }\n    }\n\n    public static final String PROP_XWIKIPROVIDER = \"oidc.xwikiprovider\";\n\n    public static final String PROP_USER_NAMEFORMATER = \"oidc.user.nameFormater\";\n\n    public static final String DEFAULT_USER_NAMEFORMATER =\n        \"${oidc.issuer.host._clean}-${oidc.user.preferredUsername._clean}\";\n\n    /**\n     * @since 1.11\n     */\n    public static final String PROP_USER_SUBJECTFORMATER = \"oidc.user.subjectFormater\";\n\n    /**\n     * @since 1.18\n     */\n    public static final String PROP_USER_MAPPING = \"oidc.user.mapping\";\n\n    /**\n     * @since 1.11\n     */\n    public static final String DEFAULT_USER_SUBJECTFORMATER = \"${oidc.user.subject}\";\n\n    public static final String PROPPREFIX_ENDPOINT = \"oidc.endpoint.\";\n\n    public static final String PROP_ENDPOINT_AUTHORIZATION = PROPPREFIX_ENDPOINT + AuthorizationOIDCEndpoint.HINT;\n\n    public static final String PROP_ENDPOINT_TOKEN = PROPPREFIX_ENDPOINT + TokenOIDCEndpoint.HINT;\n\n    public static final String PROP_ENDPOINT_USERINFO = PROPPREFIX_ENDPOINT + UserInfoOIDCEndpoint.HINT;\n\n    /**\n     * @since 1.21\n     */\n    public static final String PROP_ENDPOINT_LOGOUT = PROPPREFIX_ENDPOINT + LogoutOIDCEndpoint.HINT;\n\n    public static final String PROP_CLIENTID = \"oidc.clientid\";\n\n    /**\n     * @since 1.13\n     */\n    public static final String PROP_SECRET = \"oidc.secret\";\n\n    public static final String PROP_SKIPPED = \"oidc.skipped\";\n\n    /**\n     * @since 1.13\n     */\n    public static final String PROP_ENDPOINT_TOKEN_AUTH_METHOD =\n        PROPPREFIX_ENDPOINT + TokenOIDCEndpoint.HINT + \".auth_method\";\n\n    /**\n     * @since 1.13\n     */\n    public static final String PROP_ENDPOINT_USERINFO_METHOD =\n        PROPPREFIX_ENDPOINT + UserInfoOIDCEndpoint.HINT + \".method\";\n\n    /**\n     * @since 1.22\n     */\n    public static final String PROP_ENDPOINT_USERINFO_HEADERS =\n        PROPPREFIX_ENDPOINT + UserInfoOIDCEndpoint.HINT + \".headers\";\n\n    /**\n     * @since 1.21\n     */\n    public static final String PROP_ENDPOINT_LOGOUT_METHOD = PROPPREFIX_ENDPOINT + LogoutOIDCEndpoint.HINT + \".method\";\n\n    /**\n     * @since 1.12\n     */\n    public static final String PROP_USERINFOREFRESHRATE = \"oidc.userinforefreshrate\";\n\n    /**\n     * @since 1.16\n     */\n    public static final String PROP_SCOPE = \"oidc.scope\";\n\n    public static final String PROP_USERINFOCLAIMS = \"oidc.userinfoclaims\";\n\n    public static final List<String> DEFAULT_USERINFOCLAIMS = Arrays.asList(OIDCUserInfo.CLAIM_XWIKI_ACCESSIBILITY,\n        OIDCUserInfo.CLAIM_XWIKI_COMPANY, OIDCUserInfo.CLAIM_XWIKI_DISPLAYHIDDENDOCUMENTS,\n        OIDCUserInfo.CLAIM_XWIKI_EDITOR, OIDCUserInfo.CLAIM_XWIKI_USERTYPE);\n\n    public static final String PROP_IDTOKENCLAIMS = \"oidc.idtokenclaims\";\n\n    public static final List<String> DEFAULT_IDTOKENCLAIMS = Arrays.asList(OIDCIdToken.CLAIM_XWIKI_INSTANCE_ID);\n\n    /**\n     * @since 1.10\n     */\n    public static final String PROP_GROUPS_MAPPING = \"oidc.groups.mapping\";\n\n    /**\n     * @since 1.10\n     */\n    public static final String PROP_GROUPS_ALLOWED = \"oidc.groups.allowed\";\n\n    /**\n     * @since 1.10\n     */\n    public static final String PROP_GROUPS_FORBIDDEN = \"oidc.groups.forbidden\";\n\n    /**\n     * @since 1.27\n     */\n    public static final String PROP_GROUPS_PREFIX = \"oidc.groups.prefix\";\n\n    /**\n     * @since 1.27\n     */\n    public static final String PROP_GROUPS_SEPARATOR = \"oidc.groups.separator\";\n\n    public static final String PROP_INITIAL_REQUEST = \"xwiki.initialRequest\";\n\n    public static final String PROP_STATE = \"oidc.state\";\n\n    public static final String PROP_SESSION_ACCESSTOKEN = \"oidc.accesstoken\";\n\n    public static final String PROP_SESSION_IDTOKEN = \"oidc.idtoken\";\n\n    public static final String PROP_SESSION_USERINFO_EXPORATIONDATE = \"oidc.session.userinfoexpirationdate\";\n\n    private static final String XWIKI_GROUP_PREFIX = \"XWiki.\";\n\n    @Inject\n    private InstanceIdManager instance;\n\n    @Inject\n    private OIDCManager manager;\n\n    @Inject\n    private Container container;\n\n    @Inject\n    private ConverterManager converter;\n\n    @Inject\n    private Logger logger;\n\n    @Inject\n    // TODO: store configuration in custom objects\n    private ConfigurationSource configuration;\n\n    private HttpSession getHttpSession()\n    {\n        Session session = this.container.getSession();\n        if (session instanceof ServletSession) {\n            HttpSession httpSession = ((ServletSession) session).getHttpSession();\n\n            this.logger.debug(\"Session: {}\", httpSession.getId());\n\n            return httpSession;\n        }\n\n        return null;\n    }\n\n    private <T> T getSessionAttribute(String name)\n    {\n        HttpSession session = getHttpSession();\n        if (session != null) {\n            return (T) session.getAttribute(name);\n        }\n\n        return null;\n    }\n\n    private <T> T removeSessionAttribute(String name)\n    {\n        HttpSession session = getHttpSession();\n        if (session != null) {\n            try {\n                return (T) session.getAttribute(name);\n            } finally {\n                session.removeAttribute(name);\n            }\n        }\n\n        return null;\n    }\n\n    private void setSessionAttribute(String name, Object value)\n    {\n        HttpSession session = getHttpSession();\n        if (session != null) {\n            session.setAttribute(name, value);\n        }\n    }\n\n    private String getRequestParameter(String key)\n    {\n        Request request = this.container.getRequest();\n        if (request != null) {\n            return (String) request.getProperty(key);\n        }\n\n        return null;\n    }\n\n    public Map<String, String> getMap(String key)\n    {\n        List<String> list = getProperty(key, List.class);\n\n        Map<String, String> mapping;\n\n        if (list != null && !list.isEmpty()) {\n            mapping = new HashMap<>(list.size());\n\n            for (String listItem : list) {\n                int index = listItem.indexOf('=');\n\n                if (index != -1) {\n                    mapping.put(listItem.substring(0, index), listItem.substring(index + 1));\n                }\n            }\n        } else {\n            mapping = null;\n        }\n\n        return mapping;\n    }\n\n    @Override\n    protected <T> T getProperty(String key, Class<T> valueClass)\n    {\n        // Get property from request\n        String requestValue = getRequestParameter(key);\n        if (requestValue != null) {\n            return this.converter.convert(valueClass, requestValue);\n        }\n\n        // Get property from session\n        T sessionValue = getSessionAttribute(key);\n        if (sessionValue != null) {\n            return sessionValue;\n        }\n\n        // Get property from configuration\n        return this.configuration.getProperty(key, valueClass);\n    }\n\n    @Override\n    protected <T> T getProperty(String key, T def)\n    {\n        // Get property from request\n        String requestValue = getRequestParameter(key);\n        if (requestValue != null) {\n            return this.converter.convert(def.getClass(), requestValue);\n        }\n\n        // Get property from session\n        T sessionValue = getSessionAttribute(key);\n        if (sessionValue != null) {\n            return sessionValue;\n        }\n\n        // Get property from configuration\n        return this.configuration.getProperty(key, def);\n    }\n\n    /**\n     * @since 1.18\n     */\n    public String getSubjectFormater()\n    {\n        String userFormatter = getProperty(PROP_USER_SUBJECTFORMATER, String.class);\n        if (userFormatter == null) {\n            userFormatter = DEFAULT_USER_SUBJECTFORMATER;\n        }\n\n        return userFormatter;\n    }\n\n    /**\n     * @since 1.11\n     */\n    public String getXWikiUserNameFormater()\n    {\n        String userFormatter = getProperty(PROP_USER_NAMEFORMATER, String.class);\n        if (userFormatter == null) {\n            userFormatter = DEFAULT_USER_NAMEFORMATER;\n        }\n\n        return userFormatter;\n    }\n\n    /**\n     * @since 1.18\n     */\n    public Map<String, String> getUserMapping()\n    {\n        return getMap(PROP_USER_MAPPING);\n    }\n\n    public URL getXWikiProvider()\n    {\n        return getProperty(PROP_XWIKIPROVIDER, URL.class);\n    }\n\n    private Endpoint getEndPoint(String hint) throws URISyntaxException\n    {\n        // TODO: use URI directly when upgrading to a version of XWiki providing a URI converter\n        String uriString = getProperty(PROPPREFIX_ENDPOINT + hint, String.class);\n\n        // If no direct endpoint is provider assume it's a XWiki OIDC provider and generate the endpoint from the hint\n        URI uri;\n        if (uriString == null) {\n            if (getProperty(PROP_XWIKIPROVIDER, String.class) != null) {\n                uri = this.manager.createEndPointURI(getXWikiProvider().toString(), hint);\n            } else {\n                uri = null;\n            }\n        } else {\n            uri = new URI(uriString);\n        }\n\n        // If we still don't have any endpoint URI, return null\n        if (uri == null) {\n            return null;\n        }\n\n        // Find custom headers\n        Map<String, List<String>> headers = new LinkedHashMap<>();\n\n        List<String> entries = getProperty(PROPPREFIX_ENDPOINT + hint + \".headers\", List.class);\n        if (entries != null) {\n            for (String entry : entries) {\n                int index = entry.indexOf(':');\n\n                if (index > 0 && index < entry.length() - 1) {\n                    headers.computeIfAbsent(entry.substring(0, index), key -> new ArrayList<>())\n                        .add(entry.substring(index + 1));\n                }\n            }\n        }\n\n        return new Endpoint(uri, headers);\n    }\n\n    public Endpoint getAuthorizationOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(AuthorizationOIDCEndpoint.HINT);\n    }\n\n    public Endpoint getTokenOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(TokenOIDCEndpoint.HINT);\n    }\n\n    public Endpoint getUserInfoOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(UserInfoOIDCEndpoint.HINT);\n    }\n\n    /**\n     * @since 1.21\n     */\n    public Endpoint getLogoutOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(LogoutOIDCEndpoint.HINT);\n    }\n\n    public ClientID getClientID()\n    {\n        String clientId = getProperty(PROP_CLIENTID, String.class);\n\n        // Fallback on instance id\n        return new ClientID(clientId != null ? clientId : this.instance.getInstanceId().getInstanceId());\n    }\n\n    /**\n     * @since 1.13\n     */\n    public Secret getSecret()\n    {\n        String secret = getProperty(PROP_SECRET, String.class);\n        if (StringUtils.isBlank(secret)) {\n            return null;\n        } else {\n            return new Secret(secret);\n        }\n    }\n\n    /**\n     * @since 1.13\n     */\n    public ClientAuthenticationMethod getTokenEndPointAuthMethod()\n    {\n        String authMethod = getProperty(PROP_ENDPOINT_TOKEN_AUTH_METHOD, String.class);\n        if (\"client_secret_post\".equalsIgnoreCase(authMethod)) {\n            return ClientAuthenticationMethod.CLIENT_SECRET_POST;\n        } else {\n            return ClientAuthenticationMethod.CLIENT_SECRET_BASIC;\n        }\n    }\n\n    /**\n     * @since 1.13\n     */\n    public HTTPRequest.Method getUserInfoEndPointMethod()\n    {\n        return getProperty(PROP_ENDPOINT_USERINFO_METHOD, HTTPRequest.Method.GET);\n    }\n\n    /**\n     * @since 1.21\n     */\n    public HTTPRequest.Method getLogoutEndPointMethod()\n    {\n        return getProperty(PROP_ENDPOINT_LOGOUT_METHOD, HTTPRequest.Method.GET);\n    }\n\n    public String getSessionState()\n    {\n        return getSessionAttribute(PROP_STATE);\n    }\n\n    public boolean isSkipped()\n    {\n        return getProperty(PROP_SKIPPED, false);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public OIDCClaimsRequest getClaimsRequest()\n    {\n        // TODO: allow passing the complete JSON as configuration\n        OIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n\n        // ID Token claims\n        List<String> idtokenclaims = getIDTokenClaims();\n        if (idtokenclaims != null && !idtokenclaims.isEmpty()) {\n            ClaimsSetRequest idtokenclaimsRequest = new ClaimsSetRequest();\n\n            for (String claim : idtokenclaims) {\n                idtokenclaimsRequest.add(claim);\n            }\n\n            claimsRequest.withIDTokenClaimsRequest(idtokenclaimsRequest);\n        }\n\n        // UserInfo claims\n        List<String> userinfoclaims = getUserInfoClaims();\n        if (userinfoclaims != null && !userinfoclaims.isEmpty()) {\n            ClaimsSetRequest userinfoclaimsRequest = new ClaimsSetRequest();\n\n            for (String claim : userinfoclaims) {\n                userinfoclaimsRequest.add(claim);\n            }\n\n            claimsRequest.withUserInfoClaimsRequest(userinfoclaimsRequest);\n        }\n\n        return claimsRequest;\n    }\n\n    /**\n     * @since 1.2\n     */\n    public List<String> getIDTokenClaims()\n    {\n        return getProperty(PROP_IDTOKENCLAIMS, DEFAULT_IDTOKENCLAIMS);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public List<String> getUserInfoClaims()\n    {\n        return getProperty(PROP_USERINFOCLAIMS, DEFAULT_USERINFOCLAIMS);\n    }\n\n    /**\n     * @since 1.12\n     */\n    public int getUserInfoRefreshRate()\n    {\n        return getProperty(PROP_USERINFOREFRESHRATE, 600000);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public Scope getScope()\n    {\n        List<String> scopeValues = getProperty(PROP_SCOPE, List.class);\n\n        if (CollectionUtils.isEmpty(scopeValues)) {\n            return new Scope(OIDCScopeValue.OPENID, OIDCScopeValue.PROFILE, OIDCScopeValue.EMAIL,\n                OIDCScopeValue.ADDRESS, OIDCScopeValue.PHONE);\n        }\n\n        return new Scope(scopeValues.toArray(new String[0]));\n    }\n\n    /**\n     * @since 1.10\n     */\n    public GroupMapping getGroupMapping()\n    {\n        List<String> groupsMapping = getProperty(PROP_GROUPS_MAPPING, List.class);\n\n        GroupMapping groups;\n\n        if (groupsMapping != null && !groupsMapping.isEmpty()) {\n            groups = new GroupMapping(groupsMapping.size());\n\n            for (String groupMapping : groupsMapping) {\n                int index = groupMapping.indexOf('=');\n\n                if (index != -1) {\n                    String xwikiGroup = toXWikiGroup(groupMapping.substring(0, index));\n                    String providerGroup = groupMapping.substring(index + 1);\n\n                    // Add to XWiki mapping\n                    Set<String> providerGroups = groups.xwikiMapping.computeIfAbsent(xwikiGroup, k -> new HashSet<>());\n                    providerGroups.add(providerGroup);\n\n                    // Add to provider mapping\n                    Set<String> xwikiGroups =\n                        groups.providerMapping.computeIfAbsent(providerGroup, k -> new HashSet<>());\n                    xwikiGroups.add(xwikiGroup);\n                }\n            }\n        } else {\n            groups = null;\n        }\n\n        return groups;\n    }\n\n    /**\n     * @since 1.10\n     */\n    public String toXWikiGroup(String group)\n    {\n        return group.startsWith(XWIKI_GROUP_PREFIX) ? group : XWIKI_GROUP_PREFIX + group;\n    }\n\n    /**\n     * @since 1.10\n     */\n    public List<String> getAllowedGroups()\n    {\n        List<String> groups = getProperty(PROP_GROUPS_ALLOWED, List.class);\n\n        return groups != null && !groups.isEmpty() ? groups : null;\n    }\n\n    /**\n     * @since 1.10\n     */\n    public List<String> getForbiddenGroups()\n    {\n        List<String> groups = getProperty(PROP_GROUPS_FORBIDDEN, List.class);\n\n        return groups != null && !groups.isEmpty() ? groups : null;\n    }\n\n    /**\n     * @since 1.27\n     */\n    public String getGroupPrefix()\n    {\n        String groupPrefix = getProperty(PROP_GROUPS_PREFIX, String.class);\n        return groupPrefix != null && !groupPrefix.isEmpty() ? groupPrefix : null;\n    }\n\n    /**\n     * @since 1.27\n     */\n    public String getGroupSeparator()\n    {\n        return getProperty(PROP_GROUPS_SEPARATOR, String.class);\n    }\n\n    // Session only\n\n    /**\n     * @since 1.2\n     */\n    public Date removeUserInfoExpirationDate()\n    {\n        return removeSessionAttribute(PROP_SESSION_USERINFO_EXPORATIONDATE);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setUserInfoExpirationDate(Date date)\n    {\n        setSessionAttribute(PROP_SESSION_USERINFO_EXPORATIONDATE, date);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void resetUserInfoExpirationDate()\n    {\n        LocalDateTime expiration = LocalDateTime.now().plusMillis(getUserInfoRefreshRate());\n\n        setUserInfoExpirationDate(expiration.toDate());\n    }\n\n    /**\n     * @since 1.2\n     */\n    public BearerAccessToken getAccessToken()\n    {\n        return getSessionAttribute(PROP_SESSION_ACCESSTOKEN);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setAccessToken(BearerAccessToken accessToken)\n    {\n        setSessionAttribute(PROP_SESSION_ACCESSTOKEN, accessToken);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public IDTokenClaimsSet getIdToken()\n    {\n        return getSessionAttribute(PROP_SESSION_IDTOKEN);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setIdToken(IDTokenClaimsSet idToken)\n    {\n        setSessionAttribute(PROP_SESSION_IDTOKEN, idToken);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public URI getSuccessRedirectURI()\n    {\n        URI uri = getSessionAttribute(PROP_INITIAL_REQUEST);\n        if (uri == null) {\n            // TODO: return wiki hope page\n        }\n\n        return uri;\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setSuccessRedirectURI(URI uri)\n    {\n        setSessionAttribute(PROP_INITIAL_REQUEST, uri);\n    }\n\n    /**\n     * @return true if groups should be synchronized (in which case if the provider does not answer to the group claim\n     *         it means the user does not belong to any group)\n     * @since 1.14\n     */\n    public boolean isGroupSync()\n    {\n        String groupClaim = getGroupClaim();\n\n        return getUserInfoClaims().contains(groupClaim);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.oidc.auth.internal;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.when;\n\n/**\n * Validate {@link OIDCClientConfiguration}.\n * \n * @version $Id$\n */\n@ComponentTest\nclass OIDCClientConfigurationTest\n{\n    @InjectMockComponents\n    private OIDCClientConfiguration configuration;\n\n    @MockComponent\n    private ConfigurationSource sourceConfiguration;\n\n    @Test\n    void getUserInfoOIDCEndpoint() throws URISyntaxException\n    {\n        assertNull(this.configuration.getUserInfoOIDCEndpoint());\n\n        URI uri = new URI(\"/endpoint\");\n        when(this.sourceConfiguration.getProperty(OIDCClientConfiguration.PROP_ENDPOINT_USERINFO, String.class))\n            .thenReturn(uri.toString());\n\n        Endpoint endpoint = this.configuration.getUserInfoOIDCEndpoint();\n\n        assertEquals(uri, endpoint.getURI());\n        assertTrue(endpoint.getHeaders().isEmpty());\n\n        List<String> list = Arrays.asList(\"key1:value11\", \"key1:value12\", \"key2:value2\", \"alone\", \":\", \"\");\n\n        when(this.sourceConfiguration.getProperty(OIDCClientConfiguration.PROP_ENDPOINT_USERINFO_HEADERS, List.class))\n            .thenReturn(list);\n\n        Map<String, List<String>> headers = new LinkedHashMap<>();\n        headers.put(\"key1\", Arrays.asList(\"value11\", \"value12\"));\n        headers.put(\"key2\", Arrays.asList(\"value2\"));\n\n        endpoint = this.configuration.getUserInfoOIDCEndpoint();\n\n        assertEquals(uri, endpoint.getURI());\n        assertEquals(headers, endpoint.getHeaders());\n\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.oidc.auth.internal;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.SetUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.joda.time.LocalDateTime;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.Session;\nimport org.xwiki.container.servlet.ServletSession;\nimport org.xwiki.contrib.oidc.OIDCIdToken;\nimport org.xwiki.contrib.oidc.OIDCUserInfo;\nimport org.xwiki.contrib.oidc.internal.OIDCConfiguration;\nimport org.xwiki.contrib.oidc.provider.internal.OIDCManager;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.AuthorizationOIDCEndpoint;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.LogoutOIDCEndpoint;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.TokenOIDCEndpoint;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.UserInfoOIDCEndpoint;\nimport org.xwiki.instance.InstanceIdManager;\nimport org.xwiki.properties.ConverterManager;\n\nimport com.nimbusds.oauth2.sdk.Scope;\nimport com.nimbusds.oauth2.sdk.auth.ClientAuthenticationMethod;\nimport com.nimbusds.oauth2.sdk.auth.Secret;\nimport com.nimbusds.oauth2.sdk.http.HTTPRequest;\nimport com.nimbusds.oauth2.sdk.id.ClientID;\nimport com.nimbusds.oauth2.sdk.token.BearerAccessToken;\nimport com.nimbusds.openid.connect.sdk.OIDCClaimsRequest;\nimport com.nimbusds.openid.connect.sdk.OIDCScopeValue;\nimport com.nimbusds.openid.connect.sdk.claims.ClaimsSetRequest;\nimport com.nimbusds.openid.connect.sdk.claims.IDTokenClaimsSet;\n\n/**\n * Various OpenID Connect authenticator configurations.\n * \n * @version $Id$\n */\n@Component(roles = OIDCClientConfiguration.class)\n@Singleton\npublic class OIDCClientConfiguration extends OIDCConfiguration\n{\n    public class GroupMapping\n    {\n        private final Map<String, Set<String>> xwikiMapping;\n\n        private final Map<String, Set<String>> providerMapping;\n\n        public GroupMapping(int size)\n        {\n            this.xwikiMapping = new HashMap<>(size);\n            this.providerMapping = new HashMap<>(size);\n        }\n\n        public Set<String> fromXWiki(String xwikiGroup)\n        {\n            return this.xwikiMapping.get(xwikiGroup);\n        }\n\n        public Set<String> fromProvider(String providerGroup)\n        {\n            return this.providerMapping.get(providerGroup);\n        }\n\n        public Map<String, Set<String>> getXWikiMapping()\n        {\n            return this.xwikiMapping;\n        }\n\n        public Map<String, Set<String>> getProviderMapping()\n        {\n            return this.providerMapping;\n        }\n    }\n\n    public static final String PROP_XWIKIPROVIDER = \"oidc.xwikiprovider\";\n\n    public static final String PROP_USER_NAMEFORMATER = \"oidc.user.nameFormater\";\n\n    public static final String DEFAULT_USER_NAMEFORMATER =\n        \"${oidc.issuer.host._clean}-${oidc.user.preferredUsername._clean}\";\n\n    /**\n     * @since 1.11\n     */\n    public static final String PROP_USER_SUBJECTFORMATER = \"oidc.user.subjectFormater\";\n\n    /**\n     * @since 1.18\n     */\n    public static final String PROP_USER_MAPPING = \"oidc.user.mapping\";\n\n    /**\n     * @since 1.11\n     */\n    public static final String DEFAULT_USER_SUBJECTFORMATER = \"${oidc.user.subject}\";\n\n    public static final String PROPPREFIX_ENDPOINT = \"oidc.endpoint.\";\n\n    public static final String PROP_ENDPOINT_AUTHORIZATION = PROPPREFIX_ENDPOINT + AuthorizationOIDCEndpoint.HINT;\n\n    public static final String PROP_ENDPOINT_TOKEN = PROPPREFIX_ENDPOINT + TokenOIDCEndpoint.HINT;\n\n    public static final String PROP_ENDPOINT_USERINFO = PROPPREFIX_ENDPOINT + UserInfoOIDCEndpoint.HINT;\n\n    /**\n     * @since 1.21\n     */\n    public static final String PROP_ENDPOINT_LOGOUT = PROPPREFIX_ENDPOINT + LogoutOIDCEndpoint.HINT;\n\n    public static final String PROP_CLIENTID = \"oidc.clientid\";\n\n    /**\n     * @since 1.13\n     */\n    public static final String PROP_SECRET = \"oidc.secret\";\n\n    public static final String PROP_SKIPPED = \"oidc.skipped\";\n\n    /**\n     * @since 1.13\n     */\n    public static final String PROP_ENDPOINT_TOKEN_AUTH_METHOD =\n        PROPPREFIX_ENDPOINT + TokenOIDCEndpoint.HINT + \".auth_method\";\n\n    /**\n     * @since 1.13\n     */\n    public static final String PROP_ENDPOINT_USERINFO_METHOD =\n        PROPPREFIX_ENDPOINT + UserInfoOIDCEndpoint.HINT + \".method\";\n\n    /**\n     * @since 1.22\n     */\n    public static final String PROP_ENDPOINT_USERINFO_HEADERS =\n        PROPPREFIX_ENDPOINT + UserInfoOIDCEndpoint.HINT + \".headers\";\n\n    /**\n     * @since 1.21\n     */\n    public static final String PROP_ENDPOINT_LOGOUT_METHOD = PROPPREFIX_ENDPOINT + LogoutOIDCEndpoint.HINT + \".method\";\n\n    /**\n     * @since 1.12\n     */\n    public static final String PROP_USERINFOREFRESHRATE = \"oidc.userinforefreshrate\";\n\n    /**\n     * @since 1.16\n     */\n    public static final String PROP_SCOPE = \"oidc.scope\";\n\n    public static final String PROP_USERINFOCLAIMS = \"oidc.userinfoclaims\";\n\n    public static final List<String> DEFAULT_USERINFOCLAIMS = Arrays.asList(OIDCUserInfo.CLAIM_XWIKI_ACCESSIBILITY,\n        OIDCUserInfo.CLAIM_XWIKI_COMPANY, OIDCUserInfo.CLAIM_XWIKI_DISPLAYHIDDENDOCUMENTS,\n        OIDCUserInfo.CLAIM_XWIKI_EDITOR, OIDCUserInfo.CLAIM_XWIKI_USERTYPE);\n\n    public static final String PROP_IDTOKENCLAIMS = \"oidc.idtokenclaims\";\n\n    public static final List<String> DEFAULT_IDTOKENCLAIMS = Arrays.asList(OIDCIdToken.CLAIM_XWIKI_INSTANCE_ID);\n\n    /**\n     * @since 1.10\n     */\n    public static final String PROP_GROUPS_MAPPING = \"oidc.groups.mapping\";\n\n    /**\n     * @since 1.10\n     */\n    public static final String PROP_GROUPS_ALLOWED = \"oidc.groups.allowed\";\n\n    /**\n     * @since 1.10\n     */\n    public static final String PROP_GROUPS_FORBIDDEN = \"oidc.groups.forbidden\";\n\n    /**\n     * @since 1.27\n     */\n    public static final String PROP_GROUPS_PREFIX = \"oidc.groups.prefix\";\n\n    /**\n     * @since 1.27\n     */\n    public static final String PROP_GROUPS_SEPARATOR = \"oidc.groups.separator\";\n\n    public static final String PROP_INITIAL_REQUEST = \"xwiki.initialRequest\";\n\n    public static final String PROP_STATE = \"oidc.state\";\n\n    public static final String PROP_SESSION_ACCESSTOKEN = \"oidc.accesstoken\";\n\n    public static final String PROP_SESSION_IDTOKEN = \"oidc.idtoken\";\n\n    public static final String PROP_SESSION_USERINFO_EXPORATIONDATE = \"oidc.session.userinfoexpirationdate\";\n\n    private static final String XWIKI_GROUP_PREFIX = \"XWiki.\";\n\n    private static final Set<String> SAFE_PROPERTIES = SetUtils.hashSet(PROP_SKIPPED);\n\n    @Inject\n    private InstanceIdManager instance;\n\n    @Inject\n    private OIDCManager manager;\n\n    @Inject\n    private Container container;\n\n    @Inject\n    private ConverterManager converter;\n\n    @Inject\n    private Logger logger;\n\n    private HttpSession getHttpSession()\n    {\n        Session session = this.container.getSession();\n        if (session instanceof ServletSession) {\n            HttpSession httpSession = ((ServletSession) session).getHttpSession();\n\n            this.logger.debug(\"Session: {}\", httpSession.getId());\n\n            return httpSession;\n        }\n\n        return null;\n    }\n\n    private <T> T getSessionAttribute(String name)\n    {\n        HttpSession session = getHttpSession();\n        if (session != null) {\n            return (T) session.getAttribute(name);\n        }\n\n        return null;\n    }\n\n    private <T> T removeSessionAttribute(String name)\n    {\n        HttpSession session = getHttpSession();\n        if (session != null) {\n            try {\n                return (T) session.getAttribute(name);\n            } finally {\n                session.removeAttribute(name);\n            }\n        }\n\n        return null;\n    }\n\n    private void setSessionAttribute(String name, Object value)\n    {\n        HttpSession session = getHttpSession();\n        if (session != null) {\n            session.setAttribute(name, value);\n        }\n    }\n\n    private String getRequestParameter(String key)\n    {\n        Request request = this.container.getRequest();\n        if (request != null) {\n            return (String) request.getProperty(key);\n        }\n\n        return null;\n    }\n\n    public Map<String, String> getMap(String key)\n    {\n        List<String> list = getProperty(key, List.class);\n\n        Map<String, String> mapping;\n\n        if (list != null && !list.isEmpty()) {\n            mapping = new HashMap<>(list.size());\n\n            for (String listItem : list) {\n                int index = listItem.indexOf('=');\n\n                if (index != -1) {\n                    mapping.put(listItem.substring(0, index), listItem.substring(index + 1));\n                }\n            }\n        } else {\n            mapping = null;\n        }\n\n        return mapping;\n    }\n\n    @Override\n    protected <T> T getProperty(String key, Class<T> valueClass)\n    {\n        if (SAFE_PROPERTIES.contains(key)) {\n            // Get property from request\n            String requestValue = getRequestParameter(key);\n            if (requestValue != null) {\n                return this.converter.convert(valueClass, requestValue);\n            }\n        }\n\n        // Get property from session\n        T sessionValue = getSessionAttribute(key);\n        if (sessionValue != null) {\n            return sessionValue;\n        }\n\n        // Get property from configuration\n        return this.configuration.getProperty(key, valueClass);\n    }\n\n    @Override\n    protected <T> T getProperty(String key, T def)\n    {\n        if (SAFE_PROPERTIES.contains(key)) {\n            // Get property from request\n            String requestValue = getRequestParameter(key);\n            if (requestValue != null) {\n                return this.converter.convert(def.getClass(), requestValue);\n            }\n        }\n\n        // Get property from session\n        T sessionValue = getSessionAttribute(key);\n        if (sessionValue != null) {\n            return sessionValue;\n        }\n\n        // Get property from configuration\n        return this.configuration.getProperty(key, def);\n    }\n\n    /**\n     * @since 1.18\n     */\n    public String getSubjectFormater()\n    {\n        String userFormatter = getProperty(PROP_USER_SUBJECTFORMATER, String.class);\n        if (userFormatter == null) {\n            userFormatter = DEFAULT_USER_SUBJECTFORMATER;\n        }\n\n        return userFormatter;\n    }\n\n    /**\n     * @since 1.11\n     */\n    public String getXWikiUserNameFormater()\n    {\n        String userFormatter = getProperty(PROP_USER_NAMEFORMATER, String.class);\n        if (userFormatter == null) {\n            userFormatter = DEFAULT_USER_NAMEFORMATER;\n        }\n\n        return userFormatter;\n    }\n\n    /**\n     * @since 1.18\n     */\n    public Map<String, String> getUserMapping()\n    {\n        return getMap(PROP_USER_MAPPING);\n    }\n\n    public URL getXWikiProvider()\n    {\n        return getProperty(PROP_XWIKIPROVIDER, URL.class);\n    }\n\n    private Endpoint getEndPoint(String hint) throws URISyntaxException\n    {\n        // TODO: use URI directly when upgrading to a version of XWiki providing a URI converter\n        String uriString = getProperty(PROPPREFIX_ENDPOINT + hint, String.class);\n\n        // If no direct endpoint is provider assume it's a XWiki OIDC provider and generate the endpoint from the hint\n        URI uri;\n        if (uriString == null) {\n            if (getProperty(PROP_XWIKIPROVIDER, String.class) != null) {\n                uri = this.manager.createEndPointURI(getXWikiProvider().toString(), hint);\n            } else {\n                uri = null;\n            }\n        } else {\n            uri = new URI(uriString);\n        }\n\n        // If we still don't have any endpoint URI, try the request\n        if (uri == null) {\n            uriString = getRequestParameter(PROPPREFIX_ENDPOINT + hint);\n            if (uriString == null) {\n                String provider = getRequestParameter(PROP_XWIKIPROVIDER);\n                if (provider == null) {\n                    return null;\n                }\n\n                uri = this.manager.createEndPointURI(provider, hint);\n            } else {\n                uri = new URI(uriString);\n            }\n        }\n\n        // Find custom headers\n        Map<String, List<String>> headers = new LinkedHashMap<>();\n\n        List<String> entries = getProperty(PROPPREFIX_ENDPOINT + hint + \".headers\", List.class);\n        if (entries != null) {\n            for (String entry : entries) {\n                int index = entry.indexOf(':');\n\n                if (index > 0 && index < entry.length() - 1) {\n                    headers.computeIfAbsent(entry.substring(0, index), key -> new ArrayList<>())\n                        .add(entry.substring(index + 1));\n                }\n            }\n        }\n\n        return new Endpoint(uri, headers);\n    }\n\n    public Endpoint getAuthorizationOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(AuthorizationOIDCEndpoint.HINT);\n    }\n\n    public Endpoint getTokenOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(TokenOIDCEndpoint.HINT);\n    }\n\n    public Endpoint getUserInfoOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(UserInfoOIDCEndpoint.HINT);\n    }\n\n    /**\n     * @since 1.21\n     */\n    public Endpoint getLogoutOIDCEndpoint() throws URISyntaxException\n    {\n        return getEndPoint(LogoutOIDCEndpoint.HINT);\n    }\n\n    public ClientID getClientID()\n    {\n        String clientId = getProperty(PROP_CLIENTID, String.class);\n\n        // Fallback on instance id\n        return new ClientID(clientId != null ? clientId : this.instance.getInstanceId().getInstanceId());\n    }\n\n    /**\n     * @since 1.13\n     */\n    public Secret getSecret()\n    {\n        String secret = getProperty(PROP_SECRET, String.class);\n        if (StringUtils.isBlank(secret)) {\n            return null;\n        } else {\n            return new Secret(secret);\n        }\n    }\n\n    /**\n     * @since 1.13\n     */\n    public ClientAuthenticationMethod getTokenEndPointAuthMethod()\n    {\n        String authMethod = getProperty(PROP_ENDPOINT_TOKEN_AUTH_METHOD, String.class);\n        if (\"client_secret_post\".equalsIgnoreCase(authMethod)) {\n            return ClientAuthenticationMethod.CLIENT_SECRET_POST;\n        } else {\n            return ClientAuthenticationMethod.CLIENT_SECRET_BASIC;\n        }\n    }\n\n    /**\n     * @since 1.13\n     */\n    public HTTPRequest.Method getUserInfoEndPointMethod()\n    {\n        return getProperty(PROP_ENDPOINT_USERINFO_METHOD, HTTPRequest.Method.GET);\n    }\n\n    /**\n     * @since 1.21\n     */\n    public HTTPRequest.Method getLogoutEndPointMethod()\n    {\n        return getProperty(PROP_ENDPOINT_LOGOUT_METHOD, HTTPRequest.Method.GET);\n    }\n\n    public String getSessionState()\n    {\n        return getSessionAttribute(PROP_STATE);\n    }\n\n    public boolean isSkipped()\n    {\n        return getProperty(PROP_SKIPPED, false);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public OIDCClaimsRequest getClaimsRequest()\n    {\n        // TODO: allow passing the complete JSON as configuration\n        OIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n\n        // ID Token claims\n        List<String> idtokenclaims = getIDTokenClaims();\n        if (idtokenclaims != null && !idtokenclaims.isEmpty()) {\n            ClaimsSetRequest idtokenclaimsRequest = new ClaimsSetRequest();\n\n            for (String claim : idtokenclaims) {\n                idtokenclaimsRequest.add(claim);\n            }\n\n            claimsRequest.withIDTokenClaimsRequest(idtokenclaimsRequest);\n        }\n\n        // UserInfo claims\n        List<String> userinfoclaims = getUserInfoClaims();\n        if (userinfoclaims != null && !userinfoclaims.isEmpty()) {\n            ClaimsSetRequest userinfoclaimsRequest = new ClaimsSetRequest();\n\n            for (String claim : userinfoclaims) {\n                userinfoclaimsRequest.add(claim);\n            }\n\n            claimsRequest.withUserInfoClaimsRequest(userinfoclaimsRequest);\n        }\n\n        return claimsRequest;\n    }\n\n    /**\n     * @since 1.2\n     */\n    public List<String> getIDTokenClaims()\n    {\n        return getProperty(PROP_IDTOKENCLAIMS, DEFAULT_IDTOKENCLAIMS);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public List<String> getUserInfoClaims()\n    {\n        return getProperty(PROP_USERINFOCLAIMS, DEFAULT_USERINFOCLAIMS);\n    }\n\n    /**\n     * @since 1.12\n     */\n    public int getUserInfoRefreshRate()\n    {\n        return getProperty(PROP_USERINFOREFRESHRATE, 600000);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public Scope getScope()\n    {\n        List<String> scopeValues = getProperty(PROP_SCOPE, List.class);\n\n        if (CollectionUtils.isEmpty(scopeValues)) {\n            return new Scope(OIDCScopeValue.OPENID, OIDCScopeValue.PROFILE, OIDCScopeValue.EMAIL,\n                OIDCScopeValue.ADDRESS, OIDCScopeValue.PHONE);\n        }\n\n        return new Scope(scopeValues.toArray(new String[0]));\n    }\n\n    /**\n     * @since 1.10\n     */\n    public GroupMapping getGroupMapping()\n    {\n        List<String> groupsMapping = getProperty(PROP_GROUPS_MAPPING, List.class);\n\n        GroupMapping groups;\n\n        if (groupsMapping != null && !groupsMapping.isEmpty()) {\n            groups = new GroupMapping(groupsMapping.size());\n\n            for (String groupMapping : groupsMapping) {\n                int index = groupMapping.indexOf('=');\n\n                if (index != -1) {\n                    String xwikiGroup = toXWikiGroup(groupMapping.substring(0, index));\n                    String providerGroup = groupMapping.substring(index + 1);\n\n                    // Add to XWiki mapping\n                    Set<String> providerGroups = groups.xwikiMapping.computeIfAbsent(xwikiGroup, k -> new HashSet<>());\n                    providerGroups.add(providerGroup);\n\n                    // Add to provider mapping\n                    Set<String> xwikiGroups =\n                        groups.providerMapping.computeIfAbsent(providerGroup, k -> new HashSet<>());\n                    xwikiGroups.add(xwikiGroup);\n                }\n            }\n        } else {\n            groups = null;\n        }\n\n        return groups;\n    }\n\n    /**\n     * @since 1.10\n     */\n    public String toXWikiGroup(String group)\n    {\n        return group.startsWith(XWIKI_GROUP_PREFIX) ? group : XWIKI_GROUP_PREFIX + group;\n    }\n\n    /**\n     * @since 1.10\n     */\n    public List<String> getAllowedGroups()\n    {\n        List<String> groups = getProperty(PROP_GROUPS_ALLOWED, List.class);\n\n        return groups != null && !groups.isEmpty() ? groups : null;\n    }\n\n    /**\n     * @since 1.10\n     */\n    public List<String> getForbiddenGroups()\n    {\n        List<String> groups = getProperty(PROP_GROUPS_FORBIDDEN, List.class);\n\n        return groups != null && !groups.isEmpty() ? groups : null;\n    }\n\n    /**\n     * @since 1.27\n     */\n    public String getGroupPrefix()\n    {\n        String groupPrefix = getProperty(PROP_GROUPS_PREFIX, String.class);\n        return groupPrefix != null && !groupPrefix.isEmpty() ? groupPrefix : null;\n    }\n\n    /**\n     * @since 1.27\n     */\n    public String getGroupSeparator()\n    {\n        return getProperty(PROP_GROUPS_SEPARATOR, String.class);\n    }\n\n    // Session only\n\n    /**\n     * @since 1.2\n     */\n    public Date removeUserInfoExpirationDate()\n    {\n        return removeSessionAttribute(PROP_SESSION_USERINFO_EXPORATIONDATE);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setUserInfoExpirationDate(Date date)\n    {\n        setSessionAttribute(PROP_SESSION_USERINFO_EXPORATIONDATE, date);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void resetUserInfoExpirationDate()\n    {\n        LocalDateTime expiration = LocalDateTime.now().plusMillis(getUserInfoRefreshRate());\n\n        setUserInfoExpirationDate(expiration.toDate());\n    }\n\n    /**\n     * @since 1.2\n     */\n    public BearerAccessToken getAccessToken()\n    {\n        return getSessionAttribute(PROP_SESSION_ACCESSTOKEN);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setAccessToken(BearerAccessToken accessToken)\n    {\n        setSessionAttribute(PROP_SESSION_ACCESSTOKEN, accessToken);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public IDTokenClaimsSet getIdToken()\n    {\n        return getSessionAttribute(PROP_SESSION_IDTOKEN);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setIdToken(IDTokenClaimsSet idToken)\n    {\n        setSessionAttribute(PROP_SESSION_IDTOKEN, idToken);\n    }\n\n    /**\n     * @since 1.2\n     */\n    public URI getSuccessRedirectURI()\n    {\n        URI uri = getSessionAttribute(PROP_INITIAL_REQUEST);\n        if (uri == null) {\n            // TODO: return wiki hope page\n        }\n\n        return uri;\n    }\n\n    /**\n     * @since 1.2\n     */\n    public void setSuccessRedirectURI(URI uri)\n    {\n        setSessionAttribute(PROP_INITIAL_REQUEST, uri);\n    }\n\n    /**\n     * @return true if groups should be synchronized (in which case if the provider does not answer to the group claim\n     *         it means the user does not belong to any group)\n     * @since 1.14\n     */\n    public boolean isGroupSync()\n    {\n        String groupClaim = getGroupClaim();\n\n        return getUserInfoClaims().contains(groupClaim);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.oidc.auth.internal;\n\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.contrib.oidc.provider.internal.OIDCManager;\nimport org.xwiki.contrib.oidc.provider.internal.endpoint.TokenOIDCEndpoint;\nimport org.xwiki.properties.ConverterManager;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.when;\n\n/**\n * Validate {@link OIDCClientConfiguration}.\n * \n * @version $Id$\n */\n@ComponentTest\nclass OIDCClientConfigurationTest\n{\n    @InjectMockComponents\n    private OIDCClientConfiguration configuration;\n\n    @MockComponent\n    private ConfigurationSource sourceConfiguration;\n\n    @MockComponent\n    private Container container;\n\n    @MockComponent\n    private OIDCManager manager;\n\n    @MockComponent\n    private ConverterManager converterManager;\n\n    @Test\n    void getUserInfoOIDCEndpoint() throws URISyntaxException\n    {\n        assertNull(this.configuration.getUserInfoOIDCEndpoint());\n\n        URI uri = new URI(\"/endpoint\");\n        when(this.sourceConfiguration.getProperty(OIDCClientConfiguration.PROP_ENDPOINT_USERINFO, String.class))\n            .thenReturn(uri.toString());\n\n        Endpoint endpoint = this.configuration.getUserInfoOIDCEndpoint();\n\n        assertEquals(uri, endpoint.getURI());\n        assertTrue(endpoint.getHeaders().isEmpty());\n\n        List<String> list = Arrays.asList(\"key1:value11\", \"key1:value12\", \"key2:value2\", \"alone\", \":\", \"\");\n\n        when(this.sourceConfiguration.getProperty(OIDCClientConfiguration.PROP_ENDPOINT_USERINFO_HEADERS, List.class))\n            .thenReturn(list);\n\n        Map<String, List<String>> headers = new LinkedHashMap<>();\n        headers.put(\"key1\", Arrays.asList(\"value11\", \"value12\"));\n        headers.put(\"key2\", Arrays.asList(\"value2\"));\n\n        endpoint = this.configuration.getUserInfoOIDCEndpoint();\n\n        assertEquals(uri, endpoint.getURI());\n        assertEquals(headers, endpoint.getHeaders());\n    }\n\n    @Test\n    void getPropertyOrder() throws MalformedURLException, URISyntaxException\n    {\n        String provider = \"http://urlprovider\";\n        URI urlauthorization = new URI(\"http://urlauthorization\");\n\n        XWikiServletRequestStub requestStub = new XWikiServletRequestStub(new URL(\"http://url\"), null);\n\n        when(this.container.getRequest()).thenReturn(new ServletRequest(requestStub));\n        when(this.sourceConfiguration.getProperty(OIDCClientConfiguration.PROP_SKIPPED, false)).thenReturn(false);\n\n        assertFalse(this.configuration.isSkipped());\n        assertNull(this.configuration.getXWikiProvider());\n        assertNull(this.configuration.getAuthorizationOIDCEndpoint());\n        assertNull(this.configuration.getAuthorizationOIDCEndpoint());\n        assertNull(this.configuration.getTokenOIDCEndpoint());\n\n        requestStub.put(OIDCClientConfiguration.PROP_SKIPPED, \"true\");\n        when(this.converterManager.convert(Boolean.class, \"true\")).thenReturn(true);\n\n        assertTrue(this.configuration.isSkipped());\n\n        requestStub.put(OIDCClientConfiguration.PROP_GROUPS_ALLOWED, \"true\");\n\n        assertNull(this.configuration.getAllowedGroups());\n\n        requestStub.put(OIDCClientConfiguration.PROP_XWIKIPROVIDER, provider.toString());\n        requestStub.put(OIDCClientConfiguration.PROP_ENDPOINT_AUTHORIZATION, urlauthorization.toString());\n        when(this.manager.createEndPointURI(provider, TokenOIDCEndpoint.HINT)).thenReturn(new URI(provider));\n\n        assertEquals(urlauthorization, this.configuration.getAuthorizationOIDCEndpoint().getURI());\n        assertEquals(provider, this.configuration.getTokenOIDCEndpoint().getURI().toString());\n    }\n}\n"], "filenames": ["oidc-authenticator/src/main/java/org/xwiki/contrib/oidc/auth/internal/OIDCClientConfiguration.java", "oidc-authenticator/src/test/java/org/xwiki/contrib/oidc/auth/internal/OIDCClientConfigurationTest.java"], "buggy_code_start_loc": [39, 21], "buggy_code_end_loc": [432, 81], "fixing_code_start_loc": [40, 22], "fixing_code_end_loc": [444, 134], "type": "CWE-287", "message": "XWiki OIDC has various tools to manipulate OpenID Connect protocol in XWiki. Prior to version 1.29.1, even if a wiki has an OpenID provider configured through its xwiki.properties, it is possible to provide a third party provider its details through request parameters. One can then bypass the XWiki authentication altogether by specifying its own provider through the oidc.endpoint.* request parameters (or by using an XWiki-based OpenID provider with oidc.xwikiprovider. With the same approach, one could also provide a specific group mapping through oidc.groups.mapping that would make his user automatically part of the XWikiAdminGroup. This issue has been patched, please upgrade to 1.29.1. There is no workaround, an upgrade of the authenticator is required.", "other": {"cve": {"id": "CVE-2022-39387", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-04T19:15:10.983", "lastModified": "2022-11-07T19:12:19.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki OIDC has various tools to manipulate OpenID Connect protocol in XWiki. Prior to version 1.29.1, even if a wiki has an OpenID provider configured through its xwiki.properties, it is possible to provide a third party provider its details through request parameters. One can then bypass the XWiki authentication altogether by specifying its own provider through the oidc.endpoint.* request parameters (or by using an XWiki-based OpenID provider with oidc.xwikiprovider. With the same approach, one could also provide a specific group mapping through oidc.groups.mapping that would make his user automatically part of the XWikiAdminGroup. This issue has been patched, please upgrade to 1.29.1. There is no workaround, an upgrade of the authenticator is required."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:openid_connect:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.29.1", "matchCriteriaId": "194BF34A-5D90-4594-B925-4892420B4CC5"}]}]}], "references": [{"url": "https://github.com/xwiki-contrib/oidc/commit/0247af1417925b9734ab106ad7cd934ee870ac89", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki-contrib/oidc/security/advisories/GHSA-m7gv-v8xx-v47w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/OIDC-118", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki-contrib/oidc/commit/0247af1417925b9734ab106ad7cd934ee870ac89"}}