{"buggy_code": ["# developing\n- ORM mock. [4407](https://github.com/beego/beego/pull/4407)\n- Add sonar check and ignore test. [4432](https://github.com/beego/beego/pull/4432) [4433](https://github.com/beego/beego/pull/4433)\n- Update changlog.yml to check every PR to develop branch.[4427](https://github.com/beego/beego/pull/4427)\n- Fix 4396: Add context.param module into adapter. [4398](https://github.com/beego/beego/pull/4398)\n- Remove `duration` from prometheus labels. [4391](https://github.com/beego/beego/pull/4391)\n- Fix `unknown escape sequence` in generated code. [4385](https://github.com/beego/beego/pull/4385)\n- Using fixed name `commentRouter.go` as generated file name. [4385](https://github.com/beego/beego/pull/4385)\n- Fix 4383: ORM Adapter produces panic when using orm.RegisterModelWithPrefix. [4386](https://github.com/beego/beego/pull/4386)\n- Support 4144: Add new api for order by for supporting multiple way to query [4294](https://github.com/beego/beego/pull/4294)\n- Support session Filter chain. [4404](https://github.com/beego/beego/pull/4404)\n- Feature issue #4402 finish router get example. [4416](https://github.com/beego/beego/pull/4416)\n- Implement context.Context support and deprecate `QueryM2MWithCtx` and `QueryTableWithCtx` [4424](https://github.com/beego/beego/pull/4424)\n- Finish timeout option for tasks #4441 [4441](https://github.com/beego/beego/pull/4441)\n- Error Module brief design & using httplib module to validate this design. [4453](https://github.com/beego/beego/pull/4453)\n- Fix 4444: panic when 404 not found. [4446](https://github.com/beego/beego/pull/4446)\n- Fix 4435: fix panic when controller dir not found. [4452](https://github.com/beego/beego/pull/4452)", "// Copyright 2014 beego Author. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/beego/beego/v2/core/utils\"\n\n\t\"github.com/beego/beego/v2/server/web/context\"\n)\n\nvar (\n\tallowSuffixExt = []string{\".json\", \".xml\", \".html\"}\n)\n\n// Tree has three elements: FixRouter/wildcard/leaves\n// fixRouter stores Fixed Router\n// wildcard stores params\n// leaves store the endpoint information\ntype Tree struct {\n\t// prefix set for static router\n\tprefix string\n\t// search fix route first\n\tfixrouters []*Tree\n\t// if set, failure to match fixrouters search then search wildcard\n\twildcard *Tree\n\t// if set, failure to match wildcard search\n\tleaves []*leafInfo\n}\n\n// NewTree return a new Tree\nfunc NewTree() *Tree {\n\treturn &Tree{}\n}\n\n// AddTree will add tree to the exist Tree\n// prefix should has no params\nfunc (t *Tree) AddTree(prefix string, tree *Tree) {\n\tt.addtree(splitPath(prefix), tree, nil, \"\")\n}\n\nfunc (t *Tree) addtree(segments []string, tree *Tree, wildcards []string, reg string) {\n\tif len(segments) == 0 {\n\t\tpanic(\"prefix should has path\")\n\t}\n\tseg := segments[0]\n\tiswild, params, regexpStr := splitSegment(seg)\n\t// if it's ? meaning can igone this, so add one more rule for it\n\tif len(params) > 0 && params[0] == \":\" {\n\t\tparams = params[1:]\n\t\tif len(segments[1:]) > 0 {\n\t\t\tt.addtree(segments[1:], tree, append(wildcards, params...), reg)\n\t\t} else {\n\t\t\tfilterTreeWithPrefix(tree, wildcards, reg)\n\t\t}\n\t}\n\t// Rule: /login/*/access match /login/2009/11/access\n\t// if already has *, and when loop the access, should as a regexpStr\n\tif !iswild && utils.InSlice(\":splat\", wildcards) {\n\t\tiswild = true\n\t\tregexpStr = seg\n\t}\n\t// Rule: /user/:id/*\n\tif seg == \"*\" && len(wildcards) > 0 && reg == \"\" {\n\t\tregexpStr = \"(.+)\"\n\t}\n\tif len(segments) == 1 {\n\t\tif iswild {\n\t\t\tif regexpStr != \"\" {\n\t\t\t\tif reg == \"\" {\n\t\t\t\t\trr := \"\"\n\t\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t\t} else {\n\t\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t\t}\n\t\t\t} else if reg != \"\" {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tregexpStr = \"([^.]+).(.+)\"\n\t\t\t\t} else {\n\t\t\t\t\tfor _, w := range params {\n\t\t\t\t\t\tif w == \".\" || w == \":\" {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregexpStr = \"([^/]+)/\" + regexpStr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treg = strings.Trim(reg+\"/\"+regexpStr, \"/\")\n\t\t\tfilterTreeWithPrefix(tree, append(wildcards, params...), reg)\n\t\t\tt.wildcard = tree\n\t\t} else {\n\t\t\treg = strings.Trim(reg+\"/\"+regexpStr, \"/\")\n\t\t\tfilterTreeWithPrefix(tree, append(wildcards, params...), reg)\n\t\t\ttree.prefix = seg\n\t\t\tt.fixrouters = append(t.fixrouters, tree)\n\t\t}\n\t\treturn\n\t}\n\n\tif iswild {\n\t\tif t.wildcard == nil {\n\t\t\tt.wildcard = NewTree()\n\t\t}\n\t\tif regexpStr != \"\" {\n\t\t\tif reg == \"\" {\n\t\t\t\trr := \"\"\n\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t} else {\n\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t}\n\t\t} else if reg != \"\" {\n\t\t\tif seg == \"*.*\" {\n\t\t\t\tregexpStr = \"([^.]+).(.+)\"\n\t\t\t\tparams = params[1:]\n\t\t\t} else {\n\t\t\t\tfor range params {\n\t\t\t\t\tregexpStr = \"([^/]+)/\" + regexpStr\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif seg == \"*.*\" {\n\t\t\t\tparams = params[1:]\n\t\t\t}\n\t\t}\n\t\treg = strings.TrimRight(strings.TrimRight(reg, \"/\")+\"/\"+regexpStr, \"/\")\n\t\tt.wildcard.addtree(segments[1:], tree, append(wildcards, params...), reg)\n\t} else {\n\t\tsubTree := NewTree()\n\t\tsubTree.prefix = seg\n\t\tt.fixrouters = append(t.fixrouters, subTree)\n\t\tsubTree.addtree(segments[1:], tree, append(wildcards, params...), reg)\n\t}\n}\n\nfunc filterTreeWithPrefix(t *Tree, wildcards []string, reg string) {\n\tfor _, v := range t.fixrouters {\n\t\tfilterTreeWithPrefix(v, wildcards, reg)\n\t}\n\tif t.wildcard != nil {\n\t\tfilterTreeWithPrefix(t.wildcard, wildcards, reg)\n\t}\n\tfor _, l := range t.leaves {\n\t\tif reg != \"\" {\n\t\t\tif l.regexps != nil {\n\t\t\t\tl.wildcards = append(wildcards, l.wildcards...)\n\t\t\t\tl.regexps = regexp.MustCompile(\"^\" + reg + \"/\" + strings.Trim(l.regexps.String(), \"^$\") + \"$\")\n\t\t\t} else {\n\t\t\t\tfor _, v := range l.wildcards {\n\t\t\t\t\tif v == \":splat\" {\n\t\t\t\t\t\treg = reg + \"/(.+)\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\treg = reg + \"/([^/]+)\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl.regexps = regexp.MustCompile(\"^\" + reg + \"$\")\n\t\t\t\tl.wildcards = append(wildcards, l.wildcards...)\n\t\t\t}\n\t\t} else {\n\t\t\tl.wildcards = append(wildcards, l.wildcards...)\n\t\t\tif l.regexps != nil {\n\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\treg = \"(.+)/\" + reg\n\t\t\t\t\t} else {\n\t\t\t\t\t\treg = \"([^/]+)/\" + reg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl.regexps = regexp.MustCompile(\"^\" + reg + strings.Trim(l.regexps.String(), \"^$\") + \"$\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n// AddRouter call addseg function\nfunc (t *Tree) AddRouter(pattern string, runObject interface{}) {\n\tt.addseg(splitPath(pattern), runObject, nil, \"\")\n}\n\n// \"/\"\n// \"admin\" ->\nfunc (t *Tree) addseg(segments []string, route interface{}, wildcards []string, reg string) {\n\tif len(segments) == 0 {\n\t\tif reg != \"\" {\n\t\t\tt.leaves = append([]*leafInfo{{runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(\"^\" + reg + \"$\")}}, t.leaves...)\n\t\t} else {\n\t\t\tt.leaves = append([]*leafInfo{{runObject: route, wildcards: wildcards}}, t.leaves...)\n\t\t}\n\t} else {\n\t\tseg := segments[0]\n\t\tiswild, params, regexpStr := splitSegment(seg)\n\t\t// if it's ? meaning can igone this, so add one more rule for it\n\t\tif len(params) > 0 && params[0] == \":\" {\n\t\t\tt.addseg(segments[1:], route, wildcards, reg)\n\t\t\tparams = params[1:]\n\t\t}\n\t\t// Rule: /login/*/access match /login/2009/11/access\n\t\t// if already has *, and when loop the access, should as a regexpStr\n\t\tif !iswild && utils.InSlice(\":splat\", wildcards) {\n\t\t\tiswild = true\n\t\t\tregexpStr = seg\n\t\t}\n\t\t// Rule: /user/:id/*\n\t\tif seg == \"*\" && len(wildcards) > 0 && reg == \"\" {\n\t\t\tregexpStr = \"(.+)\"\n\t\t}\n\t\tif iswild {\n\t\t\tif t.wildcard == nil {\n\t\t\t\tt.wildcard = NewTree()\n\t\t\t}\n\t\t\tif regexpStr != \"\" {\n\t\t\t\tif reg == \"\" {\n\t\t\t\t\trr := \"\"\n\t\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t\t} else {\n\t\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t\t}\n\t\t\t} else if reg != \"\" {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tregexpStr = \"/([^.]+).(.+)\"\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t} else {\n\t\t\t\t\tfor range params {\n\t\t\t\t\t\tregexpStr = \"/([^/]+)\" + regexpStr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.wildcard.addseg(segments[1:], route, append(wildcards, params...), reg+regexpStr)\n\t\t} else {\n\t\t\tvar subTree *Tree\n\t\t\tfor _, sub := range t.fixrouters {\n\t\t\t\tif sub.prefix == seg {\n\t\t\t\t\tsubTree = sub\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif subTree == nil {\n\t\t\t\tsubTree = NewTree()\n\t\t\t\tsubTree.prefix = seg\n\t\t\t\tt.fixrouters = append(t.fixrouters, subTree)\n\t\t\t}\n\t\t\tsubTree.addseg(segments[1:], route, wildcards, reg)\n\t\t}\n\t}\n}\n\n// Match router to runObject & params\nfunc (t *Tree) Match(pattern string, ctx *context.Context) (runObject interface{}) {\n\tif len(pattern) == 0 || pattern[0] != '/' {\n\t\treturn nil\n\t}\n\tw := make([]string, 0, 20)\n\treturn t.match(pattern[1:], pattern, w, ctx)\n}\n\nfunc (t *Tree) match(treePattern string, pattern string, wildcardValues []string, ctx *context.Context) (runObject interface{}) {\n\tif len(pattern) > 0 {\n\t\ti := 0\n\t\tfor ; i < len(pattern) && pattern[i] == '/'; i++ {\n\t\t}\n\t\tpattern = pattern[i:]\n\t}\n\t// Handle leaf nodes:\n\tif len(pattern) == 0 {\n\t\tfor _, l := range t.leaves {\n\t\t\tif ok := l.match(treePattern, wildcardValues, ctx); ok {\n\t\t\t\treturn l.runObject\n\t\t\t}\n\t\t}\n\t\tif t.wildcard != nil {\n\t\t\tfor _, l := range t.wildcard.leaves {\n\t\t\t\tif ok := l.match(treePattern, wildcardValues, ctx); ok {\n\t\t\t\t\treturn l.runObject\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tvar seg string\n\ti, l := 0, len(pattern)\n\tfor ; i < l && pattern[i] != '/'; i++ {\n\t}\n\tif i == 0 {\n\t\tseg = pattern\n\t\tpattern = \"\"\n\t} else {\n\t\tseg = pattern[:i]\n\t\tpattern = pattern[i:]\n\t}\n\tfor _, subTree := range t.fixrouters {\n\t\tif subTree.prefix == seg {\n\t\t\tif len(pattern) != 0 && pattern[0] == '/' {\n\t\t\t\ttreePattern = pattern[1:]\n\t\t\t} else {\n\t\t\t\ttreePattern = pattern\n\t\t\t}\n\t\t\trunObject = subTree.match(treePattern, pattern, wildcardValues, ctx)\n\t\t\tif runObject != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif runObject == nil && len(t.fixrouters) > 0 {\n\t\t// Filter the .json .xml .html extension\n\t\tfor _, str := range allowSuffixExt {\n\t\t\tif strings.HasSuffix(seg, str) {\n\t\t\t\tfor _, subTree := range t.fixrouters {\n\t\t\t\t\tif subTree.prefix == seg[:len(seg)-len(str)] {\n\t\t\t\t\t\trunObject = subTree.match(treePattern, pattern, wildcardValues, ctx)\n\t\t\t\t\t\tif runObject != nil {\n\t\t\t\t\t\t\tctx.Input.SetParam(\":ext\", str[1:])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif runObject == nil && t.wildcard != nil {\n\t\trunObject = t.wildcard.match(treePattern, pattern, append(wildcardValues, seg), ctx)\n\t}\n\n\tif runObject == nil && len(t.leaves) > 0 {\n\t\twildcardValues = append(wildcardValues, seg)\n\t\tstart, i := 0, 0\n\t\tfor ; i < len(pattern); i++ {\n\t\t\tif pattern[i] == '/' {\n\t\t\t\tif i != 0 && start < len(pattern) {\n\t\t\t\t\twildcardValues = append(wildcardValues, pattern[start:i])\n\t\t\t\t}\n\t\t\t\tstart = i + 1\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif start > 0 {\n\t\t\twildcardValues = append(wildcardValues, pattern[start:i])\n\t\t}\n\t\tfor _, l := range t.leaves {\n\t\t\tif ok := l.match(treePattern, wildcardValues, ctx); ok {\n\t\t\t\treturn l.runObject\n\t\t\t}\n\t\t}\n\t}\n\treturn runObject\n}\n\ntype leafInfo struct {\n\t// names of wildcards that lead to this leaf. eg, [\"id\" \"name\"] for the wildcard \":id\" and \":name\"\n\twildcards []string\n\n\t// if the leaf is regexp\n\tregexps *regexp.Regexp\n\n\trunObject interface{}\n}\n\nfunc (leaf *leafInfo) match(treePattern string, wildcardValues []string, ctx *context.Context) (ok bool) {\n\t// fmt.Println(\"Leaf:\", wildcardValues, leaf.wildcards, leaf.regexps)\n\tif leaf.regexps == nil {\n\t\tif len(wildcardValues) == 0 && len(leaf.wildcards) == 0 { // static path\n\t\t\treturn true\n\t\t}\n\t\t// match *\n\t\tif len(leaf.wildcards) == 1 && leaf.wildcards[0] == \":splat\" {\n\t\t\tctx.Input.SetParam(\":splat\", treePattern)\n\t\t\treturn true\n\t\t}\n\t\t// match *.* or :id\n\t\tif len(leaf.wildcards) >= 2 && leaf.wildcards[len(leaf.wildcards)-2] == \":path\" && leaf.wildcards[len(leaf.wildcards)-1] == \":ext\" {\n\t\t\tif len(leaf.wildcards) == 2 {\n\t\t\t\tlastone := wildcardValues[len(wildcardValues)-1]\n\t\t\t\tstrs := strings.SplitN(lastone, \".\", 2)\n\t\t\t\tif len(strs) == 2 {\n\t\t\t\t\tctx.Input.SetParam(\":ext\", strs[1])\n\t\t\t\t}\n\t\t\t\tctx.Input.SetParam(\":path\", path.Join(path.Join(wildcardValues[:len(wildcardValues)-1]...), strs[0]))\n\t\t\t\treturn true\n\t\t\t} else if len(wildcardValues) < 2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tvar index int\n\t\t\tfor index = 0; index < len(leaf.wildcards)-2; index++ {\n\t\t\t\tctx.Input.SetParam(leaf.wildcards[index], wildcardValues[index])\n\t\t\t}\n\t\t\tlastone := wildcardValues[len(wildcardValues)-1]\n\t\t\tstrs := strings.SplitN(lastone, \".\", 2)\n\t\t\tif len(strs) == 2 {\n\t\t\t\tctx.Input.SetParam(\":ext\", strs[1])\n\t\t\t}\n\t\t\tif index > (len(wildcardValues) - 1) {\n\t\t\t\tctx.Input.SetParam(\":path\", \"\")\n\t\t\t} else {\n\t\t\t\tctx.Input.SetParam(\":path\", path.Join(path.Join(wildcardValues[index:len(wildcardValues)-1]...), strs[0]))\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\t// match :id\n\t\tif len(leaf.wildcards) != len(wildcardValues) {\n\t\t\treturn false\n\t\t}\n\t\tfor j, v := range leaf.wildcards {\n\t\t\tctx.Input.SetParam(v, wildcardValues[j])\n\t\t}\n\t\treturn true\n\t}\n\n\tif !leaf.regexps.MatchString(path.Join(wildcardValues...)) {\n\t\treturn false\n\t}\n\tmatches := leaf.regexps.FindStringSubmatch(path.Join(wildcardValues...))\n\tfor i, match := range matches[1:] {\n\t\tif i < len(leaf.wildcards) {\n\t\t\tctx.Input.SetParam(leaf.wildcards[i], match)\n\t\t}\n\t}\n\treturn true\n}\n\n// \"/\" -> []\n// \"/admin\" -> [\"admin\"]\n// \"/admin/\" -> [\"admin\"]\n// \"/admin/users\" -> [\"admin\", \"users\"]\nfunc splitPath(key string) []string {\n\tkey = strings.Trim(key, \"/ \")\n\tif key == \"\" {\n\t\treturn []string{}\n\t}\n\treturn strings.Split(key, \"/\")\n}\n\n// \"admin\" -> false, nil, \"\"\n// \":id\" -> true, [:id], \"\"\n// \"?:id\" -> true, [: :id], \"\"        : meaning can empty\n// \":id:int\" -> true, [:id], ([0-9]+)\n// \":name:string\" -> true, [:name], ([\\w]+)\n// \":id([0-9]+)\" -> true, [:id], ([0-9]+)\n// \":id([0-9]+)_:name\" -> true, [:id :name], ([0-9]+)_(.+)\n// \"cms_:id_:page.html\" -> true, [:id_ :page], cms_(.+)(.+).html\n// \"cms_:id(.+)_:page.html\" -> true, [:id :page], cms_(.+)_(.+).html\n// \"*\" -> true, [:splat], \"\"\n// \"*.*\" -> true,[. :path :ext], \"\"      . meaning separator\nfunc splitSegment(key string) (bool, []string, string) {\n\tif strings.HasPrefix(key, \"*\") {\n\t\tif key == \"*.*\" {\n\t\t\treturn true, []string{\".\", \":path\", \":ext\"}, \"\"\n\t\t}\n\t\treturn true, []string{\":splat\"}, \"\"\n\t}\n\tif strings.ContainsAny(key, \":\") {\n\t\tvar paramsNum int\n\t\tvar out []rune\n\t\tvar start bool\n\t\tvar startexp bool\n\t\tvar param []rune\n\t\tvar expt []rune\n\t\tvar skipnum int\n\t\tparams := []string{}\n\t\treg := regexp.MustCompile(`[a-zA-Z0-9_]+`)\n\t\tfor i, v := range key {\n\t\t\tif skipnum > 0 {\n\t\t\t\tskipnum--\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif start {\n\t\t\t\t// :id:int and :name:string\n\t\t\t\tif v == ':' {\n\t\t\t\t\tif len(key) >= i+4 {\n\t\t\t\t\t\tif key[i+1:i+4] == \"int\" {\n\t\t\t\t\t\t\tout = append(out, []rune(\"([0-9]+)\")...)\n\t\t\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\t\t\tstart = false\n\t\t\t\t\t\t\tstartexp = false\n\t\t\t\t\t\t\tskipnum = 3\n\t\t\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t\t\t\tparamsNum++\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif len(key) >= i+7 {\n\t\t\t\t\t\tif key[i+1:i+7] == \"string\" {\n\t\t\t\t\t\t\tout = append(out, []rune(`([\\w]+)`)...)\n\t\t\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\t\t\tparamsNum++\n\t\t\t\t\t\t\tstart = false\n\t\t\t\t\t\t\tstartexp = false\n\t\t\t\t\t\t\tskipnum = 6\n\t\t\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// params only support a-zA-Z0-9\n\t\t\t\tif reg.MatchString(string(v)) {\n\t\t\t\t\tparam = append(param, v)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif v != '(' {\n\t\t\t\t\tout = append(out, []rune(`(.+)`)...)\n\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t\tparamsNum++\n\t\t\t\t\tstart = false\n\t\t\t\t\tstartexp = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif startexp {\n\t\t\t\tif v != ')' {\n\t\t\t\t\texpt = append(expt, v)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Escape Sequence '\\'\n\t\t\tif i > 0 && key[i-1] == '\\\\' {\n\t\t\t\tout = append(out, v)\n\t\t\t} else if v == ':' {\n\t\t\t\tparam = make([]rune, 0)\n\t\t\t\tstart = true\n\t\t\t} else if v == '(' {\n\t\t\t\tstartexp = true\n\t\t\t\tstart = false\n\t\t\t\tif len(param) > 0 {\n\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t}\n\t\t\t\tparamsNum++\n\t\t\t\texpt = make([]rune, 0)\n\t\t\t\texpt = append(expt, '(')\n\t\t\t} else if v == ')' {\n\t\t\t\tstartexp = false\n\t\t\t\texpt = append(expt, ')')\n\t\t\t\tout = append(out, expt...)\n\t\t\t\tparam = make([]rune, 0)\n\t\t\t} else if v == '?' {\n\t\t\t\tparams = append(params, \":\")\n\t\t\t} else {\n\t\t\t\tout = append(out, v)\n\t\t\t}\n\t\t}\n\t\tif len(param) > 0 {\n\t\t\tif paramsNum > 0 {\n\t\t\t\tout = append(out, []rune(`(.+)`)...)\n\t\t\t}\n\t\t\tparams = append(params, \":\"+string(param))\n\t\t}\n\t\treturn true, params, string(out)\n\t}\n\treturn false, nil, \"\"\n}\n", "// Copyright 2014 beego Author. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/beego/beego/v2/server/web/context\"\n)\n\ntype testInfo struct {\n\tpattern          string\n\trequestUrl       string\n\tparams           map[string]string\n\tshouldMatchOrNot bool\n}\n\nvar routers []testInfo\n\nfunc matchTestInfo(pattern, url string, params map[string]string) testInfo {\n\treturn testInfo{\n\t\tpattern:          pattern,\n\t\trequestUrl:       url,\n\t\tparams:           params,\n\t\tshouldMatchOrNot: true,\n\t}\n}\n\nfunc notMatchTestInfo(pattern, url string) testInfo {\n\treturn testInfo{\n\t\tpattern:          pattern,\n\t\trequestUrl:       url,\n\t\tparams:           nil,\n\t\tshouldMatchOrNot: false,\n\t}\n}\n\nfunc init() {\n\trouters = make([]testInfo, 0)\n\t// match example\n\trouters = append(routers, matchTestInfo(\"/topic/?:auth:int\", \"/topic\", nil))\n\trouters = append(routers, matchTestInfo(\"/topic/?:auth:int\", \"/topic/123\", map[string]string{\":auth\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth\", \"/topic/1\", map[string]string{\":id\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth\", \"/topic/1/2\", map[string]string{\":id\": \"1\", \":auth\": \"2\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth:int\", \"/topic/1\", map[string]string{\":id\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth:int\", \"/topic/1/123\", map[string]string{\":id\": \"1\", \":auth\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/:id\", \"/123\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/hello/?:id\", \"/hello\", map[string]string{\":id\": \"\"}))\n\trouters = append(routers, matchTestInfo(\"/\", \"/\", nil))\n\trouters = append(routers, matchTestInfo(\"/customer/login\", \"/customer/login\", nil))\n\trouters = append(routers, matchTestInfo(\"/customer/login\", \"/customer/login.json\", map[string]string{\":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/*\", \"/http://customer/123/\", map[string]string{\":splat\": \"http://customer/123/\"}))\n\trouters = append(routers, matchTestInfo(\"/*\", \"/customer/2009/12/11\", map[string]string{\":splat\": \"customer/2009/12/11\"}))\n\trouters = append(routers, matchTestInfo(\"/aa/*/bb\", \"/aa/2009/bb\", map[string]string{\":splat\": \"2009\"}))\n\trouters = append(routers, matchTestInfo(\"/cc/*/dd\", \"/cc/2009/11/dd\", map[string]string{\":splat\": \"2009/11\"}))\n\trouters = append(routers, matchTestInfo(\"/cc/:id/*\", \"/cc/2009/11/dd\", map[string]string{\":id\": \"2009\", \":splat\": \"11/dd\"}))\n\trouters = append(routers, matchTestInfo(\"/ee/:year/*/ff\", \"/ee/2009/11/ff\", map[string]string{\":year\": \"2009\", \":splat\": \"11\"}))\n\trouters = append(routers, matchTestInfo(\"/thumbnail/:size/uploads/*\", \"/thumbnail/100x100/uploads/items/2014/04/20/dPRCdChkUd651t1Hvs18.jpg\", map[string]string{\":size\": \"100x100\", \":splat\": \"items/2014/04/20/dPRCdChkUd651t1Hvs18.jpg\"}))\n\trouters = append(routers, matchTestInfo(\"/*.*\", \"/nice/api.json\", map[string]string{\":path\": \"nice/api\", \":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/:name/*.*\", \"/nice/api.json\", map[string]string{\":name\": \"nice\", \":path\": \"api\", \":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/:name/test/*.*\", \"/nice/test/api.json\", map[string]string{\":name\": \"nice\", \":path\": \"api\", \":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/dl/:width:int/:height:int/*.*\", \"/dl/48/48/05ac66d9bda00a3acf948c43e306fc9a.jpg\", map[string]string{\":width\": \"48\", \":height\": \"48\", \":ext\": \"jpg\", \":path\": \"05ac66d9bda00a3acf948c43e306fc9a\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id:int\", \"/v1/shop/123\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id\\\\((a|b|c)\\\\)\", \"/v1/shop/123(a)\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id\\\\((a|b|c)\\\\)\", \"/v1/shop/123(b)\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id\\\\((a|b|c)\\\\)\", \"/v1/shop/123(c)\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/:year:int/:month:int/:id/:endid\", \"/1111/111/aaa/aaa\", map[string]string{\":year\": \"1111\", \":month\": \"111\", \":id\": \"aaa\", \":endid\": \"aaa\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id/:name\", \"/v1/shop/123/nike\", map[string]string{\":id\": \"123\", \":name\": \"nike\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id/account\", \"/v1/shop/123/account\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:name:string\", \"/v1/shop/nike\", map[string]string{\":name\": \"nike\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id([0-9]+)\", \"/v1/shop//123\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id([0-9]+)_:name\", \"/v1/shop/123_nike\", map[string]string{\":id\": \"123\", \":name\": \"nike\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id(.+)_cms.html\", \"/v1/shop/123_cms.html\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/cms_:id(.+)_:page(.+).html\", \"/v1/shop/cms_123_1.html\", map[string]string{\":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/:v/cms/aaa_:id(.+)_:page(.+).html\", \"/v1/2/cms/aaa_123_1.html\", map[string]string{\":v\": \"2\", \":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/:v/cms_:id(.+)_:page(.+).html\", \"/v1/2/cms_123_1.html\", map[string]string{\":v\": \"2\", \":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/:v(.+)_cms/ttt_:id(.+)_:page(.+).html\", \"/v1/2_cms/ttt_123_1.html\", map[string]string{\":v\": \"2\", \":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/api/projects/:pid/members/?:mid\", \"/api/projects/1/members\", map[string]string{\":pid\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/api/projects/:pid/members/?:mid\", \"/api/projects/1/members/2\", map[string]string{\":pid\": \"1\", \":mid\": \"2\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/?:day\", \"/2020/11/10\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/?:day\", \"/2020/11\", map[string]string{\":year\": \"2020\", \":month\": \"11\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year\", \"/2020\", map[string]string{\":year\": \"2020\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year([0-9]+)/?:month([0-9]+)/mid/?:day([0-9]+)/?:hour([0-9]+)\", \"/2020/11/mid/10/24\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\", \":hour\": \"24\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/mid/?:day/?:hour\", \"/2020/mid/10\", map[string]string{\":year\": \"2020\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/mid/?:day/?:hour\", \"/2020/11/mid\", map[string]string{\":year\": \"2020\", \":month\": \"11\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/mid/?:day/?:hour\", \"/mid/10/24\", map[string]string{\":day\": \"10\", \":hour\": \"24\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year([0-9]+)/:month([0-9]+)/mid/:day([0-9]+)/?:hour([0-9]+)\", \"/2020/11/mid/10/24\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\", \":hour\": \"24\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/:month/mid/:day/?:hour\", \"/11/mid/10/24\", map[string]string{\":month\": \"11\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/:month/mid/:day/?:hour\", \"/2020/11/mid/10\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/:month/mid/:day/?:hour\", \"/11/mid/10\", map[string]string{\":month\": \"11\", \":day\": \"10\"}))\n\t// not match example\n\n\t// https://github.com/beego/beego/v2/issues/3865\n\trouters = append(routers, notMatchTestInfo(\"/read_:id:int\\\\.htm\", \"/read_222htm\"))\n\trouters = append(routers, notMatchTestInfo(\"/read_:id:int\\\\.htm\", \"/read_222_htm\"))\n\trouters = append(routers, notMatchTestInfo(\"/read_:id:int\\\\.htm\", \" /read_262shtm\"))\n\n}\n\nfunc TestTreeRouters(t *testing.T) {\n\tfor _, r := range routers {\n\t\tshouldMatch := r.shouldMatchOrNot\n\n\t\ttr := NewTree()\n\t\ttr.AddRouter(r.pattern, \"astaxie\")\n\t\tctx := context.NewContext()\n\t\tobj := tr.Match(r.requestUrl, ctx)\n\t\tif !shouldMatch {\n\t\t\tif obj != nil {\n\t\t\t\tt.Fatal(\"pattern:\", r.pattern, \", should not match\", r.requestUrl)\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\t\tt.Fatal(\"pattern:\", r.pattern+\", can't match obj, Expect \", r.requestUrl)\n\t\t}\n\t\tif r.params != nil {\n\t\t\tfor k, v := range r.params {\n\t\t\t\tif vv := ctx.Input.Param(k); vv != v {\n\t\t\t\t\tt.Fatal(\"The Rule: \" + r.pattern + \"\\nThe RequestURL:\" + r.requestUrl + \"\\nThe Key is \" + k + \", The Value should be: \" + v + \", but get: \" + vv)\n\t\t\t\t} else if vv == \"\" && v != \"\" {\n\t\t\t\t\tt.Fatal(r.pattern + \"    \" + r.requestUrl + \" get param empty:\" + k)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestStaticPath(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/topic/:id\", \"wildcard\")\n\ttr.AddRouter(\"/topic\", \"static\")\n\tctx := context.NewContext()\n\tobj := tr.Match(\"/topic\", ctx)\n\tif obj == nil || obj.(string) != \"static\" {\n\t\tt.Fatal(\"/topic is  a static route\")\n\t}\n\tobj = tr.Match(\"/topic/1\", ctx)\n\tif obj == nil || obj.(string) != \"wildcard\" {\n\t\tt.Fatal(\"/topic/1 is a wildcard route\")\n\t}\n}\n\nfunc TestAddTree(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/shop/:id/account\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/ttt_:id(.+)_:page(.+).html\", \"astaxie\")\n\tt1 := NewTree()\n\tt1.AddTree(\"/v1/zl\", tr)\n\tctx := context.NewContext()\n\tobj := t1.Match(\"/v1/zl/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/zl/shop/:id/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":id\") != \"123\" {\n\t\tt.Fatal(\"get :id param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t1.Match(\"/v1/zl/shop/123/ttt_1_12.html\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/zl//shop/:sd/ttt_:id(.+)_:page(.+).html can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":sd\") != \"123\" || ctx.Input.Param(\":id\") != \"1\" || ctx.Input.Param(\":page\") != \"12\" {\n\t\tt.Fatal(\"get :sd :id :page param error\")\n\t}\n\n\tt2 := NewTree()\n\tt2.AddTree(\"/v1/:shopid\", tr)\n\tctx.Input.Reset(ctx)\n\tobj = t2.Match(\"/v1/zl/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/:shopid/shop/:id/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":id\") != \"123\" || ctx.Input.Param(\":shopid\") != \"zl\" {\n\t\tt.Fatal(\"get :id :shopid param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t2.Match(\"/v1/zl/shop/123/ttt_1_12.html\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/:shopid/shop/:sd/ttt_:id(.+)_:page(.+).html can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get :shopid param error\")\n\t}\n\tif ctx.Input.Param(\":sd\") != \"123\" || ctx.Input.Param(\":id\") != \"1\" || ctx.Input.Param(\":page\") != \"12\" || ctx.Input.Param(\":shopid\") != \"zl\" {\n\t\tt.Fatal(\"get :sd :id :page :shopid param error\")\n\t}\n}\n\nfunc TestAddTree2(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/shop/:id/account\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/ttt_:id(.+)_:page(.+).html\", \"astaxie\")\n\tt3 := NewTree()\n\tt3.AddTree(\"/:version(v1|v2)/:prefix\", tr)\n\tctx := context.NewContext()\n\tobj := t3.Match(\"/v1/zl/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/:version(v1|v2)/:prefix/shop/:id/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":id\") != \"123\" || ctx.Input.Param(\":prefix\") != \"zl\" || ctx.Input.Param(\":version\") != \"v1\" {\n\t\tt.Fatal(\"get :id :prefix :version param error\")\n\t}\n}\n\nfunc TestAddTree3(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/create\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/account\", \"astaxie\")\n\tt3 := NewTree()\n\tt3.AddTree(\"/table/:num\", tr)\n\tctx := context.NewContext()\n\tobj := t3.Match(\"/table/123/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/table/:num/shop/:sd/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":num\") != \"123\" || ctx.Input.Param(\":sd\") != \"123\" {\n\t\tt.Fatal(\"get :num :sd param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t3.Match(\"/table/123/create\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/table/:num/create can't get obj \")\n\t}\n}\n\nfunc TestAddTree4(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/create\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/:account\", \"astaxie\")\n\tt4 := NewTree()\n\tt4.AddTree(\"/:info:int/:num/:id\", tr)\n\tctx := context.NewContext()\n\tobj := t4.Match(\"/12/123/456/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/:info:int/:num/:id/shop/:sd/:account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":info\") != \"12\" || ctx.Input.Param(\":num\") != \"123\" ||\n\t\tctx.Input.Param(\":id\") != \"456\" || ctx.Input.Param(\":sd\") != \"123\" ||\n\t\tctx.Input.Param(\":account\") != \"account\" {\n\t\tt.Fatal(\"get :info :num :id :sd :account param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t4.Match(\"/12/123/456/create\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/:info:int/:num/:id/create can't get obj \")\n\t}\n}\n\n// Test for issue #1595\nfunc TestAddTree5(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/v1/shop/:id\", \"shopdetail\")\n\ttr.AddRouter(\"/v1/shop/\", \"shophome\")\n\tctx := context.NewContext()\n\tobj := tr.Match(\"/v1/shop/\", ctx)\n\tif obj == nil || obj.(string) != \"shophome\" {\n\t\tt.Fatal(\"url /v1/shop/ need match router /v1/shop/ \")\n\t}\n}\nfunc TestSplitPath(t *testing.T) {\n\ta := splitPath(\"\")\n\tif len(a) != 0 {\n\t\tt.Fatal(\"/ should retrun []\")\n\t}\n\ta = splitPath(\"/\")\n\tif len(a) != 0 {\n\t\tt.Fatal(\"/ should retrun []\")\n\t}\n\ta = splitPath(\"/admin\")\n\tif len(a) != 1 || a[0] != \"admin\" {\n\t\tt.Fatal(\"/admin should retrun [admin]\")\n\t}\n\ta = splitPath(\"/admin/\")\n\tif len(a) != 1 || a[0] != \"admin\" {\n\t\tt.Fatal(\"/admin/ should retrun [admin]\")\n\t}\n\ta = splitPath(\"/admin/users\")\n\tif len(a) != 2 || a[0] != \"admin\" || a[1] != \"users\" {\n\t\tt.Fatal(\"/admin should retrun [admin users]\")\n\t}\n\ta = splitPath(\"/admin/:id:int\")\n\tif len(a) != 2 || a[0] != \"admin\" || a[1] != \":id:int\" {\n\t\tt.Fatal(\"/admin should retrun [admin :id:int]\")\n\t}\n}\n\nfunc TestSplitSegment(t *testing.T) {\n\n\titems := map[string]struct {\n\t\tisReg  bool\n\t\tparams []string\n\t\tregStr string\n\t}{\n\t\t\"admin\":                      {false, nil, \"\"},\n\t\t\"*\":                          {true, []string{\":splat\"}, \"\"},\n\t\t\"*.*\":                        {true, []string{\".\", \":path\", \":ext\"}, \"\"},\n\t\t\":id\":                        {true, []string{\":id\"}, \"\"},\n\t\t\"?:id\":                       {true, []string{\":\", \":id\"}, \"\"},\n\t\t\":id:int\":                    {true, []string{\":id\"}, \"([0-9]+)\"},\n\t\t\":name:string\":               {true, []string{\":name\"}, `([\\w]+)`},\n\t\t\":id([0-9]+)\":                {true, []string{\":id\"}, `([0-9]+)`},\n\t\t\":id([0-9]+)_:name\":          {true, []string{\":id\", \":name\"}, `([0-9]+)_(.+)`},\n\t\t\":id(.+)_cms.html\":           {true, []string{\":id\"}, `(.+)_cms.html`},\n\t\t\":id(.+)_cms\\\\.html\":         {true, []string{\":id\"}, `(.+)_cms\\.html`},\n\t\t\"cms_:id(.+)_:page(.+).html\": {true, []string{\":id\", \":page\"}, `cms_(.+)_(.+).html`},\n\t\t`:app(a|b|c)`:                {true, []string{\":app\"}, `(a|b|c)`},\n\t\t`:app\\((a|b|c)\\)`:            {true, []string{\":app\"}, `(.+)\\((a|b|c)\\)`},\n\t}\n\n\tfor pattern, v := range items {\n\t\tb, w, r := splitSegment(pattern)\n\t\tif b != v.isReg || r != v.regStr || strings.Join(w, \",\") != strings.Join(v.params, \",\") {\n\t\t\tt.Fatalf(\"%s should return %t,%s,%q, got %t,%s,%q\", pattern, v.isReg, v.params, v.regStr, b, w, r)\n\t\t}\n\t}\n}\n"], "fixing_code": ["# developing\n- Fix: /abc.html/aaa match /abc/aaa. [4459](https://github.com/beego/beego/pull/4459)\n- ORM mock. [4407](https://github.com/beego/beego/pull/4407)\n- Add sonar check and ignore test. [4432](https://github.com/beego/beego/pull/4432) [4433](https://github.com/beego/beego/pull/4433)\n- Update changlog.yml to check every PR to develop branch.[4427](https://github.com/beego/beego/pull/4427)\n- Fix 4396: Add context.param module into adapter. [4398](https://github.com/beego/beego/pull/4398)\n- Remove `duration` from prometheus labels. [4391](https://github.com/beego/beego/pull/4391)\n- Fix `unknown escape sequence` in generated code. [4385](https://github.com/beego/beego/pull/4385)\n- Using fixed name `commentRouter.go` as generated file name. [4385](https://github.com/beego/beego/pull/4385)\n- Fix 4383: ORM Adapter produces panic when using orm.RegisterModelWithPrefix. [4386](https://github.com/beego/beego/pull/4386)\n- Support 4144: Add new api for order by for supporting multiple way to query [4294](https://github.com/beego/beego/pull/4294)\n- Support session Filter chain. [4404](https://github.com/beego/beego/pull/4404)\n- Feature issue #4402 finish router get example. [4416](https://github.com/beego/beego/pull/4416)\n- Implement context.Context support and deprecate `QueryM2MWithCtx` and `QueryTableWithCtx` [4424](https://github.com/beego/beego/pull/4424)\n- Finish timeout option for tasks #4441 [4441](https://github.com/beego/beego/pull/4441)\n- Error Module brief design & using httplib module to validate this design. [4453](https://github.com/beego/beego/pull/4453)\n- Fix 4444: panic when 404 not found. [4446](https://github.com/beego/beego/pull/4446)\n- Fix 4435: fix panic when controller dir not found. [4452](https://github.com/beego/beego/pull/4452)", "// Copyright 2014 beego Author. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/beego/beego/v2/core/utils\"\n\n\t\"github.com/beego/beego/v2/server/web/context\"\n)\n\nvar (\n\tallowSuffixExt = []string{\".json\", \".xml\", \".html\"}\n)\n\n// Tree has three elements: FixRouter/wildcard/leaves\n// fixRouter stores Fixed Router\n// wildcard stores params\n// leaves store the endpoint information\ntype Tree struct {\n\t// prefix set for static router\n\tprefix string\n\t// search fix route first\n\tfixrouters []*Tree\n\t// if set, failure to match fixrouters search then search wildcard\n\twildcard *Tree\n\t// if set, failure to match wildcard search\n\tleaves []*leafInfo\n}\n\n// NewTree return a new Tree\nfunc NewTree() *Tree {\n\treturn &Tree{}\n}\n\n// AddTree will add tree to the exist Tree\n// prefix should has no params\nfunc (t *Tree) AddTree(prefix string, tree *Tree) {\n\tt.addtree(splitPath(prefix), tree, nil, \"\")\n}\n\nfunc (t *Tree) addtree(segments []string, tree *Tree, wildcards []string, reg string) {\n\tif len(segments) == 0 {\n\t\tpanic(\"prefix should has path\")\n\t}\n\tseg := segments[0]\n\tiswild, params, regexpStr := splitSegment(seg)\n\t// if it's ? meaning can igone this, so add one more rule for it\n\tif len(params) > 0 && params[0] == \":\" {\n\t\tparams = params[1:]\n\t\tif len(segments[1:]) > 0 {\n\t\t\tt.addtree(segments[1:], tree, append(wildcards, params...), reg)\n\t\t} else {\n\t\t\tfilterTreeWithPrefix(tree, wildcards, reg)\n\t\t}\n\t}\n\t// Rule: /login/*/access match /login/2009/11/access\n\t// if already has *, and when loop the access, should as a regexpStr\n\tif !iswild && utils.InSlice(\":splat\", wildcards) {\n\t\tiswild = true\n\t\tregexpStr = seg\n\t}\n\t// Rule: /user/:id/*\n\tif seg == \"*\" && len(wildcards) > 0 && reg == \"\" {\n\t\tregexpStr = \"(.+)\"\n\t}\n\tif len(segments) == 1 {\n\t\tif iswild {\n\t\t\tif regexpStr != \"\" {\n\t\t\t\tif reg == \"\" {\n\t\t\t\t\trr := \"\"\n\t\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t\t} else {\n\t\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t\t}\n\t\t\t} else if reg != \"\" {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tregexpStr = \"([^.]+).(.+)\"\n\t\t\t\t} else {\n\t\t\t\t\tfor _, w := range params {\n\t\t\t\t\t\tif w == \".\" || w == \":\" {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregexpStr = \"([^/]+)/\" + regexpStr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treg = strings.Trim(reg+\"/\"+regexpStr, \"/\")\n\t\t\tfilterTreeWithPrefix(tree, append(wildcards, params...), reg)\n\t\t\tt.wildcard = tree\n\t\t} else {\n\t\t\treg = strings.Trim(reg+\"/\"+regexpStr, \"/\")\n\t\t\tfilterTreeWithPrefix(tree, append(wildcards, params...), reg)\n\t\t\ttree.prefix = seg\n\t\t\tt.fixrouters = append(t.fixrouters, tree)\n\t\t}\n\t\treturn\n\t}\n\n\tif iswild {\n\t\tif t.wildcard == nil {\n\t\t\tt.wildcard = NewTree()\n\t\t}\n\t\tif regexpStr != \"\" {\n\t\t\tif reg == \"\" {\n\t\t\t\trr := \"\"\n\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t} else {\n\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t}\n\t\t} else if reg != \"\" {\n\t\t\tif seg == \"*.*\" {\n\t\t\t\tregexpStr = \"([^.]+).(.+)\"\n\t\t\t\tparams = params[1:]\n\t\t\t} else {\n\t\t\t\tfor range params {\n\t\t\t\t\tregexpStr = \"([^/]+)/\" + regexpStr\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif seg == \"*.*\" {\n\t\t\t\tparams = params[1:]\n\t\t\t}\n\t\t}\n\t\treg = strings.TrimRight(strings.TrimRight(reg, \"/\")+\"/\"+regexpStr, \"/\")\n\t\tt.wildcard.addtree(segments[1:], tree, append(wildcards, params...), reg)\n\t} else {\n\t\tsubTree := NewTree()\n\t\tsubTree.prefix = seg\n\t\tt.fixrouters = append(t.fixrouters, subTree)\n\t\tsubTree.addtree(segments[1:], tree, append(wildcards, params...), reg)\n\t}\n}\n\nfunc filterTreeWithPrefix(t *Tree, wildcards []string, reg string) {\n\tfor _, v := range t.fixrouters {\n\t\tfilterTreeWithPrefix(v, wildcards, reg)\n\t}\n\tif t.wildcard != nil {\n\t\tfilterTreeWithPrefix(t.wildcard, wildcards, reg)\n\t}\n\tfor _, l := range t.leaves {\n\t\tif reg != \"\" {\n\t\t\tif l.regexps != nil {\n\t\t\t\tl.wildcards = append(wildcards, l.wildcards...)\n\t\t\t\tl.regexps = regexp.MustCompile(\"^\" + reg + \"/\" + strings.Trim(l.regexps.String(), \"^$\") + \"$\")\n\t\t\t} else {\n\t\t\t\tfor _, v := range l.wildcards {\n\t\t\t\t\tif v == \":splat\" {\n\t\t\t\t\t\treg = reg + \"/(.+)\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\treg = reg + \"/([^/]+)\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl.regexps = regexp.MustCompile(\"^\" + reg + \"$\")\n\t\t\t\tl.wildcards = append(wildcards, l.wildcards...)\n\t\t\t}\n\t\t} else {\n\t\t\tl.wildcards = append(wildcards, l.wildcards...)\n\t\t\tif l.regexps != nil {\n\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\treg = \"(.+)/\" + reg\n\t\t\t\t\t} else {\n\t\t\t\t\t\treg = \"([^/]+)/\" + reg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl.regexps = regexp.MustCompile(\"^\" + reg + strings.Trim(l.regexps.String(), \"^$\") + \"$\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n// AddRouter call addseg function\nfunc (t *Tree) AddRouter(pattern string, runObject interface{}) {\n\tt.addseg(splitPath(pattern), runObject, nil, \"\")\n}\n\n// \"/\"\n// \"admin\" ->\nfunc (t *Tree) addseg(segments []string, route interface{}, wildcards []string, reg string) {\n\tif len(segments) == 0 {\n\t\tif reg != \"\" {\n\t\t\tt.leaves = append([]*leafInfo{{runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(\"^\" + reg + \"$\")}}, t.leaves...)\n\t\t} else {\n\t\t\tt.leaves = append([]*leafInfo{{runObject: route, wildcards: wildcards}}, t.leaves...)\n\t\t}\n\t} else {\n\t\tseg := segments[0]\n\t\tiswild, params, regexpStr := splitSegment(seg)\n\t\t// if it's ? meaning can igone this, so add one more rule for it\n\t\tif len(params) > 0 && params[0] == \":\" {\n\t\t\tt.addseg(segments[1:], route, wildcards, reg)\n\t\t\tparams = params[1:]\n\t\t}\n\t\t// Rule: /login/*/access match /login/2009/11/access\n\t\t// if already has *, and when loop the access, should as a regexpStr\n\t\tif !iswild && utils.InSlice(\":splat\", wildcards) {\n\t\t\tiswild = true\n\t\t\tregexpStr = seg\n\t\t}\n\t\t// Rule: /user/:id/*\n\t\tif seg == \"*\" && len(wildcards) > 0 && reg == \"\" {\n\t\t\tregexpStr = \"(.+)\"\n\t\t}\n\t\tif iswild {\n\t\t\tif t.wildcard == nil {\n\t\t\t\tt.wildcard = NewTree()\n\t\t\t}\n\t\t\tif regexpStr != \"\" {\n\t\t\t\tif reg == \"\" {\n\t\t\t\t\trr := \"\"\n\t\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t\t} else {\n\t\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t\t}\n\t\t\t} else if reg != \"\" {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tregexpStr = \"/([^.]+).(.+)\"\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t} else {\n\t\t\t\t\tfor range params {\n\t\t\t\t\t\tregexpStr = \"/([^/]+)\" + regexpStr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.wildcard.addseg(segments[1:], route, append(wildcards, params...), reg+regexpStr)\n\t\t} else {\n\t\t\tvar subTree *Tree\n\t\t\tfor _, sub := range t.fixrouters {\n\t\t\t\tif sub.prefix == seg {\n\t\t\t\t\tsubTree = sub\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif subTree == nil {\n\t\t\t\tsubTree = NewTree()\n\t\t\t\tsubTree.prefix = seg\n\t\t\t\tt.fixrouters = append(t.fixrouters, subTree)\n\t\t\t}\n\t\t\tsubTree.addseg(segments[1:], route, wildcards, reg)\n\t\t}\n\t}\n}\n\n// Match router to runObject & params\nfunc (t *Tree) Match(pattern string, ctx *context.Context) (runObject interface{}) {\n\tif len(pattern) == 0 || pattern[0] != '/' {\n\t\treturn nil\n\t}\n\tw := make([]string, 0, 20)\n\treturn t.match(pattern[1:], pattern, w, ctx)\n}\n\nfunc (t *Tree) match(treePattern string, pattern string, wildcardValues []string, ctx *context.Context) (runObject interface{}) {\n\tif len(pattern) > 0 {\n\t\ti := 0\n\t\tfor ; i < len(pattern) && pattern[i] == '/'; i++ {\n\t\t}\n\t\tpattern = pattern[i:]\n\t}\n\t// Handle leaf nodes:\n\tif len(pattern) == 0 {\n\t\tfor _, l := range t.leaves {\n\t\t\tif ok := l.match(treePattern, wildcardValues, ctx); ok {\n\t\t\t\treturn l.runObject\n\t\t\t}\n\t\t}\n\t\tif t.wildcard != nil {\n\t\t\tfor _, l := range t.wildcard.leaves {\n\t\t\t\tif ok := l.match(treePattern, wildcardValues, ctx); ok {\n\t\t\t\t\treturn l.runObject\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tvar seg string\n\ti, l := 0, len(pattern)\n\tfor ; i < l && pattern[i] != '/'; i++ {\n\t}\n\tif i == 0 {\n\t\tseg = pattern\n\t\tpattern = \"\"\n\t} else {\n\t\tseg = pattern[:i]\n\t\tpattern = pattern[i:]\n\t}\n\tfor _, subTree := range t.fixrouters {\n\t\tif subTree.prefix == seg {\n\t\t\tif len(pattern) != 0 && pattern[0] == '/' {\n\t\t\t\ttreePattern = pattern[1:]\n\t\t\t} else {\n\t\t\t\ttreePattern = pattern\n\t\t\t}\n\t\t\trunObject = subTree.match(treePattern, pattern, wildcardValues, ctx)\n\t\t\tif runObject != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif runObject == nil && len(t.fixrouters) > 0 {\n\t\t// Filter the .json .xml .html extension\n\t\tfor _, str := range allowSuffixExt {\n\t\t\tif strings.HasSuffix(seg, str) && strings.HasSuffix(treePattern, seg){\n\t\t\t\tfor _, subTree := range t.fixrouters {\n\t\t\t\t\t// strings.HasSuffix(treePattern, seg) avoid cases: /aaa.html/bbb could access /aaa/bbb\n\t\t\t\t\tif subTree.prefix == seg[:len(seg)-len(str)] {\n\t\t\t\t\t\trunObject = subTree.match(treePattern, pattern, wildcardValues, ctx)\n\t\t\t\t\t\tif runObject != nil {\n\t\t\t\t\t\t\tctx.Input.SetParam(\":ext\", str[1:])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif runObject == nil && t.wildcard != nil {\n\t\trunObject = t.wildcard.match(treePattern, pattern, append(wildcardValues, seg), ctx)\n\t}\n\n\tif runObject == nil && len(t.leaves) > 0 {\n\t\twildcardValues = append(wildcardValues, seg)\n\t\tstart, i := 0, 0\n\t\tfor ; i < len(pattern); i++ {\n\t\t\tif pattern[i] == '/' {\n\t\t\t\tif i != 0 && start < len(pattern) {\n\t\t\t\t\twildcardValues = append(wildcardValues, pattern[start:i])\n\t\t\t\t}\n\t\t\t\tstart = i + 1\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif start > 0 {\n\t\t\twildcardValues = append(wildcardValues, pattern[start:i])\n\t\t}\n\t\tfor _, l := range t.leaves {\n\t\t\tif ok := l.match(treePattern, wildcardValues, ctx); ok {\n\t\t\t\treturn l.runObject\n\t\t\t}\n\t\t}\n\t}\n\treturn runObject\n}\n\ntype leafInfo struct {\n\t// names of wildcards that lead to this leaf. eg, [\"id\" \"name\"] for the wildcard \":id\" and \":name\"\n\twildcards []string\n\n\t// if the leaf is regexp\n\tregexps *regexp.Regexp\n\n\trunObject interface{}\n}\n\nfunc (leaf *leafInfo) match(treePattern string, wildcardValues []string, ctx *context.Context) (ok bool) {\n\t// fmt.Println(\"Leaf:\", wildcardValues, leaf.wildcards, leaf.regexps)\n\tif leaf.regexps == nil {\n\t\tif len(wildcardValues) == 0 && len(leaf.wildcards) == 0 { // static path\n\t\t\treturn true\n\t\t}\n\t\t// match *\n\t\tif len(leaf.wildcards) == 1 && leaf.wildcards[0] == \":splat\" {\n\t\t\tctx.Input.SetParam(\":splat\", treePattern)\n\t\t\treturn true\n\t\t}\n\t\t// match *.* or :id\n\t\tif len(leaf.wildcards) >= 2 && leaf.wildcards[len(leaf.wildcards)-2] == \":path\" && leaf.wildcards[len(leaf.wildcards)-1] == \":ext\" {\n\t\t\tif len(leaf.wildcards) == 2 {\n\t\t\t\tlastone := wildcardValues[len(wildcardValues)-1]\n\t\t\t\tstrs := strings.SplitN(lastone, \".\", 2)\n\t\t\t\tif len(strs) == 2 {\n\t\t\t\t\tctx.Input.SetParam(\":ext\", strs[1])\n\t\t\t\t}\n\t\t\t\tctx.Input.SetParam(\":path\", path.Join(path.Join(wildcardValues[:len(wildcardValues)-1]...), strs[0]))\n\t\t\t\treturn true\n\t\t\t} else if len(wildcardValues) < 2 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tvar index int\n\t\t\tfor index = 0; index < len(leaf.wildcards)-2; index++ {\n\t\t\t\tctx.Input.SetParam(leaf.wildcards[index], wildcardValues[index])\n\t\t\t}\n\t\t\tlastone := wildcardValues[len(wildcardValues)-1]\n\t\t\tstrs := strings.SplitN(lastone, \".\", 2)\n\t\t\tif len(strs) == 2 {\n\t\t\t\tctx.Input.SetParam(\":ext\", strs[1])\n\t\t\t}\n\t\t\tif index > (len(wildcardValues) - 1) {\n\t\t\t\tctx.Input.SetParam(\":path\", \"\")\n\t\t\t} else {\n\t\t\t\tctx.Input.SetParam(\":path\", path.Join(path.Join(wildcardValues[index:len(wildcardValues)-1]...), strs[0]))\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\t// match :id\n\t\tif len(leaf.wildcards) != len(wildcardValues) {\n\t\t\treturn false\n\t\t}\n\t\tfor j, v := range leaf.wildcards {\n\t\t\tctx.Input.SetParam(v, wildcardValues[j])\n\t\t}\n\t\treturn true\n\t}\n\n\tif !leaf.regexps.MatchString(path.Join(wildcardValues...)) {\n\t\treturn false\n\t}\n\tmatches := leaf.regexps.FindStringSubmatch(path.Join(wildcardValues...))\n\tfor i, match := range matches[1:] {\n\t\tif i < len(leaf.wildcards) {\n\t\t\tctx.Input.SetParam(leaf.wildcards[i], match)\n\t\t}\n\t}\n\treturn true\n}\n\n// \"/\" -> []\n// \"/admin\" -> [\"admin\"]\n// \"/admin/\" -> [\"admin\"]\n// \"/admin/users\" -> [\"admin\", \"users\"]\nfunc splitPath(key string) []string {\n\tkey = strings.Trim(key, \"/ \")\n\tif key == \"\" {\n\t\treturn []string{}\n\t}\n\treturn strings.Split(key, \"/\")\n}\n\n// \"admin\" -> false, nil, \"\"\n// \":id\" -> true, [:id], \"\"\n// \"?:id\" -> true, [: :id], \"\"        : meaning can empty\n// \":id:int\" -> true, [:id], ([0-9]+)\n// \":name:string\" -> true, [:name], ([\\w]+)\n// \":id([0-9]+)\" -> true, [:id], ([0-9]+)\n// \":id([0-9]+)_:name\" -> true, [:id :name], ([0-9]+)_(.+)\n// \"cms_:id_:page.html\" -> true, [:id_ :page], cms_(.+)(.+).html\n// \"cms_:id(.+)_:page.html\" -> true, [:id :page], cms_(.+)_(.+).html\n// \"*\" -> true, [:splat], \"\"\n// \"*.*\" -> true,[. :path :ext], \"\"      . meaning separator\nfunc splitSegment(key string) (bool, []string, string) {\n\tif strings.HasPrefix(key, \"*\") {\n\t\tif key == \"*.*\" {\n\t\t\treturn true, []string{\".\", \":path\", \":ext\"}, \"\"\n\t\t}\n\t\treturn true, []string{\":splat\"}, \"\"\n\t}\n\tif strings.ContainsAny(key, \":\") {\n\t\tvar paramsNum int\n\t\tvar out []rune\n\t\tvar start bool\n\t\tvar startexp bool\n\t\tvar param []rune\n\t\tvar expt []rune\n\t\tvar skipnum int\n\t\tparams := []string{}\n\t\treg := regexp.MustCompile(`[a-zA-Z0-9_]+`)\n\t\tfor i, v := range key {\n\t\t\tif skipnum > 0 {\n\t\t\t\tskipnum--\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif start {\n\t\t\t\t// :id:int and :name:string\n\t\t\t\tif v == ':' {\n\t\t\t\t\tif len(key) >= i+4 {\n\t\t\t\t\t\tif key[i+1:i+4] == \"int\" {\n\t\t\t\t\t\t\tout = append(out, []rune(\"([0-9]+)\")...)\n\t\t\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\t\t\tstart = false\n\t\t\t\t\t\t\tstartexp = false\n\t\t\t\t\t\t\tskipnum = 3\n\t\t\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t\t\t\tparamsNum++\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif len(key) >= i+7 {\n\t\t\t\t\t\tif key[i+1:i+7] == \"string\" {\n\t\t\t\t\t\t\tout = append(out, []rune(`([\\w]+)`)...)\n\t\t\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\t\t\tparamsNum++\n\t\t\t\t\t\t\tstart = false\n\t\t\t\t\t\t\tstartexp = false\n\t\t\t\t\t\t\tskipnum = 6\n\t\t\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// params only support a-zA-Z0-9\n\t\t\t\tif reg.MatchString(string(v)) {\n\t\t\t\t\tparam = append(param, v)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif v != '(' {\n\t\t\t\t\tout = append(out, []rune(`(.+)`)...)\n\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t\tparamsNum++\n\t\t\t\t\tstart = false\n\t\t\t\t\tstartexp = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif startexp {\n\t\t\t\tif v != ')' {\n\t\t\t\t\texpt = append(expt, v)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Escape Sequence '\\'\n\t\t\tif i > 0 && key[i-1] == '\\\\' {\n\t\t\t\tout = append(out, v)\n\t\t\t} else if v == ':' {\n\t\t\t\tparam = make([]rune, 0)\n\t\t\t\tstart = true\n\t\t\t} else if v == '(' {\n\t\t\t\tstartexp = true\n\t\t\t\tstart = false\n\t\t\t\tif len(param) > 0 {\n\t\t\t\t\tparams = append(params, \":\"+string(param))\n\t\t\t\t\tparam = make([]rune, 0)\n\t\t\t\t}\n\t\t\t\tparamsNum++\n\t\t\t\texpt = make([]rune, 0)\n\t\t\t\texpt = append(expt, '(')\n\t\t\t} else if v == ')' {\n\t\t\t\tstartexp = false\n\t\t\t\texpt = append(expt, ')')\n\t\t\t\tout = append(out, expt...)\n\t\t\t\tparam = make([]rune, 0)\n\t\t\t} else if v == '?' {\n\t\t\t\tparams = append(params, \":\")\n\t\t\t} else {\n\t\t\t\tout = append(out, v)\n\t\t\t}\n\t\t}\n\t\tif len(param) > 0 {\n\t\t\tif paramsNum > 0 {\n\t\t\t\tout = append(out, []rune(`(.+)`)...)\n\t\t\t}\n\t\t\tparams = append(params, \":\"+string(param))\n\t\t}\n\t\treturn true, params, string(out)\n\t}\n\treturn false, nil, \"\"\n}\n", "// Copyright 2014 beego Author. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage web\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/beego/beego/v2/server/web/context\"\n)\n\ntype testInfo struct {\n\tpattern          string\n\trequestUrl       string\n\tparams           map[string]string\n\tshouldMatchOrNot bool\n}\n\nvar routers []testInfo\n\nfunc matchTestInfo(pattern, url string, params map[string]string) testInfo {\n\treturn testInfo{\n\t\tpattern:          pattern,\n\t\trequestUrl:       url,\n\t\tparams:           params,\n\t\tshouldMatchOrNot: true,\n\t}\n}\n\nfunc notMatchTestInfo(pattern, url string) testInfo {\n\treturn testInfo{\n\t\tpattern:          pattern,\n\t\trequestUrl:       url,\n\t\tparams:           nil,\n\t\tshouldMatchOrNot: false,\n\t}\n}\n\nfunc init() {\n\trouters = make([]testInfo, 0, 128)\n\t// match example\n\trouters = append(routers, matchTestInfo(\"/topic/?:auth:int\", \"/topic\", nil))\n\trouters = append(routers, matchTestInfo(\"/topic/?:auth:int\", \"/topic/123\", map[string]string{\":auth\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth\", \"/topic/1\", map[string]string{\":id\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth\", \"/topic/1/2\", map[string]string{\":id\": \"1\", \":auth\": \"2\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth:int\", \"/topic/1\", map[string]string{\":id\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/topic/:id/?:auth:int\", \"/topic/1/123\", map[string]string{\":id\": \"1\", \":auth\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/:id\", \"/123\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/hello/?:id\", \"/hello\", map[string]string{\":id\": \"\"}))\n\trouters = append(routers, matchTestInfo(\"/\", \"/\", nil))\n\trouters = append(routers, matchTestInfo(\"/customer/login\", \"/customer/login\", nil))\n\trouters = append(routers, matchTestInfo(\"/customer/login\", \"/customer/login.json\", map[string]string{\":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/*\", \"/http://customer/123/\", map[string]string{\":splat\": \"http://customer/123/\"}))\n\trouters = append(routers, matchTestInfo(\"/*\", \"/customer/2009/12/11\", map[string]string{\":splat\": \"customer/2009/12/11\"}))\n\trouters = append(routers, matchTestInfo(\"/aa/*/bb\", \"/aa/2009/bb\", map[string]string{\":splat\": \"2009\"}))\n\trouters = append(routers, matchTestInfo(\"/cc/*/dd\", \"/cc/2009/11/dd\", map[string]string{\":splat\": \"2009/11\"}))\n\trouters = append(routers, matchTestInfo(\"/cc/:id/*\", \"/cc/2009/11/dd\", map[string]string{\":id\": \"2009\", \":splat\": \"11/dd\"}))\n\trouters = append(routers, matchTestInfo(\"/ee/:year/*/ff\", \"/ee/2009/11/ff\", map[string]string{\":year\": \"2009\", \":splat\": \"11\"}))\n\trouters = append(routers, matchTestInfo(\"/thumbnail/:size/uploads/*\", \"/thumbnail/100x100/uploads/items/2014/04/20/dPRCdChkUd651t1Hvs18.jpg\", map[string]string{\":size\": \"100x100\", \":splat\": \"items/2014/04/20/dPRCdChkUd651t1Hvs18.jpg\"}))\n\trouters = append(routers, matchTestInfo(\"/*.*\", \"/nice/api.json\", map[string]string{\":path\": \"nice/api\", \":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/:name/*.*\", \"/nice/api.json\", map[string]string{\":name\": \"nice\", \":path\": \"api\", \":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/:name/test/*.*\", \"/nice/test/api.json\", map[string]string{\":name\": \"nice\", \":path\": \"api\", \":ext\": \"json\"}))\n\trouters = append(routers, matchTestInfo(\"/dl/:width:int/:height:int/*.*\", \"/dl/48/48/05ac66d9bda00a3acf948c43e306fc9a.jpg\", map[string]string{\":width\": \"48\", \":height\": \"48\", \":ext\": \"jpg\", \":path\": \"05ac66d9bda00a3acf948c43e306fc9a\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id:int\", \"/v1/shop/123\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id\\\\((a|b|c)\\\\)\", \"/v1/shop/123(a)\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id\\\\((a|b|c)\\\\)\", \"/v1/shop/123(b)\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id\\\\((a|b|c)\\\\)\", \"/v1/shop/123(c)\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/:year:int/:month:int/:id/:endid\", \"/1111/111/aaa/aaa\", map[string]string{\":year\": \"1111\", \":month\": \"111\", \":id\": \"aaa\", \":endid\": \"aaa\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id/:name\", \"/v1/shop/123/nike\", map[string]string{\":id\": \"123\", \":name\": \"nike\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id/account\", \"/v1/shop/123/account\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:name:string\", \"/v1/shop/nike\", map[string]string{\":name\": \"nike\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id([0-9]+)\", \"/v1/shop//123\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id([0-9]+)_:name\", \"/v1/shop/123_nike\", map[string]string{\":id\": \"123\", \":name\": \"nike\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/:id(.+)_cms.html\", \"/v1/shop/123_cms.html\", map[string]string{\":id\": \"123\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/shop/cms_:id(.+)_:page(.+).html\", \"/v1/shop/cms_123_1.html\", map[string]string{\":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/:v/cms/aaa_:id(.+)_:page(.+).html\", \"/v1/2/cms/aaa_123_1.html\", map[string]string{\":v\": \"2\", \":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/:v/cms_:id(.+)_:page(.+).html\", \"/v1/2/cms_123_1.html\", map[string]string{\":v\": \"2\", \":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/v1/:v(.+)_cms/ttt_:id(.+)_:page(.+).html\", \"/v1/2_cms/ttt_123_1.html\", map[string]string{\":v\": \"2\", \":id\": \"123\", \":page\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/api/projects/:pid/members/?:mid\", \"/api/projects/1/members\", map[string]string{\":pid\": \"1\"}))\n\trouters = append(routers, matchTestInfo(\"/api/projects/:pid/members/?:mid\", \"/api/projects/1/members/2\", map[string]string{\":pid\": \"1\", \":mid\": \"2\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/?:day\", \"/2020/11/10\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/?:day\", \"/2020/11\", map[string]string{\":year\": \"2020\", \":month\": \"11\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year\", \"/2020\", map[string]string{\":year\": \"2020\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year([0-9]+)/?:month([0-9]+)/mid/?:day([0-9]+)/?:hour([0-9]+)\", \"/2020/11/mid/10/24\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\", \":hour\": \"24\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/mid/?:day/?:hour\", \"/2020/mid/10\", map[string]string{\":year\": \"2020\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/mid/?:day/?:hour\", \"/2020/11/mid\", map[string]string{\":year\": \"2020\", \":month\": \"11\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/?:month/mid/?:day/?:hour\", \"/mid/10/24\", map[string]string{\":day\": \"10\", \":hour\": \"24\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year([0-9]+)/:month([0-9]+)/mid/:day([0-9]+)/?:hour([0-9]+)\", \"/2020/11/mid/10/24\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\", \":hour\": \"24\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/:month/mid/:day/?:hour\", \"/11/mid/10/24\", map[string]string{\":month\": \"11\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/:month/mid/:day/?:hour\", \"/2020/11/mid/10\", map[string]string{\":year\": \"2020\", \":month\": \"11\", \":day\": \"10\"}))\n\trouters = append(routers, matchTestInfo(\"/?:year/:month/mid/:day/?:hour\", \"/11/mid/10\", map[string]string{\":month\": \"11\", \":day\": \"10\"}))\n\t// not match example\n\n\t// https://github.com/beego/beego/v2/issues/3865\n\trouters = append(routers, notMatchTestInfo(\"/read_:id:int\\\\.htm\", \"/read_222htm\"))\n\trouters = append(routers, notMatchTestInfo(\"/read_:id:int\\\\.htm\", \"/read_222_htm\"))\n\trouters = append(routers, notMatchTestInfo(\"/read_:id:int\\\\.htm\", \" /read_262shtm\"))\n\n\t// test .html, .json not suffix\n\tconst abcHtml = \"/suffix/abc.html\"\n\trouters = append(routers, notMatchTestInfo(abcHtml, \"/suffix.html/abc\"))\n\trouters = append(routers, matchTestInfo(\"/suffix/abc\", abcHtml, nil))\n\trouters = append(routers, matchTestInfo(\"/suffix/*\", abcHtml, nil))\n\trouters = append(routers, notMatchTestInfo(\"/suffix/*\", \"/suffix.html/a\"))\n\tconst abcSuffix = \"/abc/suffix/*\"\n\trouters = append(routers, notMatchTestInfo(abcSuffix, \"/abc/suffix.html/a\"))\n\trouters = append(routers, matchTestInfo(abcSuffix, \"/abc/suffix/a\", nil))\n\trouters = append(routers, notMatchTestInfo(abcSuffix, \"/abc.j/suffix/a\"))\n\n}\n\nfunc TestTreeRouters(t *testing.T) {\n\tfor _, r := range routers {\n\n\t\tshouldMatch := r.shouldMatchOrNot\n\t\ttr := NewTree()\n\t\ttr.AddRouter(r.pattern, \"astaxie\")\n\t\tctx := context.NewContext()\n\t\tobj := tr.Match(r.requestUrl, ctx)\n\t\tif !shouldMatch {\n\t\t\tif obj != nil {\n\t\t\t\tt.Fatal(\"pattern:\", r.pattern, \", should not match\", r.requestUrl)\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\t\tt.Fatal(\"pattern:\", r.pattern+\", can't match obj, Expect \", r.requestUrl)\n\t\t}\n\t\tif r.params != nil {\n\t\t\tfor k, v := range r.params {\n\t\t\t\tif vv := ctx.Input.Param(k); vv != v {\n\t\t\t\t\tt.Fatal(\"The Rule: \" + r.pattern + \"\\nThe RequestURL:\" + r.requestUrl + \"\\nThe Key is \" + k + \", The Value should be: \" + v + \", but get: \" + vv)\n\t\t\t\t} else if vv == \"\" && v != \"\" {\n\t\t\t\t\tt.Fatal(r.pattern + \"    \" + r.requestUrl + \" get param empty:\" + k)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttime.Sleep(time.Second)\n}\n\nfunc TestStaticPath(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/topic/:id\", \"wildcard\")\n\ttr.AddRouter(\"/topic\", \"static\")\n\tctx := context.NewContext()\n\tobj := tr.Match(\"/topic\", ctx)\n\tif obj == nil || obj.(string) != \"static\" {\n\t\tt.Fatal(\"/topic is  a static route\")\n\t}\n\tobj = tr.Match(\"/topic/1\", ctx)\n\tif obj == nil || obj.(string) != \"wildcard\" {\n\t\tt.Fatal(\"/topic/1 is a wildcard route\")\n\t}\n}\n\nfunc TestAddTree(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/shop/:id/account\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/ttt_:id(.+)_:page(.+).html\", \"astaxie\")\n\tt1 := NewTree()\n\tt1.AddTree(\"/v1/zl\", tr)\n\tctx := context.NewContext()\n\tobj := t1.Match(\"/v1/zl/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/zl/shop/:id/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":id\") != \"123\" {\n\t\tt.Fatal(\"get :id param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t1.Match(\"/v1/zl/shop/123/ttt_1_12.html\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/zl//shop/:sd/ttt_:id(.+)_:page(.+).html can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":sd\") != \"123\" || ctx.Input.Param(\":id\") != \"1\" || ctx.Input.Param(\":page\") != \"12\" {\n\t\tt.Fatal(\"get :sd :id :page param error\")\n\t}\n\n\tt2 := NewTree()\n\tt2.AddTree(\"/v1/:shopid\", tr)\n\tctx.Input.Reset(ctx)\n\tobj = t2.Match(\"/v1/zl/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/:shopid/shop/:id/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":id\") != \"123\" || ctx.Input.Param(\":shopid\") != \"zl\" {\n\t\tt.Fatal(\"get :id :shopid param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t2.Match(\"/v1/zl/shop/123/ttt_1_12.html\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/v1/:shopid/shop/:sd/ttt_:id(.+)_:page(.+).html can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get :shopid param error\")\n\t}\n\tif ctx.Input.Param(\":sd\") != \"123\" || ctx.Input.Param(\":id\") != \"1\" || ctx.Input.Param(\":page\") != \"12\" || ctx.Input.Param(\":shopid\") != \"zl\" {\n\t\tt.Fatal(\"get :sd :id :page :shopid param error\")\n\t}\n}\n\nfunc TestAddTree2(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/shop/:id/account\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/ttt_:id(.+)_:page(.+).html\", \"astaxie\")\n\tt3 := NewTree()\n\tt3.AddTree(\"/:version(v1|v2)/:prefix\", tr)\n\tctx := context.NewContext()\n\tobj := t3.Match(\"/v1/zl/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/:version(v1|v2)/:prefix/shop/:id/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":id\") != \"123\" || ctx.Input.Param(\":prefix\") != \"zl\" || ctx.Input.Param(\":version\") != \"v1\" {\n\t\tt.Fatal(\"get :id :prefix :version param error\")\n\t}\n}\n\nfunc TestAddTree3(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/create\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/account\", \"astaxie\")\n\tt3 := NewTree()\n\tt3.AddTree(\"/table/:num\", tr)\n\tctx := context.NewContext()\n\tobj := t3.Match(\"/table/123/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/table/:num/shop/:sd/account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":num\") != \"123\" || ctx.Input.Param(\":sd\") != \"123\" {\n\t\tt.Fatal(\"get :num :sd param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t3.Match(\"/table/123/create\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/table/:num/create can't get obj \")\n\t}\n}\n\nfunc TestAddTree4(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/create\", \"astaxie\")\n\ttr.AddRouter(\"/shop/:sd/:account\", \"astaxie\")\n\tt4 := NewTree()\n\tt4.AddTree(\"/:info:int/:num/:id\", tr)\n\tctx := context.NewContext()\n\tobj := t4.Match(\"/12/123/456/shop/123/account\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/:info:int/:num/:id/shop/:sd/:account can't get obj \")\n\t}\n\tif ctx.Input.ParamsLen() == 0 {\n\t\tt.Fatal(\"get param error\")\n\t}\n\tif ctx.Input.Param(\":info\") != \"12\" || ctx.Input.Param(\":num\") != \"123\" ||\n\t\tctx.Input.Param(\":id\") != \"456\" || ctx.Input.Param(\":sd\") != \"123\" ||\n\t\tctx.Input.Param(\":account\") != \"account\" {\n\t\tt.Fatal(\"get :info :num :id :sd :account param error\")\n\t}\n\tctx.Input.Reset(ctx)\n\tobj = t4.Match(\"/12/123/456/create\", ctx)\n\tif obj == nil || obj.(string) != \"astaxie\" {\n\t\tt.Fatal(\"/:info:int/:num/:id/create can't get obj \")\n\t}\n}\n\n// Test for issue #1595\nfunc TestAddTree5(t *testing.T) {\n\ttr := NewTree()\n\ttr.AddRouter(\"/v1/shop/:id\", \"shopdetail\")\n\ttr.AddRouter(\"/v1/shop/\", \"shophome\")\n\tctx := context.NewContext()\n\tobj := tr.Match(\"/v1/shop/\", ctx)\n\tif obj == nil || obj.(string) != \"shophome\" {\n\t\tt.Fatal(\"url /v1/shop/ need match router /v1/shop/ \")\n\t}\n}\nfunc TestSplitPath(t *testing.T) {\n\ta := splitPath(\"\")\n\tif len(a) != 0 {\n\t\tt.Fatal(\"/ should retrun []\")\n\t}\n\ta = splitPath(\"/\")\n\tif len(a) != 0 {\n\t\tt.Fatal(\"/ should retrun []\")\n\t}\n\ta = splitPath(\"/admin\")\n\tif len(a) != 1 || a[0] != \"admin\" {\n\t\tt.Fatal(\"/admin should retrun [admin]\")\n\t}\n\ta = splitPath(\"/admin/\")\n\tif len(a) != 1 || a[0] != \"admin\" {\n\t\tt.Fatal(\"/admin/ should retrun [admin]\")\n\t}\n\ta = splitPath(\"/admin/users\")\n\tif len(a) != 2 || a[0] != \"admin\" || a[1] != \"users\" {\n\t\tt.Fatal(\"/admin should retrun [admin users]\")\n\t}\n\ta = splitPath(\"/admin/:id:int\")\n\tif len(a) != 2 || a[0] != \"admin\" || a[1] != \":id:int\" {\n\t\tt.Fatal(\"/admin should retrun [admin :id:int]\")\n\t}\n}\n\nfunc TestSplitSegment(t *testing.T) {\n\n\titems := map[string]struct {\n\t\tisReg  bool\n\t\tparams []string\n\t\tregStr string\n\t}{\n\t\t\"admin\":                      {false, nil, \"\"},\n\t\t\"*\":                          {true, []string{\":splat\"}, \"\"},\n\t\t\"*.*\":                        {true, []string{\".\", \":path\", \":ext\"}, \"\"},\n\t\t\":id\":                        {true, []string{\":id\"}, \"\"},\n\t\t\"?:id\":                       {true, []string{\":\", \":id\"}, \"\"},\n\t\t\":id:int\":                    {true, []string{\":id\"}, \"([0-9]+)\"},\n\t\t\":name:string\":               {true, []string{\":name\"}, `([\\w]+)`},\n\t\t\":id([0-9]+)\":                {true, []string{\":id\"}, `([0-9]+)`},\n\t\t\":id([0-9]+)_:name\":          {true, []string{\":id\", \":name\"}, `([0-9]+)_(.+)`},\n\t\t\":id(.+)_cms.html\":           {true, []string{\":id\"}, `(.+)_cms.html`},\n\t\t\":id(.+)_cms\\\\.html\":         {true, []string{\":id\"}, `(.+)_cms\\.html`},\n\t\t\"cms_:id(.+)_:page(.+).html\": {true, []string{\":id\", \":page\"}, `cms_(.+)_(.+).html`},\n\t\t`:app(a|b|c)`:                {true, []string{\":app\"}, `(a|b|c)`},\n\t\t`:app\\((a|b|c)\\)`:            {true, []string{\":app\"}, `(.+)\\((a|b|c)\\)`},\n\t}\n\n\tfor pattern, v := range items {\n\t\tb, w, r := splitSegment(pattern)\n\t\tif b != v.isReg || r != v.regStr || strings.Join(w, \",\") != strings.Join(v.params, \",\") {\n\t\t\tt.Fatalf(\"%s should return %t,%s,%q, got %t,%s,%q\", pattern, v.isReg, v.params, v.regStr, b, w, r)\n\t\t}\n\t}\n}\n"], "filenames": ["CHANGELOG.md", "server/web/tree.go", "server/web/tree_test.go"], "buggy_code_start_loc": [1, 345, 19], "buggy_code_end_loc": [1, 346, 140], "fixing_code_start_loc": [2, 345, 20], "fixing_code_end_loc": [3, 348, 154], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in the route lookup process in beego through 2.0.1, allows attackers to bypass access control.", "other": {"cve": {"id": "CVE-2021-30080", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-05T16:15:12.123", "lastModified": "2022-04-12T20:08:20.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the route lookup process in beego through 2.0.1, allows attackers to bypass access control."}, {"lang": "es", "value": "Se ha detectado un problema en el proceso de b\u00fasqueda de rutas en beego versiones hasta 2.0.1, que permite a atacantes omitir el control de acceso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:beego:beego:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "BB99A2E0-769A-4782-874E-36A21E97D17A"}]}]}], "references": [{"url": "https://github.com/beego/beego/commit/d5df5e470d0a8ed291930ae802fd7e6b95226519", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/beego/beego/commit/d5df5e470d0a8ed291930ae802fd7e6b95226519"}}