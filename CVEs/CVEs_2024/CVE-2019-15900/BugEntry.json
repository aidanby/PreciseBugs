{"buggy_code": ["CC?=clang\nYACC?=yacc\nBIN=doas\nPREFIX?=/usr/local\nMANDIR?=$(DESTDIR)$(PREFIX)/man\nSYSCONFDIR?=$(DESTDIR)$(PREFIX)/etc\nOBJECTS=doas.o env.o execvpe.o reallocarray.o y.tab.o\n# Can set GLOBAL_PATH here to set PATH for target user.\n# TARGETPATH=-DGLOBAL_PATH=\\\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\\\"\nCFLAGS+=-DUSE_PAM -DDOAS_CONF=\\\"${SYSCONFDIR}/doas.conf\\\" $(TARGETPATH)\nLDFLAGS+=-lpam\nUNAME_S := $(shell uname -s)\nifeq ($(UNAME_S),Linux)\n    LDFLAGS+=-lpam_misc\n    OBJECTS+=strlcat.o strlcpy.o\n    CFLAGS+=-D_GNU_SOURCE\nendif\nifeq ($(UNAME_S),FreeBSD)\n    CFLAGS+=-DHAVE_LOGIN_CAP_H\n    LDFLAGS+=-lutil\nendif\nifeq ($(UNAME_S),SunOS)\n    CPPFLAGS+=-Icompat -include compat.h\n    SAFE_PATH?=/bin:/sbin:/usr/bin:/usr/sbin:$(PREFIX)/bin:$(PREFIX)/sbin\n    GLOBAL_PATH?=/bin:/sbin:/usr/bin:/usr/sbin:$(PREFIX)/bin:$(PREFIX)/sbin\n    CFLAGS+=-DSOLARIS_PAM -DSAFE_PATH=\\\"$(SAFE_PATH)\\\" -DGLOBAL_PATH=\\\"$(GLOBAL_PATH)\\\"\n    COMPAT=errc.o pm_pam_conv.o setresuid.o verrc.o\n    OBJECTS+=$(COMPAT:%.o=compat/%.o)\nendif\n\nall: $(OBJECTS)\n\t$(CC) -o $(BIN) $(OBJECTS) $(LDFLAGS)\n\nenv.o: doas.h env.c\n\nexecvpe.o: doas.h execvpe.c\n\ndoas.o: doas.h doas.c parse.y\n\nreallocarray.o: doas.h reallocarray.c\n\ny.tab.o: parse.y\n\t$(YACC) parse.y\n\t$(CC) $(CFLAGS) -c y.tab.c\n\ninstall: $(BIN)\n\tmkdir -p $(DESTDIR)$(PREFIX)/bin\n\tcp $(BIN) $(DESTDIR)$(PREFIX)/bin/\n\tchmod 4755 $(DESTDIR)$(PREFIX)/bin/$(BIN)\n\tmkdir -p $(MANDIR)/man1\n\tcp doas.1 $(MANDIR)/man1/\n\tmkdir -p $(MANDIR)/man5\n\tcp doas.conf.5 $(MANDIR)/man5/\n\nclean:\n\trm -f $(BIN) $(OBJECTS) y.tab.c\n\n", "/* $OpenBSD: doas.c,v 1.57 2016/06/19 19:29:43 martijn Exp $ */\n/*\n * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n\n#if defined(HAVE_INTTYPES_H)\n#include <inttypes.h>\n#endif\n\n#include <limits.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <syslog.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#if defined(HAVE_LOGIN_CAP_H)\n#include <login_cap.h>\n#endif\n\n#if defined(USE_BSD_AUTH)\n#include <bsd_auth.h>\n#include <readpassphrase.h>\n#endif\n\n#if defined(USE_PAM)\n#include <security/pam_appl.h>\n\n#if defined(OPENPAM) /* BSD, MacOS & certain Linux distros */\n#include <security/openpam.h>\nstatic struct pam_conv pamc = { openpam_ttyconv, NULL };\n\n#elif defined(__LINUX_PAM__) /* Linux */\n#include <security/pam_misc.h>\nstatic struct pam_conv pamc = { misc_conv, NULL };\n\n#elif defined(SOLARIS_PAM) /* illumos & Solaris */\n#include \"pm_pam_conv.h\"\nstatic struct pam_conv pamc = { pam_tty_conv, NULL };\n\n#endif /* OPENPAM */\n#endif /* USE_PAM */\n\n#include \"doas.h\"\n\nstatic void \nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\");\n\texit(1);\n}\n\n#ifdef linux\nvoid\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}\n#endif\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}\n\nstatic void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\"doas: Unable to set UID\\n\");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}\n\n#if defined(USE_BSD_AUTH)      \nstatic void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrc(1, EPERM, NULL);\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}\n#endif\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"a:C:nsu:\")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \"a:C:Lnsu:\")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \"pw_name too long\");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* #endif */\n\n\t\tpam_err = pam_start(\"doas\", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(LOG_ERR, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \"failed auth for %s\", myname);\n                                errx(EXIT_FAILURE, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \"failed auth for %s\", myname);\n                        errx(EXIT_FAILURE, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setresgid\");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setregid\");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \"initgroups\");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \"setresuid\");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \"setreuid\");\n\t#endif\n#endif\n        /*\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}\n\n"], "fixing_code": ["CC?=clang\nYACC?=yacc\nBIN=doas\nPREFIX?=/usr/local\nMANDIR?=$(DESTDIR)$(PREFIX)/man\nSYSCONFDIR?=$(DESTDIR)$(PREFIX)/etc\nOBJECTS=doas.o env.o execvpe.o reallocarray.o y.tab.o\nOPT?=-O2\n# Can set GLOBAL_PATH here to set PATH for target user.\n# TARGETPATH=-DGLOBAL_PATH=\\\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\\\"\nCFLAGS+=-Wall $(OPT) -DUSE_PAM -DDOAS_CONF=\\\"${SYSCONFDIR}/doas.conf\\\" $(TARGETPATH)\nLDFLAGS+=-lpam\nUNAME_S := $(shell uname -s)\nifeq ($(UNAME_S),Linux)\n    LDFLAGS+=-lpam_misc\n    OBJECTS+=strlcat.o strlcpy.o\n    CFLAGS+=-D_GNU_SOURCE\nendif\nifeq ($(UNAME_S),FreeBSD)\n    CFLAGS+=-DHAVE_LOGIN_CAP_H\n    LDFLAGS+=-lutil\nendif\nifeq ($(UNAME_S),SunOS)\n    CPPFLAGS+=-Icompat -include compat.h\n    SAFE_PATH?=/bin:/sbin:/usr/bin:/usr/sbin:$(PREFIX)/bin:$(PREFIX)/sbin\n    GLOBAL_PATH?=/bin:/sbin:/usr/bin:/usr/sbin:$(PREFIX)/bin:$(PREFIX)/sbin\n    CFLAGS+=-DSOLARIS_PAM -DSAFE_PATH=\\\"$(SAFE_PATH)\\\" -DGLOBAL_PATH=\\\"$(GLOBAL_PATH)\\\"\n    COMPAT=errc.o pm_pam_conv.o setresuid.o verrc.o\n    OBJECTS+=$(COMPAT:%.o=compat/%.o)\nendif\n\nall: $(OBJECTS)\n\t$(CC) -o $(BIN) $(OBJECTS) $(LDFLAGS)\n\nenv.o: doas.h env.c\n\nexecvpe.o: doas.h execvpe.c\n\ndoas.o: doas.h doas.c parse.y\n\nreallocarray.o: doas.h reallocarray.c\n\ny.tab.o: parse.y\n\t$(YACC) parse.y\n\t$(CC) $(CFLAGS) -c y.tab.c\n\ninstall: $(BIN)\n\tmkdir -p $(DESTDIR)$(PREFIX)/bin\n\tcp $(BIN) $(DESTDIR)$(PREFIX)/bin/\n\tchmod 4755 $(DESTDIR)$(PREFIX)/bin/$(BIN)\n\tmkdir -p $(MANDIR)/man1\n\tcp doas.1 $(MANDIR)/man1/\n\tmkdir -p $(MANDIR)/man5\n\tcp doas.conf.5 $(MANDIR)/man5/\n\nclean:\n\trm -f $(BIN) $(OBJECTS) y.tab.c\n\n", "/* $OpenBSD: doas.c,v 1.57 2016/06/19 19:29:43 martijn Exp $ */\n/*\n * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n\n#if defined(HAVE_INTTYPES_H)\n#include <inttypes.h>\n#endif\n\n#include <limits.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <syslog.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#if defined(HAVE_LOGIN_CAP_H)\n#include <login_cap.h>\n#endif\n\n#if defined(USE_BSD_AUTH)\n#include <bsd_auth.h>\n#include <readpassphrase.h>\n#endif\n\n#if defined(USE_PAM)\n#include <security/pam_appl.h>\n\n#if defined(OPENPAM) /* BSD, MacOS & certain Linux distros */\n#include <security/openpam.h>\nstatic struct pam_conv pamc = { openpam_ttyconv, NULL };\n\n#elif defined(__LINUX_PAM__) /* Linux */\n#include <security/pam_misc.h>\nstatic struct pam_conv pamc = { misc_conv, NULL };\n\n#elif defined(SOLARIS_PAM) /* illumos & Solaris */\n#include \"pm_pam_conv.h\"\nstatic struct pam_conv pamc = { pam_tty_conv, NULL };\n\n#endif /* OPENPAM */\n#endif /* USE_PAM */\n\n#include \"doas.h\"\n\nstatic void \nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\");\n\texit(1);\n}\n\n#ifdef linux\nvoid\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}\n#endif\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \"%d\", uid);\n        if (status != 1)\n           return -1;\n\t#endif\n\treturn 0;\n}\n\nstatic int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \"%d\", gid);\n        if (status != 1)\n            return -1;\n\t#endif\n\treturn 0;\n}\n\nstatic int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}\n\nstatic void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\"doas: Unable to set UID\\n\");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}\n\n#if defined(USE_BSD_AUTH)      \nstatic void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrc(1, EPERM, NULL);\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}\n#endif\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"a:C:nsu:\")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \"a:C:Lnsu:\")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \"pw_name too long\");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* #endif */\n\n\t\tpam_err = pam_start(\"doas\", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(LOG_ERR, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \"failed auth for %s\", myname);\n                                errx(EXIT_FAILURE, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \"failed auth for %s\", myname);\n                        errx(EXIT_FAILURE, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setresgid\");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setregid\");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \"initgroups\");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \"setresuid\");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \"setreuid\");\n\t#endif\n#endif\n        /*\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}\n\n"], "filenames": ["Makefile", "doas.c"], "buggy_code_start_loc": [7, 88], "buggy_code_end_loc": [11, 132], "fixing_code_start_loc": [8, 88], "fixing_code_end_loc": [12, 145], "type": "CWE-754", "message": "An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root.", "other": {"cve": {"id": "CVE-2019-15900", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-18T16:15:10.257", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root."}, {"lang": "es", "value": "Se detect\u00f3 un problema en slicer69 doas versiones anteriores a 6.2 en determinadas plataformas diferentes de OpenBSD. En plataformas sin strtonum(3), se utiliz\u00f3 sscanf sin comprobar los casos de error. En cambio, la variable no inicializada errstr fue comprobada y en algunos casos se devolvi\u00f3 con \u00e9xito incluso si sscanf fallaba. El resultado fue que, en vez de reportar que el nombre de usuario o nombre de grupo suministrado no exist\u00eda, ejecutar\u00eda el comando como root."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}, {"lang": "en", "value": "CWE-863"}, {"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:doas_project:doas:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2", "matchCriteriaId": "B57E67C2-7E3C-4F0C-AC58-B958EAFFE1F9"}]}]}], "references": [{"url": "https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/slicer69/doas/compare/6.1p1...6.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531"}}