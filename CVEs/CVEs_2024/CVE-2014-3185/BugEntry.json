{"buggy_code": ["/*\n * USB ConnectTech WhiteHEAT driver\n *\n *\tCopyright (C) 2002\n *\t    Connect Tech Inc.\n *\n *\tCopyright (C) 1999 - 2001\n *\t    Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation; either version 2 of the License, or\n *\t(at your option) any later version.\n *\n * See Documentation/usb/usb-serial.txt for more information on using this\n * driver\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <asm/termbits.h>\n#include <linux/usb.h>\n#include <linux/serial_reg.h>\n#include <linux/serial.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/ezusb.h>\n#include \"whiteheat.h\"\t\t\t/* WhiteHEAT specific commands */\n\n#ifndef CMSPAR\n#define CMSPAR 0\n#endif\n\n/*\n * Version Information\n */\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>, Stuart MacDonald <stuartm@connecttech.com>\"\n#define DRIVER_DESC \"USB ConnectTech WhiteHEAT driver\"\n\n#define CONNECT_TECH_VENDOR_ID\t\t0x0710\n#define CONNECT_TECH_FAKE_WHITE_HEAT_ID\t0x0001\n#define CONNECT_TECH_WHITE_HEAT_ID\t0x8001\n\n/*\n   ID tables for whiteheat are unusual, because we want to different\n   things for different versions of the device.  Eventually, this\n   will be doable from a single table.  But, for now, we define two\n   separate ID tables, and then a third table that combines them\n   just for the purpose of exporting the autoloading information.\n*/\nstatic const struct usb_device_id id_table_std[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id id_table_prerenumeration[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n\n/* function prototypes for the Connect Tech WhiteHEAT prerenumeration device */\nstatic int  whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  whiteheat_firmware_attach(struct usb_serial *serial);\n\n/* function prototypes for the Connect Tech WhiteHEAT serial converter */\nstatic int  whiteheat_attach(struct usb_serial *serial);\nstatic void whiteheat_release(struct usb_serial *serial);\nstatic int  whiteheat_port_probe(struct usb_serial_port *port);\nstatic int  whiteheat_port_remove(struct usb_serial_port *port);\nstatic int  whiteheat_open(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port);\nstatic void whiteheat_close(struct usb_serial_port *port);\nstatic int  whiteheat_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg);\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port, struct ktermios *old);\nstatic int  whiteheat_tiocmget(struct tty_struct *tty);\nstatic int  whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear);\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state);\n\nstatic struct usb_serial_driver whiteheat_fake_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheatnofirm\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT - (prerenumeration)\",\n\t.id_table =\t\tid_table_prerenumeration,\n\t.num_ports =\t\t1,\n\t.probe =\t\twhiteheat_firmware_download,\n\t.attach =\t\twhiteheat_firmware_attach,\n};\n\nstatic struct usb_serial_driver whiteheat_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheat\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT\",\n\t.id_table =\t\tid_table_std,\n\t.num_ports =\t\t4,\n\t.attach =\t\twhiteheat_attach,\n\t.release =\t\twhiteheat_release,\n\t.port_probe =\t\twhiteheat_port_probe,\n\t.port_remove =\t\twhiteheat_port_remove,\n\t.open =\t\t\twhiteheat_open,\n\t.close =\t\twhiteheat_close,\n\t.ioctl =\t\twhiteheat_ioctl,\n\t.set_termios =\t\twhiteheat_set_termios,\n\t.break_ctl =\t\twhiteheat_break_ctl,\n\t.tiocmget =\t\twhiteheat_tiocmget,\n\t.tiocmset =\t\twhiteheat_tiocmset,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&whiteheat_fake_device, &whiteheat_device, NULL\n};\n\nstruct whiteheat_command_private {\n\tstruct mutex\t\tmutex;\n\t__u8\t\t\tport_running;\n\t__u8\t\t\tcommand_finished;\n\twait_queue_head_t\twait_command; /* for handling sleeping whilst\n\t\t\t\t\t\t waiting for a command to\n\t\t\t\t\t\t finish */\n\t__u8\t\t\tresult_buffer[64];\n};\n\nstruct whiteheat_private {\n\t__u8\t\t\tmcr;\t\t/* FIXME: no locking on mcr */\n};\n\n\n/* local function prototypes */\nstatic int start_command_port(struct usb_serial *serial);\nstatic void stop_command_port(struct usb_serial *serial);\nstatic void command_port_write_callback(struct urb *urb);\nstatic void command_port_read_callback(struct urb *urb);\n\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize);\nstatic int firm_open(struct usb_serial_port *port);\nstatic int firm_close(struct usb_serial_port *port);\nstatic void firm_setup_port(struct tty_struct *tty);\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx);\nstatic int firm_get_dtr_rts(struct usb_serial_port *port);\nstatic int firm_report_tx_done(struct usb_serial_port *port);\n\n\n#define COMMAND_PORT\t\t4\n#define COMMAND_TIMEOUT\t\t(2*HZ)\t/* 2 second timeout for a command */\n#define\tCOMMAND_TIMEOUT_MS\t2000\n#define CLOSING_DELAY\t\t(30 * HZ)\n\n\n/*****************************************************************************\n * Connect Tech's White Heat prerenumeration driver functions\n *****************************************************************************/\n\n/* steps to download the firmware to the WhiteHEAT device:\n - hold the reset (by writing to the reset bit of the CPUCS register)\n - download the VEND_AX.HEX file to the chip using VENDOR_REQUEST-ANCHOR_LOAD\n - release the reset (by writing to the CPUCS register)\n - download the WH.HEX file for all addresses greater than 0x1b3f using\n   VENDOR_REQUEST-ANCHOR_EXTERNAL_RAM_LOAD\n - hold the reset\n - download the WH.HEX file for all addresses less than 0x1b40 using\n   VENDOR_REQUEST_ANCHOR_LOAD\n - release the reset\n - device renumerated itself and comes up as new device id with all\n   firmware download completed.\n*/\nstatic int whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint response;\n\n\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat_loader.fw\");\n\tif (response >= 0) {\n\t\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat.fw\");\n\t\tif (response >= 0)\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n\nstatic int whiteheat_firmware_attach(struct usb_serial *serial)\n{\n\t/* We want this device to fail to have a driver assigned to it */\n\treturn 1;\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat serial driver functions\n *****************************************************************************/\nstatic int whiteheat_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\t/*\n\t * When the module is reloaded the firmware is still there and\n\t * the endpoints are still in the usb core unchanged. This is the\n\t * unlinking bug in disguise. Same for the call below.\n\t */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\t/* See the comment on the usb_clear_halt() above */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\n\treturn 0;\n\nno_firmware:\n\t/* Firmware likely not running */\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\n\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\n\nstatic void whiteheat_release(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\n\t/* free up our private data for our command port */\n\tcommand_port = serial->port[COMMAND_PORT];\n\tkfree(usb_get_serial_port_data(command_port));\n}\n\nstatic int whiteheat_port_probe(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_port_data(port, info);\n\n\treturn 0;\n}\n\nstatic int whiteheat_port_remove(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = usb_get_serial_port_data(port);\n\tkfree(info);\n\n\treturn 0;\n}\n\nstatic int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\n\t/* send an open port command */\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\n\t/* Work around HCD bugs */\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}\n\n\nstatic void whiteheat_close(struct usb_serial_port *port)\n{\n\tfirm_report_tx_done(port);\n\tfirm_close(port);\n\n\tusb_serial_generic_close(port);\n\n\tstop_command_port(port->serial);\n}\n\nstatic int whiteheat_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\tunsigned int modem_signals = 0;\n\n\tfirm_get_dtr_rts(port);\n\tif (info->mcr & UART_MCR_DTR)\n\t\tmodem_signals |= TIOCM_DTR;\n\tif (info->mcr & UART_MCR_RTS)\n\t\tmodem_signals |= TIOCM_RTS;\n\n\treturn modem_signals;\n}\n\nstatic int whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->mcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->mcr |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tinfo->mcr &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->mcr &= ~UART_MCR_DTR;\n\n\tfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\n\tfirm_set_rts(port, info->mcr & UART_MCR_RTS);\n\treturn 0;\n}\n\n\nstatic int whiteheat_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct serial_struct serstruct;\n\tvoid __user *user_arg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tmemset(&serstruct, 0, sizeof(serstruct));\n\t\tserstruct.type = PORT_16654;\n\t\tserstruct.line = port->minor;\n\t\tserstruct.port = port->port_number;\n\t\tserstruct.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\n\t\tserstruct.xmit_fifo_size = kfifo_size(&port->write_fifo);\n\t\tserstruct.custom_divisor = 0;\n\t\tserstruct.baud_base = 460800;\n\t\tserstruct.close_delay = CLOSING_DELAY;\n\t\tserstruct.closing_wait = CLOSING_DELAY;\n\n\t\tif (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\n\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\tstruct usb_serial_port *port, struct ktermios *old_termios)\n{\n\tfirm_setup_port(tty);\n}\n\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tfirm_set_break(port, break_state);\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat callback routines\n *****************************************************************************/\nstatic void command_port_write_callback(struct urb *urb)\n{\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"nonzero urb status: %d\\n\", status);\n\t\treturn;\n\t}\n}\n\n\nstatic void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\t/* These are unsolicited reports from the firmware, hence no\n\t\t   waiting command to wakeup */\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t/* Continue trying to always read */\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat firmware interface\n *****************************************************************************/\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_private *info;\n\tstruct device *dev = &port->dev;\n\t__u8 *transfer_buffer;\n\tint retval = 0;\n\tint t;\n\n\tdev_dbg(dev, \"%s - command %d\\n\", __func__, command);\n\n\tcommand_port = port->serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->command_finished = false;\n\n\ttransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\n\ttransfer_buffer[0] = command;\n\tmemcpy(&transfer_buffer[1], data, datasize);\n\tcommand_port->write_urb->transfer_buffer_length = datasize + 1;\n\tretval = usb_submit_urb(command_port->write_urb, GFP_NOIO);\n\tif (retval) {\n\t\tdev_dbg(dev, \"%s - submit urb failed\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\t/* wait for the command to complete */\n\tt = wait_event_timeout(command_info->wait_command,\n\t\t(bool)command_info->command_finished, COMMAND_TIMEOUT);\n\tif (!t)\n\t\tusb_kill_urb(command_port->write_urb);\n\n\tif (command_info->command_finished == false) {\n\t\tdev_dbg(dev, \"%s - command timed out.\\n\", __func__);\n\t\tretval = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tif (command_info->command_finished == WHITEHEAT_CMD_FAILURE) {\n\t\tdev_dbg(dev, \"%s - command failed.\\n\", __func__);\n\t\tretval = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (command_info->command_finished == WHITEHEAT_CMD_COMPLETE) {\n\t\tdev_dbg(dev, \"%s - command completed.\\n\", __func__);\n\t\tswitch (command) {\n\t\tcase WHITEHEAT_GET_DTR_RTS:\n\t\t\tinfo = usb_get_serial_port_data(port);\n\t\t\tmemcpy(&info->mcr, command_info->result_buffer,\n\t\t\t\t\tsizeof(struct whiteheat_dr_info));\n\t\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\n\n\nstatic int firm_open(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple open_command;\n\n\topen_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_OPEN,\n\t\t(__u8 *)&open_command, sizeof(open_command));\n}\n\n\nstatic int firm_close(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_CLOSE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n\n\nstatic void firm_setup_port(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tstruct whiteheat_port_settings port_settings;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n\tport_settings.port = port->port_number + 1;\n\n\t/* get the byte size */\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\tport_settings.bits = 5;   break;\n\tcase CS6:\tport_settings.bits = 6;   break;\n\tcase CS7:\tport_settings.bits = 7;   break;\n\tdefault:\n\tcase CS8:\tport_settings.bits = 8;   break;\n\t}\n\tdev_dbg(dev, \"%s - data bits = %d\\n\", __func__, port_settings.bits);\n\n\t/* determine the parity */\n\tif (cflag & PARENB)\n\t\tif (cflag & CMSPAR)\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_MARK;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_SPACE;\n\t\telse\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_ODD;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_EVEN;\n\telse\n\t\tport_settings.parity = WHITEHEAT_PAR_NONE;\n\tdev_dbg(dev, \"%s - parity = %c\\n\", __func__, port_settings.parity);\n\n\t/* figure out the stop bits requested */\n\tif (cflag & CSTOPB)\n\t\tport_settings.stop = 2;\n\telse\n\t\tport_settings.stop = 1;\n\tdev_dbg(dev, \"%s - stop bits = %d\\n\", __func__, port_settings.stop);\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS)\n\t\tport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\n\t\t\t\t\t\tWHITEHEAT_HFLOW_RTS);\n\telse\n\t\tport_settings.hflow = WHITEHEAT_HFLOW_NONE;\n\tdev_dbg(dev, \"%s - hardware flow control = %s %s %s %s\\n\", __func__,\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? \"CTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? \"RTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? \"DSR\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? \"DTR\" : \"\");\n\n\t/* determine software flow control */\n\tif (I_IXOFF(tty))\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\n\telse\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_NONE;\n\tdev_dbg(dev, \"%s - software flow control = %c\\n\", __func__, port_settings.sflow);\n\n\tport_settings.xon = START_CHAR(tty);\n\tport_settings.xoff = STOP_CHAR(tty);\n\tdev_dbg(dev, \"%s - XON = %2x, XOFF = %2x\\n\", __func__, port_settings.xon, port_settings.xoff);\n\n\t/* get the baud rate wanted */\n\tport_settings.baud = tty_get_baud_rate(tty);\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, port_settings.baud);\n\n\t/* fixme: should set validated settings */\n\ttty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\n\t/* handle any settings that aren't specified in the tty structure */\n\tport_settings.lloop = 0;\n\n\t/* now send the message to the device */\n\tfirm_send_command(port, WHITEHEAT_SETUP_PORT,\n\t\t\t(__u8 *)&port_settings, sizeof(port_settings));\n}\n\n\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}\n\n\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb dtr_command;\n\n\tdtr_command.port = port->port_number + 1;\n\tdtr_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_DTR,\n\t\t\t(__u8 *)&dtr_command, sizeof(dtr_command));\n}\n\n\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb break_command;\n\n\tbreak_command.port = port->port_number + 1;\n\tbreak_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_BREAK,\n\t\t\t(__u8 *)&break_command, sizeof(break_command));\n}\n\n\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx)\n{\n\tstruct whiteheat_purge purge_command;\n\n\tpurge_command.port = port->port_number + 1;\n\tpurge_command.what = rxtx;\n\treturn firm_send_command(port, WHITEHEAT_PURGE,\n\t\t\t(__u8 *)&purge_command, sizeof(purge_command));\n}\n\n\nstatic int firm_get_dtr_rts(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple get_dr_command;\n\n\tget_dr_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_GET_DTR_RTS,\n\t\t\t(__u8 *)&get_dr_command, sizeof(get_dr_command));\n}\n\n\nstatic int firm_report_tx_done(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat utility functions\n *****************************************************************************/\nstatic int start_command_port(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tint retval = 0;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tif (!command_info->port_running) {\n\t\t/* Work around HCD bugs */\n\t\tusb_clear_halt(serial->dev, command_port->read_urb->pipe);\n\n\t\tretval = usb_submit_urb(command_port->read_urb, GFP_KERNEL);\n\t\tif (retval) {\n\t\t\tdev_err(&serial->dev->dev,\n\t\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tcommand_info->port_running++;\n\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\n\n\nstatic void stop_command_port(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->port_running--;\n\tif (!command_info->port_running)\n\t\tusb_kill_urb(command_port->read_urb);\n\tmutex_unlock(&command_info->mutex);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"whiteheat.fw\");\nMODULE_FIRMWARE(\"whiteheat_loader.fw\");\n"], "fixing_code": ["/*\n * USB ConnectTech WhiteHEAT driver\n *\n *\tCopyright (C) 2002\n *\t    Connect Tech Inc.\n *\n *\tCopyright (C) 1999 - 2001\n *\t    Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation; either version 2 of the License, or\n *\t(at your option) any later version.\n *\n * See Documentation/usb/usb-serial.txt for more information on using this\n * driver\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <asm/termbits.h>\n#include <linux/usb.h>\n#include <linux/serial_reg.h>\n#include <linux/serial.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/ezusb.h>\n#include \"whiteheat.h\"\t\t\t/* WhiteHEAT specific commands */\n\n#ifndef CMSPAR\n#define CMSPAR 0\n#endif\n\n/*\n * Version Information\n */\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>, Stuart MacDonald <stuartm@connecttech.com>\"\n#define DRIVER_DESC \"USB ConnectTech WhiteHEAT driver\"\n\n#define CONNECT_TECH_VENDOR_ID\t\t0x0710\n#define CONNECT_TECH_FAKE_WHITE_HEAT_ID\t0x0001\n#define CONNECT_TECH_WHITE_HEAT_ID\t0x8001\n\n/*\n   ID tables for whiteheat are unusual, because we want to different\n   things for different versions of the device.  Eventually, this\n   will be doable from a single table.  But, for now, we define two\n   separate ID tables, and then a third table that combines them\n   just for the purpose of exporting the autoloading information.\n*/\nstatic const struct usb_device_id id_table_std[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id id_table_prerenumeration[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n\n/* function prototypes for the Connect Tech WhiteHEAT prerenumeration device */\nstatic int  whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  whiteheat_firmware_attach(struct usb_serial *serial);\n\n/* function prototypes for the Connect Tech WhiteHEAT serial converter */\nstatic int  whiteheat_attach(struct usb_serial *serial);\nstatic void whiteheat_release(struct usb_serial *serial);\nstatic int  whiteheat_port_probe(struct usb_serial_port *port);\nstatic int  whiteheat_port_remove(struct usb_serial_port *port);\nstatic int  whiteheat_open(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port);\nstatic void whiteheat_close(struct usb_serial_port *port);\nstatic int  whiteheat_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg);\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port, struct ktermios *old);\nstatic int  whiteheat_tiocmget(struct tty_struct *tty);\nstatic int  whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear);\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state);\n\nstatic struct usb_serial_driver whiteheat_fake_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheatnofirm\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT - (prerenumeration)\",\n\t.id_table =\t\tid_table_prerenumeration,\n\t.num_ports =\t\t1,\n\t.probe =\t\twhiteheat_firmware_download,\n\t.attach =\t\twhiteheat_firmware_attach,\n};\n\nstatic struct usb_serial_driver whiteheat_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheat\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT\",\n\t.id_table =\t\tid_table_std,\n\t.num_ports =\t\t4,\n\t.attach =\t\twhiteheat_attach,\n\t.release =\t\twhiteheat_release,\n\t.port_probe =\t\twhiteheat_port_probe,\n\t.port_remove =\t\twhiteheat_port_remove,\n\t.open =\t\t\twhiteheat_open,\n\t.close =\t\twhiteheat_close,\n\t.ioctl =\t\twhiteheat_ioctl,\n\t.set_termios =\t\twhiteheat_set_termios,\n\t.break_ctl =\t\twhiteheat_break_ctl,\n\t.tiocmget =\t\twhiteheat_tiocmget,\n\t.tiocmset =\t\twhiteheat_tiocmset,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&whiteheat_fake_device, &whiteheat_device, NULL\n};\n\nstruct whiteheat_command_private {\n\tstruct mutex\t\tmutex;\n\t__u8\t\t\tport_running;\n\t__u8\t\t\tcommand_finished;\n\twait_queue_head_t\twait_command; /* for handling sleeping whilst\n\t\t\t\t\t\t waiting for a command to\n\t\t\t\t\t\t finish */\n\t__u8\t\t\tresult_buffer[64];\n};\n\nstruct whiteheat_private {\n\t__u8\t\t\tmcr;\t\t/* FIXME: no locking on mcr */\n};\n\n\n/* local function prototypes */\nstatic int start_command_port(struct usb_serial *serial);\nstatic void stop_command_port(struct usb_serial *serial);\nstatic void command_port_write_callback(struct urb *urb);\nstatic void command_port_read_callback(struct urb *urb);\n\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize);\nstatic int firm_open(struct usb_serial_port *port);\nstatic int firm_close(struct usb_serial_port *port);\nstatic void firm_setup_port(struct tty_struct *tty);\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx);\nstatic int firm_get_dtr_rts(struct usb_serial_port *port);\nstatic int firm_report_tx_done(struct usb_serial_port *port);\n\n\n#define COMMAND_PORT\t\t4\n#define COMMAND_TIMEOUT\t\t(2*HZ)\t/* 2 second timeout for a command */\n#define\tCOMMAND_TIMEOUT_MS\t2000\n#define CLOSING_DELAY\t\t(30 * HZ)\n\n\n/*****************************************************************************\n * Connect Tech's White Heat prerenumeration driver functions\n *****************************************************************************/\n\n/* steps to download the firmware to the WhiteHEAT device:\n - hold the reset (by writing to the reset bit of the CPUCS register)\n - download the VEND_AX.HEX file to the chip using VENDOR_REQUEST-ANCHOR_LOAD\n - release the reset (by writing to the CPUCS register)\n - download the WH.HEX file for all addresses greater than 0x1b3f using\n   VENDOR_REQUEST-ANCHOR_EXTERNAL_RAM_LOAD\n - hold the reset\n - download the WH.HEX file for all addresses less than 0x1b40 using\n   VENDOR_REQUEST_ANCHOR_LOAD\n - release the reset\n - device renumerated itself and comes up as new device id with all\n   firmware download completed.\n*/\nstatic int whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint response;\n\n\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat_loader.fw\");\n\tif (response >= 0) {\n\t\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat.fw\");\n\t\tif (response >= 0)\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n\nstatic int whiteheat_firmware_attach(struct usb_serial *serial)\n{\n\t/* We want this device to fail to have a driver assigned to it */\n\treturn 1;\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat serial driver functions\n *****************************************************************************/\nstatic int whiteheat_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\t/*\n\t * When the module is reloaded the firmware is still there and\n\t * the endpoints are still in the usb core unchanged. This is the\n\t * unlinking bug in disguise. Same for the call below.\n\t */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\t/* See the comment on the usb_clear_halt() above */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\n\treturn 0;\n\nno_firmware:\n\t/* Firmware likely not running */\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\n\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\n\nstatic void whiteheat_release(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\n\t/* free up our private data for our command port */\n\tcommand_port = serial->port[COMMAND_PORT];\n\tkfree(usb_get_serial_port_data(command_port));\n}\n\nstatic int whiteheat_port_probe(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_port_data(port, info);\n\n\treturn 0;\n}\n\nstatic int whiteheat_port_remove(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = usb_get_serial_port_data(port);\n\tkfree(info);\n\n\treturn 0;\n}\n\nstatic int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\n\t/* send an open port command */\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\n\t/* Work around HCD bugs */\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}\n\n\nstatic void whiteheat_close(struct usb_serial_port *port)\n{\n\tfirm_report_tx_done(port);\n\tfirm_close(port);\n\n\tusb_serial_generic_close(port);\n\n\tstop_command_port(port->serial);\n}\n\nstatic int whiteheat_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\tunsigned int modem_signals = 0;\n\n\tfirm_get_dtr_rts(port);\n\tif (info->mcr & UART_MCR_DTR)\n\t\tmodem_signals |= TIOCM_DTR;\n\tif (info->mcr & UART_MCR_RTS)\n\t\tmodem_signals |= TIOCM_RTS;\n\n\treturn modem_signals;\n}\n\nstatic int whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->mcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->mcr |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tinfo->mcr &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->mcr &= ~UART_MCR_DTR;\n\n\tfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\n\tfirm_set_rts(port, info->mcr & UART_MCR_RTS);\n\treturn 0;\n}\n\n\nstatic int whiteheat_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct serial_struct serstruct;\n\tvoid __user *user_arg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tmemset(&serstruct, 0, sizeof(serstruct));\n\t\tserstruct.type = PORT_16654;\n\t\tserstruct.line = port->minor;\n\t\tserstruct.port = port->port_number;\n\t\tserstruct.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\n\t\tserstruct.xmit_fifo_size = kfifo_size(&port->write_fifo);\n\t\tserstruct.custom_divisor = 0;\n\t\tserstruct.baud_base = 460800;\n\t\tserstruct.close_delay = CLOSING_DELAY;\n\t\tserstruct.closing_wait = CLOSING_DELAY;\n\n\t\tif (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\n\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\tstruct usb_serial_port *port, struct ktermios *old_termios)\n{\n\tfirm_setup_port(tty);\n}\n\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tfirm_set_break(port, break_state);\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat callback routines\n *****************************************************************************/\nstatic void command_port_write_callback(struct urb *urb)\n{\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"nonzero urb status: %d\\n\", status);\n\t\treturn;\n\t}\n}\n\n\nstatic void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - empty response, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\t/* These are unsolicited reports from the firmware, hence no\n\t\t   waiting command to wakeup */\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) &&\n\t\t(urb->actual_length - 1 <= sizeof(command_info->result_buffer))) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t/* Continue trying to always read */\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat firmware interface\n *****************************************************************************/\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_private *info;\n\tstruct device *dev = &port->dev;\n\t__u8 *transfer_buffer;\n\tint retval = 0;\n\tint t;\n\n\tdev_dbg(dev, \"%s - command %d\\n\", __func__, command);\n\n\tcommand_port = port->serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->command_finished = false;\n\n\ttransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\n\ttransfer_buffer[0] = command;\n\tmemcpy(&transfer_buffer[1], data, datasize);\n\tcommand_port->write_urb->transfer_buffer_length = datasize + 1;\n\tretval = usb_submit_urb(command_port->write_urb, GFP_NOIO);\n\tif (retval) {\n\t\tdev_dbg(dev, \"%s - submit urb failed\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\t/* wait for the command to complete */\n\tt = wait_event_timeout(command_info->wait_command,\n\t\t(bool)command_info->command_finished, COMMAND_TIMEOUT);\n\tif (!t)\n\t\tusb_kill_urb(command_port->write_urb);\n\n\tif (command_info->command_finished == false) {\n\t\tdev_dbg(dev, \"%s - command timed out.\\n\", __func__);\n\t\tretval = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tif (command_info->command_finished == WHITEHEAT_CMD_FAILURE) {\n\t\tdev_dbg(dev, \"%s - command failed.\\n\", __func__);\n\t\tretval = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (command_info->command_finished == WHITEHEAT_CMD_COMPLETE) {\n\t\tdev_dbg(dev, \"%s - command completed.\\n\", __func__);\n\t\tswitch (command) {\n\t\tcase WHITEHEAT_GET_DTR_RTS:\n\t\t\tinfo = usb_get_serial_port_data(port);\n\t\t\tmemcpy(&info->mcr, command_info->result_buffer,\n\t\t\t\t\tsizeof(struct whiteheat_dr_info));\n\t\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\n\n\nstatic int firm_open(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple open_command;\n\n\topen_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_OPEN,\n\t\t(__u8 *)&open_command, sizeof(open_command));\n}\n\n\nstatic int firm_close(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_CLOSE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n\n\nstatic void firm_setup_port(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tstruct whiteheat_port_settings port_settings;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n\tport_settings.port = port->port_number + 1;\n\n\t/* get the byte size */\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\tport_settings.bits = 5;   break;\n\tcase CS6:\tport_settings.bits = 6;   break;\n\tcase CS7:\tport_settings.bits = 7;   break;\n\tdefault:\n\tcase CS8:\tport_settings.bits = 8;   break;\n\t}\n\tdev_dbg(dev, \"%s - data bits = %d\\n\", __func__, port_settings.bits);\n\n\t/* determine the parity */\n\tif (cflag & PARENB)\n\t\tif (cflag & CMSPAR)\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_MARK;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_SPACE;\n\t\telse\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_ODD;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_EVEN;\n\telse\n\t\tport_settings.parity = WHITEHEAT_PAR_NONE;\n\tdev_dbg(dev, \"%s - parity = %c\\n\", __func__, port_settings.parity);\n\n\t/* figure out the stop bits requested */\n\tif (cflag & CSTOPB)\n\t\tport_settings.stop = 2;\n\telse\n\t\tport_settings.stop = 1;\n\tdev_dbg(dev, \"%s - stop bits = %d\\n\", __func__, port_settings.stop);\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS)\n\t\tport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\n\t\t\t\t\t\tWHITEHEAT_HFLOW_RTS);\n\telse\n\t\tport_settings.hflow = WHITEHEAT_HFLOW_NONE;\n\tdev_dbg(dev, \"%s - hardware flow control = %s %s %s %s\\n\", __func__,\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? \"CTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? \"RTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? \"DSR\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? \"DTR\" : \"\");\n\n\t/* determine software flow control */\n\tif (I_IXOFF(tty))\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\n\telse\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_NONE;\n\tdev_dbg(dev, \"%s - software flow control = %c\\n\", __func__, port_settings.sflow);\n\n\tport_settings.xon = START_CHAR(tty);\n\tport_settings.xoff = STOP_CHAR(tty);\n\tdev_dbg(dev, \"%s - XON = %2x, XOFF = %2x\\n\", __func__, port_settings.xon, port_settings.xoff);\n\n\t/* get the baud rate wanted */\n\tport_settings.baud = tty_get_baud_rate(tty);\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, port_settings.baud);\n\n\t/* fixme: should set validated settings */\n\ttty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\n\t/* handle any settings that aren't specified in the tty structure */\n\tport_settings.lloop = 0;\n\n\t/* now send the message to the device */\n\tfirm_send_command(port, WHITEHEAT_SETUP_PORT,\n\t\t\t(__u8 *)&port_settings, sizeof(port_settings));\n}\n\n\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}\n\n\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb dtr_command;\n\n\tdtr_command.port = port->port_number + 1;\n\tdtr_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_DTR,\n\t\t\t(__u8 *)&dtr_command, sizeof(dtr_command));\n}\n\n\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb break_command;\n\n\tbreak_command.port = port->port_number + 1;\n\tbreak_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_BREAK,\n\t\t\t(__u8 *)&break_command, sizeof(break_command));\n}\n\n\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx)\n{\n\tstruct whiteheat_purge purge_command;\n\n\tpurge_command.port = port->port_number + 1;\n\tpurge_command.what = rxtx;\n\treturn firm_send_command(port, WHITEHEAT_PURGE,\n\t\t\t(__u8 *)&purge_command, sizeof(purge_command));\n}\n\n\nstatic int firm_get_dtr_rts(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple get_dr_command;\n\n\tget_dr_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_GET_DTR_RTS,\n\t\t\t(__u8 *)&get_dr_command, sizeof(get_dr_command));\n}\n\n\nstatic int firm_report_tx_done(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n\n\n/*****************************************************************************\n * Connect Tech's White Heat utility functions\n *****************************************************************************/\nstatic int start_command_port(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tint retval = 0;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tif (!command_info->port_running) {\n\t\t/* Work around HCD bugs */\n\t\tusb_clear_halt(serial->dev, command_port->read_urb->pipe);\n\n\t\tretval = usb_submit_urb(command_port->read_urb, GFP_KERNEL);\n\t\tif (retval) {\n\t\t\tdev_err(&serial->dev->dev,\n\t\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tcommand_info->port_running++;\n\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\n\n\nstatic void stop_command_port(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->port_running--;\n\tif (!command_info->port_running)\n\t\tusb_kill_urb(command_port->read_urb);\n\tmutex_unlock(&command_info->mutex);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"whiteheat.fw\");\nMODULE_FIRMWARE(\"whiteheat_loader.fw\");\n"], "filenames": ["drivers/usb/serial/whiteheat.c"], "buggy_code_start_loc": [516], "buggy_code_end_loc": [538], "fixing_code_start_loc": [517], "fixing_code_end_loc": [543], "type": "CWE-119", "message": "Multiple buffer overflows in the command_port_read_callback function in drivers/usb/serial/whiteheat.c in the Whiteheat USB Serial Driver in the Linux kernel before 3.16.2 allow physically proximate attackers to execute arbitrary code or cause a denial of service (memory corruption and system crash) via a crafted device that provides a large amount of (1) EHCI or (2) XHCI data associated with a bulk response.", "other": {"cve": {"id": "CVE-2014-3185", "sourceIdentifier": "cve-coordination@google.com", "published": "2014-09-28T10:55:10.283", "lastModified": "2015-05-12T02:00:45.520", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple buffer overflows in the command_port_read_callback function in drivers/usb/serial/whiteheat.c in the Whiteheat USB Serial Driver in the Linux kernel before 3.16.2 allow physically proximate attackers to execute arbitrary code or cause a denial of service (memory corruption and system crash) via a crafted device that provides a large amount of (1) EHCI or (2) XHCI data associated with a bulk response."}, {"lang": "es", "value": "M\u00faltiples desbordamientos de buffer en la funci\u00f3n command_port_read_callback en drivers/usb/serial/whiteheat.c en Whiteheat USB Serial Driver en el kernel de Linux anterior a 3.16.2 permiten a atacantes f\u00edsicamente pr\u00f3ximos ejecutar c\u00f3digo arbitrario o causar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria y ca\u00edda del sistema) a trav\u00e9s de un dispositivo manipulado que proporciona una cantidad grande de datos (1) EHCI o (2) XHCI asociados con una respuesta en masa."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.16.1", "matchCriteriaId": "8452407A-5074-4385-B9A1-9E49042CCAEB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.16.0:*:*:*:*:*:*:*", "matchCriteriaId": "3CFFCDFC-AE4F-47EE-B1DA-05A6865D1745"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=6817ae225cd650fb1c3295d769298c38b1eba818", "source": "cve-coordination@google.com", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "cve-coordination@google.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "cve-coordination@google.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00000.html", "source": "cve-coordination@google.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "cve-coordination@google.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1318.html", "source": "cve-coordination@google.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0284.html", "source": "cve-coordination@google.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.16.2", "source": "cve-coordination@google.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/09/11/21", "source": "cve-coordination@google.com"}, {"url": "http://www.securityfocus.com/bid/69781", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2374-1", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2375-1", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2376-1", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2377-1", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2378-1", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2379-1", "source": "cve-coordination@google.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1141400", "source": "cve-coordination@google.com", "tags": ["Patch"]}, {"url": "https://code.google.com/p/google-security-research/issues/detail?id=98", "source": "cve-coordination@google.com", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818", "source": "cve-coordination@google.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818"}}