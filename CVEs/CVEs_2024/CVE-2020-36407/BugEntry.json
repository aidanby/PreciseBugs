{"buggy_code": ["// Copyright 2019 Joe Drago. All rights reserved.\n// SPDX-License-Identifier: BSD-2-Clause\n\n#ifndef AVIF_INTERNAL_H\n#define AVIF_INTERNAL_H\n\n#include \"avif/avif.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Yes, clamp macros are nasty. Do not use them.\n#define AVIF_CLAMP(x, low, high) (((x) < (low))) ? (low) : (((high) < (x)) ? (high) : (x))\n#define AVIF_MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n// Used by stream related things.\n#define CHECK(A)               \\\n    do {                       \\\n        if (!(A))              \\\n            return AVIF_FALSE; \\\n    } while (0)\n\n// ---------------------------------------------------------------------------\n// URNs and Content-Types\n\n#define URN_ALPHA0 \"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\"\n#define URN_ALPHA1 \"urn:mpeg:hevc:2015:auxid:1\"\n\n#define CONTENT_TYPE_XMP \"application/rdf+xml\"\n\n// ---------------------------------------------------------------------------\n// Utils\n\nfloat avifRoundf(float v);\n\nuint16_t avifHTONS(uint16_t s);\nuint16_t avifNTOHS(uint16_t s);\nuint32_t avifHTONL(uint32_t l);\nuint32_t avifNTOHL(uint32_t l);\nuint64_t avifHTON64(uint64_t l);\nuint64_t avifNTOH64(uint64_t l);\n\nvoid avifCalcYUVCoefficients(const avifImage * image, float * outR, float * outG, float * outB);\n\n#define AVIF_ARRAY_DECLARE(TYPENAME, ITEMSTYPE, ITEMSNAME) \\\n    typedef struct TYPENAME                                \\\n    {                                                      \\\n        ITEMSTYPE * ITEMSNAME;                             \\\n        uint32_t elementSize;                              \\\n        uint32_t count;                                    \\\n        uint32_t capacity;                                 \\\n    } TYPENAME\nvoid avifArrayCreate(void * arrayStruct, uint32_t elementSize, uint32_t initialCapacity);\nuint32_t avifArrayPushIndex(void * arrayStruct);\nvoid * avifArrayPushPtr(void * arrayStruct);\nvoid avifArrayPush(void * arrayStruct, void * element);\nvoid avifArrayDestroy(void * arrayStruct);\n\nAVIF_ARRAY_DECLARE(avifRODataArray, avifROData, raw);\nAVIF_ARRAY_DECLARE(avifRWDataArray, avifRWData, raw);\n\ntypedef struct avifAlphaParams\n{\n    uint32_t width;\n    uint32_t height;\n\n    uint32_t srcDepth;\n    avifRange srcRange;\n    uint8_t * srcPlane;\n    uint32_t srcRowBytes;\n    uint32_t srcOffsetBytes;\n    uint32_t srcPixelBytes;\n\n    uint32_t dstDepth;\n    avifRange dstRange;\n    uint8_t * dstPlane;\n    uint32_t dstRowBytes;\n    uint32_t dstOffsetBytes;\n    uint32_t dstPixelBytes;\n\n} avifAlphaParams;\n\navifBool avifFillAlpha(const avifAlphaParams * const params);\navifBool avifReformatAlpha(const avifAlphaParams * const params);\n\n// ---------------------------------------------------------------------------\n// avifCodecDecodeInput\n\ntypedef struct avifDecodeSample\n{\n    avifROData data;\n    avifBool sync; // is sync sample (keyframe)\n} avifDecodeSample;\nAVIF_ARRAY_DECLARE(avifDecodeSampleArray, avifDecodeSample, sample);\n\ntypedef struct avifCodecDecodeInput\n{\n    avifDecodeSampleArray samples;\n    avifBool alpha; // if true, this is decoding an alpha plane\n} avifCodecDecodeInput;\n\navifCodecDecodeInput * avifCodecDecodeInputCreate(void);\nvoid avifCodecDecodeInputDestroy(avifCodecDecodeInput * decodeInput);\n\n// ---------------------------------------------------------------------------\n// avifCodecEncodeOutput\n\ntypedef struct avifEncodeSample\n{\n    avifRWData data;\n    avifBool sync; // is sync sample (keyframe)\n} avifEncodeSample;\nAVIF_ARRAY_DECLARE(avifEncodeSampleArray, avifEncodeSample, sample);\n\ntypedef struct avifCodecEncodeOutput\n{\n    avifEncodeSampleArray samples;\n} avifCodecEncodeOutput;\n\navifCodecEncodeOutput * avifCodecEncodeOutputCreate(void);\nvoid avifCodecEncodeOutputAddSample(avifCodecEncodeOutput * encodeOutput, const uint8_t * data, size_t len, avifBool sync);\nvoid avifCodecEncodeOutputDestroy(avifCodecEncodeOutput * encodeOutput);\n\n// ---------------------------------------------------------------------------\n// avifCodec (abstraction layer to use different AV1 implementations)\n\nstruct avifCodec;\nstruct avifCodecInternal;\n\ntypedef avifBool (*avifCodecOpenFunc)(struct avifCodec * codec, uint32_t firstSampleIndex);\ntypedef avifBool (*avifCodecGetNextImageFunc)(struct avifCodec * codec, avifImage * image);\n// EncodeImage and EncodeFinish are not required to always emit a sample, but when all images are\n// encoded and EncodeFinish is called, the number of samples emitted must match the number of submitted frames.\ntypedef avifBool (*avifCodecEncodeImageFunc)(struct avifCodec * codec,\n                                             avifEncoder * encoder,\n                                             const avifImage * image,\n                                             avifBool alpha,\n                                             uint32_t addImageFlags,\n                                             avifCodecEncodeOutput * output);\ntypedef avifBool (*avifCodecEncodeFinishFunc)(struct avifCodec * codec, avifCodecEncodeOutput * output);\ntypedef void (*avifCodecDestroyInternalFunc)(struct avifCodec * codec);\n\ntypedef struct avifCodec\n{\n    avifCodecDecodeInput * decodeInput;\n    avifCodecConfigurationBox configBox; // Pre-populated by avifEncoderWrite(), available and overridable by codec impls\n    struct avifCodecInternal * internal; // up to each codec to use how it wants\n\n    avifCodecOpenFunc open;\n    avifCodecGetNextImageFunc getNextImage;\n    avifCodecEncodeImageFunc encodeImage;\n    avifCodecEncodeFinishFunc encodeFinish;\n    avifCodecDestroyInternalFunc destroyInternal;\n} avifCodec;\n\navifCodec * avifCodecCreate(avifCodecChoice choice, uint32_t requiredFlags);\nvoid avifCodecDestroy(avifCodec * codec);\n\navifCodec * avifCodecCreateAOM(void);     // requires AVIF_CODEC_AOM (codec_aom.c)\nconst char * avifCodecVersionAOM(void);   // requires AVIF_CODEC_AOM (codec_aom.c)\navifCodec * avifCodecCreateDav1d(void);   // requires AVIF_CODEC_DAV1D (codec_dav1d.c)\nconst char * avifCodecVersionDav1d(void); // requires AVIF_CODEC_DAV1D (codec_dav1d.c)\navifCodec * avifCodecCreateGav1(void);    // requires AVIF_CODEC_LIBGAV1 (codec_libgav1.c)\nconst char * avifCodecVersionGav1(void);  // requires AVIF_CODEC_LIBGAV1 (codec_libgav1.c)\navifCodec * avifCodecCreateRav1e(void);   // requires AVIF_CODEC_RAV1E (codec_rav1e.c)\nconst char * avifCodecVersionRav1e(void); // requires AVIF_CODEC_RAV1E (codec_rav1e.c)\n\n// ---------------------------------------------------------------------------\n// avifStream\n\ntypedef size_t avifBoxMarker;\n\ntypedef struct avifBoxHeader\n{\n    size_t size;\n    uint8_t type[4];\n} avifBoxHeader;\n\ntypedef struct avifROStream\n{\n    avifROData * raw;\n    size_t offset;\n} avifROStream;\n\nconst uint8_t * avifROStreamCurrent(avifROStream * stream);\nvoid avifROStreamStart(avifROStream * stream, avifROData * raw);\nsize_t avifROStreamOffset(const avifROStream * stream);\nvoid avifROStreamSetOffset(avifROStream * stream, size_t offset);\n\navifBool avifROStreamHasBytesLeft(const avifROStream * stream, size_t byteCount);\nsize_t avifROStreamRemainingBytes(const avifROStream * stream);\navifBool avifROStreamSkip(avifROStream * stream, size_t byteCount);\navifBool avifROStreamRead(avifROStream * stream, uint8_t * data, size_t size);\navifBool avifROStreamReadU16(avifROStream * stream, uint16_t * v);\navifBool avifROStreamReadU32(avifROStream * stream, uint32_t * v);\navifBool avifROStreamReadUX8(avifROStream * stream, uint64_t * v, uint64_t factor); // Reads a factor*8 sized uint, saves in v\navifBool avifROStreamReadU64(avifROStream * stream, uint64_t * v);\navifBool avifROStreamReadString(avifROStream * stream, char * output, size_t outputSize);\navifBool avifROStreamReadBoxHeader(avifROStream * stream, avifBoxHeader * header);\navifBool avifROStreamReadVersionAndFlags(avifROStream * stream, uint8_t * version, uint32_t * flags); // version and flags ptrs are both optional\navifBool avifROStreamReadAndEnforceVersion(avifROStream * stream, uint8_t enforcedVersion); // currently discards flags\n\ntypedef struct avifRWStream\n{\n    avifRWData * raw;\n    size_t offset;\n} avifRWStream;\n\nuint8_t * avifRWStreamCurrent(avifRWStream * stream);\nvoid avifRWStreamStart(avifRWStream * stream, avifRWData * raw);\nsize_t avifRWStreamOffset(const avifRWStream * stream);\nvoid avifRWStreamSetOffset(avifRWStream * stream, size_t offset);\n\nvoid avifRWStreamFinishWrite(avifRWStream * stream);\nvoid avifRWStreamWrite(avifRWStream * stream, const void * data, size_t size);\nvoid avifRWStreamWriteChars(avifRWStream * stream, const char * chars, size_t size);\navifBoxMarker avifRWStreamWriteBox(avifRWStream * stream, const char * type, size_t contentSize);\navifBoxMarker avifRWStreamWriteFullBox(avifRWStream * stream, const char * type, size_t contentSize, int version, uint32_t flags);\nvoid avifRWStreamFinishBox(avifRWStream * stream, avifBoxMarker marker);\nvoid avifRWStreamWriteU8(avifRWStream * stream, uint8_t v);\nvoid avifRWStreamWriteU16(avifRWStream * stream, uint16_t v);\nvoid avifRWStreamWriteU32(avifRWStream * stream, uint32_t v);\nvoid avifRWStreamWriteU64(avifRWStream * stream, uint64_t v);\nvoid avifRWStreamWriteZeros(avifRWStream * stream, size_t byteCount);\n\n// This is to make it clear that the box size is currently unknown, and will be determined later (with a call to avifRWStreamFinishBox)\n#define AVIF_BOX_SIZE_TBD 0\n\ntypedef struct avifSequenceHeader\n{\n    uint32_t maxWidth;\n    uint32_t maxHeight;\n    uint32_t bitDepth;\n    avifPixelFormat yuvFormat;\n    avifChromaSamplePosition chromaSamplePosition;\n    avifColorPrimaries colorPrimaries;\n    avifTransferCharacteristics transferCharacteristics;\n    avifMatrixCoefficients matrixCoefficients;\n    avifRange range;\n} avifSequenceHeader;\navifBool avifSequenceHeaderParse(avifSequenceHeader * header, const avifROData * sample);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif // ifndef AVIF_INTERNAL_H\n", "// Copyright 2019 Joe Drago. All rights reserved.\n// SPDX-License-Identifier: BSD-2-Clause\n\n#include \"avif/internal.h\"\n\n#include <string.h>\n\n#define AUXTYPE_SIZE 64\n#define CONTENTTYPE_SIZE 64\n\n// class VisualSampleEntry(codingname) extends SampleEntry(codingname) {\n//     unsigned int(16) pre_defined = 0;\n//     const unsigned int(16) reserved = 0;\n//     unsigned int(32)[3] pre_defined = 0;\n//     unsigned int(16) width;\n//     unsigned int(16) height;\n//     template unsigned int(32) horizresolution = 0x00480000; // 72 dpi\n//     template unsigned int(32) vertresolution = 0x00480000;  // 72 dpi\n//     const unsigned int(32) reserved = 0;\n//     template unsigned int(16) frame_count = 1;\n//     string[32] compressorname;\n//     template unsigned int(16) depth = 0x0018;\n//     int(16) pre_defined = -1;\n//     // other boxes from derived specifications\n//     CleanApertureBox clap;    // optional\n//     PixelAspectRatioBox pasp; // optional\n// }\nstatic const size_t VISUALSAMPLEENTRY_SIZE = 78;\n\nstatic const char xmpContentType[] = CONTENT_TYPE_XMP;\nstatic const size_t xmpContentTypeSize = sizeof(xmpContentType);\n\n// ---------------------------------------------------------------------------\n// Box data structures\n\n// ftyp\ntypedef struct avifFileType\n{\n    uint8_t majorBrand[4];\n    uint32_t minorVersion;\n    // If not null, points to a memory block of 4 * compatibleBrandsCount bytes.\n    const uint8_t * compatibleBrands;\n    int compatibleBrandsCount;\n} avifFileType;\n\n// ispe\ntypedef struct avifImageSpatialExtents\n{\n    uint32_t width;\n    uint32_t height;\n} avifImageSpatialExtents;\n\n// auxC\ntypedef struct avifAuxiliaryType\n{\n    char auxType[AUXTYPE_SIZE];\n} avifAuxiliaryType;\n\n// infe mime content_type\ntypedef struct avifContentType\n{\n    char contentType[CONTENTTYPE_SIZE];\n} avifContentType;\n\n// colr\ntypedef struct avifColourInformationBox\n{\n    avifBool hasICC;\n    const uint8_t * icc;\n    size_t iccSize;\n\n    avifBool hasNCLX;\n    avifColorPrimaries colorPrimaries;\n    avifTransferCharacteristics transferCharacteristics;\n    avifMatrixCoefficients matrixCoefficients;\n    avifRange range;\n} avifColourInformationBox;\n\n#define MAX_PIXI_PLANE_DEPTHS 4\ntypedef struct avifPixelInformationProperty\n{\n    uint8_t planeDepths[MAX_PIXI_PLANE_DEPTHS];\n    uint8_t planeCount;\n} avifPixelInformationProperty;\n\n// ---------------------------------------------------------------------------\n// Top-level structures\n\nstruct avifMeta;\n\n// Temporary storage for ipco/stsd contents until they can be associated and memcpy'd to an avifDecoderItem\ntypedef struct avifProperty\n{\n    uint8_t type[4];\n    union\n    {\n        avifImageSpatialExtents ispe;\n        avifAuxiliaryType auxC;\n        avifColourInformationBox colr;\n        avifCodecConfigurationBox av1C;\n        avifPixelAspectRatioBox pasp;\n        avifCleanApertureBox clap;\n        avifImageRotation irot;\n        avifImageMirror imir;\n        avifPixelInformationProperty pixi;\n    } u;\n} avifProperty;\nAVIF_ARRAY_DECLARE(avifPropertyArray, avifProperty, prop);\n\nstatic const avifProperty * avifPropertyArrayFind(const avifPropertyArray * properties, const char * type)\n{\n    for (uint32_t propertyIndex = 0; propertyIndex < properties->count; ++propertyIndex) {\n        avifProperty * prop = &properties->prop[propertyIndex];\n        if (!memcmp(prop->type, type, 4)) {\n            return prop;\n        }\n    }\n    return NULL;\n}\n\n// one \"item\" worth for decoding (all iref, iloc, iprp, etc refer to one of these)\ntypedef struct avifDecoderItem\n{\n    uint32_t id;\n    struct avifMeta * meta; // Unowned; A back-pointer for convenience\n    uint8_t type[4];\n    uint32_t offset;\n    uint32_t size;\n    uint32_t idatID; // If non-zero, offset is relative to this idat box (iloc construction_method==1)\n    avifContentType contentType;\n    avifPropertyArray properties;\n    uint32_t thumbnailForID; // if non-zero, this item is a thumbnail for Item #{thumbnailForID}\n    uint32_t auxForID;       // if non-zero, this item is an auxC plane for Item #{auxForID}\n    uint32_t descForID;      // if non-zero, this item is a content description for Item #{descForID}\n    uint32_t dimgForID;      // if non-zero, this item is a derived image for Item #{dimgForID}\n    avifBool hasUnsupportedEssentialProperty; // If true, this item cites a property flagged as 'essential' that libavif doesn't support (yet). Ignore the item, if so.\n} avifDecoderItem;\nAVIF_ARRAY_DECLARE(avifDecoderItemArray, avifDecoderItem, item);\n\n// idat storage\ntypedef struct avifDecoderItemData\n{\n    uint32_t id;\n    avifROData data;\n} avifDecoderItemData;\nAVIF_ARRAY_DECLARE(avifDecoderItemDataArray, avifDecoderItemData, idat);\n\n// grid storage\ntypedef struct avifImageGrid\n{\n    uint8_t rows;\n    uint8_t columns;\n    uint32_t outputWidth;\n    uint32_t outputHeight;\n} avifImageGrid;\n\n// ---------------------------------------------------------------------------\n// avifTrack\n\ntypedef struct avifSampleTableChunk\n{\n    uint64_t offset;\n} avifSampleTableChunk;\nAVIF_ARRAY_DECLARE(avifSampleTableChunkArray, avifSampleTableChunk, chunk);\n\ntypedef struct avifSampleTableSampleToChunk\n{\n    uint32_t firstChunk;\n    uint32_t samplesPerChunk;\n    uint32_t sampleDescriptionIndex;\n} avifSampleTableSampleToChunk;\nAVIF_ARRAY_DECLARE(avifSampleTableSampleToChunkArray, avifSampleTableSampleToChunk, sampleToChunk);\n\ntypedef struct avifSampleTableSampleSize\n{\n    uint32_t size;\n} avifSampleTableSampleSize;\nAVIF_ARRAY_DECLARE(avifSampleTableSampleSizeArray, avifSampleTableSampleSize, sampleSize);\n\ntypedef struct avifSampleTableTimeToSample\n{\n    uint32_t sampleCount;\n    uint32_t sampleDelta;\n} avifSampleTableTimeToSample;\nAVIF_ARRAY_DECLARE(avifSampleTableTimeToSampleArray, avifSampleTableTimeToSample, timeToSample);\n\ntypedef struct avifSyncSample\n{\n    uint32_t sampleNumber;\n} avifSyncSample;\nAVIF_ARRAY_DECLARE(avifSyncSampleArray, avifSyncSample, syncSample);\n\ntypedef struct avifSampleDescription\n{\n    uint8_t format[4];\n    avifPropertyArray properties;\n} avifSampleDescription;\nAVIF_ARRAY_DECLARE(avifSampleDescriptionArray, avifSampleDescription, description);\n\ntypedef struct avifSampleTable\n{\n    avifSampleTableChunkArray chunks;\n    avifSampleDescriptionArray sampleDescriptions;\n    avifSampleTableSampleToChunkArray sampleToChunks;\n    avifSampleTableSampleSizeArray sampleSizes;\n    avifSampleTableTimeToSampleArray timeToSamples;\n    avifSyncSampleArray syncSamples;\n    uint32_t allSamplesSize; // If this is non-zero, sampleSizes will be empty and all samples will be this size\n} avifSampleTable;\n\nstatic avifSampleTable * avifSampleTableCreate()\n{\n    avifSampleTable * sampleTable = (avifSampleTable *)avifAlloc(sizeof(avifSampleTable));\n    memset(sampleTable, 0, sizeof(avifSampleTable));\n    avifArrayCreate(&sampleTable->chunks, sizeof(avifSampleTableChunk), 16);\n    avifArrayCreate(&sampleTable->sampleDescriptions, sizeof(avifSampleDescription), 2);\n    avifArrayCreate(&sampleTable->sampleToChunks, sizeof(avifSampleTableSampleToChunk), 16);\n    avifArrayCreate(&sampleTable->sampleSizes, sizeof(avifSampleTableSampleSize), 16);\n    avifArrayCreate(&sampleTable->timeToSamples, sizeof(avifSampleTableTimeToSample), 16);\n    avifArrayCreate(&sampleTable->syncSamples, sizeof(avifSyncSample), 16);\n    return sampleTable;\n}\n\nstatic void avifSampleTableDestroy(avifSampleTable * sampleTable)\n{\n    avifArrayDestroy(&sampleTable->chunks);\n    for (uint32_t i = 0; i < sampleTable->sampleDescriptions.count; ++i) {\n        avifSampleDescription * description = &sampleTable->sampleDescriptions.description[i];\n        avifArrayDestroy(&description->properties);\n    }\n    avifArrayDestroy(&sampleTable->sampleDescriptions);\n    avifArrayDestroy(&sampleTable->sampleToChunks);\n    avifArrayDestroy(&sampleTable->sampleSizes);\n    avifArrayDestroy(&sampleTable->timeToSamples);\n    avifArrayDestroy(&sampleTable->syncSamples);\n    avifFree(sampleTable);\n}\n\nstatic uint32_t avifSampleTableGetImageDelta(const avifSampleTable * sampleTable, int imageIndex)\n{\n    int maxSampleIndex = 0;\n    for (uint32_t i = 0; i < sampleTable->timeToSamples.count; ++i) {\n        const avifSampleTableTimeToSample * timeToSample = &sampleTable->timeToSamples.timeToSample[i];\n        maxSampleIndex += timeToSample->sampleCount;\n        if ((imageIndex < maxSampleIndex) || (i == (sampleTable->timeToSamples.count - 1))) {\n            return timeToSample->sampleDelta;\n        }\n    }\n\n    // TODO: fail here?\n    return 1;\n}\n\nstatic avifBool avifSampleTableHasFormat(const avifSampleTable * sampleTable, const char * format)\n{\n    for (uint32_t i = 0; i < sampleTable->sampleDescriptions.count; ++i) {\n        if (!memcmp(sampleTable->sampleDescriptions.description[i].format, format, 4)) {\n            return AVIF_TRUE;\n        }\n    }\n    return AVIF_FALSE;\n}\n\nstatic uint32_t avifCodecConfigurationBoxGetDepth(const avifCodecConfigurationBox * av1C)\n{\n    if (av1C->twelveBit) {\n        return 12;\n    } else if (av1C->highBitdepth) {\n        return 10;\n    }\n    return 8;\n}\n\nstatic const avifPropertyArray * avifSampleTableGetProperties(const avifSampleTable * sampleTable)\n{\n    for (uint32_t i = 0; i < sampleTable->sampleDescriptions.count; ++i) {\n        const avifSampleDescription * description = &sampleTable->sampleDescriptions.description[i];\n        if (!memcmp(description->format, \"av01\", 4)) {\n            return &description->properties;\n        }\n    }\n    return NULL;\n}\n\n// one video track (\"trak\" contents)\ntypedef struct avifTrack\n{\n    uint32_t id;\n    uint32_t auxForID; // if non-zero, this item is an auxC plane for Track #{auxForID}\n    uint32_t mediaTimescale;\n    uint64_t mediaDuration;\n    uint32_t width;\n    uint32_t height;\n    avifSampleTable * sampleTable;\n    struct avifMeta * meta;\n} avifTrack;\nAVIF_ARRAY_DECLARE(avifTrackArray, avifTrack, track);\n\n// ---------------------------------------------------------------------------\n// avifCodecDecodeInput\n\navifCodecDecodeInput * avifCodecDecodeInputCreate(void)\n{\n    avifCodecDecodeInput * decodeInput = (avifCodecDecodeInput *)avifAlloc(sizeof(avifCodecDecodeInput));\n    memset(decodeInput, 0, sizeof(avifCodecDecodeInput));\n    avifArrayCreate(&decodeInput->samples, sizeof(avifDecodeSample), 1);\n    return decodeInput;\n}\n\nvoid avifCodecDecodeInputDestroy(avifCodecDecodeInput * decodeInput)\n{\n    avifArrayDestroy(&decodeInput->samples);\n    avifFree(decodeInput);\n}\n\nstatic avifBool avifCodecDecodeInputGetSamples(avifCodecDecodeInput * decodeInput, avifSampleTable * sampleTable, avifROData * rawInput)\n{\n    uint32_t sampleSizeIndex = 0;\n    for (uint32_t chunkIndex = 0; chunkIndex < sampleTable->chunks.count; ++chunkIndex) {\n        avifSampleTableChunk * chunk = &sampleTable->chunks.chunk[chunkIndex];\n\n        // First, figure out how many samples are in this chunk\n        uint32_t sampleCount = 0;\n        for (int sampleToChunkIndex = sampleTable->sampleToChunks.count - 1; sampleToChunkIndex >= 0; --sampleToChunkIndex) {\n            avifSampleTableSampleToChunk * sampleToChunk = &sampleTable->sampleToChunks.sampleToChunk[sampleToChunkIndex];\n            if (sampleToChunk->firstChunk <= (chunkIndex + 1)) {\n                sampleCount = sampleToChunk->samplesPerChunk;\n                break;\n            }\n        }\n        if (sampleCount == 0) {\n            // chunks with 0 samples are invalid\n            return AVIF_FALSE;\n        }\n\n        uint64_t sampleOffset = chunk->offset;\n        for (uint32_t sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n            uint32_t sampleSize = sampleTable->allSamplesSize;\n            if (sampleSize == 0) {\n                if (sampleSizeIndex >= sampleTable->sampleSizes.count) {\n                    // We've run out of samples to sum\n                    return AVIF_FALSE;\n                }\n                avifSampleTableSampleSize * sampleSizePtr = &sampleTable->sampleSizes.sampleSize[sampleSizeIndex];\n                sampleSize = sampleSizePtr->size;\n            }\n\n            avifDecodeSample * sample = (avifDecodeSample *)avifArrayPushPtr(&decodeInput->samples);\n            sample->data.data = rawInput->data + sampleOffset;\n            sample->data.size = sampleSize;\n            sample->sync = AVIF_FALSE; // to potentially be set to true following the outer loop\n\n            if ((sampleOffset + sampleSize) > (uint64_t)rawInput->size) {\n                return AVIF_FALSE;\n            }\n\n            sampleOffset += sampleSize;\n            ++sampleSizeIndex;\n        }\n    }\n\n    // Mark appropriate samples as sync\n    for (uint32_t syncSampleIndex = 0; syncSampleIndex < sampleTable->syncSamples.count; ++syncSampleIndex) {\n        uint32_t frameIndex = sampleTable->syncSamples.syncSample[syncSampleIndex].sampleNumber - 1; // sampleNumber is 1-based\n        if (frameIndex < decodeInput->samples.count) {\n            decodeInput->samples.sample[frameIndex].sync = AVIF_TRUE;\n        }\n    }\n\n    // Assume frame 0 is sync, just in case the stss box is absent in the BMFF. (Unnecessary?)\n    if (decodeInput->samples.count > 0) {\n        decodeInput->samples.sample[0].sync = AVIF_TRUE;\n    }\n    return AVIF_TRUE;\n}\n\n// ---------------------------------------------------------------------------\n// Helper macros\n\n#define BEGIN_STREAM(VARNAME, PTR, SIZE) \\\n    avifROStream VARNAME;                \\\n    avifROData VARNAME##_roData;         \\\n    VARNAME##_roData.data = PTR;         \\\n    VARNAME##_roData.size = SIZE;        \\\n    avifROStreamStart(&VARNAME, &VARNAME##_roData)\n\n// ---------------------------------------------------------------------------\n// avifDecoderData\n\ntypedef struct avifTile\n{\n    avifCodecDecodeInput * input;\n    struct avifCodec * codec;\n    avifImage * image;\n} avifTile;\nAVIF_ARRAY_DECLARE(avifTileArray, avifTile, tile);\n\n// This holds one \"meta\" box (from the BMFF and HEIF standards) worth of relevant-to-AVIF information.\n// * If a meta box is parsed from the root level of the BMFF, it can contain the information about\n//   \"items\" which might be color planes, alpha planes, or EXIF or XMP metadata.\n// * If a meta box is parsed from inside of a track (\"trak\") box, any metadata (EXIF/XMP) items inside\n//   of that box are implicitly associated with that track.\ntypedef struct avifMeta\n{\n    // Items (from HEIF) are the generic storage for any data that does not require timed processing\n    // (single image color planes, alpha planes, EXIF, XMP, etc). Each item has a unique integer ID >1,\n    // and is defined by a series of child boxes in a meta box:\n    //  * iloc - location:     byte offset to item data, item size in bytes\n    //  * iinf - information:  type of item (color planes, alpha plane, EXIF, XMP)\n    //  * ipco - properties:   dimensions, aspect ratio, image transformations, references to other items\n    //  * ipma - associations: Attaches an item in the properties list to a given item\n    //\n    // Items are lazily created in this array when any of the above boxes refer to one by a new (unseen) ID,\n    // and are then further modified/updated as new information for an item's ID is parsed.\n    avifDecoderItemArray items;\n\n    // Any ipco boxes explained above are populated into this array as a staging area, which are\n    // then duplicated into the appropriate items upon encountering an item property association\n    // (ipma) box.\n    avifPropertyArray properties;\n\n    // Filled with the contents of \"idat\" boxes, which are raw data that an item can directly refer to in its\n    // item location box (iloc) instead of just giving an offset into the overall file. If all items' iloc boxes\n    // simply point at an offset/length in the file itself, this array will likely be empty.\n    avifDecoderItemDataArray idats;\n\n    // Ever-incrementing ID for uniquely identifying which 'meta' box contains an idat (when\n    // multiple meta boxes exist as BMFF siblings). Each time avifParseMetaBox() is called on an\n    // avifMeta struct, this value is incremented. Any time an additional meta box is detected at\n    // the same \"level\" (root level, trak level, etc), this ID helps distinguish which meta box's\n    // \"idat\" is which, as items implicitly reference idat boxes that exist in the same meta\n    // box.\n    uint32_t idatID;\n\n    // Contents of a pitm box, which signal which of the items in this file is the main image. For\n    // AVIF, this should point at an av01 type item containing color planes, and all other items\n    // are ignored unless they refer to this item in some way (alpha plane, EXIF/XMP metadata).\n    uint32_t primaryItemID;\n} avifMeta;\n\nstatic avifMeta * avifMetaCreate()\n{\n    avifMeta * meta = (avifMeta *)avifAlloc(sizeof(avifMeta));\n    memset(meta, 0, sizeof(avifMeta));\n    avifArrayCreate(&meta->items, sizeof(avifDecoderItem), 8);\n    avifArrayCreate(&meta->properties, sizeof(avifProperty), 16);\n    avifArrayCreate(&meta->idats, sizeof(avifDecoderItemData), 1);\n    return meta;\n}\n\nstatic void avifMetaDestroy(avifMeta * meta)\n{\n    for (uint32_t i = 0; i < meta->items.count; ++i) {\n        avifDecoderItem * item = &meta->items.item[i];\n        avifArrayDestroy(&item->properties);\n    }\n    avifArrayDestroy(&meta->items);\n    avifArrayDestroy(&meta->properties);\n    avifArrayDestroy(&meta->idats);\n    avifFree(meta);\n}\n\nstatic avifDecoderItem * avifMetaFindItem(avifMeta * meta, uint32_t itemID)\n{\n    if (itemID == 0) {\n        return NULL;\n    }\n\n    for (uint32_t i = 0; i < meta->items.count; ++i) {\n        if (meta->items.item[i].id == itemID) {\n            return &meta->items.item[i];\n        }\n    }\n\n    avifDecoderItem * item = (avifDecoderItem *)avifArrayPushPtr(&meta->items);\n    avifArrayCreate(&item->properties, sizeof(avifProperty), 16);\n    item->id = itemID;\n    item->meta = meta;\n    return item;\n}\n\ntypedef struct avifDecoderData\n{\n    avifFileType ftyp;\n    avifMeta * meta; // The root-level meta box\n    avifTrackArray tracks;\n    avifROData rawInput;\n    avifTileArray tiles;\n    unsigned int colorTileCount;\n    unsigned int alphaTileCount;\n    avifImageGrid colorGrid;\n    avifImageGrid alphaGrid;\n    avifDecoderSource source;\n    const avifSampleTable * sourceSampleTable; // NULL unless (source == AVIF_DECODER_SOURCE_TRACKS), owned by an avifTrack\n    avifBool cicpSet;                          // True if avifDecoder's image has had its CICP set correctly yet.\n                                               // This allows nclx colr boxes to override AV1 CICP, as specified in the MIAF\n                                               // standard (ISO/IEC 23000-22:2019), section 7.3.6.4:\n                                               //\n    // \"The colour information property takes precedence over any colour information in the image\n    // bitstream, i.e. if the property is present, colour information in the bitstream shall be ignored.\"\n} avifDecoderData;\n\nstatic avifDecoderData * avifDecoderDataCreate()\n{\n    avifDecoderData * data = (avifDecoderData *)avifAlloc(sizeof(avifDecoderData));\n    memset(data, 0, sizeof(avifDecoderData));\n    data->meta = avifMetaCreate();\n    avifArrayCreate(&data->tracks, sizeof(avifTrack), 2);\n    avifArrayCreate(&data->tiles, sizeof(avifTile), 8);\n    return data;\n}\n\nstatic void avifDecoderDataResetCodec(avifDecoderData * data)\n{\n    for (unsigned int i = 0; i < data->tiles.count; ++i) {\n        avifTile * tile = &data->tiles.tile[i];\n        if (tile->image) {\n            avifImageFreePlanes(tile->image, AVIF_PLANES_ALL); // forget any pointers into codec image buffers\n        }\n        if (tile->codec) {\n            avifCodecDestroy(tile->codec);\n            tile->codec = NULL;\n        }\n    }\n}\n\nstatic avifTile * avifDecoderDataCreateTile(avifDecoderData * data)\n{\n    avifTile * tile = (avifTile *)avifArrayPushPtr(&data->tiles);\n    tile->image = avifImageCreateEmpty();\n    tile->input = avifCodecDecodeInputCreate();\n    return tile;\n}\n\nstatic avifTrack * avifDecoderDataCreateTrack(avifDecoderData * data)\n{\n    avifTrack * track = (avifTrack *)avifArrayPushPtr(&data->tracks);\n    track->meta = avifMetaCreate();\n    return track;\n}\n\nstatic void avifDecoderDataClearTiles(avifDecoderData * data)\n{\n    for (unsigned int i = 0; i < data->tiles.count; ++i) {\n        avifTile * tile = &data->tiles.tile[i];\n        if (tile->input) {\n            avifCodecDecodeInputDestroy(tile->input);\n            tile->input = NULL;\n        }\n        if (tile->codec) {\n            avifCodecDestroy(tile->codec);\n            tile->codec = NULL;\n        }\n        if (tile->image) {\n            avifImageDestroy(tile->image);\n            tile->image = NULL;\n        }\n    }\n    data->tiles.count = 0;\n    data->colorTileCount = 0;\n    data->alphaTileCount = 0;\n}\n\nstatic void avifDecoderDataDestroy(avifDecoderData * data)\n{\n    avifMetaDestroy(data->meta);\n    for (uint32_t i = 0; i < data->tracks.count; ++i) {\n        avifTrack * track = &data->tracks.track[i];\n        if (track->sampleTable) {\n            avifSampleTableDestroy(track->sampleTable);\n        }\n        if (track->meta) {\n            avifMetaDestroy(track->meta);\n        }\n    }\n    avifArrayDestroy(&data->tracks);\n    avifDecoderDataClearTiles(data);\n    avifArrayDestroy(&data->tiles);\n    avifFree(data);\n}\n\nstatic const uint8_t * avifDecoderDataCalcItemPtr(avifDecoderData * data, avifDecoderItem * item)\n{\n    avifROData * offsetBuffer = NULL;\n    if (item->idatID == 0) {\n        // construction_method: file(0)\n\n        offsetBuffer = &data->rawInput;\n    } else {\n        // construction_method: idat(1)\n\n        // Find associated idat block\n        for (uint32_t i = 0; i < item->meta->idats.count; ++i) {\n            if (item->meta->idats.idat[i].id == item->idatID) {\n                offsetBuffer = &item->meta->idats.idat[i].data;\n                break;\n            }\n        }\n\n        if (offsetBuffer == NULL) {\n            // no idat box was found in this meta box, bail out\n            return NULL;\n        }\n    }\n\n    if (item->offset > offsetBuffer->size) {\n        return NULL;\n    }\n    uint64_t offsetSize = (uint64_t)item->offset + (uint64_t)item->size;\n    if (offsetSize > (uint64_t)offsetBuffer->size) {\n        return NULL;\n    }\n    return offsetBuffer->data + item->offset;\n}\n\nstatic avifBool avifDecoderDataGenerateImageGridTiles(avifDecoderData * data, avifImageGrid * grid, avifDecoderItem * gridItem, avifBool alpha)\n{\n    unsigned int tilesRequested = (unsigned int)grid->rows * (unsigned int)grid->columns;\n\n    // Count number of dimg for this item, bail out if it doesn't match perfectly\n    unsigned int tilesAvailable = 0;\n    for (uint32_t i = 0; i < gridItem->meta->items.count; ++i) {\n        avifDecoderItem * item = &gridItem->meta->items.item[i];\n        if (item->dimgForID == gridItem->id) {\n            if (memcmp(item->type, \"av01\", 4)) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n\n            ++tilesAvailable;\n        }\n    }\n\n    if (tilesRequested != tilesAvailable) {\n        return AVIF_FALSE;\n    }\n\n    avifBool firstTile = AVIF_TRUE;\n    for (uint32_t i = 0; i < gridItem->meta->items.count; ++i) {\n        avifDecoderItem * item = &gridItem->meta->items.item[i];\n        if (item->dimgForID == gridItem->id) {\n            if (memcmp(item->type, \"av01\", 4)) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n\n            avifTile * tile = avifDecoderDataCreateTile(data);\n            avifDecodeSample * sample = (avifDecodeSample *)avifArrayPushPtr(&tile->input->samples);\n            sample->data.data = avifDecoderDataCalcItemPtr(data, item);\n            sample->data.size = item->size;\n            sample->sync = AVIF_TRUE;\n            tile->input->alpha = alpha;\n\n            if (firstTile) {\n                firstTile = AVIF_FALSE;\n\n                // Adopt the av1C property of the first av01 tile, so that it can be queried from\n                // the top-level color/alpha item during avifDecoderReset().\n                const avifProperty * srcProp = avifPropertyArrayFind(&item->properties, \"av1C\");\n                if (!srcProp) {\n                    return AVIF_FALSE;\n                }\n                avifProperty * dstProp = (avifProperty *)avifArrayPushPtr(&gridItem->properties);\n                memcpy(dstProp, srcProp, sizeof(avifProperty));\n            }\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifDecoderDataFillImageGrid(avifDecoderData * data,\n                                             avifImageGrid * grid,\n                                             avifImage * dstImage,\n                                             unsigned int firstTileIndex,\n                                             unsigned int tileCount,\n                                             avifBool alpha)\n{\n    if (tileCount == 0) {\n        return AVIF_FALSE;\n    }\n\n    avifTile * firstTile = &data->tiles.tile[firstTileIndex];\n    avifBool firstTileUVPresent = (firstTile->image->yuvPlanes[AVIF_CHAN_U] && firstTile->image->yuvPlanes[AVIF_CHAN_V]);\n\n    // Check for tile consistency: All tiles in a grid image should match in the properties checked below.\n    for (unsigned int i = 1; i < tileCount; ++i) {\n        avifTile * tile = &data->tiles.tile[firstTileIndex + i];\n        avifBool uvPresent = (tile->image->yuvPlanes[AVIF_CHAN_U] && tile->image->yuvPlanes[AVIF_CHAN_V]);\n        if ((tile->image->width != firstTile->image->width) || (tile->image->height != firstTile->image->height) ||\n            (tile->image->depth != firstTile->image->depth) || (tile->image->yuvFormat != firstTile->image->yuvFormat) ||\n            (tile->image->yuvRange != firstTile->image->yuvRange) || (uvPresent != firstTileUVPresent) ||\n            ((tile->image->colorPrimaries != firstTile->image->colorPrimaries) ||\n             (tile->image->transferCharacteristics != firstTile->image->transferCharacteristics) ||\n             (tile->image->matrixCoefficients != firstTile->image->matrixCoefficients))) {\n            return AVIF_FALSE;\n        }\n    }\n\n    // Lazily populate dstImage with the new frame's properties. If we're decoding alpha,\n    // these values must already match.\n    if ((dstImage->width != grid->outputWidth) || (dstImage->height != grid->outputHeight) ||\n        (dstImage->depth != firstTile->image->depth) || (dstImage->yuvFormat != firstTile->image->yuvFormat)) {\n        if (alpha) {\n            // Alpha doesn't match size, just bail out\n            return AVIF_FALSE;\n        }\n\n        avifImageFreePlanes(dstImage, AVIF_PLANES_ALL);\n        dstImage->width = grid->outputWidth;\n        dstImage->height = grid->outputHeight;\n        dstImage->depth = firstTile->image->depth;\n        dstImage->yuvFormat = firstTile->image->yuvFormat;\n        dstImage->yuvRange = firstTile->image->yuvRange;\n        if (!data->cicpSet) {\n            data->cicpSet = AVIF_TRUE;\n            dstImage->colorPrimaries = firstTile->image->colorPrimaries;\n            dstImage->transferCharacteristics = firstTile->image->transferCharacteristics;\n            dstImage->matrixCoefficients = firstTile->image->matrixCoefficients;\n        }\n    }\n    if (alpha) {\n        dstImage->alphaRange = firstTile->image->alphaRange;\n    }\n\n    avifImageAllocatePlanes(dstImage, alpha ? AVIF_PLANES_A : AVIF_PLANES_YUV);\n\n    avifPixelFormatInfo formatInfo;\n    avifGetPixelFormatInfo(firstTile->image->yuvFormat, &formatInfo);\n\n    unsigned int tileIndex = firstTileIndex;\n    size_t pixelBytes = avifImageUsesU16(dstImage) ? 2 : 1;\n    for (unsigned int rowIndex = 0; rowIndex < grid->rows; ++rowIndex) {\n        for (unsigned int colIndex = 0; colIndex < grid->columns; ++colIndex, ++tileIndex) {\n            avifTile * tile = &data->tiles.tile[tileIndex];\n\n            unsigned int widthToCopy = firstTile->image->width;\n            unsigned int maxX = firstTile->image->width * (colIndex + 1);\n            if (maxX > grid->outputWidth) {\n                widthToCopy -= maxX - grid->outputWidth;\n            }\n\n            unsigned int heightToCopy = firstTile->image->height;\n            unsigned int maxY = firstTile->image->height * (rowIndex + 1);\n            if (maxY > grid->outputHeight) {\n                heightToCopy -= maxY - grid->outputHeight;\n            }\n\n            // Y and A channels\n            size_t yaColOffset = colIndex * firstTile->image->width;\n            size_t yaRowOffset = rowIndex * firstTile->image->height;\n            size_t yaRowBytes = widthToCopy * pixelBytes;\n\n            if (alpha) {\n                // A\n                for (unsigned int j = 0; j < heightToCopy; ++j) {\n                    uint8_t * src = &tile->image->alphaPlane[j * tile->image->alphaRowBytes];\n                    uint8_t * dst = &dstImage->alphaPlane[(yaColOffset * pixelBytes) + ((yaRowOffset + j) * dstImage->alphaRowBytes)];\n                    memcpy(dst, src, yaRowBytes);\n                }\n            } else {\n                // Y\n                for (unsigned int j = 0; j < heightToCopy; ++j) {\n                    uint8_t * src = &tile->image->yuvPlanes[AVIF_CHAN_Y][j * tile->image->yuvRowBytes[AVIF_CHAN_Y]];\n                    uint8_t * dst =\n                        &dstImage->yuvPlanes[AVIF_CHAN_Y][(yaColOffset * pixelBytes) + ((yaRowOffset + j) * dstImage->yuvRowBytes[AVIF_CHAN_Y])];\n                    memcpy(dst, src, yaRowBytes);\n                }\n\n                if (!firstTileUVPresent) {\n                    continue;\n                }\n\n                // UV\n                heightToCopy >>= formatInfo.chromaShiftY;\n                size_t uvColOffset = yaColOffset >> formatInfo.chromaShiftX;\n                size_t uvRowOffset = yaRowOffset >> formatInfo.chromaShiftY;\n                size_t uvRowBytes = yaRowBytes >> formatInfo.chromaShiftX;\n                for (unsigned int j = 0; j < heightToCopy; ++j) {\n                    uint8_t * srcU = &tile->image->yuvPlanes[AVIF_CHAN_U][j * tile->image->yuvRowBytes[AVIF_CHAN_U]];\n                    uint8_t * dstU =\n                        &dstImage->yuvPlanes[AVIF_CHAN_U][(uvColOffset * pixelBytes) + ((uvRowOffset + j) * dstImage->yuvRowBytes[AVIF_CHAN_U])];\n                    memcpy(dstU, srcU, uvRowBytes);\n\n                    uint8_t * srcV = &tile->image->yuvPlanes[AVIF_CHAN_V][j * tile->image->yuvRowBytes[AVIF_CHAN_V]];\n                    uint8_t * dstV =\n                        &dstImage->yuvPlanes[AVIF_CHAN_V][(uvColOffset * pixelBytes) + ((uvRowOffset + j) * dstImage->yuvRowBytes[AVIF_CHAN_V])];\n                    memcpy(dstV, srcV, uvRowBytes);\n                }\n            }\n        }\n    }\n\n    return AVIF_TRUE;\n}\n\n// If colorId == 0 (a sentinel value as item IDs must be nonzero), accept any found EXIF/XMP metadata. Passing in 0\n// is used when finding metadata in a meta box embedded in a trak box, as any items inside of a meta box that is\n// inside of a trak box are implicitly associated to the track.\nstatic avifBool avifDecoderDataFindMetadata(avifDecoderData * data, avifMeta * meta, avifImage * image, uint32_t colorId)\n{\n    avifROData exifData = AVIF_DATA_EMPTY;\n    avifROData xmpData = AVIF_DATA_EMPTY;\n\n    for (uint32_t itemIndex = 0; itemIndex < meta->items.count; ++itemIndex) {\n        avifDecoderItem * item = &meta->items.item[itemIndex];\n        if (!item->size) {\n            continue;\n        }\n        if (item->hasUnsupportedEssentialProperty) {\n            // An essential property isn't supported by libavif; ignore the item.\n            continue;\n        }\n\n        if ((colorId > 0) && (item->descForID != colorId)) {\n            // Not a content description (metadata) for the colorOBU, skip it\n            continue;\n        }\n\n        if (!memcmp(item->type, \"Exif\", 4)) {\n            // Advance past Annex A.2.1's header\n            const uint8_t * boxPtr = avifDecoderDataCalcItemPtr(data, item);\n            BEGIN_STREAM(exifBoxStream, boxPtr, item->size);\n            uint32_t exifTiffHeaderOffset;\n            CHECK(avifROStreamReadU32(&exifBoxStream, &exifTiffHeaderOffset)); // unsigned int(32) exif_tiff_header_offset;\n\n            exifData.data = avifROStreamCurrent(&exifBoxStream);\n            exifData.size = avifROStreamRemainingBytes(&exifBoxStream);\n        } else if (!memcmp(item->type, \"mime\", 4) && !memcmp(item->contentType.contentType, xmpContentType, xmpContentTypeSize)) {\n            xmpData.data = avifDecoderDataCalcItemPtr(data, item);\n            xmpData.size = item->size;\n        }\n    }\n\n    if (exifData.data && exifData.size) {\n        avifImageSetMetadataExif(image, exifData.data, exifData.size);\n    }\n    if (xmpData.data && xmpData.size) {\n        avifImageSetMetadataXMP(image, xmpData.data, xmpData.size);\n    }\n    return AVIF_TRUE;\n}\n\n// ---------------------------------------------------------------------------\n// URN\n\nstatic avifBool isAlphaURN(const char * urn)\n{\n    return !strcmp(urn, URN_ALPHA0) || !strcmp(urn, URN_ALPHA1);\n}\n\n// ---------------------------------------------------------------------------\n// BMFF Parsing\n\nstatic avifBool avifParseItemLocationBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n    if (version > 2) {\n        return AVIF_FALSE;\n    }\n\n    uint8_t offsetSizeAndLengthSize;\n    CHECK(avifROStreamRead(&s, &offsetSizeAndLengthSize, 1));\n    uint8_t offsetSize = (offsetSizeAndLengthSize >> 4) & 0xf; // unsigned int(4) offset_size;\n    uint8_t lengthSize = (offsetSizeAndLengthSize >> 0) & 0xf; // unsigned int(4) length_size;\n\n    uint8_t baseOffsetSizeAndIndexSize;\n    CHECK(avifROStreamRead(&s, &baseOffsetSizeAndIndexSize, 1));\n    uint8_t baseOffsetSize = (baseOffsetSizeAndIndexSize >> 4) & 0xf; // unsigned int(4) base_offset_size;\n    uint8_t indexSize = 0;\n    if ((version == 1) || (version == 2)) {\n        indexSize = baseOffsetSizeAndIndexSize & 0xf; // unsigned int(4) index_size;\n        if (indexSize != 0) {\n            // extent_index unsupported\n            return AVIF_FALSE;\n        }\n    }\n\n    uint16_t tmp16;\n    uint32_t itemCount;\n    if (version < 2) {\n        CHECK(avifROStreamReadU16(&s, &tmp16)); // unsigned int(16) item_count;\n        itemCount = tmp16;\n    } else {\n        CHECK(avifROStreamReadU32(&s, &itemCount)); // unsigned int(32) item_count;\n    }\n    for (uint32_t i = 0; i < itemCount; ++i) {\n        uint32_t itemID;\n        uint32_t idatID = 0;\n        if (version < 2) {\n            CHECK(avifROStreamReadU16(&s, &tmp16)); // unsigned int(16) item_ID;\n            itemID = tmp16;\n        } else {\n            CHECK(avifROStreamReadU32(&s, &itemID)); // unsigned int(32) item_ID;\n        }\n\n        if ((version == 1) || (version == 2)) {\n            uint8_t ignored;\n            uint8_t constructionMethod;\n            CHECK(avifROStreamRead(&s, &ignored, 1));            // unsigned int(12) reserved = 0;\n            CHECK(avifROStreamRead(&s, &constructionMethod, 1)); // unsigned int(4) construction_method;\n            constructionMethod = constructionMethod & 0xf;\n            if ((constructionMethod != 0 /* file */) && (constructionMethod != 1 /* idat */)) {\n                // construction method item(2) unsupported\n                return AVIF_FALSE;\n            }\n            if (constructionMethod == 1) {\n                idatID = meta->idatID;\n            }\n        }\n\n        uint16_t dataReferenceIndex;                                 // unsigned int(16) data_ref rence_index;\n        CHECK(avifROStreamReadU16(&s, &dataReferenceIndex));         //\n        uint64_t baseOffset;                                         // unsigned int(base_offset_size*8) base_offset;\n        CHECK(avifROStreamReadUX8(&s, &baseOffset, baseOffsetSize)); //\n        uint16_t extentCount;                                        // unsigned int(16) extent_count;\n        CHECK(avifROStreamReadU16(&s, &extentCount));                //\n        if (extentCount == 1) {\n            // If extent_index is ever supported, this spec must be implemented here:\n            // ::  if (((version == 1) || (version == 2)) && (index_size > 0)) {\n            // ::      unsigned int(index_size*8) extent_index;\n            // ::  }\n\n            uint64_t extentOffset; // unsigned int(offset_size*8) extent_offset;\n            CHECK(avifROStreamReadUX8(&s, &extentOffset, offsetSize));\n            uint64_t extentLength; // unsigned int(offset_size*8) extent_length;\n            CHECK(avifROStreamReadUX8(&s, &extentLength, lengthSize));\n\n            avifDecoderItem * item = avifMetaFindItem(meta, itemID);\n            if (!item) {\n                return AVIF_FALSE;\n            }\n            item->id = itemID;\n            item->offset = (uint32_t)(baseOffset + extentOffset);\n            item->size = (uint32_t)extentLength;\n            item->idatID = idatID;\n        } else {\n            // TODO: support more than one extent\n            return AVIF_FALSE;\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); // unsigned int(8) version = 0;\n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         // unsigned int(8) flags;\n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    // unsigned int(8) rows_minus_one;\n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); // unsigned int(8) columns_minus_one;\n    ++grid->rows;\n    ++grid->columns;\n\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  // unsigned int(FieldLength) output_width;\n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); // unsigned int(FieldLength) output_height;\n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            // This should be impossible\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;\n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageSpatialExtentsProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    avifImageSpatialExtents * ispe = &prop->u.ispe;\n    CHECK(avifROStreamReadU32(&s, &ispe->width));\n    CHECK(avifROStreamReadU32(&s, &ispe->height));\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseAuxiliaryTypeProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    CHECK(avifROStreamReadString(&s, prop->u.auxC.auxType, AUXTYPE_SIZE));\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseColourInformationBox(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifColourInformationBox * colr = &prop->u.colr;\n    colr->hasICC = AVIF_FALSE;\n    colr->hasNCLX = AVIF_FALSE;\n\n    uint8_t colorType[4]; // unsigned int(32) colour_type;\n    CHECK(avifROStreamRead(&s, colorType, 4));\n    if (!memcmp(colorType, \"rICC\", 4) || !memcmp(colorType, \"prof\", 4)) {\n        colr->hasICC = AVIF_TRUE;\n        colr->icc = avifROStreamCurrent(&s);\n        colr->iccSize = avifROStreamRemainingBytes(&s);\n    } else if (!memcmp(colorType, \"nclx\", 4)) {\n        uint16_t tmp16;\n        // unsigned int(16) colour_primaries;\n        CHECK(avifROStreamReadU16(&s, &tmp16));\n        colr->colorPrimaries = (avifColorPrimaries)tmp16;\n        // unsigned int(16) transfer_characteristics;\n        CHECK(avifROStreamReadU16(&s, &tmp16));\n        colr->transferCharacteristics = (avifTransferCharacteristics)tmp16;\n        // unsigned int(16) matrix_coefficients;\n        CHECK(avifROStreamReadU16(&s, &tmp16));\n        colr->matrixCoefficients = (avifMatrixCoefficients)tmp16;\n        // unsigned int(1) full_range_flag;\n        // unsigned int(7) reserved = 0;\n        uint8_t tmp8;\n        CHECK(avifROStreamRead(&s, &tmp8, 1));\n        colr->range = (tmp8 & 0x80) ? AVIF_RANGE_FULL : AVIF_RANGE_LIMITED;\n        colr->hasNCLX = AVIF_TRUE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseAV1CodecConfigurationBox(const uint8_t * raw, size_t rawLen, avifCodecConfigurationBox * av1C)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t markerAndVersion = 0;\n    CHECK(avifROStreamRead(&s, &markerAndVersion, 1));\n    uint8_t seqProfileAndIndex = 0;\n    CHECK(avifROStreamRead(&s, &seqProfileAndIndex, 1));\n    uint8_t rawFlags = 0;\n    CHECK(avifROStreamRead(&s, &rawFlags, 1));\n\n    if (markerAndVersion != 0x81) {\n        // Marker and version must both == 1\n        return AVIF_FALSE;\n    }\n\n    av1C->seqProfile = (seqProfileAndIndex >> 5) & 0x7;    // unsigned int (3) seq_profile;\n    av1C->seqLevelIdx0 = (seqProfileAndIndex >> 0) & 0x1f; // unsigned int (5) seq_level_idx_0;\n    av1C->seqTier0 = (rawFlags >> 7) & 0x1;                // unsigned int (1) seq_tier_0;\n    av1C->highBitdepth = (rawFlags >> 6) & 0x1;            // unsigned int (1) high_bitdepth;\n    av1C->twelveBit = (rawFlags >> 5) & 0x1;               // unsigned int (1) twelve_bit;\n    av1C->monochrome = (rawFlags >> 4) & 0x1;              // unsigned int (1) monochrome;\n    av1C->chromaSubsamplingX = (rawFlags >> 3) & 0x1;      // unsigned int (1) chroma_subsampling_x;\n    av1C->chromaSubsamplingY = (rawFlags >> 2) & 0x1;      // unsigned int (1) chroma_subsampling_y;\n    av1C->chromaSamplePosition = (rawFlags >> 0) & 0x3;    // unsigned int (2) chroma_sample_position;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseAV1CodecConfigurationBoxProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    return avifParseAV1CodecConfigurationBox(raw, rawLen, &prop->u.av1C);\n}\n\nstatic avifBool avifParsePixelAspectRatioBoxProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifPixelAspectRatioBox * pasp = &prop->u.pasp;\n    CHECK(avifROStreamReadU32(&s, &pasp->hSpacing)); // unsigned int(32) hSpacing;\n    CHECK(avifROStreamReadU32(&s, &pasp->vSpacing)); // unsigned int(32) vSpacing;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseCleanApertureBoxProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifCleanApertureBox * clap = &prop->u.clap;\n    CHECK(avifROStreamReadU32(&s, &clap->widthN));    // unsigned int(32) cleanApertureWidthN;\n    CHECK(avifROStreamReadU32(&s, &clap->widthD));    // unsigned int(32) cleanApertureWidthD;\n    CHECK(avifROStreamReadU32(&s, &clap->heightN));   // unsigned int(32) cleanApertureHeightN;\n    CHECK(avifROStreamReadU32(&s, &clap->heightD));   // unsigned int(32) cleanApertureHeightD;\n    CHECK(avifROStreamReadU32(&s, &clap->horizOffN)); // unsigned int(32) horizOffN;\n    CHECK(avifROStreamReadU32(&s, &clap->horizOffD)); // unsigned int(32) horizOffD;\n    CHECK(avifROStreamReadU32(&s, &clap->vertOffN));  // unsigned int(32) vertOffN;\n    CHECK(avifROStreamReadU32(&s, &clap->vertOffD));  // unsigned int(32) vertOffD;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageRotationProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifImageRotation * irot = &prop->u.irot;\n    CHECK(avifROStreamRead(&s, &irot->angle, 1)); // unsigned int (6) reserved = 0; unsigned int (2) angle;\n    if ((irot->angle & 0xfc) != 0) {\n        // reserved bits must be 0\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageMirrorProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifImageMirror * imir = &prop->u.imir;\n    CHECK(avifROStreamRead(&s, &imir->axis, 1)); // unsigned int (7) reserved = 0; unsigned int (1) axis;\n    if ((imir->axis & 0xfe) != 0) {\n        // reserved bits must be 0\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParsePixelInformationProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    avifPixelInformationProperty * pixi = &prop->u.pixi;\n    CHECK(avifROStreamRead(&s, &pixi->planeCount, 1)); // unsigned int (8) num_channels;\n    if (pixi->planeCount > MAX_PIXI_PLANE_DEPTHS) {\n        return AVIF_FALSE;\n    }\n    for (uint8_t i = 0; i < pixi->planeCount; ++i) {\n        CHECK(avifROStreamRead(&s, &pixi->planeDepths[i], 1)); // unsigned int (8) bits_per_channel;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemPropertyContainerBox(avifPropertyArray * properties, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        int propertyIndex = avifArrayPushIndex(properties);\n        avifProperty * prop = &properties->prop[propertyIndex];\n        memcpy(prop->type, header.type, 4);\n        if (!memcmp(header.type, \"ispe\", 4)) {\n            CHECK(avifParseImageSpatialExtentsProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"auxC\", 4)) {\n            CHECK(avifParseAuxiliaryTypeProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"colr\", 4)) {\n            CHECK(avifParseColourInformationBox(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"av1C\", 4)) {\n            CHECK(avifParseAV1CodecConfigurationBoxProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"pasp\", 4)) {\n            CHECK(avifParsePixelAspectRatioBoxProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"clap\", 4)) {\n            CHECK(avifParseCleanApertureBoxProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"irot\", 4)) {\n            CHECK(avifParseImageRotationProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"imir\", 4)) {\n            CHECK(avifParseImageMirrorProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"pixi\", 4)) {\n            CHECK(avifParsePixelInformationProperty(prop, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemPropertyAssociation(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    uint32_t flags;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, &flags));\n    avifBool propertyIndexIsU16 = ((flags & 0x1) != 0);\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount));\n    for (uint32_t entryIndex = 0; entryIndex < entryCount; ++entryIndex) {\n        unsigned int itemID;\n        if (version < 1) {\n            uint16_t tmp;\n            CHECK(avifROStreamReadU16(&s, &tmp));\n            itemID = tmp;\n        } else {\n            CHECK(avifROStreamReadU32(&s, &itemID));\n        }\n        uint8_t associationCount;\n        CHECK(avifROStreamRead(&s, &associationCount, 1));\n        for (uint8_t associationIndex = 0; associationIndex < associationCount; ++associationIndex) {\n            avifBool essential = AVIF_FALSE;\n            uint16_t propertyIndex = 0;\n            if (propertyIndexIsU16) {\n                CHECK(avifROStreamReadU16(&s, &propertyIndex));\n                essential = ((propertyIndex & 0x8000) != 0);\n                propertyIndex &= 0x7fff;\n            } else {\n                uint8_t tmp;\n                CHECK(avifROStreamRead(&s, &tmp, 1));\n                essential = ((tmp & 0x80) != 0);\n                propertyIndex = tmp & 0x7f;\n            }\n\n            if (propertyIndex == 0) {\n                // Not associated with any item\n                continue;\n            }\n            --propertyIndex; // 1-indexed\n\n            if (propertyIndex >= meta->properties.count) {\n                return AVIF_FALSE;\n            }\n\n            avifDecoderItem * item = avifMetaFindItem(meta, itemID);\n            if (!item) {\n                return AVIF_FALSE;\n            }\n\n            // Copy property to item\n            avifProperty * srcProp = &meta->properties.prop[propertyIndex];\n\n            static const char * supportedTypes[] = { \"ispe\", \"auxC\", \"colr\", \"av1C\", \"pasp\", \"clap\", \"irot\", \"imir\", \"pixi\" };\n            size_t supportedTypesCount = sizeof(supportedTypes) / sizeof(supportedTypes[0]);\n            avifBool supportedType = AVIF_FALSE;\n            for (size_t i = 0; i < supportedTypesCount; ++i) {\n                if (!memcmp(srcProp->type, supportedTypes[i], 4)) {\n                    supportedType = AVIF_TRUE;\n                    break;\n                }\n            }\n            if (supportedType) {\n                avifProperty * dstProp = (avifProperty *)avifArrayPushPtr(&item->properties);\n                memcpy(dstProp, srcProp, sizeof(avifProperty));\n            } else {\n                if (essential) {\n                    // Discovered an essential item property that libavif doesn't support!\n                    // Make a note to ignore this item later.\n                    item->hasUnsupportedEssentialProperty = AVIF_TRUE;\n                }\n            }\n        }\n    }\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParsePrimaryItemBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    if (meta->primaryItemID > 0) {\n        // Illegal to have multiple pitm boxes, bail out\n        return AVIF_FALSE;\n    }\n\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    if (version == 0) {\n        uint16_t tmp16;\n        CHECK(avifROStreamReadU16(&s, &tmp16)); // unsigned int(16) item_ID;\n        meta->primaryItemID = tmp16;\n    } else {\n        CHECK(avifROStreamReadU32(&s, &meta->primaryItemID)); // unsigned int(32) item_ID;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemDataBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    // Check to see if we've already seen an idat box for this meta box. If so, bail out\n    for (uint32_t i = 0; i < meta->idats.count; ++i) {\n        if (meta->idats.idat[i].id == meta->idatID) {\n            return AVIF_FALSE;\n        }\n    }\n\n    int index = avifArrayPushIndex(&meta->idats);\n    avifDecoderItemData * idat = &meta->idats.idat[index];\n    idat->id = meta->idatID;\n    idat->data.data = raw;\n    idat->data.size = rawLen;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemPropertiesBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifBoxHeader ipcoHeader;\n    CHECK(avifROStreamReadBoxHeader(&s, &ipcoHeader));\n    if (memcmp(ipcoHeader.type, \"ipco\", 4) != 0) {\n        return AVIF_FALSE;\n    }\n\n    // Read all item properties inside of ItemPropertyContainerBox\n    CHECK(avifParseItemPropertyContainerBox(&meta->properties, avifROStreamCurrent(&s), ipcoHeader.size));\n    CHECK(avifROStreamSkip(&s, ipcoHeader.size));\n\n    // Now read all ItemPropertyAssociation until the end of the box, and make associations\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader ipmaHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &ipmaHeader));\n\n        if (!memcmp(ipmaHeader.type, \"ipma\", 4)) {\n            CHECK(avifParseItemPropertyAssociation(meta, avifROStreamCurrent(&s), ipmaHeader.size));\n        } else {\n            // These must all be type ipma\n            return AVIF_FALSE;\n        }\n\n        CHECK(avifROStreamSkip(&s, ipmaHeader.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemInfoEntry(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 2)); // TODO: support version > 2? 2+ is required for item_type\n\n    uint16_t itemID;                                      // unsigned int(16) item_ID;\n    CHECK(avifROStreamReadU16(&s, &itemID));              //\n    uint16_t itemProtectionIndex;                         // unsigned int(16) item_protection_index;\n    CHECK(avifROStreamReadU16(&s, &itemProtectionIndex)); //\n    uint8_t itemType[4];                                  // unsigned int(32) item_type;\n    CHECK(avifROStreamRead(&s, itemType, 4));             //\n\n    avifContentType contentType;\n    if (!memcmp(itemType, \"mime\", 4)) {\n        CHECK(avifROStreamReadString(&s, NULL, 0));                                   // string item_name; (skipped)\n        CHECK(avifROStreamReadString(&s, contentType.contentType, CONTENTTYPE_SIZE)); // string content_type;\n    } else {\n        memset(&contentType, 0, sizeof(contentType));\n    }\n\n    avifDecoderItem * item = avifMetaFindItem(meta, itemID);\n    if (!item) {\n        return AVIF_FALSE;\n    }\n\n    memcpy(item->type, itemType, sizeof(itemType));\n    memcpy(&item->contentType, &contentType, sizeof(contentType));\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemInfoBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n    uint32_t entryCount;\n    if (version == 0) {\n        uint16_t tmp;\n        CHECK(avifROStreamReadU16(&s, &tmp)); // unsigned int(16) entry_count;\n        entryCount = tmp;\n    } else if (version == 1) {\n        CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n    } else {\n        return AVIF_FALSE;\n    }\n\n    for (uint32_t entryIndex = 0; entryIndex < entryCount; ++entryIndex) {\n        avifBoxHeader infeHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &infeHeader));\n\n        if (!memcmp(infeHeader.type, \"infe\", 4)) {\n            CHECK(avifParseItemInfoEntry(meta, avifROStreamCurrent(&s), infeHeader.size));\n        } else {\n            // These must all be type ipma\n            return AVIF_FALSE;\n        }\n\n        CHECK(avifROStreamSkip(&s, infeHeader.size));\n    }\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemReferenceBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader irefHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &irefHeader));\n\n        uint32_t fromID = 0;\n        if (version == 0) {\n            uint16_t tmp;\n            CHECK(avifROStreamReadU16(&s, &tmp)); // unsigned int(16) from_item_ID;\n            fromID = tmp;\n        } else if (version == 1) {\n            CHECK(avifROStreamReadU32(&s, &fromID)); // unsigned int(32) from_item_ID;\n        } else {\n            // unsupported iref version, skip it\n            break;\n        }\n\n        uint16_t referenceCount = 0;\n        CHECK(avifROStreamReadU16(&s, &referenceCount)); // unsigned int(16) reference_count;\n\n        for (uint16_t refIndex = 0; refIndex < referenceCount; ++refIndex) {\n            uint32_t toID = 0;\n            if (version == 0) {\n                uint16_t tmp;\n                CHECK(avifROStreamReadU16(&s, &tmp)); // unsigned int(16) to_item_ID;\n                toID = tmp;\n            } else if (version == 1) {\n                CHECK(avifROStreamReadU32(&s, &toID)); // unsigned int(32) to_item_ID;\n            } else {\n                // unsupported iref version, skip it\n                break;\n            }\n\n            // Read this reference as \"{fromID} is a {irefType} for {toID}\"\n            if (fromID && toID) {\n                avifDecoderItem * item = avifMetaFindItem(meta, fromID);\n                if (!item) {\n                    return AVIF_FALSE;\n                }\n\n                if (!memcmp(irefHeader.type, \"thmb\", 4)) {\n                    item->thumbnailForID = toID;\n                }\n                if (!memcmp(irefHeader.type, \"auxl\", 4)) {\n                    item->auxForID = toID;\n                }\n                if (!memcmp(irefHeader.type, \"cdsc\", 4)) {\n                    item->descForID = toID;\n                }\n                if (!memcmp(irefHeader.type, \"dimg\", 4)) {\n                    // derived images refer in the opposite direction\n                    avifDecoderItem * dimg = avifMetaFindItem(meta, toID);\n                    if (!dimg) {\n                        return AVIF_FALSE;\n                    }\n\n                    dimg->dimgForID = fromID;\n                }\n            }\n        }\n    }\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMetaBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    ++meta->idatID; // for tracking idat\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"iloc\", 4)) {\n            CHECK(avifParseItemLocationBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"pitm\", 4)) {\n            CHECK(avifParsePrimaryItemBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"idat\", 4)) {\n            CHECK(avifParseItemDataBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"iprp\", 4)) {\n            CHECK(avifParseItemPropertiesBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"iinf\", 4)) {\n            CHECK(avifParseItemInfoBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"iref\", 4)) {\n            CHECK(avifParseItemReferenceBox(meta, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseTrackHeaderBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    uint32_t ignored32, trackID;\n    uint64_t ignored64;\n    if (version == 1) {\n        CHECK(avifROStreamReadU64(&s, &ignored64)); // unsigned int(64) creation_time;\n        CHECK(avifROStreamReadU64(&s, &ignored64)); // unsigned int(64) modification_time;\n        CHECK(avifROStreamReadU32(&s, &trackID));   // unsigned int(32) track_ID;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // const unsigned int(32) reserved = 0;\n        CHECK(avifROStreamReadU64(&s, &ignored64)); // unsigned int(64) duration;\n    } else if (version == 0) {\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // unsigned int(32) creation_time;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // unsigned int(32) modification_time;\n        CHECK(avifROStreamReadU32(&s, &trackID));   // unsigned int(32) track_ID;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // const unsigned int(32) reserved = 0;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // unsigned int(32) duration;\n    } else {\n        // Unsupported version\n        return AVIF_FALSE;\n    }\n\n    // Skipping the following 52 bytes here:\n    // ------------------------------------\n    // const unsigned int(32)[2] reserved = 0;\n    // template int(16) layer = 0;\n    // template int(16) alternate_group = 0;\n    // template int(16) volume = {if track_is_audio 0x0100 else 0};\n    // const unsigned int(16) reserved = 0;\n    // template int(32)[9] matrix= { 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 }; // unity matrix\n    CHECK(avifROStreamSkip(&s, 52));\n\n    uint32_t width, height;\n    CHECK(avifROStreamReadU32(&s, &width));  // unsigned int(32) width;\n    CHECK(avifROStreamReadU32(&s, &height)); // unsigned int(32) height;\n    track->width = width >> 16;\n    track->height = height >> 16;\n\n    // TODO: support scaling based on width/height track header info?\n\n    track->id = trackID;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMediaHeaderBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    uint32_t ignored32, mediaTimescale, mediaDuration32;\n    uint64_t ignored64, mediaDuration64;\n    if (version == 1) {\n        CHECK(avifROStreamReadU64(&s, &ignored64));       // unsigned int(64) creation_time;\n        CHECK(avifROStreamReadU64(&s, &ignored64));       // unsigned int(64) modification_time;\n        CHECK(avifROStreamReadU32(&s, &mediaTimescale));  // unsigned int(32) timescale;\n        CHECK(avifROStreamReadU64(&s, &mediaDuration64)); // unsigned int(64) duration;\n        track->mediaDuration = mediaDuration64;\n    } else if (version == 0) {\n        CHECK(avifROStreamReadU32(&s, &ignored32));       // unsigned int(32) creation_time;\n        CHECK(avifROStreamReadU32(&s, &ignored32));       // unsigned int(32) modification_time;\n        CHECK(avifROStreamReadU32(&s, &mediaTimescale));  // unsigned int(32) timescale;\n        CHECK(avifROStreamReadU32(&s, &mediaDuration32)); // unsigned int(32) duration;\n        track->mediaDuration = (uint64_t)mediaDuration32;\n    } else {\n        // Unsupported version\n        return AVIF_FALSE;\n    }\n\n    track->mediaTimescale = mediaTimescale;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseChunkOffsetBox(avifSampleTable * sampleTable, avifBool largeOffsets, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        uint64_t offset;\n        if (largeOffsets) {\n            CHECK(avifROStreamReadU64(&s, &offset)); // unsigned int(32) chunk_offset;\n        } else {\n            uint32_t offset32;\n            CHECK(avifROStreamReadU32(&s, &offset32)); // unsigned int(32) chunk_offset;\n            offset = (uint64_t)offset32;\n        }\n\n        avifSampleTableChunk * chunk = (avifSampleTableChunk *)avifArrayPushPtr(&sampleTable->chunks);\n        chunk->offset = offset;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleToChunkBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        avifSampleTableSampleToChunk * sampleToChunk = (avifSampleTableSampleToChunk *)avifArrayPushPtr(&sampleTable->sampleToChunks);\n        CHECK(avifROStreamReadU32(&s, &sampleToChunk->firstChunk));             // unsigned int(32) first_chunk;\n        CHECK(avifROStreamReadU32(&s, &sampleToChunk->samplesPerChunk));        // unsigned int(32) samples_per_chunk;\n        CHECK(avifROStreamReadU32(&s, &sampleToChunk->sampleDescriptionIndex)); // unsigned int(32) sample_description_index;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleSizeBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t allSamplesSize, sampleCount;\n    CHECK(avifROStreamReadU32(&s, &allSamplesSize)); // unsigned int(32) sample_size;\n    CHECK(avifROStreamReadU32(&s, &sampleCount));    // unsigned int(32) sample_count;\n\n    if (allSamplesSize > 0) {\n        sampleTable->allSamplesSize = allSamplesSize;\n    } else {\n        for (uint32_t i = 0; i < sampleCount; ++i) {\n            avifSampleTableSampleSize * sampleSize = (avifSampleTableSampleSize *)avifArrayPushPtr(&sampleTable->sampleSizes);\n            CHECK(avifROStreamReadU32(&s, &sampleSize->size)); // unsigned int(32) entry_size;\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSyncSampleBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        uint32_t sampleNumber = 0;\n        CHECK(avifROStreamReadU32(&s, &sampleNumber)); // unsigned int(32) sample_number;\n        avifSyncSample * syncSample = (avifSyncSample *)avifArrayPushPtr(&sampleTable->syncSamples);\n        syncSample->sampleNumber = sampleNumber;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseTimeToSampleBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        avifSampleTableTimeToSample * timeToSample = (avifSampleTableTimeToSample *)avifArrayPushPtr(&sampleTable->timeToSamples);\n        CHECK(avifROStreamReadU32(&s, &timeToSample->sampleCount)); // unsigned int(32) sample_count;\n        CHECK(avifROStreamReadU32(&s, &timeToSample->sampleDelta)); // unsigned int(32) sample_delta;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleDescriptionBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        avifBoxHeader sampleEntryHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &sampleEntryHeader));\n\n        avifSampleDescription * description = (avifSampleDescription *)avifArrayPushPtr(&sampleTable->sampleDescriptions);\n        avifArrayCreate(&description->properties, sizeof(avifProperty), 16);\n        memcpy(description->format, sampleEntryHeader.type, sizeof(description->format));\n        size_t remainingBytes = avifROStreamRemainingBytes(&s);\n        if (!memcmp(description->format, \"av01\", 4) && (remainingBytes > VISUALSAMPLEENTRY_SIZE)) {\n            CHECK(avifParseItemPropertyContainerBox(\n                &description->properties, avifROStreamCurrent(&s) + VISUALSAMPLEENTRY_SIZE, remainingBytes - VISUALSAMPLEENTRY_SIZE));\n        }\n\n        CHECK(avifROStreamSkip(&s, sampleEntryHeader.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleTableBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    if (track->sampleTable) {\n        // A TrackBox may only have one SampleTable\n        return AVIF_FALSE;\n    }\n    track->sampleTable = avifSampleTableCreate();\n\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"stco\", 4)) {\n            CHECK(avifParseChunkOffsetBox(track->sampleTable, AVIF_FALSE, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"co64\", 4)) {\n            CHECK(avifParseChunkOffsetBox(track->sampleTable, AVIF_TRUE, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stsc\", 4)) {\n            CHECK(avifParseSampleToChunkBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stsz\", 4)) {\n            CHECK(avifParseSampleSizeBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stss\", 4)) {\n            CHECK(avifParseSyncSampleBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stts\", 4)) {\n            CHECK(avifParseTimeToSampleBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stsd\", 4)) {\n            CHECK(avifParseSampleDescriptionBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMediaInformationBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"stbl\", 4)) {\n            CHECK(avifParseSampleTableBox(track, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMediaBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"mdhd\", 4)) {\n            CHECK(avifParseMediaHeaderBox(track, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"minf\", 4)) {\n            CHECK(avifParseMediaInformationBox(track, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifTrackReferenceBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"auxl\", 4)) {\n            uint32_t toID;\n            CHECK(avifROStreamReadU32(&s, &toID));                       // unsigned int(32) track_IDs[]\n            CHECK(avifROStreamSkip(&s, header.size - sizeof(uint32_t))); // just take the first one\n            track->auxForID = toID;\n        } else {\n            CHECK(avifROStreamSkip(&s, header.size));\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseTrackBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifTrack * track = avifDecoderDataCreateTrack(data);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"tkhd\", 4)) {\n            CHECK(avifParseTrackHeaderBox(track, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"meta\", 4)) {\n            CHECK(avifParseMetaBox(track->meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"mdia\", 4)) {\n            CHECK(avifParseMediaBox(track, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"tref\", 4)) {\n            CHECK(avifTrackReferenceBox(track, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMoovBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"trak\", 4)) {\n            CHECK(avifParseTrackBox(data, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseFileTypeBox(avifFileType * ftyp, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamRead(&s, ftyp->majorBrand, 4));\n    CHECK(avifROStreamReadU32(&s, &ftyp->minorVersion));\n\n    size_t compatibleBrandsBytes = avifROStreamRemainingBytes(&s);\n    if ((compatibleBrandsBytes % 4) != 0) {\n        return AVIF_FALSE;\n    }\n    ftyp->compatibleBrands = avifROStreamCurrent(&s);\n    CHECK(avifROStreamSkip(&s, compatibleBrandsBytes));\n    ftyp->compatibleBrandsCount = (int)compatibleBrandsBytes / 4;\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParse(avifDecoderData * data, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"ftyp\", 4)) {\n            CHECK(avifParseFileTypeBox(&data->ftyp, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"meta\", 4)) {\n            CHECK(avifParseMetaBox(data->meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"moov\", 4)) {\n            CHECK(avifParseMoovBox(data, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\n// ---------------------------------------------------------------------------\n\nstatic avifBool avifFileTypeIsCompatible(avifFileType * ftyp)\n{\n    avifBool avifCompatible = (memcmp(ftyp->majorBrand, \"avif\", 4) == 0 || memcmp(ftyp->majorBrand, \"avis\", 4) == 0);\n    if (!avifCompatible) {\n        for (int compatibleBrandIndex = 0; compatibleBrandIndex < ftyp->compatibleBrandsCount; ++compatibleBrandIndex) {\n            const uint8_t * compatibleBrand = &ftyp->compatibleBrands[4 * compatibleBrandIndex];\n            if (!memcmp(compatibleBrand, \"avif\", 4) || !memcmp(compatibleBrand, \"avis\", 4)) {\n                avifCompatible = AVIF_TRUE;\n                break;\n            }\n        }\n    }\n    return avifCompatible;\n}\n\navifBool avifPeekCompatibleFileType(const avifROData * input)\n{\n    BEGIN_STREAM(s, input->data, input->size);\n\n    avifBoxHeader header;\n    CHECK(avifROStreamReadBoxHeader(&s, &header));\n    if (memcmp(header.type, \"ftyp\", 4) != 0) {\n        return AVIF_FALSE;\n    }\n\n    avifFileType ftyp;\n    memset(&ftyp, 0, sizeof(avifFileType));\n    avifBool parsed = avifParseFileTypeBox(&ftyp, avifROStreamCurrent(&s), header.size);\n    if (!parsed) {\n        return AVIF_FALSE;\n    }\n    return avifFileTypeIsCompatible(&ftyp);\n}\n\n// ---------------------------------------------------------------------------\n\navifDecoder * avifDecoderCreate(void)\n{\n    avifDecoder * decoder = (avifDecoder *)avifAlloc(sizeof(avifDecoder));\n    memset(decoder, 0, sizeof(avifDecoder));\n    return decoder;\n}\n\nstatic void avifDecoderCleanup(avifDecoder * decoder)\n{\n    if (decoder->data) {\n        avifDecoderDataDestroy(decoder->data);\n        decoder->data = NULL;\n    }\n\n    if (decoder->image) {\n        avifImageDestroy(decoder->image);\n        decoder->image = NULL;\n    }\n}\n\nvoid avifDecoderDestroy(avifDecoder * decoder)\n{\n    avifDecoderCleanup(decoder);\n    avifFree(decoder);\n}\n\navifResult avifDecoderSetSource(avifDecoder * decoder, avifDecoderSource source)\n{\n    decoder->requestedSource = source;\n    return avifDecoderReset(decoder);\n}\n\navifResult avifDecoderParse(avifDecoder * decoder, const avifROData * rawInput)\n{\n    // Cleanup anything lingering in the decoder\n    avifDecoderCleanup(decoder);\n\n    // -----------------------------------------------------------------------\n    // Parse BMFF boxes\n\n    decoder->data = avifDecoderDataCreate();\n\n    // Shallow copy, on purpose\n    memcpy(&decoder->data->rawInput, rawInput, sizeof(avifROData));\n\n    if (!avifParse(decoder->data, decoder->data->rawInput.data, decoder->data->rawInput.size)) {\n        return AVIF_RESULT_BMFF_PARSE_FAILED;\n    }\n\n    avifBool avifCompatible = avifFileTypeIsCompatible(&decoder->data->ftyp);\n    if (!avifCompatible) {\n        return AVIF_RESULT_INVALID_FTYP;\n    }\n\n    // Sanity check items\n    for (uint32_t itemIndex = 0; itemIndex < decoder->data->meta->items.count; ++itemIndex) {\n        avifDecoderItem * item = &decoder->data->meta->items.item[itemIndex];\n        if (item->hasUnsupportedEssentialProperty) {\n            // An essential property isn't supported by libavif; ignore the item.\n            continue;\n        }\n        const uint8_t * p = avifDecoderDataCalcItemPtr(decoder->data, item);\n        if (p == NULL) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n    }\n\n    // Sanity check tracks\n    for (uint32_t trackIndex = 0; trackIndex < decoder->data->tracks.count; ++trackIndex) {\n        avifTrack * track = &decoder->data->tracks.track[trackIndex];\n        if (!track->sampleTable) {\n            continue;\n        }\n\n        for (uint32_t chunkIndex = 0; chunkIndex < track->sampleTable->chunks.count; ++chunkIndex) {\n            avifSampleTableChunk * chunk = &track->sampleTable->chunks.chunk[chunkIndex];\n            if (chunk->offset > decoder->data->rawInput.size) {\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n    }\n    return avifDecoderReset(decoder);\n}\n\nstatic avifCodec * avifCodecCreateInternal(avifCodecChoice choice, avifCodecDecodeInput * decodeInput)\n{\n    avifCodec * codec = avifCodecCreate(choice, AVIF_CODEC_FLAG_CAN_DECODE);\n    if (codec) {\n        codec->decodeInput = decodeInput;\n    }\n    return codec;\n}\n\nstatic avifResult avifDecoderFlush(avifDecoder * decoder)\n{\n    avifDecoderDataResetCodec(decoder->data);\n\n    for (unsigned int i = 0; i < decoder->data->tiles.count; ++i) {\n        avifTile * tile = &decoder->data->tiles.tile[i];\n        tile->codec = avifCodecCreateInternal(decoder->codecChoice, tile->input);\n        if (!tile->codec) {\n            return AVIF_RESULT_NO_CODEC_AVAILABLE;\n        }\n        if (!tile->codec->open(tile->codec, decoder->imageIndex + 1)) {\n            return AVIF_RESULT_DECODE_COLOR_FAILED;\n        }\n    }\n    return AVIF_RESULT_OK;\n}\n\navifResult avifDecoderReset(avifDecoder * decoder)\n{\n    avifDecoderData * data = decoder->data;\n    if (!data) {\n        // Nothing to reset.\n        return AVIF_RESULT_OK;\n    }\n\n    memset(&data->colorGrid, 0, sizeof(data->colorGrid));\n    memset(&data->alphaGrid, 0, sizeof(data->alphaGrid));\n    avifDecoderDataClearTiles(data);\n\n    // Prepare / cleanup decoded image state\n    if (decoder->image) {\n        avifImageDestroy(decoder->image);\n    }\n    decoder->image = avifImageCreateEmpty();\n    data->cicpSet = AVIF_FALSE;\n\n    memset(&decoder->ioStats, 0, sizeof(decoder->ioStats));\n\n    // -----------------------------------------------------------------------\n    // Build decode input\n\n    data->sourceSampleTable = NULL; // Reset\n    if (decoder->requestedSource == AVIF_DECODER_SOURCE_AUTO) {\n        if (data->tracks.count > 0) {\n            data->source = AVIF_DECODER_SOURCE_TRACKS;\n        } else {\n            data->source = AVIF_DECODER_SOURCE_PRIMARY_ITEM;\n        }\n    } else {\n        data->source = decoder->requestedSource;\n    }\n\n    const avifPropertyArray * colorProperties = NULL;\n    if (data->source == AVIF_DECODER_SOURCE_TRACKS) {\n        avifTrack * colorTrack = NULL;\n        avifTrack * alphaTrack = NULL;\n\n        // Find primary track - this probably needs some better detection\n        uint32_t colorTrackIndex = 0;\n        for (; colorTrackIndex < decoder->data->tracks.count; ++colorTrackIndex) {\n            avifTrack * track = &decoder->data->tracks.track[colorTrackIndex];\n            if (!track->sampleTable) {\n                continue;\n            }\n            if (!track->id) { // trak box might be missing a tkhd box inside, skip it\n                continue;\n            }\n            if (!track->sampleTable->chunks.count) {\n                continue;\n            }\n            if (!avifSampleTableHasFormat(track->sampleTable, \"av01\")) {\n                continue;\n            }\n            if (track->auxForID != 0) {\n                continue;\n            }\n\n            // Found one!\n            break;\n        }\n        if (colorTrackIndex == decoder->data->tracks.count) {\n            return AVIF_RESULT_NO_CONTENT;\n        }\n        colorTrack = &decoder->data->tracks.track[colorTrackIndex];\n\n        colorProperties = avifSampleTableGetProperties(colorTrack->sampleTable);\n        if (!colorProperties) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n\n        // Find Exif and/or XMP metadata, if any\n        if (colorTrack->meta) {\n            // See the comment above avifDecoderDataFindMetadata() for the explanation of using 0 here\n            if (!avifDecoderDataFindMetadata(data, colorTrack->meta, decoder->image, 0)) {\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n\n        uint32_t alphaTrackIndex = 0;\n        for (; alphaTrackIndex < decoder->data->tracks.count; ++alphaTrackIndex) {\n            avifTrack * track = &decoder->data->tracks.track[alphaTrackIndex];\n            if (!track->sampleTable) {\n                continue;\n            }\n            if (!track->id) {\n                continue;\n            }\n            if (!track->sampleTable->chunks.count) {\n                continue;\n            }\n            if (!avifSampleTableHasFormat(track->sampleTable, \"av01\")) {\n                continue;\n            }\n            if (track->auxForID == colorTrack->id) {\n                // Found it!\n                break;\n            }\n        }\n        if (alphaTrackIndex != decoder->data->tracks.count) {\n            alphaTrack = &decoder->data->tracks.track[alphaTrackIndex];\n        }\n\n        avifTile * colorTile = avifDecoderDataCreateTile(decoder->data);\n        if (!avifCodecDecodeInputGetSamples(colorTile->input, colorTrack->sampleTable, &decoder->data->rawInput)) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n        decoder->data->colorTileCount = 1;\n\n        avifTile * alphaTile = NULL;\n        if (alphaTrack) {\n            alphaTile = avifDecoderDataCreateTile(decoder->data);\n            if (!avifCodecDecodeInputGetSamples(alphaTile->input, alphaTrack->sampleTable, &decoder->data->rawInput)) {\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n            alphaTile->input->alpha = AVIF_TRUE;\n            decoder->data->alphaTileCount = 1;\n        }\n\n        // Stash off sample table for future timing information\n        data->sourceSampleTable = colorTrack->sampleTable;\n\n        // Image sequence timing\n        decoder->imageIndex = -1;\n        decoder->imageCount = colorTile->input->samples.count;\n        decoder->timescale = colorTrack->mediaTimescale;\n        decoder->durationInTimescales = colorTrack->mediaDuration;\n        if (colorTrack->mediaTimescale) {\n            decoder->duration = (double)decoder->durationInTimescales / (double)colorTrack->mediaTimescale;\n        } else {\n            decoder->duration = 0;\n        }\n        memset(&decoder->imageTiming, 0, sizeof(decoder->imageTiming)); // to be set in avifDecoderNextImage()\n\n        decoder->image->width = colorTrack->width;\n        decoder->image->height = colorTrack->height;\n        decoder->alphaPresent = (alphaTrack != NULL);\n    } else {\n        // Create from items\n\n        avifROData colorOBU = AVIF_DATA_EMPTY;\n        avifROData alphaOBU = AVIF_DATA_EMPTY;\n        avifDecoderItem * colorOBUItem = NULL;\n        avifDecoderItem * alphaOBUItem = NULL;\n\n        // Find the colorOBU (primary) item\n        for (uint32_t itemIndex = 0; itemIndex < data->meta->items.count; ++itemIndex) {\n            avifDecoderItem * item = &data->meta->items.item[itemIndex];\n            if (!item->size) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n            avifBool isGrid = (memcmp(item->type, \"grid\", 4) == 0);\n            if (memcmp(item->type, \"av01\", 4) && !isGrid) {\n                // probably exif or some other data\n                continue;\n            }\n            if (item->thumbnailForID != 0) {\n                // It's a thumbnail, skip it\n                continue;\n            }\n            if ((data->meta->primaryItemID > 0) && (item->id != data->meta->primaryItemID)) {\n                // a primary item ID was specified, require it\n                continue;\n            }\n\n            if (isGrid) {\n                const uint8_t * itemPtr = avifDecoderDataCalcItemPtr(data, item);\n                if (itemPtr == NULL) {\n                    return AVIF_RESULT_BMFF_PARSE_FAILED;\n                }\n                if (!avifParseImageGridBox(&data->colorGrid, itemPtr, item->size)) {\n                    return AVIF_RESULT_INVALID_IMAGE_GRID;\n                }\n            } else {\n                colorOBU.data = avifDecoderDataCalcItemPtr(data, item);\n                colorOBU.size = item->size;\n            }\n\n            colorOBUItem = item;\n            break;\n        }\n\n        if (!colorOBUItem) {\n            return AVIF_RESULT_NO_AV1_ITEMS_FOUND;\n        }\n        colorProperties = &colorOBUItem->properties;\n\n        // Find the alphaOBU item, if any\n        for (uint32_t itemIndex = 0; itemIndex < data->meta->items.count; ++itemIndex) {\n            avifDecoderItem * item = &data->meta->items.item[itemIndex];\n            if (!item->size) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n            avifBool isGrid = (memcmp(item->type, \"grid\", 4) == 0);\n            if (memcmp(item->type, \"av01\", 4) && !isGrid) {\n                // probably exif or some other data\n                continue;\n            }\n            if (item->thumbnailForID != 0) {\n                // It's a thumbnail, skip it\n                continue;\n            }\n\n            const avifProperty * auxCProp = avifPropertyArrayFind(&item->properties, \"auxC\");\n            if (auxCProp && isAlphaURN(auxCProp->u.auxC.auxType) && (item->auxForID == colorOBUItem->id)) {\n                if (isGrid) {\n                    const uint8_t * itemPtr = avifDecoderDataCalcItemPtr(data, item);\n                    if (itemPtr == NULL) {\n                        return AVIF_RESULT_BMFF_PARSE_FAILED;\n                    }\n                    if (!avifParseImageGridBox(&data->alphaGrid, itemPtr, item->size)) {\n                        return AVIF_RESULT_INVALID_IMAGE_GRID;\n                    }\n                } else {\n                    alphaOBU.data = avifDecoderDataCalcItemPtr(data, item);\n                    alphaOBU.size = item->size;\n                }\n\n                alphaOBUItem = item;\n                break;\n            }\n        }\n\n        // Find Exif and/or XMP metadata, if any\n        if (!avifDecoderDataFindMetadata(data, data->meta, decoder->image, colorOBUItem->id)) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n\n        if ((data->colorGrid.rows > 0) && (data->colorGrid.columns > 0)) {\n            if (!avifDecoderDataGenerateImageGridTiles(data, &data->colorGrid, colorOBUItem, AVIF_FALSE)) {\n                return AVIF_RESULT_INVALID_IMAGE_GRID;\n            }\n            data->colorTileCount = data->tiles.count;\n        } else {\n            if (colorOBU.size == 0) {\n                return AVIF_RESULT_NO_AV1_ITEMS_FOUND;\n            }\n\n            avifTile * colorTile = avifDecoderDataCreateTile(decoder->data);\n            avifDecodeSample * colorSample = (avifDecodeSample *)avifArrayPushPtr(&colorTile->input->samples);\n            memcpy(&colorSample->data, &colorOBU, sizeof(avifROData));\n            colorSample->sync = AVIF_TRUE;\n            decoder->data->colorTileCount = 1;\n        }\n\n        if ((data->alphaGrid.rows > 0) && (data->alphaGrid.columns > 0) && alphaOBUItem) {\n            if (!avifDecoderDataGenerateImageGridTiles(data, &data->alphaGrid, alphaOBUItem, AVIF_FALSE)) {\n                return AVIF_RESULT_INVALID_IMAGE_GRID;\n            }\n            data->alphaTileCount = data->tiles.count - data->colorTileCount;\n        } else {\n            avifTile * alphaTile = NULL;\n            if (alphaOBU.size > 0) {\n                alphaTile = avifDecoderDataCreateTile(decoder->data);\n\n                avifDecodeSample * alphaSample = (avifDecodeSample *)avifArrayPushPtr(&alphaTile->input->samples);\n                memcpy(&alphaSample->data, &alphaOBU, sizeof(avifROData));\n                alphaSample->sync = AVIF_TRUE;\n                alphaTile->input->alpha = AVIF_TRUE;\n                decoder->data->alphaTileCount = 1;\n            }\n        }\n\n        // Set all counts and timing to safe-but-uninteresting values\n        decoder->imageIndex = -1;\n        decoder->imageCount = 1;\n        decoder->imageTiming.timescale = 1;\n        decoder->imageTiming.pts = 0;\n        decoder->imageTiming.ptsInTimescales = 0;\n        decoder->imageTiming.duration = 1;\n        decoder->imageTiming.durationInTimescales = 1;\n        decoder->timescale = 1;\n        decoder->duration = 1;\n        decoder->durationInTimescales = 1;\n\n        decoder->ioStats.colorOBUSize = colorOBU.size;\n        decoder->ioStats.alphaOBUSize = alphaOBU.size;\n\n        const avifProperty * ispeProp = avifPropertyArrayFind(colorProperties, \"ispe\");\n        if (ispeProp) {\n            decoder->image->width = ispeProp->u.ispe.width;\n            decoder->image->height = ispeProp->u.ispe.height;\n        } else {\n            decoder->image->width = 0;\n            decoder->image->height = 0;\n        }\n        decoder->alphaPresent = (alphaOBUItem != NULL);\n    }\n\n    // Sanity check tiles\n    for (uint32_t tileIndex = 0; tileIndex < data->tiles.count; ++tileIndex) {\n        avifTile * tile = &data->tiles.tile[tileIndex];\n        for (uint32_t sampleIndex = 0; sampleIndex < tile->input->samples.count; ++sampleIndex) {\n            avifDecodeSample * sample = &tile->input->samples.sample[sampleIndex];\n            if (!sample->data.data || !sample->data.size) {\n                // Every sample must have some data\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n    }\n\n    const avifProperty * colrProp = avifPropertyArrayFind(colorProperties, \"colr\");\n    if (colrProp) {\n        if (colrProp->u.colr.hasICC) {\n            avifImageSetProfileICC(decoder->image, colrProp->u.colr.icc, colrProp->u.colr.iccSize);\n        } else if (colrProp->u.colr.hasNCLX) {\n            data->cicpSet = AVIF_TRUE;\n            decoder->image->colorPrimaries = colrProp->u.colr.colorPrimaries;\n            decoder->image->transferCharacteristics = colrProp->u.colr.transferCharacteristics;\n            decoder->image->matrixCoefficients = colrProp->u.colr.matrixCoefficients;\n            decoder->image->yuvRange = colrProp->u.colr.range;\n        }\n    }\n\n    // Transformations\n    const avifProperty * paspProp = avifPropertyArrayFind(colorProperties, \"pasp\");\n    if (paspProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_PASP;\n        memcpy(&decoder->image->pasp, &paspProp->u.pasp, sizeof(avifPixelAspectRatioBox));\n    }\n    const avifProperty * clapProp = avifPropertyArrayFind(colorProperties, \"clap\");\n    if (clapProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_CLAP;\n        memcpy(&decoder->image->clap, &clapProp->u.clap, sizeof(avifCleanApertureBox));\n    }\n    const avifProperty * irotProp = avifPropertyArrayFind(colorProperties, \"irot\");\n    if (irotProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_IROT;\n        memcpy(&decoder->image->irot, &irotProp->u.irot, sizeof(avifImageRotation));\n    }\n    const avifProperty * imirProp = avifPropertyArrayFind(colorProperties, \"imir\");\n    if (imirProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_IMIR;\n        memcpy(&decoder->image->imir, &imirProp->u.imir, sizeof(avifImageMirror));\n    }\n\n    if (!decoder->data->cicpSet && (data->tiles.count > 0)) {\n        avifTile * firstTile = &data->tiles.tile[0];\n        if (firstTile->input->samples.count > 0) {\n            avifDecodeSample * sample = &firstTile->input->samples.sample[0];\n            avifSequenceHeader sequenceHeader;\n            if (avifSequenceHeaderParse(&sequenceHeader, &sample->data)) {\n                decoder->data->cicpSet = AVIF_TRUE;\n                decoder->image->colorPrimaries = sequenceHeader.colorPrimaries;\n                decoder->image->transferCharacteristics = sequenceHeader.transferCharacteristics;\n                decoder->image->matrixCoefficients = sequenceHeader.matrixCoefficients;\n                decoder->image->yuvRange = sequenceHeader.range;\n            }\n        }\n    }\n\n    const avifProperty * av1CProp = avifPropertyArrayFind(colorProperties, \"av1C\");\n    if (av1CProp) {\n        decoder->image->depth = avifCodecConfigurationBoxGetDepth(&av1CProp->u.av1C);\n        if (av1CProp->u.av1C.monochrome) {\n            decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV400;\n        } else {\n            if (av1CProp->u.av1C.chromaSubsamplingX && av1CProp->u.av1C.chromaSubsamplingY) {\n                decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV420;\n            } else if (av1CProp->u.av1C.chromaSubsamplingX) {\n                decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV422;\n\n            } else {\n                decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV444;\n            }\n        }\n        decoder->image->yuvChromaSamplePosition = (avifChromaSamplePosition)av1CProp->u.av1C.chromaSamplePosition;\n    } else {\n        // An av1C box is mandatory in all valid AVIF configurations. Bail out.\n        return AVIF_RESULT_BMFF_PARSE_FAILED;\n    }\n\n    return avifDecoderFlush(decoder);\n}\n\navifResult avifDecoderNextImage(avifDecoder * decoder)\n{\n    for (unsigned int tileIndex = 0; tileIndex < decoder->data->tiles.count; ++tileIndex) {\n        avifTile * tile = &decoder->data->tiles.tile[tileIndex];\n\n        if (!tile->codec->getNextImage(tile->codec, tile->image)) {\n            if (tile->input->alpha) {\n                return AVIF_RESULT_DECODE_ALPHA_FAILED;\n            } else {\n                if (tile->image->width) {\n                    // We've sent at least one image, but we've run out now.\n                    return AVIF_RESULT_NO_IMAGES_REMAINING;\n                }\n                return AVIF_RESULT_DECODE_COLOR_FAILED;\n            }\n        }\n    }\n\n    if (decoder->data->tiles.count != (decoder->data->colorTileCount + decoder->data->alphaTileCount)) {\n        // TODO: assert here? This should be impossible.\n        return AVIF_RESULT_UNKNOWN_ERROR;\n    }\n\n    if ((decoder->data->colorGrid.rows > 0) || (decoder->data->colorGrid.columns > 0)) {\n        if (!avifDecoderDataFillImageGrid(\n                decoder->data, &decoder->data->colorGrid, decoder->image, 0, decoder->data->colorTileCount, AVIF_FALSE)) {\n            return AVIF_RESULT_INVALID_IMAGE_GRID;\n        }\n    } else {\n        // Normal (most common) non-grid path. Just steal the planes from the only \"tile\".\n\n        if (decoder->data->colorTileCount != 1) {\n            return AVIF_RESULT_DECODE_COLOR_FAILED;\n        }\n\n        avifImage * srcColor = decoder->data->tiles.tile[0].image;\n\n        if ((decoder->image->width != srcColor->width) || (decoder->image->height != srcColor->height) ||\n            (decoder->image->depth != srcColor->depth)) {\n            avifImageFreePlanes(decoder->image, AVIF_PLANES_ALL);\n\n            decoder->image->width = srcColor->width;\n            decoder->image->height = srcColor->height;\n            decoder->image->depth = srcColor->depth;\n        }\n\n#if 0\n        // This code is currently unnecessary as the CICP is always set by the end of avifDecoderParse().\n        if (!decoder->data->cicpSet) {\n            decoder->data->cicpSet = AVIF_TRUE;\n            decoder->image->colorPrimaries = srcColor->colorPrimaries;\n            decoder->image->transferCharacteristics = srcColor->transferCharacteristics;\n            decoder->image->matrixCoefficients = srcColor->matrixCoefficients;\n        }\n#endif\n\n        avifImageStealPlanes(decoder->image, srcColor, AVIF_PLANES_YUV);\n    }\n\n    if ((decoder->data->alphaGrid.rows > 0) || (decoder->data->alphaGrid.columns > 0)) {\n        if (!avifDecoderDataFillImageGrid(\n                decoder->data, &decoder->data->alphaGrid, decoder->image, decoder->data->colorTileCount, decoder->data->alphaTileCount, AVIF_TRUE)) {\n            return AVIF_RESULT_INVALID_IMAGE_GRID;\n        }\n    } else {\n        // Normal (most common) non-grid path. Just steal the planes from the only \"tile\".\n\n        if (decoder->data->alphaTileCount == 0) {\n            avifImageFreePlanes(decoder->image, AVIF_PLANES_A); // no alpha\n        } else {\n            if (decoder->data->alphaTileCount != 1) {\n                return AVIF_RESULT_DECODE_ALPHA_FAILED;\n            }\n\n            avifImage * srcAlpha = decoder->data->tiles.tile[decoder->data->colorTileCount].image;\n            if ((decoder->image->width != srcAlpha->width) || (decoder->image->height != srcAlpha->height) ||\n                (decoder->image->depth != srcAlpha->depth)) {\n                return AVIF_RESULT_DECODE_ALPHA_FAILED;\n            }\n\n            avifImageStealPlanes(decoder->image, srcAlpha, AVIF_PLANES_A);\n        }\n    }\n\n    ++decoder->imageIndex;\n    if (decoder->data->sourceSampleTable) {\n        // Decoding from a track! Provide timing information.\n\n        avifResult timingResult = avifDecoderNthImageTiming(decoder, decoder->imageIndex, &decoder->imageTiming);\n        if (timingResult != AVIF_RESULT_OK) {\n            return timingResult;\n        }\n    }\n    return AVIF_RESULT_OK;\n}\n\navifResult avifDecoderNthImageTiming(const avifDecoder * decoder, uint32_t frameIndex, avifImageTiming * outTiming)\n{\n    if (!decoder->data) {\n        // Nothing has been parsed yet\n        return AVIF_RESULT_NO_CONTENT;\n    }\n\n    if ((int)frameIndex >= decoder->imageCount) {\n        // Impossible index\n        return AVIF_RESULT_NO_IMAGES_REMAINING;\n    }\n\n    if (!decoder->data->sourceSampleTable) {\n        // There isn't any real timing associated with this decode, so\n        // just hand back the defaults chosen in avifDecoderReset().\n        memcpy(outTiming, &decoder->imageTiming, sizeof(avifImageTiming));\n        return AVIF_RESULT_OK;\n    }\n\n    outTiming->timescale = decoder->timescale;\n    outTiming->ptsInTimescales = 0;\n    for (int imageIndex = 0; imageIndex < (int)frameIndex; ++imageIndex) {\n        outTiming->ptsInTimescales += avifSampleTableGetImageDelta(decoder->data->sourceSampleTable, imageIndex);\n    }\n    outTiming->durationInTimescales = avifSampleTableGetImageDelta(decoder->data->sourceSampleTable, frameIndex);\n\n    if (outTiming->timescale > 0) {\n        outTiming->pts = (double)outTiming->ptsInTimescales / (double)outTiming->timescale;\n        outTiming->duration = (double)outTiming->durationInTimescales / (double)outTiming->timescale;\n    } else {\n        outTiming->pts = 0.0;\n        outTiming->duration = 0.0;\n    }\n    return AVIF_RESULT_OK;\n}\n\navifResult avifDecoderNthImage(avifDecoder * decoder, uint32_t frameIndex)\n{\n    int requestedIndex = (int)frameIndex;\n    if (requestedIndex == decoder->imageIndex) {\n        // We're here already, nothing to do\n        return AVIF_RESULT_OK;\n    }\n\n    if (requestedIndex == (decoder->imageIndex + 1)) {\n        // it's just the next image, nothing special here\n        return avifDecoderNextImage(decoder);\n    }\n\n    if (requestedIndex >= decoder->imageCount) {\n        // Impossible index\n        return AVIF_RESULT_NO_IMAGES_REMAINING;\n    }\n\n    // If we get here, a decoder flush is necessary\n    decoder->imageIndex = ((int)avifDecoderNearestKeyframe(decoder, frameIndex)) - 1; // prepare to read nearest keyframe\n    avifDecoderFlush(decoder);\n    for (;;) {\n        avifResult result = avifDecoderNextImage(decoder);\n        if (result != AVIF_RESULT_OK) {\n            return result;\n        }\n\n        if (requestedIndex == decoder->imageIndex) {\n            break;\n        }\n    }\n    return AVIF_RESULT_OK;\n}\n\navifBool avifDecoderIsKeyframe(const avifDecoder * decoder, uint32_t frameIndex)\n{\n    if ((decoder->data->tiles.count > 0) && decoder->data->tiles.tile[0].input) {\n        if (frameIndex < decoder->data->tiles.tile[0].input->samples.count) {\n            return decoder->data->tiles.tile[0].input->samples.sample[frameIndex].sync;\n        }\n    }\n    return AVIF_FALSE;\n}\n\nuint32_t avifDecoderNearestKeyframe(const avifDecoder * decoder, uint32_t frameIndex)\n{\n    for (; frameIndex != 0; --frameIndex) {\n        if (avifDecoderIsKeyframe(decoder, frameIndex)) {\n            break;\n        }\n    }\n    return frameIndex;\n}\n\navifResult avifDecoderRead(avifDecoder * decoder, avifImage * image, const avifROData * input)\n{\n    avifResult result = avifDecoderParse(decoder, input);\n    if (result != AVIF_RESULT_OK) {\n        return result;\n    }\n    result = avifDecoderNextImage(decoder);\n    if (result != AVIF_RESULT_OK) {\n        return result;\n    }\n    avifImageCopy(image, decoder->image, AVIF_PLANES_ALL);\n    return AVIF_RESULT_OK;\n}\n"], "fixing_code": ["// Copyright 2019 Joe Drago. All rights reserved.\n// SPDX-License-Identifier: BSD-2-Clause\n\n#ifndef AVIF_INTERNAL_H\n#define AVIF_INTERNAL_H\n\n#include \"avif/avif.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Yes, clamp macros are nasty. Do not use them.\n#define AVIF_CLAMP(x, low, high) (((x) < (low))) ? (low) : (((high) < (x)) ? (high) : (x))\n#define AVIF_MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n// Used by stream related things.\n#define CHECK(A)               \\\n    do {                       \\\n        if (!(A))              \\\n            return AVIF_FALSE; \\\n    } while (0)\n\n// ---------------------------------------------------------------------------\n// URNs and Content-Types\n\n#define URN_ALPHA0 \"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\"\n#define URN_ALPHA1 \"urn:mpeg:hevc:2015:auxid:1\"\n\n#define CONTENT_TYPE_XMP \"application/rdf+xml\"\n\n// ---------------------------------------------------------------------------\n// Utils\n\nfloat avifRoundf(float v);\n\nuint16_t avifHTONS(uint16_t s);\nuint16_t avifNTOHS(uint16_t s);\nuint32_t avifHTONL(uint32_t l);\nuint32_t avifNTOHL(uint32_t l);\nuint64_t avifHTON64(uint64_t l);\nuint64_t avifNTOH64(uint64_t l);\n\nvoid avifCalcYUVCoefficients(const avifImage * image, float * outR, float * outG, float * outB);\n\n#define AVIF_ARRAY_DECLARE(TYPENAME, ITEMSTYPE, ITEMSNAME) \\\n    typedef struct TYPENAME                                \\\n    {                                                      \\\n        ITEMSTYPE * ITEMSNAME;                             \\\n        uint32_t elementSize;                              \\\n        uint32_t count;                                    \\\n        uint32_t capacity;                                 \\\n    } TYPENAME\nvoid avifArrayCreate(void * arrayStruct, uint32_t elementSize, uint32_t initialCapacity);\nuint32_t avifArrayPushIndex(void * arrayStruct);\nvoid * avifArrayPushPtr(void * arrayStruct);\nvoid avifArrayPush(void * arrayStruct, void * element);\nvoid avifArrayDestroy(void * arrayStruct);\n\nAVIF_ARRAY_DECLARE(avifRODataArray, avifROData, raw);\nAVIF_ARRAY_DECLARE(avifRWDataArray, avifRWData, raw);\n\ntypedef struct avifAlphaParams\n{\n    uint32_t width;\n    uint32_t height;\n\n    uint32_t srcDepth;\n    avifRange srcRange;\n    uint8_t * srcPlane;\n    uint32_t srcRowBytes;\n    uint32_t srcOffsetBytes;\n    uint32_t srcPixelBytes;\n\n    uint32_t dstDepth;\n    avifRange dstRange;\n    uint8_t * dstPlane;\n    uint32_t dstRowBytes;\n    uint32_t dstOffsetBytes;\n    uint32_t dstPixelBytes;\n\n} avifAlphaParams;\n\navifBool avifFillAlpha(const avifAlphaParams * const params);\navifBool avifReformatAlpha(const avifAlphaParams * const params);\n\n// ---------------------------------------------------------------------------\n// avifCodecDecodeInput\n\ntypedef struct avifDecodeSample\n{\n    avifROData data;\n    avifBool sync; // is sync sample (keyframe)\n} avifDecodeSample;\nAVIF_ARRAY_DECLARE(avifDecodeSampleArray, avifDecodeSample, sample);\n\ntypedef struct avifCodecDecodeInput\n{\n    avifDecodeSampleArray samples;\n    avifBool alpha; // if true, this is decoding an alpha plane\n} avifCodecDecodeInput;\n\navifCodecDecodeInput * avifCodecDecodeInputCreate(void);\nvoid avifCodecDecodeInputDestroy(avifCodecDecodeInput * decodeInput);\n\n// ---------------------------------------------------------------------------\n// avifCodecEncodeOutput\n\ntypedef struct avifEncodeSample\n{\n    avifRWData data;\n    avifBool sync; // is sync sample (keyframe)\n} avifEncodeSample;\nAVIF_ARRAY_DECLARE(avifEncodeSampleArray, avifEncodeSample, sample);\n\ntypedef struct avifCodecEncodeOutput\n{\n    avifEncodeSampleArray samples;\n} avifCodecEncodeOutput;\n\navifCodecEncodeOutput * avifCodecEncodeOutputCreate(void);\nvoid avifCodecEncodeOutputAddSample(avifCodecEncodeOutput * encodeOutput, const uint8_t * data, size_t len, avifBool sync);\nvoid avifCodecEncodeOutputDestroy(avifCodecEncodeOutput * encodeOutput);\n\n// ---------------------------------------------------------------------------\n// avifCodec (abstraction layer to use different AV1 implementations)\n\nstruct avifCodec;\nstruct avifCodecInternal;\n\ntypedef avifBool (*avifCodecOpenFunc)(struct avifCodec * codec, uint32_t firstSampleIndex);\ntypedef avifBool (*avifCodecGetNextImageFunc)(struct avifCodec * codec, avifImage * image);\n// EncodeImage and EncodeFinish are not required to always emit a sample, but when all images are\n// encoded and EncodeFinish is called, the number of samples emitted must match the number of submitted frames.\ntypedef avifBool (*avifCodecEncodeImageFunc)(struct avifCodec * codec,\n                                             avifEncoder * encoder,\n                                             const avifImage * image,\n                                             avifBool alpha,\n                                             uint32_t addImageFlags,\n                                             avifCodecEncodeOutput * output);\ntypedef avifBool (*avifCodecEncodeFinishFunc)(struct avifCodec * codec, avifCodecEncodeOutput * output);\ntypedef void (*avifCodecDestroyInternalFunc)(struct avifCodec * codec);\n\ntypedef struct avifCodec\n{\n    avifCodecDecodeInput * decodeInput;\n    avifCodecConfigurationBox configBox; // Pre-populated by avifEncoderWrite(), available and overridable by codec impls\n    struct avifCodecInternal * internal; // up to each codec to use how it wants\n\n    avifCodecOpenFunc open;\n    avifCodecGetNextImageFunc getNextImage;\n    avifCodecEncodeImageFunc encodeImage;\n    avifCodecEncodeFinishFunc encodeFinish;\n    avifCodecDestroyInternalFunc destroyInternal;\n} avifCodec;\n\navifCodec * avifCodecCreate(avifCodecChoice choice, uint32_t requiredFlags);\nvoid avifCodecDestroy(avifCodec * codec);\n\navifCodec * avifCodecCreateAOM(void);     // requires AVIF_CODEC_AOM (codec_aom.c)\nconst char * avifCodecVersionAOM(void);   // requires AVIF_CODEC_AOM (codec_aom.c)\navifCodec * avifCodecCreateDav1d(void);   // requires AVIF_CODEC_DAV1D (codec_dav1d.c)\nconst char * avifCodecVersionDav1d(void); // requires AVIF_CODEC_DAV1D (codec_dav1d.c)\navifCodec * avifCodecCreateGav1(void);    // requires AVIF_CODEC_LIBGAV1 (codec_libgav1.c)\nconst char * avifCodecVersionGav1(void);  // requires AVIF_CODEC_LIBGAV1 (codec_libgav1.c)\navifCodec * avifCodecCreateRav1e(void);   // requires AVIF_CODEC_RAV1E (codec_rav1e.c)\nconst char * avifCodecVersionRav1e(void); // requires AVIF_CODEC_RAV1E (codec_rav1e.c)\n\n// ---------------------------------------------------------------------------\n// avifStream\n\ntypedef size_t avifBoxMarker;\n\ntypedef struct avifBoxHeader\n{\n    size_t size;\n    uint8_t type[4];\n} avifBoxHeader;\n\ntypedef struct avifROStream\n{\n    avifROData * raw;\n    size_t offset;\n} avifROStream;\n\nconst uint8_t * avifROStreamCurrent(avifROStream * stream);\nvoid avifROStreamStart(avifROStream * stream, avifROData * raw);\nsize_t avifROStreamOffset(const avifROStream * stream);\nvoid avifROStreamSetOffset(avifROStream * stream, size_t offset);\n\navifBool avifROStreamHasBytesLeft(const avifROStream * stream, size_t byteCount);\nsize_t avifROStreamRemainingBytes(const avifROStream * stream);\navifBool avifROStreamSkip(avifROStream * stream, size_t byteCount);\navifBool avifROStreamRead(avifROStream * stream, uint8_t * data, size_t size);\navifBool avifROStreamReadU16(avifROStream * stream, uint16_t * v);\navifBool avifROStreamReadU32(avifROStream * stream, uint32_t * v);\navifBool avifROStreamReadUX8(avifROStream * stream, uint64_t * v, uint64_t factor); // Reads a factor*8 sized uint, saves in v\navifBool avifROStreamReadU64(avifROStream * stream, uint64_t * v);\navifBool avifROStreamReadString(avifROStream * stream, char * output, size_t outputSize);\navifBool avifROStreamReadBoxHeader(avifROStream * stream, avifBoxHeader * header);\navifBool avifROStreamReadVersionAndFlags(avifROStream * stream, uint8_t * version, uint32_t * flags); // version and flags ptrs are both optional\navifBool avifROStreamReadAndEnforceVersion(avifROStream * stream, uint8_t enforcedVersion); // currently discards flags\n\ntypedef struct avifRWStream\n{\n    avifRWData * raw;\n    size_t offset;\n} avifRWStream;\n\nuint8_t * avifRWStreamCurrent(avifRWStream * stream);\nvoid avifRWStreamStart(avifRWStream * stream, avifRWData * raw);\nsize_t avifRWStreamOffset(const avifRWStream * stream);\nvoid avifRWStreamSetOffset(avifRWStream * stream, size_t offset);\n\nvoid avifRWStreamFinishWrite(avifRWStream * stream);\nvoid avifRWStreamWrite(avifRWStream * stream, const void * data, size_t size);\nvoid avifRWStreamWriteChars(avifRWStream * stream, const char * chars, size_t size);\navifBoxMarker avifRWStreamWriteBox(avifRWStream * stream, const char * type, size_t contentSize);\navifBoxMarker avifRWStreamWriteFullBox(avifRWStream * stream, const char * type, size_t contentSize, int version, uint32_t flags);\nvoid avifRWStreamFinishBox(avifRWStream * stream, avifBoxMarker marker);\nvoid avifRWStreamWriteU8(avifRWStream * stream, uint8_t v);\nvoid avifRWStreamWriteU16(avifRWStream * stream, uint16_t v);\nvoid avifRWStreamWriteU32(avifRWStream * stream, uint32_t v);\nvoid avifRWStreamWriteU64(avifRWStream * stream, uint64_t v);\nvoid avifRWStreamWriteZeros(avifRWStream * stream, size_t byteCount);\n\n// This is to make it clear that the box size is currently unknown, and will be determined later (with a call to avifRWStreamFinishBox)\n#define AVIF_BOX_SIZE_TBD 0\n\ntypedef struct avifSequenceHeader\n{\n    uint32_t maxWidth;\n    uint32_t maxHeight;\n    uint32_t bitDepth;\n    avifPixelFormat yuvFormat;\n    avifChromaSamplePosition chromaSamplePosition;\n    avifColorPrimaries colorPrimaries;\n    avifTransferCharacteristics transferCharacteristics;\n    avifMatrixCoefficients matrixCoefficients;\n    avifRange range;\n} avifSequenceHeader;\navifBool avifSequenceHeaderParse(avifSequenceHeader * header, const avifROData * sample);\n\n// A maximum image size to avoid out-of-memory errors or integer overflow in\n// (32-bit) int or unsigned int arithmetic operations.\n#define AVIF_MAX_IMAGE_SIZE (16384 * 16384)\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif // ifndef AVIF_INTERNAL_H\n", "// Copyright 2019 Joe Drago. All rights reserved.\n// SPDX-License-Identifier: BSD-2-Clause\n\n#include \"avif/internal.h\"\n\n#include <string.h>\n\n#define AUXTYPE_SIZE 64\n#define CONTENTTYPE_SIZE 64\n\n// class VisualSampleEntry(codingname) extends SampleEntry(codingname) {\n//     unsigned int(16) pre_defined = 0;\n//     const unsigned int(16) reserved = 0;\n//     unsigned int(32)[3] pre_defined = 0;\n//     unsigned int(16) width;\n//     unsigned int(16) height;\n//     template unsigned int(32) horizresolution = 0x00480000; // 72 dpi\n//     template unsigned int(32) vertresolution = 0x00480000;  // 72 dpi\n//     const unsigned int(32) reserved = 0;\n//     template unsigned int(16) frame_count = 1;\n//     string[32] compressorname;\n//     template unsigned int(16) depth = 0x0018;\n//     int(16) pre_defined = -1;\n//     // other boxes from derived specifications\n//     CleanApertureBox clap;    // optional\n//     PixelAspectRatioBox pasp; // optional\n// }\nstatic const size_t VISUALSAMPLEENTRY_SIZE = 78;\n\nstatic const char xmpContentType[] = CONTENT_TYPE_XMP;\nstatic const size_t xmpContentTypeSize = sizeof(xmpContentType);\n\n// ---------------------------------------------------------------------------\n// Box data structures\n\n// ftyp\ntypedef struct avifFileType\n{\n    uint8_t majorBrand[4];\n    uint32_t minorVersion;\n    // If not null, points to a memory block of 4 * compatibleBrandsCount bytes.\n    const uint8_t * compatibleBrands;\n    int compatibleBrandsCount;\n} avifFileType;\n\n// ispe\ntypedef struct avifImageSpatialExtents\n{\n    uint32_t width;\n    uint32_t height;\n} avifImageSpatialExtents;\n\n// auxC\ntypedef struct avifAuxiliaryType\n{\n    char auxType[AUXTYPE_SIZE];\n} avifAuxiliaryType;\n\n// infe mime content_type\ntypedef struct avifContentType\n{\n    char contentType[CONTENTTYPE_SIZE];\n} avifContentType;\n\n// colr\ntypedef struct avifColourInformationBox\n{\n    avifBool hasICC;\n    const uint8_t * icc;\n    size_t iccSize;\n\n    avifBool hasNCLX;\n    avifColorPrimaries colorPrimaries;\n    avifTransferCharacteristics transferCharacteristics;\n    avifMatrixCoefficients matrixCoefficients;\n    avifRange range;\n} avifColourInformationBox;\n\n#define MAX_PIXI_PLANE_DEPTHS 4\ntypedef struct avifPixelInformationProperty\n{\n    uint8_t planeDepths[MAX_PIXI_PLANE_DEPTHS];\n    uint8_t planeCount;\n} avifPixelInformationProperty;\n\n// ---------------------------------------------------------------------------\n// Top-level structures\n\nstruct avifMeta;\n\n// Temporary storage for ipco/stsd contents until they can be associated and memcpy'd to an avifDecoderItem\ntypedef struct avifProperty\n{\n    uint8_t type[4];\n    union\n    {\n        avifImageSpatialExtents ispe;\n        avifAuxiliaryType auxC;\n        avifColourInformationBox colr;\n        avifCodecConfigurationBox av1C;\n        avifPixelAspectRatioBox pasp;\n        avifCleanApertureBox clap;\n        avifImageRotation irot;\n        avifImageMirror imir;\n        avifPixelInformationProperty pixi;\n    } u;\n} avifProperty;\nAVIF_ARRAY_DECLARE(avifPropertyArray, avifProperty, prop);\n\nstatic const avifProperty * avifPropertyArrayFind(const avifPropertyArray * properties, const char * type)\n{\n    for (uint32_t propertyIndex = 0; propertyIndex < properties->count; ++propertyIndex) {\n        avifProperty * prop = &properties->prop[propertyIndex];\n        if (!memcmp(prop->type, type, 4)) {\n            return prop;\n        }\n    }\n    return NULL;\n}\n\n// one \"item\" worth for decoding (all iref, iloc, iprp, etc refer to one of these)\ntypedef struct avifDecoderItem\n{\n    uint32_t id;\n    struct avifMeta * meta; // Unowned; A back-pointer for convenience\n    uint8_t type[4];\n    uint32_t offset;\n    uint32_t size;\n    uint32_t idatID; // If non-zero, offset is relative to this idat box (iloc construction_method==1)\n    avifContentType contentType;\n    avifPropertyArray properties;\n    uint32_t thumbnailForID; // if non-zero, this item is a thumbnail for Item #{thumbnailForID}\n    uint32_t auxForID;       // if non-zero, this item is an auxC plane for Item #{auxForID}\n    uint32_t descForID;      // if non-zero, this item is a content description for Item #{descForID}\n    uint32_t dimgForID;      // if non-zero, this item is a derived image for Item #{dimgForID}\n    avifBool hasUnsupportedEssentialProperty; // If true, this item cites a property flagged as 'essential' that libavif doesn't support (yet). Ignore the item, if so.\n} avifDecoderItem;\nAVIF_ARRAY_DECLARE(avifDecoderItemArray, avifDecoderItem, item);\n\n// idat storage\ntypedef struct avifDecoderItemData\n{\n    uint32_t id;\n    avifROData data;\n} avifDecoderItemData;\nAVIF_ARRAY_DECLARE(avifDecoderItemDataArray, avifDecoderItemData, idat);\n\n// grid storage\ntypedef struct avifImageGrid\n{\n    uint8_t rows;\n    uint8_t columns;\n    uint32_t outputWidth;\n    uint32_t outputHeight;\n} avifImageGrid;\n\n// ---------------------------------------------------------------------------\n// avifTrack\n\ntypedef struct avifSampleTableChunk\n{\n    uint64_t offset;\n} avifSampleTableChunk;\nAVIF_ARRAY_DECLARE(avifSampleTableChunkArray, avifSampleTableChunk, chunk);\n\ntypedef struct avifSampleTableSampleToChunk\n{\n    uint32_t firstChunk;\n    uint32_t samplesPerChunk;\n    uint32_t sampleDescriptionIndex;\n} avifSampleTableSampleToChunk;\nAVIF_ARRAY_DECLARE(avifSampleTableSampleToChunkArray, avifSampleTableSampleToChunk, sampleToChunk);\n\ntypedef struct avifSampleTableSampleSize\n{\n    uint32_t size;\n} avifSampleTableSampleSize;\nAVIF_ARRAY_DECLARE(avifSampleTableSampleSizeArray, avifSampleTableSampleSize, sampleSize);\n\ntypedef struct avifSampleTableTimeToSample\n{\n    uint32_t sampleCount;\n    uint32_t sampleDelta;\n} avifSampleTableTimeToSample;\nAVIF_ARRAY_DECLARE(avifSampleTableTimeToSampleArray, avifSampleTableTimeToSample, timeToSample);\n\ntypedef struct avifSyncSample\n{\n    uint32_t sampleNumber;\n} avifSyncSample;\nAVIF_ARRAY_DECLARE(avifSyncSampleArray, avifSyncSample, syncSample);\n\ntypedef struct avifSampleDescription\n{\n    uint8_t format[4];\n    avifPropertyArray properties;\n} avifSampleDescription;\nAVIF_ARRAY_DECLARE(avifSampleDescriptionArray, avifSampleDescription, description);\n\ntypedef struct avifSampleTable\n{\n    avifSampleTableChunkArray chunks;\n    avifSampleDescriptionArray sampleDescriptions;\n    avifSampleTableSampleToChunkArray sampleToChunks;\n    avifSampleTableSampleSizeArray sampleSizes;\n    avifSampleTableTimeToSampleArray timeToSamples;\n    avifSyncSampleArray syncSamples;\n    uint32_t allSamplesSize; // If this is non-zero, sampleSizes will be empty and all samples will be this size\n} avifSampleTable;\n\nstatic avifSampleTable * avifSampleTableCreate()\n{\n    avifSampleTable * sampleTable = (avifSampleTable *)avifAlloc(sizeof(avifSampleTable));\n    memset(sampleTable, 0, sizeof(avifSampleTable));\n    avifArrayCreate(&sampleTable->chunks, sizeof(avifSampleTableChunk), 16);\n    avifArrayCreate(&sampleTable->sampleDescriptions, sizeof(avifSampleDescription), 2);\n    avifArrayCreate(&sampleTable->sampleToChunks, sizeof(avifSampleTableSampleToChunk), 16);\n    avifArrayCreate(&sampleTable->sampleSizes, sizeof(avifSampleTableSampleSize), 16);\n    avifArrayCreate(&sampleTable->timeToSamples, sizeof(avifSampleTableTimeToSample), 16);\n    avifArrayCreate(&sampleTable->syncSamples, sizeof(avifSyncSample), 16);\n    return sampleTable;\n}\n\nstatic void avifSampleTableDestroy(avifSampleTable * sampleTable)\n{\n    avifArrayDestroy(&sampleTable->chunks);\n    for (uint32_t i = 0; i < sampleTable->sampleDescriptions.count; ++i) {\n        avifSampleDescription * description = &sampleTable->sampleDescriptions.description[i];\n        avifArrayDestroy(&description->properties);\n    }\n    avifArrayDestroy(&sampleTable->sampleDescriptions);\n    avifArrayDestroy(&sampleTable->sampleToChunks);\n    avifArrayDestroy(&sampleTable->sampleSizes);\n    avifArrayDestroy(&sampleTable->timeToSamples);\n    avifArrayDestroy(&sampleTable->syncSamples);\n    avifFree(sampleTable);\n}\n\nstatic uint32_t avifSampleTableGetImageDelta(const avifSampleTable * sampleTable, int imageIndex)\n{\n    int maxSampleIndex = 0;\n    for (uint32_t i = 0; i < sampleTable->timeToSamples.count; ++i) {\n        const avifSampleTableTimeToSample * timeToSample = &sampleTable->timeToSamples.timeToSample[i];\n        maxSampleIndex += timeToSample->sampleCount;\n        if ((imageIndex < maxSampleIndex) || (i == (sampleTable->timeToSamples.count - 1))) {\n            return timeToSample->sampleDelta;\n        }\n    }\n\n    // TODO: fail here?\n    return 1;\n}\n\nstatic avifBool avifSampleTableHasFormat(const avifSampleTable * sampleTable, const char * format)\n{\n    for (uint32_t i = 0; i < sampleTable->sampleDescriptions.count; ++i) {\n        if (!memcmp(sampleTable->sampleDescriptions.description[i].format, format, 4)) {\n            return AVIF_TRUE;\n        }\n    }\n    return AVIF_FALSE;\n}\n\nstatic uint32_t avifCodecConfigurationBoxGetDepth(const avifCodecConfigurationBox * av1C)\n{\n    if (av1C->twelveBit) {\n        return 12;\n    } else if (av1C->highBitdepth) {\n        return 10;\n    }\n    return 8;\n}\n\nstatic const avifPropertyArray * avifSampleTableGetProperties(const avifSampleTable * sampleTable)\n{\n    for (uint32_t i = 0; i < sampleTable->sampleDescriptions.count; ++i) {\n        const avifSampleDescription * description = &sampleTable->sampleDescriptions.description[i];\n        if (!memcmp(description->format, \"av01\", 4)) {\n            return &description->properties;\n        }\n    }\n    return NULL;\n}\n\n// one video track (\"trak\" contents)\ntypedef struct avifTrack\n{\n    uint32_t id;\n    uint32_t auxForID; // if non-zero, this item is an auxC plane for Track #{auxForID}\n    uint32_t mediaTimescale;\n    uint64_t mediaDuration;\n    uint32_t width;\n    uint32_t height;\n    avifSampleTable * sampleTable;\n    struct avifMeta * meta;\n} avifTrack;\nAVIF_ARRAY_DECLARE(avifTrackArray, avifTrack, track);\n\n// ---------------------------------------------------------------------------\n// avifCodecDecodeInput\n\navifCodecDecodeInput * avifCodecDecodeInputCreate(void)\n{\n    avifCodecDecodeInput * decodeInput = (avifCodecDecodeInput *)avifAlloc(sizeof(avifCodecDecodeInput));\n    memset(decodeInput, 0, sizeof(avifCodecDecodeInput));\n    avifArrayCreate(&decodeInput->samples, sizeof(avifDecodeSample), 1);\n    return decodeInput;\n}\n\nvoid avifCodecDecodeInputDestroy(avifCodecDecodeInput * decodeInput)\n{\n    avifArrayDestroy(&decodeInput->samples);\n    avifFree(decodeInput);\n}\n\nstatic avifBool avifCodecDecodeInputGetSamples(avifCodecDecodeInput * decodeInput, avifSampleTable * sampleTable, avifROData * rawInput)\n{\n    uint32_t sampleSizeIndex = 0;\n    for (uint32_t chunkIndex = 0; chunkIndex < sampleTable->chunks.count; ++chunkIndex) {\n        avifSampleTableChunk * chunk = &sampleTable->chunks.chunk[chunkIndex];\n\n        // First, figure out how many samples are in this chunk\n        uint32_t sampleCount = 0;\n        for (int sampleToChunkIndex = sampleTable->sampleToChunks.count - 1; sampleToChunkIndex >= 0; --sampleToChunkIndex) {\n            avifSampleTableSampleToChunk * sampleToChunk = &sampleTable->sampleToChunks.sampleToChunk[sampleToChunkIndex];\n            if (sampleToChunk->firstChunk <= (chunkIndex + 1)) {\n                sampleCount = sampleToChunk->samplesPerChunk;\n                break;\n            }\n        }\n        if (sampleCount == 0) {\n            // chunks with 0 samples are invalid\n            return AVIF_FALSE;\n        }\n\n        uint64_t sampleOffset = chunk->offset;\n        for (uint32_t sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n            uint32_t sampleSize = sampleTable->allSamplesSize;\n            if (sampleSize == 0) {\n                if (sampleSizeIndex >= sampleTable->sampleSizes.count) {\n                    // We've run out of samples to sum\n                    return AVIF_FALSE;\n                }\n                avifSampleTableSampleSize * sampleSizePtr = &sampleTable->sampleSizes.sampleSize[sampleSizeIndex];\n                sampleSize = sampleSizePtr->size;\n            }\n\n            avifDecodeSample * sample = (avifDecodeSample *)avifArrayPushPtr(&decodeInput->samples);\n            sample->data.data = rawInput->data + sampleOffset;\n            sample->data.size = sampleSize;\n            sample->sync = AVIF_FALSE; // to potentially be set to true following the outer loop\n\n            if ((sampleOffset + sampleSize) > (uint64_t)rawInput->size) {\n                return AVIF_FALSE;\n            }\n\n            sampleOffset += sampleSize;\n            ++sampleSizeIndex;\n        }\n    }\n\n    // Mark appropriate samples as sync\n    for (uint32_t syncSampleIndex = 0; syncSampleIndex < sampleTable->syncSamples.count; ++syncSampleIndex) {\n        uint32_t frameIndex = sampleTable->syncSamples.syncSample[syncSampleIndex].sampleNumber - 1; // sampleNumber is 1-based\n        if (frameIndex < decodeInput->samples.count) {\n            decodeInput->samples.sample[frameIndex].sync = AVIF_TRUE;\n        }\n    }\n\n    // Assume frame 0 is sync, just in case the stss box is absent in the BMFF. (Unnecessary?)\n    if (decodeInput->samples.count > 0) {\n        decodeInput->samples.sample[0].sync = AVIF_TRUE;\n    }\n    return AVIF_TRUE;\n}\n\n// ---------------------------------------------------------------------------\n// Helper macros\n\n#define BEGIN_STREAM(VARNAME, PTR, SIZE) \\\n    avifROStream VARNAME;                \\\n    avifROData VARNAME##_roData;         \\\n    VARNAME##_roData.data = PTR;         \\\n    VARNAME##_roData.size = SIZE;        \\\n    avifROStreamStart(&VARNAME, &VARNAME##_roData)\n\n// ---------------------------------------------------------------------------\n// avifDecoderData\n\ntypedef struct avifTile\n{\n    avifCodecDecodeInput * input;\n    struct avifCodec * codec;\n    avifImage * image;\n} avifTile;\nAVIF_ARRAY_DECLARE(avifTileArray, avifTile, tile);\n\n// This holds one \"meta\" box (from the BMFF and HEIF standards) worth of relevant-to-AVIF information.\n// * If a meta box is parsed from the root level of the BMFF, it can contain the information about\n//   \"items\" which might be color planes, alpha planes, or EXIF or XMP metadata.\n// * If a meta box is parsed from inside of a track (\"trak\") box, any metadata (EXIF/XMP) items inside\n//   of that box are implicitly associated with that track.\ntypedef struct avifMeta\n{\n    // Items (from HEIF) are the generic storage for any data that does not require timed processing\n    // (single image color planes, alpha planes, EXIF, XMP, etc). Each item has a unique integer ID >1,\n    // and is defined by a series of child boxes in a meta box:\n    //  * iloc - location:     byte offset to item data, item size in bytes\n    //  * iinf - information:  type of item (color planes, alpha plane, EXIF, XMP)\n    //  * ipco - properties:   dimensions, aspect ratio, image transformations, references to other items\n    //  * ipma - associations: Attaches an item in the properties list to a given item\n    //\n    // Items are lazily created in this array when any of the above boxes refer to one by a new (unseen) ID,\n    // and are then further modified/updated as new information for an item's ID is parsed.\n    avifDecoderItemArray items;\n\n    // Any ipco boxes explained above are populated into this array as a staging area, which are\n    // then duplicated into the appropriate items upon encountering an item property association\n    // (ipma) box.\n    avifPropertyArray properties;\n\n    // Filled with the contents of \"idat\" boxes, which are raw data that an item can directly refer to in its\n    // item location box (iloc) instead of just giving an offset into the overall file. If all items' iloc boxes\n    // simply point at an offset/length in the file itself, this array will likely be empty.\n    avifDecoderItemDataArray idats;\n\n    // Ever-incrementing ID for uniquely identifying which 'meta' box contains an idat (when\n    // multiple meta boxes exist as BMFF siblings). Each time avifParseMetaBox() is called on an\n    // avifMeta struct, this value is incremented. Any time an additional meta box is detected at\n    // the same \"level\" (root level, trak level, etc), this ID helps distinguish which meta box's\n    // \"idat\" is which, as items implicitly reference idat boxes that exist in the same meta\n    // box.\n    uint32_t idatID;\n\n    // Contents of a pitm box, which signal which of the items in this file is the main image. For\n    // AVIF, this should point at an av01 type item containing color planes, and all other items\n    // are ignored unless they refer to this item in some way (alpha plane, EXIF/XMP metadata).\n    uint32_t primaryItemID;\n} avifMeta;\n\nstatic avifMeta * avifMetaCreate()\n{\n    avifMeta * meta = (avifMeta *)avifAlloc(sizeof(avifMeta));\n    memset(meta, 0, sizeof(avifMeta));\n    avifArrayCreate(&meta->items, sizeof(avifDecoderItem), 8);\n    avifArrayCreate(&meta->properties, sizeof(avifProperty), 16);\n    avifArrayCreate(&meta->idats, sizeof(avifDecoderItemData), 1);\n    return meta;\n}\n\nstatic void avifMetaDestroy(avifMeta * meta)\n{\n    for (uint32_t i = 0; i < meta->items.count; ++i) {\n        avifDecoderItem * item = &meta->items.item[i];\n        avifArrayDestroy(&item->properties);\n    }\n    avifArrayDestroy(&meta->items);\n    avifArrayDestroy(&meta->properties);\n    avifArrayDestroy(&meta->idats);\n    avifFree(meta);\n}\n\nstatic avifDecoderItem * avifMetaFindItem(avifMeta * meta, uint32_t itemID)\n{\n    if (itemID == 0) {\n        return NULL;\n    }\n\n    for (uint32_t i = 0; i < meta->items.count; ++i) {\n        if (meta->items.item[i].id == itemID) {\n            return &meta->items.item[i];\n        }\n    }\n\n    avifDecoderItem * item = (avifDecoderItem *)avifArrayPushPtr(&meta->items);\n    avifArrayCreate(&item->properties, sizeof(avifProperty), 16);\n    item->id = itemID;\n    item->meta = meta;\n    return item;\n}\n\ntypedef struct avifDecoderData\n{\n    avifFileType ftyp;\n    avifMeta * meta; // The root-level meta box\n    avifTrackArray tracks;\n    avifROData rawInput;\n    avifTileArray tiles;\n    unsigned int colorTileCount;\n    unsigned int alphaTileCount;\n    avifImageGrid colorGrid;\n    avifImageGrid alphaGrid;\n    avifDecoderSource source;\n    const avifSampleTable * sourceSampleTable; // NULL unless (source == AVIF_DECODER_SOURCE_TRACKS), owned by an avifTrack\n    avifBool cicpSet;                          // True if avifDecoder's image has had its CICP set correctly yet.\n                                               // This allows nclx colr boxes to override AV1 CICP, as specified in the MIAF\n                                               // standard (ISO/IEC 23000-22:2019), section 7.3.6.4:\n                                               //\n    // \"The colour information property takes precedence over any colour information in the image\n    // bitstream, i.e. if the property is present, colour information in the bitstream shall be ignored.\"\n} avifDecoderData;\n\nstatic avifDecoderData * avifDecoderDataCreate()\n{\n    avifDecoderData * data = (avifDecoderData *)avifAlloc(sizeof(avifDecoderData));\n    memset(data, 0, sizeof(avifDecoderData));\n    data->meta = avifMetaCreate();\n    avifArrayCreate(&data->tracks, sizeof(avifTrack), 2);\n    avifArrayCreate(&data->tiles, sizeof(avifTile), 8);\n    return data;\n}\n\nstatic void avifDecoderDataResetCodec(avifDecoderData * data)\n{\n    for (unsigned int i = 0; i < data->tiles.count; ++i) {\n        avifTile * tile = &data->tiles.tile[i];\n        if (tile->image) {\n            avifImageFreePlanes(tile->image, AVIF_PLANES_ALL); // forget any pointers into codec image buffers\n        }\n        if (tile->codec) {\n            avifCodecDestroy(tile->codec);\n            tile->codec = NULL;\n        }\n    }\n}\n\nstatic avifTile * avifDecoderDataCreateTile(avifDecoderData * data)\n{\n    avifTile * tile = (avifTile *)avifArrayPushPtr(&data->tiles);\n    tile->image = avifImageCreateEmpty();\n    tile->input = avifCodecDecodeInputCreate();\n    return tile;\n}\n\nstatic avifTrack * avifDecoderDataCreateTrack(avifDecoderData * data)\n{\n    avifTrack * track = (avifTrack *)avifArrayPushPtr(&data->tracks);\n    track->meta = avifMetaCreate();\n    return track;\n}\n\nstatic void avifDecoderDataClearTiles(avifDecoderData * data)\n{\n    for (unsigned int i = 0; i < data->tiles.count; ++i) {\n        avifTile * tile = &data->tiles.tile[i];\n        if (tile->input) {\n            avifCodecDecodeInputDestroy(tile->input);\n            tile->input = NULL;\n        }\n        if (tile->codec) {\n            avifCodecDestroy(tile->codec);\n            tile->codec = NULL;\n        }\n        if (tile->image) {\n            avifImageDestroy(tile->image);\n            tile->image = NULL;\n        }\n    }\n    data->tiles.count = 0;\n    data->colorTileCount = 0;\n    data->alphaTileCount = 0;\n}\n\nstatic void avifDecoderDataDestroy(avifDecoderData * data)\n{\n    avifMetaDestroy(data->meta);\n    for (uint32_t i = 0; i < data->tracks.count; ++i) {\n        avifTrack * track = &data->tracks.track[i];\n        if (track->sampleTable) {\n            avifSampleTableDestroy(track->sampleTable);\n        }\n        if (track->meta) {\n            avifMetaDestroy(track->meta);\n        }\n    }\n    avifArrayDestroy(&data->tracks);\n    avifDecoderDataClearTiles(data);\n    avifArrayDestroy(&data->tiles);\n    avifFree(data);\n}\n\nstatic const uint8_t * avifDecoderDataCalcItemPtr(avifDecoderData * data, avifDecoderItem * item)\n{\n    avifROData * offsetBuffer = NULL;\n    if (item->idatID == 0) {\n        // construction_method: file(0)\n\n        offsetBuffer = &data->rawInput;\n    } else {\n        // construction_method: idat(1)\n\n        // Find associated idat block\n        for (uint32_t i = 0; i < item->meta->idats.count; ++i) {\n            if (item->meta->idats.idat[i].id == item->idatID) {\n                offsetBuffer = &item->meta->idats.idat[i].data;\n                break;\n            }\n        }\n\n        if (offsetBuffer == NULL) {\n            // no idat box was found in this meta box, bail out\n            return NULL;\n        }\n    }\n\n    if (item->offset > offsetBuffer->size) {\n        return NULL;\n    }\n    uint64_t offsetSize = (uint64_t)item->offset + (uint64_t)item->size;\n    if (offsetSize > (uint64_t)offsetBuffer->size) {\n        return NULL;\n    }\n    return offsetBuffer->data + item->offset;\n}\n\nstatic avifBool avifDecoderDataGenerateImageGridTiles(avifDecoderData * data, avifImageGrid * grid, avifDecoderItem * gridItem, avifBool alpha)\n{\n    unsigned int tilesRequested = (unsigned int)grid->rows * (unsigned int)grid->columns;\n\n    // Count number of dimg for this item, bail out if it doesn't match perfectly\n    unsigned int tilesAvailable = 0;\n    for (uint32_t i = 0; i < gridItem->meta->items.count; ++i) {\n        avifDecoderItem * item = &gridItem->meta->items.item[i];\n        if (item->dimgForID == gridItem->id) {\n            if (memcmp(item->type, \"av01\", 4)) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n\n            ++tilesAvailable;\n        }\n    }\n\n    if (tilesRequested != tilesAvailable) {\n        return AVIF_FALSE;\n    }\n\n    avifBool firstTile = AVIF_TRUE;\n    for (uint32_t i = 0; i < gridItem->meta->items.count; ++i) {\n        avifDecoderItem * item = &gridItem->meta->items.item[i];\n        if (item->dimgForID == gridItem->id) {\n            if (memcmp(item->type, \"av01\", 4)) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n\n            avifTile * tile = avifDecoderDataCreateTile(data);\n            avifDecodeSample * sample = (avifDecodeSample *)avifArrayPushPtr(&tile->input->samples);\n            sample->data.data = avifDecoderDataCalcItemPtr(data, item);\n            sample->data.size = item->size;\n            sample->sync = AVIF_TRUE;\n            tile->input->alpha = alpha;\n\n            if (firstTile) {\n                firstTile = AVIF_FALSE;\n\n                // Adopt the av1C property of the first av01 tile, so that it can be queried from\n                // the top-level color/alpha item during avifDecoderReset().\n                const avifProperty * srcProp = avifPropertyArrayFind(&item->properties, \"av1C\");\n                if (!srcProp) {\n                    return AVIF_FALSE;\n                }\n                avifProperty * dstProp = (avifProperty *)avifArrayPushPtr(&gridItem->properties);\n                memcpy(dstProp, srcProp, sizeof(avifProperty));\n            }\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifDecoderDataFillImageGrid(avifDecoderData * data,\n                                             avifImageGrid * grid,\n                                             avifImage * dstImage,\n                                             unsigned int firstTileIndex,\n                                             unsigned int tileCount,\n                                             avifBool alpha)\n{\n    if (tileCount == 0) {\n        return AVIF_FALSE;\n    }\n\n    avifTile * firstTile = &data->tiles.tile[firstTileIndex];\n    avifBool firstTileUVPresent = (firstTile->image->yuvPlanes[AVIF_CHAN_U] && firstTile->image->yuvPlanes[AVIF_CHAN_V]);\n\n    // Check for tile consistency: All tiles in a grid image should match in the properties checked below.\n    for (unsigned int i = 1; i < tileCount; ++i) {\n        avifTile * tile = &data->tiles.tile[firstTileIndex + i];\n        avifBool uvPresent = (tile->image->yuvPlanes[AVIF_CHAN_U] && tile->image->yuvPlanes[AVIF_CHAN_V]);\n        if ((tile->image->width != firstTile->image->width) || (tile->image->height != firstTile->image->height) ||\n            (tile->image->depth != firstTile->image->depth) || (tile->image->yuvFormat != firstTile->image->yuvFormat) ||\n            (tile->image->yuvRange != firstTile->image->yuvRange) || (uvPresent != firstTileUVPresent) ||\n            ((tile->image->colorPrimaries != firstTile->image->colorPrimaries) ||\n             (tile->image->transferCharacteristics != firstTile->image->transferCharacteristics) ||\n             (tile->image->matrixCoefficients != firstTile->image->matrixCoefficients))) {\n            return AVIF_FALSE;\n        }\n    }\n\n    // Lazily populate dstImage with the new frame's properties. If we're decoding alpha,\n    // these values must already match.\n    if ((dstImage->width != grid->outputWidth) || (dstImage->height != grid->outputHeight) ||\n        (dstImage->depth != firstTile->image->depth) || (dstImage->yuvFormat != firstTile->image->yuvFormat)) {\n        if (alpha) {\n            // Alpha doesn't match size, just bail out\n            return AVIF_FALSE;\n        }\n\n        avifImageFreePlanes(dstImage, AVIF_PLANES_ALL);\n        dstImage->width = grid->outputWidth;\n        dstImage->height = grid->outputHeight;\n        dstImage->depth = firstTile->image->depth;\n        dstImage->yuvFormat = firstTile->image->yuvFormat;\n        dstImage->yuvRange = firstTile->image->yuvRange;\n        if (!data->cicpSet) {\n            data->cicpSet = AVIF_TRUE;\n            dstImage->colorPrimaries = firstTile->image->colorPrimaries;\n            dstImage->transferCharacteristics = firstTile->image->transferCharacteristics;\n            dstImage->matrixCoefficients = firstTile->image->matrixCoefficients;\n        }\n    }\n    if (alpha) {\n        dstImage->alphaRange = firstTile->image->alphaRange;\n    }\n\n    avifImageAllocatePlanes(dstImage, alpha ? AVIF_PLANES_A : AVIF_PLANES_YUV);\n\n    avifPixelFormatInfo formatInfo;\n    avifGetPixelFormatInfo(firstTile->image->yuvFormat, &formatInfo);\n\n    unsigned int tileIndex = firstTileIndex;\n    size_t pixelBytes = avifImageUsesU16(dstImage) ? 2 : 1;\n    for (unsigned int rowIndex = 0; rowIndex < grid->rows; ++rowIndex) {\n        for (unsigned int colIndex = 0; colIndex < grid->columns; ++colIndex, ++tileIndex) {\n            avifTile * tile = &data->tiles.tile[tileIndex];\n\n            unsigned int widthToCopy = firstTile->image->width;\n            unsigned int maxX = firstTile->image->width * (colIndex + 1);\n            if (maxX > grid->outputWidth) {\n                widthToCopy -= maxX - grid->outputWidth;\n            }\n\n            unsigned int heightToCopy = firstTile->image->height;\n            unsigned int maxY = firstTile->image->height * (rowIndex + 1);\n            if (maxY > grid->outputHeight) {\n                heightToCopy -= maxY - grid->outputHeight;\n            }\n\n            // Y and A channels\n            size_t yaColOffset = colIndex * firstTile->image->width;\n            size_t yaRowOffset = rowIndex * firstTile->image->height;\n            size_t yaRowBytes = widthToCopy * pixelBytes;\n\n            if (alpha) {\n                // A\n                for (unsigned int j = 0; j < heightToCopy; ++j) {\n                    uint8_t * src = &tile->image->alphaPlane[j * tile->image->alphaRowBytes];\n                    uint8_t * dst = &dstImage->alphaPlane[(yaColOffset * pixelBytes) + ((yaRowOffset + j) * dstImage->alphaRowBytes)];\n                    memcpy(dst, src, yaRowBytes);\n                }\n            } else {\n                // Y\n                for (unsigned int j = 0; j < heightToCopy; ++j) {\n                    uint8_t * src = &tile->image->yuvPlanes[AVIF_CHAN_Y][j * tile->image->yuvRowBytes[AVIF_CHAN_Y]];\n                    uint8_t * dst =\n                        &dstImage->yuvPlanes[AVIF_CHAN_Y][(yaColOffset * pixelBytes) + ((yaRowOffset + j) * dstImage->yuvRowBytes[AVIF_CHAN_Y])];\n                    memcpy(dst, src, yaRowBytes);\n                }\n\n                if (!firstTileUVPresent) {\n                    continue;\n                }\n\n                // UV\n                heightToCopy >>= formatInfo.chromaShiftY;\n                size_t uvColOffset = yaColOffset >> formatInfo.chromaShiftX;\n                size_t uvRowOffset = yaRowOffset >> formatInfo.chromaShiftY;\n                size_t uvRowBytes = yaRowBytes >> formatInfo.chromaShiftX;\n                for (unsigned int j = 0; j < heightToCopy; ++j) {\n                    uint8_t * srcU = &tile->image->yuvPlanes[AVIF_CHAN_U][j * tile->image->yuvRowBytes[AVIF_CHAN_U]];\n                    uint8_t * dstU =\n                        &dstImage->yuvPlanes[AVIF_CHAN_U][(uvColOffset * pixelBytes) + ((uvRowOffset + j) * dstImage->yuvRowBytes[AVIF_CHAN_U])];\n                    memcpy(dstU, srcU, uvRowBytes);\n\n                    uint8_t * srcV = &tile->image->yuvPlanes[AVIF_CHAN_V][j * tile->image->yuvRowBytes[AVIF_CHAN_V]];\n                    uint8_t * dstV =\n                        &dstImage->yuvPlanes[AVIF_CHAN_V][(uvColOffset * pixelBytes) + ((uvRowOffset + j) * dstImage->yuvRowBytes[AVIF_CHAN_V])];\n                    memcpy(dstV, srcV, uvRowBytes);\n                }\n            }\n        }\n    }\n\n    return AVIF_TRUE;\n}\n\n// If colorId == 0 (a sentinel value as item IDs must be nonzero), accept any found EXIF/XMP metadata. Passing in 0\n// is used when finding metadata in a meta box embedded in a trak box, as any items inside of a meta box that is\n// inside of a trak box are implicitly associated to the track.\nstatic avifBool avifDecoderDataFindMetadata(avifDecoderData * data, avifMeta * meta, avifImage * image, uint32_t colorId)\n{\n    avifROData exifData = AVIF_DATA_EMPTY;\n    avifROData xmpData = AVIF_DATA_EMPTY;\n\n    for (uint32_t itemIndex = 0; itemIndex < meta->items.count; ++itemIndex) {\n        avifDecoderItem * item = &meta->items.item[itemIndex];\n        if (!item->size) {\n            continue;\n        }\n        if (item->hasUnsupportedEssentialProperty) {\n            // An essential property isn't supported by libavif; ignore the item.\n            continue;\n        }\n\n        if ((colorId > 0) && (item->descForID != colorId)) {\n            // Not a content description (metadata) for the colorOBU, skip it\n            continue;\n        }\n\n        if (!memcmp(item->type, \"Exif\", 4)) {\n            // Advance past Annex A.2.1's header\n            const uint8_t * boxPtr = avifDecoderDataCalcItemPtr(data, item);\n            BEGIN_STREAM(exifBoxStream, boxPtr, item->size);\n            uint32_t exifTiffHeaderOffset;\n            CHECK(avifROStreamReadU32(&exifBoxStream, &exifTiffHeaderOffset)); // unsigned int(32) exif_tiff_header_offset;\n\n            exifData.data = avifROStreamCurrent(&exifBoxStream);\n            exifData.size = avifROStreamRemainingBytes(&exifBoxStream);\n        } else if (!memcmp(item->type, \"mime\", 4) && !memcmp(item->contentType.contentType, xmpContentType, xmpContentTypeSize)) {\n            xmpData.data = avifDecoderDataCalcItemPtr(data, item);\n            xmpData.size = item->size;\n        }\n    }\n\n    if (exifData.data && exifData.size) {\n        avifImageSetMetadataExif(image, exifData.data, exifData.size);\n    }\n    if (xmpData.data && xmpData.size) {\n        avifImageSetMetadataXMP(image, xmpData.data, xmpData.size);\n    }\n    return AVIF_TRUE;\n}\n\n// ---------------------------------------------------------------------------\n// URN\n\nstatic avifBool isAlphaURN(const char * urn)\n{\n    return !strcmp(urn, URN_ALPHA0) || !strcmp(urn, URN_ALPHA1);\n}\n\n// ---------------------------------------------------------------------------\n// BMFF Parsing\n\nstatic avifBool avifParseItemLocationBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n    if (version > 2) {\n        return AVIF_FALSE;\n    }\n\n    uint8_t offsetSizeAndLengthSize;\n    CHECK(avifROStreamRead(&s, &offsetSizeAndLengthSize, 1));\n    uint8_t offsetSize = (offsetSizeAndLengthSize >> 4) & 0xf; // unsigned int(4) offset_size;\n    uint8_t lengthSize = (offsetSizeAndLengthSize >> 0) & 0xf; // unsigned int(4) length_size;\n\n    uint8_t baseOffsetSizeAndIndexSize;\n    CHECK(avifROStreamRead(&s, &baseOffsetSizeAndIndexSize, 1));\n    uint8_t baseOffsetSize = (baseOffsetSizeAndIndexSize >> 4) & 0xf; // unsigned int(4) base_offset_size;\n    uint8_t indexSize = 0;\n    if ((version == 1) || (version == 2)) {\n        indexSize = baseOffsetSizeAndIndexSize & 0xf; // unsigned int(4) index_size;\n        if (indexSize != 0) {\n            // extent_index unsupported\n            return AVIF_FALSE;\n        }\n    }\n\n    uint16_t tmp16;\n    uint32_t itemCount;\n    if (version < 2) {\n        CHECK(avifROStreamReadU16(&s, &tmp16)); // unsigned int(16) item_count;\n        itemCount = tmp16;\n    } else {\n        CHECK(avifROStreamReadU32(&s, &itemCount)); // unsigned int(32) item_count;\n    }\n    for (uint32_t i = 0; i < itemCount; ++i) {\n        uint32_t itemID;\n        uint32_t idatID = 0;\n        if (version < 2) {\n            CHECK(avifROStreamReadU16(&s, &tmp16)); // unsigned int(16) item_ID;\n            itemID = tmp16;\n        } else {\n            CHECK(avifROStreamReadU32(&s, &itemID)); // unsigned int(32) item_ID;\n        }\n\n        if ((version == 1) || (version == 2)) {\n            uint8_t ignored;\n            uint8_t constructionMethod;\n            CHECK(avifROStreamRead(&s, &ignored, 1));            // unsigned int(12) reserved = 0;\n            CHECK(avifROStreamRead(&s, &constructionMethod, 1)); // unsigned int(4) construction_method;\n            constructionMethod = constructionMethod & 0xf;\n            if ((constructionMethod != 0 /* file */) && (constructionMethod != 1 /* idat */)) {\n                // construction method item(2) unsupported\n                return AVIF_FALSE;\n            }\n            if (constructionMethod == 1) {\n                idatID = meta->idatID;\n            }\n        }\n\n        uint16_t dataReferenceIndex;                                 // unsigned int(16) data_ref rence_index;\n        CHECK(avifROStreamReadU16(&s, &dataReferenceIndex));         //\n        uint64_t baseOffset;                                         // unsigned int(base_offset_size*8) base_offset;\n        CHECK(avifROStreamReadUX8(&s, &baseOffset, baseOffsetSize)); //\n        uint16_t extentCount;                                        // unsigned int(16) extent_count;\n        CHECK(avifROStreamReadU16(&s, &extentCount));                //\n        if (extentCount == 1) {\n            // If extent_index is ever supported, this spec must be implemented here:\n            // ::  if (((version == 1) || (version == 2)) && (index_size > 0)) {\n            // ::      unsigned int(index_size*8) extent_index;\n            // ::  }\n\n            uint64_t extentOffset; // unsigned int(offset_size*8) extent_offset;\n            CHECK(avifROStreamReadUX8(&s, &extentOffset, offsetSize));\n            uint64_t extentLength; // unsigned int(offset_size*8) extent_length;\n            CHECK(avifROStreamReadUX8(&s, &extentLength, lengthSize));\n\n            avifDecoderItem * item = avifMetaFindItem(meta, itemID);\n            if (!item) {\n                return AVIF_FALSE;\n            }\n            item->id = itemID;\n            item->offset = (uint32_t)(baseOffset + extentOffset);\n            item->size = (uint32_t)extentLength;\n            item->idatID = idatID;\n        } else {\n            // TODO: support more than one extent\n            return AVIF_FALSE;\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); // unsigned int(8) version = 0;\n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         // unsigned int(8) flags;\n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    // unsigned int(8) rows_minus_one;\n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); // unsigned int(8) columns_minus_one;\n    ++grid->rows;\n    ++grid->columns;\n\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  // unsigned int(FieldLength) output_width;\n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); // unsigned int(FieldLength) output_height;\n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            // This should be impossible\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;\n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;\n    }\n    if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageSpatialExtentsProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    avifImageSpatialExtents * ispe = &prop->u.ispe;\n    CHECK(avifROStreamReadU32(&s, &ispe->width));\n    CHECK(avifROStreamReadU32(&s, &ispe->height));\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseAuxiliaryTypeProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    CHECK(avifROStreamReadString(&s, prop->u.auxC.auxType, AUXTYPE_SIZE));\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseColourInformationBox(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifColourInformationBox * colr = &prop->u.colr;\n    colr->hasICC = AVIF_FALSE;\n    colr->hasNCLX = AVIF_FALSE;\n\n    uint8_t colorType[4]; // unsigned int(32) colour_type;\n    CHECK(avifROStreamRead(&s, colorType, 4));\n    if (!memcmp(colorType, \"rICC\", 4) || !memcmp(colorType, \"prof\", 4)) {\n        colr->hasICC = AVIF_TRUE;\n        colr->icc = avifROStreamCurrent(&s);\n        colr->iccSize = avifROStreamRemainingBytes(&s);\n    } else if (!memcmp(colorType, \"nclx\", 4)) {\n        uint16_t tmp16;\n        // unsigned int(16) colour_primaries;\n        CHECK(avifROStreamReadU16(&s, &tmp16));\n        colr->colorPrimaries = (avifColorPrimaries)tmp16;\n        // unsigned int(16) transfer_characteristics;\n        CHECK(avifROStreamReadU16(&s, &tmp16));\n        colr->transferCharacteristics = (avifTransferCharacteristics)tmp16;\n        // unsigned int(16) matrix_coefficients;\n        CHECK(avifROStreamReadU16(&s, &tmp16));\n        colr->matrixCoefficients = (avifMatrixCoefficients)tmp16;\n        // unsigned int(1) full_range_flag;\n        // unsigned int(7) reserved = 0;\n        uint8_t tmp8;\n        CHECK(avifROStreamRead(&s, &tmp8, 1));\n        colr->range = (tmp8 & 0x80) ? AVIF_RANGE_FULL : AVIF_RANGE_LIMITED;\n        colr->hasNCLX = AVIF_TRUE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseAV1CodecConfigurationBox(const uint8_t * raw, size_t rawLen, avifCodecConfigurationBox * av1C)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t markerAndVersion = 0;\n    CHECK(avifROStreamRead(&s, &markerAndVersion, 1));\n    uint8_t seqProfileAndIndex = 0;\n    CHECK(avifROStreamRead(&s, &seqProfileAndIndex, 1));\n    uint8_t rawFlags = 0;\n    CHECK(avifROStreamRead(&s, &rawFlags, 1));\n\n    if (markerAndVersion != 0x81) {\n        // Marker and version must both == 1\n        return AVIF_FALSE;\n    }\n\n    av1C->seqProfile = (seqProfileAndIndex >> 5) & 0x7;    // unsigned int (3) seq_profile;\n    av1C->seqLevelIdx0 = (seqProfileAndIndex >> 0) & 0x1f; // unsigned int (5) seq_level_idx_0;\n    av1C->seqTier0 = (rawFlags >> 7) & 0x1;                // unsigned int (1) seq_tier_0;\n    av1C->highBitdepth = (rawFlags >> 6) & 0x1;            // unsigned int (1) high_bitdepth;\n    av1C->twelveBit = (rawFlags >> 5) & 0x1;               // unsigned int (1) twelve_bit;\n    av1C->monochrome = (rawFlags >> 4) & 0x1;              // unsigned int (1) monochrome;\n    av1C->chromaSubsamplingX = (rawFlags >> 3) & 0x1;      // unsigned int (1) chroma_subsampling_x;\n    av1C->chromaSubsamplingY = (rawFlags >> 2) & 0x1;      // unsigned int (1) chroma_subsampling_y;\n    av1C->chromaSamplePosition = (rawFlags >> 0) & 0x3;    // unsigned int (2) chroma_sample_position;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseAV1CodecConfigurationBoxProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    return avifParseAV1CodecConfigurationBox(raw, rawLen, &prop->u.av1C);\n}\n\nstatic avifBool avifParsePixelAspectRatioBoxProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifPixelAspectRatioBox * pasp = &prop->u.pasp;\n    CHECK(avifROStreamReadU32(&s, &pasp->hSpacing)); // unsigned int(32) hSpacing;\n    CHECK(avifROStreamReadU32(&s, &pasp->vSpacing)); // unsigned int(32) vSpacing;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseCleanApertureBoxProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifCleanApertureBox * clap = &prop->u.clap;\n    CHECK(avifROStreamReadU32(&s, &clap->widthN));    // unsigned int(32) cleanApertureWidthN;\n    CHECK(avifROStreamReadU32(&s, &clap->widthD));    // unsigned int(32) cleanApertureWidthD;\n    CHECK(avifROStreamReadU32(&s, &clap->heightN));   // unsigned int(32) cleanApertureHeightN;\n    CHECK(avifROStreamReadU32(&s, &clap->heightD));   // unsigned int(32) cleanApertureHeightD;\n    CHECK(avifROStreamReadU32(&s, &clap->horizOffN)); // unsigned int(32) horizOffN;\n    CHECK(avifROStreamReadU32(&s, &clap->horizOffD)); // unsigned int(32) horizOffD;\n    CHECK(avifROStreamReadU32(&s, &clap->vertOffN));  // unsigned int(32) vertOffN;\n    CHECK(avifROStreamReadU32(&s, &clap->vertOffD));  // unsigned int(32) vertOffD;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageRotationProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifImageRotation * irot = &prop->u.irot;\n    CHECK(avifROStreamRead(&s, &irot->angle, 1)); // unsigned int (6) reserved = 0; unsigned int (2) angle;\n    if ((irot->angle & 0xfc) != 0) {\n        // reserved bits must be 0\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseImageMirrorProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifImageMirror * imir = &prop->u.imir;\n    CHECK(avifROStreamRead(&s, &imir->axis, 1)); // unsigned int (7) reserved = 0; unsigned int (1) axis;\n    if ((imir->axis & 0xfe) != 0) {\n        // reserved bits must be 0\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParsePixelInformationProperty(avifProperty * prop, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    avifPixelInformationProperty * pixi = &prop->u.pixi;\n    CHECK(avifROStreamRead(&s, &pixi->planeCount, 1)); // unsigned int (8) num_channels;\n    if (pixi->planeCount > MAX_PIXI_PLANE_DEPTHS) {\n        return AVIF_FALSE;\n    }\n    for (uint8_t i = 0; i < pixi->planeCount; ++i) {\n        CHECK(avifROStreamRead(&s, &pixi->planeDepths[i], 1)); // unsigned int (8) bits_per_channel;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemPropertyContainerBox(avifPropertyArray * properties, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        int propertyIndex = avifArrayPushIndex(properties);\n        avifProperty * prop = &properties->prop[propertyIndex];\n        memcpy(prop->type, header.type, 4);\n        if (!memcmp(header.type, \"ispe\", 4)) {\n            CHECK(avifParseImageSpatialExtentsProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"auxC\", 4)) {\n            CHECK(avifParseAuxiliaryTypeProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"colr\", 4)) {\n            CHECK(avifParseColourInformationBox(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"av1C\", 4)) {\n            CHECK(avifParseAV1CodecConfigurationBoxProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"pasp\", 4)) {\n            CHECK(avifParsePixelAspectRatioBoxProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"clap\", 4)) {\n            CHECK(avifParseCleanApertureBoxProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"irot\", 4)) {\n            CHECK(avifParseImageRotationProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"imir\", 4)) {\n            CHECK(avifParseImageMirrorProperty(prop, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"pixi\", 4)) {\n            CHECK(avifParsePixelInformationProperty(prop, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemPropertyAssociation(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    uint32_t flags;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, &flags));\n    avifBool propertyIndexIsU16 = ((flags & 0x1) != 0);\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount));\n    for (uint32_t entryIndex = 0; entryIndex < entryCount; ++entryIndex) {\n        unsigned int itemID;\n        if (version < 1) {\n            uint16_t tmp;\n            CHECK(avifROStreamReadU16(&s, &tmp));\n            itemID = tmp;\n        } else {\n            CHECK(avifROStreamReadU32(&s, &itemID));\n        }\n        uint8_t associationCount;\n        CHECK(avifROStreamRead(&s, &associationCount, 1));\n        for (uint8_t associationIndex = 0; associationIndex < associationCount; ++associationIndex) {\n            avifBool essential = AVIF_FALSE;\n            uint16_t propertyIndex = 0;\n            if (propertyIndexIsU16) {\n                CHECK(avifROStreamReadU16(&s, &propertyIndex));\n                essential = ((propertyIndex & 0x8000) != 0);\n                propertyIndex &= 0x7fff;\n            } else {\n                uint8_t tmp;\n                CHECK(avifROStreamRead(&s, &tmp, 1));\n                essential = ((tmp & 0x80) != 0);\n                propertyIndex = tmp & 0x7f;\n            }\n\n            if (propertyIndex == 0) {\n                // Not associated with any item\n                continue;\n            }\n            --propertyIndex; // 1-indexed\n\n            if (propertyIndex >= meta->properties.count) {\n                return AVIF_FALSE;\n            }\n\n            avifDecoderItem * item = avifMetaFindItem(meta, itemID);\n            if (!item) {\n                return AVIF_FALSE;\n            }\n\n            // Copy property to item\n            avifProperty * srcProp = &meta->properties.prop[propertyIndex];\n\n            static const char * supportedTypes[] = { \"ispe\", \"auxC\", \"colr\", \"av1C\", \"pasp\", \"clap\", \"irot\", \"imir\", \"pixi\" };\n            size_t supportedTypesCount = sizeof(supportedTypes) / sizeof(supportedTypes[0]);\n            avifBool supportedType = AVIF_FALSE;\n            for (size_t i = 0; i < supportedTypesCount; ++i) {\n                if (!memcmp(srcProp->type, supportedTypes[i], 4)) {\n                    supportedType = AVIF_TRUE;\n                    break;\n                }\n            }\n            if (supportedType) {\n                avifProperty * dstProp = (avifProperty *)avifArrayPushPtr(&item->properties);\n                memcpy(dstProp, srcProp, sizeof(avifProperty));\n            } else {\n                if (essential) {\n                    // Discovered an essential item property that libavif doesn't support!\n                    // Make a note to ignore this item later.\n                    item->hasUnsupportedEssentialProperty = AVIF_TRUE;\n                }\n            }\n        }\n    }\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParsePrimaryItemBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    if (meta->primaryItemID > 0) {\n        // Illegal to have multiple pitm boxes, bail out\n        return AVIF_FALSE;\n    }\n\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    if (version == 0) {\n        uint16_t tmp16;\n        CHECK(avifROStreamReadU16(&s, &tmp16)); // unsigned int(16) item_ID;\n        meta->primaryItemID = tmp16;\n    } else {\n        CHECK(avifROStreamReadU32(&s, &meta->primaryItemID)); // unsigned int(32) item_ID;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemDataBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    // Check to see if we've already seen an idat box for this meta box. If so, bail out\n    for (uint32_t i = 0; i < meta->idats.count; ++i) {\n        if (meta->idats.idat[i].id == meta->idatID) {\n            return AVIF_FALSE;\n        }\n    }\n\n    int index = avifArrayPushIndex(&meta->idats);\n    avifDecoderItemData * idat = &meta->idats.idat[index];\n    idat->id = meta->idatID;\n    idat->data.data = raw;\n    idat->data.size = rawLen;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemPropertiesBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifBoxHeader ipcoHeader;\n    CHECK(avifROStreamReadBoxHeader(&s, &ipcoHeader));\n    if (memcmp(ipcoHeader.type, \"ipco\", 4) != 0) {\n        return AVIF_FALSE;\n    }\n\n    // Read all item properties inside of ItemPropertyContainerBox\n    CHECK(avifParseItemPropertyContainerBox(&meta->properties, avifROStreamCurrent(&s), ipcoHeader.size));\n    CHECK(avifROStreamSkip(&s, ipcoHeader.size));\n\n    // Now read all ItemPropertyAssociation until the end of the box, and make associations\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader ipmaHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &ipmaHeader));\n\n        if (!memcmp(ipmaHeader.type, \"ipma\", 4)) {\n            CHECK(avifParseItemPropertyAssociation(meta, avifROStreamCurrent(&s), ipmaHeader.size));\n        } else {\n            // These must all be type ipma\n            return AVIF_FALSE;\n        }\n\n        CHECK(avifROStreamSkip(&s, ipmaHeader.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemInfoEntry(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 2)); // TODO: support version > 2? 2+ is required for item_type\n\n    uint16_t itemID;                                      // unsigned int(16) item_ID;\n    CHECK(avifROStreamReadU16(&s, &itemID));              //\n    uint16_t itemProtectionIndex;                         // unsigned int(16) item_protection_index;\n    CHECK(avifROStreamReadU16(&s, &itemProtectionIndex)); //\n    uint8_t itemType[4];                                  // unsigned int(32) item_type;\n    CHECK(avifROStreamRead(&s, itemType, 4));             //\n\n    avifContentType contentType;\n    if (!memcmp(itemType, \"mime\", 4)) {\n        CHECK(avifROStreamReadString(&s, NULL, 0));                                   // string item_name; (skipped)\n        CHECK(avifROStreamReadString(&s, contentType.contentType, CONTENTTYPE_SIZE)); // string content_type;\n    } else {\n        memset(&contentType, 0, sizeof(contentType));\n    }\n\n    avifDecoderItem * item = avifMetaFindItem(meta, itemID);\n    if (!item) {\n        return AVIF_FALSE;\n    }\n\n    memcpy(item->type, itemType, sizeof(itemType));\n    memcpy(&item->contentType, &contentType, sizeof(contentType));\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemInfoBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n    uint32_t entryCount;\n    if (version == 0) {\n        uint16_t tmp;\n        CHECK(avifROStreamReadU16(&s, &tmp)); // unsigned int(16) entry_count;\n        entryCount = tmp;\n    } else if (version == 1) {\n        CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n    } else {\n        return AVIF_FALSE;\n    }\n\n    for (uint32_t entryIndex = 0; entryIndex < entryCount; ++entryIndex) {\n        avifBoxHeader infeHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &infeHeader));\n\n        if (!memcmp(infeHeader.type, \"infe\", 4)) {\n            CHECK(avifParseItemInfoEntry(meta, avifROStreamCurrent(&s), infeHeader.size));\n        } else {\n            // These must all be type ipma\n            return AVIF_FALSE;\n        }\n\n        CHECK(avifROStreamSkip(&s, infeHeader.size));\n    }\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseItemReferenceBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader irefHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &irefHeader));\n\n        uint32_t fromID = 0;\n        if (version == 0) {\n            uint16_t tmp;\n            CHECK(avifROStreamReadU16(&s, &tmp)); // unsigned int(16) from_item_ID;\n            fromID = tmp;\n        } else if (version == 1) {\n            CHECK(avifROStreamReadU32(&s, &fromID)); // unsigned int(32) from_item_ID;\n        } else {\n            // unsupported iref version, skip it\n            break;\n        }\n\n        uint16_t referenceCount = 0;\n        CHECK(avifROStreamReadU16(&s, &referenceCount)); // unsigned int(16) reference_count;\n\n        for (uint16_t refIndex = 0; refIndex < referenceCount; ++refIndex) {\n            uint32_t toID = 0;\n            if (version == 0) {\n                uint16_t tmp;\n                CHECK(avifROStreamReadU16(&s, &tmp)); // unsigned int(16) to_item_ID;\n                toID = tmp;\n            } else if (version == 1) {\n                CHECK(avifROStreamReadU32(&s, &toID)); // unsigned int(32) to_item_ID;\n            } else {\n                // unsupported iref version, skip it\n                break;\n            }\n\n            // Read this reference as \"{fromID} is a {irefType} for {toID}\"\n            if (fromID && toID) {\n                avifDecoderItem * item = avifMetaFindItem(meta, fromID);\n                if (!item) {\n                    return AVIF_FALSE;\n                }\n\n                if (!memcmp(irefHeader.type, \"thmb\", 4)) {\n                    item->thumbnailForID = toID;\n                }\n                if (!memcmp(irefHeader.type, \"auxl\", 4)) {\n                    item->auxForID = toID;\n                }\n                if (!memcmp(irefHeader.type, \"cdsc\", 4)) {\n                    item->descForID = toID;\n                }\n                if (!memcmp(irefHeader.type, \"dimg\", 4)) {\n                    // derived images refer in the opposite direction\n                    avifDecoderItem * dimg = avifMetaFindItem(meta, toID);\n                    if (!dimg) {\n                        return AVIF_FALSE;\n                    }\n\n                    dimg->dimgForID = fromID;\n                }\n            }\n        }\n    }\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMetaBox(avifMeta * meta, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    ++meta->idatID; // for tracking idat\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"iloc\", 4)) {\n            CHECK(avifParseItemLocationBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"pitm\", 4)) {\n            CHECK(avifParsePrimaryItemBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"idat\", 4)) {\n            CHECK(avifParseItemDataBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"iprp\", 4)) {\n            CHECK(avifParseItemPropertiesBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"iinf\", 4)) {\n            CHECK(avifParseItemInfoBox(meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"iref\", 4)) {\n            CHECK(avifParseItemReferenceBox(meta, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseTrackHeaderBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    uint32_t ignored32, trackID;\n    uint64_t ignored64;\n    if (version == 1) {\n        CHECK(avifROStreamReadU64(&s, &ignored64)); // unsigned int(64) creation_time;\n        CHECK(avifROStreamReadU64(&s, &ignored64)); // unsigned int(64) modification_time;\n        CHECK(avifROStreamReadU32(&s, &trackID));   // unsigned int(32) track_ID;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // const unsigned int(32) reserved = 0;\n        CHECK(avifROStreamReadU64(&s, &ignored64)); // unsigned int(64) duration;\n    } else if (version == 0) {\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // unsigned int(32) creation_time;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // unsigned int(32) modification_time;\n        CHECK(avifROStreamReadU32(&s, &trackID));   // unsigned int(32) track_ID;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // const unsigned int(32) reserved = 0;\n        CHECK(avifROStreamReadU32(&s, &ignored32)); // unsigned int(32) duration;\n    } else {\n        // Unsupported version\n        return AVIF_FALSE;\n    }\n\n    // Skipping the following 52 bytes here:\n    // ------------------------------------\n    // const unsigned int(32)[2] reserved = 0;\n    // template int(16) layer = 0;\n    // template int(16) alternate_group = 0;\n    // template int(16) volume = {if track_is_audio 0x0100 else 0};\n    // const unsigned int(16) reserved = 0;\n    // template int(32)[9] matrix= { 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 }; // unity matrix\n    CHECK(avifROStreamSkip(&s, 52));\n\n    uint32_t width, height;\n    CHECK(avifROStreamReadU32(&s, &width));  // unsigned int(32) width;\n    CHECK(avifROStreamReadU32(&s, &height)); // unsigned int(32) height;\n    track->width = width >> 16;\n    track->height = height >> 16;\n\n    // TODO: support scaling based on width/height track header info?\n\n    track->id = trackID;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMediaHeaderBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    uint8_t version;\n    CHECK(avifROStreamReadVersionAndFlags(&s, &version, NULL));\n\n    uint32_t ignored32, mediaTimescale, mediaDuration32;\n    uint64_t ignored64, mediaDuration64;\n    if (version == 1) {\n        CHECK(avifROStreamReadU64(&s, &ignored64));       // unsigned int(64) creation_time;\n        CHECK(avifROStreamReadU64(&s, &ignored64));       // unsigned int(64) modification_time;\n        CHECK(avifROStreamReadU32(&s, &mediaTimescale));  // unsigned int(32) timescale;\n        CHECK(avifROStreamReadU64(&s, &mediaDuration64)); // unsigned int(64) duration;\n        track->mediaDuration = mediaDuration64;\n    } else if (version == 0) {\n        CHECK(avifROStreamReadU32(&s, &ignored32));       // unsigned int(32) creation_time;\n        CHECK(avifROStreamReadU32(&s, &ignored32));       // unsigned int(32) modification_time;\n        CHECK(avifROStreamReadU32(&s, &mediaTimescale));  // unsigned int(32) timescale;\n        CHECK(avifROStreamReadU32(&s, &mediaDuration32)); // unsigned int(32) duration;\n        track->mediaDuration = (uint64_t)mediaDuration32;\n    } else {\n        // Unsupported version\n        return AVIF_FALSE;\n    }\n\n    track->mediaTimescale = mediaTimescale;\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseChunkOffsetBox(avifSampleTable * sampleTable, avifBool largeOffsets, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        uint64_t offset;\n        if (largeOffsets) {\n            CHECK(avifROStreamReadU64(&s, &offset)); // unsigned int(32) chunk_offset;\n        } else {\n            uint32_t offset32;\n            CHECK(avifROStreamReadU32(&s, &offset32)); // unsigned int(32) chunk_offset;\n            offset = (uint64_t)offset32;\n        }\n\n        avifSampleTableChunk * chunk = (avifSampleTableChunk *)avifArrayPushPtr(&sampleTable->chunks);\n        chunk->offset = offset;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleToChunkBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        avifSampleTableSampleToChunk * sampleToChunk = (avifSampleTableSampleToChunk *)avifArrayPushPtr(&sampleTable->sampleToChunks);\n        CHECK(avifROStreamReadU32(&s, &sampleToChunk->firstChunk));             // unsigned int(32) first_chunk;\n        CHECK(avifROStreamReadU32(&s, &sampleToChunk->samplesPerChunk));        // unsigned int(32) samples_per_chunk;\n        CHECK(avifROStreamReadU32(&s, &sampleToChunk->sampleDescriptionIndex)); // unsigned int(32) sample_description_index;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleSizeBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t allSamplesSize, sampleCount;\n    CHECK(avifROStreamReadU32(&s, &allSamplesSize)); // unsigned int(32) sample_size;\n    CHECK(avifROStreamReadU32(&s, &sampleCount));    // unsigned int(32) sample_count;\n\n    if (allSamplesSize > 0) {\n        sampleTable->allSamplesSize = allSamplesSize;\n    } else {\n        for (uint32_t i = 0; i < sampleCount; ++i) {\n            avifSampleTableSampleSize * sampleSize = (avifSampleTableSampleSize *)avifArrayPushPtr(&sampleTable->sampleSizes);\n            CHECK(avifROStreamReadU32(&s, &sampleSize->size)); // unsigned int(32) entry_size;\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSyncSampleBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        uint32_t sampleNumber = 0;\n        CHECK(avifROStreamReadU32(&s, &sampleNumber)); // unsigned int(32) sample_number;\n        avifSyncSample * syncSample = (avifSyncSample *)avifArrayPushPtr(&sampleTable->syncSamples);\n        syncSample->sampleNumber = sampleNumber;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseTimeToSampleBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        avifSampleTableTimeToSample * timeToSample = (avifSampleTableTimeToSample *)avifArrayPushPtr(&sampleTable->timeToSamples);\n        CHECK(avifROStreamReadU32(&s, &timeToSample->sampleCount)); // unsigned int(32) sample_count;\n        CHECK(avifROStreamReadU32(&s, &timeToSample->sampleDelta)); // unsigned int(32) sample_delta;\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleDescriptionBox(avifSampleTable * sampleTable, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamReadAndEnforceVersion(&s, 0));\n\n    uint32_t entryCount;\n    CHECK(avifROStreamReadU32(&s, &entryCount)); // unsigned int(32) entry_count;\n\n    for (uint32_t i = 0; i < entryCount; ++i) {\n        avifBoxHeader sampleEntryHeader;\n        CHECK(avifROStreamReadBoxHeader(&s, &sampleEntryHeader));\n\n        avifSampleDescription * description = (avifSampleDescription *)avifArrayPushPtr(&sampleTable->sampleDescriptions);\n        avifArrayCreate(&description->properties, sizeof(avifProperty), 16);\n        memcpy(description->format, sampleEntryHeader.type, sizeof(description->format));\n        size_t remainingBytes = avifROStreamRemainingBytes(&s);\n        if (!memcmp(description->format, \"av01\", 4) && (remainingBytes > VISUALSAMPLEENTRY_SIZE)) {\n            CHECK(avifParseItemPropertyContainerBox(\n                &description->properties, avifROStreamCurrent(&s) + VISUALSAMPLEENTRY_SIZE, remainingBytes - VISUALSAMPLEENTRY_SIZE));\n        }\n\n        CHECK(avifROStreamSkip(&s, sampleEntryHeader.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseSampleTableBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    if (track->sampleTable) {\n        // A TrackBox may only have one SampleTable\n        return AVIF_FALSE;\n    }\n    track->sampleTable = avifSampleTableCreate();\n\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"stco\", 4)) {\n            CHECK(avifParseChunkOffsetBox(track->sampleTable, AVIF_FALSE, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"co64\", 4)) {\n            CHECK(avifParseChunkOffsetBox(track->sampleTable, AVIF_TRUE, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stsc\", 4)) {\n            CHECK(avifParseSampleToChunkBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stsz\", 4)) {\n            CHECK(avifParseSampleSizeBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stss\", 4)) {\n            CHECK(avifParseSyncSampleBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stts\", 4)) {\n            CHECK(avifParseTimeToSampleBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"stsd\", 4)) {\n            CHECK(avifParseSampleDescriptionBox(track->sampleTable, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMediaInformationBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"stbl\", 4)) {\n            CHECK(avifParseSampleTableBox(track, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMediaBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"mdhd\", 4)) {\n            CHECK(avifParseMediaHeaderBox(track, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"minf\", 4)) {\n            CHECK(avifParseMediaInformationBox(track, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifTrackReferenceBox(avifTrack * track, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"auxl\", 4)) {\n            uint32_t toID;\n            CHECK(avifROStreamReadU32(&s, &toID));                       // unsigned int(32) track_IDs[]\n            CHECK(avifROStreamSkip(&s, header.size - sizeof(uint32_t))); // just take the first one\n            track->auxForID = toID;\n        } else {\n            CHECK(avifROStreamSkip(&s, header.size));\n        }\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseTrackBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    avifTrack * track = avifDecoderDataCreateTrack(data);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"tkhd\", 4)) {\n            CHECK(avifParseTrackHeaderBox(track, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"meta\", 4)) {\n            CHECK(avifParseMetaBox(track->meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"mdia\", 4)) {\n            CHECK(avifParseMediaBox(track, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"tref\", 4)) {\n            CHECK(avifTrackReferenceBox(track, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseMoovBox(avifDecoderData * data, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"trak\", 4)) {\n            CHECK(avifParseTrackBox(data, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParseFileTypeBox(avifFileType * ftyp, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    CHECK(avifROStreamRead(&s, ftyp->majorBrand, 4));\n    CHECK(avifROStreamReadU32(&s, &ftyp->minorVersion));\n\n    size_t compatibleBrandsBytes = avifROStreamRemainingBytes(&s);\n    if ((compatibleBrandsBytes % 4) != 0) {\n        return AVIF_FALSE;\n    }\n    ftyp->compatibleBrands = avifROStreamCurrent(&s);\n    CHECK(avifROStreamSkip(&s, compatibleBrandsBytes));\n    ftyp->compatibleBrandsCount = (int)compatibleBrandsBytes / 4;\n\n    return AVIF_TRUE;\n}\n\nstatic avifBool avifParse(avifDecoderData * data, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n\n    while (avifROStreamHasBytesLeft(&s, 1)) {\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeader(&s, &header));\n\n        if (!memcmp(header.type, \"ftyp\", 4)) {\n            CHECK(avifParseFileTypeBox(&data->ftyp, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"meta\", 4)) {\n            CHECK(avifParseMetaBox(data->meta, avifROStreamCurrent(&s), header.size));\n        } else if (!memcmp(header.type, \"moov\", 4)) {\n            CHECK(avifParseMoovBox(data, avifROStreamCurrent(&s), header.size));\n        }\n\n        CHECK(avifROStreamSkip(&s, header.size));\n    }\n    return AVIF_TRUE;\n}\n\n// ---------------------------------------------------------------------------\n\nstatic avifBool avifFileTypeIsCompatible(avifFileType * ftyp)\n{\n    avifBool avifCompatible = (memcmp(ftyp->majorBrand, \"avif\", 4) == 0 || memcmp(ftyp->majorBrand, \"avis\", 4) == 0);\n    if (!avifCompatible) {\n        for (int compatibleBrandIndex = 0; compatibleBrandIndex < ftyp->compatibleBrandsCount; ++compatibleBrandIndex) {\n            const uint8_t * compatibleBrand = &ftyp->compatibleBrands[4 * compatibleBrandIndex];\n            if (!memcmp(compatibleBrand, \"avif\", 4) || !memcmp(compatibleBrand, \"avis\", 4)) {\n                avifCompatible = AVIF_TRUE;\n                break;\n            }\n        }\n    }\n    return avifCompatible;\n}\n\navifBool avifPeekCompatibleFileType(const avifROData * input)\n{\n    BEGIN_STREAM(s, input->data, input->size);\n\n    avifBoxHeader header;\n    CHECK(avifROStreamReadBoxHeader(&s, &header));\n    if (memcmp(header.type, \"ftyp\", 4) != 0) {\n        return AVIF_FALSE;\n    }\n\n    avifFileType ftyp;\n    memset(&ftyp, 0, sizeof(avifFileType));\n    avifBool parsed = avifParseFileTypeBox(&ftyp, avifROStreamCurrent(&s), header.size);\n    if (!parsed) {\n        return AVIF_FALSE;\n    }\n    return avifFileTypeIsCompatible(&ftyp);\n}\n\n// ---------------------------------------------------------------------------\n\navifDecoder * avifDecoderCreate(void)\n{\n    avifDecoder * decoder = (avifDecoder *)avifAlloc(sizeof(avifDecoder));\n    memset(decoder, 0, sizeof(avifDecoder));\n    return decoder;\n}\n\nstatic void avifDecoderCleanup(avifDecoder * decoder)\n{\n    if (decoder->data) {\n        avifDecoderDataDestroy(decoder->data);\n        decoder->data = NULL;\n    }\n\n    if (decoder->image) {\n        avifImageDestroy(decoder->image);\n        decoder->image = NULL;\n    }\n}\n\nvoid avifDecoderDestroy(avifDecoder * decoder)\n{\n    avifDecoderCleanup(decoder);\n    avifFree(decoder);\n}\n\navifResult avifDecoderSetSource(avifDecoder * decoder, avifDecoderSource source)\n{\n    decoder->requestedSource = source;\n    return avifDecoderReset(decoder);\n}\n\navifResult avifDecoderParse(avifDecoder * decoder, const avifROData * rawInput)\n{\n    // Cleanup anything lingering in the decoder\n    avifDecoderCleanup(decoder);\n\n    // -----------------------------------------------------------------------\n    // Parse BMFF boxes\n\n    decoder->data = avifDecoderDataCreate();\n\n    // Shallow copy, on purpose\n    memcpy(&decoder->data->rawInput, rawInput, sizeof(avifROData));\n\n    if (!avifParse(decoder->data, decoder->data->rawInput.data, decoder->data->rawInput.size)) {\n        return AVIF_RESULT_BMFF_PARSE_FAILED;\n    }\n\n    avifBool avifCompatible = avifFileTypeIsCompatible(&decoder->data->ftyp);\n    if (!avifCompatible) {\n        return AVIF_RESULT_INVALID_FTYP;\n    }\n\n    // Sanity check items\n    for (uint32_t itemIndex = 0; itemIndex < decoder->data->meta->items.count; ++itemIndex) {\n        avifDecoderItem * item = &decoder->data->meta->items.item[itemIndex];\n        if (item->hasUnsupportedEssentialProperty) {\n            // An essential property isn't supported by libavif; ignore the item.\n            continue;\n        }\n        const uint8_t * p = avifDecoderDataCalcItemPtr(decoder->data, item);\n        if (p == NULL) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n    }\n\n    // Sanity check tracks\n    for (uint32_t trackIndex = 0; trackIndex < decoder->data->tracks.count; ++trackIndex) {\n        avifTrack * track = &decoder->data->tracks.track[trackIndex];\n        if (!track->sampleTable) {\n            continue;\n        }\n\n        for (uint32_t chunkIndex = 0; chunkIndex < track->sampleTable->chunks.count; ++chunkIndex) {\n            avifSampleTableChunk * chunk = &track->sampleTable->chunks.chunk[chunkIndex];\n            if (chunk->offset > decoder->data->rawInput.size) {\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n    }\n    return avifDecoderReset(decoder);\n}\n\nstatic avifCodec * avifCodecCreateInternal(avifCodecChoice choice, avifCodecDecodeInput * decodeInput)\n{\n    avifCodec * codec = avifCodecCreate(choice, AVIF_CODEC_FLAG_CAN_DECODE);\n    if (codec) {\n        codec->decodeInput = decodeInput;\n    }\n    return codec;\n}\n\nstatic avifResult avifDecoderFlush(avifDecoder * decoder)\n{\n    avifDecoderDataResetCodec(decoder->data);\n\n    for (unsigned int i = 0; i < decoder->data->tiles.count; ++i) {\n        avifTile * tile = &decoder->data->tiles.tile[i];\n        tile->codec = avifCodecCreateInternal(decoder->codecChoice, tile->input);\n        if (!tile->codec) {\n            return AVIF_RESULT_NO_CODEC_AVAILABLE;\n        }\n        if (!tile->codec->open(tile->codec, decoder->imageIndex + 1)) {\n            return AVIF_RESULT_DECODE_COLOR_FAILED;\n        }\n    }\n    return AVIF_RESULT_OK;\n}\n\navifResult avifDecoderReset(avifDecoder * decoder)\n{\n    avifDecoderData * data = decoder->data;\n    if (!data) {\n        // Nothing to reset.\n        return AVIF_RESULT_OK;\n    }\n\n    memset(&data->colorGrid, 0, sizeof(data->colorGrid));\n    memset(&data->alphaGrid, 0, sizeof(data->alphaGrid));\n    avifDecoderDataClearTiles(data);\n\n    // Prepare / cleanup decoded image state\n    if (decoder->image) {\n        avifImageDestroy(decoder->image);\n    }\n    decoder->image = avifImageCreateEmpty();\n    data->cicpSet = AVIF_FALSE;\n\n    memset(&decoder->ioStats, 0, sizeof(decoder->ioStats));\n\n    // -----------------------------------------------------------------------\n    // Build decode input\n\n    data->sourceSampleTable = NULL; // Reset\n    if (decoder->requestedSource == AVIF_DECODER_SOURCE_AUTO) {\n        if (data->tracks.count > 0) {\n            data->source = AVIF_DECODER_SOURCE_TRACKS;\n        } else {\n            data->source = AVIF_DECODER_SOURCE_PRIMARY_ITEM;\n        }\n    } else {\n        data->source = decoder->requestedSource;\n    }\n\n    const avifPropertyArray * colorProperties = NULL;\n    if (data->source == AVIF_DECODER_SOURCE_TRACKS) {\n        avifTrack * colorTrack = NULL;\n        avifTrack * alphaTrack = NULL;\n\n        // Find primary track - this probably needs some better detection\n        uint32_t colorTrackIndex = 0;\n        for (; colorTrackIndex < decoder->data->tracks.count; ++colorTrackIndex) {\n            avifTrack * track = &decoder->data->tracks.track[colorTrackIndex];\n            if (!track->sampleTable) {\n                continue;\n            }\n            if (!track->id) { // trak box might be missing a tkhd box inside, skip it\n                continue;\n            }\n            if (!track->sampleTable->chunks.count) {\n                continue;\n            }\n            if (!avifSampleTableHasFormat(track->sampleTable, \"av01\")) {\n                continue;\n            }\n            if (track->auxForID != 0) {\n                continue;\n            }\n\n            // Found one!\n            break;\n        }\n        if (colorTrackIndex == decoder->data->tracks.count) {\n            return AVIF_RESULT_NO_CONTENT;\n        }\n        colorTrack = &decoder->data->tracks.track[colorTrackIndex];\n\n        colorProperties = avifSampleTableGetProperties(colorTrack->sampleTable);\n        if (!colorProperties) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n\n        // Find Exif and/or XMP metadata, if any\n        if (colorTrack->meta) {\n            // See the comment above avifDecoderDataFindMetadata() for the explanation of using 0 here\n            if (!avifDecoderDataFindMetadata(data, colorTrack->meta, decoder->image, 0)) {\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n\n        uint32_t alphaTrackIndex = 0;\n        for (; alphaTrackIndex < decoder->data->tracks.count; ++alphaTrackIndex) {\n            avifTrack * track = &decoder->data->tracks.track[alphaTrackIndex];\n            if (!track->sampleTable) {\n                continue;\n            }\n            if (!track->id) {\n                continue;\n            }\n            if (!track->sampleTable->chunks.count) {\n                continue;\n            }\n            if (!avifSampleTableHasFormat(track->sampleTable, \"av01\")) {\n                continue;\n            }\n            if (track->auxForID == colorTrack->id) {\n                // Found it!\n                break;\n            }\n        }\n        if (alphaTrackIndex != decoder->data->tracks.count) {\n            alphaTrack = &decoder->data->tracks.track[alphaTrackIndex];\n        }\n\n        avifTile * colorTile = avifDecoderDataCreateTile(decoder->data);\n        if (!avifCodecDecodeInputGetSamples(colorTile->input, colorTrack->sampleTable, &decoder->data->rawInput)) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n        decoder->data->colorTileCount = 1;\n\n        avifTile * alphaTile = NULL;\n        if (alphaTrack) {\n            alphaTile = avifDecoderDataCreateTile(decoder->data);\n            if (!avifCodecDecodeInputGetSamples(alphaTile->input, alphaTrack->sampleTable, &decoder->data->rawInput)) {\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n            alphaTile->input->alpha = AVIF_TRUE;\n            decoder->data->alphaTileCount = 1;\n        }\n\n        // Stash off sample table for future timing information\n        data->sourceSampleTable = colorTrack->sampleTable;\n\n        // Image sequence timing\n        decoder->imageIndex = -1;\n        decoder->imageCount = colorTile->input->samples.count;\n        decoder->timescale = colorTrack->mediaTimescale;\n        decoder->durationInTimescales = colorTrack->mediaDuration;\n        if (colorTrack->mediaTimescale) {\n            decoder->duration = (double)decoder->durationInTimescales / (double)colorTrack->mediaTimescale;\n        } else {\n            decoder->duration = 0;\n        }\n        memset(&decoder->imageTiming, 0, sizeof(decoder->imageTiming)); // to be set in avifDecoderNextImage()\n\n        decoder->image->width = colorTrack->width;\n        decoder->image->height = colorTrack->height;\n        decoder->alphaPresent = (alphaTrack != NULL);\n    } else {\n        // Create from items\n\n        avifROData colorOBU = AVIF_DATA_EMPTY;\n        avifROData alphaOBU = AVIF_DATA_EMPTY;\n        avifDecoderItem * colorOBUItem = NULL;\n        avifDecoderItem * alphaOBUItem = NULL;\n\n        // Find the colorOBU (primary) item\n        for (uint32_t itemIndex = 0; itemIndex < data->meta->items.count; ++itemIndex) {\n            avifDecoderItem * item = &data->meta->items.item[itemIndex];\n            if (!item->size) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n            avifBool isGrid = (memcmp(item->type, \"grid\", 4) == 0);\n            if (memcmp(item->type, \"av01\", 4) && !isGrid) {\n                // probably exif or some other data\n                continue;\n            }\n            if (item->thumbnailForID != 0) {\n                // It's a thumbnail, skip it\n                continue;\n            }\n            if ((data->meta->primaryItemID > 0) && (item->id != data->meta->primaryItemID)) {\n                // a primary item ID was specified, require it\n                continue;\n            }\n\n            if (isGrid) {\n                const uint8_t * itemPtr = avifDecoderDataCalcItemPtr(data, item);\n                if (itemPtr == NULL) {\n                    return AVIF_RESULT_BMFF_PARSE_FAILED;\n                }\n                if (!avifParseImageGridBox(&data->colorGrid, itemPtr, item->size)) {\n                    return AVIF_RESULT_INVALID_IMAGE_GRID;\n                }\n            } else {\n                colorOBU.data = avifDecoderDataCalcItemPtr(data, item);\n                colorOBU.size = item->size;\n            }\n\n            colorOBUItem = item;\n            break;\n        }\n\n        if (!colorOBUItem) {\n            return AVIF_RESULT_NO_AV1_ITEMS_FOUND;\n        }\n        colorProperties = &colorOBUItem->properties;\n\n        // Find the alphaOBU item, if any\n        for (uint32_t itemIndex = 0; itemIndex < data->meta->items.count; ++itemIndex) {\n            avifDecoderItem * item = &data->meta->items.item[itemIndex];\n            if (!item->size) {\n                continue;\n            }\n            if (item->hasUnsupportedEssentialProperty) {\n                // An essential property isn't supported by libavif; ignore the item.\n                continue;\n            }\n            avifBool isGrid = (memcmp(item->type, \"grid\", 4) == 0);\n            if (memcmp(item->type, \"av01\", 4) && !isGrid) {\n                // probably exif or some other data\n                continue;\n            }\n            if (item->thumbnailForID != 0) {\n                // It's a thumbnail, skip it\n                continue;\n            }\n\n            const avifProperty * auxCProp = avifPropertyArrayFind(&item->properties, \"auxC\");\n            if (auxCProp && isAlphaURN(auxCProp->u.auxC.auxType) && (item->auxForID == colorOBUItem->id)) {\n                if (isGrid) {\n                    const uint8_t * itemPtr = avifDecoderDataCalcItemPtr(data, item);\n                    if (itemPtr == NULL) {\n                        return AVIF_RESULT_BMFF_PARSE_FAILED;\n                    }\n                    if (!avifParseImageGridBox(&data->alphaGrid, itemPtr, item->size)) {\n                        return AVIF_RESULT_INVALID_IMAGE_GRID;\n                    }\n                } else {\n                    alphaOBU.data = avifDecoderDataCalcItemPtr(data, item);\n                    alphaOBU.size = item->size;\n                }\n\n                alphaOBUItem = item;\n                break;\n            }\n        }\n\n        // Find Exif and/or XMP metadata, if any\n        if (!avifDecoderDataFindMetadata(data, data->meta, decoder->image, colorOBUItem->id)) {\n            return AVIF_RESULT_BMFF_PARSE_FAILED;\n        }\n\n        if ((data->colorGrid.rows > 0) && (data->colorGrid.columns > 0)) {\n            if (!avifDecoderDataGenerateImageGridTiles(data, &data->colorGrid, colorOBUItem, AVIF_FALSE)) {\n                return AVIF_RESULT_INVALID_IMAGE_GRID;\n            }\n            data->colorTileCount = data->tiles.count;\n        } else {\n            if (colorOBU.size == 0) {\n                return AVIF_RESULT_NO_AV1_ITEMS_FOUND;\n            }\n\n            avifTile * colorTile = avifDecoderDataCreateTile(decoder->data);\n            avifDecodeSample * colorSample = (avifDecodeSample *)avifArrayPushPtr(&colorTile->input->samples);\n            memcpy(&colorSample->data, &colorOBU, sizeof(avifROData));\n            colorSample->sync = AVIF_TRUE;\n            decoder->data->colorTileCount = 1;\n        }\n\n        if ((data->alphaGrid.rows > 0) && (data->alphaGrid.columns > 0) && alphaOBUItem) {\n            if (!avifDecoderDataGenerateImageGridTiles(data, &data->alphaGrid, alphaOBUItem, AVIF_FALSE)) {\n                return AVIF_RESULT_INVALID_IMAGE_GRID;\n            }\n            data->alphaTileCount = data->tiles.count - data->colorTileCount;\n        } else {\n            avifTile * alphaTile = NULL;\n            if (alphaOBU.size > 0) {\n                alphaTile = avifDecoderDataCreateTile(decoder->data);\n\n                avifDecodeSample * alphaSample = (avifDecodeSample *)avifArrayPushPtr(&alphaTile->input->samples);\n                memcpy(&alphaSample->data, &alphaOBU, sizeof(avifROData));\n                alphaSample->sync = AVIF_TRUE;\n                alphaTile->input->alpha = AVIF_TRUE;\n                decoder->data->alphaTileCount = 1;\n            }\n        }\n\n        // Set all counts and timing to safe-but-uninteresting values\n        decoder->imageIndex = -1;\n        decoder->imageCount = 1;\n        decoder->imageTiming.timescale = 1;\n        decoder->imageTiming.pts = 0;\n        decoder->imageTiming.ptsInTimescales = 0;\n        decoder->imageTiming.duration = 1;\n        decoder->imageTiming.durationInTimescales = 1;\n        decoder->timescale = 1;\n        decoder->duration = 1;\n        decoder->durationInTimescales = 1;\n\n        decoder->ioStats.colorOBUSize = colorOBU.size;\n        decoder->ioStats.alphaOBUSize = alphaOBU.size;\n\n        const avifProperty * ispeProp = avifPropertyArrayFind(colorProperties, \"ispe\");\n        if (ispeProp) {\n            decoder->image->width = ispeProp->u.ispe.width;\n            decoder->image->height = ispeProp->u.ispe.height;\n        } else {\n            decoder->image->width = 0;\n            decoder->image->height = 0;\n        }\n        decoder->alphaPresent = (alphaOBUItem != NULL);\n    }\n\n    // Sanity check tiles\n    for (uint32_t tileIndex = 0; tileIndex < data->tiles.count; ++tileIndex) {\n        avifTile * tile = &data->tiles.tile[tileIndex];\n        for (uint32_t sampleIndex = 0; sampleIndex < tile->input->samples.count; ++sampleIndex) {\n            avifDecodeSample * sample = &tile->input->samples.sample[sampleIndex];\n            if (!sample->data.data || !sample->data.size) {\n                // Every sample must have some data\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n    }\n\n    const avifProperty * colrProp = avifPropertyArrayFind(colorProperties, \"colr\");\n    if (colrProp) {\n        if (colrProp->u.colr.hasICC) {\n            avifImageSetProfileICC(decoder->image, colrProp->u.colr.icc, colrProp->u.colr.iccSize);\n        } else if (colrProp->u.colr.hasNCLX) {\n            data->cicpSet = AVIF_TRUE;\n            decoder->image->colorPrimaries = colrProp->u.colr.colorPrimaries;\n            decoder->image->transferCharacteristics = colrProp->u.colr.transferCharacteristics;\n            decoder->image->matrixCoefficients = colrProp->u.colr.matrixCoefficients;\n            decoder->image->yuvRange = colrProp->u.colr.range;\n        }\n    }\n\n    // Transformations\n    const avifProperty * paspProp = avifPropertyArrayFind(colorProperties, \"pasp\");\n    if (paspProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_PASP;\n        memcpy(&decoder->image->pasp, &paspProp->u.pasp, sizeof(avifPixelAspectRatioBox));\n    }\n    const avifProperty * clapProp = avifPropertyArrayFind(colorProperties, \"clap\");\n    if (clapProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_CLAP;\n        memcpy(&decoder->image->clap, &clapProp->u.clap, sizeof(avifCleanApertureBox));\n    }\n    const avifProperty * irotProp = avifPropertyArrayFind(colorProperties, \"irot\");\n    if (irotProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_IROT;\n        memcpy(&decoder->image->irot, &irotProp->u.irot, sizeof(avifImageRotation));\n    }\n    const avifProperty * imirProp = avifPropertyArrayFind(colorProperties, \"imir\");\n    if (imirProp) {\n        decoder->image->transformFlags |= AVIF_TRANSFORM_IMIR;\n        memcpy(&decoder->image->imir, &imirProp->u.imir, sizeof(avifImageMirror));\n    }\n\n    if (!decoder->data->cicpSet && (data->tiles.count > 0)) {\n        avifTile * firstTile = &data->tiles.tile[0];\n        if (firstTile->input->samples.count > 0) {\n            avifDecodeSample * sample = &firstTile->input->samples.sample[0];\n            avifSequenceHeader sequenceHeader;\n            if (avifSequenceHeaderParse(&sequenceHeader, &sample->data)) {\n                decoder->data->cicpSet = AVIF_TRUE;\n                decoder->image->colorPrimaries = sequenceHeader.colorPrimaries;\n                decoder->image->transferCharacteristics = sequenceHeader.transferCharacteristics;\n                decoder->image->matrixCoefficients = sequenceHeader.matrixCoefficients;\n                decoder->image->yuvRange = sequenceHeader.range;\n            }\n        }\n    }\n\n    const avifProperty * av1CProp = avifPropertyArrayFind(colorProperties, \"av1C\");\n    if (av1CProp) {\n        decoder->image->depth = avifCodecConfigurationBoxGetDepth(&av1CProp->u.av1C);\n        if (av1CProp->u.av1C.monochrome) {\n            decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV400;\n        } else {\n            if (av1CProp->u.av1C.chromaSubsamplingX && av1CProp->u.av1C.chromaSubsamplingY) {\n                decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV420;\n            } else if (av1CProp->u.av1C.chromaSubsamplingX) {\n                decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV422;\n\n            } else {\n                decoder->image->yuvFormat = AVIF_PIXEL_FORMAT_YUV444;\n            }\n        }\n        decoder->image->yuvChromaSamplePosition = (avifChromaSamplePosition)av1CProp->u.av1C.chromaSamplePosition;\n    } else {\n        // An av1C box is mandatory in all valid AVIF configurations. Bail out.\n        return AVIF_RESULT_BMFF_PARSE_FAILED;\n    }\n\n    return avifDecoderFlush(decoder);\n}\n\navifResult avifDecoderNextImage(avifDecoder * decoder)\n{\n    for (unsigned int tileIndex = 0; tileIndex < decoder->data->tiles.count; ++tileIndex) {\n        avifTile * tile = &decoder->data->tiles.tile[tileIndex];\n\n        if (!tile->codec->getNextImage(tile->codec, tile->image)) {\n            if (tile->input->alpha) {\n                return AVIF_RESULT_DECODE_ALPHA_FAILED;\n            } else {\n                if (tile->image->width) {\n                    // We've sent at least one image, but we've run out now.\n                    return AVIF_RESULT_NO_IMAGES_REMAINING;\n                }\n                return AVIF_RESULT_DECODE_COLOR_FAILED;\n            }\n        }\n    }\n\n    if (decoder->data->tiles.count != (decoder->data->colorTileCount + decoder->data->alphaTileCount)) {\n        // TODO: assert here? This should be impossible.\n        return AVIF_RESULT_UNKNOWN_ERROR;\n    }\n\n    if ((decoder->data->colorGrid.rows > 0) || (decoder->data->colorGrid.columns > 0)) {\n        if (!avifDecoderDataFillImageGrid(\n                decoder->data, &decoder->data->colorGrid, decoder->image, 0, decoder->data->colorTileCount, AVIF_FALSE)) {\n            return AVIF_RESULT_INVALID_IMAGE_GRID;\n        }\n    } else {\n        // Normal (most common) non-grid path. Just steal the planes from the only \"tile\".\n\n        if (decoder->data->colorTileCount != 1) {\n            return AVIF_RESULT_DECODE_COLOR_FAILED;\n        }\n\n        avifImage * srcColor = decoder->data->tiles.tile[0].image;\n\n        if ((decoder->image->width != srcColor->width) || (decoder->image->height != srcColor->height) ||\n            (decoder->image->depth != srcColor->depth)) {\n            avifImageFreePlanes(decoder->image, AVIF_PLANES_ALL);\n\n            decoder->image->width = srcColor->width;\n            decoder->image->height = srcColor->height;\n            decoder->image->depth = srcColor->depth;\n        }\n\n#if 0\n        // This code is currently unnecessary as the CICP is always set by the end of avifDecoderParse().\n        if (!decoder->data->cicpSet) {\n            decoder->data->cicpSet = AVIF_TRUE;\n            decoder->image->colorPrimaries = srcColor->colorPrimaries;\n            decoder->image->transferCharacteristics = srcColor->transferCharacteristics;\n            decoder->image->matrixCoefficients = srcColor->matrixCoefficients;\n        }\n#endif\n\n        avifImageStealPlanes(decoder->image, srcColor, AVIF_PLANES_YUV);\n    }\n\n    if ((decoder->data->alphaGrid.rows > 0) || (decoder->data->alphaGrid.columns > 0)) {\n        if (!avifDecoderDataFillImageGrid(\n                decoder->data, &decoder->data->alphaGrid, decoder->image, decoder->data->colorTileCount, decoder->data->alphaTileCount, AVIF_TRUE)) {\n            return AVIF_RESULT_INVALID_IMAGE_GRID;\n        }\n    } else {\n        // Normal (most common) non-grid path. Just steal the planes from the only \"tile\".\n\n        if (decoder->data->alphaTileCount == 0) {\n            avifImageFreePlanes(decoder->image, AVIF_PLANES_A); // no alpha\n        } else {\n            if (decoder->data->alphaTileCount != 1) {\n                return AVIF_RESULT_DECODE_ALPHA_FAILED;\n            }\n\n            avifImage * srcAlpha = decoder->data->tiles.tile[decoder->data->colorTileCount].image;\n            if ((decoder->image->width != srcAlpha->width) || (decoder->image->height != srcAlpha->height) ||\n                (decoder->image->depth != srcAlpha->depth)) {\n                return AVIF_RESULT_DECODE_ALPHA_FAILED;\n            }\n\n            avifImageStealPlanes(decoder->image, srcAlpha, AVIF_PLANES_A);\n        }\n    }\n\n    ++decoder->imageIndex;\n    if (decoder->data->sourceSampleTable) {\n        // Decoding from a track! Provide timing information.\n\n        avifResult timingResult = avifDecoderNthImageTiming(decoder, decoder->imageIndex, &decoder->imageTiming);\n        if (timingResult != AVIF_RESULT_OK) {\n            return timingResult;\n        }\n    }\n    return AVIF_RESULT_OK;\n}\n\navifResult avifDecoderNthImageTiming(const avifDecoder * decoder, uint32_t frameIndex, avifImageTiming * outTiming)\n{\n    if (!decoder->data) {\n        // Nothing has been parsed yet\n        return AVIF_RESULT_NO_CONTENT;\n    }\n\n    if ((int)frameIndex >= decoder->imageCount) {\n        // Impossible index\n        return AVIF_RESULT_NO_IMAGES_REMAINING;\n    }\n\n    if (!decoder->data->sourceSampleTable) {\n        // There isn't any real timing associated with this decode, so\n        // just hand back the defaults chosen in avifDecoderReset().\n        memcpy(outTiming, &decoder->imageTiming, sizeof(avifImageTiming));\n        return AVIF_RESULT_OK;\n    }\n\n    outTiming->timescale = decoder->timescale;\n    outTiming->ptsInTimescales = 0;\n    for (int imageIndex = 0; imageIndex < (int)frameIndex; ++imageIndex) {\n        outTiming->ptsInTimescales += avifSampleTableGetImageDelta(decoder->data->sourceSampleTable, imageIndex);\n    }\n    outTiming->durationInTimescales = avifSampleTableGetImageDelta(decoder->data->sourceSampleTable, frameIndex);\n\n    if (outTiming->timescale > 0) {\n        outTiming->pts = (double)outTiming->ptsInTimescales / (double)outTiming->timescale;\n        outTiming->duration = (double)outTiming->durationInTimescales / (double)outTiming->timescale;\n    } else {\n        outTiming->pts = 0.0;\n        outTiming->duration = 0.0;\n    }\n    return AVIF_RESULT_OK;\n}\n\navifResult avifDecoderNthImage(avifDecoder * decoder, uint32_t frameIndex)\n{\n    int requestedIndex = (int)frameIndex;\n    if (requestedIndex == decoder->imageIndex) {\n        // We're here already, nothing to do\n        return AVIF_RESULT_OK;\n    }\n\n    if (requestedIndex == (decoder->imageIndex + 1)) {\n        // it's just the next image, nothing special here\n        return avifDecoderNextImage(decoder);\n    }\n\n    if (requestedIndex >= decoder->imageCount) {\n        // Impossible index\n        return AVIF_RESULT_NO_IMAGES_REMAINING;\n    }\n\n    // If we get here, a decoder flush is necessary\n    decoder->imageIndex = ((int)avifDecoderNearestKeyframe(decoder, frameIndex)) - 1; // prepare to read nearest keyframe\n    avifDecoderFlush(decoder);\n    for (;;) {\n        avifResult result = avifDecoderNextImage(decoder);\n        if (result != AVIF_RESULT_OK) {\n            return result;\n        }\n\n        if (requestedIndex == decoder->imageIndex) {\n            break;\n        }\n    }\n    return AVIF_RESULT_OK;\n}\n\navifBool avifDecoderIsKeyframe(const avifDecoder * decoder, uint32_t frameIndex)\n{\n    if ((decoder->data->tiles.count > 0) && decoder->data->tiles.tile[0].input) {\n        if (frameIndex < decoder->data->tiles.tile[0].input->samples.count) {\n            return decoder->data->tiles.tile[0].input->samples.sample[frameIndex].sync;\n        }\n    }\n    return AVIF_FALSE;\n}\n\nuint32_t avifDecoderNearestKeyframe(const avifDecoder * decoder, uint32_t frameIndex)\n{\n    for (; frameIndex != 0; --frameIndex) {\n        if (avifDecoderIsKeyframe(decoder, frameIndex)) {\n            break;\n        }\n    }\n    return frameIndex;\n}\n\navifResult avifDecoderRead(avifDecoder * decoder, avifImage * image, const avifROData * input)\n{\n    avifResult result = avifDecoderParse(decoder, input);\n    if (result != AVIF_RESULT_OK) {\n        return result;\n    }\n    result = avifDecoderNextImage(decoder);\n    if (result != AVIF_RESULT_OK) {\n        return result;\n    }\n    avifImageCopy(image, decoder->image, AVIF_PLANES_ALL);\n    return AVIF_RESULT_OK;\n}\n"], "filenames": ["include/avif/internal.h", "src/read.c"], "buggy_code_start_loc": [243, 981], "buggy_code_end_loc": [243, 981], "fixing_code_start_loc": [244, 982], "fixing_code_end_loc": [248, 985], "type": "CWE-787", "message": "libavif 0.8.0 and 0.8.1 has an out-of-bounds write in avifDecoderDataFillImageGrid.", "other": {"cve": {"id": "CVE-2020-36407", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:08.033", "lastModified": "2021-07-06T21:04:30.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libavif 0.8.0 and 0.8.1 has an out-of-bounds write in avifDecoderDataFillImageGrid."}, {"lang": "es", "value": "libavif versiones 0.8.0 y 0.8.1, presenta una escritura fuera de l\u00edmites en la funci\u00f3n avifDecoderDataFillImageGrid"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aomedia:libavif:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "AD08C676-CD90-45A8-9892-B5C09467C304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aomedia:libavif:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "89091832-5929-4625-BBE7-7E41DF2008AC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24811", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/AOMediaCodec/libavif/commit/0a8e7244d494ae98e9756355dfbfb6697ded2ff9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/libavif/OSV-2020-1597.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AOMediaCodec/libavif/commit/0a8e7244d494ae98e9756355dfbfb6697ded2ff9"}}