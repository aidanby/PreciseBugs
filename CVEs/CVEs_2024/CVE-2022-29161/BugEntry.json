{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.crypto.script;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.GeneralSecurityException;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.crypto.KeyPairGenerator;\nimport org.xwiki.crypto.params.cipher.asymmetric.AsymmetricKeyPair;\nimport org.xwiki.crypto.params.cipher.asymmetric.PrivateKeyParameters;\nimport org.xwiki.crypto.params.cipher.asymmetric.PublicKeyParameters;\nimport org.xwiki.crypto.params.generator.asymmetric.RSAKeyGenerationParameters;\nimport org.xwiki.crypto.pkix.CertificateChainBuilder;\nimport org.xwiki.crypto.pkix.CertificateGeneratorFactory;\nimport org.xwiki.crypto.pkix.CertificateProvider;\nimport org.xwiki.crypto.pkix.CertifyingSigner;\nimport org.xwiki.crypto.pkix.X509ExtensionBuilder;\nimport org.xwiki.crypto.pkix.params.CertifiedKeyPair;\nimport org.xwiki.crypto.pkix.params.CertifiedPublicKey;\nimport org.xwiki.crypto.pkix.params.x509certificate.DistinguishedName;\nimport org.xwiki.crypto.pkix.params.x509certificate.X509CertificateGenerationParameters;\nimport org.xwiki.crypto.pkix.params.x509certificate.X509CertificateParameters;\nimport org.xwiki.crypto.pkix.params.x509certificate.X509CertifiedPublicKey;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.ExtendedKeyUsages;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.KeyUsage;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509DnsName;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509GeneralName;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509IpAddress;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509Rfc822Name;\nimport org.xwiki.crypto.signer.CMSSignedDataGenerator;\nimport org.xwiki.crypto.signer.CMSSignedDataVerifier;\nimport org.xwiki.crypto.signer.SignerFactory;\nimport org.xwiki.crypto.signer.param.CMSSignedDataGeneratorParameters;\nimport org.xwiki.crypto.signer.param.CMSSignedDataVerified;\nimport org.xwiki.crypto.signer.param.CMSSignerInfo;\nimport org.xwiki.script.service.ScriptService;\n\n/**\n * Script service allowing a user to create keys pairs and issue certificates.\n *\n * @version $Id$\n * @since 8.4RC1\n */\n@Component\n@Named(CryptoScriptService.ROLEHINT + '.' + RSACryptoScriptService.ROLEHINT)\n@Singleton\npublic class RSACryptoScriptService implements ScriptService\n{\n    /**\n     * The role hint of this component.\n     */\n    public static final String ROLEHINT = \"rsa\";\n\n    @Inject\n    @Named(\"RSA\")\n    private KeyPairGenerator keyPairGenerator;\n\n    @Inject\n    @Named(\"SHA1withRSAEncryption\")\n    private SignerFactory signerFactory;\n\n    @Inject\n    private Provider<X509ExtensionBuilder> extensionBuilder;\n\n    @Inject\n    @Named(\"X509\")\n    private CertificateGeneratorFactory certificateGeneratorFactory;\n\n    @Inject\n    private CMSSignedDataGenerator cmsSignedDataGenerator;\n\n    @Inject\n    @Named(\"X509\")\n    private CertificateChainBuilder certificateChainBuilder;\n\n    @Inject\n    private CMSSignedDataVerifier cmsSignedDataVerifier;\n\n    /**\n     * Generate a new RSA key pair.\n     *\n     * The key strength will be {@value RSAKeyGenerationParameters#DEFAULT_STRENGTH}.\n     * The key public exponent will be 0x10001.\n     * The probability a chosen prime could not be a real prime will be smaller\n     * than 2^-{@value RSAKeyGenerationParameters#DEFAULT_CERTAINTY}.\n     *\n     * @return an new asymmetric key pair.\n     */\n    public AsymmetricKeyPair generateKeyPair()\n    {\n        return keyPairGenerator.generate();\n    }\n\n    /**\n     * Generate a new RSA key pair of given strength. The strength should be given in number of bytes, so for\n     * a 2048 bits key, you should use 256 (bytes) as the integer parameter. The minimum valid strength is 2.\n     *\n     * The key public exponent will be 0x10001.\n     * The probability a chosen prime could not be a real prime will be smaller\n     * than 2^-{@value RSAKeyGenerationParameters#DEFAULT_CERTAINTY}.\n     *\n     * @param strength the strength in bytes.\n     * @return an new asymmetric key pair.\n     */\n    public AsymmetricKeyPair generateKeyPair(int strength)\n    {\n        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength));\n    }\n\n    /**\n     * Build a new instance with all custom parameters. The strength\n     * should be given in number of bytes, so for a 2048 bits key, you should use 256 (bytes) as the integer parameter.\n     * The minimum valid strength is 2. The exponent should be an odd number. The probability a chosen prime could\n     * not be a real prime will be smaller than 2^certainty.\n     *\n     * @param strength the key strength in bytes.\n     * @param publicExponent the public exponent.\n     * @param certainty certainty for prime evaluation.\n     *\n     * @return an new asymmetric key pair.\n     */\n    public AsymmetricKeyPair generateKeyPair(int strength, BigInteger publicExponent, int certainty)\n    {\n        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength, publicExponent, certainty));\n    }\n\n    /**\n     * Create a CertifiedKeyPair from a private key and a certificate.\n     *\n     * @param privateKey the private key.\n     * @param certificate the certified public key.\n     * @return a certified key pair.\n     */\n    public CertifiedKeyPair createCertifiedKeyPair(PrivateKeyParameters privateKey, CertifiedPublicKey certificate)\n    {\n        return new CertifiedKeyPair(privateKey, certificate);\n    }\n\n    /**\n     * Create a self-signed certificate for a Root CA.\n     *\n     * @param keyPair the keypair to issue the certificate for and used for signing it.\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedKeyPair issueRootCACertificate(AsymmetricKeyPair keyPair, String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return new CertifiedKeyPair(\n            keyPair.getPrivate(),\n            certificateGeneratorFactory.getInstance(signerFactory.getInstance(true, keyPair.getPrivate()),\n                new X509CertificateGenerationParameters(\n                    validity,\n                    extensionBuilder.get().addBasicConstraints(true)\n                        .addKeyUsage(true, EnumSet.of(KeyUsage.keyCertSign,\n                            KeyUsage.cRLSign))\n                        .build()))\n                .generate(new DistinguishedName(dn), keyPair.getPublic(),\n                    new X509CertificateParameters())\n        );\n    }\n\n    /**\n     * Create an intermediate CA certificate.\n     *\n     * @param issuer the certified keypair for issuing the certificate\n     * @param keyPair the keyPair of the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified keypair.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedKeyPair issueIntermediateCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair,\n        String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return new CertifiedKeyPair(\n            keyPair.getPrivate(),\n            issueIntermediateCertificate(issuer, keyPair.getPublic(), dn, validity)\n        );\n    }\n\n    /**\n     * Create an intermediate CA certificate.\n     *\n     * @param privateKey the private key for signing the certificate\n     * @param issuer the certificate of the issuer of the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueIntermediateCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,\n        PublicKeyParameters publicKey, String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return issueIntermediateCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity);\n    }\n\n    /**\n     * Create an intermediate CA certificate.\n     *\n     * @param issuer the certified keypair for issuing the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueIntermediateCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,\n        String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return certificateGeneratorFactory.getInstance(\n            CertifyingSigner.getInstance(true, issuer, signerFactory),\n            new X509CertificateGenerationParameters(\n                validity,\n                extensionBuilder.get().addBasicConstraints(0)\n                    .addKeyUsage(EnumSet.of(KeyUsage.keyCertSign,\n                        KeyUsage.cRLSign))\n                    .build()))\n                .generate(new DistinguishedName(dn), publicKey,\n                    new X509CertificateParameters());\n    }\n\n    /**\n     * Create an end entity certificate.\n     *\n     * @param issuer the certified keypair for issuing the certificate\n     * @param keyPair the keyPair of the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @param subjectAltName the alternative names for the certificate\n     * @return a certified keypair.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedKeyPair issueCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair, String dn,\n        int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException\n    {\n        return new CertifiedKeyPair(\n            keyPair.getPrivate(),\n            issueCertificate(issuer, keyPair.getPublic(), dn, validity, subjectAltName)\n        );\n    }\n\n    /**\n     * Create an end entity certificate.\n     *\n     * @param privateKey the private key for signing the certificate\n     * @param issuer the certificate of the issuer of the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @param subjectAltName the alternative names for the certificate\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,\n        PublicKeyParameters publicKey, String dn, int validity, List<X509GeneralName> subjectAltName)\n        throws IOException, GeneralSecurityException\n    {\n        return issueCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity, subjectAltName);\n    }\n\n    /**\n     * Create an end entity certificate. By default, the key can be used for encryption and signing. If the end entity\n     * contains some alternate subject names of type X509Rfc822Name a extended email protection usage is added. If the\n     * end entity contains some alternate subject names of type X509DnsName or X509IpAddress extended server and client\n     * authentication usages are added.\n     *\n     * @param issuer the keypair for issuing the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @param subjectAltName the alternative names for the certificate\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,\n        String dn, int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException\n    {\n        X509CertificateParameters params;\n        X509ExtensionBuilder builder = extensionBuilder.get().addKeyUsage(EnumSet.of(KeyUsage.digitalSignature,\n            KeyUsage.dataEncipherment));\n\n        if (subjectAltName != null) {\n            params = new X509CertificateParameters(\n                extensionBuilder.get().addSubjectAltName(false, subjectAltName.toArray(new X509GeneralName[]{}))\n                    .build());\n            Set<String> extUsage = new HashSet<>();\n            for (X509GeneralName genName : subjectAltName) {\n                if (genName instanceof X509Rfc822Name) {\n                    extUsage.add(ExtendedKeyUsages.EMAIL_PROTECTION);\n                } else if (genName instanceof X509DnsName || genName instanceof X509IpAddress) {\n                    extUsage.add(ExtendedKeyUsages.SERVER_AUTH);\n                    extUsage.add(ExtendedKeyUsages.CLIENT_AUTH);\n                }\n                builder.addExtendedKeyUsage(false, new ExtendedKeyUsages(extUsage));\n            }\n        } else {\n            params = new X509CertificateParameters();\n        }\n\n\n        return certificateGeneratorFactory.getInstance(\n                CertifyingSigner.getInstance(true, issuer, signerFactory),\n                new X509CertificateGenerationParameters(validity, builder.build()))\n            .generate(new DistinguishedName(dn), publicKey, params);\n    }\n\n    /**\n     * Generate a CMS (Cryptographic Message Syntax) signature for a given byte content. The resulting signature\n     * might contains the content itself.\n     *\n     * @param data the data to be signed\n     * @param keyPair the certified key pair used for signing\n     * @param embedContent if true, the signed content is embedded with the signature.\n     * @return the resulting signature encoded ASN.1 and in accordance with RFC 3852.\n     * @throws GeneralSecurityException on error.\n     */\n    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, boolean embedContent)\n        throws GeneralSecurityException\n    {\n        return cmsSign(data, keyPair, null, null, embedContent);\n    }\n\n    /**\n     * Generate a CMS (Cryptographic Message Syntax) signature for a given byte content. The resulting signature\n     * might contains the content itself and the certificate chain of the key used to sign.\n     *\n     * @param data the data to be signed\n     * @param keyPair the certified key pair used for signing\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate to embed.\n     *                            If null, no certificate are embedded with the signature.\n     * @param embedContent if true, the signed content is embedded with the signature.\n     * @return the resulting signature encoded ASN.1 and in accordance with RFC 3852.\n     * @throws GeneralSecurityException on error.\n     */\n    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,\n        boolean embedContent) throws GeneralSecurityException\n    {\n        return cmsSign(data, keyPair, certificateProvider, null, embedContent);\n    }\n\n    /**\n     * Generate a CMS (Cryptographic Message Syntax) signature for a given byte content. The resulting signature\n     * might contains the content itself and the certificate chain of the key used to sign.\n     *\n     * @param data the data to be signed\n     * @param keyPair the certified key pair used for signing\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate to embed.\n     *                            If null, no certificate are embedded with the signature.\n     * @param existingSignature if not null, a existing signature on the same data that should be kept.\n     * @param embedContent if true, the signed content is embedded with the signature.\n     * @return the resulting signature encoded ASN.1 and in accordance with RFC 3852.\n     * @throws GeneralSecurityException on error.\n     */\n    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,\n        CMSSignedDataVerified existingSignature, boolean embedContent) throws GeneralSecurityException\n    {\n        CMSSignedDataGeneratorParameters parameters = new CMSSignedDataGeneratorParameters()\n            .addSigner(CertifyingSigner.getInstance(true, keyPair, signerFactory));\n\n        if (existingSignature != null) {\n            for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {\n                parameters.addSignature(existingSigner);\n            }\n        }\n\n        Set<CertifiedPublicKey> certs = new HashSet<>();\n        if (existingSignature != null && existingSignature.getCertificates() != null) {\n            certs.addAll(existingSignature.getCertificates());\n        }\n\n        if (certificateProvider != null) {\n            if (existingSignature != null) {\n                for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {\n                    if (existingSigner.getSubjectKeyIdentifier() != null) {\n                        addCertificateChain(\n                            certificateProvider.getCertificate(existingSigner.getSubjectKeyIdentifier()),\n                            certificateProvider, certs);\n                    } else {\n                        addCertificateChain(\n                            certificateProvider.getCertificate(existingSigner.getIssuer(),\n                                existingSigner.getSerialNumber()),\n                            certificateProvider, certs);\n                    }\n                }\n            }\n\n            addCertificateChain(keyPair.getCertificate(), certificateProvider, certs);\n        }\n\n        if (!certs.isEmpty()) {\n            parameters.addCertificates(certs);\n        }\n\n        return cmsSignedDataGenerator.generate(data, parameters, embedContent);\n    }\n\n    private void addCertificateChain(CertifiedPublicKey certificate, CertificateProvider certificateProvider,\n        Collection<CertifiedPublicKey> certs)\n    {\n        Collection<CertifiedPublicKey> chain = certificateChainBuilder.build(certificate, certificateProvider);\n        if (chain != null) {\n            certs.addAll(chain);\n        }\n    }\n\n    /**\n     * Verify a CMS signature with embedded content and containing all the certificate required for validation.\n     *\n     * @param signature the CMS signature to verify. The signature should have the signed content embedded as well as\n     *                  all the certificates for the signers.\n     * @return result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature);\n    }\n\n    /**\n     * Verify a CMS signature without embedded content but containing all the certificate required for validation.\n     *\n     * @param signature the CMS signature to verify.\n     * @param data the content to verify the signature against, or null of the content is embedded in the signature.\n     * @return a the result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature, data);\n    }\n\n    /**\n     * Verify a CMS signature with embedded content, but requiring external certificates to be validated.\n     *\n     * @param signature the CMS signature to verify.\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate for\n     *                            verifying the signatures. If null, certificat should all be embedded in the signature.\n     * @return a the result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature, CertificateProvider certificateProvider)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature, certificateProvider);\n    }\n\n    /**\n     * Verify a CMS signature without embedded content, and requiring external certificates to be validated.\n     *\n     * @param signature the CMS signature to verify.\n     * @param data the content to verify the signature against, or null of the content is embedded in the signature.\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate for\n     *                            verifying the signatures. If null, certificat should all be embedded in the signature.\n     * @return a the result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data, CertificateProvider certificateProvider)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature, data, certificateProvider);\n    }\n\n    /**\n     * Check that an X509 certificate chain is complete and valid now.\n     *\n     * @param chain the ordered chain of certificate starting from root CA.\n     * @return true if the chain is a X509 certificate chain complete and valid on the given date.\n     */\n    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain)\n    {\n        return checkX509CertificateChainValidity(chain, null);\n    }\n\n    /**\n     * Check that an X509 certificate chain is complete and is valid on a given date.\n     *\n     * @param chain the ordered chain of certificate starting from root CA.\n     * @param date the date to check the validity for, or null to check for now.\n     * @return true if the chain is a X509 certificate chain complete and valid on the given date.\n     */\n    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain, Date date)\n    {\n        if (chain == null || chain.isEmpty()) {\n            return false;\n        }\n\n        Date checkDate = (date != null) ? date : new Date();\n        boolean rootExpected = true;\n        for (CertifiedPublicKey cert : chain) {\n            if (!(cert instanceof X509CertifiedPublicKey)) {\n                return false;\n            }\n            if (rootExpected) {\n                if (!((X509CertifiedPublicKey) cert).isRootCA()) {\n                    return false;\n                }\n                rootExpected = false;\n            }\n            if (!((X509CertifiedPublicKey) cert).isValidOn(checkDate)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.crypto.script;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.GeneralSecurityException;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.crypto.KeyPairGenerator;\nimport org.xwiki.crypto.params.cipher.asymmetric.AsymmetricKeyPair;\nimport org.xwiki.crypto.params.cipher.asymmetric.PrivateKeyParameters;\nimport org.xwiki.crypto.params.cipher.asymmetric.PublicKeyParameters;\nimport org.xwiki.crypto.params.generator.asymmetric.RSAKeyGenerationParameters;\nimport org.xwiki.crypto.pkix.CertificateChainBuilder;\nimport org.xwiki.crypto.pkix.CertificateGeneratorFactory;\nimport org.xwiki.crypto.pkix.CertificateProvider;\nimport org.xwiki.crypto.pkix.CertifyingSigner;\nimport org.xwiki.crypto.pkix.X509ExtensionBuilder;\nimport org.xwiki.crypto.pkix.params.CertifiedKeyPair;\nimport org.xwiki.crypto.pkix.params.CertifiedPublicKey;\nimport org.xwiki.crypto.pkix.params.x509certificate.DistinguishedName;\nimport org.xwiki.crypto.pkix.params.x509certificate.X509CertificateGenerationParameters;\nimport org.xwiki.crypto.pkix.params.x509certificate.X509CertificateParameters;\nimport org.xwiki.crypto.pkix.params.x509certificate.X509CertifiedPublicKey;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.ExtendedKeyUsages;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.KeyUsage;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509DnsName;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509GeneralName;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509IpAddress;\nimport org.xwiki.crypto.pkix.params.x509certificate.extension.X509Rfc822Name;\nimport org.xwiki.crypto.signer.CMSSignedDataGenerator;\nimport org.xwiki.crypto.signer.CMSSignedDataVerifier;\nimport org.xwiki.crypto.signer.SignerFactory;\nimport org.xwiki.crypto.signer.param.CMSSignedDataGeneratorParameters;\nimport org.xwiki.crypto.signer.param.CMSSignedDataVerified;\nimport org.xwiki.crypto.signer.param.CMSSignerInfo;\nimport org.xwiki.script.service.ScriptService;\n\n/**\n * Script service allowing a user to create keys pairs and issue certificates.\n *\n * @version $Id$\n * @since 8.4RC1\n */\n@Component\n@Named(CryptoScriptService.ROLEHINT + '.' + RSACryptoScriptService.ROLEHINT)\n@Singleton\npublic class RSACryptoScriptService implements ScriptService\n{\n    /**\n     * The role hint of this component.\n     */\n    public static final String ROLEHINT = \"rsa\";\n\n    @Inject\n    @Named(\"RSA\")\n    private KeyPairGenerator keyPairGenerator;\n\n    @Inject\n    @Named(\"SHA256withRSAEncryption\")\n    private SignerFactory signerFactory;\n\n    @Inject\n    private Provider<X509ExtensionBuilder> extensionBuilder;\n\n    @Inject\n    @Named(\"X509\")\n    private CertificateGeneratorFactory certificateGeneratorFactory;\n\n    @Inject\n    private CMSSignedDataGenerator cmsSignedDataGenerator;\n\n    @Inject\n    @Named(\"X509\")\n    private CertificateChainBuilder certificateChainBuilder;\n\n    @Inject\n    private CMSSignedDataVerifier cmsSignedDataVerifier;\n\n    /**\n     * Generate a new RSA key pair.\n     *\n     * The key strength will be {@value RSAKeyGenerationParameters#DEFAULT_STRENGTH}.\n     * The key public exponent will be 0x10001.\n     * The probability a chosen prime could not be a real prime will be smaller\n     * than 2^-{@value RSAKeyGenerationParameters#DEFAULT_CERTAINTY}.\n     *\n     * @return an new asymmetric key pair.\n     */\n    public AsymmetricKeyPair generateKeyPair()\n    {\n        return keyPairGenerator.generate();\n    }\n\n    /**\n     * Generate a new RSA key pair of given strength. The strength should be given in number of bytes, so for\n     * a 2048 bits key, you should use 256 (bytes) as the integer parameter. The minimum valid strength is 2.\n     *\n     * The key public exponent will be 0x10001.\n     * The probability a chosen prime could not be a real prime will be smaller\n     * than 2^-{@value RSAKeyGenerationParameters#DEFAULT_CERTAINTY}.\n     *\n     * @param strength the strength in bytes.\n     * @return an new asymmetric key pair.\n     */\n    public AsymmetricKeyPair generateKeyPair(int strength)\n    {\n        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength));\n    }\n\n    /**\n     * Build a new instance with all custom parameters. The strength\n     * should be given in number of bytes, so for a 2048 bits key, you should use 256 (bytes) as the integer parameter.\n     * The minimum valid strength is 2. The exponent should be an odd number. The probability a chosen prime could\n     * not be a real prime will be smaller than 2^certainty.\n     *\n     * @param strength the key strength in bytes.\n     * @param publicExponent the public exponent.\n     * @param certainty certainty for prime evaluation.\n     *\n     * @return an new asymmetric key pair.\n     */\n    public AsymmetricKeyPair generateKeyPair(int strength, BigInteger publicExponent, int certainty)\n    {\n        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength, publicExponent, certainty));\n    }\n\n    /**\n     * Create a CertifiedKeyPair from a private key and a certificate.\n     *\n     * @param privateKey the private key.\n     * @param certificate the certified public key.\n     * @return a certified key pair.\n     */\n    public CertifiedKeyPair createCertifiedKeyPair(PrivateKeyParameters privateKey, CertifiedPublicKey certificate)\n    {\n        return new CertifiedKeyPair(privateKey, certificate);\n    }\n\n    /**\n     * Create a self-signed certificate for a Root CA.\n     *\n     * @param keyPair the keypair to issue the certificate for and used for signing it.\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedKeyPair issueRootCACertificate(AsymmetricKeyPair keyPair, String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return new CertifiedKeyPair(\n            keyPair.getPrivate(),\n            certificateGeneratorFactory.getInstance(signerFactory.getInstance(true, keyPair.getPrivate()),\n                new X509CertificateGenerationParameters(\n                    validity,\n                    extensionBuilder.get().addBasicConstraints(true)\n                        .addKeyUsage(true, EnumSet.of(KeyUsage.keyCertSign,\n                            KeyUsage.cRLSign))\n                        .build()))\n                .generate(new DistinguishedName(dn), keyPair.getPublic(),\n                    new X509CertificateParameters())\n        );\n    }\n\n    /**\n     * Create an intermediate CA certificate.\n     *\n     * @param issuer the certified keypair for issuing the certificate\n     * @param keyPair the keyPair of the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified keypair.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedKeyPair issueIntermediateCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair,\n        String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return new CertifiedKeyPair(\n            keyPair.getPrivate(),\n            issueIntermediateCertificate(issuer, keyPair.getPublic(), dn, validity)\n        );\n    }\n\n    /**\n     * Create an intermediate CA certificate.\n     *\n     * @param privateKey the private key for signing the certificate\n     * @param issuer the certificate of the issuer of the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueIntermediateCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,\n        PublicKeyParameters publicKey, String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return issueIntermediateCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity);\n    }\n\n    /**\n     * Create an intermediate CA certificate.\n     *\n     * @param issuer the certified keypair for issuing the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueIntermediateCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,\n        String dn, int validity)\n        throws IOException, GeneralSecurityException\n    {\n        return certificateGeneratorFactory.getInstance(\n            CertifyingSigner.getInstance(true, issuer, signerFactory),\n            new X509CertificateGenerationParameters(\n                validity,\n                extensionBuilder.get().addBasicConstraints(0)\n                    .addKeyUsage(EnumSet.of(KeyUsage.keyCertSign,\n                        KeyUsage.cRLSign))\n                    .build()))\n                .generate(new DistinguishedName(dn), publicKey,\n                    new X509CertificateParameters());\n    }\n\n    /**\n     * Create an end entity certificate.\n     *\n     * @param issuer the certified keypair for issuing the certificate\n     * @param keyPair the keyPair of the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @param subjectAltName the alternative names for the certificate\n     * @return a certified keypair.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedKeyPair issueCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair, String dn,\n        int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException\n    {\n        return new CertifiedKeyPair(\n            keyPair.getPrivate(),\n            issueCertificate(issuer, keyPair.getPublic(), dn, validity, subjectAltName)\n        );\n    }\n\n    /**\n     * Create an end entity certificate.\n     *\n     * @param privateKey the private key for signing the certificate\n     * @param issuer the certificate of the issuer of the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @param subjectAltName the alternative names for the certificate\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,\n        PublicKeyParameters publicKey, String dn, int validity, List<X509GeneralName> subjectAltName)\n        throws IOException, GeneralSecurityException\n    {\n        return issueCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity, subjectAltName);\n    }\n\n    /**\n     * Create an end entity certificate. By default, the key can be used for encryption and signing. If the end entity\n     * contains some alternate subject names of type X509Rfc822Name a extended email protection usage is added. If the\n     * end entity contains some alternate subject names of type X509DnsName or X509IpAddress extended server and client\n     * authentication usages are added.\n     *\n     * @param issuer the keypair for issuing the certificate\n     * @param publicKey the public key to certify\n     * @param dn the distinguished name for the new the certificate.\n     * @param validity the validity of the certificate from now in days.\n     * @param subjectAltName the alternative names for the certificate\n     * @return a certified public key.\n     * @throws IOException in case on error while reading the public key.\n     * @throws GeneralSecurityException in case of error.\n     */\n    public CertifiedPublicKey issueCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,\n        String dn, int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException\n    {\n        X509CertificateParameters params;\n        X509ExtensionBuilder builder = extensionBuilder.get().addKeyUsage(EnumSet.of(KeyUsage.digitalSignature,\n            KeyUsage.dataEncipherment));\n\n        if (subjectAltName != null) {\n            params = new X509CertificateParameters(\n                extensionBuilder.get().addSubjectAltName(false, subjectAltName.toArray(new X509GeneralName[]{}))\n                    .build());\n            Set<String> extUsage = new HashSet<>();\n            for (X509GeneralName genName : subjectAltName) {\n                if (genName instanceof X509Rfc822Name) {\n                    extUsage.add(ExtendedKeyUsages.EMAIL_PROTECTION);\n                } else if (genName instanceof X509DnsName || genName instanceof X509IpAddress) {\n                    extUsage.add(ExtendedKeyUsages.SERVER_AUTH);\n                    extUsage.add(ExtendedKeyUsages.CLIENT_AUTH);\n                }\n                builder.addExtendedKeyUsage(false, new ExtendedKeyUsages(extUsage));\n            }\n        } else {\n            params = new X509CertificateParameters();\n        }\n\n\n        return certificateGeneratorFactory.getInstance(\n                CertifyingSigner.getInstance(true, issuer, signerFactory),\n                new X509CertificateGenerationParameters(validity, builder.build()))\n            .generate(new DistinguishedName(dn), publicKey, params);\n    }\n\n    /**\n     * Generate a CMS (Cryptographic Message Syntax) signature for a given byte content. The resulting signature\n     * might contains the content itself.\n     *\n     * @param data the data to be signed\n     * @param keyPair the certified key pair used for signing\n     * @param embedContent if true, the signed content is embedded with the signature.\n     * @return the resulting signature encoded ASN.1 and in accordance with RFC 3852.\n     * @throws GeneralSecurityException on error.\n     */\n    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, boolean embedContent)\n        throws GeneralSecurityException\n    {\n        return cmsSign(data, keyPair, null, null, embedContent);\n    }\n\n    /**\n     * Generate a CMS (Cryptographic Message Syntax) signature for a given byte content. The resulting signature\n     * might contains the content itself and the certificate chain of the key used to sign.\n     *\n     * @param data the data to be signed\n     * @param keyPair the certified key pair used for signing\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate to embed.\n     *                            If null, no certificate are embedded with the signature.\n     * @param embedContent if true, the signed content is embedded with the signature.\n     * @return the resulting signature encoded ASN.1 and in accordance with RFC 3852.\n     * @throws GeneralSecurityException on error.\n     */\n    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,\n        boolean embedContent) throws GeneralSecurityException\n    {\n        return cmsSign(data, keyPair, certificateProvider, null, embedContent);\n    }\n\n    /**\n     * Generate a CMS (Cryptographic Message Syntax) signature for a given byte content. The resulting signature\n     * might contains the content itself and the certificate chain of the key used to sign.\n     *\n     * @param data the data to be signed\n     * @param keyPair the certified key pair used for signing\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate to embed.\n     *                            If null, no certificate are embedded with the signature.\n     * @param existingSignature if not null, a existing signature on the same data that should be kept.\n     * @param embedContent if true, the signed content is embedded with the signature.\n     * @return the resulting signature encoded ASN.1 and in accordance with RFC 3852.\n     * @throws GeneralSecurityException on error.\n     */\n    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,\n        CMSSignedDataVerified existingSignature, boolean embedContent) throws GeneralSecurityException\n    {\n        CMSSignedDataGeneratorParameters parameters = new CMSSignedDataGeneratorParameters()\n            .addSigner(CertifyingSigner.getInstance(true, keyPair, signerFactory));\n\n        if (existingSignature != null) {\n            for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {\n                parameters.addSignature(existingSigner);\n            }\n        }\n\n        Set<CertifiedPublicKey> certs = new HashSet<>();\n        if (existingSignature != null && existingSignature.getCertificates() != null) {\n            certs.addAll(existingSignature.getCertificates());\n        }\n\n        if (certificateProvider != null) {\n            if (existingSignature != null) {\n                for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {\n                    if (existingSigner.getSubjectKeyIdentifier() != null) {\n                        addCertificateChain(\n                            certificateProvider.getCertificate(existingSigner.getSubjectKeyIdentifier()),\n                            certificateProvider, certs);\n                    } else {\n                        addCertificateChain(\n                            certificateProvider.getCertificate(existingSigner.getIssuer(),\n                                existingSigner.getSerialNumber()),\n                            certificateProvider, certs);\n                    }\n                }\n            }\n\n            addCertificateChain(keyPair.getCertificate(), certificateProvider, certs);\n        }\n\n        if (!certs.isEmpty()) {\n            parameters.addCertificates(certs);\n        }\n\n        return cmsSignedDataGenerator.generate(data, parameters, embedContent);\n    }\n\n    private void addCertificateChain(CertifiedPublicKey certificate, CertificateProvider certificateProvider,\n        Collection<CertifiedPublicKey> certs)\n    {\n        Collection<CertifiedPublicKey> chain = certificateChainBuilder.build(certificate, certificateProvider);\n        if (chain != null) {\n            certs.addAll(chain);\n        }\n    }\n\n    /**\n     * Verify a CMS signature with embedded content and containing all the certificate required for validation.\n     *\n     * @param signature the CMS signature to verify. The signature should have the signed content embedded as well as\n     *                  all the certificates for the signers.\n     * @return result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature);\n    }\n\n    /**\n     * Verify a CMS signature without embedded content but containing all the certificate required for validation.\n     *\n     * @param signature the CMS signature to verify.\n     * @param data the content to verify the signature against, or null of the content is embedded in the signature.\n     * @return a the result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature, data);\n    }\n\n    /**\n     * Verify a CMS signature with embedded content, but requiring external certificates to be validated.\n     *\n     * @param signature the CMS signature to verify.\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate for\n     *                            verifying the signatures. If null, certificat should all be embedded in the signature.\n     * @return a the result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature, CertificateProvider certificateProvider)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature, certificateProvider);\n    }\n\n    /**\n     * Verify a CMS signature without embedded content, and requiring external certificates to be validated.\n     *\n     * @param signature the CMS signature to verify.\n     * @param data the content to verify the signature against, or null of the content is embedded in the signature.\n     * @param certificateProvider Optionally, a certificate provider for obtaining the chain of certificate for\n     *                            verifying the signatures. If null, certificat should all be embedded in the signature.\n     * @return a the result of the verification.\n     * @throws GeneralSecurityException on error.\n     */\n    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data, CertificateProvider certificateProvider)\n        throws GeneralSecurityException\n    {\n        return cmsSignedDataVerifier.verify(signature, data, certificateProvider);\n    }\n\n    /**\n     * Check that an X509 certificate chain is complete and valid now.\n     *\n     * @param chain the ordered chain of certificate starting from root CA.\n     * @return true if the chain is a X509 certificate chain complete and valid on the given date.\n     */\n    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain)\n    {\n        return checkX509CertificateChainValidity(chain, null);\n    }\n\n    /**\n     * Check that an X509 certificate chain is complete and is valid on a given date.\n     *\n     * @param chain the ordered chain of certificate starting from root CA.\n     * @param date the date to check the validity for, or null to check for now.\n     * @return true if the chain is a X509 certificate chain complete and valid on the given date.\n     */\n    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain, Date date)\n    {\n        if (chain == null || chain.isEmpty()) {\n            return false;\n        }\n\n        Date checkDate = (date != null) ? date : new Date();\n        boolean rootExpected = true;\n        for (CertifiedPublicKey cert : chain) {\n            if (!(cert instanceof X509CertifiedPublicKey)) {\n                return false;\n            }\n            if (rootExpected) {\n                if (!((X509CertifiedPublicKey) cert).isRootCA()) {\n                    return false;\n                }\n                rootExpected = false;\n            }\n            if (!((X509CertifiedPublicKey) cert).isValidOn(checkDate)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-crypto/xwiki-platform-crypto-script/src/main/java/org/xwiki/crypto/script/RSACryptoScriptService.java"], "buggy_code_start_loc": [89], "buggy_code_end_loc": [90], "fixing_code_start_loc": [89], "fixing_code_end_loc": [90], "type": "CWE-327", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. The XWiki Crypto API will generate X509 certificates signed by default using SHA1 with RSA, which is not considered safe anymore for use in certificate signatures, due to the risk of collisions with SHA1. The problem has been patched in XWiki version 13.10.6, 14.3.1 and 14.4-rc-1. Since then, the Crypto API will generate X509 certificates signed by default using SHA256 with RSA. Administrators are advised to upgrade their XWiki installation to one of the patched versions. If the upgrade is not possible, it is possible to patch the module xwiki-platform-crypto in a local installation by applying the change exposed in 26728f3 and re-compiling the module.", "other": {"cve": {"id": "CVE-2022-29161", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-06T00:15:07.930", "lastModified": "2022-05-17T14:18:01.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. The XWiki Crypto API will generate X509 certificates signed by default using SHA1 with RSA, which is not considered safe anymore for use in certificate signatures, due to the risk of collisions with SHA1. The problem has been patched in XWiki version 13.10.6, 14.3.1 and 14.4-rc-1. Since then, the Crypto API will generate X509 certificates signed by default using SHA256 with RSA. Administrators are advised to upgrade their XWiki installation to one of the patched versions. If the upgrade is not possible, it is possible to patch the module xwiki-platform-crypto in a local installation by applying the change exposed in 26728f3 and re-compiling the module."}, {"lang": "es", "value": "La plataforma XWiki es una plataforma wiki gen\u00e9rica que ofrece servicios de ejecuci\u00f3n para las aplicaciones construidas sobre ella. La API Crypto de XWiki generar\u00e1 certificados X509 firmados por defecto usando SHA1 con RSA, que ya no es considerada segura para su uso en firmas de certificados, debido al riesgo de colisiones con SHA1. El problema ha sido parcheado en versiones 13.10.6, 14.3.1 y 14.4-rc-1 de XWiki. Desde entonces, la Crypto API generar\u00e1 certificados X509 firmados por defecto usando SHA256 con RSA. Es recomendado a administradores que actualicen su instalaci\u00f3n de XWiki a una de las versiones parcheadas. Si la actualizaci\u00f3n no es posible, es posible parchear el m\u00f3dulo xwiki-platform-crypto en una instalaci\u00f3n local al aplicar el cambio expuesto en 26728f3 y volviendo a compilar el m\u00f3dulo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-327"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.10.6", "matchCriteriaId": "5A3B27A3-E526-4110-AB6A-F3643EFF99DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0", "versionEndExcluding": "14.3.1", "matchCriteriaId": "BD2B8B0D-EDA5-4275-B385-2A626EC29FAE"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/26728f3f23658288683667a5182a916c7ecefc52", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-h8v5-p258-pqf4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-19676", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/26728f3f23658288683667a5182a916c7ecefc52"}}