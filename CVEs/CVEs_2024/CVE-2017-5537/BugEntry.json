{"buggy_code": ["# -*- coding: utf-8 -*-\n#\n# Copyright \u00a9 2012 - 2016 Michal \u010ciha\u0159 <michal@cihar.com>\n#\n# This file is part of Weblate <https://weblate.org/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n\"\"\"\nTests for user handling.\n\"\"\"\n\nimport json\n\nimport httpretty\nfrom six.moves.urllib.parse import parse_qs, urlparse\n\nfrom django.contrib.auth.models import User\nfrom django.core.urlresolvers import reverse\nfrom django.core import mail\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\n\nimport social.apps.django_app.utils\n\nfrom weblate.accounts.models import VerifiedEmail\nfrom weblate.trans.tests.test_views import RegistrationTestMixin\nfrom weblate.trans.tests import OverrideSettings\n\nREGISTRATION_DATA = {\n    'username': 'username',\n    'email': 'noreply-weblate@example.org',\n    'first_name': 'First Last',\n    'captcha_id': '00',\n    'captcha': '9999'\n}\n\nGH_BACKENDS = (\n    'weblate.accounts.auth.EmailAuth',\n    'social.backends.github.GithubOAuth2',\n    'weblate.accounts.auth.WeblateUserBackend',\n)\n\n\nclass RegistrationTest(TestCase, RegistrationTestMixin):\n    clear_cookie = False\n\n    def assert_registration(self, match=None):\n        url = self.assert_registration_mailbox(match)\n\n        if self.clear_cookie and 'sessionid' in self.client.cookies:\n            del self.client.cookies['sessionid']\n\n        # Confirm account\n        response = self.client.get(url, follow=True)\n        self.assertRedirects(\n            response,\n            reverse('password')\n        )\n\n    @OverrideSettings(REGISTRATION_CAPTCHA=True)\n    def test_register_captcha(self):\n        # Enable captcha\n\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        self.assertContains(\n            response,\n            'Please check your math and try again.'\n        )\n\n    @OverrideSettings(REGISTRATION_OPEN=False)\n    def test_register_closed(self):\n        # Disable registration\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        self.assertContains(\n            response,\n            'Sorry, but registrations on this site are disabled.'\n        )\n\n    @OverrideSettings(REGISTRATION_OPEN=True)\n    @OverrideSettings(REGISTRATION_CAPTCHA=False)\n    def test_register(self):\n        # Disable captcha\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        # Check we did succeed\n        self.assertRedirects(response, reverse('email-sent'))\n\n        # Confirm account\n        self.assert_registration()\n\n        # Set password\n        response = self.client.post(\n            reverse('password'),\n            {\n                'password1': 'password',\n                'password2': 'password',\n            }\n        )\n        self.assertRedirects(response, reverse('profile'))\n\n        # Check we can access home (was redirected to password change)\n        response = self.client.get(reverse('home'))\n        self.assertContains(response, 'First Last')\n\n        user = User.objects.get(username='username')\n        # Verify user is active\n        self.assertTrue(user.is_active)\n        # Verify stored first/last name\n        self.assertEqual(user.first_name, 'First Last')\n\n    @OverrideSettings(REGISTRATION_OPEN=True)\n    @OverrideSettings(REGISTRATION_CAPTCHA=False)\n    def test_double_register(self):\n        \"\"\"Test double registration from single browser\"\"\"\n\n        # First registration\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        first_url = self.assert_registration_mailbox()\n        mail.outbox.pop()\n\n        # Second registration\n        data = REGISTRATION_DATA.copy()\n        data['email'] = 'noreply@example.net'\n        data['username'] = 'second'\n        response = self.client.post(\n            reverse('register'),\n            data,\n        )\n        second_url = self.assert_registration_mailbox()\n        mail.outbox.pop()\n\n        # Confirm first account\n        response = self.client.get(first_url, follow=True)\n        self.assertRedirects(\n            response,\n            reverse('password')\n        )\n        self.client.get(reverse('logout'))\n\n        # Confirm second account\n        response = self.client.get(second_url, follow=True)\n        self.assertRedirects(\n            response,\n            reverse('password')\n        )\n\n    @OverrideSettings(REGISTRATION_OPEN=True)\n    @OverrideSettings(REGISTRATION_CAPTCHA=False)\n    def test_register_missing(self):\n        # Disable captcha\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        # Check we did succeed\n        self.assertRedirects(response, reverse('email-sent'))\n\n        # Confirm account\n        url = self.assert_registration_mailbox()\n\n        # Remove session ID from URL\n        url = url.split('&id=')[0]\n\n        # Confirm account\n        response = self.client.get(url, follow=True)\n        self.assertRedirects(response, reverse('login'))\n        self.assertContains(response, 'Failed to verify your registration')\n\n    def test_reset(self):\n        '''\n        Test for password reset.\n        '''\n        User.objects.create_user('testuser', 'test@example.com', 'x')\n\n        response = self.client.get(\n            reverse('password_reset'),\n        )\n        self.assertContains(response, 'Reset my password')\n        response = self.client.post(\n            reverse('password_reset'),\n            {\n                'email': 'test@example.com'\n            }\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n\n        self.assert_registration('[Weblate] Password reset on Weblate')\n\n    def test_reset_twice(self):\n        '''\n        Test for password reset.\n        '''\n        User.objects.create_user('testuser', 'test@example.com', 'x')\n        User.objects.create_user('testuser2', 'test2@example.com', 'x')\n\n        response = self.client.post(\n            reverse('password_reset'),\n            {'email': 'test@example.com'}\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n        self.assert_registration('[Weblate] Password reset on Weblate')\n        sent_mail = mail.outbox.pop()\n        self.assertEqual(['test@example.com'], sent_mail.to)\n\n        response = self.client.post(\n            reverse('password_reset'),\n            {'email': 'test2@example.com'}\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n        self.assert_registration('[Weblate] Password reset on Weblate')\n        sent_mail = mail.outbox.pop()\n        self.assertEqual(['test2@example.com'], sent_mail.to)\n\n    def test_wrong_username(self):\n        data = REGISTRATION_DATA.copy()\n        data['username'] = ''\n        response = self.client.post(\n            reverse('register'),\n            data\n        )\n        self.assertContains(\n            response,\n            'This field is required.',\n        )\n\n    def test_wrong_mail(self):\n        data = REGISTRATION_DATA.copy()\n        data['email'] = 'x'\n        response = self.client.post(\n            reverse('register'),\n            data\n        )\n        self.assertContains(\n            response,\n            'Enter a valid email address.'\n        )\n\n    def test_spam(self):\n        data = REGISTRATION_DATA.copy()\n        data['content'] = 'x'\n        response = self.client.post(\n            reverse('register'),\n            data\n        )\n        self.assertContains(\n            response,\n            'Invalid value'\n        )\n\n    def test_add_mail(self):\n        # Create user\n        self.test_register()\n        mail.outbox.pop()\n\n        # Check adding email page\n        response = self.client.get(\n            reverse('email_login')\n        )\n        self.assertContains(response, 'Register email')\n\n        # Try invalid address first\n        response = self.client.post(\n            reverse('email_login'),\n            {'email': 'invalid'},\n        )\n        self.assertContains(response, 'has-error')\n\n        # Add email account\n        response = self.client.post(\n            reverse('email_login'),\n            {'email': 'second@example.net'},\n            follow=True,\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n\n        # Verify confirmation mail\n        url = self.assert_registration_mailbox()\n        response = self.client.get(url, follow=True)\n        self.assertRedirects(\n            response, '{0}#auth'.format(reverse('profile'))\n        )\n\n        # Check database models\n        user = User.objects.get(username='username')\n        self.assertEqual(\n            VerifiedEmail.objects.filter(social__user=user).count(), 2\n        )\n        self.assertTrue(\n            VerifiedEmail.objects.filter(\n                social__user=user, email='second@example.net'\n            ).exists()\n        )\n\n    @httpretty.activate\n    @override_settings(AUTHENTICATION_BACKENDS=GH_BACKENDS)\n    def test_github(self):\n        \"\"\"Test GitHub integration\"\"\"\n        try:\n            # psa creates copy of settings...\n            orig_backends = social.apps.django_app.utils.BACKENDS\n            social.apps.django_app.utils.BACKENDS = GH_BACKENDS\n\n            httpretty.register_uri(\n                httpretty.POST,\n                'https://github.com/login/oauth/access_token',\n                body=json.dumps({\n                    'access_token': '123',\n                    'token_type': 'bearer',\n                })\n            )\n            httpretty.register_uri(\n                httpretty.GET,\n                'https://api.github.com/user',\n                body=json.dumps({\n                    'email': 'foo@example.net',\n                    'login': 'weblate',\n                    'id': 1,\n                    'name': 'Weblate',\n                }),\n            )\n            httpretty.register_uri(\n                httpretty.GET,\n                'https://api.github.com/user/emails',\n                body=json.dumps([\n                    {\n                        'email': 'noreply2@example.org',\n                        'verified': False,\n                        'primary': False,\n                    }, {\n                        'email': 'noreply-weblate@example.org',\n                        'verified': True,\n                        'primary': True\n                    }\n                ])\n            )\n            response = self.client.get(\n                reverse('social:begin', args=('github',))\n            )\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(\n                response['Location'].startswith(\n                    'https://github.com/login/oauth/authorize'\n                )\n            )\n            query = parse_qs(urlparse(response['Location']).query)\n            return_query = parse_qs(urlparse(query['redirect_uri'][0]).query)\n            response = self.client.get(\n                reverse('social:complete', args=('github',)),\n                {\n                    'state': query['state'][0],\n                    'redirect_state': return_query['redirect_state'][0],\n                    'code': 'XXX'\n                },\n                follow=True\n            )\n            user = User.objects.get(username='weblate')\n            self.assertEqual(user.first_name, 'Weblate')\n            self.assertEqual(user.email, 'noreply-weblate@example.org')\n        finally:\n            social.apps.django_app.utils.BACKENDS = orig_backends\n\n\nclass NoCookieRegistrationTest(RegistrationTest):\n    clear_cookie = True\n", "# -*- coding: utf-8 -*-\n#\n# Copyright \u00a9 2012 - 2016 Michal \u010ciha\u0159 <michal@cihar.com>\n#\n# This file is part of Weblate <https://weblate.org/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nfrom __future__ import unicode_literals\n\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom django.http import HttpResponse, HttpResponseRedirect\nfrom django.contrib.auth import logout\nfrom django.conf import settings\nfrom django.utils.translation import ugettext as _\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.mail.message import EmailMultiAlternatives\nfrom django.utils import translation\nfrom django.utils.cache import patch_response_headers\nfrom django.utils.crypto import get_random_string\nfrom django.utils.translation import get_language\nfrom django.contrib.auth.models import User\nfrom django.contrib.auth import views as auth_views\nfrom django.views.generic import TemplateView\nfrom django.contrib.auth import update_session_auth_hash\nfrom django.core.urlresolvers import reverse\n\nfrom rest_framework.authtoken.models import Token\n\nfrom six.moves.urllib.parse import urlencode\n\nfrom social.backends.utils import load_backends\nfrom social.apps.django_app.utils import BACKENDS\nfrom social.apps.django_app.views import complete\n\nfrom weblate.accounts.forms import (\n    RegistrationForm, PasswordForm, PasswordChangeForm, EmailForm, ResetForm,\n    LoginForm, HostingForm, CaptchaRegistrationForm\n)\nfrom weblate.logger import LOGGER\nfrom weblate.accounts.avatar import get_avatar_image, get_fallback_avatar_url\nfrom weblate.accounts.models import set_lang, remove_user, Profile\nfrom weblate.trans import messages\nfrom weblate.trans.models import Change, Project, SubProject\nfrom weblate.trans.views.helper import get_project\nfrom weblate.accounts.forms import (\n    ProfileForm, SubscriptionForm, UserForm, ContactForm,\n    SubscriptionSettingsForm, UserSettingsForm, DashboardSettingsForm\n)\nfrom weblate import appsettings\n\nCONTACT_TEMPLATE = '''\nMessage from %(name)s <%(email)s>:\n\n%(message)s\n'''\n\nHOSTING_TEMPLATE = '''\n%(name)s <%(email)s> wants to host %(project)s\n\nProject:    %(project)s\nWebsite:    %(url)s\nRepository: %(repo)s\nFilemask:   %(mask)s\nUsername:   %(username)s\n\nAdditional message:\n\n%(message)s\n'''\n\n\nclass RegistrationTemplateView(TemplateView):\n    '''\n    Class for rendering registration pages.\n    '''\n    def get_context_data(self, **kwargs):\n        '''\n        Creates context for rendering page.\n        '''\n        context = super(RegistrationTemplateView, self).get_context_data(\n            **kwargs\n        )\n        context['title'] = _('User registration')\n        return context\n\n\ndef mail_admins_contact(request, subject, message, context, sender):\n    '''\n    Sends a message to the admins, as defined by the ADMINS setting.\n    '''\n    LOGGER.info(\n        'contact form from %s',\n        sender,\n    )\n    if not settings.ADMINS:\n        messages.error(\n            request,\n            _('Message could not be sent to administrator!')\n        )\n        LOGGER.error(\n            'ADMINS not configured, can not send message!'\n        )\n        return\n\n    mail = EmailMultiAlternatives(\n        '%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject % context),\n        message % context,\n        to=[a[1] for a in settings.ADMINS],\n        headers={'Reply-To': sender},\n    )\n\n    mail.send(fail_silently=False)\n\n    messages.success(\n        request,\n        _('Message has been sent to administrator.')\n    )\n\n\ndef deny_demo(request):\n    \"\"\"\n    Denies editing of demo account on demo server.\n    \"\"\"\n    messages.warning(\n        request,\n        _('You cannot change demo account on the demo server.')\n    )\n    return redirect_profile(request.POST.get('activetab'))\n\n\ndef redirect_profile(page=''):\n    url = reverse('profile')\n    if page and page.startswith('#'):\n        url = url + page\n    return HttpResponseRedirect(url)\n\n\n@login_required\ndef user_profile(request):\n\n    profile = request.user.profile\n\n    if not profile.language:\n        profile.language = get_language()\n        profile.save()\n\n    form_classes = [\n        ProfileForm,\n        SubscriptionForm,\n        SubscriptionSettingsForm,\n        UserSettingsForm,\n        DashboardSettingsForm,\n    ]\n\n    if request.method == 'POST':\n        # Parse POST params\n        forms = [form(request.POST, instance=profile) for form in form_classes]\n        forms.append(UserForm(request.POST, instance=request.user))\n\n        if appsettings.DEMO_SERVER and request.user.username == 'demo':\n            return deny_demo(request)\n\n        if all([form.is_valid() for form in forms]):\n            # Save changes\n            for form in forms:\n                form.save()\n\n            # Change language\n            set_lang(request, request.user.profile)\n\n            # Redirect after saving (and possibly changing language)\n            response = redirect_profile(request.POST.get('activetab'))\n\n            # Set language cookie and activate new language (for message below)\n            lang_code = profile.language\n            response.set_cookie(settings.LANGUAGE_COOKIE_NAME, lang_code)\n            translation.activate(lang_code)\n\n            messages.success(request, _('Your profile has been updated.'))\n\n            return response\n    else:\n        forms = [form(instance=profile) for form in form_classes]\n        forms.append(UserForm(instance=request.user))\n\n    social = request.user.social_auth.all()\n    social_names = [assoc.provider for assoc in social]\n    all_backends = set(load_backends(BACKENDS).keys())\n    new_backends = [\n        x for x in all_backends\n        if x == 'email' or x not in social_names\n    ]\n    license_projects = SubProject.objects.filter(\n        project__in=Project.objects.all_acl(request.user)\n    ).exclude(\n        license=''\n    )\n\n    result = render(\n        request,\n        'accounts/profile.html',\n        {\n            'form': forms[0],\n            'subscriptionform': forms[1],\n            'subscriptionsettingsform': forms[2],\n            'usersettingsform': forms[3],\n            'dashboardsettingsform': forms[4],\n            'userform': forms[5],\n            'profile': profile,\n            'title': _('User profile'),\n            'licenses': license_projects,\n            'associated': social,\n            'new_backends': new_backends,\n        }\n    )\n    result.set_cookie(\n        settings.LANGUAGE_COOKIE_NAME,\n        profile.language\n    )\n    return result\n\n\n@login_required\ndef user_remove(request):\n    if appsettings.DEMO_SERVER and request.user.username == 'demo':\n        return deny_demo(request)\n\n    if request.method == 'POST':\n        remove_user(request.user)\n\n        logout(request)\n\n        messages.success(\n            request,\n            _('Your account has been removed.')\n        )\n\n        return redirect('home')\n\n    return render(\n        request,\n        'accounts/removal.html',\n    )\n\n\ndef get_initial_contact(request):\n    '''\n    Fills in initial contact form fields from request.\n    '''\n    initial = {}\n    if request.user.is_authenticated():\n        initial['name'] = request.user.first_name\n        initial['email'] = request.user.email\n    return initial\n\n\ndef contact(request):\n    if request.method == 'POST':\n        form = ContactForm(request.POST)\n        if form.is_valid():\n            mail_admins_contact(\n                request,\n                '%(subject)s',\n                CONTACT_TEMPLATE,\n                form.cleaned_data,\n                form.cleaned_data['email'],\n            )\n            return redirect('home')\n    else:\n        initial = get_initial_contact(request)\n        if 'subject' in request.GET:\n            initial['subject'] = request.GET['subject']\n        form = ContactForm(initial=initial)\n\n    return render(\n        request,\n        'accounts/contact.html',\n        {\n            'form': form,\n            'title': _('Contact'),\n        }\n    )\n\n\n@login_required\ndef hosting(request):\n    '''\n    Form for hosting request.\n    '''\n    if not appsettings.OFFER_HOSTING:\n        return redirect('home')\n\n    if request.method == 'POST':\n        form = HostingForm(request.POST)\n        if form.is_valid():\n            context = form.cleaned_data\n            context['username'] = request.user.username\n            mail_admins_contact(\n                request,\n                'Hosting request for %(project)s',\n                HOSTING_TEMPLATE,\n                context,\n                form.cleaned_data['email'],\n            )\n            return redirect('home')\n    else:\n        initial = get_initial_contact(request)\n        form = HostingForm(initial=initial)\n\n    return render(\n        request,\n        'accounts/hosting.html',\n        {\n            'form': form,\n            'title': _('Hosting'),\n        }\n    )\n\n\ndef user_page(request, user):\n    '''\n    User details page.\n    '''\n    user = get_object_or_404(User, username=user)\n    profile = Profile.objects.get_or_create(user=user)[0]\n\n    # Filter all user activity\n    all_changes = Change.objects.last_changes(request.user).filter(\n        user=user,\n    )\n\n    # Last user activity\n    last_changes = all_changes[:10]\n\n    # Filter where project is active\n    user_projects_ids = set(all_changes.values_list(\n        'translation__subproject__project', flat=True\n    ))\n    user_projects = Project.objects.filter(id__in=user_projects_ids)\n\n    return render(\n        request,\n        'accounts/user.html',\n        {\n            'page_profile': profile,\n            'page_user': user,\n            'last_changes': last_changes,\n            'last_changes_url': urlencode(\n                {'user': user.username.encode('utf-8')}\n            ),\n            'user_projects': user_projects,\n        }\n    )\n\n\ndef user_avatar(request, user, size):\n    '''\n    User avatar page.\n    '''\n    user = get_object_or_404(User, username=user)\n\n    if user.email == 'noreply@weblate.org':\n        return redirect(get_fallback_avatar_url(size))\n\n    response = HttpResponse(\n        content_type='image/png',\n        content=get_avatar_image(request, user, size)\n    )\n\n    patch_response_headers(response, 3600 * 24 * 7)\n\n    return response\n\n\ndef weblate_login(request):\n    '''\n    Login handler, just wrapper around login.\n    '''\n\n    # Redirect logged in users to profile\n    if request.user.is_authenticated():\n        return redirect_profile()\n\n    # Redirect if there is only one backend\n    auth_backends = list(load_backends(BACKENDS).keys())\n    if len(auth_backends) == 1 and auth_backends[0] != 'email':\n        return redirect('social:begin', auth_backends[0])\n\n    return auth_views.login(\n        request,\n        template_name='accounts/login.html',\n        authentication_form=LoginForm,\n        extra_context={\n            'login_backends': [\n                x for x in auth_backends if x != 'email'\n            ],\n            'can_reset': 'email' in auth_backends,\n            'title': _('Login'),\n        }\n    )\n\n\n@login_required\ndef weblate_logout(request):\n    '''\n    Logout handler, just wrapper around standard logout.\n    '''\n    messages.info(request, _('Thanks for using Weblate!'))\n\n    return auth_views.logout(\n        request,\n        next_page=reverse('home'),\n    )\n\n\ndef register(request):\n    '''\n    Registration form.\n    '''\n    if appsettings.REGISTRATION_CAPTCHA:\n        form_class = CaptchaRegistrationForm\n    else:\n        form_class = RegistrationForm\n\n    if request.method == 'POST':\n        form = form_class(request.POST)\n        if form.is_valid() and appsettings.REGISTRATION_OPEN:\n            # Ensure we do registration in separate session\n            # not sent to client\n            request.session.create()\n            result = complete(request, 'email')\n            request.session.save()\n            request.session = None\n            return result\n    else:\n        form = form_class()\n\n    backends = set(load_backends(BACKENDS).keys())\n\n    # Redirect if there is only one backend\n    if len(backends) == 1 and 'email' not in backends:\n        return redirect('social:begin', backends.pop())\n\n    return render(\n        request,\n        'accounts/register.html',\n        {\n            'registration_email': 'email' in backends,\n            'registration_backends': backends - set(['email']),\n            'title': _('User registration'),\n            'form': form,\n        }\n    )\n\n\n@login_required\ndef email_login(request):\n    '''\n    Connect email.\n    '''\n    if request.method == 'POST':\n        form = EmailForm(request.POST)\n        if form.is_valid():\n            return complete(request, 'email')\n    else:\n        form = EmailForm()\n\n    return render(\n        request,\n        'accounts/email.html',\n        {\n            'title': _('Register email'),\n            'form': form,\n        }\n    )\n\n\n@login_required\ndef password(request):\n    '''\n    Password change / set form.\n    '''\n    if appsettings.DEMO_SERVER and request.user.username == 'demo':\n        return deny_demo(request)\n\n    do_change = False\n\n    if not request.user.has_usable_password():\n        do_change = True\n        change_form = None\n    elif request.method == 'POST':\n        change_form = PasswordChangeForm(request.POST)\n        if change_form.is_valid():\n            cur_password = change_form.cleaned_data['password']\n            do_change = request.user.check_password(cur_password)\n            if not do_change:\n                messages.error(\n                    request,\n                    _('You have entered an invalid password.')\n                )\n    else:\n        change_form = PasswordChangeForm()\n\n    if request.method == 'POST':\n        form = PasswordForm(request.POST)\n        if form.is_valid() and do_change:\n\n            # Clear flag forcing user to set password\n            redirect_page = '#auth'\n            if 'show_set_password' in request.session:\n                del request.session['show_set_password']\n                redirect_page = ''\n\n            request.user.set_password(\n                form.cleaned_data['password1']\n            )\n            request.user.save()\n\n            # Update session hash\n            update_session_auth_hash(request, request.user)\n\n            messages.success(\n                request,\n                _('Your password has been changed.')\n            )\n            return redirect_profile(redirect_page)\n    else:\n        form = PasswordForm()\n\n    return render(\n        request,\n        'accounts/password.html',\n        {\n            'title': _('Change password'),\n            'change_form': change_form,\n            'form': form,\n        }\n    )\n\n\ndef reset_password(request):\n    '''\n    Password reset handling.\n    '''\n    if 'email' not in load_backends(BACKENDS).keys():\n        messages.error(\n            request,\n            _('Can not reset password, email authentication is disabled!')\n        )\n        return redirect('login')\n\n    if request.method == 'POST':\n        form = ResetForm(request.POST)\n        if form.is_valid():\n            # Force creating new session\n            request.session.create()\n            if request.user.is_authenticated():\n                logout(request)\n\n            request.session['password_reset'] = True\n            return complete(request, 'email')\n    else:\n        form = ResetForm()\n\n    return render(\n        request,\n        'accounts/reset.html',\n        {\n            'title': _('Password reset'),\n            'form': form,\n        }\n    )\n\n\n@login_required\ndef reset_api_key(request):\n    \"\"\"Resets user API key\"\"\"\n    request.user.auth_token.delete()\n    Token.objects.create(\n        user=request.user,\n        key=get_random_string(40)\n    )\n\n    return redirect_profile('#api')\n\n\n@login_required\ndef watch(request, project):\n    obj = get_project(request, project)\n    request.user.profile.subscriptions.add(obj)\n    return redirect(obj)\n\n\n@login_required\ndef unwatch(request, project):\n    obj = get_project(request, project)\n    request.user.profile.subscriptions.remove(obj)\n    return redirect(obj)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#\n# Copyright \u00a9 2012 - 2016 Michal \u010ciha\u0159 <michal@cihar.com>\n#\n# This file is part of Weblate <https://weblate.org/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n\"\"\"\nTests for user handling.\n\"\"\"\n\nimport json\n\nimport httpretty\nfrom six.moves.urllib.parse import parse_qs, urlparse\n\nfrom django.contrib.auth.models import User\nfrom django.core.urlresolvers import reverse\nfrom django.core import mail\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\n\nimport social.apps.django_app.utils\n\nfrom weblate.accounts.models import VerifiedEmail\nfrom weblate.trans.tests.test_views import RegistrationTestMixin\nfrom weblate.trans.tests import OverrideSettings\n\nREGISTRATION_DATA = {\n    'username': 'username',\n    'email': 'noreply-weblate@example.org',\n    'first_name': 'First Last',\n    'captcha_id': '00',\n    'captcha': '9999'\n}\n\nGH_BACKENDS = (\n    'weblate.accounts.auth.EmailAuth',\n    'social.backends.github.GithubOAuth2',\n    'weblate.accounts.auth.WeblateUserBackend',\n)\n\n\nclass RegistrationTest(TestCase, RegistrationTestMixin):\n    clear_cookie = False\n\n    def assert_registration(self, match=None):\n        url = self.assert_registration_mailbox(match)\n\n        if self.clear_cookie and 'sessionid' in self.client.cookies:\n            del self.client.cookies['sessionid']\n\n        # Confirm account\n        response = self.client.get(url, follow=True)\n        self.assertRedirects(\n            response,\n            reverse('password')\n        )\n\n    @OverrideSettings(REGISTRATION_CAPTCHA=True)\n    def test_register_captcha(self):\n        # Enable captcha\n\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        self.assertContains(\n            response,\n            'Please check your math and try again.'\n        )\n\n    @OverrideSettings(REGISTRATION_OPEN=False)\n    def test_register_closed(self):\n        # Disable registration\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        self.assertContains(\n            response,\n            'Sorry, but registrations on this site are disabled.'\n        )\n\n    @OverrideSettings(REGISTRATION_OPEN=True)\n    @OverrideSettings(REGISTRATION_CAPTCHA=False)\n    def test_register(self):\n        # Disable captcha\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        # Check we did succeed\n        self.assertRedirects(response, reverse('email-sent'))\n\n        # Confirm account\n        self.assert_registration()\n\n        # Set password\n        response = self.client.post(\n            reverse('password'),\n            {\n                'password1': 'password',\n                'password2': 'password',\n            }\n        )\n        self.assertRedirects(response, reverse('profile'))\n\n        # Check we can access home (was redirected to password change)\n        response = self.client.get(reverse('home'))\n        self.assertContains(response, 'First Last')\n\n        user = User.objects.get(username='username')\n        # Verify user is active\n        self.assertTrue(user.is_active)\n        # Verify stored first/last name\n        self.assertEqual(user.first_name, 'First Last')\n\n    @OverrideSettings(REGISTRATION_OPEN=True)\n    @OverrideSettings(REGISTRATION_CAPTCHA=False)\n    def test_double_register(self):\n        \"\"\"Test double registration from single browser\"\"\"\n\n        # First registration\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        first_url = self.assert_registration_mailbox()\n        mail.outbox.pop()\n\n        # Second registration\n        data = REGISTRATION_DATA.copy()\n        data['email'] = 'noreply@example.net'\n        data['username'] = 'second'\n        response = self.client.post(\n            reverse('register'),\n            data,\n        )\n        second_url = self.assert_registration_mailbox()\n        mail.outbox.pop()\n\n        # Confirm first account\n        response = self.client.get(first_url, follow=True)\n        self.assertRedirects(\n            response,\n            reverse('password')\n        )\n        self.client.get(reverse('logout'))\n\n        # Confirm second account\n        response = self.client.get(second_url, follow=True)\n        self.assertRedirects(\n            response,\n            reverse('password')\n        )\n\n    @OverrideSettings(REGISTRATION_OPEN=True)\n    @OverrideSettings(REGISTRATION_CAPTCHA=False)\n    def test_register_missing(self):\n        # Disable captcha\n        response = self.client.post(\n            reverse('register'),\n            REGISTRATION_DATA\n        )\n        # Check we did succeed\n        self.assertRedirects(response, reverse('email-sent'))\n\n        # Confirm account\n        url = self.assert_registration_mailbox()\n\n        # Remove session ID from URL\n        url = url.split('&id=')[0]\n\n        # Confirm account\n        response = self.client.get(url, follow=True)\n        self.assertRedirects(response, reverse('login'))\n        self.assertContains(response, 'Failed to verify your registration')\n\n    def test_reset(self):\n        '''\n        Test for password reset.\n        '''\n        User.objects.create_user('testuser', 'test@example.com', 'x')\n\n        response = self.client.get(\n            reverse('password_reset'),\n        )\n        self.assertContains(response, 'Reset my password')\n        response = self.client.post(\n            reverse('password_reset'),\n            {\n                'email': 'test@example.com'\n            }\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n\n        self.assert_registration('[Weblate] Password reset on Weblate')\n\n    def test_reset_nonexisting(self):\n        '''\n        Test for password reset.\n        '''\n        response = self.client.get(\n            reverse('password_reset'),\n        )\n        self.assertContains(response, 'Reset my password')\n        response = self.client.post(\n            reverse('password_reset'),\n            {\n                'email': 'test@example.com'\n            }\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_reset_twice(self):\n        '''\n        Test for password reset.\n        '''\n        User.objects.create_user('testuser', 'test@example.com', 'x')\n        User.objects.create_user('testuser2', 'test2@example.com', 'x')\n\n        response = self.client.post(\n            reverse('password_reset'),\n            {'email': 'test@example.com'}\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n        self.assert_registration('[Weblate] Password reset on Weblate')\n        sent_mail = mail.outbox.pop()\n        self.assertEqual(['test@example.com'], sent_mail.to)\n\n        response = self.client.post(\n            reverse('password_reset'),\n            {'email': 'test2@example.com'}\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n        self.assert_registration('[Weblate] Password reset on Weblate')\n        sent_mail = mail.outbox.pop()\n        self.assertEqual(['test2@example.com'], sent_mail.to)\n\n    def test_wrong_username(self):\n        data = REGISTRATION_DATA.copy()\n        data['username'] = ''\n        response = self.client.post(\n            reverse('register'),\n            data\n        )\n        self.assertContains(\n            response,\n            'This field is required.',\n        )\n\n    def test_wrong_mail(self):\n        data = REGISTRATION_DATA.copy()\n        data['email'] = 'x'\n        response = self.client.post(\n            reverse('register'),\n            data\n        )\n        self.assertContains(\n            response,\n            'Enter a valid email address.'\n        )\n\n    def test_spam(self):\n        data = REGISTRATION_DATA.copy()\n        data['content'] = 'x'\n        response = self.client.post(\n            reverse('register'),\n            data\n        )\n        self.assertContains(\n            response,\n            'Invalid value'\n        )\n\n    def test_add_mail(self):\n        # Create user\n        self.test_register()\n        mail.outbox.pop()\n\n        # Check adding email page\n        response = self.client.get(\n            reverse('email_login')\n        )\n        self.assertContains(response, 'Register email')\n\n        # Try invalid address first\n        response = self.client.post(\n            reverse('email_login'),\n            {'email': 'invalid'},\n        )\n        self.assertContains(response, 'has-error')\n\n        # Add email account\n        response = self.client.post(\n            reverse('email_login'),\n            {'email': 'second@example.net'},\n            follow=True,\n        )\n        self.assertRedirects(response, reverse('email-sent'))\n\n        # Verify confirmation mail\n        url = self.assert_registration_mailbox()\n        response = self.client.get(url, follow=True)\n        self.assertRedirects(\n            response, '{0}#auth'.format(reverse('profile'))\n        )\n\n        # Check database models\n        user = User.objects.get(username='username')\n        self.assertEqual(\n            VerifiedEmail.objects.filter(social__user=user).count(), 2\n        )\n        self.assertTrue(\n            VerifiedEmail.objects.filter(\n                social__user=user, email='second@example.net'\n            ).exists()\n        )\n\n    @httpretty.activate\n    @override_settings(AUTHENTICATION_BACKENDS=GH_BACKENDS)\n    def test_github(self):\n        \"\"\"Test GitHub integration\"\"\"\n        try:\n            # psa creates copy of settings...\n            orig_backends = social.apps.django_app.utils.BACKENDS\n            social.apps.django_app.utils.BACKENDS = GH_BACKENDS\n\n            httpretty.register_uri(\n                httpretty.POST,\n                'https://github.com/login/oauth/access_token',\n                body=json.dumps({\n                    'access_token': '123',\n                    'token_type': 'bearer',\n                })\n            )\n            httpretty.register_uri(\n                httpretty.GET,\n                'https://api.github.com/user',\n                body=json.dumps({\n                    'email': 'foo@example.net',\n                    'login': 'weblate',\n                    'id': 1,\n                    'name': 'Weblate',\n                }),\n            )\n            httpretty.register_uri(\n                httpretty.GET,\n                'https://api.github.com/user/emails',\n                body=json.dumps([\n                    {\n                        'email': 'noreply2@example.org',\n                        'verified': False,\n                        'primary': False,\n                    }, {\n                        'email': 'noreply-weblate@example.org',\n                        'verified': True,\n                        'primary': True\n                    }\n                ])\n            )\n            response = self.client.get(\n                reverse('social:begin', args=('github',))\n            )\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(\n                response['Location'].startswith(\n                    'https://github.com/login/oauth/authorize'\n                )\n            )\n            query = parse_qs(urlparse(response['Location']).query)\n            return_query = parse_qs(urlparse(query['redirect_uri'][0]).query)\n            response = self.client.get(\n                reverse('social:complete', args=('github',)),\n                {\n                    'state': query['state'][0],\n                    'redirect_state': return_query['redirect_state'][0],\n                    'code': 'XXX'\n                },\n                follow=True\n            )\n            user = User.objects.get(username='weblate')\n            self.assertEqual(user.first_name, 'Weblate')\n            self.assertEqual(user.email, 'noreply-weblate@example.org')\n        finally:\n            social.apps.django_app.utils.BACKENDS = orig_backends\n\n\nclass NoCookieRegistrationTest(RegistrationTest):\n    clear_cookie = True\n", "# -*- coding: utf-8 -*-\n#\n# Copyright \u00a9 2012 - 2016 Michal \u010ciha\u0159 <michal@cihar.com>\n#\n# This file is part of Weblate <https://weblate.org/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nfrom __future__ import unicode_literals\n\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom django.http import HttpResponse, HttpResponseRedirect\nfrom django.contrib.auth import logout\nfrom django.conf import settings\nfrom django.utils.translation import ugettext as _\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.mail.message import EmailMultiAlternatives\nfrom django.utils import translation\nfrom django.utils.cache import patch_response_headers\nfrom django.utils.crypto import get_random_string\nfrom django.utils.translation import get_language\nfrom django.contrib.auth.models import User\nfrom django.contrib.auth import views as auth_views\nfrom django.views.generic import TemplateView\nfrom django.contrib.auth import update_session_auth_hash\nfrom django.core.urlresolvers import reverse\n\nfrom rest_framework.authtoken.models import Token\n\nfrom six.moves.urllib.parse import urlencode\n\nfrom social.backends.utils import load_backends\nfrom social.apps.django_app.utils import BACKENDS\nfrom social.apps.django_app.views import complete\n\nfrom weblate.accounts.forms import (\n    RegistrationForm, PasswordForm, PasswordChangeForm, EmailForm, ResetForm,\n    LoginForm, HostingForm, CaptchaRegistrationForm\n)\nfrom weblate.logger import LOGGER\nfrom weblate.accounts.avatar import get_avatar_image, get_fallback_avatar_url\nfrom weblate.accounts.models import set_lang, remove_user, Profile\nfrom weblate.trans import messages\nfrom weblate.trans.models import Change, Project, SubProject\nfrom weblate.trans.views.helper import get_project\nfrom weblate.accounts.forms import (\n    ProfileForm, SubscriptionForm, UserForm, ContactForm,\n    SubscriptionSettingsForm, UserSettingsForm, DashboardSettingsForm\n)\nfrom weblate import appsettings\n\nCONTACT_TEMPLATE = '''\nMessage from %(name)s <%(email)s>:\n\n%(message)s\n'''\n\nHOSTING_TEMPLATE = '''\n%(name)s <%(email)s> wants to host %(project)s\n\nProject:    %(project)s\nWebsite:    %(url)s\nRepository: %(repo)s\nFilemask:   %(mask)s\nUsername:   %(username)s\n\nAdditional message:\n\n%(message)s\n'''\n\n\nclass RegistrationTemplateView(TemplateView):\n    '''\n    Class for rendering registration pages.\n    '''\n    def get_context_data(self, **kwargs):\n        '''\n        Creates context for rendering page.\n        '''\n        context = super(RegistrationTemplateView, self).get_context_data(\n            **kwargs\n        )\n        context['title'] = _('User registration')\n        return context\n\n\ndef mail_admins_contact(request, subject, message, context, sender):\n    '''\n    Sends a message to the admins, as defined by the ADMINS setting.\n    '''\n    LOGGER.info(\n        'contact form from %s',\n        sender,\n    )\n    if not settings.ADMINS:\n        messages.error(\n            request,\n            _('Message could not be sent to administrator!')\n        )\n        LOGGER.error(\n            'ADMINS not configured, can not send message!'\n        )\n        return\n\n    mail = EmailMultiAlternatives(\n        '%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject % context),\n        message % context,\n        to=[a[1] for a in settings.ADMINS],\n        headers={'Reply-To': sender},\n    )\n\n    mail.send(fail_silently=False)\n\n    messages.success(\n        request,\n        _('Message has been sent to administrator.')\n    )\n\n\ndef deny_demo(request):\n    \"\"\"\n    Denies editing of demo account on demo server.\n    \"\"\"\n    messages.warning(\n        request,\n        _('You cannot change demo account on the demo server.')\n    )\n    return redirect_profile(request.POST.get('activetab'))\n\n\ndef redirect_profile(page=''):\n    url = reverse('profile')\n    if page and page.startswith('#'):\n        url = url + page\n    return HttpResponseRedirect(url)\n\n\n@login_required\ndef user_profile(request):\n\n    profile = request.user.profile\n\n    if not profile.language:\n        profile.language = get_language()\n        profile.save()\n\n    form_classes = [\n        ProfileForm,\n        SubscriptionForm,\n        SubscriptionSettingsForm,\n        UserSettingsForm,\n        DashboardSettingsForm,\n    ]\n\n    if request.method == 'POST':\n        # Parse POST params\n        forms = [form(request.POST, instance=profile) for form in form_classes]\n        forms.append(UserForm(request.POST, instance=request.user))\n\n        if appsettings.DEMO_SERVER and request.user.username == 'demo':\n            return deny_demo(request)\n\n        if all([form.is_valid() for form in forms]):\n            # Save changes\n            for form in forms:\n                form.save()\n\n            # Change language\n            set_lang(request, request.user.profile)\n\n            # Redirect after saving (and possibly changing language)\n            response = redirect_profile(request.POST.get('activetab'))\n\n            # Set language cookie and activate new language (for message below)\n            lang_code = profile.language\n            response.set_cookie(settings.LANGUAGE_COOKIE_NAME, lang_code)\n            translation.activate(lang_code)\n\n            messages.success(request, _('Your profile has been updated.'))\n\n            return response\n    else:\n        forms = [form(instance=profile) for form in form_classes]\n        forms.append(UserForm(instance=request.user))\n\n    social = request.user.social_auth.all()\n    social_names = [assoc.provider for assoc in social]\n    all_backends = set(load_backends(BACKENDS).keys())\n    new_backends = [\n        x for x in all_backends\n        if x == 'email' or x not in social_names\n    ]\n    license_projects = SubProject.objects.filter(\n        project__in=Project.objects.all_acl(request.user)\n    ).exclude(\n        license=''\n    )\n\n    result = render(\n        request,\n        'accounts/profile.html',\n        {\n            'form': forms[0],\n            'subscriptionform': forms[1],\n            'subscriptionsettingsform': forms[2],\n            'usersettingsform': forms[3],\n            'dashboardsettingsform': forms[4],\n            'userform': forms[5],\n            'profile': profile,\n            'title': _('User profile'),\n            'licenses': license_projects,\n            'associated': social,\n            'new_backends': new_backends,\n        }\n    )\n    result.set_cookie(\n        settings.LANGUAGE_COOKIE_NAME,\n        profile.language\n    )\n    return result\n\n\n@login_required\ndef user_remove(request):\n    if appsettings.DEMO_SERVER and request.user.username == 'demo':\n        return deny_demo(request)\n\n    if request.method == 'POST':\n        remove_user(request.user)\n\n        logout(request)\n\n        messages.success(\n            request,\n            _('Your account has been removed.')\n        )\n\n        return redirect('home')\n\n    return render(\n        request,\n        'accounts/removal.html',\n    )\n\n\ndef get_initial_contact(request):\n    '''\n    Fills in initial contact form fields from request.\n    '''\n    initial = {}\n    if request.user.is_authenticated():\n        initial['name'] = request.user.first_name\n        initial['email'] = request.user.email\n    return initial\n\n\ndef contact(request):\n    if request.method == 'POST':\n        form = ContactForm(request.POST)\n        if form.is_valid():\n            mail_admins_contact(\n                request,\n                '%(subject)s',\n                CONTACT_TEMPLATE,\n                form.cleaned_data,\n                form.cleaned_data['email'],\n            )\n            return redirect('home')\n    else:\n        initial = get_initial_contact(request)\n        if 'subject' in request.GET:\n            initial['subject'] = request.GET['subject']\n        form = ContactForm(initial=initial)\n\n    return render(\n        request,\n        'accounts/contact.html',\n        {\n            'form': form,\n            'title': _('Contact'),\n        }\n    )\n\n\n@login_required\ndef hosting(request):\n    '''\n    Form for hosting request.\n    '''\n    if not appsettings.OFFER_HOSTING:\n        return redirect('home')\n\n    if request.method == 'POST':\n        form = HostingForm(request.POST)\n        if form.is_valid():\n            context = form.cleaned_data\n            context['username'] = request.user.username\n            mail_admins_contact(\n                request,\n                'Hosting request for %(project)s',\n                HOSTING_TEMPLATE,\n                context,\n                form.cleaned_data['email'],\n            )\n            return redirect('home')\n    else:\n        initial = get_initial_contact(request)\n        form = HostingForm(initial=initial)\n\n    return render(\n        request,\n        'accounts/hosting.html',\n        {\n            'form': form,\n            'title': _('Hosting'),\n        }\n    )\n\n\ndef user_page(request, user):\n    '''\n    User details page.\n    '''\n    user = get_object_or_404(User, username=user)\n    profile = Profile.objects.get_or_create(user=user)[0]\n\n    # Filter all user activity\n    all_changes = Change.objects.last_changes(request.user).filter(\n        user=user,\n    )\n\n    # Last user activity\n    last_changes = all_changes[:10]\n\n    # Filter where project is active\n    user_projects_ids = set(all_changes.values_list(\n        'translation__subproject__project', flat=True\n    ))\n    user_projects = Project.objects.filter(id__in=user_projects_ids)\n\n    return render(\n        request,\n        'accounts/user.html',\n        {\n            'page_profile': profile,\n            'page_user': user,\n            'last_changes': last_changes,\n            'last_changes_url': urlencode(\n                {'user': user.username.encode('utf-8')}\n            ),\n            'user_projects': user_projects,\n        }\n    )\n\n\ndef user_avatar(request, user, size):\n    '''\n    User avatar page.\n    '''\n    user = get_object_or_404(User, username=user)\n\n    if user.email == 'noreply@weblate.org':\n        return redirect(get_fallback_avatar_url(size))\n\n    response = HttpResponse(\n        content_type='image/png',\n        content=get_avatar_image(request, user, size)\n    )\n\n    patch_response_headers(response, 3600 * 24 * 7)\n\n    return response\n\n\ndef weblate_login(request):\n    '''\n    Login handler, just wrapper around login.\n    '''\n\n    # Redirect logged in users to profile\n    if request.user.is_authenticated():\n        return redirect_profile()\n\n    # Redirect if there is only one backend\n    auth_backends = list(load_backends(BACKENDS).keys())\n    if len(auth_backends) == 1 and auth_backends[0] != 'email':\n        return redirect('social:begin', auth_backends[0])\n\n    return auth_views.login(\n        request,\n        template_name='accounts/login.html',\n        authentication_form=LoginForm,\n        extra_context={\n            'login_backends': [\n                x for x in auth_backends if x != 'email'\n            ],\n            'can_reset': 'email' in auth_backends,\n            'title': _('Login'),\n        }\n    )\n\n\n@login_required\ndef weblate_logout(request):\n    '''\n    Logout handler, just wrapper around standard logout.\n    '''\n    messages.info(request, _('Thanks for using Weblate!'))\n\n    return auth_views.logout(\n        request,\n        next_page=reverse('home'),\n    )\n\n\ndef register(request):\n    '''\n    Registration form.\n    '''\n    if appsettings.REGISTRATION_CAPTCHA:\n        form_class = CaptchaRegistrationForm\n    else:\n        form_class = RegistrationForm\n\n    if request.method == 'POST':\n        form = form_class(request.POST)\n        if form.is_valid() and appsettings.REGISTRATION_OPEN:\n            # Ensure we do registration in separate session\n            # not sent to client\n            request.session.create()\n            result = complete(request, 'email')\n            request.session.save()\n            request.session = None\n            return result\n    else:\n        form = form_class()\n\n    backends = set(load_backends(BACKENDS).keys())\n\n    # Redirect if there is only one backend\n    if len(backends) == 1 and 'email' not in backends:\n        return redirect('social:begin', backends.pop())\n\n    return render(\n        request,\n        'accounts/register.html',\n        {\n            'registration_email': 'email' in backends,\n            'registration_backends': backends - set(['email']),\n            'title': _('User registration'),\n            'form': form,\n        }\n    )\n\n\n@login_required\ndef email_login(request):\n    '''\n    Connect email.\n    '''\n    if request.method == 'POST':\n        form = EmailForm(request.POST)\n        if form.is_valid():\n            return complete(request, 'email')\n    else:\n        form = EmailForm()\n\n    return render(\n        request,\n        'accounts/email.html',\n        {\n            'title': _('Register email'),\n            'form': form,\n        }\n    )\n\n\n@login_required\ndef password(request):\n    '''\n    Password change / set form.\n    '''\n    if appsettings.DEMO_SERVER and request.user.username == 'demo':\n        return deny_demo(request)\n\n    do_change = False\n\n    if not request.user.has_usable_password():\n        do_change = True\n        change_form = None\n    elif request.method == 'POST':\n        change_form = PasswordChangeForm(request.POST)\n        if change_form.is_valid():\n            cur_password = change_form.cleaned_data['password']\n            do_change = request.user.check_password(cur_password)\n            if not do_change:\n                messages.error(\n                    request,\n                    _('You have entered an invalid password.')\n                )\n    else:\n        change_form = PasswordChangeForm()\n\n    if request.method == 'POST':\n        form = PasswordForm(request.POST)\n        if form.is_valid() and do_change:\n\n            # Clear flag forcing user to set password\n            redirect_page = '#auth'\n            if 'show_set_password' in request.session:\n                del request.session['show_set_password']\n                redirect_page = ''\n\n            request.user.set_password(\n                form.cleaned_data['password1']\n            )\n            request.user.save()\n\n            # Update session hash\n            update_session_auth_hash(request, request.user)\n\n            messages.success(\n                request,\n                _('Your password has been changed.')\n            )\n            return redirect_profile(redirect_page)\n    else:\n        form = PasswordForm()\n\n    return render(\n        request,\n        'accounts/password.html',\n        {\n            'title': _('Change password'),\n            'change_form': change_form,\n            'form': form,\n        }\n    )\n\n\ndef reset_password(request):\n    '''\n    Password reset handling.\n    '''\n    if 'email' not in load_backends(BACKENDS).keys():\n        messages.error(\n            request,\n            _('Can not reset password, email authentication is disabled!')\n        )\n        return redirect('login')\n\n    if request.method == 'POST':\n        form = ResetForm(request.POST)\n        if form.is_valid():\n            # Force creating new session\n            request.session.create()\n            if request.user.is_authenticated():\n                logout(request)\n\n            request.session['password_reset'] = True\n            return complete(request, 'email')\n        else:\n            return redirect('email-sent')\n    else:\n        form = ResetForm()\n\n    return render(\n        request,\n        'accounts/reset.html',\n        {\n            'title': _('Password reset'),\n            'form': form,\n        }\n    )\n\n\n@login_required\ndef reset_api_key(request):\n    \"\"\"Resets user API key\"\"\"\n    request.user.auth_token.delete()\n    Token.objects.create(\n        user=request.user,\n        key=get_random_string(40)\n    )\n\n    return redirect_profile('#api')\n\n\n@login_required\ndef watch(request, project):\n    obj = get_project(request, project)\n    request.user.profile.subscriptions.add(obj)\n    return redirect(obj)\n\n\n@login_required\ndef unwatch(request, project):\n    obj = get_project(request, project)\n    request.user.profile.subscriptions.remove(obj)\n    return redirect(obj)\n"], "filenames": ["weblate/accounts/tests/test_registration.py", "weblate/accounts/views.py"], "buggy_code_start_loc": [211, 574], "buggy_code_end_loc": [211, 574], "fixing_code_start_loc": [212, 575], "fixing_code_end_loc": [229, 577], "type": "CWE-200", "message": "The password reset form in Weblate before 2.10.1 provides different error messages depending on whether the email address is associated with an account, which allows remote attackers to enumerate user accounts via a series of requests.", "other": {"cve": {"id": "CVE-2017-5537", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T15:59:00.750", "lastModified": "2017-03-21T18:56:38.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The password reset form in Weblate before 2.10.1 provides different error messages depending on whether the email address is associated with an account, which allows remote attackers to enumerate user accounts via a series of requests."}, {"lang": "es", "value": "El formulario de restablecimiento de contrase\u00f1a en Weblate en versiones anteriores a 2.10.1 proporciona diferentes mensajes de error dependiendo de si la direcci\u00f3n de correo electr\u00f3nico est\u00e1 asociada con una cuenta, lo que permite a atacantes remotos enumerar cuentas de usuario a trav\u00e9s de una serie de solicitudes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:weblate:weblate:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.10", "matchCriteriaId": "1D99D0EC-932C-429F-A026-FEF01C817081"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/01/18/11", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/20/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/95676", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/WeblateOrg/weblate/blob/weblate-2.10.1/docs/changes.rst", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "https://github.com/WeblateOrg/weblate/commit/abe0d2a29a1d8e896bfe829c8461bf8b391f1079", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/WeblateOrg/weblate/issues/1317", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/WeblateOrg/weblate/commit/abe0d2a29a1d8e896bfe829c8461bf8b391f1079"}}