{"buggy_code": ["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * Scans an object for all keys that are either objects or arrays\n * and returns an array of those keys only.\n * @param {Object|Array} obj The object to scan.\n * @returns {[string]} An array of string keys.\n * @private\n */\nvar _iterableKeys = function _iterableKeys(obj) {\n  return Object.entries(obj).reduce(function (arr, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        key = _ref2[0],\n        val = _ref2[1];\n\n    var valType = type(val);\n\n    if (valType === \"object\" || valType === \"array\") {\n      arr.push(key);\n    }\n\n    return arr;\n  }, []);\n};\n/**\n * Creates a new instance of \"item\" that is dereferenced. Useful\n * when you want to return a new version of \"item\" with the same\n * data for immutable data structures.\n * @param {Object|Array} item The item to mimic.\n * @param {String} key The key to set data in.\n * @param {*} val The data to set in the key.\n * @returns {*} A new dereferenced version of \"item\" with the \"key\"\n * containing the \"val\" data.\n * @private\n */\n\n\nvar _newInstance = function _newInstance(item) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var objType = type(item);\n  var newObj;\n\n  if (objType === \"object\") {\n    newObj = _objectSpread({}, item);\n  }\n\n  if (objType === \"array\") {\n    newObj = (0, _toConsumableArray2[\"default\"])(item);\n  }\n\n  if (key !== undefined) {\n    newObj[key] = val;\n  }\n\n  return newObj;\n};\n/**\n * Determines if the given path points to a root leaf node (has no delimiter)\n * or contains a dot delimiter so will drill down before reaching a leaf node.\n * If it has a delimiter, it is called a \"composite\" path.\n * @param {String} path The path to evaluate.\n * @returns {boolean} True if delimiter found, false if not.\n */\n\n\nvar isCompositePath = function isCompositePath(path) {\n  var regExp = /\\./g;\n  var result;\n\n  while (result = regExp.exec(path)) {\n    // Check if the previous character was an escape\n    // and if so, ignore this delimiter\n    if (result.index === 0 || path.substr(result.index - 1, 1) !== \"\\\\\") {\n      // This is not an escaped path so it IS a composite path\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Provides the opposite of `isCompositePath()`. If a delimiter is found, this\n * function returns false.\n * @param {String} path The path to evaluate.\n * @returns {boolean} False if delimiter found, true if not.\n */\n\n\nvar isNonCompositePath = function isNonCompositePath(path) {\n  return !isCompositePath(path);\n};\n/**\n * Returns the given path after removing the last\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"foo.bar\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move up.\n * @returns {String} The new path string.\n */\n\n\nvar up = function up(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n\n  for (var i = 0; i < levels; i++) {\n    parts.pop();\n  }\n\n  return parts.join(\".\");\n};\n/**\n * Returns the given path after removing the first\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"bar.thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move down.\n * @returns {String} The new path string.\n */\n\n\nvar down = function down(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n\n  for (var i = 0; i < levels; i++) {\n    parts.shift();\n  }\n\n  return parts.join(\".\");\n};\n/**\n * Returns the last leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * pop.\n * @returns {String} The new path string.\n */\n\n\nvar pop = function pop(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n  var part;\n\n  for (var i = 0; i < levels; i++) {\n    part = parts.pop();\n  }\n\n  return part || \"\";\n};\n/**\n * Adds a leaf to the end of the path. E.g.\n * pushing \"goo\" to path \"foo.bar.thing\" returns\n * \"foo.bar.thing.goo\".\n * @param {String} path The path to operate on.\n * @param {String} val The string value to push\n * to the end of the path.\n * @returns {String} The new path string.\n */\n\n\nvar push = function push(path) {\n  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return \"\".concat(path, \".\").concat(val);\n};\n/**\n * Returns the first leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"foo\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * shift.\n * @returns {String} The new path string.\n */\n\n\nvar shift = function shift(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n  var part;\n\n  for (var i = 0; i < levels; i++) {\n    part = parts.shift();\n  }\n\n  return part || \"\";\n};\n/**\n * A function that just returns the first argument.\n * @param {*} val The argument to return.\n * @returns {*} The passed argument.\n */\n\n\nvar returnWhatWasGiven = function returnWhatWasGiven(val) {\n  return val;\n};\n/**\n * Converts any key matching the wildcard to a zero.\n * @param {String} key The key to test.\n * @returns {String} The key.\n */\n\n\nvar wildcardToZero = function wildcardToZero(key) {\n  return key === \"$\" ? \"0\" : key;\n};\n/**\n * If a key is a number, will return a wildcard, otherwise\n * will return the originally passed key.\n * @param {String} key The key to test.\n * @returns {String} The original key or a wildcard.\n */\n\n\nvar numberToWildcard = function numberToWildcard(key) {\n  // Check if the key is a number\n  if (String(parseInt(key, 10)) === key) {\n    // The key is a number, convert to a wildcard\n    return \"$\";\n  }\n\n  return key;\n};\n/**\n * Removes leading period (.) from string and returns new string.\n * @param {String} str The string to clean.\n * @returns {*} The cleaned string.\n */\n\n\nvar clean = function clean(str) {\n  if (!str) {\n    return str;\n  }\n\n  if (str.substr(0, 1) === \".\") {\n    str = str.substr(1, str.length - 1);\n  }\n\n  return str;\n};\n/**\n * Splits a path by period character, taking into account\n * escaped period characters.\n * @param {String} path The path to split into an array.\n * @return {Array<String>} The component parts of the path, split\n * by period character.\n */\n\n\nvar split = function split(path) {\n  // Convert all \\. (escaped periods) to another character\n  // temporarily\n  var escapedPath = path.replace(/\\\\\\./g, \"[--]\");\n  var splitPath = escapedPath.split(\".\"); // Loop the split path array and convert any escaped period\n  // placeholders back to their real period characters\n\n  for (var i = 0; i < splitPath.length; i++) {\n    splitPath[i] = splitPath[i].replace(/\\[--]/g, \"\\\\.\");\n  }\n\n  return splitPath;\n};\n/**\n * Escapes any periods in the passed string so they will\n * not be identified as part of a path. Useful if you have\n * a path like \"domains.www.google.com.data\" where the\n * \"www.google.com\" should not be considered part of the\n * traversal as it is actually in an object like:\n * {\n * \t\"domains\": {\n * \t\t\"www.google.com\": {\n * \t\t\t\"data\": \"foo\"\n * \t\t}\n * \t}\n * }\n * @param {String} str The string to escape periods in.\n * @return {String} The escaped string.\n */\n\n\nvar escape = function escape(str) {\n  return str.replace(/\\./g, \"\\\\.\");\n};\n/**\n * Converts a string previously escaped with the `escape()`\n * function back to its original value.\n * @param {String} str The string to unescape.\n * @returns {string} The unescaped string.\n */\n\n\nvar unEscape = function unEscape(str) {\n  return str.replace(/\\\\./g, \".\");\n};\n/**\n * Gets a single value from the passed object and given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {*=} defaultVal Optional default to return if the\n * value retrieved from the given object and path equals undefined.\n * @param {Object=} options Optional options object.\n * @returns {*} The value retrieved from the passed object at\n * the passed path.\n */\n\n\nvar get = function get(obj, path) {\n  var defaultVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var internalPath = path,\n      objPart;\n\n  if (path instanceof Array) {\n    return path.map(function (individualPath) {\n      get(obj, individualPath, defaultVal, options);\n    });\n  }\n\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options); // No object data, return undefined\n\n  if (obj === undefined || obj === null) {\n    return defaultVal;\n  } // No path string, return the base obj\n\n\n  if (!internalPath) {\n    return obj;\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  } // Path has no dot-notation, return key/value\n\n\n  if (isNonCompositePath(internalPath)) {\n    return obj[internalPath] !== undefined ? obj[internalPath] : defaultVal;\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return defaultVal !== undefined ? defaultVal : undefined;\n  }\n\n  var pathParts = split(internalPath);\n  objPart = obj;\n\n  var _loop2 = function _loop2(i) {\n    var pathPart = pathParts[i];\n    objPart = objPart[options.transformKey(unEscape(pathPart))];\n\n    if (objPart instanceof Array && options.arrayTraversal === true) {\n      // The data is an array and we have arrayTraversal enabled\n      // so loop the array items and return the first non-undefined\n      // value from any array item leaf node that matches the path\n      var result = objPart.reduce(function (result, arrItem) {\n        return get(arrItem, pathParts.slice(i + 1).join(\".\"), defaultVal, options);\n      }, undefined);\n      return {\n        v: result !== undefined ? result : defaultVal\n      };\n    } else if (!objPart || (0, _typeof2[\"default\"])(objPart) !== \"object\") {\n      if (i !== pathParts.length - 1) {\n        // The path terminated in the object before we reached\n        // the end node we wanted so make sure we return undefined\n        objPart = undefined;\n      }\n\n      return \"break\";\n    }\n  };\n\n  _loop: for (var i = 0; i < pathParts.length; i++) {\n    var _ret = _loop2(i);\n\n    switch (_ret) {\n      case \"break\":\n        break _loop;\n\n      default:\n        if ((0, _typeof2[\"default\"])(_ret) === \"object\") return _ret.v;\n    }\n  }\n\n  return objPart !== undefined ? objPart : defaultVal;\n};\n/**\n * Sets a single value on the passed object and given path. This\n * will directly modify the \"obj\" object. If you need immutable\n * updates, use setImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to set data on.\n * @param {*} val The value to assign to the obj at the path.\n * @param {Object=} options The options object.\n * @returns {*} Nothing.\n */\n\n\nvar set = function set(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var internalPath = path,\n      objPart;\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options); // No object data\n\n  if (obj === undefined || obj === null) {\n    return;\n  } // No path string\n\n\n  if (!internalPath) {\n    return;\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return;\n  } // Path has no dot-notation, set key/value\n\n\n  if (isNonCompositePath(internalPath)) {\n    obj = decouple(obj, options);\n    obj[options.transformKey(unEscape(internalPath))] = val;\n    return obj;\n  }\n\n  var newObj = decouple(obj, options);\n  var pathParts = split(internalPath);\n  var pathPart = pathParts.shift();\n  var transformedPathPart = options.transformKey(pathPart);\n  var childPart = newObj[transformedPathPart];\n\n  if ((0, _typeof2[\"default\"])(childPart) !== \"object\") {\n    // Create an object or array on the path\n    if (String(parseInt(transformedPathPart, 10)) === transformedPathPart) {\n      // This is an array index\n      newObj[transformedPathPart] = [];\n    } else {\n      newObj[transformedPathPart] = {};\n    }\n\n    objPart = newObj[transformedPathPart];\n  } else {\n    objPart = childPart;\n  }\n\n  return set(newObj, transformedPathPart, set(objPart, pathParts.join('.'), val, options), options);\n};\n/**\n * Deletes a key from an object by the given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to delete.\n * @param {Object=} options The options object.\n * @param {Object=} tracking Do not use.\n */\n\n\nvar unSet = function unSet(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tracking = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var internalPath = path;\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options); // No object data\n\n  if (obj === undefined || obj === null) {\n    return;\n  } // No path string\n\n\n  if (!internalPath) {\n    return;\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return;\n  }\n\n  var newObj = decouple(obj, options); // Path has no dot-notation, set key/value\n\n  if (isNonCompositePath(internalPath)) {\n    if (newObj.hasOwnProperty(unEscape(internalPath))) {\n      delete newObj[options.transformKey(unEscape(internalPath))];\n      return newObj;\n    }\n\n    tracking.returnOriginal = true;\n    return obj;\n  }\n\n  var pathParts = split(internalPath);\n  var pathPart = pathParts.shift();\n  var transformedPathPart = options.transformKey(unEscape(pathPart));\n  var childPart = newObj[transformedPathPart];\n\n  if (!childPart) {\n    // No child part available, nothing to unset!\n    tracking.returnOriginal = true;\n    return obj;\n  }\n\n  newObj[transformedPathPart] = unSet(childPart, pathParts.join('.'), options, tracking);\n\n  if (tracking.returnOriginal) {\n    return obj;\n  }\n\n  return newObj;\n};\n/**\n * Takes an update object or array and iterates the keys of it, then\n * sets data on the target object or array at the specified path with\n * the corresponding value from the path key, effectively doing\n * multiple set() operations in a single call. This will directly\n * modify the \"obj\" object. If you need immutable updates, use\n * updateImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The object with the modified data.\n */\n\n\nvar update = function update(obj, updateData) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var newObj = obj;\n\n  for (var path in updateData) {\n    if (updateData.hasOwnProperty(path)) {\n      var data = updateData[path];\n      newObj = set(newObj, path, data, options);\n    }\n  }\n\n  return newObj;\n};\n/**\n * If options.immutable === true then return a new de-referenced\n * instance of the passed object/array. If immutable is false\n * then simply return the same `obj` that was passed.\n * @param {*} obj The object or array to decouple.\n * @param {Object=} options The options object that has the immutable\n * key with a boolean value.\n * @returns {*} The new decoupled instance (if immutable is true)\n * or the original `obj` if immutable is false.\n */\n\n\nvar decouple = function decouple(obj) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!options.immutable) {\n    return obj;\n  }\n\n  return _newInstance(obj);\n};\n/**\n * Push a value to an array on an object for the specified path.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to push to.\n * @param {*} val The value to push to the array at the object path.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\n\n\nvar pushVal = function pushVal(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (obj === undefined || obj === null || path === undefined) {\n    return obj;\n  } // Clean the path\n\n\n  path = clean(path);\n  var pathParts = split(path);\n  var part = pathParts.shift();\n\n  if (pathParts.length) {\n    // Generate the path part in the object if it does not already exist\n    obj[part] = decouple(obj[part], options) || {}; // Recurse\n\n    pushVal(obj[part], pathParts.join(\".\"), val, options);\n  } else if (part) {\n    // We have found the target array, push the value\n    obj[part] = decouple(obj[part], options) || [];\n\n    if (!(obj[part] instanceof Array)) {\n      throw \"Cannot push to a path whose leaf node is not an array!\";\n    }\n\n    obj[part].push(val);\n  } else {\n    // We have found the target array, push the value\n    obj = decouple(obj, options) || [];\n\n    if (!(obj instanceof Array)) {\n      throw \"Cannot push to a path whose leaf node is not an array!\";\n    }\n\n    obj.push(val);\n  }\n\n  return decouple(obj, options);\n};\n/**\n * Pull a value to from an array at the specified path. Removes the first\n * matching value, not every matching value.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to pull from.\n * @param {*} val The value to pull from the array.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\n\n\nvar pullVal = function pullVal(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    strict: true\n  };\n\n  if (obj === undefined || obj === null || path === undefined) {\n    return obj;\n  } // Clean the path\n\n\n  path = clean(path);\n  var pathParts = split(path);\n  var part = pathParts.shift();\n\n  if (pathParts.length) {\n    // Generate the path part in the object if it does not already exist\n    obj[part] = decouple(obj[part], options) || {}; // Recurse - we don't need to assign obj[part] the result of this call because\n    // we are modifying by reference since we haven't reached the furthest path\n    // part (leaf) node yet\n\n    pullVal(obj[part], pathParts.join(\".\"), val, options);\n  } else if (part) {\n    obj[part] = decouple(obj[part], options) || []; // Recurse - this is the leaf node so assign the response to obj[part] in\n    // case it is set to an immutable response\n\n    obj[part] = pullVal(obj[part], \"\", val, options);\n  } else {\n    // The target array is the root object, pull the value\n    obj = decouple(obj, options) || [];\n\n    if (!(obj instanceof Array)) {\n      throw \"Cannot pull from a path whose leaf node is not an array!\";\n    }\n\n    var index = -1; // Find the index of the passed value\n\n    if (options.strict === true) {\n      index = obj.indexOf(val);\n    } else {\n      // Do a non-strict check\n      index = obj.findIndex(function (item) {\n        return match(item, val);\n      });\n    }\n\n    if (index > -1) {\n      // Remove the item from the array\n      obj.splice(index, 1);\n    }\n  }\n\n  return decouple(obj, options);\n};\n/**\n * Given a path and an object, determines the outermost leaf node\n * that can be reached where the leaf value is not undefined.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {String} The path to the furthest non-undefined value.\n */\n\n\nvar furthest = function furthest(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var internalPath = path,\n      objPart;\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": wildcardToZero,\n    // Any path that has a wildcard will essentially check the first array item to continue down the tree\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n  var finalPath = []; // No path string, return the base obj\n\n  if (!internalPath) {\n    return finalPath.join(\".\");\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return finalPath.join(\".\");\n  } // Path has no dot-notation, return key/value\n\n\n  if (isNonCompositePath(internalPath)) {\n    if (obj[internalPath] !== undefined) {\n      return internalPath;\n    }\n\n    return finalPath.join(\".\");\n  }\n\n  var pathParts = split(internalPath);\n  objPart = obj;\n\n  for (var i = 0; i < pathParts.length; i++) {\n    var pathPart = pathParts[i];\n    objPart = objPart[options.transformKey(unEscape(pathPart))];\n\n    if (objPart === undefined) {\n      break;\n    }\n\n    finalPath.push(pathPart);\n  }\n\n  return finalPath.join(\".\");\n};\n/**\n * Traverses the object by the given path and returns an object where\n * each key is a path pointing to a leaf node and contains the value\n * from the leaf node from the overall object in the obj argument,\n * essentially providing all available paths in an object and all the\n * values for each path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {Object|Array} The result of the traversal.\n */\n\n\nvar values = function values(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var internalPath = clean(path);\n  var pathParts = split(internalPath);\n  var currentPath = [];\n  var valueData = {};\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n\n  for (var i = 0; i < pathParts.length; i++) {\n    var pathPart = options.transformKey(pathParts[i]);\n    currentPath.push(pathPart);\n    var tmpPath = currentPath.join(\".\");\n    valueData[tmpPath] = get(obj, tmpPath);\n  }\n\n  return valueData;\n};\n/**\n * Takes an object and finds all paths, then returns the paths as an\n * array of strings.\n * @param {Object|Array} obj The object to scan.\n * @param {Array=} finalArr An object used to collect the path keys.\n * (Do not pass this in directly - use undefined).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly - use undefined).\n * @param {Object=} options An options object.\n * @returns {Array<String>} An array containing path strings.\n */\n\n\nvar flatten = function flatten(obj) {\n  var finalArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var objCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n  var transformedObj = options.transformRead(obj); // Check that we haven't visited this object before (avoid infinite recursion)\n\n  if (objCache.indexOf(transformedObj) > -1) {\n    return finalArr;\n  } // Add object to cache to make sure we don't traverse it twice\n\n\n  objCache.push(transformedObj);\n\n  var currentPath = function currentPath(i) {\n    var tKey = options.transformKey(i);\n    return parentPath ? parentPath + \".\" + tKey : tKey;\n  };\n\n  for (var i in transformedObj) {\n    if (transformedObj.hasOwnProperty(i)) {\n      if (options.ignore && options.ignore.test(i)) {\n        continue;\n      }\n\n      if ((0, _typeof2[\"default\"])(transformedObj[i]) === \"object\" && transformedObj[i] !== null) {\n        flatten(transformedObj[i], finalArr, currentPath(i), options, objCache);\n      }\n\n      finalArr.push(currentPath(i));\n    }\n  }\n\n  return finalArr;\n};\n/**\n * Takes an object and finds all paths, then returns the paths as keys\n * and the values of each path as the values.\n * @param {Object|Array} obj The object to scan.\n * @param {Object=} finalObj An object used to collect the path keys.\n * (Do not pass this in directly).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly).\n * @param {Object=} options An options object.\n * @returns {Object|Array} An object containing path keys and their values.\n */\n\n\nvar flattenValues = function flattenValues(obj) {\n  var finalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var objCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n  var transformedObj = options.transformRead(obj); // Check that we haven't visited this object before (avoid infinite recursion)\n\n  if (objCache.indexOf(transformedObj) > -1) {\n    return finalObj;\n  } // Add object to cache to make sure we don't traverse it twice\n\n\n  objCache.push(transformedObj);\n\n  var currentPath = function currentPath(i, info) {\n    var tKey = options.transformKey(i, info);\n    return parentPath ? parentPath + \".\" + tKey : tKey;\n  };\n\n  for (var i in transformedObj) {\n    if (transformedObj.hasOwnProperty(i)) {\n      var _type = (0, _typeof2[\"default\"])(transformedObj[i]);\n\n      var info = {\n        type: _type,\n        isArrayIndex: Array.isArray(transformedObj),\n        isFlat: _type !== \"object\" || transformedObj[i] instanceof Date || transformedObj[i] instanceof RegExp\n      };\n      var pathKey = currentPath(i, info);\n\n      if (!info.isFlat) {\n        if (transformedObj[i] !== null) {\n          flattenValues(transformedObj[i], finalObj, pathKey, options, objCache);\n        }\n      } else if (options.leavesOnly) {\n        // Found leaf node!\n        finalObj[pathKey] = options.transformWrite(transformedObj[i]);\n      }\n\n      if (!options.leavesOnly) {\n        finalObj[pathKey] = options.transformWrite(transformedObj[i]);\n      }\n    }\n  }\n\n  return finalObj;\n};\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args args Path to join.\n * @returns {String} A final path string.\n */\n\n\nvar join = function join() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args.reduce(function (arr, item) {\n    if (item !== undefined && String(item)) {\n      arr.push(item);\n    }\n\n    return arr;\n  }, []).join(\".\");\n};\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args Path to join.\n * @returns {String} A final path string.\n */\n\n\nvar joinEscaped = function joinEscaped() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  var escapedArgs = args.map(function (item) {\n    return escape(item);\n  });\n  return join.apply(void 0, (0, _toConsumableArray2[\"default\"])(escapedArgs));\n};\n/**\n * Counts the total number of key leaf nodes in the passed object.\n * @param {Object|Array} obj The object to count key leaf nodes for.\n * @param {Array=} objCache Do not use. Internal array to track\n * visited leafs.\n * @returns {Number} The number of keys.\n */\n\n\nvar countLeafNodes = function countLeafNodes(obj) {\n  var objCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var totalKeys = 0; // Add object to cache to make sure we don't traverse it twice\n\n  objCache.push(obj);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (obj[i] !== undefined) {\n        if ((0, _typeof2[\"default\"])(obj[i]) !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n          totalKeys++;\n        } else {\n          totalKeys += countLeafNodes(obj[i], objCache);\n        }\n      }\n    }\n  }\n\n  return totalKeys;\n};\n/**\n * Finds all the leaf nodes for a given object and returns an array of paths\n * to them. This is different from `flatten()` in that it only includes leaf\n * nodes and will not include every intermediary path traversed to get to a\n * leaf node.\n * @param {Object|Array} obj The object to traverse.\n * @param {String} [parentPath=\"\"] The path to use as a root/base path to\n * start scanning for leaf nodes under.\n * @param {Object} [objCache=[]] Internal usage to check for cyclic structures.\n * @returns {[]}\n */\n\n\nvar leafNodes = function leafNodes(obj) {\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var objCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var paths = []; // Add object to cache to make sure we don't traverse it twice\n\n  objCache.push(obj);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (obj[i] !== undefined) {\n        var currentPath = join(parentPath, i);\n\n        if ((0, _typeof2[\"default\"])(obj[i]) !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n          paths.push(currentPath);\n        } else {\n          paths.push.apply(paths, (0, _toConsumableArray2[\"default\"])(leafNodes(obj[i], currentPath, objCache)));\n        }\n      }\n    }\n  }\n\n  return paths;\n};\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths. MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Boolean} True if the object paths exist.\n */\n\n\nvar hasMatchingPathsInObject = function hasMatchingPathsInObject(testKeys, testObj) {\n  var result = true;\n\n  for (var i in testKeys) {\n    if (testKeys.hasOwnProperty(i)) {\n      if (testObj[i] === undefined) {\n        return false;\n      }\n\n      if ((0, _typeof2[\"default\"])(testKeys[i]) === \"object\" && testKeys[i] !== null) {\n        // Recurse object\n        result = hasMatchingPathsInObject(testKeys[i], testObj[i]); // Should we exit early?\n\n        if (!result) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths and if so returns the number matched.\n * MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Object<matchedKeys<Number>, matchedKeyCount<Number>, totalKeyCount<Number>>} Stats on the matched keys.\n */\n\n\nvar countMatchingPathsInObject = function countMatchingPathsInObject(testKeys, testObj) {\n  var matchedKeys = {};\n  var matchData,\n      matchedKeyCount = 0,\n      totalKeyCount = 0;\n\n  for (var i in testObj) {\n    if (testObj.hasOwnProperty(i)) {\n      if ((0, _typeof2[\"default\"])(testObj[i]) === \"object\" && testObj[i] !== null) {\n        // The test / query object key is an object, recurse\n        matchData = countMatchingPathsInObject(testKeys[i], testObj[i]);\n        matchedKeys[i] = matchData.matchedKeys;\n        totalKeyCount += matchData.totalKeyCount;\n        matchedKeyCount += matchData.matchedKeyCount;\n      } else {\n        // The test / query object has a property that is not an object so add it as a key\n        totalKeyCount++; // Check if the test keys also have this key and it is also not an object\n\n        if (testKeys && testKeys[i] && ((0, _typeof2[\"default\"])(testKeys[i]) !== \"object\" || testKeys[i] === null)) {\n          matchedKeys[i] = true;\n          matchedKeyCount++;\n        } else {\n          matchedKeys[i] = false;\n        }\n      }\n    }\n  }\n\n  return {\n    matchedKeys: matchedKeys,\n    matchedKeyCount: matchedKeyCount,\n    totalKeyCount: totalKeyCount\n  };\n};\n/**\n * Returns the type from the item passed. Similar to JavaScript's\n * built-in typeof except it will distinguish between arrays, nulls\n * and objects as well.\n * @param {*} item The item to get the type of.\n * @returns {string|\"undefined\"|\"object\"|\"boolean\"|\"number\"|\"string\"|\"function\"|\"symbol\"|\"null\"|\"array\"}\n */\n\n\nvar type = function type(item) {\n  if (item === null) {\n    return 'null';\n  }\n\n  if (Array.isArray(item)) {\n    return 'array';\n  }\n\n  return (0, _typeof2[\"default\"])(item);\n};\n/**\n * Determines if the query data exists anywhere inside the source\n * data. Will recurse into arrays and objects to find query.\n * @param {*} source The source data to check.\n * @param {*} query The query data to find.\n * @returns {Boolean} True if query was matched, false if not.\n */\n\n\nvar match = function match(source, query) {\n  var sourceType = (0, _typeof2[\"default\"])(source);\n  var queryType = (0, _typeof2[\"default\"])(query);\n\n  if (sourceType !== queryType) {\n    return false;\n  }\n\n  if (sourceType !== \"object\" || source === null) {\n    // Simple test\n    return source === query;\n  } // The source is an object-like (array or object) structure\n\n\n  var entries = Object.entries(query);\n  var foundNonMatch = entries.find(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n        key = _ref4[0],\n        val = _ref4[1];\n\n    // Recurse if type is array or object\n    if ((0, _typeof2[\"default\"])(val) === \"object\" && val !== null) {\n      return !match(source[key], val);\n    }\n\n    return source[key] !== val;\n  });\n  return !foundNonMatch;\n};\n/**\n * @typedef {object} FindOptionsObject\n * @property {number} [maxDepth=Infinity] The maximum depth to scan inside\n * the source object for matching data.\n * @property {number} [currentDepth=0] The current depth of the\n * operation scan.\n * @property {boolean} [includeRoot=true] If true, will include the\n * root source object if it matches the query.\n */\n\n/**\n * Finds all items that matches the structure of `query` and\n * returns the path to them as an array of strings.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<Array>.\n */\n\n\nvar findPath = function findPath(source, query) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  };\n  var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  var resultArr = [];\n  var sourceType = (0, _typeof2[\"default\"])(source);\n  options = _objectSpread({\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  }, options);\n\n  if (options.currentDepth !== 0 || options.currentDepth === 0 && options.includeRoot) {\n    if (match(source, query)) {\n      resultArr.push(parentPath);\n    }\n  }\n\n  options.currentDepth++;\n\n  if (options.currentDepth <= options.maxDepth && sourceType === \"object\") {\n    var entries = Object.entries(source);\n    entries.forEach(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          key = _ref6[0],\n          val = _ref6[1];\n\n      // Recurse down object to find more instances\n      var result = findPath(val, query, options, join(parentPath, key));\n\n      if (result.match) {\n        resultArr.push.apply(resultArr, (0, _toConsumableArray2[\"default\"])(result.path));\n      }\n    });\n  }\n\n  return {\n    match: resultArr.length > 0,\n    path: resultArr\n  };\n};\n/**\n * Finds the first item that matches the structure of `query`\n * and returns the path to it.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<String>.\n */\n\n\nvar findOnePath = function findOnePath(source, query) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  };\n  var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  var sourceType = (0, _typeof2[\"default\"])(source);\n  options = _objectSpread({\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  }, options);\n\n  if (options.currentDepth !== 0 || options.currentDepth === 0 && options.includeRoot) {\n    if (match(source, query)) {\n      return {\n        match: true,\n        path: parentPath\n      };\n    }\n  }\n\n  options.currentDepth++;\n\n  if (options.currentDepth <= options.maxDepth && sourceType === \"object\" && source !== null) {\n    var entries = Object.entries(source);\n\n    for (var i = 0; i < entries.length; i++) {\n      var _entries$i = (0, _slicedToArray2[\"default\"])(entries[i], 2),\n          key = _entries$i[0],\n          val = _entries$i[1]; // Recurse down object to find more instances\n\n\n      var subPath = join(parentPath, key);\n      var result = findOnePath(val, query, options, subPath);\n\n      if (result.match) {\n        return result;\n      }\n    }\n  }\n\n  return {\n    match: false\n  };\n};\n/**\n * Returns a deduplicated array of strings.\n * @param {Array<String>} keys An array of strings to deduplicate.\n * @returns {Array<String>} The deduplicated array.\n */\n\n\nvar keyDedup = function keyDedup(keys) {\n  return keys.filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  });\n};\n/**\n * Compares two provided objects / arrays and returns an array of\n * dot-notation paths to the fields that hold different values.\n * @param {Object|Array} obj1 The first object / array to compare.\n * @param {Object|Array} obj2 The second object / array to compare.\n * @param {String=\"\"} basePath The base path from which to check for\n * differences. Differences outside the base path will not be\n * returned as part of the array of differences. Leave blank to check\n * for all differences between the two objects to compare.\n * @param {Boolean=false} strict If strict is true, diff uses strict\n * equality to determine difference rather than non-strict equality;\n * effectively (=== is strict, == is non-strict).\n * @param {Number=Infinity} maxDepth Specifies the maximum number of\n * path sub-trees to walk down before returning what we have found.\n * For instance, if set to 2, a diff would only check down,\n * \"someFieldName.anotherField\", or \"user.name\" and would not go\n * further down than two fields. If anything in the trees further\n * down than this level have changed, the change will not be detected\n * and the path will not be included in the resulting diff array.\n * @param {String=\"\"} parentPath Used internally only.\n * @returns {Array} An array of strings, each string is a path to a\n * field that holds a different value between the two objects being\n * compared.\n */\n\n\nvar diff = function diff(obj1, obj2) {\n  var basePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var maxDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n  var parentPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n  var objCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  var paths = [];\n\n  if (basePath instanceof Array) {\n    // We were given an array of paths, check each path\n    return basePath.reduce(function (arr, individualPath) {\n      // Here we find any path that has a *non-equal* result which\n      // returns true and then returns the index as a positive integer\n      // that is not -1. If -1 is returned then no non-equal matches\n      // were found\n      var result = diff(obj1, obj2, individualPath, strict, maxDepth, parentPath, objCache);\n\n      if (result && result.length) {\n        arr.push.apply(arr, (0, _toConsumableArray2[\"default\"])(result));\n      }\n\n      return arr;\n    }, []);\n  }\n\n  var currentPath = join(parentPath, basePath);\n  var val1 = get(obj1, basePath);\n  var val2 = get(obj2, basePath);\n  var type1 = type(val1);\n  var type2 = type(val2);\n\n  if (type1 !== type2) {\n    // Difference in source and comparison types\n    paths.push(currentPath);\n  } else if (type1 === \"array\" && val1.length !== val2.length) {\n    // Difference in source and comparison types\n    paths.push(currentPath);\n  }\n\n  var pathParts = currentPath.split(\".\");\n  var hasParts = pathParts[0] !== \"\";\n\n  if ((!hasParts || pathParts.length < maxDepth) && (0, _typeof2[\"default\"])(val1) === \"object\" && val1 !== null) {\n    // Check that we haven't visited this object before (avoid infinite recursion)\n    if (objCache.indexOf(val1) > -1 || objCache.indexOf(val2) > -1) {\n      return paths;\n    }\n\n    objCache.push(val1);\n    objCache.push(val2); // Grab composite of all keys on val1 and val2\n\n    var val1Keys = Object.keys(val1);\n    var val2Keys = (0, _typeof2[\"default\"])(val2) === \"object\" && val2 !== null ? Object.keys(val2) : [];\n    var compositeKeys = keyDedup(val1Keys.concat(val2Keys));\n    return compositeKeys.reduce(function (arr, key) {\n      var result = diff(val1, val2, key, strict, maxDepth, currentPath, objCache);\n\n      if (result && result.length) {\n        arr.push.apply(arr, (0, _toConsumableArray2[\"default\"])(result));\n      }\n\n      return arr;\n    }, paths);\n  }\n\n  if (strict && val1 !== val2 || !strict && val1 != val2) {\n    paths.push(currentPath);\n  }\n\n  return keyDedup(paths);\n};\n/**\n * A boolean check to see if the values at the given path or paths\n * are the same in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to check\n * values in. If this is an array, all values at the paths in the array\n * must be the same for the function to provide a true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for equality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values match, false if not.\n */\n\n\nvar isEqual = function isEqual(obj1, obj2, path) {\n  var deep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var strict = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (path instanceof Array) {\n    // We were given an array of paths, check each path\n    return path.findIndex(function (individualPath) {\n      // Here we find any path that has a *non-equal* result which\n      // returns true and then returns the index as a positive integer\n      // that is not -1. If -1 is returned then no non-equal matches\n      // were found\n      return isNotEqual(obj1, obj2, individualPath, deep, strict);\n    }) === -1;\n  }\n\n  var val1 = get(obj1, path);\n  var val2 = get(obj2, path);\n\n  if (deep) {\n    if ((0, _typeof2[\"default\"])(val1) === \"object\" && val1 !== null) {\n      // TODO: This probably needs a composite key array of val1 and val2 keys\n      //  just as we do in the diff() function\n      return Object.keys(val1).findIndex(function (key) {\n        return isNotEqual(val1, val2, key, deep, strict);\n      }) === -1;\n    }\n  }\n\n  return strict && val1 === val2 || !strict && val1 == val2;\n};\n/**\n * A boolean check to see if the values at the given path or paths\n * are different in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to\n * check values in. If this is an array, all values at the paths\n * in the array must be different for the function to provide a\n * true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for inequality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-not-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values differ, false if not.\n */\n\n\nvar isNotEqual = function isNotEqual(obj1, obj2, path) {\n  var deep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var strict = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return !isEqual(obj1, obj2, path, deep, strict);\n};\n/**\n * Same as set() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar setImmutable = function setImmutable(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return set(obj, path, val, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as pushVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar pushValImmutable = function pushValImmutable(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return pushVal(obj, path, val, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as pullVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar pullValImmutable = function pullValImmutable(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return pullVal(obj, path, val, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as unSet() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar unSetImmutable = function unSetImmutable(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return unSet(obj, path, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as update() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar updateImmutable = function updateImmutable(obj, updateData, options) {\n  return update(obj, updateData, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Gets the values of the paths in pathArr and returns them as an object\n * with each key matching the path and the value matching the value from\n * obj that was at that path.\n * @param {Object} obj The object to operate on.\n * @param {Array<String>} pathArr Array of path strings.\n * @returns {*} The new object.\n */\n\n\nvar distill = function distill(obj, pathArr) {\n  return pathArr.reduce(function (newObj, path) {\n    newObj[path] = get(obj, path);\n    return newObj;\n  }, {});\n};\n/**\n * Chops a `path` string down to the given `level`. Given a `path` string\n * like \"foo.bar.ram.you.too\", chop will remove any path parts below\n * the given `level`. If we pass 2 as the `level` with that given `path`,\n * the result will be \"foo.bar\" as foo is level 1 and bar is level 2.\n * If the `path` is shorter than the given `level`, it is returned intact.\n * @param {String} path The path to operate on.\n * @param {Number} level The maximum level of a path.\n * @returns {String} The new path string.\n */\n\n\nvar chop = function chop(path, level) {\n  var parts = split(path);\n\n  if (parts.length > level) {\n    parts.length = level;\n  }\n\n  return join.apply(void 0, (0, _toConsumableArray2[\"default\"])(parts));\n};\n\nmodule.exports = {\n  wildcardToZero: wildcardToZero,\n  numberToWildcard: numberToWildcard,\n  clean: clean,\n  decouple: decouple,\n  split: split,\n  escape: escape,\n  get: get,\n  set: set,\n  setImmutable: setImmutable,\n  unSet: unSet,\n  unSetImmutable: unSetImmutable,\n  pushValImmutable: pushValImmutable,\n  pushVal: pushVal,\n  pullValImmutable: pullValImmutable,\n  pullVal: pullVal,\n  furthest: furthest,\n  values: values,\n  flatten: flatten,\n  flattenValues: flattenValues,\n  join: join,\n  joinEscaped: joinEscaped,\n  up: up,\n  down: down,\n  push: push,\n  pop: pop,\n  shift: shift,\n  countLeafNodes: countLeafNodes,\n  hasMatchingPathsInObject: hasMatchingPathsInObject,\n  countMatchingPathsInObject: countMatchingPathsInObject,\n  findOnePath: findOnePath,\n  findPath: findPath,\n  type: type,\n  match: match,\n  isEqual: isEqual,\n  isNotEqual: isNotEqual,\n  leafNodes: leafNodes,\n  diff: diff,\n  update: update,\n  updateImmutable: updateImmutable,\n  distill: distill,\n  chop: chop\n};", "{\n\t\"name\": \"@irrelon/path\",\n\t\"version\": \"4.6.8\",\n\t\"description\": \"A powerful JSON path processor. Allows you to drill into and manipulate JSON objects with a simple dot-delimited path format e.g. \\\"obj.name\\\".\",\n\t\"main\": \"./src/Path.js\",\n\t\"scripts\": {\n\t\t\"test\": \"NODE_ENV=test mocha ./tests/**/**.test.js\",\n\t\t\"testMon\": \"nodemon --watch src --watch tests --exec \\\"NODE_ENV=test BABEL_DISABLE_CACHE=1 mocha ./tests/**/**.test.js\\\"\",\n\t\t\"build\": \"npm test && rimraf dist && babel ./src/*.js --out-dir dist\",\n\t\t\"eslint\": \"eslint ./src/**.js ./tests/**.js ./dist/Path.js\",\n\t\t\"eslint-fix\": \"eslint --fix ./src/**.js ./tests/**.js\"\n\t},\n\t\"keywords\": [\n\t\t\"path\",\n\t\t\"dot notation\",\n\t\t\"json\",\n\t\t\"node\",\n\t\t\"browser\"\n\t],\n\t\"author\": \"Rob Evans - Irrelon Software Limited\",\n\t\"license\": \"MIT\",\n\t\"devDependencies\": {\n\t\t\"@babel/cli\": \"^7.8.7\",\n\t\t\"@babel/core\": \"^7.8.7\",\n\t\t\"@babel/plugin-proposal-class-properties\": \"^7.8.7\",\n\t\t\"@babel/plugin-proposal-object-rest-spread\": \"^7.8.7\",\n\t\t\"@babel/plugin-transform-runtime\": \"^7.8.7\",\n\t\t\"@babel/preset-env\": \"^7.8.7\",\n\t\t\"@babel/preset-react\": \"^7.8.7\",\n\t\t\"@babel/register\": \"^7.8.7\",\n\t\t\"eslint-config-irrelon\": \"^1.0.2\",\n\t\t\"mocha\": \"^6.2.2\",\n\t\t\"mocha-expect\": \"^1.0.3\",\n\t\t\"rimraf\": \"^2.7.1\",\n\t\t\"nodemon\": \"^2.0.3\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/irrelon/irrelon-path.git\"\n\t},\n\t\"private\": false\n}\n", "/**\n * Scans an object for all keys that are either objects or arrays\n * and returns an array of those keys only.\n * @param {Object|Array} obj The object to scan.\n * @returns {[string]} An array of string keys.\n * @private\n */\nconst _iterableKeys = (obj) => {\n\treturn Object.entries(obj).reduce((arr, [key, val]) => {\n\t\tconst valType = type(val);\n\t\tif (valType === \"object\" || valType === \"array\") {\n\t\t\tarr.push(key);\n\t\t}\n\t\t\n\t\treturn arr;\n\t}, []);\n};\n\n/**\n * Creates a new instance of \"item\" that is dereferenced. Useful\n * when you want to return a new version of \"item\" with the same\n * data for immutable data structures.\n * @param {Object|Array} item The item to mimic.\n * @param {String} key The key to set data in.\n * @param {*} val The data to set in the key.\n * @returns {*} A new dereferenced version of \"item\" with the \"key\"\n * containing the \"val\" data.\n * @private\n */\nconst _newInstance = (item, key = undefined, val = undefined) => {\n\tconst objType = type(item);\n\t\n\tlet newObj;\n\t\n\tif (objType === \"object\") {\n\t\tnewObj = {\n\t\t\t...item\n\t\t};\n\t}\n\t\n\tif (objType === \"array\") {\n\t\tnewObj = [\n\t\t\t...item\n\t\t];\n\t}\n\t\n\tif (key !== undefined) {\n\t\tnewObj[key] = val;\n\t}\n\t\n\treturn newObj;\n};\n\n/**\n * Determines if the given path points to a root leaf node (has no delimiter)\n * or contains a dot delimiter so will drill down before reaching a leaf node.\n * If it has a delimiter, it is called a \"composite\" path.\n * @param {String} path The path to evaluate.\n * @returns {boolean} True if delimiter found, false if not.\n */\nconst isCompositePath = (path) => {\n\tconst regExp = /\\./g;\n\tlet result;\n\t\n\twhile (result = regExp.exec(path)) {\n\t\t// Check if the previous character was an escape\n\t\t// and if so, ignore this delimiter\n\t\tif (result.index === 0 || path.substr(result.index - 1, 1) !== \"\\\\\") {\n\t\t\t// This is not an escaped path so it IS a composite path\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Provides the opposite of `isCompositePath()`. If a delimiter is found, this\n * function returns false.\n * @param {String} path The path to evaluate.\n * @returns {boolean} False if delimiter found, true if not.\n */\nconst isNonCompositePath = (path) => {\n\treturn !isCompositePath(path);\n};\n\n/**\n * Returns the given path after removing the last\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"foo.bar\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move up.\n * @returns {String} The new path string.\n */\nconst up = (path, levels = 1) => {\n\tconst parts = split(path);\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tparts.pop();\n\t}\n\t\n\treturn parts.join(\".\");\n};\n\n/**\n * Returns the given path after removing the first\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"bar.thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move down.\n * @returns {String} The new path string.\n */\nconst down = (path, levels = 1) => {\n\tconst parts = split(path);\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tparts.shift();\n\t}\n\t\n\treturn parts.join(\".\");\n};\n\n/**\n * Returns the last leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * pop.\n * @returns {String} The new path string.\n */\nconst pop = (path, levels = 1) => {\n\tconst parts = split(path);\n\tlet part;\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tpart = parts.pop();\n\t}\n\t\n\treturn part || \"\";\n};\n\n/**\n * Adds a leaf to the end of the path. E.g.\n * pushing \"goo\" to path \"foo.bar.thing\" returns\n * \"foo.bar.thing.goo\".\n * @param {String} path The path to operate on.\n * @param {String} val The string value to push\n * to the end of the path.\n * @returns {String} The new path string.\n */\nconst push = (path, val = \"\") => {\n\treturn `${path}.${val}`;\n};\n\n/**\n * Returns the first leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"foo\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * shift.\n * @returns {String} The new path string.\n */\nconst shift = (path, levels = 1) => {\n\tconst parts = split(path);\n\tlet part;\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tpart = parts.shift();\n\t}\n\t\n\treturn part || \"\";\n};\n\n/**\n * A function that just returns the first argument.\n * @param {*} val The argument to return.\n * @returns {*} The passed argument.\n */\nconst returnWhatWasGiven = (val) => val;\n\n/**\n * Converts any key matching the wildcard to a zero.\n * @param {String} key The key to test.\n * @returns {String} The key.\n */\nconst wildcardToZero = (key) => {\n\treturn key === \"$\" ? \"0\" : key;\n};\n\n/**\n * If a key is a number, will return a wildcard, otherwise\n * will return the originally passed key.\n * @param {String} key The key to test.\n * @returns {String} The original key or a wildcard.\n */\nconst numberToWildcard = (key) => {\n\t// Check if the key is a number\n\tif (String(parseInt(key, 10)) === key) {\n\t\t// The key is a number, convert to a wildcard\n\t\treturn \"$\";\n\t}\n\t\n\treturn key;\n};\n\n/**\n * Removes leading period (.) from string and returns new string.\n * @param {String} str The string to clean.\n * @returns {*} The cleaned string.\n */\nconst clean = (str) => {\n\tif (!str) {\n\t\treturn str;\n\t}\n\t\n\tif (str.substr(0, 1) === \".\") {\n\t\tstr = str.substr(1, str.length - 1);\n\t}\n\t\n\treturn str;\n};\n\n/**\n * Splits a path by period character, taking into account\n * escaped period characters.\n * @param {String} path The path to split into an array.\n * @return {Array<String>} The component parts of the path, split\n * by period character.\n */\nconst split = (path) => {\n\t// Convert all \\. (escaped periods) to another character\n\t// temporarily\n\tconst escapedPath = path.replace(/\\\\\\./g, \"[--]\");\n\tconst splitPath = escapedPath.split(\".\");\n\t\n\t// Loop the split path array and convert any escaped period\n\t// placeholders back to their real period characters\n\tfor (let i = 0; i < splitPath.length; i++) {\n\t\tsplitPath[i] = splitPath[i].replace(/\\[--]/g, \"\\\\.\");\n\t}\n\t\n\treturn splitPath;\n};\n\n/**\n * Escapes any periods in the passed string so they will\n * not be identified as part of a path. Useful if you have\n * a path like \"domains.www.google.com.data\" where the\n * \"www.google.com\" should not be considered part of the\n * traversal as it is actually in an object like:\n * {\n * \t\"domains\": {\n * \t\t\"www.google.com\": {\n * \t\t\t\"data\": \"foo\"\n * \t\t}\n * \t}\n * }\n * @param {String} str The string to escape periods in.\n * @return {String} The escaped string.\n */\nconst escape = (str) => {\n\treturn str.replace(/\\./g, \"\\\\.\");\n};\n\n/**\n * Converts a string previously escaped with the `escape()`\n * function back to its original value.\n * @param {String} str The string to unescape.\n * @returns {string} The unescaped string.\n */\nconst unEscape = (str) => {\n\treturn str.replace(/\\\\./g, \".\");\n};\n\n/**\n * Gets a single value from the passed object and given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {*=} defaultVal Optional default to return if the\n * value retrieved from the given object and path equals undefined.\n * @param {Object=} options Optional options object.\n * @returns {*} The value retrieved from the passed object at\n * the passed path.\n */\nconst get = (obj, path, defaultVal = undefined, options = {}) => {\n\tlet internalPath = path,\n\t\tobjPart;\n\t\n\tif (path instanceof Array) {\n\t\treturn path.map((individualPath) => {\n\t\t\tget(obj, individualPath, defaultVal, options);\n\t\t});\n\t}\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\t// No object data, return undefined\n\tif (obj === undefined || obj === null) {\n\t\treturn defaultVal;\n\t}\n\t\n\t// No path string, return the base obj\n\tif (!internalPath) {\n\t\treturn obj;\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\t// Path has no dot-notation, return key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\treturn obj[internalPath] !== undefined ? obj[internalPath] : defaultVal;\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn defaultVal !== undefined ? defaultVal : undefined;\n\t}\n\t\n\tconst pathParts = split(internalPath);\n\tobjPart = obj;\n\t\n\tfor (let i = 0; i < pathParts.length; i++) {\n\t\tconst pathPart = pathParts[i];\n\t\tobjPart = objPart[options.transformKey(unEscape(pathPart))];\n\t\t\n\t\tif (objPart instanceof Array && options.arrayTraversal === true) {\n\t\t\t// The data is an array and we have arrayTraversal enabled\n\t\t\t// so loop the array items and return the first non-undefined\n\t\t\t// value from any array item leaf node that matches the path\n\t\t\tconst result = objPart.reduce((result, arrItem) => {\n\t\t\t\treturn get(arrItem, pathParts.slice(i + 1).join(\".\"), defaultVal, options);\n\t\t\t}, undefined);\n\t\t\t\n\t\t\treturn result !== undefined ? result : defaultVal;\n\t\t} else if (!objPart || typeof objPart !== \"object\") {\n\t\t\tif (i !== pathParts.length - 1) {\n\t\t\t\t// The path terminated in the object before we reached\n\t\t\t\t// the end node we wanted so make sure we return undefined\n\t\t\t\tobjPart = undefined;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn objPart !== undefined ? objPart : defaultVal;\n};\n\n/**\n * Sets a single value on the passed object and given path. This\n * will directly modify the \"obj\" object. If you need immutable\n * updates, use setImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to set data on.\n * @param {*} val The value to assign to the obj at the path.\n * @param {Object=} options The options object.\n * @returns {*} Nothing.\n */\nconst set = (obj, path, val, options = {}) => {\n\tlet internalPath = path,\n\t\tobjPart;\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\t// No object data\n\tif (obj === undefined || obj === null) {\n\t\treturn;\n\t}\n\t\n\t// No path string\n\tif (!internalPath) {\n\t\treturn;\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn;\n\t}\n\t\n\t// Path has no dot-notation, set key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\tobj = decouple(obj, options);\n\t\tobj[options.transformKey(unEscape(internalPath))] = val;\n\t\treturn obj;\n\t}\n\t\n\tconst newObj = decouple(obj, options);\n\tconst pathParts = split(internalPath);\n\tconst pathPart = pathParts.shift();\n\tconst transformedPathPart = options.transformKey(pathPart);\n\tlet childPart = newObj[transformedPathPart];\n\t\n\tif (typeof childPart !== \"object\") {\n\t\t// Create an object or array on the path\n\t\tif (String(parseInt(transformedPathPart, 10)) === transformedPathPart) {\n\t\t\t// This is an array index\n\t\t\tnewObj[transformedPathPart] = [];\n\t\t} else {\n\t\t\tnewObj[transformedPathPart] = {};\n\t\t}\n\t\t\n\t\tobjPart = newObj[transformedPathPart];\n\t} else {\n\t\tobjPart = childPart;\n\t}\n\t\n\treturn set(newObj, transformedPathPart, set(objPart, pathParts.join('.'), val, options), options);\n};\n\n/**\n * Deletes a key from an object by the given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to delete.\n * @param {Object=} options The options object.\n * @param {Object=} tracking Do not use.\n */\nconst unSet = (obj, path, options = {}, tracking = {}) => {\n\tlet internalPath = path;\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\t// No object data\n\tif (obj === undefined || obj === null) {\n\t\treturn;\n\t}\n\t\n\t// No path string\n\tif (!internalPath) {\n\t\treturn;\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn;\n\t}\n\t\n\tconst newObj = decouple(obj, options);\n\t\n\t// Path has no dot-notation, set key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\tif (newObj.hasOwnProperty(unEscape(internalPath))) {\n\t\t\tdelete newObj[options.transformKey(unEscape(internalPath))];\n\t\t\treturn newObj;\n\t\t}\n\t\t\n\t\ttracking.returnOriginal = true;\n\t\treturn obj;\n\t}\n\t\n\t\n\tconst pathParts = split(internalPath);\n\tconst pathPart = pathParts.shift();\n\tconst transformedPathPart = options.transformKey(unEscape(pathPart));\n\tlet childPart = newObj[transformedPathPart];\n\t\n\tif (!childPart) {\n\t\t// No child part available, nothing to unset!\n\t\ttracking.returnOriginal = true;\n\t\treturn obj;\n\t}\n\t\n\tnewObj[transformedPathPart] = unSet(childPart, pathParts.join('.'), options, tracking);\n\t\n\tif (tracking.returnOriginal) {\n\t\treturn obj;\n\t}\n\t\n\treturn newObj;\n};\n\n/**\n * Takes an update object or array and iterates the keys of it, then\n * sets data on the target object or array at the specified path with\n * the corresponding value from the path key, effectively doing\n * multiple set() operations in a single call. This will directly\n * modify the \"obj\" object. If you need immutable updates, use\n * updateImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The object with the modified data.\n */\nconst update = (obj, updateData, options = {}) => {\n\tlet newObj = obj;\n\t\n\tfor (let path in updateData) {\n\t\tif (updateData.hasOwnProperty(path)) {\n\t\t\tconst data = updateData[path];\n\t\t\tnewObj = set(newObj, path, data, options);\n\t\t}\n\t}\n\t\n\treturn newObj;\n};\n\n/**\n * If options.immutable === true then return a new de-referenced\n * instance of the passed object/array. If immutable is false\n * then simply return the same `obj` that was passed.\n * @param {*} obj The object or array to decouple.\n * @param {Object=} options The options object that has the immutable\n * key with a boolean value.\n * @returns {*} The new decoupled instance (if immutable is true)\n * or the original `obj` if immutable is false.\n */\nconst decouple = (obj, options = {}) => {\n\tif (!options.immutable) {\n\t\treturn obj;\n\t}\n\t\n\treturn _newInstance(obj);\n};\n\n/**\n * Push a value to an array on an object for the specified path.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to push to.\n * @param {*} val The value to push to the array at the object path.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\nconst pushVal = (obj, path, val, options = {}) => {\n\tif (obj === undefined || obj === null || path === undefined) {\n\t\treturn obj;\n\t}\n\t\n\t// Clean the path\n\tpath = clean(path);\n\t\n\tconst pathParts = split(path);\n\tconst part = pathParts.shift();\n\t\n\tif (pathParts.length) {\n\t\t// Generate the path part in the object if it does not already exist\n\t\tobj[part] = decouple(obj[part], options) || {};\n\t\t\n\t\t// Recurse\n\t\tpushVal(obj[part], pathParts.join(\".\"), val, options);\n\t} else if (part) {\n\t\t// We have found the target array, push the value\n\t\tobj[part] = decouple(obj[part], options) || [];\n\t\t\n\t\tif (!(obj[part] instanceof Array)) {\n\t\t\tthrow(\"Cannot push to a path whose leaf node is not an array!\");\n\t\t}\n\t\t\n\t\tobj[part].push(val);\n\t} else {\n\t\t// We have found the target array, push the value\n\t\tobj = decouple(obj, options) || [];\n\t\t\n\t\tif (!(obj instanceof Array)) {\n\t\t\tthrow(\"Cannot push to a path whose leaf node is not an array!\");\n\t\t}\n\t\t\n\t\tobj.push(val);\n\t}\n\t\n\treturn decouple(obj, options);\n};\n\n/**\n * Pull a value to from an array at the specified path. Removes the first\n * matching value, not every matching value.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to pull from.\n * @param {*} val The value to pull from the array.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\nconst pullVal = (obj, path, val, options = {strict: true}) => {\n\tif (obj === undefined || obj === null || path === undefined) {\n\t\treturn obj;\n\t}\n\t\n\t// Clean the path\n\tpath = clean(path);\n\t\n\tconst pathParts = split(path);\n\tconst part = pathParts.shift();\n\t\n\tif (pathParts.length) {\n\t\t// Generate the path part in the object if it does not already exist\n\t\tobj[part] = decouple(obj[part], options) || {};\n\t\t\n\t\t// Recurse - we don't need to assign obj[part] the result of this call because\n\t\t// we are modifying by reference since we haven't reached the furthest path\n\t\t// part (leaf) node yet\n\t\tpullVal(obj[part], pathParts.join(\".\"), val, options);\n\t} else if (part) {\n\t\tobj[part] = decouple(obj[part], options) || [];\n\t\t\n\t\t// Recurse - this is the leaf node so assign the response to obj[part] in\n\t\t// case it is set to an immutable response\n\t\tobj[part] = pullVal(obj[part], \"\", val, options);\n\t} else {\n\t\t// The target array is the root object, pull the value\n\t\tobj = decouple(obj, options) || [];\n\t\t\n\t\tif (!(obj instanceof Array)) {\n\t\t\tthrow(\"Cannot pull from a path whose leaf node is not an array!\");\n\t\t}\n\t\t\n\t\tlet index = -1;\n\t\t\n\t\t// Find the index of the passed value\n\t\tif (options.strict === true) {\n\t\t\tindex = obj.indexOf(val);\n\t\t} else {\n\t\t\t// Do a non-strict check\n\t\t\tindex = obj.findIndex((item) => {\n\t\t\t\treturn match(item, val);\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (index > -1) {\n\t\t\t// Remove the item from the array\n\t\t\tobj.splice(index, 1);\n\t\t}\n\t}\n\t\n\treturn decouple(obj, options);\n};\n\n/**\n * Given a path and an object, determines the outermost leaf node\n * that can be reached where the leaf value is not undefined.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {String} The path to the furthest non-undefined value.\n */\nconst furthest = (obj, path, options = {}) => {\n\tlet internalPath = path,\n\t\tobjPart;\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": wildcardToZero, // Any path that has a wildcard will essentially check the first array item to continue down the tree\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tconst finalPath = [];\n\t\n\t// No path string, return the base obj\n\tif (!internalPath) {\n\t\treturn finalPath.join(\".\");\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn finalPath.join(\".\");\n\t}\n\t\n\t// Path has no dot-notation, return key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\tif (obj[internalPath] !== undefined) {\n\t\t\treturn internalPath;\n\t\t}\n\t\t\n\t\treturn finalPath.join(\".\");\n\t}\n\t\n\tconst pathParts = split(internalPath);\n\tobjPart = obj;\n\t\n\tfor (let i = 0; i < pathParts.length; i++) {\n\t\tconst pathPart = pathParts[i];\n\t\tobjPart = objPart[options.transformKey(unEscape(pathPart))];\n\t\t\n\t\tif (objPart === undefined) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfinalPath.push(pathPart);\n\t}\n\t\n\treturn finalPath.join(\".\");\n};\n\n/**\n * Traverses the object by the given path and returns an object where\n * each key is a path pointing to a leaf node and contains the value\n * from the leaf node from the overall object in the obj argument,\n * essentially providing all available paths in an object and all the\n * values for each path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {Object|Array} The result of the traversal.\n */\nconst values = (obj, path, options = {}) => {\n\tconst internalPath = clean(path);\n\tconst pathParts = split(internalPath);\n\tconst currentPath = [];\n\tconst valueData = {};\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tfor (let i = 0; i < pathParts.length; i++) {\n\t\tconst pathPart = options.transformKey(pathParts[i]);\n\t\tcurrentPath.push(pathPart);\n\t\t\n\t\tconst tmpPath = currentPath.join(\".\");\n\t\t\n\t\tvalueData[tmpPath] = get(obj, tmpPath);\n\t}\n\t\n\treturn valueData;\n};\n\n/**\n * Takes an object and finds all paths, then returns the paths as an\n * array of strings.\n * @param {Object|Array} obj The object to scan.\n * @param {Array=} finalArr An object used to collect the path keys.\n * (Do not pass this in directly - use undefined).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly - use undefined).\n * @param {Object=} options An options object.\n * @returns {Array<String>} An array containing path strings.\n */\nconst flatten = (obj, finalArr = [], parentPath = \"\", options = {}, objCache = []) => {\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tconst transformedObj = options.transformRead(obj);\n\t\n\t// Check that we haven't visited this object before (avoid infinite recursion)\n\tif (objCache.indexOf(transformedObj) > -1) {\n\t\treturn finalArr;\n\t}\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(transformedObj);\n\t\n\tconst currentPath = (i) => {\n\t\tconst tKey = options.transformKey(i);\n\t\treturn parentPath ? parentPath + \".\" + tKey : tKey;\n\t};\n\t\n\tfor (const i in transformedObj) {\n\t\tif (transformedObj.hasOwnProperty(i)) {\n\t\t\tif (options.ignore && options.ignore.test(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof transformedObj[i] === \"object\" && transformedObj[i] !== null) {\n\t\t\t\tflatten(transformedObj[i], finalArr, currentPath(i), options, objCache);\n\t\t\t}\n\t\t\t\n\t\t\tfinalArr.push(currentPath(i));\n\t\t}\n\t}\n\t\n\treturn finalArr;\n};\n\n/**\n * Takes an object and finds all paths, then returns the paths as keys\n * and the values of each path as the values.\n * @param {Object|Array} obj The object to scan.\n * @param {Object=} finalObj An object used to collect the path keys.\n * (Do not pass this in directly).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly).\n * @param {Object=} options An options object.\n * @returns {Object|Array} An object containing path keys and their values.\n */\nconst flattenValues = (obj, finalObj = {}, parentPath = \"\", options = {}, objCache = []) => {\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tconst transformedObj = options.transformRead(obj);\n\t\n\t// Check that we haven't visited this object before (avoid infinite recursion)\n\tif (objCache.indexOf(transformedObj) > -1) {\n\t\treturn finalObj;\n\t}\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(transformedObj);\n\t\n\tconst currentPath = (i, info) => {\n\t\tconst tKey = options.transformKey(i, info);\n\t\treturn parentPath ? parentPath + \".\" + tKey : tKey;\n\t};\n\t\n\tfor (const i in transformedObj) {\n\t\tif (transformedObj.hasOwnProperty(i)) {\n\t\t\tconst type = typeof transformedObj[i];\n\t\t\tconst info = {\n\t\t\t\ttype,\n\t\t\t\tisArrayIndex: Array.isArray(transformedObj),\n\t\t\t\tisFlat: type !== \"object\" || transformedObj[i] instanceof Date || transformedObj[i] instanceof RegExp\n\t\t\t};\n\t\t\t\n\t\t\tconst pathKey = currentPath(i, info);\n\t\t\t\n\t\t\tif (!info.isFlat) {\n\t\t\t\tif (transformedObj[i] !== null) {\n\t\t\t\t\tflattenValues(transformedObj[i], finalObj, pathKey, options, objCache);\n\t\t\t\t}\n\t\t\t} else if (options.leavesOnly) {\n\t\t\t\t// Found leaf node!\n\t\t\t\tfinalObj[pathKey] = options.transformWrite(transformedObj[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (!options.leavesOnly) {\n\t\t\t\tfinalObj[pathKey] = options.transformWrite(transformedObj[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn finalObj;\n};\n\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args args Path to join.\n * @returns {String} A final path string.\n */\nconst join = (...args) => {\n\treturn args.reduce((arr, item) => {\n\t\tif (item !== undefined && String(item)) {\n\t\t\tarr.push(item);\n\t\t}\n\t\t\n\t\treturn arr;\n\t}, []).join(\".\");\n};\n\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args Path to join.\n * @returns {String} A final path string.\n */\nconst joinEscaped = (...args) => {\n\tconst escapedArgs = args.map((item) => {\n\t\treturn escape(item);\n\t});\n\t\n\treturn join(...escapedArgs);\n};\n\n/**\n * Counts the total number of key leaf nodes in the passed object.\n * @param {Object|Array} obj The object to count key leaf nodes for.\n * @param {Array=} objCache Do not use. Internal array to track\n * visited leafs.\n * @returns {Number} The number of keys.\n */\nconst countLeafNodes = (obj, objCache = []) => {\n\tlet totalKeys = 0;\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(obj);\n\t\n\tfor (const i in obj) {\n\t\tif (obj.hasOwnProperty(i)) {\n\t\t\tif (obj[i] !== undefined) {\n\t\t\t\tif (typeof obj[i] !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n\t\t\t\t\ttotalKeys++;\n\t\t\t\t} else {\n\t\t\t\t\ttotalKeys += countLeafNodes(obj[i], objCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn totalKeys;\n};\n\n/**\n * Finds all the leaf nodes for a given object and returns an array of paths\n * to them. This is different from `flatten()` in that it only includes leaf\n * nodes and will not include every intermediary path traversed to get to a\n * leaf node.\n * @param {Object|Array} obj The object to traverse.\n * @param {String} [parentPath=\"\"] The path to use as a root/base path to\n * start scanning for leaf nodes under.\n * @param {Object} [objCache=[]] Internal usage to check for cyclic structures.\n * @returns {[]}\n */\nconst leafNodes = (obj, parentPath = \"\", objCache = []) => {\n\tconst paths = [];\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(obj);\n\t\n\tfor (const i in obj) {\n\t\tif (obj.hasOwnProperty(i)) {\n\t\t\tif (obj[i] !== undefined) {\n\t\t\t\tconst currentPath = join(parentPath, i);\n\t\t\t\t\n\t\t\t\tif (typeof obj[i] !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n\t\t\t\t\tpaths.push(currentPath);\n\t\t\t\t} else {\n\t\t\t\t\tpaths.push(...leafNodes(obj[i], currentPath, objCache));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn paths;\n};\n\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths. MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Boolean} True if the object paths exist.\n */\nconst hasMatchingPathsInObject = function (testKeys, testObj) {\n\tlet result = true;\n\t\n\tfor (const i in testKeys) {\n\t\tif (testKeys.hasOwnProperty(i)) {\n\t\t\tif (testObj[i] === undefined) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof testKeys[i] === \"object\" && testKeys[i] !== null) {\n\t\t\t\t// Recurse object\n\t\t\t\tresult = hasMatchingPathsInObject(testKeys[i], testObj[i]);\n\t\t\t\t\n\t\t\t\t// Should we exit early?\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths and if so returns the number matched.\n * MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Object<matchedKeys<Number>, matchedKeyCount<Number>, totalKeyCount<Number>>} Stats on the matched keys.\n */\nconst countMatchingPathsInObject = (testKeys, testObj) => {\n\tconst matchedKeys = {};\n\t\n\tlet matchData,\n\t\tmatchedKeyCount = 0,\n\t\ttotalKeyCount = 0;\n\t\n\tfor (const i in testObj) {\n\t\tif (testObj.hasOwnProperty(i)) {\n\t\t\tif (typeof testObj[i] === \"object\" && testObj[i] !== null) {\n\t\t\t\t// The test / query object key is an object, recurse\n\t\t\t\tmatchData = countMatchingPathsInObject(testKeys[i], testObj[i]);\n\t\t\t\t\n\t\t\t\tmatchedKeys[i] = matchData.matchedKeys;\n\t\t\t\ttotalKeyCount += matchData.totalKeyCount;\n\t\t\t\tmatchedKeyCount += matchData.matchedKeyCount;\n\t\t\t} else {\n\t\t\t\t// The test / query object has a property that is not an object so add it as a key\n\t\t\t\ttotalKeyCount++;\n\t\t\t\t\n\t\t\t\t// Check if the test keys also have this key and it is also not an object\n\t\t\t\tif (testKeys && testKeys[i] && (typeof testKeys[i] !== \"object\" || testKeys[i] === null)) {\n\t\t\t\t\tmatchedKeys[i] = true;\n\t\t\t\t\tmatchedKeyCount++;\n\t\t\t\t} else {\n\t\t\t\t\tmatchedKeys[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn {\n\t\tmatchedKeys,\n\t\tmatchedKeyCount,\n\t\ttotalKeyCount\n\t};\n};\n\n/**\n * Returns the type from the item passed. Similar to JavaScript's\n * built-in typeof except it will distinguish between arrays, nulls\n * and objects as well.\n * @param {*} item The item to get the type of.\n * @returns {string|\"undefined\"|\"object\"|\"boolean\"|\"number\"|\"string\"|\"function\"|\"symbol\"|\"null\"|\"array\"}\n */\nconst type = (item) => {\n\tif (item === null) {\n\t\treturn 'null';\n\t}\n\tif (Array.isArray(item)) {\n\t\treturn 'array';\n\t}\n\t\n\treturn typeof item;\n};\n\n/**\n * Determines if the query data exists anywhere inside the source\n * data. Will recurse into arrays and objects to find query.\n * @param {*} source The source data to check.\n * @param {*} query The query data to find.\n * @returns {Boolean} True if query was matched, false if not.\n */\nconst match = (source, query) => {\n\tconst sourceType = typeof source;\n\tconst queryType = typeof query;\n\t\n\tif (sourceType !== queryType) {\n\t\treturn false;\n\t}\n\t\n\tif (sourceType !== \"object\" || source === null) {\n\t\t// Simple test\n\t\treturn source === query;\n\t}\n\t\n\t// The source is an object-like (array or object) structure\n\tconst entries = Object.entries(query);\n\t\n\tconst foundNonMatch = entries.find(([key, val]) => {\n\t\t// Recurse if type is array or object\n\t\tif (typeof val === \"object\" && val !== null) {\n\t\t\treturn !match(source[key], val);\n\t\t}\n\t\t\n\t\treturn source[key] !== val;\n\t});\n\t\n\treturn !foundNonMatch;\n};\n\n/**\n * @typedef {object} FindOptionsObject\n * @property {number} [maxDepth=Infinity] The maximum depth to scan inside\n * the source object for matching data.\n * @property {number} [currentDepth=0] The current depth of the\n * operation scan.\n * @property {boolean} [includeRoot=true] If true, will include the\n * root source object if it matches the query.\n */\n\n/**\n * Finds all items that matches the structure of `query` and\n * returns the path to them as an array of strings.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<Array>.\n */\nconst findPath = (source, query, options = {maxDepth: Infinity, currentDepth: 0, includeRoot: true}, parentPath = \"\") => {\n\tconst resultArr = [];\n\tconst sourceType = typeof source;\n\t\n\toptions = {\n\t\tmaxDepth: Infinity,\n\t\tcurrentDepth: 0,\n\t\tincludeRoot: true,\n\t\t...options\n\t};\n\t\n\tif (options.currentDepth !== 0 || (options.currentDepth === 0 && options.includeRoot)) {\n\t\tif (match(source, query)) {\n\t\t\tresultArr.push(parentPath);\n\t\t}\n\t}\n\t\n\toptions.currentDepth++;\n\t\n\tif (options.currentDepth <= options.maxDepth && sourceType === \"object\") {\n\t\tconst entries = Object.entries(source);\n\t\t\n\t\tentries.forEach(([key, val]) => {\n\t\t\t// Recurse down object to find more instances\n\t\t\tconst result = findPath(val, query, options, join(parentPath, key));\n\t\t\t\n\t\t\tif (result.match) {\n\t\t\t\tresultArr.push(...result.path);\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn {match: resultArr.length > 0, path: resultArr};\n};\n\n/**\n * Finds the first item that matches the structure of `query`\n * and returns the path to it.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<String>.\n */\nconst findOnePath = (source, query, options = {maxDepth: Infinity, currentDepth: 0, includeRoot: true}, parentPath = \"\") => {\n\tconst sourceType = typeof source;\n\t\n\toptions = {\n\t\tmaxDepth: Infinity,\n\t\tcurrentDepth: 0,\n\t\tincludeRoot: true,\n\t\t...options\n\t};\n\t\n\tif (options.currentDepth !== 0 || (options.currentDepth === 0 && options.includeRoot)) {\n\t\tif (match(source, query)) {\n\t\t\treturn {\n\t\t\t\tmatch: true,\n\t\t\t\tpath: parentPath\n\t\t\t};\n\t\t}\n\t}\n\t\n\toptions.currentDepth++;\n\t\n\tif (options.currentDepth <= options.maxDepth && sourceType === \"object\" && source !== null) {\n\t\tconst entries = Object.entries(source);\n\t\t\n\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\tconst [key, val] = entries[i];\n\t\t\t\n\t\t\t// Recurse down object to find more instances\n\t\t\tconst subPath = join(parentPath, key);\n\t\t\tconst result = findOnePath(val, query, options, subPath);\n\t\t\t\n\t\t\tif (result.match) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn {match: false};\n};\n\n/**\n * Returns a deduplicated array of strings.\n * @param {Array<String>} keys An array of strings to deduplicate.\n * @returns {Array<String>} The deduplicated array.\n */\nconst keyDedup = (keys) => {\n\treturn keys.filter((elem, pos, arr) => {\n\t\treturn arr.indexOf(elem) === pos;\n\t});\n};\n\n/**\n * Compares two provided objects / arrays and returns an array of\n * dot-notation paths to the fields that hold different values.\n * @param {Object|Array} obj1 The first object / array to compare.\n * @param {Object|Array} obj2 The second object / array to compare.\n * @param {String=\"\"} basePath The base path from which to check for\n * differences. Differences outside the base path will not be\n * returned as part of the array of differences. Leave blank to check\n * for all differences between the two objects to compare.\n * @param {Boolean=false} strict If strict is true, diff uses strict\n * equality to determine difference rather than non-strict equality;\n * effectively (=== is strict, == is non-strict).\n * @param {Number=Infinity} maxDepth Specifies the maximum number of\n * path sub-trees to walk down before returning what we have found.\n * For instance, if set to 2, a diff would only check down,\n * \"someFieldName.anotherField\", or \"user.name\" and would not go\n * further down than two fields. If anything in the trees further\n * down than this level have changed, the change will not be detected\n * and the path will not be included in the resulting diff array.\n * @param {String=\"\"} parentPath Used internally only.\n * @returns {Array} An array of strings, each string is a path to a\n * field that holds a different value between the two objects being\n * compared.\n */\nconst diff = (obj1, obj2, basePath = \"\", strict = false, maxDepth = Infinity, parentPath = \"\", objCache = []) => {\n\tconst paths = [];\n\t\n\tif (basePath instanceof Array) {\n\t\t// We were given an array of paths, check each path\n\t\treturn basePath.reduce((arr, individualPath) => {\n\t\t\t// Here we find any path that has a *non-equal* result which\n\t\t\t// returns true and then returns the index as a positive integer\n\t\t\t// that is not -1. If -1 is returned then no non-equal matches\n\t\t\t// were found\n\t\t\tconst result = diff(obj1, obj2, individualPath, strict, maxDepth, parentPath, objCache);\n\t\t\tif (result && result.length) {\n\t\t\t\tarr.push(...result);\n\t\t\t}\n\t\t\t\n\t\t\treturn arr;\n\t\t}, []);\n\t}\n\t\n\tconst currentPath = join(parentPath, basePath);\n\tconst val1 = get(obj1, basePath);\n\tconst val2 = get(obj2, basePath);\n\tconst type1 = type(val1);\n\tconst type2 = type(val2);\n\t\n\tif (type1 !== type2) {\n\t\t// Difference in source and comparison types\n\t\tpaths.push(currentPath);\n\t} else if (type1 === \"array\" && val1.length !== val2.length) {\n\t\t// Difference in source and comparison types\n\t\tpaths.push(currentPath);\n\t}\n\t\n\tconst pathParts = currentPath.split(\".\");\n\tconst hasParts = pathParts[0] !== \"\";\n\t\n\tif ((!hasParts || pathParts.length < maxDepth) && typeof val1 === \"object\" && val1 !== null) {\n\t\t// Check that we haven't visited this object before (avoid infinite recursion)\n\t\tif (objCache.indexOf(val1) > -1 || objCache.indexOf(val2) > -1) {\n\t\t\treturn paths;\n\t\t}\n\t\t\n\t\tobjCache.push(val1);\n\t\tobjCache.push(val2);\n\t\t\n\t\t// Grab composite of all keys on val1 and val2\n\t\tconst val1Keys = Object.keys(val1);\n\t\tconst val2Keys = (typeof val2 === \"object\" && val2 !== null) ? Object.keys(val2) : [];\n\t\tconst compositeKeys = keyDedup(val1Keys.concat(val2Keys));\n\t\t\n\t\treturn compositeKeys.reduce((arr, key) => {\n\t\t\tconst result = diff(val1, val2, key, strict, maxDepth, currentPath, objCache);\n\t\t\tif (result && result.length) {\n\t\t\t\tarr.push(...result);\n\t\t\t}\n\t\t\t\n\t\t\treturn arr;\n\t\t}, paths);\n\t}\n\t\n\tif ((strict && val1 !== val2) || (!strict && val1 != val2)) {\n\t\tpaths.push(currentPath);\n\t}\n\t\n\treturn keyDedup(paths);\n};\n\n/**\n * A boolean check to see if the values at the given path or paths\n * are the same in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to check\n * values in. If this is an array, all values at the paths in the array\n * must be the same for the function to provide a true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for equality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values match, false if not.\n */\nconst isEqual = (obj1, obj2, path, deep = false, strict = false) => {\n\tif (path instanceof Array) {\n\t\t// We were given an array of paths, check each path\n\t\treturn path.findIndex((individualPath) => {\n\t\t\t// Here we find any path that has a *non-equal* result which\n\t\t\t// returns true and then returns the index as a positive integer\n\t\t\t// that is not -1. If -1 is returned then no non-equal matches\n\t\t\t// were found\n\t\t\treturn isNotEqual(obj1, obj2, individualPath, deep, strict);\n\t\t}) === -1;\n\t}\n\t\n\tconst val1 = get(obj1, path);\n\tconst val2 = get(obj2, path);\n\t\n\tif (deep) {\n\t\tif (typeof val1 === \"object\" && val1 !== null) {\n\t\t\t// TODO: This probably needs a composite key array of val1 and val2 keys\n\t\t\t//  just as we do in the diff() function\n\t\t\treturn Object.keys(val1).findIndex((key) => {\n\t\t\t\treturn isNotEqual(val1, val2, key, deep, strict);\n\t\t\t}) === -1;\n\t\t}\n\t}\n\t\n\treturn (strict && val1 === val2) || (!strict && val1 == val2);\n};\n\n/**\n * A boolean check to see if the values at the given path or paths\n * are different in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to\n * check values in. If this is an array, all values at the paths\n * in the array must be different for the function to provide a\n * true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for inequality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-not-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values differ, false if not.\n */\nconst isNotEqual = (obj1, obj2, path, deep = false, strict = false) => {\n\treturn !isEqual(obj1, obj2, path, deep, strict);\n};\n\n/**\n * Same as set() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst setImmutable = (obj, path, val, options = {}) => {\n\treturn set(obj, path, val, {...options, immutable: true});\n};\n\n/**\n * Same as pushVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst pushValImmutable = (obj, path, val, options = {}) => {\n\treturn pushVal(obj, path, val, {...options, immutable: true});\n};\n\n/**\n * Same as pullVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst pullValImmutable = (obj, path, val, options = {}) => {\n\treturn pullVal(obj, path, val, {...options, immutable: true});\n};\n\n/**\n * Same as unSet() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst unSetImmutable = (obj, path, options = {}) => {\n\treturn unSet(obj, path, {...options, immutable: true});\n};\n\n/**\n * Same as update() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst updateImmutable = (obj, updateData, options) => {\n\treturn update(obj, updateData, {...options, immutable: true});\n};\n\n/**\n * Gets the values of the paths in pathArr and returns them as an object\n * with each key matching the path and the value matching the value from\n * obj that was at that path.\n * @param {Object} obj The object to operate on.\n * @param {Array<String>} pathArr Array of path strings.\n * @returns {*} The new object.\n */\nconst distill = (obj, pathArr) => {\n\treturn pathArr.reduce((newObj, path) => {\n\t\tnewObj[path] = get(obj, path);\n\t\treturn newObj;\n\t}, {});\n};\n\n/**\n * Chops a `path` string down to the given `level`. Given a `path` string\n * like \"foo.bar.ram.you.too\", chop will remove any path parts below\n * the given `level`. If we pass 2 as the `level` with that given `path`,\n * the result will be \"foo.bar\" as foo is level 1 and bar is level 2.\n * If the `path` is shorter than the given `level`, it is returned intact.\n * @param {String} path The path to operate on.\n * @param {Number} level The maximum level of a path.\n * @returns {String} The new path string.\n */\nconst chop = (path, level) => {\n\tconst parts = split(path);\n\n\tif (parts.length > level) {\n\t\tparts.length = level;\n\t}\n\n\treturn join(...parts);\n};\n\nmodule.exports = {\n\twildcardToZero,\n\tnumberToWildcard,\n\tclean,\n\tdecouple,\n\tsplit,\n\tescape,\n\tget,\n\tset,\n\tsetImmutable,\n\tunSet,\n\tunSetImmutable,\n\tpushValImmutable,\n\tpushVal,\n\tpullValImmutable,\n\tpullVal,\n\tfurthest,\n\tvalues,\n\tflatten,\n\tflattenValues,\n\tjoin,\n\tjoinEscaped,\n\tup,\n\tdown,\n\tpush,\n\tpop,\n\tshift,\n\tcountLeafNodes,\n\thasMatchingPathsInObject,\n\tcountMatchingPathsInObject,\n\tfindOnePath,\n\tfindPath,\n\ttype,\n\tmatch,\n\tisEqual,\n\tisNotEqual,\n\tleafNodes,\n\tdiff,\n\tupdate,\n\tupdateImmutable,\n\tdistill,\n\tchop\n};"], "fixing_code": ["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * Scans an object for all keys that are either objects or arrays\n * and returns an array of those keys only.\n * @param {Object|Array} obj The object to scan.\n * @returns {[string]} An array of string keys.\n * @private\n */\nvar _iterableKeys = function _iterableKeys(obj) {\n  return Object.entries(obj).reduce(function (arr, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        key = _ref2[0],\n        val = _ref2[1];\n\n    var valType = type(val);\n\n    if (valType === \"object\" || valType === \"array\") {\n      arr.push(key);\n    }\n\n    return arr;\n  }, []);\n};\n/**\n * Creates a new instance of \"item\" that is dereferenced. Useful\n * when you want to return a new version of \"item\" with the same\n * data for immutable data structures.\n * @param {Object|Array} item The item to mimic.\n * @param {String} key The key to set data in.\n * @param {*} val The data to set in the key.\n * @returns {*} A new dereferenced version of \"item\" with the \"key\"\n * containing the \"val\" data.\n * @private\n */\n\n\nvar _newInstance = function _newInstance(item) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var objType = type(item);\n  var newObj;\n\n  if (objType === \"object\") {\n    newObj = _objectSpread({}, item);\n  }\n\n  if (objType === \"array\") {\n    newObj = (0, _toConsumableArray2[\"default\"])(item);\n  }\n\n  if (key !== undefined) {\n    newObj[key] = val;\n  }\n\n  return newObj;\n};\n/**\n * Determines if the given path points to a root leaf node (has no delimiter)\n * or contains a dot delimiter so will drill down before reaching a leaf node.\n * If it has a delimiter, it is called a \"composite\" path.\n * @param {String} path The path to evaluate.\n * @returns {boolean} True if delimiter found, false if not.\n */\n\n\nvar isCompositePath = function isCompositePath(path) {\n  var regExp = /\\./g;\n  var result;\n\n  while (result = regExp.exec(path)) {\n    // Check if the previous character was an escape\n    // and if so, ignore this delimiter\n    if (result.index === 0 || path.substr(result.index - 1, 1) !== \"\\\\\") {\n      // This is not an escaped path so it IS a composite path\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Provides the opposite of `isCompositePath()`. If a delimiter is found, this\n * function returns false.\n * @param {String} path The path to evaluate.\n * @returns {boolean} False if delimiter found, true if not.\n */\n\n\nvar isNonCompositePath = function isNonCompositePath(path) {\n  return !isCompositePath(path);\n};\n/**\n * Returns the given path after removing the last\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"foo.bar\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move up.\n * @returns {String} The new path string.\n */\n\n\nvar up = function up(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n\n  for (var i = 0; i < levels; i++) {\n    parts.pop();\n  }\n\n  return parts.join(\".\");\n};\n/**\n * Returns the given path after removing the first\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"bar.thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move down.\n * @returns {String} The new path string.\n */\n\n\nvar down = function down(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n\n  for (var i = 0; i < levels; i++) {\n    parts.shift();\n  }\n\n  return parts.join(\".\");\n};\n/**\n * Returns the last leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * pop.\n * @returns {String} The new path string.\n */\n\n\nvar pop = function pop(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n  var part;\n\n  for (var i = 0; i < levels; i++) {\n    part = parts.pop();\n  }\n\n  return part || \"\";\n};\n/**\n * Adds a leaf to the end of the path. E.g.\n * pushing \"goo\" to path \"foo.bar.thing\" returns\n * \"foo.bar.thing.goo\".\n * @param {String} path The path to operate on.\n * @param {String} val The string value to push\n * to the end of the path.\n * @returns {String} The new path string.\n */\n\n\nvar push = function push(path) {\n  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return \"\".concat(path, \".\").concat(val);\n};\n/**\n * Returns the first leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"foo\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * shift.\n * @returns {String} The new path string.\n */\n\n\nvar shift = function shift(path) {\n  var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var parts = split(path);\n  var part;\n\n  for (var i = 0; i < levels; i++) {\n    part = parts.shift();\n  }\n\n  return part || \"\";\n};\n/**\n * A function that just returns the first argument.\n * @param {*} val The argument to return.\n * @returns {*} The passed argument.\n */\n\n\nvar returnWhatWasGiven = function returnWhatWasGiven(val) {\n  return val;\n};\n/**\n * Converts any key matching the wildcard to a zero.\n * @param {String} key The key to test.\n * @returns {String} The key.\n */\n\n\nvar wildcardToZero = function wildcardToZero(key) {\n  return key === \"$\" ? \"0\" : key;\n};\n/**\n * If a key is a number, will return a wildcard, otherwise\n * will return the originally passed key.\n * @param {String} key The key to test.\n * @returns {String} The original key or a wildcard.\n */\n\n\nvar numberToWildcard = function numberToWildcard(key) {\n  // Check if the key is a number\n  if (String(parseInt(key, 10)) === key) {\n    // The key is a number, convert to a wildcard\n    return \"$\";\n  }\n\n  return key;\n};\n/**\n * Removes leading period (.) from string and returns new string.\n * @param {String} str The string to clean.\n * @returns {*} The cleaned string.\n */\n\n\nvar clean = function clean(str) {\n  if (!str) {\n    return str;\n  }\n\n  if (str.substr(0, 1) === \".\") {\n    str = str.substr(1, str.length - 1);\n  }\n\n  return str;\n};\n/**\n * Splits a path by period character, taking into account\n * escaped period characters.\n * @param {String} path The path to split into an array.\n * @return {Array<String>} The component parts of the path, split\n * by period character.\n */\n\n\nvar split = function split(path) {\n  // Convert all \\. (escaped periods) to another character\n  // temporarily\n  var escapedPath = path.replace(/\\\\\\./g, \"[--]\");\n  var splitPath = escapedPath.split(\".\"); // Loop the split path array and convert any escaped period\n  // placeholders back to their real period characters\n\n  for (var i = 0; i < splitPath.length; i++) {\n    splitPath[i] = splitPath[i].replace(/\\[--]/g, \"\\\\.\");\n  }\n\n  return splitPath;\n};\n/**\n * Escapes any periods in the passed string so they will\n * not be identified as part of a path. Useful if you have\n * a path like \"domains.www.google.com.data\" where the\n * \"www.google.com\" should not be considered part of the\n * traversal as it is actually in an object like:\n * {\n * \t\"domains\": {\n * \t\t\"www.google.com\": {\n * \t\t\t\"data\": \"foo\"\n * \t\t}\n * \t}\n * }\n * @param {String} str The string to escape periods in.\n * @return {String} The escaped string.\n */\n\n\nvar escape = function escape(str) {\n  return str.replace(/\\./g, \"\\\\.\");\n};\n/**\n * Converts a string previously escaped with the `escape()`\n * function back to its original value.\n * @param {String} str The string to unescape.\n * @returns {string} The unescaped string.\n */\n\n\nvar unEscape = function unEscape(str) {\n  return str.replace(/\\\\./g, \".\");\n};\n/**\n * Gets a single value from the passed object and given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {*=} defaultVal Optional default to return if the\n * value retrieved from the given object and path equals undefined.\n * @param {Object=} options Optional options object.\n * @returns {*} The value retrieved from the passed object at\n * the passed path.\n */\n\n\nvar get = function get(obj, path) {\n  var defaultVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var internalPath = path,\n      objPart;\n\n  if (path instanceof Array) {\n    return path.map(function (individualPath) {\n      get(obj, individualPath, defaultVal, options);\n    });\n  }\n\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options); // No object data, return undefined\n\n  if (obj === undefined || obj === null) {\n    return defaultVal;\n  } // No path string, return the base obj\n\n\n  if (!internalPath) {\n    return obj;\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  } // Path has no dot-notation, return key/value\n\n\n  if (isNonCompositePath(internalPath)) {\n    return obj[internalPath] !== undefined ? obj[internalPath] : defaultVal;\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return defaultVal !== undefined ? defaultVal : undefined;\n  }\n\n  var pathParts = split(internalPath);\n  objPart = obj;\n\n  var _loop2 = function _loop2(i) {\n    var pathPart = pathParts[i];\n    objPart = objPart[options.transformKey(unEscape(pathPart))];\n\n    if (objPart instanceof Array && options.arrayTraversal === true) {\n      // The data is an array and we have arrayTraversal enabled\n      // so loop the array items and return the first non-undefined\n      // value from any array item leaf node that matches the path\n      var result = objPart.reduce(function (result, arrItem) {\n        return get(arrItem, pathParts.slice(i + 1).join(\".\"), defaultVal, options);\n      }, undefined);\n      return {\n        v: result !== undefined ? result : defaultVal\n      };\n    } else if (!objPart || (0, _typeof2[\"default\"])(objPart) !== \"object\") {\n      if (i !== pathParts.length - 1) {\n        // The path terminated in the object before we reached\n        // the end node we wanted so make sure we return undefined\n        objPart = undefined;\n      }\n\n      return \"break\";\n    }\n  };\n\n  _loop: for (var i = 0; i < pathParts.length; i++) {\n    var _ret = _loop2(i);\n\n    switch (_ret) {\n      case \"break\":\n        break _loop;\n\n      default:\n        if ((0, _typeof2[\"default\"])(_ret) === \"object\") return _ret.v;\n    }\n  }\n\n  return objPart !== undefined ? objPart : defaultVal;\n};\n/**\n * Sets a single value on the passed object and given path. This\n * will directly modify the \"obj\" object. If you need immutable\n * updates, use setImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to set data on.\n * @param {*} val The value to assign to the obj at the path.\n * @param {Object=} options The options object.\n * @returns {*} Nothing.\n */\n\n\nvar set = function set(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var internalPath = path,\n      objPart;\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options); // No object data\n\n  if (obj === undefined || obj === null) {\n    return;\n  } // No path string\n\n\n  if (!internalPath) {\n    return;\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return;\n  } // Path has no dot-notation, set key/value\n\n\n  if (isNonCompositePath(internalPath)) {\n    // Do not allow prototype pollution\n    if (internalPath === \"__proto__\") return obj;\n    obj = decouple(obj, options);\n    obj[options.transformKey(unEscape(internalPath))] = val;\n    return obj;\n  }\n\n  var newObj = decouple(obj, options);\n  var pathParts = split(internalPath);\n  var pathPart = pathParts.shift();\n  var transformedPathPart = options.transformKey(pathPart); // Do not allow prototype pollution\n\n  if (transformedPathPart === \"__proto__\") return obj;\n  var childPart = newObj[transformedPathPart];\n\n  if ((0, _typeof2[\"default\"])(childPart) !== \"object\") {\n    // Create an object or array on the path\n    if (String(parseInt(transformedPathPart, 10)) === transformedPathPart) {\n      // This is an array index\n      newObj[transformedPathPart] = [];\n    } else {\n      newObj[transformedPathPart] = {};\n    }\n\n    objPart = newObj[transformedPathPart];\n  } else {\n    objPart = childPart;\n  }\n\n  return set(newObj, transformedPathPart, set(objPart, pathParts.join('.'), val, options), options);\n};\n/**\n * Deletes a key from an object by the given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to delete.\n * @param {Object=} options The options object.\n * @param {Object=} tracking Do not use.\n */\n\n\nvar unSet = function unSet(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tracking = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var internalPath = path;\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options); // No object data\n\n  if (obj === undefined || obj === null) {\n    return;\n  } // No path string\n\n\n  if (!internalPath) {\n    return;\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return;\n  }\n\n  var newObj = decouple(obj, options); // Path has no dot-notation, set key/value\n\n  if (isNonCompositePath(internalPath)) {\n    var unescapedPath = unEscape(internalPath); // Do not allow prototype pollution\n\n    if (unescapedPath === \"__proto__\") return obj;\n\n    if (newObj.hasOwnProperty(unescapedPath)) {\n      delete newObj[options.transformKey(unescapedPath)];\n      return newObj;\n    }\n\n    tracking.returnOriginal = true;\n    return obj;\n  }\n\n  var pathParts = split(internalPath);\n  var pathPart = pathParts.shift();\n  var transformedPathPart = options.transformKey(unEscape(pathPart)); // Do not allow prototype pollution\n\n  if (transformedPathPart === \"__proto__\") return obj;\n  var childPart = newObj[transformedPathPart];\n\n  if (!childPart) {\n    // No child part available, nothing to unset!\n    tracking.returnOriginal = true;\n    return obj;\n  }\n\n  newObj[transformedPathPart] = unSet(childPart, pathParts.join('.'), options, tracking);\n\n  if (tracking.returnOriginal) {\n    return obj;\n  }\n\n  return newObj;\n};\n/**\n * Takes an update object or array and iterates the keys of it, then\n * sets data on the target object or array at the specified path with\n * the corresponding value from the path key, effectively doing\n * multiple set() operations in a single call. This will directly\n * modify the \"obj\" object. If you need immutable updates, use\n * updateImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The object with the modified data.\n */\n\n\nvar update = function update(obj, updateData) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var newObj = obj;\n\n  for (var path in updateData) {\n    if (updateData.hasOwnProperty(path)) {\n      var data = updateData[path];\n      newObj = set(newObj, path, data, options);\n    }\n  }\n\n  return newObj;\n};\n/**\n * If options.immutable === true then return a new de-referenced\n * instance of the passed object/array. If immutable is false\n * then simply return the same `obj` that was passed.\n * @param {*} obj The object or array to decouple.\n * @param {Object=} options The options object that has the immutable\n * key with a boolean value.\n * @returns {*} The new decoupled instance (if immutable is true)\n * or the original `obj` if immutable is false.\n */\n\n\nvar decouple = function decouple(obj) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!options.immutable) {\n    return obj;\n  }\n\n  return _newInstance(obj);\n};\n/**\n * Push a value to an array on an object for the specified path.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to push to.\n * @param {*} val The value to push to the array at the object path.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\n\n\nvar pushVal = function pushVal(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (obj === undefined || obj === null || path === undefined) {\n    return obj;\n  } // Clean the path\n\n\n  path = clean(path);\n  var pathParts = split(path);\n  var part = pathParts.shift();\n  if (part === \"__proto__\") return obj;\n\n  if (pathParts.length) {\n    // Generate the path part in the object if it does not already exist\n    obj[part] = decouple(obj[part], options) || {}; // Recurse\n\n    pushVal(obj[part], pathParts.join(\".\"), val, options);\n  } else if (part) {\n    // We have found the target array, push the value\n    obj[part] = decouple(obj[part], options) || [];\n\n    if (!(obj[part] instanceof Array)) {\n      throw \"Cannot push to a path whose leaf node is not an array!\";\n    }\n\n    obj[part].push(val);\n  } else {\n    // We have found the target array, push the value\n    obj = decouple(obj, options) || [];\n\n    if (!(obj instanceof Array)) {\n      throw \"Cannot push to a path whose leaf node is not an array!\";\n    }\n\n    obj.push(val);\n  }\n\n  return decouple(obj, options);\n};\n/**\n * Pull a value to from an array at the specified path. Removes the first\n * matching value, not every matching value.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to pull from.\n * @param {*} val The value to pull from the array.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\n\n\nvar pullVal = function pullVal(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    strict: true\n  };\n\n  if (obj === undefined || obj === null || path === undefined) {\n    return obj;\n  } // Clean the path\n\n\n  path = clean(path);\n  var pathParts = split(path);\n  var part = pathParts.shift();\n  if (part === \"__proto__\") return obj;\n\n  if (pathParts.length) {\n    // Generate the path part in the object if it does not already exist\n    obj[part] = decouple(obj[part], options) || {}; // Recurse - we don't need to assign obj[part] the result of this call because\n    // we are modifying by reference since we haven't reached the furthest path\n    // part (leaf) node yet\n\n    pullVal(obj[part], pathParts.join(\".\"), val, options);\n  } else if (part) {\n    obj[part] = decouple(obj[part], options) || []; // Recurse - this is the leaf node so assign the response to obj[part] in\n    // case it is set to an immutable response\n\n    obj[part] = pullVal(obj[part], \"\", val, options);\n  } else {\n    // The target array is the root object, pull the value\n    obj = decouple(obj, options) || [];\n\n    if (!(obj instanceof Array)) {\n      throw \"Cannot pull from a path whose leaf node is not an array!\";\n    }\n\n    var index = -1; // Find the index of the passed value\n\n    if (options.strict === true) {\n      index = obj.indexOf(val);\n    } else {\n      // Do a non-strict check\n      index = obj.findIndex(function (item) {\n        return match(item, val);\n      });\n    }\n\n    if (index > -1) {\n      // Remove the item from the array\n      obj.splice(index, 1);\n    }\n  }\n\n  return decouple(obj, options);\n};\n/**\n * Given a path and an object, determines the outermost leaf node\n * that can be reached where the leaf value is not undefined.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {String} The path to the furthest non-undefined value.\n */\n\n\nvar furthest = function furthest(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var internalPath = path,\n      objPart;\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": wildcardToZero,\n    // Any path that has a wildcard will essentially check the first array item to continue down the tree\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n  var finalPath = []; // No path string, return the base obj\n\n  if (!internalPath) {\n    return finalPath.join(\".\");\n  }\n\n  internalPath = clean(internalPath); // Path is not a string, throw error\n\n  if (typeof internalPath !== \"string\") {\n    throw new Error(\"Path argument must be a string\");\n  }\n\n  if ((0, _typeof2[\"default\"])(obj) !== \"object\") {\n    return finalPath.join(\".\");\n  } // Path has no dot-notation, return key/value\n\n\n  if (isNonCompositePath(internalPath)) {\n    if (obj[internalPath] !== undefined) {\n      return internalPath;\n    }\n\n    return finalPath.join(\".\");\n  }\n\n  var pathParts = split(internalPath);\n  objPart = obj;\n\n  for (var i = 0; i < pathParts.length; i++) {\n    var pathPart = pathParts[i];\n    objPart = objPart[options.transformKey(unEscape(pathPart))];\n\n    if (objPart === undefined) {\n      break;\n    }\n\n    finalPath.push(pathPart);\n  }\n\n  return finalPath.join(\".\");\n};\n/**\n * Traverses the object by the given path and returns an object where\n * each key is a path pointing to a leaf node and contains the value\n * from the leaf node from the overall object in the obj argument,\n * essentially providing all available paths in an object and all the\n * values for each path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {Object|Array} The result of the traversal.\n */\n\n\nvar values = function values(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var internalPath = clean(path);\n  var pathParts = split(internalPath);\n  var currentPath = [];\n  var valueData = {};\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n\n  for (var i = 0; i < pathParts.length; i++) {\n    var pathPart = options.transformKey(pathParts[i]);\n    currentPath.push(pathPart);\n    var tmpPath = currentPath.join(\".\");\n    valueData[tmpPath] = get(obj, tmpPath);\n  }\n\n  return valueData;\n};\n/**\n * Takes an object and finds all paths, then returns the paths as an\n * array of strings.\n * @param {Object|Array} obj The object to scan.\n * @param {Array=} finalArr An object used to collect the path keys.\n * (Do not pass this in directly - use undefined).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly - use undefined).\n * @param {Object=} options An options object.\n * @returns {Array<String>} An array containing path strings.\n */\n\n\nvar flatten = function flatten(obj) {\n  var finalArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var objCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n  var transformedObj = options.transformRead(obj); // Check that we haven't visited this object before (avoid infinite recursion)\n\n  if (objCache.indexOf(transformedObj) > -1) {\n    return finalArr;\n  } // Add object to cache to make sure we don't traverse it twice\n\n\n  objCache.push(transformedObj);\n\n  var currentPath = function currentPath(i) {\n    var tKey = options.transformKey(i);\n    return parentPath ? parentPath + \".\" + tKey : tKey;\n  };\n\n  for (var i in transformedObj) {\n    if (transformedObj.hasOwnProperty(i)) {\n      if (options.ignore && options.ignore.test(i)) {\n        continue;\n      }\n\n      if ((0, _typeof2[\"default\"])(transformedObj[i]) === \"object\" && transformedObj[i] !== null) {\n        flatten(transformedObj[i], finalArr, currentPath(i), options, objCache);\n      }\n\n      finalArr.push(currentPath(i));\n    }\n  }\n\n  return finalArr;\n};\n/**\n * Takes an object and finds all paths, then returns the paths as keys\n * and the values of each path as the values.\n * @param {Object|Array} obj The object to scan.\n * @param {Object=} finalObj An object used to collect the path keys.\n * (Do not pass this in directly).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly).\n * @param {Object=} options An options object.\n * @returns {Object|Array} An object containing path keys and their values.\n */\n\n\nvar flattenValues = function flattenValues(obj) {\n  var finalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var objCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  options = _objectSpread({\n    \"transformRead\": returnWhatWasGiven,\n    \"transformKey\": returnWhatWasGiven,\n    \"transformWrite\": returnWhatWasGiven\n  }, options);\n  var transformedObj = options.transformRead(obj); // Check that we haven't visited this object before (avoid infinite recursion)\n\n  if (objCache.indexOf(transformedObj) > -1) {\n    return finalObj;\n  } // Add object to cache to make sure we don't traverse it twice\n\n\n  objCache.push(transformedObj);\n\n  var currentPath = function currentPath(i, info) {\n    var tKey = options.transformKey(i, info);\n    return parentPath ? parentPath + \".\" + tKey : tKey;\n  };\n\n  for (var i in transformedObj) {\n    if (transformedObj.hasOwnProperty(i)) {\n      var _type = (0, _typeof2[\"default\"])(transformedObj[i]);\n\n      var info = {\n        type: _type,\n        isArrayIndex: Array.isArray(transformedObj),\n        isFlat: _type !== \"object\" || transformedObj[i] instanceof Date || transformedObj[i] instanceof RegExp\n      };\n      var pathKey = currentPath(i, info);\n\n      if (!info.isFlat) {\n        if (transformedObj[i] !== null) {\n          flattenValues(transformedObj[i], finalObj, pathKey, options, objCache);\n        }\n      } else if (options.leavesOnly) {\n        // Found leaf node!\n        finalObj[pathKey] = options.transformWrite(transformedObj[i]);\n      }\n\n      if (!options.leavesOnly) {\n        finalObj[pathKey] = options.transformWrite(transformedObj[i]);\n      }\n    }\n  }\n\n  return finalObj;\n};\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args args Path to join.\n * @returns {String} A final path string.\n */\n\n\nvar join = function join() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args.reduce(function (arr, item) {\n    if (item !== undefined && String(item)) {\n      arr.push(item);\n    }\n\n    return arr;\n  }, []).join(\".\");\n};\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args Path to join.\n * @returns {String} A final path string.\n */\n\n\nvar joinEscaped = function joinEscaped() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  var escapedArgs = args.map(function (item) {\n    return escape(item);\n  });\n  return join.apply(void 0, (0, _toConsumableArray2[\"default\"])(escapedArgs));\n};\n/**\n * Counts the total number of key leaf nodes in the passed object.\n * @param {Object|Array} obj The object to count key leaf nodes for.\n * @param {Array=} objCache Do not use. Internal array to track\n * visited leafs.\n * @returns {Number} The number of keys.\n */\n\n\nvar countLeafNodes = function countLeafNodes(obj) {\n  var objCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var totalKeys = 0; // Add object to cache to make sure we don't traverse it twice\n\n  objCache.push(obj);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (obj[i] !== undefined) {\n        if ((0, _typeof2[\"default\"])(obj[i]) !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n          totalKeys++;\n        } else {\n          totalKeys += countLeafNodes(obj[i], objCache);\n        }\n      }\n    }\n  }\n\n  return totalKeys;\n};\n/**\n * Finds all the leaf nodes for a given object and returns an array of paths\n * to them. This is different from `flatten()` in that it only includes leaf\n * nodes and will not include every intermediary path traversed to get to a\n * leaf node.\n * @param {Object|Array} obj The object to traverse.\n * @param {String} [parentPath=\"\"] The path to use as a root/base path to\n * start scanning for leaf nodes under.\n * @param {Object} [objCache=[]] Internal usage to check for cyclic structures.\n * @returns {[]}\n */\n\n\nvar leafNodes = function leafNodes(obj) {\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var objCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var paths = []; // Add object to cache to make sure we don't traverse it twice\n\n  objCache.push(obj);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (obj[i] !== undefined) {\n        var currentPath = join(parentPath, i);\n\n        if ((0, _typeof2[\"default\"])(obj[i]) !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n          paths.push(currentPath);\n        } else {\n          paths.push.apply(paths, (0, _toConsumableArray2[\"default\"])(leafNodes(obj[i], currentPath, objCache)));\n        }\n      }\n    }\n  }\n\n  return paths;\n};\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths. MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Boolean} True if the object paths exist.\n */\n\n\nvar hasMatchingPathsInObject = function hasMatchingPathsInObject(testKeys, testObj) {\n  var result = true;\n\n  for (var i in testKeys) {\n    if (testKeys.hasOwnProperty(i)) {\n      if (testObj[i] === undefined) {\n        return false;\n      }\n\n      if ((0, _typeof2[\"default\"])(testKeys[i]) === \"object\" && testKeys[i] !== null) {\n        // Recurse object\n        result = hasMatchingPathsInObject(testKeys[i], testObj[i]); // Should we exit early?\n\n        if (!result) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths and if so returns the number matched.\n * MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Object<matchedKeys<Number>, matchedKeyCount<Number>, totalKeyCount<Number>>} Stats on the matched keys.\n */\n\n\nvar countMatchingPathsInObject = function countMatchingPathsInObject(testKeys, testObj) {\n  var matchedKeys = {};\n  var matchData,\n      matchedKeyCount = 0,\n      totalKeyCount = 0;\n\n  for (var i in testObj) {\n    if (testObj.hasOwnProperty(i)) {\n      if ((0, _typeof2[\"default\"])(testObj[i]) === \"object\" && testObj[i] !== null) {\n        // The test / query object key is an object, recurse\n        matchData = countMatchingPathsInObject(testKeys[i], testObj[i]);\n        matchedKeys[i] = matchData.matchedKeys;\n        totalKeyCount += matchData.totalKeyCount;\n        matchedKeyCount += matchData.matchedKeyCount;\n      } else {\n        // The test / query object has a property that is not an object so add it as a key\n        totalKeyCount++; // Check if the test keys also have this key and it is also not an object\n\n        if (testKeys && testKeys[i] && ((0, _typeof2[\"default\"])(testKeys[i]) !== \"object\" || testKeys[i] === null)) {\n          matchedKeys[i] = true;\n          matchedKeyCount++;\n        } else {\n          matchedKeys[i] = false;\n        }\n      }\n    }\n  }\n\n  return {\n    matchedKeys: matchedKeys,\n    matchedKeyCount: matchedKeyCount,\n    totalKeyCount: totalKeyCount\n  };\n};\n/**\n * Returns the type from the item passed. Similar to JavaScript's\n * built-in typeof except it will distinguish between arrays, nulls\n * and objects as well.\n * @param {*} item The item to get the type of.\n * @returns {string|\"undefined\"|\"object\"|\"boolean\"|\"number\"|\"string\"|\"function\"|\"symbol\"|\"null\"|\"array\"}\n */\n\n\nvar type = function type(item) {\n  if (item === null) {\n    return 'null';\n  }\n\n  if (Array.isArray(item)) {\n    return 'array';\n  }\n\n  return (0, _typeof2[\"default\"])(item);\n};\n/**\n * Determines if the query data exists anywhere inside the source\n * data. Will recurse into arrays and objects to find query.\n * @param {*} source The source data to check.\n * @param {*} query The query data to find.\n * @returns {Boolean} True if query was matched, false if not.\n */\n\n\nvar match = function match(source, query) {\n  var sourceType = (0, _typeof2[\"default\"])(source);\n  var queryType = (0, _typeof2[\"default\"])(query);\n\n  if (sourceType !== queryType) {\n    return false;\n  }\n\n  if (sourceType !== \"object\" || source === null) {\n    // Simple test\n    return source === query;\n  } // The source is an object-like (array or object) structure\n\n\n  var entries = Object.entries(query);\n  var foundNonMatch = entries.find(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n        key = _ref4[0],\n        val = _ref4[1];\n\n    // Recurse if type is array or object\n    if ((0, _typeof2[\"default\"])(val) === \"object\" && val !== null) {\n      return !match(source[key], val);\n    }\n\n    return source[key] !== val;\n  });\n  return !foundNonMatch;\n};\n/**\n * @typedef {object} FindOptionsObject\n * @property {number} [maxDepth=Infinity] The maximum depth to scan inside\n * the source object for matching data.\n * @property {number} [currentDepth=0] The current depth of the\n * operation scan.\n * @property {boolean} [includeRoot=true] If true, will include the\n * root source object if it matches the query.\n */\n\n/**\n * Finds all items that matches the structure of `query` and\n * returns the path to them as an array of strings.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<Array>.\n */\n\n\nvar findPath = function findPath(source, query) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  };\n  var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  var resultArr = [];\n  var sourceType = (0, _typeof2[\"default\"])(source);\n  options = _objectSpread({\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  }, options);\n\n  if (options.currentDepth !== 0 || options.currentDepth === 0 && options.includeRoot) {\n    if (match(source, query)) {\n      resultArr.push(parentPath);\n    }\n  }\n\n  options.currentDepth++;\n\n  if (options.currentDepth <= options.maxDepth && sourceType === \"object\") {\n    var entries = Object.entries(source);\n    entries.forEach(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          key = _ref6[0],\n          val = _ref6[1];\n\n      // Recurse down object to find more instances\n      var result = findPath(val, query, options, join(parentPath, key));\n\n      if (result.match) {\n        resultArr.push.apply(resultArr, (0, _toConsumableArray2[\"default\"])(result.path));\n      }\n    });\n  }\n\n  return {\n    match: resultArr.length > 0,\n    path: resultArr\n  };\n};\n/**\n * Finds the first item that matches the structure of `query`\n * and returns the path to it.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<String>.\n */\n\n\nvar findOnePath = function findOnePath(source, query) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  };\n  var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  var sourceType = (0, _typeof2[\"default\"])(source);\n  options = _objectSpread({\n    maxDepth: Infinity,\n    currentDepth: 0,\n    includeRoot: true\n  }, options);\n\n  if (options.currentDepth !== 0 || options.currentDepth === 0 && options.includeRoot) {\n    if (match(source, query)) {\n      return {\n        match: true,\n        path: parentPath\n      };\n    }\n  }\n\n  options.currentDepth++;\n\n  if (options.currentDepth <= options.maxDepth && sourceType === \"object\" && source !== null) {\n    var entries = Object.entries(source);\n\n    for (var i = 0; i < entries.length; i++) {\n      var _entries$i = (0, _slicedToArray2[\"default\"])(entries[i], 2),\n          key = _entries$i[0],\n          val = _entries$i[1]; // Recurse down object to find more instances\n\n\n      var subPath = join(parentPath, key);\n      var result = findOnePath(val, query, options, subPath);\n\n      if (result.match) {\n        return result;\n      }\n    }\n  }\n\n  return {\n    match: false\n  };\n};\n/**\n * Returns a deduplicated array of strings.\n * @param {Array<String>} keys An array of strings to deduplicate.\n * @returns {Array<String>} The deduplicated array.\n */\n\n\nvar keyDedup = function keyDedup(keys) {\n  return keys.filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  });\n};\n/**\n * Compares two provided objects / arrays and returns an array of\n * dot-notation paths to the fields that hold different values.\n * @param {Object|Array} obj1 The first object / array to compare.\n * @param {Object|Array} obj2 The second object / array to compare.\n * @param {String=\"\"} basePath The base path from which to check for\n * differences. Differences outside the base path will not be\n * returned as part of the array of differences. Leave blank to check\n * for all differences between the two objects to compare.\n * @param {Boolean=false} strict If strict is true, diff uses strict\n * equality to determine difference rather than non-strict equality;\n * effectively (=== is strict, == is non-strict).\n * @param {Number=Infinity} maxDepth Specifies the maximum number of\n * path sub-trees to walk down before returning what we have found.\n * For instance, if set to 2, a diff would only check down,\n * \"someFieldName.anotherField\", or \"user.name\" and would not go\n * further down than two fields. If anything in the trees further\n * down than this level have changed, the change will not be detected\n * and the path will not be included in the resulting diff array.\n * @param {String=\"\"} parentPath Used internally only.\n * @returns {Array} An array of strings, each string is a path to a\n * field that holds a different value between the two objects being\n * compared.\n */\n\n\nvar diff = function diff(obj1, obj2) {\n  var basePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var maxDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n  var parentPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n  var objCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  var paths = [];\n\n  if (basePath instanceof Array) {\n    // We were given an array of paths, check each path\n    return basePath.reduce(function (arr, individualPath) {\n      // Here we find any path that has a *non-equal* result which\n      // returns true and then returns the index as a positive integer\n      // that is not -1. If -1 is returned then no non-equal matches\n      // were found\n      var result = diff(obj1, obj2, individualPath, strict, maxDepth, parentPath, objCache);\n\n      if (result && result.length) {\n        arr.push.apply(arr, (0, _toConsumableArray2[\"default\"])(result));\n      }\n\n      return arr;\n    }, []);\n  }\n\n  var currentPath = join(parentPath, basePath);\n  var val1 = get(obj1, basePath);\n  var val2 = get(obj2, basePath);\n  var type1 = type(val1);\n  var type2 = type(val2);\n\n  if (type1 !== type2) {\n    // Difference in source and comparison types\n    paths.push(currentPath);\n  } else if (type1 === \"array\" && val1.length !== val2.length) {\n    // Difference in source and comparison types\n    paths.push(currentPath);\n  }\n\n  var pathParts = currentPath.split(\".\");\n  var hasParts = pathParts[0] !== \"\";\n\n  if ((!hasParts || pathParts.length < maxDepth) && (0, _typeof2[\"default\"])(val1) === \"object\" && val1 !== null) {\n    // Check that we haven't visited this object before (avoid infinite recursion)\n    if (objCache.indexOf(val1) > -1 || objCache.indexOf(val2) > -1) {\n      return paths;\n    }\n\n    objCache.push(val1);\n    objCache.push(val2); // Grab composite of all keys on val1 and val2\n\n    var val1Keys = Object.keys(val1);\n    var val2Keys = (0, _typeof2[\"default\"])(val2) === \"object\" && val2 !== null ? Object.keys(val2) : [];\n    var compositeKeys = keyDedup(val1Keys.concat(val2Keys));\n    return compositeKeys.reduce(function (arr, key) {\n      var result = diff(val1, val2, key, strict, maxDepth, currentPath, objCache);\n\n      if (result && result.length) {\n        arr.push.apply(arr, (0, _toConsumableArray2[\"default\"])(result));\n      }\n\n      return arr;\n    }, paths);\n  }\n\n  if (strict && val1 !== val2 || !strict && val1 != val2) {\n    paths.push(currentPath);\n  }\n\n  return keyDedup(paths);\n};\n/**\n * A boolean check to see if the values at the given path or paths\n * are the same in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to check\n * values in. If this is an array, all values at the paths in the array\n * must be the same for the function to provide a true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for equality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values match, false if not.\n */\n\n\nvar isEqual = function isEqual(obj1, obj2, path) {\n  var deep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var strict = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (path instanceof Array) {\n    // We were given an array of paths, check each path\n    return path.findIndex(function (individualPath) {\n      // Here we find any path that has a *non-equal* result which\n      // returns true and then returns the index as a positive integer\n      // that is not -1. If -1 is returned then no non-equal matches\n      // were found\n      return isNotEqual(obj1, obj2, individualPath, deep, strict);\n    }) === -1;\n  }\n\n  var val1 = get(obj1, path);\n  var val2 = get(obj2, path);\n\n  if (deep) {\n    if ((0, _typeof2[\"default\"])(val1) === \"object\" && val1 !== null) {\n      // TODO: This probably needs a composite key array of val1 and val2 keys\n      //  just as we do in the diff() function\n      return Object.keys(val1).findIndex(function (key) {\n        return isNotEqual(val1, val2, key, deep, strict);\n      }) === -1;\n    }\n  }\n\n  return strict && val1 === val2 || !strict && val1 == val2;\n};\n/**\n * A boolean check to see if the values at the given path or paths\n * are different in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to\n * check values in. If this is an array, all values at the paths\n * in the array must be different for the function to provide a\n * true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for inequality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-not-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values differ, false if not.\n */\n\n\nvar isNotEqual = function isNotEqual(obj1, obj2, path) {\n  var deep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var strict = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return !isEqual(obj1, obj2, path, deep, strict);\n};\n/**\n * Same as set() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar setImmutable = function setImmutable(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return set(obj, path, val, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as pushVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar pushValImmutable = function pushValImmutable(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return pushVal(obj, path, val, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as pullVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar pullValImmutable = function pullValImmutable(obj, path, val) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return pullVal(obj, path, val, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as unSet() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar unSetImmutable = function unSetImmutable(obj, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return unSet(obj, path, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Same as update() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\n\n\nvar updateImmutable = function updateImmutable(obj, updateData, options) {\n  return update(obj, updateData, _objectSpread(_objectSpread({}, options), {}, {\n    immutable: true\n  }));\n};\n/**\n * Gets the values of the paths in pathArr and returns them as an object\n * with each key matching the path and the value matching the value from\n * obj that was at that path.\n * @param {Object} obj The object to operate on.\n * @param {Array<String>} pathArr Array of path strings.\n * @returns {*} The new object.\n */\n\n\nvar distill = function distill(obj, pathArr) {\n  return pathArr.reduce(function (newObj, path) {\n    newObj[path] = get(obj, path);\n    return newObj;\n  }, {});\n};\n/**\n * Chops a `path` string down to the given `level`. Given a `path` string\n * like \"foo.bar.ram.you.too\", chop will remove any path parts below\n * the given `level`. If we pass 2 as the `level` with that given `path`,\n * the result will be \"foo.bar\" as foo is level 1 and bar is level 2.\n * If the `path` is shorter than the given `level`, it is returned intact.\n * @param {String} path The path to operate on.\n * @param {Number} level The maximum level of a path.\n * @returns {String} The new path string.\n */\n\n\nvar chop = function chop(path, level) {\n  var parts = split(path);\n\n  if (parts.length > level) {\n    parts.length = level;\n  }\n\n  return join.apply(void 0, (0, _toConsumableArray2[\"default\"])(parts));\n};\n\nmodule.exports = {\n  wildcardToZero: wildcardToZero,\n  numberToWildcard: numberToWildcard,\n  clean: clean,\n  decouple: decouple,\n  split: split,\n  escape: escape,\n  get: get,\n  set: set,\n  setImmutable: setImmutable,\n  unSet: unSet,\n  unSetImmutable: unSetImmutable,\n  pushValImmutable: pushValImmutable,\n  pushVal: pushVal,\n  pullValImmutable: pullValImmutable,\n  pullVal: pullVal,\n  furthest: furthest,\n  values: values,\n  flatten: flatten,\n  flattenValues: flattenValues,\n  join: join,\n  joinEscaped: joinEscaped,\n  up: up,\n  down: down,\n  push: push,\n  pop: pop,\n  shift: shift,\n  countLeafNodes: countLeafNodes,\n  hasMatchingPathsInObject: hasMatchingPathsInObject,\n  countMatchingPathsInObject: countMatchingPathsInObject,\n  findOnePath: findOnePath,\n  findPath: findPath,\n  type: type,\n  match: match,\n  isEqual: isEqual,\n  isNotEqual: isNotEqual,\n  leafNodes: leafNodes,\n  diff: diff,\n  update: update,\n  updateImmutable: updateImmutable,\n  distill: distill,\n  chop: chop\n};", "{\n\t\"name\": \"@irrelon/path\",\n\t\"version\": \"4.7.0\",\n\t\"description\": \"A powerful JSON path processor. Allows you to drill into and manipulate JSON objects with a simple dot-delimited path format e.g. \\\"obj.name\\\".\",\n\t\"main\": \"./src/Path.js\",\n\t\"scripts\": {\n\t\t\"test\": \"NODE_ENV=test mocha ./tests/**/**.test.js\",\n\t\t\"testMon\": \"nodemon --watch src --watch tests --exec \\\"NODE_ENV=test BABEL_DISABLE_CACHE=1 mocha ./tests/**/**.test.js\\\"\",\n\t\t\"build\": \"npm test && rimraf dist && babel ./src/*.js --out-dir dist\",\n\t\t\"eslint\": \"eslint ./src/**.js ./tests/**.js ./dist/Path.js\",\n\t\t\"eslint-fix\": \"eslint --fix ./src/**.js ./tests/**.js\"\n\t},\n\t\"keywords\": [\n\t\t\"path\",\n\t\t\"dot notation\",\n\t\t\"json\",\n\t\t\"node\",\n\t\t\"browser\"\n\t],\n\t\"author\": \"Rob Evans - Irrelon Software Limited\",\n\t\"license\": \"MIT\",\n\t\"devDependencies\": {\n\t\t\"@babel/cli\": \"^7.8.7\",\n\t\t\"@babel/core\": \"^7.8.7\",\n\t\t\"@babel/plugin-proposal-class-properties\": \"^7.8.7\",\n\t\t\"@babel/plugin-proposal-object-rest-spread\": \"^7.8.7\",\n\t\t\"@babel/plugin-transform-runtime\": \"^7.8.7\",\n\t\t\"@babel/preset-env\": \"^7.8.7\",\n\t\t\"@babel/preset-react\": \"^7.8.7\",\n\t\t\"@babel/register\": \"^7.8.7\",\n\t\t\"eslint-config-irrelon\": \"^1.0.2\",\n\t\t\"mocha\": \"^6.2.2\",\n\t\t\"mocha-expect\": \"^1.0.3\",\n\t\t\"rimraf\": \"^2.7.1\",\n\t\t\"nodemon\": \"^2.0.3\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/irrelon/irrelon-path.git\"\n\t},\n\t\"private\": false\n}\n", "/**\n * Scans an object for all keys that are either objects or arrays\n * and returns an array of those keys only.\n * @param {Object|Array} obj The object to scan.\n * @returns {[string]} An array of string keys.\n * @private\n */\nconst _iterableKeys = (obj) => {\n\treturn Object.entries(obj).reduce((arr, [key, val]) => {\n\t\tconst valType = type(val);\n\t\tif (valType === \"object\" || valType === \"array\") {\n\t\t\tarr.push(key);\n\t\t}\n\t\t\n\t\treturn arr;\n\t}, []);\n};\n\n/**\n * Creates a new instance of \"item\" that is dereferenced. Useful\n * when you want to return a new version of \"item\" with the same\n * data for immutable data structures.\n * @param {Object|Array} item The item to mimic.\n * @param {String} key The key to set data in.\n * @param {*} val The data to set in the key.\n * @returns {*} A new dereferenced version of \"item\" with the \"key\"\n * containing the \"val\" data.\n * @private\n */\nconst _newInstance = (item, key = undefined, val = undefined) => {\n\tconst objType = type(item);\n\t\n\tlet newObj;\n\t\n\tif (objType === \"object\") {\n\t\tnewObj = {\n\t\t\t...item\n\t\t};\n\t}\n\t\n\tif (objType === \"array\") {\n\t\tnewObj = [\n\t\t\t...item\n\t\t];\n\t}\n\t\n\tif (key !== undefined) {\n\t\tnewObj[key] = val;\n\t}\n\t\n\treturn newObj;\n};\n\n/**\n * Determines if the given path points to a root leaf node (has no delimiter)\n * or contains a dot delimiter so will drill down before reaching a leaf node.\n * If it has a delimiter, it is called a \"composite\" path.\n * @param {String} path The path to evaluate.\n * @returns {boolean} True if delimiter found, false if not.\n */\nconst isCompositePath = (path) => {\n\tconst regExp = /\\./g;\n\tlet result;\n\t\n\twhile (result = regExp.exec(path)) {\n\t\t// Check if the previous character was an escape\n\t\t// and if so, ignore this delimiter\n\t\tif (result.index === 0 || path.substr(result.index - 1, 1) !== \"\\\\\") {\n\t\t\t// This is not an escaped path so it IS a composite path\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Provides the opposite of `isCompositePath()`. If a delimiter is found, this\n * function returns false.\n * @param {String} path The path to evaluate.\n * @returns {boolean} False if delimiter found, true if not.\n */\nconst isNonCompositePath = (path) => {\n\treturn !isCompositePath(path);\n};\n\n/**\n * Returns the given path after removing the last\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"foo.bar\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move up.\n * @returns {String} The new path string.\n */\nconst up = (path, levels = 1) => {\n\tconst parts = split(path);\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tparts.pop();\n\t}\n\t\n\treturn parts.join(\".\");\n};\n\n/**\n * Returns the given path after removing the first\n * leaf from the path. E.g. \"foo.bar.thing\" becomes\n * \"bar.thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * move down.\n * @returns {String} The new path string.\n */\nconst down = (path, levels = 1) => {\n\tconst parts = split(path);\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tparts.shift();\n\t}\n\t\n\treturn parts.join(\".\");\n};\n\n/**\n * Returns the last leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"thing\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * pop.\n * @returns {String} The new path string.\n */\nconst pop = (path, levels = 1) => {\n\tconst parts = split(path);\n\tlet part;\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tpart = parts.pop();\n\t}\n\t\n\treturn part || \"\";\n};\n\n/**\n * Adds a leaf to the end of the path. E.g.\n * pushing \"goo\" to path \"foo.bar.thing\" returns\n * \"foo.bar.thing.goo\".\n * @param {String} path The path to operate on.\n * @param {String} val The string value to push\n * to the end of the path.\n * @returns {String} The new path string.\n */\nconst push = (path, val = \"\") => {\n\treturn `${path}.${val}`;\n};\n\n/**\n * Returns the first leaf from the path. E.g.\n * \"foo.bar.thing\" returns \"foo\".\n * @param {String} path The path to operate on.\n * @param {Number=} levels The number of levels to\n * shift.\n * @returns {String} The new path string.\n */\nconst shift = (path, levels = 1) => {\n\tconst parts = split(path);\n\tlet part;\n\t\n\tfor (let i = 0; i < levels; i++) {\n\t\tpart = parts.shift();\n\t}\n\t\n\treturn part || \"\";\n};\n\n/**\n * A function that just returns the first argument.\n * @param {*} val The argument to return.\n * @returns {*} The passed argument.\n */\nconst returnWhatWasGiven = (val) => val;\n\n/**\n * Converts any key matching the wildcard to a zero.\n * @param {String} key The key to test.\n * @returns {String} The key.\n */\nconst wildcardToZero = (key) => {\n\treturn key === \"$\" ? \"0\" : key;\n};\n\n/**\n * If a key is a number, will return a wildcard, otherwise\n * will return the originally passed key.\n * @param {String} key The key to test.\n * @returns {String} The original key or a wildcard.\n */\nconst numberToWildcard = (key) => {\n\t// Check if the key is a number\n\tif (String(parseInt(key, 10)) === key) {\n\t\t// The key is a number, convert to a wildcard\n\t\treturn \"$\";\n\t}\n\t\n\treturn key;\n};\n\n/**\n * Removes leading period (.) from string and returns new string.\n * @param {String} str The string to clean.\n * @returns {*} The cleaned string.\n */\nconst clean = (str) => {\n\tif (!str) {\n\t\treturn str;\n\t}\n\t\n\tif (str.substr(0, 1) === \".\") {\n\t\tstr = str.substr(1, str.length - 1);\n\t}\n\t\n\treturn str;\n};\n\n/**\n * Splits a path by period character, taking into account\n * escaped period characters.\n * @param {String} path The path to split into an array.\n * @return {Array<String>} The component parts of the path, split\n * by period character.\n */\nconst split = (path) => {\n\t// Convert all \\. (escaped periods) to another character\n\t// temporarily\n\tconst escapedPath = path.replace(/\\\\\\./g, \"[--]\");\n\tconst splitPath = escapedPath.split(\".\");\n\t\n\t// Loop the split path array and convert any escaped period\n\t// placeholders back to their real period characters\n\tfor (let i = 0; i < splitPath.length; i++) {\n\t\tsplitPath[i] = splitPath[i].replace(/\\[--]/g, \"\\\\.\");\n\t}\n\t\n\treturn splitPath;\n};\n\n/**\n * Escapes any periods in the passed string so they will\n * not be identified as part of a path. Useful if you have\n * a path like \"domains.www.google.com.data\" where the\n * \"www.google.com\" should not be considered part of the\n * traversal as it is actually in an object like:\n * {\n * \t\"domains\": {\n * \t\t\"www.google.com\": {\n * \t\t\t\"data\": \"foo\"\n * \t\t}\n * \t}\n * }\n * @param {String} str The string to escape periods in.\n * @return {String} The escaped string.\n */\nconst escape = (str) => {\n\treturn str.replace(/\\./g, \"\\\\.\");\n};\n\n/**\n * Converts a string previously escaped with the `escape()`\n * function back to its original value.\n * @param {String} str The string to unescape.\n * @returns {string} The unescaped string.\n */\nconst unEscape = (str) => {\n\treturn str.replace(/\\\\./g, \".\");\n};\n\n/**\n * Gets a single value from the passed object and given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {*=} defaultVal Optional default to return if the\n * value retrieved from the given object and path equals undefined.\n * @param {Object=} options Optional options object.\n * @returns {*} The value retrieved from the passed object at\n * the passed path.\n */\nconst get = (obj, path, defaultVal = undefined, options = {}) => {\n\tlet internalPath = path,\n\t\tobjPart;\n\t\n\tif (path instanceof Array) {\n\t\treturn path.map((individualPath) => {\n\t\t\tget(obj, individualPath, defaultVal, options);\n\t\t});\n\t}\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\t// No object data, return undefined\n\tif (obj === undefined || obj === null) {\n\t\treturn defaultVal;\n\t}\n\t\n\t// No path string, return the base obj\n\tif (!internalPath) {\n\t\treturn obj;\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\t// Path has no dot-notation, return key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\treturn obj[internalPath] !== undefined ? obj[internalPath] : defaultVal;\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn defaultVal !== undefined ? defaultVal : undefined;\n\t}\n\t\n\tconst pathParts = split(internalPath);\n\tobjPart = obj;\n\t\n\tfor (let i = 0; i < pathParts.length; i++) {\n\t\tconst pathPart = pathParts[i];\n\t\tobjPart = objPart[options.transformKey(unEscape(pathPart))];\n\t\t\n\t\tif (objPart instanceof Array && options.arrayTraversal === true) {\n\t\t\t// The data is an array and we have arrayTraversal enabled\n\t\t\t// so loop the array items and return the first non-undefined\n\t\t\t// value from any array item leaf node that matches the path\n\t\t\tconst result = objPart.reduce((result, arrItem) => {\n\t\t\t\treturn get(arrItem, pathParts.slice(i + 1).join(\".\"), defaultVal, options);\n\t\t\t}, undefined);\n\t\t\t\n\t\t\treturn result !== undefined ? result : defaultVal;\n\t\t} else if (!objPart || typeof objPart !== \"object\") {\n\t\t\tif (i !== pathParts.length - 1) {\n\t\t\t\t// The path terminated in the object before we reached\n\t\t\t\t// the end node we wanted so make sure we return undefined\n\t\t\t\tobjPart = undefined;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn objPart !== undefined ? objPart : defaultVal;\n};\n\n/**\n * Sets a single value on the passed object and given path. This\n * will directly modify the \"obj\" object. If you need immutable\n * updates, use setImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to set data on.\n * @param {*} val The value to assign to the obj at the path.\n * @param {Object=} options The options object.\n * @returns {*} Nothing.\n */\nconst set = (obj, path, val, options = {}) => {\n\tlet internalPath = path,\n\t\tobjPart;\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\t// No object data\n\tif (obj === undefined || obj === null) {\n\t\treturn;\n\t}\n\t\n\t// No path string\n\tif (!internalPath) {\n\t\treturn;\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn;\n\t}\n\t\n\t// Path has no dot-notation, set key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\t// Do not allow prototype pollution\n\t\tif (internalPath === \"__proto__\") return obj;\n\n\t\tobj = decouple(obj, options);\n\t\tobj[options.transformKey(unEscape(internalPath))] = val;\n\t\treturn obj;\n\t}\n\t\n\tconst newObj = decouple(obj, options);\n\tconst pathParts = split(internalPath);\n\tconst pathPart = pathParts.shift();\n\tconst transformedPathPart = options.transformKey(pathPart);\n\n\t// Do not allow prototype pollution\n\tif (transformedPathPart === \"__proto__\") return obj;\n\n\tlet childPart = newObj[transformedPathPart];\n\t\n\tif (typeof childPart !== \"object\") {\n\t\t// Create an object or array on the path\n\t\tif (String(parseInt(transformedPathPart, 10)) === transformedPathPart) {\n\t\t\t// This is an array index\n\t\t\tnewObj[transformedPathPart] = [];\n\t\t} else {\n\t\t\tnewObj[transformedPathPart] = {};\n\t\t}\n\t\t\n\t\tobjPart = newObj[transformedPathPart];\n\t} else {\n\t\tobjPart = childPart;\n\t}\n\t\n\treturn set(newObj, transformedPathPart, set(objPart, pathParts.join('.'), val, options), options);\n};\n\n/**\n * Deletes a key from an object by the given path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to delete.\n * @param {Object=} options The options object.\n * @param {Object=} tracking Do not use.\n */\nconst unSet = (obj, path, options = {}, tracking = {}) => {\n\tlet internalPath = path;\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\t// No object data\n\tif (obj === undefined || obj === null) {\n\t\treturn;\n\t}\n\t\n\t// No path string\n\tif (!internalPath) {\n\t\treturn;\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn;\n\t}\n\t\n\tconst newObj = decouple(obj, options);\n\t\n\t// Path has no dot-notation, set key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\tconst unescapedPath = unEscape(internalPath);\n\n\t\t// Do not allow prototype pollution\n\t\tif (unescapedPath === \"__proto__\") return obj;\n\n\t\tif (newObj.hasOwnProperty(unescapedPath)) {\n\t\t\tdelete newObj[options.transformKey(unescapedPath)];\n\t\t\treturn newObj;\n\t\t}\n\t\t\n\t\ttracking.returnOriginal = true;\n\t\treturn obj;\n\t}\n\t\n\tconst pathParts = split(internalPath);\n\tconst pathPart = pathParts.shift();\n\tconst transformedPathPart = options.transformKey(unEscape(pathPart));\n\n\t// Do not allow prototype pollution\n\tif (transformedPathPart === \"__proto__\") return obj;\n\n\tlet childPart = newObj[transformedPathPart];\n\t\n\tif (!childPart) {\n\t\t// No child part available, nothing to unset!\n\t\ttracking.returnOriginal = true;\n\t\treturn obj;\n\t}\n\t\n\tnewObj[transformedPathPart] = unSet(childPart, pathParts.join('.'), options, tracking);\n\t\n\tif (tracking.returnOriginal) {\n\t\treturn obj;\n\t}\n\t\n\treturn newObj;\n};\n\n/**\n * Takes an update object or array and iterates the keys of it, then\n * sets data on the target object or array at the specified path with\n * the corresponding value from the path key, effectively doing\n * multiple set() operations in a single call. This will directly\n * modify the \"obj\" object. If you need immutable updates, use\n * updateImmutable() instead.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The object with the modified data.\n */\nconst update = (obj, updateData, options = {}) => {\n\tlet newObj = obj;\n\t\n\tfor (let path in updateData) {\n\t\tif (updateData.hasOwnProperty(path)) {\n\t\t\tconst data = updateData[path];\n\t\t\tnewObj = set(newObj, path, data, options);\n\t\t}\n\t}\n\t\n\treturn newObj;\n};\n\n/**\n * If options.immutable === true then return a new de-referenced\n * instance of the passed object/array. If immutable is false\n * then simply return the same `obj` that was passed.\n * @param {*} obj The object or array to decouple.\n * @param {Object=} options The options object that has the immutable\n * key with a boolean value.\n * @returns {*} The new decoupled instance (if immutable is true)\n * or the original `obj` if immutable is false.\n */\nconst decouple = (obj, options = {}) => {\n\tif (!options.immutable) {\n\t\treturn obj;\n\t}\n\t\n\treturn _newInstance(obj);\n};\n\n/**\n * Push a value to an array on an object for the specified path.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to push to.\n * @param {*} val The value to push to the array at the object path.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\nconst pushVal = (obj, path, val, options = {}) => {\n\tif (obj === undefined || obj === null || path === undefined) {\n\t\treturn obj;\n\t}\n\t\n\t// Clean the path\n\tpath = clean(path);\n\t\n\tconst pathParts = split(path);\n\tconst part = pathParts.shift();\n\n\tif (part === \"__proto__\") return obj;\n\n\tif (pathParts.length) {\n\t\t// Generate the path part in the object if it does not already exist\n\t\tobj[part] = decouple(obj[part], options) || {};\n\t\t\n\t\t// Recurse\n\t\tpushVal(obj[part], pathParts.join(\".\"), val, options);\n\t} else if (part) {\n\t\t// We have found the target array, push the value\n\t\tobj[part] = decouple(obj[part], options) || [];\n\t\t\n\t\tif (!(obj[part] instanceof Array)) {\n\t\t\tthrow(\"Cannot push to a path whose leaf node is not an array!\");\n\t\t}\n\t\t\n\t\tobj[part].push(val);\n\t} else {\n\t\t// We have found the target array, push the value\n\t\tobj = decouple(obj, options) || [];\n\t\t\n\t\tif (!(obj instanceof Array)) {\n\t\t\tthrow(\"Cannot push to a path whose leaf node is not an array!\");\n\t\t}\n\t\t\n\t\tobj.push(val);\n\t}\n\t\n\treturn decouple(obj, options);\n};\n\n/**\n * Pull a value to from an array at the specified path. Removes the first\n * matching value, not every matching value.\n * @param {Object|Array} obj The object to update.\n * @param {String} path The path to the array to pull from.\n * @param {*} val The value to pull from the array.\n * @param {Object=} options An options object.\n * @returns {Object|Array} The original object passed in \"obj\" but with\n * the array at the path specified having the newly pushed value.\n */\nconst pullVal = (obj, path, val, options = {strict: true}) => {\n\tif (obj === undefined || obj === null || path === undefined) {\n\t\treturn obj;\n\t}\n\t\n\t// Clean the path\n\tpath = clean(path);\n\t\n\tconst pathParts = split(path);\n\tconst part = pathParts.shift();\n\n\tif (part === \"__proto__\") return obj;\n\t\n\tif (pathParts.length) {\n\t\t// Generate the path part in the object if it does not already exist\n\t\tobj[part] = decouple(obj[part], options) || {};\n\t\t\n\t\t// Recurse - we don't need to assign obj[part] the result of this call because\n\t\t// we are modifying by reference since we haven't reached the furthest path\n\t\t// part (leaf) node yet\n\t\tpullVal(obj[part], pathParts.join(\".\"), val, options);\n\t} else if (part) {\n\t\tobj[part] = decouple(obj[part], options) || [];\n\t\t\n\t\t// Recurse - this is the leaf node so assign the response to obj[part] in\n\t\t// case it is set to an immutable response\n\t\tobj[part] = pullVal(obj[part], \"\", val, options);\n\t} else {\n\t\t// The target array is the root object, pull the value\n\t\tobj = decouple(obj, options) || [];\n\t\t\n\t\tif (!(obj instanceof Array)) {\n\t\t\tthrow(\"Cannot pull from a path whose leaf node is not an array!\");\n\t\t}\n\t\t\n\t\tlet index = -1;\n\t\t\n\t\t// Find the index of the passed value\n\t\tif (options.strict === true) {\n\t\t\tindex = obj.indexOf(val);\n\t\t} else {\n\t\t\t// Do a non-strict check\n\t\t\tindex = obj.findIndex((item) => {\n\t\t\t\treturn match(item, val);\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (index > -1) {\n\t\t\t// Remove the item from the array\n\t\t\tobj.splice(index, 1);\n\t\t}\n\t}\n\t\n\treturn decouple(obj, options);\n};\n\n/**\n * Given a path and an object, determines the outermost leaf node\n * that can be reached where the leaf value is not undefined.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {String} The path to the furthest non-undefined value.\n */\nconst furthest = (obj, path, options = {}) => {\n\tlet internalPath = path,\n\t\tobjPart;\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": wildcardToZero, // Any path that has a wildcard will essentially check the first array item to continue down the tree\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tconst finalPath = [];\n\t\n\t// No path string, return the base obj\n\tif (!internalPath) {\n\t\treturn finalPath.join(\".\");\n\t}\n\t\n\tinternalPath = clean(internalPath);\n\t\n\t// Path is not a string, throw error\n\tif (typeof internalPath !== \"string\") {\n\t\tthrow new Error(\"Path argument must be a string\");\n\t}\n\t\n\tif (typeof obj !== \"object\") {\n\t\treturn finalPath.join(\".\");\n\t}\n\t\n\t// Path has no dot-notation, return key/value\n\tif (isNonCompositePath(internalPath)) {\n\t\tif (obj[internalPath] !== undefined) {\n\t\t\treturn internalPath;\n\t\t}\n\t\t\n\t\treturn finalPath.join(\".\");\n\t}\n\t\n\tconst pathParts = split(internalPath);\n\tobjPart = obj;\n\t\n\tfor (let i = 0; i < pathParts.length; i++) {\n\t\tconst pathPart = pathParts[i];\n\t\tobjPart = objPart[options.transformKey(unEscape(pathPart))];\n\t\t\n\t\tif (objPart === undefined) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfinalPath.push(pathPart);\n\t}\n\t\n\treturn finalPath.join(\".\");\n};\n\n/**\n * Traverses the object by the given path and returns an object where\n * each key is a path pointing to a leaf node and contains the value\n * from the leaf node from the overall object in the obj argument,\n * essentially providing all available paths in an object and all the\n * values for each path.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to retrieve data from.\n * @param {Object=} options Optional options object.\n * @returns {Object|Array} The result of the traversal.\n */\nconst values = (obj, path, options = {}) => {\n\tconst internalPath = clean(path);\n\tconst pathParts = split(internalPath);\n\tconst currentPath = [];\n\tconst valueData = {};\n\t\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tfor (let i = 0; i < pathParts.length; i++) {\n\t\tconst pathPart = options.transformKey(pathParts[i]);\n\t\tcurrentPath.push(pathPart);\n\t\t\n\t\tconst tmpPath = currentPath.join(\".\");\n\t\t\n\t\tvalueData[tmpPath] = get(obj, tmpPath);\n\t}\n\t\n\treturn valueData;\n};\n\n/**\n * Takes an object and finds all paths, then returns the paths as an\n * array of strings.\n * @param {Object|Array} obj The object to scan.\n * @param {Array=} finalArr An object used to collect the path keys.\n * (Do not pass this in directly - use undefined).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly - use undefined).\n * @param {Object=} options An options object.\n * @returns {Array<String>} An array containing path strings.\n */\nconst flatten = (obj, finalArr = [], parentPath = \"\", options = {}, objCache = []) => {\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tconst transformedObj = options.transformRead(obj);\n\t\n\t// Check that we haven't visited this object before (avoid infinite recursion)\n\tif (objCache.indexOf(transformedObj) > -1) {\n\t\treturn finalArr;\n\t}\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(transformedObj);\n\t\n\tconst currentPath = (i) => {\n\t\tconst tKey = options.transformKey(i);\n\t\treturn parentPath ? parentPath + \".\" + tKey : tKey;\n\t};\n\t\n\tfor (const i in transformedObj) {\n\t\tif (transformedObj.hasOwnProperty(i)) {\n\t\t\tif (options.ignore && options.ignore.test(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof transformedObj[i] === \"object\" && transformedObj[i] !== null) {\n\t\t\t\tflatten(transformedObj[i], finalArr, currentPath(i), options, objCache);\n\t\t\t}\n\t\t\t\n\t\t\tfinalArr.push(currentPath(i));\n\t\t}\n\t}\n\t\n\treturn finalArr;\n};\n\n/**\n * Takes an object and finds all paths, then returns the paths as keys\n * and the values of each path as the values.\n * @param {Object|Array} obj The object to scan.\n * @param {Object=} finalObj An object used to collect the path keys.\n * (Do not pass this in directly).\n * @param {String=} parentPath The path of the parent object. (Do not\n * pass this in directly).\n * @param {Object=} options An options object.\n * @returns {Object|Array} An object containing path keys and their values.\n */\nconst flattenValues = (obj, finalObj = {}, parentPath = \"\", options = {}, objCache = []) => {\n\toptions = {\n\t\t\"transformRead\": returnWhatWasGiven,\n\t\t\"transformKey\": returnWhatWasGiven,\n\t\t\"transformWrite\": returnWhatWasGiven,\n\t\t...options\n\t};\n\t\n\tconst transformedObj = options.transformRead(obj);\n\t\n\t// Check that we haven't visited this object before (avoid infinite recursion)\n\tif (objCache.indexOf(transformedObj) > -1) {\n\t\treturn finalObj;\n\t}\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(transformedObj);\n\t\n\tconst currentPath = (i, info) => {\n\t\tconst tKey = options.transformKey(i, info);\n\t\treturn parentPath ? parentPath + \".\" + tKey : tKey;\n\t};\n\t\n\tfor (const i in transformedObj) {\n\t\tif (transformedObj.hasOwnProperty(i)) {\n\t\t\tconst type = typeof transformedObj[i];\n\t\t\tconst info = {\n\t\t\t\ttype,\n\t\t\t\tisArrayIndex: Array.isArray(transformedObj),\n\t\t\t\tisFlat: type !== \"object\" || transformedObj[i] instanceof Date || transformedObj[i] instanceof RegExp\n\t\t\t};\n\t\t\t\n\t\t\tconst pathKey = currentPath(i, info);\n\t\t\t\n\t\t\tif (!info.isFlat) {\n\t\t\t\tif (transformedObj[i] !== null) {\n\t\t\t\t\tflattenValues(transformedObj[i], finalObj, pathKey, options, objCache);\n\t\t\t\t}\n\t\t\t} else if (options.leavesOnly) {\n\t\t\t\t// Found leaf node!\n\t\t\t\tfinalObj[pathKey] = options.transformWrite(transformedObj[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (!options.leavesOnly) {\n\t\t\t\tfinalObj[pathKey] = options.transformWrite(transformedObj[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn finalObj;\n};\n\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args args Path to join.\n * @returns {String} A final path string.\n */\nconst join = (...args) => {\n\treturn args.reduce((arr, item) => {\n\t\tif (item !== undefined && String(item)) {\n\t\t\tarr.push(item);\n\t\t}\n\t\t\n\t\treturn arr;\n\t}, []).join(\".\");\n};\n\n/**\n * Joins multiple string arguments into a path string.\n * Ignores blank or undefined path parts and also ensures\n * that each part is escaped so passing \"foo.bar\" will\n * result in an escaped version.\n * @param {...String} args Path to join.\n * @returns {String} A final path string.\n */\nconst joinEscaped = (...args) => {\n\tconst escapedArgs = args.map((item) => {\n\t\treturn escape(item);\n\t});\n\t\n\treturn join(...escapedArgs);\n};\n\n/**\n * Counts the total number of key leaf nodes in the passed object.\n * @param {Object|Array} obj The object to count key leaf nodes for.\n * @param {Array=} objCache Do not use. Internal array to track\n * visited leafs.\n * @returns {Number} The number of keys.\n */\nconst countLeafNodes = (obj, objCache = []) => {\n\tlet totalKeys = 0;\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(obj);\n\t\n\tfor (const i in obj) {\n\t\tif (obj.hasOwnProperty(i)) {\n\t\t\tif (obj[i] !== undefined) {\n\t\t\t\tif (typeof obj[i] !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n\t\t\t\t\ttotalKeys++;\n\t\t\t\t} else {\n\t\t\t\t\ttotalKeys += countLeafNodes(obj[i], objCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn totalKeys;\n};\n\n/**\n * Finds all the leaf nodes for a given object and returns an array of paths\n * to them. This is different from `flatten()` in that it only includes leaf\n * nodes and will not include every intermediary path traversed to get to a\n * leaf node.\n * @param {Object|Array} obj The object to traverse.\n * @param {String} [parentPath=\"\"] The path to use as a root/base path to\n * start scanning for leaf nodes under.\n * @param {Object} [objCache=[]] Internal usage to check for cyclic structures.\n * @returns {[]}\n */\nconst leafNodes = (obj, parentPath = \"\", objCache = []) => {\n\tconst paths = [];\n\t\n\t// Add object to cache to make sure we don't traverse it twice\n\tobjCache.push(obj);\n\t\n\tfor (const i in obj) {\n\t\tif (obj.hasOwnProperty(i)) {\n\t\t\tif (obj[i] !== undefined) {\n\t\t\t\tconst currentPath = join(parentPath, i);\n\t\t\t\t\n\t\t\t\tif (typeof obj[i] !== \"object\" || objCache.indexOf(obj[i]) > -1) {\n\t\t\t\t\tpaths.push(currentPath);\n\t\t\t\t} else {\n\t\t\t\t\tpaths.push(...leafNodes(obj[i], currentPath, objCache));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn paths;\n};\n\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths. MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Boolean} True if the object paths exist.\n */\nconst hasMatchingPathsInObject = function (testKeys, testObj) {\n\tlet result = true;\n\t\n\tfor (const i in testKeys) {\n\t\tif (testKeys.hasOwnProperty(i)) {\n\t\t\tif (testObj[i] === undefined) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof testKeys[i] === \"object\" && testKeys[i] !== null) {\n\t\t\t\t// Recurse object\n\t\t\t\tresult = hasMatchingPathsInObject(testKeys[i], testObj[i]);\n\t\t\t\t\n\t\t\t\t// Should we exit early?\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Tests if the passed object has the paths that are specified and that\n * a value exists in those paths and if so returns the number matched.\n * MAY NOT BE INFINITE RECURSION SAFE.\n * @param {Object|Array} testKeys The object describing the paths to test for.\n * @param {Object|Array} testObj The object to test paths against.\n * @returns {Object<matchedKeys<Number>, matchedKeyCount<Number>, totalKeyCount<Number>>} Stats on the matched keys.\n */\nconst countMatchingPathsInObject = (testKeys, testObj) => {\n\tconst matchedKeys = {};\n\t\n\tlet matchData,\n\t\tmatchedKeyCount = 0,\n\t\ttotalKeyCount = 0;\n\t\n\tfor (const i in testObj) {\n\t\tif (testObj.hasOwnProperty(i)) {\n\t\t\tif (typeof testObj[i] === \"object\" && testObj[i] !== null) {\n\t\t\t\t// The test / query object key is an object, recurse\n\t\t\t\tmatchData = countMatchingPathsInObject(testKeys[i], testObj[i]);\n\t\t\t\t\n\t\t\t\tmatchedKeys[i] = matchData.matchedKeys;\n\t\t\t\ttotalKeyCount += matchData.totalKeyCount;\n\t\t\t\tmatchedKeyCount += matchData.matchedKeyCount;\n\t\t\t} else {\n\t\t\t\t// The test / query object has a property that is not an object so add it as a key\n\t\t\t\ttotalKeyCount++;\n\t\t\t\t\n\t\t\t\t// Check if the test keys also have this key and it is also not an object\n\t\t\t\tif (testKeys && testKeys[i] && (typeof testKeys[i] !== \"object\" || testKeys[i] === null)) {\n\t\t\t\t\tmatchedKeys[i] = true;\n\t\t\t\t\tmatchedKeyCount++;\n\t\t\t\t} else {\n\t\t\t\t\tmatchedKeys[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn {\n\t\tmatchedKeys,\n\t\tmatchedKeyCount,\n\t\ttotalKeyCount\n\t};\n};\n\n/**\n * Returns the type from the item passed. Similar to JavaScript's\n * built-in typeof except it will distinguish between arrays, nulls\n * and objects as well.\n * @param {*} item The item to get the type of.\n * @returns {string|\"undefined\"|\"object\"|\"boolean\"|\"number\"|\"string\"|\"function\"|\"symbol\"|\"null\"|\"array\"}\n */\nconst type = (item) => {\n\tif (item === null) {\n\t\treturn 'null';\n\t}\n\tif (Array.isArray(item)) {\n\t\treturn 'array';\n\t}\n\t\n\treturn typeof item;\n};\n\n/**\n * Determines if the query data exists anywhere inside the source\n * data. Will recurse into arrays and objects to find query.\n * @param {*} source The source data to check.\n * @param {*} query The query data to find.\n * @returns {Boolean} True if query was matched, false if not.\n */\nconst match = (source, query) => {\n\tconst sourceType = typeof source;\n\tconst queryType = typeof query;\n\t\n\tif (sourceType !== queryType) {\n\t\treturn false;\n\t}\n\t\n\tif (sourceType !== \"object\" || source === null) {\n\t\t// Simple test\n\t\treturn source === query;\n\t}\n\t\n\t// The source is an object-like (array or object) structure\n\tconst entries = Object.entries(query);\n\t\n\tconst foundNonMatch = entries.find(([key, val]) => {\n\t\t// Recurse if type is array or object\n\t\tif (typeof val === \"object\" && val !== null) {\n\t\t\treturn !match(source[key], val);\n\t\t}\n\t\t\n\t\treturn source[key] !== val;\n\t});\n\t\n\treturn !foundNonMatch;\n};\n\n/**\n * @typedef {object} FindOptionsObject\n * @property {number} [maxDepth=Infinity] The maximum depth to scan inside\n * the source object for matching data.\n * @property {number} [currentDepth=0] The current depth of the\n * operation scan.\n * @property {boolean} [includeRoot=true] If true, will include the\n * root source object if it matches the query.\n */\n\n/**\n * Finds all items that matches the structure of `query` and\n * returns the path to them as an array of strings.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<Array>.\n */\nconst findPath = (source, query, options = {maxDepth: Infinity, currentDepth: 0, includeRoot: true}, parentPath = \"\") => {\n\tconst resultArr = [];\n\tconst sourceType = typeof source;\n\t\n\toptions = {\n\t\tmaxDepth: Infinity,\n\t\tcurrentDepth: 0,\n\t\tincludeRoot: true,\n\t\t...options\n\t};\n\t\n\tif (options.currentDepth !== 0 || (options.currentDepth === 0 && options.includeRoot)) {\n\t\tif (match(source, query)) {\n\t\t\tresultArr.push(parentPath);\n\t\t}\n\t}\n\t\n\toptions.currentDepth++;\n\t\n\tif (options.currentDepth <= options.maxDepth && sourceType === \"object\") {\n\t\tconst entries = Object.entries(source);\n\t\t\n\t\tentries.forEach(([key, val]) => {\n\t\t\t// Recurse down object to find more instances\n\t\t\tconst result = findPath(val, query, options, join(parentPath, key));\n\t\t\t\n\t\t\tif (result.match) {\n\t\t\t\tresultArr.push(...result.path);\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn {match: resultArr.length > 0, path: resultArr};\n};\n\n/**\n * Finds the first item that matches the structure of `query`\n * and returns the path to it.\n * @param {*} source The source to test.\n * @param {*} query The query to match.\n * @param {FindOptionsObject} [options] Options object.\n * @param {String=\"\"} parentPath Do not use. The aggregated\n * path to the current structure in source.\n * @returns {Object} Contains match<Boolean> and path<String>.\n */\nconst findOnePath = (source, query, options = {maxDepth: Infinity, currentDepth: 0, includeRoot: true}, parentPath = \"\") => {\n\tconst sourceType = typeof source;\n\t\n\toptions = {\n\t\tmaxDepth: Infinity,\n\t\tcurrentDepth: 0,\n\t\tincludeRoot: true,\n\t\t...options\n\t};\n\t\n\tif (options.currentDepth !== 0 || (options.currentDepth === 0 && options.includeRoot)) {\n\t\tif (match(source, query)) {\n\t\t\treturn {\n\t\t\t\tmatch: true,\n\t\t\t\tpath: parentPath\n\t\t\t};\n\t\t}\n\t}\n\t\n\toptions.currentDepth++;\n\t\n\tif (options.currentDepth <= options.maxDepth && sourceType === \"object\" && source !== null) {\n\t\tconst entries = Object.entries(source);\n\t\t\n\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\tconst [key, val] = entries[i];\n\t\t\t\n\t\t\t// Recurse down object to find more instances\n\t\t\tconst subPath = join(parentPath, key);\n\t\t\tconst result = findOnePath(val, query, options, subPath);\n\t\t\t\n\t\t\tif (result.match) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn {match: false};\n};\n\n/**\n * Returns a deduplicated array of strings.\n * @param {Array<String>} keys An array of strings to deduplicate.\n * @returns {Array<String>} The deduplicated array.\n */\nconst keyDedup = (keys) => {\n\treturn keys.filter((elem, pos, arr) => {\n\t\treturn arr.indexOf(elem) === pos;\n\t});\n};\n\n/**\n * Compares two provided objects / arrays and returns an array of\n * dot-notation paths to the fields that hold different values.\n * @param {Object|Array} obj1 The first object / array to compare.\n * @param {Object|Array} obj2 The second object / array to compare.\n * @param {String=\"\"} basePath The base path from which to check for\n * differences. Differences outside the base path will not be\n * returned as part of the array of differences. Leave blank to check\n * for all differences between the two objects to compare.\n * @param {Boolean=false} strict If strict is true, diff uses strict\n * equality to determine difference rather than non-strict equality;\n * effectively (=== is strict, == is non-strict).\n * @param {Number=Infinity} maxDepth Specifies the maximum number of\n * path sub-trees to walk down before returning what we have found.\n * For instance, if set to 2, a diff would only check down,\n * \"someFieldName.anotherField\", or \"user.name\" and would not go\n * further down than two fields. If anything in the trees further\n * down than this level have changed, the change will not be detected\n * and the path will not be included in the resulting diff array.\n * @param {String=\"\"} parentPath Used internally only.\n * @returns {Array} An array of strings, each string is a path to a\n * field that holds a different value between the two objects being\n * compared.\n */\nconst diff = (obj1, obj2, basePath = \"\", strict = false, maxDepth = Infinity, parentPath = \"\", objCache = []) => {\n\tconst paths = [];\n\t\n\tif (basePath instanceof Array) {\n\t\t// We were given an array of paths, check each path\n\t\treturn basePath.reduce((arr, individualPath) => {\n\t\t\t// Here we find any path that has a *non-equal* result which\n\t\t\t// returns true and then returns the index as a positive integer\n\t\t\t// that is not -1. If -1 is returned then no non-equal matches\n\t\t\t// were found\n\t\t\tconst result = diff(obj1, obj2, individualPath, strict, maxDepth, parentPath, objCache);\n\t\t\tif (result && result.length) {\n\t\t\t\tarr.push(...result);\n\t\t\t}\n\t\t\t\n\t\t\treturn arr;\n\t\t}, []);\n\t}\n\t\n\tconst currentPath = join(parentPath, basePath);\n\tconst val1 = get(obj1, basePath);\n\tconst val2 = get(obj2, basePath);\n\tconst type1 = type(val1);\n\tconst type2 = type(val2);\n\t\n\tif (type1 !== type2) {\n\t\t// Difference in source and comparison types\n\t\tpaths.push(currentPath);\n\t} else if (type1 === \"array\" && val1.length !== val2.length) {\n\t\t// Difference in source and comparison types\n\t\tpaths.push(currentPath);\n\t}\n\t\n\tconst pathParts = currentPath.split(\".\");\n\tconst hasParts = pathParts[0] !== \"\";\n\t\n\tif ((!hasParts || pathParts.length < maxDepth) && typeof val1 === \"object\" && val1 !== null) {\n\t\t// Check that we haven't visited this object before (avoid infinite recursion)\n\t\tif (objCache.indexOf(val1) > -1 || objCache.indexOf(val2) > -1) {\n\t\t\treturn paths;\n\t\t}\n\t\t\n\t\tobjCache.push(val1);\n\t\tobjCache.push(val2);\n\t\t\n\t\t// Grab composite of all keys on val1 and val2\n\t\tconst val1Keys = Object.keys(val1);\n\t\tconst val2Keys = (typeof val2 === \"object\" && val2 !== null) ? Object.keys(val2) : [];\n\t\tconst compositeKeys = keyDedup(val1Keys.concat(val2Keys));\n\t\t\n\t\treturn compositeKeys.reduce((arr, key) => {\n\t\t\tconst result = diff(val1, val2, key, strict, maxDepth, currentPath, objCache);\n\t\t\tif (result && result.length) {\n\t\t\t\tarr.push(...result);\n\t\t\t}\n\t\t\t\n\t\t\treturn arr;\n\t\t}, paths);\n\t}\n\t\n\tif ((strict && val1 !== val2) || (!strict && val1 != val2)) {\n\t\tpaths.push(currentPath);\n\t}\n\t\n\treturn keyDedup(paths);\n};\n\n/**\n * A boolean check to see if the values at the given path or paths\n * are the same in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to check\n * values in. If this is an array, all values at the paths in the array\n * must be the same for the function to provide a true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for equality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values match, false if not.\n */\nconst isEqual = (obj1, obj2, path, deep = false, strict = false) => {\n\tif (path instanceof Array) {\n\t\t// We were given an array of paths, check each path\n\t\treturn path.findIndex((individualPath) => {\n\t\t\t// Here we find any path that has a *non-equal* result which\n\t\t\t// returns true and then returns the index as a positive integer\n\t\t\t// that is not -1. If -1 is returned then no non-equal matches\n\t\t\t// were found\n\t\t\treturn isNotEqual(obj1, obj2, individualPath, deep, strict);\n\t\t}) === -1;\n\t}\n\t\n\tconst val1 = get(obj1, path);\n\tconst val2 = get(obj2, path);\n\t\n\tif (deep) {\n\t\tif (typeof val1 === \"object\" && val1 !== null) {\n\t\t\t// TODO: This probably needs a composite key array of val1 and val2 keys\n\t\t\t//  just as we do in the diff() function\n\t\t\treturn Object.keys(val1).findIndex((key) => {\n\t\t\t\treturn isNotEqual(val1, val2, key, deep, strict);\n\t\t\t}) === -1;\n\t\t}\n\t}\n\t\n\treturn (strict && val1 === val2) || (!strict && val1 == val2);\n};\n\n/**\n * A boolean check to see if the values at the given path or paths\n * are different in both given objects.\n * @param {*} obj1 The first object to check values in.\n * @param {*} obj2 The second object to check values in.\n * @param {Array<String>|String}path A path or array of paths to\n * check values in. If this is an array, all values at the paths\n * in the array must be different for the function to provide a\n * true result.\n * @param {Boolean} deep If true will traverse all objects and arrays\n * to check for inequality. Defaults to false.\n * @param {Boolean} strict If true, values must be strict-not-equal.\n * Defaults to false.\n * @returns {Boolean} True if path values differ, false if not.\n */\nconst isNotEqual = (obj1, obj2, path, deep = false, strict = false) => {\n\treturn !isEqual(obj1, obj2, path, deep, strict);\n};\n\n/**\n * Same as set() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst setImmutable = (obj, path, val, options = {}) => {\n\treturn set(obj, path, val, {...options, immutable: true});\n};\n\n/**\n * Same as pushVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst pushValImmutable = (obj, path, val, options = {}) => {\n\treturn pushVal(obj, path, val, {...options, immutable: true});\n};\n\n/**\n * Same as pullVal() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {*} val The value to use for the operation.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst pullValImmutable = (obj, path, val, options = {}) => {\n\treturn pullVal(obj, path, val, {...options, immutable: true});\n};\n\n/**\n * Same as unSet() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {String} path The path to operate on.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst unSetImmutable = (obj, path, options = {}) => {\n\treturn unSet(obj, path, {...options, immutable: true});\n};\n\n/**\n * Same as update() but will not change or modify the existing `obj`.\n * References to objects that were not modified remain the same.\n * @param {Object|Array} obj The object to operate on.\n * @param {Object|Array} updateData The update data to apply with\n * keys as string paths.\n * @param {Object=} options The options object.\n * @returns {*} The new object with the modified data.\n */\nconst updateImmutable = (obj, updateData, options) => {\n\treturn update(obj, updateData, {...options, immutable: true});\n};\n\n/**\n * Gets the values of the paths in pathArr and returns them as an object\n * with each key matching the path and the value matching the value from\n * obj that was at that path.\n * @param {Object} obj The object to operate on.\n * @param {Array<String>} pathArr Array of path strings.\n * @returns {*} The new object.\n */\nconst distill = (obj, pathArr) => {\n\treturn pathArr.reduce((newObj, path) => {\n\t\tnewObj[path] = get(obj, path);\n\t\treturn newObj;\n\t}, {});\n};\n\n/**\n * Chops a `path` string down to the given `level`. Given a `path` string\n * like \"foo.bar.ram.you.too\", chop will remove any path parts below\n * the given `level`. If we pass 2 as the `level` with that given `path`,\n * the result will be \"foo.bar\" as foo is level 1 and bar is level 2.\n * If the `path` is shorter than the given `level`, it is returned intact.\n * @param {String} path The path to operate on.\n * @param {Number} level The maximum level of a path.\n * @returns {String} The new path string.\n */\nconst chop = (path, level) => {\n\tconst parts = split(path);\n\n\tif (parts.length > level) {\n\t\tparts.length = level;\n\t}\n\n\treturn join(...parts);\n};\n\nmodule.exports = {\n\twildcardToZero,\n\tnumberToWildcard,\n\tclean,\n\tdecouple,\n\tsplit,\n\tescape,\n\tget,\n\tset,\n\tsetImmutable,\n\tunSet,\n\tunSetImmutable,\n\tpushValImmutable,\n\tpushVal,\n\tpullValImmutable,\n\tpullVal,\n\tfurthest,\n\tvalues,\n\tflatten,\n\tflattenValues,\n\tjoin,\n\tjoinEscaped,\n\tup,\n\tdown,\n\tpush,\n\tpop,\n\tshift,\n\tcountLeafNodes,\n\thasMatchingPathsInObject,\n\tcountMatchingPathsInObject,\n\tfindOnePath,\n\tfindPath,\n\ttype,\n\tmatch,\n\tisEqual,\n\tisNotEqual,\n\tleafNodes,\n\tdiff,\n\tupdate,\n\tupdateImmutable,\n\tdistill,\n\tchop\n};"], "filenames": ["dist/Path.js", "package.json", "src/Path.js"], "buggy_code_start_loc": [453, 3, 402], "buggy_code_end_loc": [673, 4, 615], "fixing_code_start_loc": [454, 3, 403], "fixing_code_end_loc": [686, 4, 635], "type": "CWE-1321", "message": "The package irrelon-path before 4.7.0; the package @irrelon/path before 4.7.0 are vulnerable to Prototype Pollution via the set, unSet, pushVal and pullVal functions.", "other": {"cve": {"id": "CVE-2020-7708", "sourceIdentifier": "report@snyk.io", "published": "2020-08-18T15:15:12.333", "lastModified": "2022-12-02T19:55:48.067", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package irrelon-path before 4.7.0; the package @irrelon/path before 4.7.0 are vulnerable to Prototype Pollution via the set, unSet, pushVal and pullVal functions."}, {"lang": "es", "value": "El paquete irrelon-path versiones anteriores a 4.7.0; el paquete @irrelon/path versiones anteriores a 4.7.0, es vulnerable a una Contaminaci\u00f3n de Prototipo por medio de las funciones set, unSet, pushVal y pullVal."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irrelon:\\@irrelon\\/path:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.7.0", "matchCriteriaId": "202548AC-FA8E-406E-A5EF-C48122B58FF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:irrelon:irrelon-path:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.7.0", "matchCriteriaId": "9717B005-C679-4C0C-A583-41FC2380E688"}]}]}], "references": [{"url": "https://github.com/Irrelon/irrelon-path/commit/8a126b160c1a854ae511659c111413ad9910ebe3", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-IRRELONPATH-598672", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-IRRELONPATH-598673", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Irrelon/irrelon-path/commit/8a126b160c1a854ae511659c111413ad9910ebe3"}}