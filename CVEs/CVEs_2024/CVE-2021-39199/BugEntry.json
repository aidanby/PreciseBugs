{"buggy_code": ["/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('hast-util-sanitize').Schema} Schema\n * @typedef {import('mdast-util-to-hast').Handlers} Handlers\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean|Schema|null} [sanitize]\n *   How to sanitize the output.\n * @property {Handlers} [handlers={}]\n *   Object mapping mdast nodes to functions handling them.\n */\n\nimport {toHtml} from 'hast-util-to-html'\nimport {sanitize} from 'hast-util-sanitize'\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Plugin to serialize markdown as HTML.\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root, string>}\n */\nexport default function remarkHtml(options = {}) {\n  const handlers = options.handlers || {}\n  const schema =\n    options.sanitize && typeof options.sanitize === 'object'\n      ? options.sanitize\n      : undefined\n\n  Object.assign(this, {Compiler: compiler})\n\n  /**\n   * @type {import('unified').CompilerFunction<Root, string>}\n   */\n  function compiler(node, file) {\n    const hast = toHast(node, {allowDangerousHtml: !options.sanitize, handlers})\n    // @ts-expect-error: assume root.\n    const cleanHast = options.sanitize ? sanitize(hast, schema) : hast\n    const result = toHtml(\n      // @ts-expect-error: assume root.\n      cleanHast,\n      Object.assign({}, options, {allowDangerousHtml: !options.sanitize})\n    )\n\n    if (file.extname) {\n      file.extname = '.html'\n    }\n\n    // Add an eof eol.\n    return node &&\n      node.type &&\n      node.type === 'root' &&\n      result &&\n      /[^\\r\\n]/.test(result.charAt(result.length - 1))\n      ? result + '\\n'\n      : result\n  }\n}\n", "/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('../index.js').Options} Options\n */\n\nimport path from 'node:path'\nimport fs from 'node:fs'\nimport test from 'tape'\nimport {isHidden} from 'is-hidden'\nimport {commonmark} from 'commonmark.json'\nimport {toVFile} from 'to-vfile'\nimport {all} from 'mdast-util-to-hast'\nimport {unified} from 'unified'\nimport {remark} from 'remark'\nimport remarkParse from 'remark-parse'\nimport remarkSlug from 'remark-slug'\nimport remarkFootnotes from 'remark-footnotes'\nimport remarkFrontmatter from 'remark-frontmatter'\nimport remarkGfm from 'remark-gfm'\nimport remarkGithub from 'remark-github'\nimport remarkToc from 'remark-toc'\nimport rehypeParse from 'rehype-parse'\nimport rehypeStringify from 'rehype-stringify'\nimport remarkHtml from '../index.js'\n\ntest('remarkHtml', (t) => {\n  t.doesNotThrow(() => {\n    remark().use(remarkHtml).freeze()\n  }, 'should not throw if not passed options')\n\n  t.throws(\n    () => {\n      remark()\n        .use(remarkHtml)\n        // @ts-expect-error: not a node.\n        .stringify({type: 'root', children: [{value: 'baz'}]})\n    },\n    /Expected node, got `\\[object Object]`/,\n    'should throw when not given a node'\n  )\n\n  let processor = remark().use(remarkHtml)\n\n  t.equal(\n    // @ts-expect-error: unknown node.\n    processor.stringify({type: 'alpha'}),\n    '<div></div>',\n    'should stringify unknown nodes'\n  )\n\n  t.equal(\n    processor.stringify({\n      // @ts-expect-error: unknown node.\n      type: 'alpha',\n      children: [{type: 'strong', children: [{type: 'text', value: 'bravo'}]}]\n    }),\n    '<div><strong>bravo</strong></div>',\n    'should stringify unknown nodes'\n  )\n\n  t.equal(\n    processor.stringify({\n      // @ts-expect-error: unknown node.\n      type: 'alpha',\n      children: [{type: 'text', value: 'bravo'}],\n      data: {\n        hName: 'i',\n        hProperties: {className: 'charlie'},\n        hChildren: [{type: 'text', value: 'delta'}]\n      }\n    }),\n    '<i class=\"charlie\">delta</i>',\n    'should stringify unknown nodes'\n  )\n\n  processor = remark().use(remarkHtml, {\n    handlers: {\n      /** @param {Paragraph} node */\n      paragraph(h, node) {\n        const head = node.children[0]\n\n        if (head.type === 'text') {\n          head.value = 'changed'\n        }\n\n        return h(node, 'p', all(h, node))\n      }\n    }\n  })\n\n  t.equal(\n    processor.processSync('paragraph text').toString(),\n    '<p>changed</p>\\n',\n    'should allow overriding handlers'\n  )\n\n  processor = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        ast.children[0].children[0].data = {\n          hProperties: {title: 'overwrite'}\n        }\n      }\n    )\n    .use(remarkHtml)\n\n  t.equal(\n    processor.processSync('![hello](example.jpg \"overwritten\")').toString(),\n    '<p><img src=\"example.jpg\" alt=\"hello\" title=\"overwrite\"></p>\\n',\n    'should patch and merge attributes'\n  )\n\n  processor = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        ast.children[0].children[0].data = {hName: 'b'}\n      }\n    )\n    .use(remarkHtml)\n\n  t.equal(\n    processor.processSync('**Bold!**').toString(),\n    '<p><b>Bold!</b></p>\\n',\n    'should overwrite a tag-name'\n  )\n\n  processor = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        const code = ast.children[0].children[0]\n\n        code.data = {\n          hChildren: [\n            {\n              type: 'element',\n              tagName: 'span',\n              properties: {className: ['token']},\n              children: [{type: 'text', value: code.value}]\n            }\n          ]\n        }\n      }\n    )\n    .use(remarkHtml)\n\n  t.equal(\n    processor.processSync('`var`').toString(),\n    '<p><code><span class=\"token\">var</span></code></p>\\n',\n    'should overwrite content'\n  )\n\n  processor = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        const code = ast.children[0].children[0]\n\n        code.data = {\n          hChildren: [\n            {\n              type: 'element',\n              tagName: 'output',\n              properties: {className: ['token']},\n              children: [{type: 'text', value: code.value}]\n            }\n          ]\n        }\n      }\n    )\n    .use(remarkHtml, {sanitize: true})\n\n  t.equal(\n    processor.processSync('`var`').toString(),\n    '<p><code>var</code></p>\\n',\n    'should not overwrite content in `sanitize` mode'\n  )\n\n  processor = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        ast.children[0].data = {\n          hProperties: {className: 'foo'}\n        }\n      }\n    )\n    .use(remarkHtml)\n\n  t.equal(\n    processor.processSync('```js\\nvar\\n```\\n').toString(),\n    '<pre><code class=\"foo\">var\\n</code></pre>\\n',\n    'should overwrite classes on code'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml)\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello <span>world</span></h2>\\n',\n    'should be `sanitation: false` by default'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: true})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello world</h2>\\n',\n    'should support sanitation: true'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: null})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello <span>world</span></h2>\\n',\n    'should support sanitation: null'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: false})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello <span>world</span></h2>\\n',\n    'should support sanitation: false'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: {tagNames: []}})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    'Hello world\\n',\n    'should support sanitation schemas'\n  )\n\n  t.end()\n})\n\n// Assert fixtures.\ntest('Fixtures', (t) => {\n  const base = path.join('test', 'fixtures')\n  const files = fs.readdirSync(base)\n  let index = -1\n\n  while (++index < files.length) {\n    const name = files[index]\n\n    if (isHidden(name)) continue\n\n    const output = String(fs.readFileSync(path.join(base, name, 'output.html')))\n    const input = String(fs.readFileSync(path.join(base, name, 'input.md')))\n    const file = toVFile({path: name + '.md', value: input})\n    let config = {}\n\n    try {\n      config = JSON.parse(\n        String(fs.readFileSync(path.join(base, name, 'config.json')))\n      )\n    } catch {}\n\n    const result = processSync(file, config)\n\n    t.equal(result, output, 'should work on `' + name + '`')\n  }\n\n  t.end()\n})\n\ntest('CommonMark', (t) => {\n  let start = 0\n  let index = -1\n  /** @type {string|undefined} */\n  let section\n\n  while (++index < commonmark.length) {\n    const example = commonmark[index]\n    if (section !== example.section) {\n      section = example.section\n      start = index\n    }\n\n    const actual = unified()\n      .use(remarkParse)\n      .use(remarkHtml)\n      .processSync(example.markdown)\n      .toString()\n\n    const reformat = unified()\n      .use(rehypeParse, {fragment: true})\n      .use(rehypeStringify)\n\n    // Normalize meaningless stuff, like character references, `<hr />` is `<hr>`,\n    // etc.\n    t.equal(\n      String(reformat.processSync(actual)),\n      String(reformat.processSync(example.html)),\n      index + ': ' + example.section + ' (' + (index - start + 1) + ')'\n    )\n  }\n\n  t.end()\n})\n\ntest('Integrations', (t) => {\n  const integrationMap = {\n    footnotes: remarkFootnotes,\n    frontmatter: remarkFrontmatter,\n    gfm: remarkGfm,\n    github: remarkGithub,\n    toc: [remarkSlug, remarkToc]\n  }\n  const base = path.join('test', 'integrations')\n  const files = /** @type {(keyof integrationMap)[]} */ (fs.readdirSync(base))\n  let index = -1\n\n  while (++index < files.length) {\n    const name = files[index]\n\n    if (isHidden(name)) continue\n\n    const output = String(fs.readFileSync(path.join(base, name, 'output.html')))\n    const input = String(fs.readFileSync(path.join(base, name, 'input.md')))\n    const file = toVFile({path: name + '.md', value: input})\n    const result = remark()\n      // @ts-expect-error: fine.\n      .use(integrationMap[name])\n      .use(remarkHtml)\n      .processSync(file)\n      .toString()\n\n    t.equal(result, output, 'should integrate w/ `' + name + '`')\n  }\n\n  t.end()\n})\n\n/**\n * @param {VFile} file\n * @param {Options} [config]\n */\nfunction processSync(file, config) {\n  return remark().use(remarkHtml, config).processSync(file).toString()\n}\n"], "fixing_code": ["/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('hast-util-sanitize').Schema} Schema\n * @typedef {import('mdast-util-to-hast').Handlers} Handlers\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean|Schema|null} [sanitize]\n *   How to sanitize the output.\n * @property {Handlers} [handlers={}]\n *   Object mapping mdast nodes to functions handling them.\n */\n\nimport {toHtml} from 'hast-util-to-html'\nimport {sanitize} from 'hast-util-sanitize'\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Plugin to serialize markdown as HTML.\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root, string>}\n */\nexport default function remarkHtml(settings) {\n  const options = {...(settings || {})}\n  /** @type {boolean|undefined} */\n  let clean\n\n  if (typeof options.sanitize === 'boolean') {\n    clean = options.sanitize\n    options.sanitize = undefined\n  }\n\n  if (typeof clean !== 'boolean') {\n    clean = true\n  }\n\n  Object.assign(this, {Compiler: compiler})\n\n  /**\n   * @type {import('unified').CompilerFunction<Root, string>}\n   */\n  function compiler(node, file) {\n    const hast = toHast(node, {\n      allowDangerousHtml: !clean,\n      handlers: options.handlers\n    })\n    // @ts-expect-error: assume root.\n    const cleanHast = clean ? sanitize(hast, options.sanitize) : hast\n    const result = toHtml(\n      // @ts-expect-error: assume root.\n      cleanHast,\n      Object.assign({}, options, {allowDangerousHtml: !clean})\n    )\n\n    if (file.extname) {\n      file.extname = '.html'\n    }\n\n    // Add an eof eol.\n    return node &&\n      node.type &&\n      node.type === 'root' &&\n      result &&\n      /[^\\r\\n]/.test(result.charAt(result.length - 1))\n      ? result + '\\n'\n      : result\n  }\n}\n", "/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('../index.js').Options} Options\n */\n\nimport path from 'node:path'\nimport fs from 'node:fs'\nimport test from 'tape'\nimport {isHidden} from 'is-hidden'\nimport {commonmark} from 'commonmark.json'\nimport {toVFile} from 'to-vfile'\nimport {all} from 'mdast-util-to-hast'\nimport {unified} from 'unified'\nimport {remark} from 'remark'\nimport remarkParse from 'remark-parse'\nimport remarkSlug from 'remark-slug'\nimport remarkFootnotes from 'remark-footnotes'\nimport remarkFrontmatter from 'remark-frontmatter'\nimport remarkGfm from 'remark-gfm'\nimport remarkGithub from 'remark-github'\nimport remarkToc from 'remark-toc'\nimport rehypeParse from 'rehype-parse'\nimport rehypeStringify from 'rehype-stringify'\nimport remarkHtml from '../index.js'\n\ntest('remarkHtml', (t) => {\n  t.doesNotThrow(() => {\n    remark().use(remarkHtml).freeze()\n  }, 'should not throw if not passed options')\n\n  t.throws(\n    () => {\n      remark()\n        .use(remarkHtml)\n        // @ts-expect-error: not a node.\n        .stringify({type: 'root', children: [{value: 'baz'}]})\n    },\n    /Expected node, got `\\[object Object]`/,\n    'should throw when not given a node'\n  )\n\n  let processorDangerous = remark().use(remarkHtml, {sanitize: false})\n\n  t.equal(\n    // @ts-expect-error: unknown node.\n    processorDangerous.stringify({type: 'alpha'}),\n    '<div></div>',\n    'should stringify unknown nodes'\n  )\n\n  t.equal(\n    processorDangerous.stringify({\n      // @ts-expect-error: unknown node.\n      type: 'alpha',\n      children: [{type: 'strong', children: [{type: 'text', value: 'bravo'}]}]\n    }),\n    '<div><strong>bravo</strong></div>',\n    'should stringify unknown nodes'\n  )\n\n  t.equal(\n    processorDangerous.stringify({\n      // @ts-expect-error: unknown node.\n      type: 'alpha',\n      children: [{type: 'text', value: 'bravo'}],\n      data: {\n        hName: 'i',\n        hProperties: {className: 'charlie'},\n        hChildren: [{type: 'text', value: 'delta'}]\n      }\n    }),\n    '<i class=\"charlie\">delta</i>',\n    'should stringify unknown nodes'\n  )\n\n  processorDangerous = remark().use(remarkHtml, {\n    sanitize: false,\n    handlers: {\n      /** @param {Paragraph} node */\n      paragraph(h, node) {\n        const head = node.children[0]\n\n        if (head.type === 'text') {\n          head.value = 'changed'\n        }\n\n        return h(node, 'p', all(h, node))\n      }\n    }\n  })\n\n  t.equal(\n    processorDangerous.processSync('paragraph text').toString(),\n    '<p>changed</p>\\n',\n    'should allow overriding handlers'\n  )\n\n  processorDangerous = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        ast.children[0].children[0].data = {\n          hProperties: {title: 'overwrite'}\n        }\n      }\n    )\n    .use(remarkHtml, {sanitize: false})\n\n  t.equal(\n    processorDangerous\n      .processSync('![hello](example.jpg \"overwritten\")')\n      .toString(),\n    '<p><img src=\"example.jpg\" alt=\"hello\" title=\"overwrite\"></p>\\n',\n    'should patch and merge attributes'\n  )\n\n  processorDangerous = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        ast.children[0].children[0].data = {hName: 'b'}\n      }\n    )\n    .use(remarkHtml, {sanitize: false})\n\n  t.equal(\n    processorDangerous.processSync('**Bold!**').toString(),\n    '<p><b>Bold!</b></p>\\n',\n    'should overwrite a tag-name'\n  )\n\n  processorDangerous = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        const code = ast.children[0].children[0]\n\n        code.data = {\n          hChildren: [\n            {\n              type: 'element',\n              tagName: 'span',\n              properties: {className: ['token']},\n              children: [{type: 'text', value: code.value}]\n            }\n          ]\n        }\n      }\n    )\n    .use(remarkHtml, {sanitize: false})\n\n  t.equal(\n    processorDangerous.processSync('`var`').toString(),\n    '<p><code><span class=\"token\">var</span></code></p>\\n',\n    'should overwrite content'\n  )\n\n  processorDangerous = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        // @ts-expect-error: assume it exists.\n        const code = ast.children[0].children[0]\n\n        code.data = {\n          hChildren: [\n            {\n              type: 'element',\n              tagName: 'output',\n              properties: {className: ['token']},\n              children: [{type: 'text', value: code.value}]\n            }\n          ]\n        }\n      }\n    )\n    .use(remarkHtml, {sanitize: true})\n\n  t.equal(\n    processorDangerous.processSync('`var`').toString(),\n    '<p><code>var</code></p>\\n',\n    'should not overwrite content in `sanitize` mode'\n  )\n\n  processorDangerous = remark()\n    .use(\n      /** @type {import('unified').Plugin<void[], Root>} */\n      () => (ast) => {\n        ast.children[0].data = {\n          hProperties: {className: 'foo'}\n        }\n      }\n    )\n    .use(remarkHtml, {sanitize: false})\n\n  t.equal(\n    processorDangerous.processSync('```js\\nvar\\n```\\n').toString(),\n    '<pre><code class=\"foo\">var\\n</code></pre>\\n',\n    'should overwrite classes on code'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml)\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello world</h2>\\n',\n    'should be `sanitation: true` by default'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: true})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello world</h2>\\n',\n    'should support sanitation: true'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: null})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello world</h2>\\n',\n    'should support sanitation: null'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: false})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    '<h2>Hello <span>world</span></h2>\\n',\n    'should support sanitation: false'\n  )\n\n  t.equal(\n    remark()\n      .use(remarkHtml, {sanitize: {tagNames: []}})\n      .processSync('## Hello <span>world</span>')\n      .toString(),\n    'Hello world\\n',\n    'should support sanitation schemas'\n  )\n\n  t.end()\n})\n\n// Assert fixtures.\ntest('Fixtures', (t) => {\n  const base = path.join('test', 'fixtures')\n  const files = fs.readdirSync(base)\n  let index = -1\n\n  while (++index < files.length) {\n    const name = files[index]\n\n    if (isHidden(name)) continue\n\n    const output = String(fs.readFileSync(path.join(base, name, 'output.html')))\n    const input = String(fs.readFileSync(path.join(base, name, 'input.md')))\n    const file = toVFile({path: name + '.md', value: input})\n    let config = {}\n\n    try {\n      config = JSON.parse(\n        String(fs.readFileSync(path.join(base, name, 'config.json')))\n      )\n    } catch {}\n\n    const result = processSync(file, config)\n\n    t.equal(result, output, 'should work on `' + name + '`')\n  }\n\n  t.end()\n})\n\ntest('CommonMark', (t) => {\n  let start = 0\n  let index = -1\n  /** @type {string|undefined} */\n  let section\n\n  while (++index < commonmark.length) {\n    const example = commonmark[index]\n    if (section !== example.section) {\n      section = example.section\n      start = index\n    }\n\n    const actual = unified()\n      .use(remarkParse)\n      .use(remarkHtml, {sanitize: false})\n      .processSync(example.markdown)\n      .toString()\n\n    const reformat = unified()\n      .use(rehypeParse, {fragment: true})\n      .use(rehypeStringify)\n\n    // Normalize meaningless stuff, like character references, `<hr />` is `<hr>`,\n    // etc.\n    t.equal(\n      String(reformat.processSync(actual)),\n      String(reformat.processSync(example.html)),\n      index + ': ' + example.section + ' (' + (index - start + 1) + ')'\n    )\n  }\n\n  t.end()\n})\n\ntest('Integrations', (t) => {\n  const integrationMap = {\n    footnotes: remarkFootnotes,\n    frontmatter: remarkFrontmatter,\n    gfm: remarkGfm,\n    github: remarkGithub,\n    toc: [remarkSlug, remarkToc]\n  }\n  const base = path.join('test', 'integrations')\n  const files = /** @type {(keyof integrationMap)[]} */ (fs.readdirSync(base))\n  let index = -1\n\n  while (++index < files.length) {\n    const name = files[index]\n\n    if (isHidden(name)) continue\n\n    const output = String(fs.readFileSync(path.join(base, name, 'output.html')))\n    const input = String(fs.readFileSync(path.join(base, name, 'input.md')))\n    const file = toVFile({path: name + '.md', value: input})\n    const result = remark()\n      // @ts-expect-error: fine.\n      .use(integrationMap[name])\n      .use(remarkHtml, {sanitize: false})\n      .processSync(file)\n      .toString()\n\n    t.equal(result, output, 'should integrate w/ `' + name + '`')\n  }\n\n  t.end()\n})\n\n/**\n * @param {VFile} file\n * @param {Options} [config]\n */\nfunction processSync(file, config) {\n  return remark().use(remarkHtml, config).processSync(file).toString()\n}\n"], "filenames": ["index.js", "test/index.js"], "buggy_code_start_loc": [23, 44], "buggy_code_end_loc": [43, 341], "fixing_code_start_loc": [23, 44], "fixing_code_end_loc": [53, 344], "type": "CWE-79", "message": "remark-html is an open source nodejs library which compiles Markdown to HTML. In affected versions the documentation of remark-html has mentioned that it was safe by default. In practice the default was never safe and had to be opted into. That is, user input was not sanitized. This means arbitrary HTML can be passed through leading to potential XSS attacks. The problem has been patched in 13.0.2 and 14.0.1: `remark-html` is now safe by default, and the implementation matches the documentation. On older affected versions, pass `sanitize: true` if you cannot update.", "other": {"cve": {"id": "CVE-2021-39199", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-07T19:15:08.747", "lastModified": "2021-09-14T16:11:25.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "remark-html is an open source nodejs library which compiles Markdown to HTML. In affected versions the documentation of remark-html has mentioned that it was safe by default. In practice the default was never safe and had to be opted into. That is, user input was not sanitized. This means arbitrary HTML can be passed through leading to potential XSS attacks. The problem has been patched in 13.0.2 and 14.0.1: `remark-html` is now safe by default, and the implementation matches the documentation. On older affected versions, pass `sanitize: true` if you cannot update."}, {"lang": "es", "value": "remark-html es una librer\u00eda nodejs de c\u00f3digo abierto que compila Markdown a HTML. En las versiones afectadas, la documentaci\u00f3n de remark-html mencionaba que era segura por defecto. En la pr\u00e1ctica, nunca fue segura por defecto y hab\u00eda que optar por ella. Es decir, la entrada del usuario no era saneada. Esto significa que se puede pasar  HTML arbitrario, conllevando a potenciales ataques de tipo XSS. El problema ha sido parcheado en las versiones 13.0.2 y 14.0.1: \"remark-html\" es ahora seguro por defecto, y la implementaci\u00f3n coincide con la documentaci\u00f3n. En versiones anteriores afectadas, pase \"sanitize: true\" si no puede actualizar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:remark:remark-html:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "13.0.2", "matchCriteriaId": "90DE1DEF-8004-44A1-AB3F-8D17332D736D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:remark:remark-html:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.0.1", "matchCriteriaId": "DBFC237B-016F-485A-9C0E-3040E1CA4E70"}]}]}], "references": [{"url": "https://github.com/remarkjs/remark-html/commit/b75c9dde582ad87ba498e369c033dc8a350478c1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/remarkjs/remark-html/releases/tag/14.0.1", "source": "security-advisories@github.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/remarkjs/remark-html/security/advisories/GHSA-9q5w-79cv-947m", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/remark-html", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/remarkjs/remark-html/commit/b75c9dde582ad87ba498e369c033dc8a350478c1"}}