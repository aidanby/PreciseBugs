{"buggy_code": ["import { isPromise, then } from '../../util/promises';\nimport { InvokeContext, newInvokeContext, invoke } from '../../use/use-core';\nimport { createJSXError, isJSXNode, jsx } from '../jsx/jsx-runtime';\nimport { isArray, isFunction, isString, ValueOrPromise } from '../../util/types';\nimport type { JSXNode } from '../jsx/types/jsx-node';\nimport {\n  createRenderContext,\n  executeComponent,\n  getNextIndex,\n  isAriaAttribute,\n  jsxToString,\n  pushRenderContext,\n  serializeClass,\n  stringifyStyle,\n} from '../execute-component';\nimport { ELEMENT_ID, OnRenderProp, QScopedStyle, QSlot, QSlotS, QStyle } from '../../util/markers';\nimport { InternalSSRStream, Virtual, SSRRaw, SSRHint } from '../jsx/utils.public';\nimport { logError, logWarn } from '../../util/log';\nimport {\n  groupListeners,\n  isOnProp,\n  Listener,\n  PREVENT_DEFAULT,\n  setEvent,\n} from '../../state/listeners';\nimport { version } from '../../version';\nimport {\n  addQwikEvent,\n  ContainerState,\n  createContainerState,\n  setRef,\n} from '../../container/container';\nimport type { RenderContext } from '../types';\nimport { assertDefined } from '../../error/assert';\nimport { serializeSStyle } from '../../style/qrl-styles';\nimport { qDev, qInspector, seal } from '../../util/qdev';\nimport { qError, QError_canNotRenderHTML } from '../../error/error';\nimport { addSignalSub, isSignal, Signal } from '../../state/signal';\nimport { serializeQRLs } from '../../qrl/qrl';\nimport type { QwikElement } from '../dom/virtual-element';\nimport { assertElement } from '../../util/element';\nimport { EMPTY_OBJ } from '../../util/flyweight';\nimport {\n  createContext,\n  HOST_FLAG_DYNAMIC,\n  HOST_FLAG_NEED_ATTACH_LISTENER,\n  QContext,\n  Q_CTX,\n} from '../../state/context';\nimport { createPropsState, createProxy } from '../../state/store';\nimport { _IMMUTABLE, _IMMUTABLE_PREFIX } from '../../state/constants';\n\nconst FLUSH_COMMENT = '<!--qkssr-f-->';\n\n/**\n * @alpha\n */\nexport type StreamWriter = {\n  write: (chunk: string) => void;\n};\n\n/**\n * @alpha\n */\nexport interface RenderSSROptions {\n  containerTagName: string;\n  containerAttributes: Record<string, string>;\n  stream: StreamWriter;\n  base?: string;\n  envData?: Record<string, any>;\n  url?: string;\n  beforeContent?: JSXNode<string>[];\n  beforeClose?: (\n    contexts: QContext[],\n    containerState: ContainerState,\n    containsDynamic: boolean\n  ) => Promise<JSXNode>;\n}\n\nexport interface SSRContext {\n  $projectedCtxs$: [RenderContext, SSRContext] | undefined;\n  $projectedChildren$: Record<string, any[] | undefined> | undefined;\n  $invocationContext$: InvokeContext | undefined;\n  $static$: SSRContextStatic;\n}\n\nexport interface SSRContextStatic {\n  $locale$: string;\n  $contexts$: QContext[];\n  $dynamic$: boolean;\n  $headNodes$: JSXNode<string>[];\n}\n\nconst IS_HEAD = 1 << 0;\nconst IS_HTML = 1 << 2;\nconst IS_TEXT = 1 << 3;\nconst IS_INVISIBLE = 1 << 4;\nconst IS_PHASING = 1 << 5;\nconst IS_ANCHOR = 1 << 6;\nconst IS_BUTTON = 1 << 7;\n\nconst createDocument = () => {\n  const doc = { nodeType: 9 };\n  seal(doc);\n  return doc;\n};\n\n/**\n * @alpha\n */\nexport const renderSSR = async (node: JSXNode, opts: RenderSSROptions) => {\n  const root = opts.containerTagName;\n  const containerEl = createSSRContext(1).$element$;\n  const containerState = createContainerState(containerEl as Element, opts.base ?? '/');\n  containerState.$envData$.locale = opts.envData?.locale;\n  const doc = createDocument();\n  const rCtx = createRenderContext(doc as any, containerState);\n  const headNodes = opts.beforeContent ?? [];\n  const ssrCtx: SSRContext = {\n    $static$: {\n      $contexts$: [],\n      $dynamic$: false,\n      $headNodes$: root === 'html' ? headNodes : [],\n      $locale$: opts.envData?.locale,\n    },\n    $projectedChildren$: undefined,\n    $projectedCtxs$: undefined,\n    $invocationContext$: undefined,\n  };\n  seal(ssrCtx);\n\n  const containerAttributes: Record<string, any> = {\n    ...opts.containerAttributes,\n    'q:container': 'paused',\n    'q:version': version ?? 'dev',\n    'q:render': qDev ? 'ssr-dev' : 'ssr',\n    'q:base': opts.base,\n    'q:locale': opts.envData?.locale,\n    children: root === 'html' ? [node] : [headNodes, node],\n  };\n  if (root !== 'html') {\n    containerAttributes.class =\n      'qc\ud83d\udce6' + (containerAttributes.class ? ' ' + containerAttributes.class : '');\n  }\n  containerState.$envData$ = {\n    url: opts.url,\n    ...opts.envData,\n  };\n\n  node = jsx(root, containerAttributes);\n  containerState.$hostsRendering$ = new Set();\n  containerState.$renderPromise$ = Promise.resolve().then(() =>\n    renderRoot(node, rCtx, ssrCtx, opts.stream, containerState, opts)\n  );\n  await containerState.$renderPromise$;\n};\n\nconst renderRoot = async (\n  node: JSXNode,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  containerState: ContainerState,\n  opts: RenderSSROptions\n) => {\n  const beforeClose = opts.beforeClose;\n\n  await renderNode(\n    node,\n    rCtx,\n    ssrCtx,\n    stream,\n    0,\n    beforeClose\n      ? (stream: StreamWriter) => {\n          const result = beforeClose(\n            ssrCtx.$static$.$contexts$,\n            containerState,\n            ssrCtx.$static$.$dynamic$\n          );\n          return processData(result, rCtx, ssrCtx, stream, 0, undefined);\n        }\n      : undefined\n  );\n\n  if (qDev) {\n    if (ssrCtx.$static$.$headNodes$.length > 0) {\n      logError(\n        'Missing <head>. Global styles could not be rendered. Please render a <head> element at the root of the app'\n      );\n    }\n  }\n  return rCtx;\n};\n\nconst renderGenerator = async (\n  node: JSXNode<typeof InternalSSRStream>,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number\n) => {\n  stream.write(FLUSH_COMMENT);\n  const generator = node.props.children;\n  let value: AsyncGenerator;\n  if (isFunction(generator)) {\n    const v = generator({\n      write(chunk) {\n        stream.write(chunk);\n        stream.write(FLUSH_COMMENT);\n      },\n    });\n    if (isPromise(v)) {\n      return v;\n    }\n    value = v;\n  } else {\n    value = generator;\n  }\n  for await (const chunk of value) {\n    await processData(chunk, rCtx, ssrCtx, stream, flags, undefined);\n    stream.write(FLUSH_COMMENT);\n  }\n};\n\nconst renderNodeVirtual = (\n  node: JSXNode<typeof Virtual>,\n  elCtx: QContext,\n  extraNodes: JSXNode<string>[] | undefined,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n) => {\n  const props = node.props;\n  const renderQrl = props[OnRenderProp];\n  if (renderQrl) {\n    elCtx.$componentQrl$ = renderQrl;\n    return renderSSRComponent(rCtx, ssrCtx, stream, elCtx, node, flags, beforeClose);\n  }\n  let virtualComment = '<!--qv' + renderVirtualAttributes(props);\n  const isSlot = QSlotS in props;\n  const key = node.key != null ? String(node.key) : null;\n  if (isSlot) {\n    assertDefined(rCtx.$cmpCtx$?.$id$, 'hostId must be defined for a slot');\n    virtualComment += ' q:sref=' + rCtx.$cmpCtx$.$id$;\n  }\n  if (key != null) {\n    virtualComment += ' q:key=' + key;\n  }\n  virtualComment += '-->';\n  stream.write(virtualComment);\n\n  if (extraNodes) {\n    for (const node of extraNodes) {\n      renderNodeElementSync(node.type, node.props, stream);\n    }\n  }\n  const promise = walkChildren(props.children, rCtx, ssrCtx, stream, flags);\n  return then(promise, () => {\n    // Fast path\n    if (!isSlot && !beforeClose) {\n      stream.write(CLOSE_VIRTUAL);\n      return;\n    }\n\n    let promise: ValueOrPromise<void>;\n    if (isSlot) {\n      assertDefined(key, 'key must be defined for a slot');\n      const content = ssrCtx.$projectedChildren$?.[key];\n      if (content) {\n        const [rCtx, sCtx] = ssrCtx.$projectedCtxs$!;\n        const newSlotRctx = pushRenderContext(rCtx);\n        newSlotRctx.$slotCtx$ = elCtx;\n        ssrCtx.$projectedChildren$![key] = undefined;\n        promise = processData(content, newSlotRctx, sCtx, stream, flags);\n      }\n    }\n    // Inject before close\n    if (beforeClose) {\n      promise = then(promise, () => beforeClose(stream));\n    }\n\n    return then(promise, () => {\n      stream.write(CLOSE_VIRTUAL);\n    });\n  });\n};\n\nconst CLOSE_VIRTUAL = `<!--/qv-->`;\n\nconst renderAttributes = (attributes: Record<string, string>): string => {\n  let text = '';\n  for (const prop of Object.keys(attributes)) {\n    if (prop === 'dangerouslySetInnerHTML') {\n      continue;\n    }\n    const value = attributes[prop];\n    if (value != null) {\n      text += ' ' + (value === '' ? prop : prop + '=\"' + value + '\"');\n    }\n  }\n  return text;\n};\n\nconst renderVirtualAttributes = (attributes: Record<string, string>): string => {\n  let text = '';\n  for (const prop of Object.keys(attributes)) {\n    if (prop === 'children') {\n      continue;\n    }\n    const value = attributes[prop];\n    if (value != null) {\n      text += ' ' + (value === '' ? prop : prop + '=' + value + '');\n    }\n  }\n  return text;\n};\n\nconst renderNodeElementSync = (\n  tagName: string,\n  attributes: Record<string, string>,\n  stream: StreamWriter\n) => {\n  stream.write('<' + tagName + renderAttributes(attributes) + '>');\n  const empty = !!emptyElements[tagName];\n  if (empty) {\n    return;\n  }\n\n  // Render innerHTML\n  const innerHTML = attributes.dangerouslySetInnerHTML;\n  if (innerHTML != null) {\n    stream.write(innerHTML);\n  }\n  stream.write(`</${tagName}>`);\n};\n\nconst renderSSRComponent = (\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  elCtx: QContext,\n  node: JSXNode<typeof Virtual>,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n): ValueOrPromise<void> => {\n  const props = node.props;\n  setComponentProps(rCtx, elCtx, props.props);\n  return then(executeComponent(rCtx, elCtx), (res) => {\n    const hostElement = elCtx.$element$;\n    const newRCtx = res.rCtx;\n    const invocationContext = newInvokeContext(ssrCtx.$static$.$locale$, hostElement, undefined);\n    invocationContext.$subscriber$ = hostElement;\n    invocationContext.$renderCtx$ = newRCtx;\n    const newSSrContext: SSRContext = {\n      ...ssrCtx,\n      $projectedChildren$: splitProjectedChildren(props.children, ssrCtx),\n      $projectedCtxs$: [rCtx, ssrCtx],\n      $invocationContext$: invocationContext,\n    };\n\n    const extraNodes: JSXNode<string>[] = [];\n    if (elCtx.$appendStyles$) {\n      const isHTML = !!(flags & IS_HTML);\n      const array = isHTML ? ssrCtx.$static$.$headNodes$ : extraNodes;\n      for (const style of elCtx.$appendStyles$) {\n        array.push(\n          jsx('style', {\n            [QStyle]: style.styleId,\n            hidden: '',\n            dangerouslySetInnerHTML: style.content,\n          })\n        );\n      }\n    }\n    const newID = getNextIndex(rCtx);\n    const scopeId = elCtx.$scopeIds$ ? serializeSStyle(elCtx.$scopeIds$) : undefined;\n    const processedNode = jsx(\n      node.type,\n      {\n        [QScopedStyle]: scopeId,\n        [ELEMENT_ID]: newID,\n        children: res.node,\n      },\n      node.key\n    );\n\n    elCtx.$id$ = newID;\n    ssrCtx.$static$.$contexts$.push(elCtx);\n\n    return renderNodeVirtual(\n      processedNode,\n      elCtx,\n      extraNodes,\n      newRCtx,\n      newSSrContext,\n      stream,\n      flags,\n      (stream) => {\n        if (elCtx.$flags$ & HOST_FLAG_NEED_ATTACH_LISTENER) {\n          const placeholderCtx = createSSRContext(1);\n          const listeners = placeholderCtx.li;\n          listeners.push(...elCtx.li);\n          elCtx.$flags$ &= ~HOST_FLAG_NEED_ATTACH_LISTENER;\n          placeholderCtx.$id$ = getNextIndex(rCtx);\n          const attributes: Record<string, string> = {\n            type: 'placeholder',\n            hidden: '',\n            'q:id': placeholderCtx.$id$,\n          };\n          ssrCtx.$static$.$contexts$.push(placeholderCtx);\n\n          const groups = groupListeners(listeners);\n          for (const listener of groups) {\n            const eventName = normalizeInvisibleEvents(listener[0]);\n            attributes[eventName] = serializeQRLs(listener[1], placeholderCtx);\n            addQwikEvent(eventName, rCtx.$static$.$containerState$);\n          }\n          renderNodeElementSync('script', attributes, stream);\n          logWarn(`Component has listeners attached, but it does not render any elements, injecting a new <script> element to attach listeners.\n          This is likely to the usage of useClientEffect$() in a component that renders no elements.`);\n        }\n        if (beforeClose) {\n          return then(renderQTemplates(rCtx, newSSrContext, stream), () => beforeClose(stream));\n        } else {\n          return renderQTemplates(rCtx, newSSrContext, stream);\n        }\n      }\n    );\n  });\n};\n\nconst renderQTemplates = (rCtx: RenderContext, ssrContext: SSRContext, stream: StreamWriter) => {\n  const projectedChildren = ssrContext.$projectedChildren$;\n  if (projectedChildren) {\n    const nodes = Object.keys(projectedChildren).map((slotName) => {\n      const value = projectedChildren[slotName];\n      if (value) {\n        return jsx('q:template', {\n          [QSlot]: slotName,\n          hidden: '',\n          'aria-hidden': 'true',\n          children: value,\n        });\n      }\n    });\n    return processData(nodes, rCtx, ssrContext!, stream, 0, undefined);\n  }\n};\n\nconst splitProjectedChildren = (children: any, ssrCtx: SSRContext) => {\n  const flatChildren = flatVirtualChildren(children, ssrCtx);\n  if (flatChildren === null) {\n    return undefined;\n  }\n  const slotMap: Record<string, any[]> = {};\n\n  for (const child of flatChildren) {\n    let slotName = '';\n    if (isJSXNode(child)) {\n      slotName = child.props[QSlot] ?? '';\n    }\n    let array = slotMap[slotName];\n    if (!array) {\n      slotMap[slotName] = array = [];\n    }\n    array.push(child);\n  }\n  return slotMap;\n};\n\nconst createSSRContext = (nodeType: 1 | 111) => {\n  const elm = {\n    nodeType,\n    [Q_CTX]: null,\n  };\n  seal(elm);\n  return createContext(elm as any);\n};\n\nconst renderNode = (\n  node: JSXNode,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n) => {\n  const tagName = node.type;\n  const hostCtx = rCtx.$cmpCtx$;\n  const dynamicChildren = hasDynamicChildren(node);\n  if (dynamicChildren && hostCtx) {\n    hostCtx.$flags$ |= HOST_FLAG_DYNAMIC;\n    const slotCtx = rCtx.$slotCtx$;\n    if (slotCtx) {\n      addDynamicSlot(hostCtx, slotCtx);\n    }\n  }\n  if (typeof tagName === 'string') {\n    const key = node.key;\n    const props = node.props;\n    const immutableMeta: Record<string, boolean | Signal> = (props as any)[_IMMUTABLE] ?? EMPTY_OBJ;\n    const elCtx = createSSRContext(1);\n    const elm = elCtx.$element$;\n    const isHead = tagName === 'head';\n    let openingElement = '<' + tagName;\n    let useSignal = false;\n    let classStr = '';\n    let htmlStr = null;\n    assertElement(elm);\n    if (qDev && props.class && props.className) {\n      throw new TypeError('Can only have one of class or className');\n    }\n    for (const prop of Object.keys(props)) {\n      if (prop === 'children' || prop === 'dangerouslySetInnerHTML') {\n        continue;\n      }\n      if (prop === 'ref') {\n        setRef(props[prop], elm);\n        continue;\n      }\n      let value = isSignal(immutableMeta[prop]) ? immutableMeta[prop] : props[prop];\n      if (isOnProp(prop)) {\n        setEvent(elCtx.li, prop, value, undefined);\n        continue;\n      }\n      const attrName = processPropKey(prop);\n      if (isSignal(value)) {\n        if (hostCtx) {\n          const hostEl = hostCtx.$element$ as QwikElement;\n          addSignalSub(1, hostEl, value, elm, attrName);\n          useSignal = true;\n        }\n        value = value.value;\n      }\n      if (prop.startsWith(PREVENT_DEFAULT)) {\n        addQwikEvent(prop.slice(PREVENT_DEFAULT.length), rCtx.$static$.$containerState$);\n      }\n      const attrValue = processPropValue(attrName, value);\n      if (attrValue != null) {\n        if (attrName === 'class') {\n          classStr = attrValue;\n        } else if (attrName === 'value' && tagName === 'textarea') {\n          htmlStr = escapeHtml(attrValue);\n        } else {\n          openingElement +=\n            ' ' + (value === '' ? attrName : attrName + '=\"' + escapeAttr(attrValue) + '\"');\n        }\n      }\n    }\n    const listeners = elCtx.li;\n    if (hostCtx) {\n      if (qDev) {\n        if (tagName === 'html') {\n          throw qError(QError_canNotRenderHTML);\n        }\n      }\n      if (hostCtx.$scopeIds$?.length) {\n        const extra = hostCtx.$scopeIds$.join(' ');\n        classStr = classStr ? `${extra} ${classStr}` : extra;\n      }\n      if (hostCtx.$flags$ & HOST_FLAG_NEED_ATTACH_LISTENER) {\n        listeners.push(...hostCtx.li);\n        hostCtx.$flags$ &= ~HOST_FLAG_NEED_ATTACH_LISTENER;\n      }\n    }\n\n    // Reset HOST flags\n    if (qDev) {\n      if (flags & IS_PHASING) {\n        if (!phasingContent[tagName]) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because one of its ancestor is a <p> or a <pre>.\\n\nThis goes against the HTML spec: https://html.spec.whatwg.org/multipage/dom.html#phrasing-content-2`,\n            node\n          );\n        }\n      }\n      if (tagName === 'button') {\n        if (flags & IS_BUTTON) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because one of its ancestor is already a <button>.\\n\nThis goes against the HTML spec: https://html.spec.whatwg.org/multipage/dom.html#interactive-content`,\n            node\n          );\n        } else {\n          flags |= IS_BUTTON;\n        }\n      }\n      if (tagName === 'a') {\n        if (flags & IS_ANCHOR) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because one of its ancestor is already a <a>.\\n\nThis goes against the HTML spec: https://html.spec.whatwg.org/multipage/dom.html#interactive-content`,\n            node\n          );\n        } else {\n          flags |= IS_ANCHOR;\n        }\n      }\n      if (flags & IS_HEAD) {\n        if (!headContent[tagName]) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because it's not a valid children of the <head> element. https://html.spec.whatwg.org/multipage/dom.html#metadata-content`,\n            node\n          );\n        }\n      }\n      if (flags & IS_HTML) {\n        if (!htmlContent[tagName]) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because it's not a valid direct children of the <html> element, only <head> and <body> are allowed.`,\n            node\n          );\n        }\n      }\n      if (startPhasingContent[tagName]) {\n        flags |= IS_PHASING;\n      }\n    }\n    if (isHead) {\n      flags |= IS_HEAD;\n    }\n    if (invisibleElements[tagName]) {\n      flags |= IS_INVISIBLE;\n    }\n    if (textOnlyElements[tagName]) {\n      flags |= IS_TEXT;\n    }\n\n    if (classStr) {\n      openingElement += ' class=\"' + classStr + '\"';\n    }\n\n    if (listeners.length > 0) {\n      const groups = groupListeners(listeners);\n      const isInvisible = (flags & IS_INVISIBLE) !== 0;\n      for (const listener of groups) {\n        const eventName = isInvisible ? normalizeInvisibleEvents(listener[0]) : listener[0];\n        openingElement += ' ' + eventName + '=\"' + serializeQRLs(listener[1], elCtx) + '\"';\n        addQwikEvent(eventName, rCtx.$static$.$containerState$);\n      }\n    }\n    if (key != null) {\n      openingElement += ' q:key=\"' + key + '\"';\n    }\n    if ('ref' in props || useSignal || listeners.length > 0) {\n      if ('ref' in props || useSignal || listenersNeedId(listeners)) {\n        const newID = getNextIndex(rCtx);\n        openingElement += ' q:id=\"' + newID + '\"';\n        elCtx.$id$ = newID;\n      }\n      ssrCtx.$static$.$contexts$.push(elCtx);\n    }\n    if (flags & IS_HEAD) {\n      openingElement += ' q:head';\n    }\n    if (qDev && qInspector && node.dev) {\n      const sanitizedFileName = node?.dev?.fileName?.replace(/\\\\/g, '/');\n      if (sanitizedFileName) {\n        openingElement += ` data-qwik-inspector=\"${encodeURIComponent(sanitizedFileName)}:${\n          node.dev.lineNumber\n        }:${node.dev.columnNumber}\"`;\n      }\n    }\n    openingElement += '>';\n    stream.write(openingElement);\n\n    if (emptyElements[tagName]) {\n      return;\n    }\n\n    const innerHTML = props.dangerouslySetInnerHTML ?? htmlStr;\n    if (innerHTML != null) {\n      stream.write(String(innerHTML));\n      stream.write(`</${tagName}>`);\n      return;\n    }\n    if (tagName === 'html') {\n      flags |= IS_HTML;\n    } else {\n      flags &= ~IS_HTML;\n    }\n\n    const promise = processData(props.children, rCtx, ssrCtx, stream, flags);\n    return then(promise, () => {\n      // If head inject base styles\n      if (isHead) {\n        for (const node of ssrCtx.$static$.$headNodes$) {\n          renderNodeElementSync(node.type, node.props, stream);\n        }\n        ssrCtx.$static$.$headNodes$.length = 0;\n      }\n      // Fast path\n      if (!beforeClose) {\n        stream.write(`</${tagName}>`);\n        return;\n      }\n\n      // Inject before close\n      return then(beforeClose(stream), () => {\n        stream.write(`</${tagName}>`);\n      });\n    });\n  }\n\n  if (tagName === Virtual) {\n    const elCtx = createSSRContext(111);\n    elCtx.$parent$ = rCtx.$cmpCtx$;\n    elCtx.$slotParent$ = rCtx.$slotCtx$;\n    if (dynamicChildren) {\n      if (hostCtx) {\n        addDynamicSlot(hostCtx, elCtx);\n      }\n    }\n    return renderNodeVirtual(\n      node as JSXNode<typeof Virtual>,\n      elCtx,\n      undefined,\n      rCtx,\n      ssrCtx,\n      stream,\n      flags,\n      beforeClose\n    );\n  }\n\n  if (tagName === SSRRaw) {\n    stream.write((node as JSXNode<typeof SSRRaw>).props.data);\n    return;\n  }\n  if (tagName === InternalSSRStream) {\n    return renderGenerator(node as JSXNode<typeof InternalSSRStream>, rCtx, ssrCtx, stream, flags);\n  }\n\n  if (tagName === SSRHint && (node as JSXNode<typeof SSRHint>).props.dynamic === true) {\n    ssrCtx.$static$.$dynamic$ = true;\n  }\n  const res = invoke(ssrCtx.$invocationContext$, tagName, node.props, node.key);\n  return processData(res, rCtx, ssrCtx, stream, flags, beforeClose);\n};\n\nconst processData = (\n  node: any,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n): ValueOrPromise<void> => {\n  if (node == null || typeof node === 'boolean') {\n    return;\n  }\n  if (isString(node) || typeof node === 'number') {\n    stream.write(escapeHtml(String(node)));\n  } else if (isJSXNode(node)) {\n    return renderNode(node, rCtx, ssrCtx, stream, flags, beforeClose);\n  } else if (isArray(node)) {\n    return walkChildren(node, rCtx, ssrCtx, stream, flags);\n  } else if (isSignal(node)) {\n    const insideText = flags & IS_TEXT;\n    const hostEl = rCtx.$cmpCtx$?.$element$ as QwikElement;\n    let value;\n    if (hostEl) {\n      if (!insideText) {\n        value = node.value;\n        const id = getNextIndex(rCtx);\n        addSignalSub(2, hostEl, node, '#' + id, 'data');\n        stream.write(`<!--t=${id}-->${escapeHtml(jsxToString(value))}<!---->`);\n        return;\n      } else {\n        value = invoke(ssrCtx.$invocationContext$, () => node.value);\n      }\n    }\n    stream.write(escapeHtml(jsxToString(value)));\n    return;\n  } else if (isPromise(node)) {\n    stream.write(FLUSH_COMMENT);\n    return node.then((node) => processData(node, rCtx, ssrCtx, stream, flags, beforeClose));\n  } else {\n    logWarn('A unsupported value was passed to the JSX, skipping render. Value:', node);\n  }\n};\n\nconst walkChildren = (\n  children: any,\n  rCtx: RenderContext,\n  ssrContext: SSRContext,\n  stream: StreamWriter,\n  flags: number\n): ValueOrPromise<void> => {\n  if (children == null) {\n    return;\n  }\n  if (!isArray(children)) {\n    return processData(children, rCtx, ssrContext, stream, flags);\n  }\n  if (children.length === 1) {\n    return processData(children[0], rCtx, ssrContext, stream, flags);\n  }\n  if (children.length === 0) {\n    return;\n  }\n\n  let currentIndex = 0;\n  const buffers: string[][] = [];\n  return children.reduce((prevPromise, child, index) => {\n    const buffer: string[] = [];\n    buffers.push(buffer);\n    const localStream: StreamWriter = prevPromise\n      ? {\n          write(chunk) {\n            if (currentIndex === index) {\n              stream.write(chunk);\n            } else {\n              buffer.push(chunk);\n            }\n          },\n        }\n      : stream;\n\n    const rendered = processData(child, rCtx, ssrContext, localStream, flags);\n    const next = () => {\n      currentIndex++;\n      if (buffers.length > currentIndex) {\n        buffers[currentIndex].forEach((chunk) => stream.write(chunk));\n      }\n    };\n    if (isPromise(rendered) && prevPromise) {\n      return Promise.all([rendered, prevPromise]).then(next);\n    } else if (isPromise(rendered)) {\n      return rendered.then(next);\n    } else if (prevPromise) {\n      return prevPromise.then(next);\n    } else {\n      currentIndex++;\n      return undefined;\n    }\n  }, undefined);\n};\n\nconst flatVirtualChildren = (children: any, ssrCtx: SSRContext): any[] | null => {\n  if (children == null) {\n    return null;\n  }\n  const result = _flatVirtualChildren(children, ssrCtx);\n  const nodes = isArray(result) ? result : [result];\n  if (nodes.length === 0) {\n    return null;\n  }\n  return nodes;\n};\n\nconst _flatVirtualChildren = (children: any, ssrCtx: SSRContext): any => {\n  if (children == null) {\n    return null;\n  }\n  if (isArray(children)) {\n    return children.flatMap((c) => _flatVirtualChildren(c, ssrCtx));\n  } else if (\n    isJSXNode(children) &&\n    isFunction(children.type) &&\n    children.type !== SSRRaw &&\n    children.type !== InternalSSRStream &&\n    children.type !== Virtual\n  ) {\n    const res = invoke(ssrCtx.$invocationContext$, children.type, children.props, children.key);\n    return flatVirtualChildren(res, ssrCtx);\n  }\n  return children;\n};\n\nconst setComponentProps = (\n  rCtx: RenderContext,\n  elCtx: QContext,\n  expectProps: Record<string, any>\n) => {\n  const keys = Object.keys(expectProps);\n  const target = createPropsState();\n\n  elCtx.$props$ = createProxy(target, rCtx.$static$.$containerState$);\n\n  if (keys.length === 0) {\n    return;\n  }\n  const immutableMeta = ((target as any)[_IMMUTABLE] =\n    (expectProps as any)[_IMMUTABLE] ?? EMPTY_OBJ);\n  for (const prop of keys) {\n    if (prop === 'children' || prop === QSlot) {\n      continue;\n    }\n    if (isSignal(immutableMeta[prop])) {\n      target[_IMMUTABLE_PREFIX + prop] = immutableMeta[prop];\n    } else {\n      target[prop] = expectProps[prop];\n    }\n  }\n};\n\nconst processPropKey = (prop: string) => {\n  if (prop === 'htmlFor') {\n    return 'for';\n  }\n  return prop;\n};\n\nconst processPropValue = (prop: string, value: any): string | null => {\n  if (prop === 'style') {\n    return stringifyStyle(value);\n  }\n  if (prop === 'class') {\n    return serializeClass(value);\n  }\n  if (isAriaAttribute(prop) || prop === 'draggable' || prop === 'spellcheck') {\n    return value != null ? String(value) : value;\n  }\n  if (value === false || value == null) {\n    return null;\n  }\n  if (value === true) {\n    return '';\n  }\n  return String(value);\n};\n\nconst invisibleElements: Record<string, true | undefined> = {\n  head: true,\n  style: true,\n  script: true,\n  link: true,\n  meta: true,\n};\n\nconst textOnlyElements: Record<string, true | undefined> = {\n  title: true,\n  style: true,\n  script: true,\n  noframes: true,\n  textarea: true,\n};\n\nconst emptyElements: Record<string, true | undefined> = {\n  area: true,\n  base: true,\n  basefont: true,\n  bgsound: true,\n  br: true,\n  col: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true,\n};\n\nconst startPhasingContent: Record<string, true | undefined> = {\n  p: true,\n  pre: true,\n};\n\nconst htmlContent: Record<string, true | undefined> = {\n  head: true,\n  body: true,\n};\n\nconst headContent: Record<string, true | undefined> = {\n  meta: true,\n  title: true,\n  link: true,\n  style: true,\n  script: true,\n  noscript: true,\n  template: true,\n  base: true,\n};\n\nconst phasingContent: Record<string, true | undefined> = {\n  a: true,\n  abbr: true,\n  audio: true,\n  b: true,\n  bdo: true,\n  br: true,\n  button: true,\n  canvas: true,\n  cite: true,\n  code: true,\n  command: true,\n  data: true,\n  datalist: true,\n  dfn: true,\n  em: true,\n  embed: true,\n  i: true,\n  iframe: true,\n  img: true,\n  input: true,\n  kbd: true,\n  keygen: true,\n  label: true,\n  mark: true,\n  math: true,\n  meter: true,\n  noscript: true,\n  object: true,\n  output: true,\n  picture: true,\n  progress: true,\n  q: true,\n  ruby: true,\n  s: true,\n  samp: true,\n  script: true,\n  select: true,\n  small: true,\n  span: true,\n  strong: true,\n  sub: true,\n  sup: true,\n  svg: true,\n  textarea: true,\n  time: true,\n  u: true,\n  var: true,\n  video: true,\n  wbr: true,\n};\n\nexport interface ServerDocument {\n  nodeType: 9;\n  parentElement: null;\n  ownerDocument: null;\n  createElement(tagName: string): any;\n}\n\nconst ESCAPE_HTML = /[&<>]/g;\nconst ESCAPE_ATTRIBUTES = /[&\"]/g;\n\nconst escapeHtml = (s: string) => {\n  return s.replace(ESCAPE_HTML, (c) => {\n    switch (c) {\n      case '&':\n        return '&amp;';\n      case '<':\n        return '&lt;';\n      case '>':\n        return '&gt;';\n      default:\n        return '';\n    }\n  });\n};\n\nconst escapeAttr = (s: string) => {\n  return s.replace(ESCAPE_ATTRIBUTES, (c) => {\n    switch (c) {\n      case '&':\n        return '&amp;';\n      case '\"':\n        return '&quot;';\n      default:\n        return '';\n    }\n  });\n};\n\nconst listenersNeedId = (listeners: Listener[]) => {\n  return listeners.some((l) => l[1].$captureRef$ && l[1].$captureRef$.length > 0);\n};\n\nconst addDynamicSlot = (hostCtx: QContext, elCtx: QContext) => {\n  let dynamicSlots = hostCtx.$dynamicSlots$;\n  if (!dynamicSlots) {\n    hostCtx.$dynamicSlots$ = dynamicSlots = [];\n  }\n  if (!dynamicSlots.includes(elCtx)) {\n    dynamicSlots.push(elCtx);\n  }\n};\n\nconst normalizeInvisibleEvents = (eventName: string) => {\n  return eventName === 'on:qvisible' ? 'on-document:qinit' : eventName;\n};\n\nconst hasDynamicChildren = (node: JSXNode) => {\n  return (node.props as any)[_IMMUTABLE]?.children === false;\n};\n", "import type { JSXNode } from '@builder.io/qwik/jsx-runtime';\nimport { suite } from 'uvu';\nimport { equal, snapshot, unreachable, match } from 'uvu/assert';\nimport { format } from 'prettier';\n\nimport type { StreamWriter } from '../../../server/types';\nimport { component$ } from '../../component/component.public';\nimport { inlinedQrl } from '../../qrl/qrl';\nimport { $ } from '../../qrl/qrl.public';\nimport { createContext, useContext, useContextProvider } from '../../use/use-context';\nimport { useOn, useOnDocument, useOnWindow } from '../../use/use-on';\nimport { Ref, useRef } from '../../use/use-ref';\nimport { Resource, useResource$ } from '../../use/use-resource';\nimport { useStylesScopedQrl, useStylesQrl } from '../../use/use-styles';\nimport { useClientEffect$, useTask$ } from '../../use/use-task';\nimport { delay } from '../../util/promises';\nimport { SSRComment } from '../jsx/utils.public';\nimport { Slot } from '../jsx/slot.public';\nimport { jsx } from '../jsx/jsx-runtime';\nimport { renderSSR, RenderSSROptions } from './render-ssr';\nimport { useStore } from '../../use/use-store.public';\nimport { useSignal } from '../../use/use-signal';\n\nconst renderSSRSuite = suite('renderSSR');\nrenderSSRSuite('render attributes', async () => {\n  await testSSR(\n    <body id=\"stuff\" aria-required=\"true\" role=\"\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body id=\"stuff\" aria-required=\"true\" role></body></html>'\n  );\n});\n\nrenderSSRSuite('render aria value', async () => {\n  await testSSR(\n    <body\n      id=\"stuff\"\n      aria-required={true}\n      aria-busy={false}\n      role=\"\"\n      preventdefault:click\n      aria-hidden={undefined}\n    ></body>,\n    `\n        <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n          <body id=\"stuff\" aria-required=\"true\" aria-busy=\"false\" role preventdefault:click=\"\"></body>\n        </html>\n        `\n  );\n});\n\nrenderSSRSuite('render className', async () => {\n  await testSSR(\n    <body className=\"stuff\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body class=\"stuff\"></body></html>'\n  );\n});\n\nrenderSSRSuite('should not allow div inside p', async () => {\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <p>\n          <div></div>\n        </p>\n      </body>,\n      ''\n    );\n  });\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <p>\n          <span>\n            <div></div>\n          </span>\n        </p>\n      </body>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('should not allow button inside button', async () => {\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <button>\n          <button></button>\n        </button>\n      </body>,\n      ''\n    );\n  });\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <button>\n          <span>\n            <button></button>\n          </span>\n        </button>\n      </body>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('should not allow a inside a', async () => {\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <a>\n          <a></a>\n        </a>\n      </body>,\n      ''\n    );\n  });\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <a>\n          <span>\n            <a></a>\n          </span>\n        </a>\n      </body>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('should not allow div inside html', async () => {\n  await throws(async () => {\n    await testSSR(<div></div>, '');\n  });\n});\n\nrenderSSRSuite('should not allow div inside head', async () => {\n  await throws(async () => {\n    await testSSR(\n      <head>\n        <div></div>\n      </head>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('render class', async () => {\n  await testSSR(\n    <body\n      class={{\n        stuff: true,\n        other: false,\n        'm-0 p-2': true,\n      }}\n    ></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body class=\"stuff m-0 p-2\"></body></html>'\n  );\n\n  const Test = component$(() => {\n    // Extra spaces to ensure signal hasn't changed\n    const sigClass = useSignal(' myClass ');\n    return <div class={sigClass} />;\n  });\n  await testSSR(\n    <body>\n      <Test />\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        <div class=\"myClass\" q:id=\"1\"></div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n\n  await testSSR(\n    <body\n      class={['stuff', '', 'm-0 p-2', null, { active: 1 }, undefined, [{ container: 'yup' }]]}\n    ></body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body class=\"stuff m-0 p-2 active container\"></body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('render contentEditable', async () => {\n  await testSSR(\n    <body contentEditable=\"true\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body contentEditable=\"true\"></body></html>'\n  );\n});\n\nrenderSSRSuite('render draggable', async () => {\n  await testSSR(\n    <body>\n      <div draggable={true}></div>\n      <div draggable={false}></div>\n      <div draggable={undefined}></div>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <div draggable=\"true\"></div>\n        <div draggable=\"false\"></div>\n        <div></div>\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('render <textarea>', async () => {\n  await testSSR(\n    <body>\n      <textarea value=\"some text\"></textarea>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <textarea>some text</textarea>\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('render spellcheck', async () => {\n  await testSSR(\n    <body>\n      <div spellcheck={true}></div>\n      <div spellcheck={false}></div>\n      <div spellcheck={undefined}></div>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <div spellcheck=\"true\"></div>\n        <div spellcheck=\"false\"></div>\n        <div></div>\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('render styles', async () => {\n  await testSSR(\n    <body\n      style={{\n        'padding-top': '10px',\n        paddingBottom: '10px',\n        top: 0,\n        '--stuff-nu': -1,\n        '--stuff-hey': 'hey',\n        '--stuffCase': 'foo',\n      }}\n    ></body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body style=\"\n          padding-top: 10px;\n          padding-bottom: 10px;\n          top: 0;\n          --stuff-nu: -1;\n          --stuff-hey: hey;\n          --stuffCase: foo;\n        \"\n      ></body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('render fake click handler', async () => {\n  const Div = 'body' as any;\n  await testSSR(\n    <Div on:click=\"true\" onScroll=\"text\"></Div>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body on:click=\"true\" onScroll=\"text\"></body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('self closing elements', async () => {\n  await testSSR(\n    <body>\n      <input></input>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <input>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('single simple children', async () => {\n  await testSSR(\n    <body>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body>hola</body></html>'\n  );\n  await testSSR(\n    <body>{0}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body>0</body></html>'\n  );\n  await testSSR(\n    <body>{true}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  await testSSR(\n    <body>{false}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  await testSSR(\n    <body>{null}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  await testSSR(\n    <body>{undefined}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n});\n\nrenderSSRSuite('events', async () => {\n  await testSSR(\n    <body onClick$={() => console.warn('hol')}>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body on:click=\"/runtimeQRL#_\">hola</body></html>'\n  );\n  await testSSR(\n    <body document:onClick$={() => console.warn('hol')}>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body on-document:click=\"/runtimeQRL#_\">hola</body></html>'\n  );\n  await testSSR(\n    <body window:onClick$={() => console.warn('hol')}>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body on-window:click=\"/runtimeQRL#_\">hola</body></html>'\n  );\n  await testSSR(\n    <body>\n      <input onInput$={() => console.warn('hol')} />\n    </body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><input on:input=\"/runtimeQRL#_\"></body></html>'\n  );\n});\n\nrenderSSRSuite('ref', async () => {\n  const ref = { current: undefined } as Ref<any>;\n  await testSSR(\n    <body ref={ref}></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body q:id=\"0\"></body></html>'\n  );\n});\nrenderSSRSuite('innerHTML', async () => {\n  await testSSR(\n    <body dangerouslySetInnerHTML=\"<p>hola</p>\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><p>hola</p></body></html>'\n  );\n  await testSSR(\n    <body dangerouslySetInnerHTML=\"\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  const Div = 'body' as any;\n  await testSSR(\n    <Div dangerouslySetInnerHTML={0}></Div>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body>0</body></html>'\n  );\n  await testSSR(\n    <body>\n      <script dangerouslySetInnerHTML=\"() => null\"></script>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <script>\n          () => null\n        </script>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('single complex children', async () => {\n  await testSSR(\n    <div>\n      <p>hola</p>\n    </div>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><div><p>hola</p></div></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n  await testSSR(\n    <div>\n      hola {2}\n      <p>hola</p>\n    </div>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><div>hola 2<p>hola</p></div></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('single multiple children', async () => {\n  await testSSR(\n    <ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n      <li>6</li>\n      <li>7</li>\n      <li>8</li>\n    </ul>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('sanitazion', async () => {\n  await testSSR(\n    <body>\n      <div>{`.rule > thing{}`}</div>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <div>.rule &gt; thing{}</div>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using fragment', async () => {\n  await testSSR(\n    <ul>\n      <>\n        <li>1</li>\n        <li>2</li>\n      </>\n      <li>3</li>\n      <>\n        <li>4</li>\n        <>\n          <li>5</li>\n          <>\n            <>\n              <li>6</li>\n            </>\n          </>\n        </>\n        <li>7</li>\n      </>\n      <li>8</li>\n    </ul>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using promises', async () => {\n  await testSSR(\n    <body>{Promise.resolve('hola')}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><!--qkssr-f-->hola</body></html>'\n  );\n  await testSSR(\n    <body>{Promise.resolve(<p>hola</p>)}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><!--qkssr-f--><p>hola</p></body></html>'\n  );\n\n  await testSSR(\n    <ul>\n      {Promise.resolve(<li>1</li>)}\n      <li>2</li>\n      {delay(100).then(() => (\n        <li>3</li>\n      ))}\n      {delay(10).then(() => (\n        <li>4</li>\n      ))}\n    </ul>,\n    [\n      '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">',\n      '<ul>',\n      '<!--qkssr-f-->',\n      '<li>',\n      '1',\n      '</li>',\n      '<li>',\n      '2',\n      '</li>',\n      '<!--qkssr-f-->',\n      '<li>',\n      '3',\n      '</li>',\n      '<!--qkssr-f-->',\n      '<li>',\n      '4',\n      '</li>',\n      '</ul>',\n      '</container>',\n    ],\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('mixed children', async () => {\n  await testSSR(\n    <ul>\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n      {Promise.resolve(<li>3</li>)}\n      <li>4</li>\n      {delay(100).then(() => (\n        <li>5</li>\n      ))}\n      {delay(10).then(() => (\n        <li>6</li>\n      ))}\n    </ul>,\n    `\n        <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n        <ul>\n        <li>0</li>\n        <li>1</li>\n        <li>2</li>\n        <!--qkssr-f-->\n        <li>3</li>\n        <li>4</li>\n        <!--qkssr-f-->\n        <li>5</li>\n        <!--qkssr-f-->\n        <li>6</li>\n        </ul>\n        </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('DelayResource', async () => {\n  await testSSR(\n    <body>\n      <ul>\n        <DelayResource text=\"thing\" delay={100} />\n        <DelayResource text=\"thing\" delay={10} />\n      </ul>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n    <body>\n      <ul>\n        <!--qv q:id=0 q:key=sX:-->\n          <style q:style=\"fio5tb-0\" hidden>.cmp {background: blue}</style>\n          <div class=\"cmp\"><!--qkssr-f--><span>thing</span></div>\n        <!--/qv-->\n        <!--qv q:id=1 q:key=sX:-->\n          <div class=\"cmp\"><!--qkssr-f--><span>thing</span></div>\n        <!--/qv-->\n      </ul>\n    </body>\n  </html>`\n  );\n});\n\nrenderSSRSuite('using promises with DelayResource', async () => {\n  await testSSR(\n    <body>\n      <ul>\n        {delay(10).then(() => (\n          <li>thing</li>\n        ))}\n        <DelayResource text=\"thing\" delay={500} />\n      </ul>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n      <ul>\n        <!--qkssr-f-->\n        <li>thing</li>\n        <!--qv q:id=0 q:key=sX:-->\n          <style q:style=\"fio5tb-0\" hidden>.cmp {background: blue}</style>\n          <div class=\"cmp\"><!--qkssr-f--><span>thing</span></div>\n        <!--/qv-->\n      </ul>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using component', async () => {\n  await testSSR(\n    <MyCmp />,\n    `<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <section><div>MyCmp{}</div></section>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using component with key', async () => {\n  await testSSR(\n    <body>\n      <MyCmp key=\"hola\" />\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:hola-->\n        <section><div>MyCmp{}</div></section>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using component props', async () => {\n  await testSSR(\n    <MyCmp\n      id=\"12\"\n      host:prop=\"attribute\"\n      innerHTML=\"123\"\n      dangerouslySetInnerHTML=\"432\"\n      onClick=\"lazy.js\"\n      prop=\"12\"\n      q:slot=\"name\"\n    >\n      stuff\n    </MyCmp>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <section>\n        <div>MyCmp{\"id\":\"12\",\"host:prop\":\"attribute\",\"innerHTML\":\"123\",\"dangerouslySetInnerHTML\":\"432\",\"onClick\":\"lazy.js\",\"prop\":\"12\"}</div>\n      </section>\n      <q:template q:slot hidden aria-hidden=\"true\">stuff</q:template>\n      <!--/qv-->\n    </container>\n    `,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using component project content', async () => {\n  await testSSR(\n    <MyCmp>\n      <div>slot</div>\n    </MyCmp>,\n    `\n  <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n    <!--qv q:id=0 q:key=sX:-->\n    <section><div>MyCmp{}</div></section>\n    <q:template q:slot hidden aria-hidden=\"true\"><div>slot</div></q:template>\n    <!--/qv-->\n  </container>\n`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using complex component', async () => {\n  await testSSR(\n    <body>\n      <MyCmpComplex></MyCmpComplex>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        <div on:click=\"/runtimeQRL#_\" q:id=\"1\">\n          <button on:click=\"/runtimeQRL#_\">Click</button>\n          <!--qv q:s q:sref=0 q:key=--><!--/qv-->\n        </div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using complex component with slot', async () => {\n  await testSSR(\n    <MyCmpComplex>Hola</MyCmpComplex>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <div on:click=\"/runtimeQRL#_\" q:id=\"1\">\n        <button on:click=\"/runtimeQRL#_\">Click</button>\n        <!--qv q:s q:sref=0 q:key=-->\n        Hola\n        <!--/qv-->\n      </div>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('<head>', async () => {\n  await testSSR(\n    <head>\n      <title>hola</title>\n      <>\n        <meta></meta>\n      </>\n    </head>,\n    `\n  <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n    <head q:head>\n      <title q:head>hola</title>\n      <meta q:head>\n    </head>\n  </html>`\n  );\n});\n\nrenderSSRSuite('named slots', async () => {\n  await testSSR(\n    <NamedSlot>\n      Text\n      <div q:slot=\"start\">START: 1</div>\n      <>\n        <div q:slot=\"end\">END: 1</div>\n        from\n        <div q:slot=\"start\">START: 2</div>\n      </>\n      <div q:slot=\"end\">END: 2</div>\n      default\n    </NamedSlot>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <div>\n        <!--qv q:s q:sref=0 q:key=start-->\n        <div q:slot=\"start\">START: 1</div>\n        <div q:slot=\"start\">START: 2</div>\n        <!--/qv-->\n        <div><!--qv q:s q:sref=0 q:key=-->Textfromdefault<!--/qv--></div>\n        <!--qv q:s q:sref=0 q:key=end-->\n        <div q:slot=\"end\">END: 1</div>\n        <div q:slot=\"end\">END: 2</div>\n        <!--/qv-->\n      </div>\n      <!--/qv-->\n    </container>\n`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('nested slots', async () => {\n  await testSSR(\n    <SimpleSlot name=\"root\">\n      <SimpleSlot name=\"level 1\">\n        <SimpleSlot name=\"level 2\">\n          BEFORE CONTENT\n          <div>Content</div>\n          AFTER CONTENT\n        </SimpleSlot>\n      </SimpleSlot>\n    </SimpleSlot>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n        <div id=\"root\">\n          Before root\n          <!--qv q:s q:sref=0 q:key=-->\n            <!--qv q:id=1 q:key=sX:-->\n            <div id=\"level 1\">\n              Before level 1\n              <!--qv q:s q:sref=1 q:key=-->\n                <!--qv q:id=2 q:key=sX:-->\n                  <div id=\"level 2\">\n                    Before level 2\n                    <!--qv q:s q:sref=2 q:key=-->\n                      BEFORE CONTENT\n                      <div>Content</div>\n                      AFTER CONTENT\n                    <!--/qv-->\n                    After level 2\n                  </div>\n                <!--/qv-->\n              <!--/qv-->\n              After level 1\n            </div>\n            <!--/qv-->\n          <!--/qv-->\n          After root\n        </div>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('mixes slots', async () => {\n  await testSSR(\n    <MixedSlot>Content</MixedSlot>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <!--qv q:id=1 q:key=sX:-->\n        <div id=\"1\">Before 1\n        <!--qv q:s q:sref=1 q:key=-->\n          <!--qv q:s q:sref=0 q:key=-->\n            Content\n          <!--/qv-->\n        <!--/qv-->\n        After 1\n      </div>\n      <!--/qv-->\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('component RenderSignals()', async () => {\n  await testSSR(\n    <RenderSignals />,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:id=0 q:key=sX:-->\n      <head q:head>\n        <title q:head>value</title>\n        <style q:head>\n          value\n        </style>\n        <script q:head>\n          value\n        </script>\n      </head>\n      <!--/qv-->\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useContextProvider()', async () => {\n  await testSSR(\n    <Context>\n      <ContextConsumer />\n    </Context>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:id=0 q:key=sX:-->\n        <!--qv q:s q:sref=0 q:key=-->\n          <!--qv q:id=1 q:key=sX:-->hello bye<!--/qv-->\n        <!--/qv-->\n        <!--qv q:id=2 q:key=sX:-->hello bye<!--/qv-->\n      <!--/qv-->\n    </html>`\n  );\n});\n\nrenderSSRSuite('component slotted context', async () => {\n  await testSSR(\n    <body>\n      <VariadicContext>\n        <ReadValue />\n        <ReadValue q:slot=\"start\" />\n        <ReadValue q:slot=\"end\" />\n      </VariadicContext>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        <!--qv q:id=1 q:key=sX:-->\n        <!--qv q:s q:sref=1 q:key=-->\n        <!--qv q:s q:sref=0 q:key=start-->\n        <!--qv q:id=2 q:key=sX:-->\n        <span>start</span>\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--qv q:id=3 q:key=sX:-->\n        <!--qv q:s q:sref=3 q:key=-->\n        <!--qv q:s q:sref=0 q:key=-->\n        <!--qv q:id=4 q:key=sX:-->\n        <span>default</span>\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--qv q:id=5 q:key=sX:-->\n        <!--qv q:s q:sref=5 q:key=-->\n        <!--qv q:s q:sref=0 q:key=end-->\n        <!--qv q:id=6 q:key=sX:-->\n        <span>end</span>\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useOn()', async () => {\n  await testSSR(\n    <body>\n      <Events />\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n      <!--qv q:id=0 q:key=sX:-->\n      <div on:click=\"/runtimeQRL#_\\n/runtimeQRL#_\" on-window:click=\"/runtimeQRL#_\" on-document:click=\"/runtimeQRL#_\"></div>\n      <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useStyles()', async () => {\n  await testSSR(\n    <>\n      <body>\n        <Styles />\n      </body>\n    </>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n          <style q:style=\"17nc-0\" hidden>.host {color: red}</style>\n          <div class=\"host\">\n            Text\n          </div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useStylesScoped()', async () => {\n  await testSSR(\n    <>\n      <body>\n        <ScopedStyles1>\n          <div>projected</div>\n        </ScopedStyles1>\n      </body>\n    </>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:sstyle=\u2b50\ufe0f1d-0 q:id=0 q:key=sX:-->\n        <style q:style=\"1d-0\" hidden>\n          .host.\u2b50\ufe0f1d-0 {\n            color: red;\n          }\n        </style>\n        <div class=\"\u2b50\ufe0f1d-0 host\">\n          <div class=\"\u2b50\ufe0f1d-0 div\">\n            Scoped1\n            <!--qv q:s q:sref=0 q:key=-->\n            <div>projected</div>\n            <!--/qv-->\n            <p class=\"\u2b50\ufe0f1d-0\">Que tal?</p>\n          </div>\n          <!--qv q:sstyle=\u2b50\ufe0ff0gmsw-0 q:id=1 q:key=sX:-->\n          <style q:style=\"f0gmsw-0\" hidden>\n            .host.\u2b50\ufe0ff0gmsw-0 {\n              color: blue;\n            }\n          </style>\n          <div class=\"\u2b50\ufe0ff0gmsw-0 host\">\n            <div class=\"\u2b50\ufe0ff0gmsw-0\">\n              Scoped2\n              <p class=\"\u2b50\ufe0ff0gmsw-0\">Bien</p>\n            </div>\n          </div>\n          <!--/qv-->\n          <!--qv q:sstyle=\u2b50\ufe0ff0gmsw-0 q:id=2 q:key=sX:-->\n          <div class=\"\u2b50\ufe0ff0gmsw-0 host\">\n            <div class=\"\u2b50\ufe0ff0gmsw-0\">\n              Scoped2\n              <p class=\"\u2b50\ufe0ff0gmsw-0\">Bien</p>\n            </div>\n          </div>\n          <!--/qv-->\n        </div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useStylesScoped() + slot', async () => {\n  await testSSR(\n    <>\n      <RootStyles></RootStyles>\n    </>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:sstyle=\u2b50\ufe0flkei4s-0 q:id=0 q:key=sX:-->\n      <body class=\"\u2b50\ufe0flkei4s-0\">\n        <!--qv q:sstyle=\u2b50\ufe0ftdblg1-0 q:id=1 q:key=sX:-->\n        <style q:style=\"tdblg1-0\" hidden>\n          .host.\u2b50\ufe0ftdblg1-0 {\n            background: green;\n          }\n        </style>\n        <div class=\"\u2b50\ufe0ftdblg1-0\">\n          <!--qv q:s q:sref=1 q:key=one-->\n          <div q:slot=\"one\" class=\"\u2b50\ufe0flkei4s-0\">One</div>\n          <!--/qv-->\n        </div>\n        <q:template q:slot=\"two\" hidden aria-hidden=\"true\" class=\"\u2b50\ufe0flkei4s-0\">\n          <div q:slot=\"two\" class=\"\u2b50\ufe0flkei4s-0\">Two</div>\n        </q:template>\n        <!--/qv-->\n      </body>\n      <!--/qv-->\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('component useClientEffect()', async () => {\n  await testSSR(\n    <UseClientEffect />,\n    `<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n        <div on:qvisible=\"/runtimeQRL#_[0]\n/runtimeQRL#_[1]\" q:id=\"1\"></div>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('component useClientEffect() without elements', async () => {\n  await testSSR(\n    <body>\n      <UseEmptyClientEffect />\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        Hola\n        <script type=\"placeholder\" hidden q:id=\"1\" on-document:qinit=\"/runtimeQRL#_[0]\\n/runtimeQRL#_[1]\"></script>\n        <!--/qv-->\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('component useClientEffect() inside <head>', async () => {\n  await testSSR(\n    <head>\n      <UseEmptyClientEffect />\n      <UseClientEffect as=\"style\" />\n    </head>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <head q:head>\n        <!--qv q:id=0 q:key=sX:-->\n        Hola\n        <script type=\"placeholder\" hidden q:id=\"1\" on-document:qinit=\"/runtimeQRL#_[0]\\n/runtimeQRL#_[1]\"></script>\n        <!--/qv-->\n        <!--qv q:id=2 q:key=sX:-->\n        <style on-document:qinit=\"/runtimeQRL#_[0]\\n/runtimeQRL#_[1]\" q:id=\"3\" q:head></style>\n        <!--/qv-->\n      </head>\n    </html>`\n  );\n});\n\nrenderSSRSuite('nested html', async () => {\n  await testSSR(\n    <>\n      <body></body>\n    </>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>`\n  );\n});\n\nrenderSSRSuite('root html component', async () => {\n  await testSSR(\n    <HeadCmp host:aria-hidden=\"true\">\n      <link></link>\n    </HeadCmp>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:id=0 q:key=sX:-->\n      <head on-document:qinit=\"/runtimeQRL#_[0]\" q:id=\"1\" q:head>\n        <title q:head>hola</title>\n        <!--qv q:s q:sref=0 q:key=-->\n        <link q:head />\n        <!--/qv-->\n      </head>\n      <!--/qv-->\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('containerTagName', async () => {\n  await testSSR(\n    <>\n      <Styles />\n      <UseClientEffect></UseClientEffect>\n      <section></section>\n    </>,\n    `<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" q:base=\"/manu/folder\" class=\"qc\ud83d\udce6\">\n      <link rel=\"stylesheet\" href=\"/global.css\">\n      <!--qv q:id=0 q:key=sX:-->\n        <style q:style=\"17nc-0\" hidden>.host {color: red}</style>\n        <div class=\"host\">Text</div>\n      <!--/qv-->\n      <!--qv q:id=1 q:key=sX:-->\n        <div on:qvisible=\"/runtimeQRL#_[0]\n/runtimeQRL#_[1]\" q:id=\"2\"></div>\n      <!--/qv-->\n      <section></section>\n    </container>`,\n    {\n      containerTagName: 'container',\n      base: '/manu/folder',\n      beforeContent: [jsx('link', { rel: 'stylesheet', href: '/global.css' })],\n    }\n  );\n});\n\nrenderSSRSuite('containerAttributes', async () => {\n  await testSSR(\n    <>\n      <body></body>\n    </>,\n    `\n    <html prefix=\"something\" q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n     <body></body>\n    </html>\n    `,\n    {\n      containerAttributes: {\n        prefix: 'something',\n      },\n    }\n  );\n  await testSSR(\n    <>\n      <div></div>\n    </>,\n    `\n    <app prefix=\"something\" q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class='qc\ud83d\udce6 thing'>\n     <div></div>\n    </app>\n    `,\n    {\n      containerTagName: 'app',\n      containerAttributes: {\n        prefix: 'something',\n        class: 'thing',\n      },\n    }\n  );\n});\n\nrenderSSRSuite('ssr marks', async () => {\n  await testSSR(\n    <body>\n      {delay(100).then(() => (\n        <li>1</li>\n      ))}\n      {delay(10).then(() => (\n        <li>2</li>\n      ))}\n      <SSRComment data=\"here\" />\n      <div>\n        <SSRComment data=\"i am\" />\n      </div>\n      {delay(120).then(() => (\n        <li>3</li>\n      ))}\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qkssr-f-->\n        <li>1</li>\n        <!--qkssr-f-->\n        <li>2</li>\n        <!--here-->\n        <div>\n          <!--i am-->\n        </div>\n        <!--qkssr-f-->\n        <li>3</li>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('html slot', async () => {\n  await testSSR(\n    <HtmlContext>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <title>Qwik</title>\n      </head>\n      <body>\n        <div></div>\n      </body>\n    </HtmlContext>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" q:base=\"/manu/folder\">\n      <!--qv q:id=0 q:key=sX:-->\n      <!--qv q:s q:sref=0 q:key=-->\n      <head q:head>\n        <meta charset=\"utf-8\" q:head />\n        <title q:head>Qwik</title>\n        <link rel=\"stylesheet\" href=\"/global.css\" />\n        <style q:style=\"fio5tb-1\" hidden>\n          body {\n            background: blue;\n          }\n        </style>\n      </head>\n      <body>\n        <div></div>\n      </body>\n      <!--/qv-->\n      <!--/qv-->\n    </html>`,\n    {\n      beforeContent: [jsx('link', { rel: 'stylesheet', href: '/global.css' })],\n      base: '/manu/folder',\n    }\n  );\n});\n\nrenderSSRSuite('null component', async () => {\n  await testSSR(\n    <>\n      <NullCmp />\n    </>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><!--qv q:id=0 q:key=sX:--><!--/qv--></html>`\n  );\n});\n// TODO\n// Merge props on host\n// - host events\n// - class\n// - style\n// Container with tagName\n// End-to-end with qwikcity\n// SVG rendering\n// Performance metrics\n\nrenderSSRSuite.run();\n\nexport const MyCmp = component$((props: Record<string, any>) => {\n  return (\n    <section>\n      <div>\n        MyCmp\n        {JSON.stringify(props)}\n      </div>\n    </section>\n  );\n});\n\nexport const MyCmpComplex = component$(() => {\n  const ref = useRef();\n  return (\n    <div ref={ref} onClick$={() => console.warn('from component')}>\n      <button onClick$={() => console.warn('click')}>Click</button>\n      <Slot></Slot>\n    </div>\n  );\n});\n\nexport const SimpleSlot = component$((props: { name: string }) => {\n  return (\n    <div id={props.name}>\n      Before {props.name}\n      <Slot></Slot>\n      After {props.name}\n    </div>\n  );\n});\n\nexport const MixedSlot = component$(() => {\n  return (\n    <SimpleSlot name=\"1\">\n      <Slot />\n    </SimpleSlot>\n  );\n});\n\nexport const NamedSlot = component$(() => {\n  return (\n    <div>\n      <Slot name=\"start\" />\n      <div>\n        <Slot></Slot>\n      </div>\n      <Slot name=\"end\" />\n    </div>\n  );\n});\n\nexport const Events = component$(() => {\n  useOn(\n    'click',\n    $(() => console.warn('click'))\n  );\n  useOnWindow(\n    'click',\n    $(() => console.warn('window:click'))\n  );\n  useOnDocument(\n    'click',\n    $(() => console.warn('document:click'))\n  );\n\n  return <div onClick$={() => console.warn('scroll')}></div>;\n});\n\nexport const Styles = component$(() => {\n  useStylesQrl(inlinedQrl('.host {color: red}', 'styles_987'));\n\n  return <div class=\"host\">Text</div>;\n});\n\nexport const ScopedStyles1 = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {color: red}', 'styles_scoped_1'));\n\n  return (\n    <div class=\"host\">\n      <div className=\"div\">\n        Scoped1\n        <Slot></Slot>\n        <p>Que tal?</p>\n      </div>\n      <ScopedStyles2 />\n      <ScopedStyles2 />\n    </div>\n  );\n});\n\nexport const ScopedStyles2 = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {color: blue}', '20_styles_scoped'));\n\n  return (\n    <div class=\"host\">\n      <div>\n        Scoped2\n        <p>Bien</p>\n      </div>\n    </div>\n  );\n});\n\nexport const RootStyles = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {background: blue}', '20_stylesscopedblue'));\n\n  return (\n    <body>\n      <ComponentA>\n        <div q:slot=\"one\">One</div>\n        <div q:slot=\"two\">Two</div>\n      </ComponentA>\n    </body>\n  );\n});\n\nexport const ComponentA = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {background: green}', '20_stylesscopedgreen'));\n\n  return (\n    <div>\n      <Slot name=\"one\" />\n    </div>\n  );\n});\n\nconst CTX_INTERNAL = createContext<{ value: string }>('internal');\nconst CTX_QWIK_CITY = createContext<{ value: string }>('qwikcity');\nconst CTX_VALUE = createContext<{ value: string }>('value');\n\nexport const VariadicContext = component$(() => {\n  return (\n    <>\n      <ContextWithValue value=\"start\">\n        <Slot name=\"start\"></Slot>\n      </ContextWithValue>\n      <ContextWithValue value=\"default\">\n        <Slot></Slot>\n      </ContextWithValue>\n      <ContextWithValue value=\"end\">\n        <Slot name=\"end\"></Slot>\n      </ContextWithValue>\n    </>\n  );\n});\n\nexport const ReadValue = component$(() => {\n  const ctx = useContext(CTX_VALUE);\n  return <span>{ctx.value}</span>;\n});\n\nexport const ContextWithValue = component$((props: { value: string }) => {\n  const value = {\n    value: props.value,\n  };\n  useContextProvider(CTX_VALUE, value);\n  return (\n    <>\n      <Slot />\n    </>\n  );\n});\n\nexport const Context = component$(() => {\n  useContextProvider(CTX_INTERNAL, {\n    value: 'hello',\n  });\n  useContextProvider(CTX_QWIK_CITY, {\n    value: 'bye',\n  });\n  return (\n    <>\n      <Slot />\n      <ContextConsumer />\n    </>\n  );\n});\n\nexport const ContextConsumer = component$(() => {\n  const internal = useContext(CTX_INTERNAL);\n  const qwikCity = useContext(CTX_QWIK_CITY);\n\n  return (\n    <>\n      {internal.value} {qwikCity.value}\n    </>\n  );\n});\n\nexport const UseClientEffect = component$((props: any) => {\n  useClientEffect$(() => {\n    console.warn('client effect');\n  });\n  useClientEffect$(() => {\n    console.warn('second client effect');\n  });\n  useTask$(async () => {\n    await delay(10);\n  });\n\n  const Div = props.as ?? 'div';\n  return <Div />;\n});\n\nexport const UseEmptyClientEffect = component$(() => {\n  useClientEffect$(() => {\n    console.warn('client effect');\n  });\n  useClientEffect$(() => {\n    console.warn('second client effect');\n  });\n  useTask$(async () => {\n    await delay(10);\n  });\n\n  return <>Hola</>;\n});\n\nexport const HeadCmp = component$(() => {\n  useClientEffect$(() => {\n    console.warn('client effect');\n  });\n  return (\n    <head>\n      <title>hola</title>\n      <Slot></Slot>\n    </head>\n  );\n});\n\nexport const RenderSignals = component$(() => {\n  const signal = useSignal('value');\n  return (\n    <>\n      <head>\n        <title>{signal.value}</title>\n        <style>{signal.value}</style>\n        <script>{signal.value}</script>\n      </head>\n    </>\n  );\n});\n\nexport const HtmlContext = component$(() => {\n  const store = useStore({});\n  useStylesQrl(inlinedQrl(`body {background: blue}`, 'styles_DelayResource'));\n  useContextProvider(CTX_INTERNAL, store);\n\n  return <Slot />;\n});\n\nasync function testSSR(\n  node: JSXNode,\n  expected: string | string[],\n  opts?: Partial<RenderSSROptions>\n) {\n  const chunks: string[] = [];\n  const stream: StreamWriter = {\n    write(chunk) {\n      chunks.push(chunk);\n    },\n  };\n  await renderSSR(node, {\n    stream,\n    containerTagName: 'html',\n    containerAttributes: {},\n    ...opts,\n  });\n  if (typeof expected === 'string') {\n    const options = { parser: 'html', htmlWhitespaceSensitivity: 'ignore' } as const;\n    snapshot(\n      format(chunks.join(''), options),\n      format(expected.replace(/(\\n|^)\\s+/gm, ''), options)\n    );\n  } else {\n    equal(chunks, expected);\n  }\n}\n\nexport const DelayResource = component$((props: { text: string; delay: number }) => {\n  useStylesQrl(inlinedQrl(`.cmp {background: blue}`, 'styles_DelayResource'));\n\n  const resource = useResource$<string>(async ({ track }) => {\n    track(props, 'text');\n    await delay(props.delay);\n    return props.text;\n  });\n  return (\n    <div class=\"cmp\">\n      <Resource value={resource} onResolved={(value) => <span>{value}</span>} />\n    </div>\n  );\n});\n\nexport const NullCmp = component$(() => {\n  return null;\n});\n\nexport const EffectTransparent = component$(() => {\n  useClientEffect$(() => {\n    console.warn('log');\n  });\n  return <Slot />;\n});\n\nexport const EffectTransparentRoot = component$(() => {\n  useClientEffect$(() => {\n    console.warn('log');\n  });\n  return (\n    <EffectTransparent>\n      <section>Hello</section>\n    </EffectTransparent>\n  );\n});\n\nasync function throws<T>(fn: () => T, expected?: string | RegExp): Promise<void> {\n  try {\n    await fn();\n    unreachable('Expression should throw');\n  } catch (e) {\n    if (expected) {\n      match(String(e), expected);\n    }\n  }\n}\n"], "fixing_code": ["import { isPromise, then } from '../../util/promises';\nimport { InvokeContext, newInvokeContext, invoke } from '../../use/use-core';\nimport { createJSXError, isJSXNode, jsx } from '../jsx/jsx-runtime';\nimport { isArray, isFunction, isString, ValueOrPromise } from '../../util/types';\nimport type { JSXNode } from '../jsx/types/jsx-node';\nimport {\n  createRenderContext,\n  executeComponent,\n  getNextIndex,\n  isAriaAttribute,\n  jsxToString,\n  pushRenderContext,\n  serializeClass,\n  stringifyStyle,\n} from '../execute-component';\nimport { ELEMENT_ID, OnRenderProp, QScopedStyle, QSlot, QSlotS, QStyle } from '../../util/markers';\nimport { InternalSSRStream, Virtual, SSRRaw, SSRHint } from '../jsx/utils.public';\nimport { logError, logWarn } from '../../util/log';\nimport {\n  groupListeners,\n  isOnProp,\n  Listener,\n  PREVENT_DEFAULT,\n  setEvent,\n} from '../../state/listeners';\nimport { version } from '../../version';\nimport {\n  addQwikEvent,\n  ContainerState,\n  createContainerState,\n  setRef,\n} from '../../container/container';\nimport type { RenderContext } from '../types';\nimport { assertDefined } from '../../error/assert';\nimport { serializeSStyle } from '../../style/qrl-styles';\nimport { qDev, qInspector, seal } from '../../util/qdev';\nimport { qError, QError_canNotRenderHTML } from '../../error/error';\nimport { addSignalSub, isSignal, Signal } from '../../state/signal';\nimport { serializeQRLs } from '../../qrl/qrl';\nimport type { QwikElement } from '../dom/virtual-element';\nimport { assertElement } from '../../util/element';\nimport { EMPTY_OBJ } from '../../util/flyweight';\nimport {\n  createContext,\n  HOST_FLAG_DYNAMIC,\n  HOST_FLAG_NEED_ATTACH_LISTENER,\n  QContext,\n  Q_CTX,\n} from '../../state/context';\nimport { createPropsState, createProxy } from '../../state/store';\nimport { _IMMUTABLE, _IMMUTABLE_PREFIX } from '../../state/constants';\n\nconst FLUSH_COMMENT = '<!--qkssr-f-->';\n\n/**\n * @alpha\n */\nexport type StreamWriter = {\n  write: (chunk: string) => void;\n};\n\n/**\n * @alpha\n */\nexport interface RenderSSROptions {\n  containerTagName: string;\n  containerAttributes: Record<string, string>;\n  stream: StreamWriter;\n  base?: string;\n  envData?: Record<string, any>;\n  url?: string;\n  beforeContent?: JSXNode<string>[];\n  beforeClose?: (\n    contexts: QContext[],\n    containerState: ContainerState,\n    containsDynamic: boolean\n  ) => Promise<JSXNode>;\n}\n\nexport interface SSRContext {\n  $projectedCtxs$: [RenderContext, SSRContext] | undefined;\n  $projectedChildren$: Record<string, any[] | undefined> | undefined;\n  $invocationContext$: InvokeContext | undefined;\n  $static$: SSRContextStatic;\n}\n\nexport interface SSRContextStatic {\n  $locale$: string;\n  $contexts$: QContext[];\n  $dynamic$: boolean;\n  $headNodes$: JSXNode<string>[];\n}\n\nconst IS_HEAD = 1 << 0;\nconst IS_HTML = 1 << 2;\nconst IS_TEXT = 1 << 3;\nconst IS_INVISIBLE = 1 << 4;\nconst IS_PHASING = 1 << 5;\nconst IS_ANCHOR = 1 << 6;\nconst IS_BUTTON = 1 << 7;\n\nconst createDocument = () => {\n  const doc = { nodeType: 9 };\n  seal(doc);\n  return doc;\n};\n\n/**\n * @alpha\n */\nexport const renderSSR = async (node: JSXNode, opts: RenderSSROptions) => {\n  const root = opts.containerTagName;\n  const containerEl = createSSRContext(1).$element$;\n  const containerState = createContainerState(containerEl as Element, opts.base ?? '/');\n  containerState.$envData$.locale = opts.envData?.locale;\n  const doc = createDocument();\n  const rCtx = createRenderContext(doc as any, containerState);\n  const headNodes = opts.beforeContent ?? [];\n  const ssrCtx: SSRContext = {\n    $static$: {\n      $contexts$: [],\n      $dynamic$: false,\n      $headNodes$: root === 'html' ? headNodes : [],\n      $locale$: opts.envData?.locale,\n    },\n    $projectedChildren$: undefined,\n    $projectedCtxs$: undefined,\n    $invocationContext$: undefined,\n  };\n  seal(ssrCtx);\n\n  const containerAttributes: Record<string, any> = {\n    ...opts.containerAttributes,\n    'q:container': 'paused',\n    'q:version': version ?? 'dev',\n    'q:render': qDev ? 'ssr-dev' : 'ssr',\n    'q:base': opts.base,\n    'q:locale': opts.envData?.locale,\n    children: root === 'html' ? [node] : [headNodes, node],\n  };\n  if (root !== 'html') {\n    containerAttributes.class =\n      'qc\ud83d\udce6' + (containerAttributes.class ? ' ' + containerAttributes.class : '');\n  }\n  containerState.$envData$ = {\n    url: opts.url,\n    ...opts.envData,\n  };\n\n  node = jsx(root, containerAttributes);\n  containerState.$hostsRendering$ = new Set();\n  containerState.$renderPromise$ = Promise.resolve().then(() =>\n    renderRoot(node, rCtx, ssrCtx, opts.stream, containerState, opts)\n  );\n  await containerState.$renderPromise$;\n};\n\nconst renderRoot = async (\n  node: JSXNode,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  containerState: ContainerState,\n  opts: RenderSSROptions\n) => {\n  const beforeClose = opts.beforeClose;\n\n  await renderNode(\n    node,\n    rCtx,\n    ssrCtx,\n    stream,\n    0,\n    beforeClose\n      ? (stream: StreamWriter) => {\n          const result = beforeClose(\n            ssrCtx.$static$.$contexts$,\n            containerState,\n            ssrCtx.$static$.$dynamic$\n          );\n          return processData(result, rCtx, ssrCtx, stream, 0, undefined);\n        }\n      : undefined\n  );\n\n  if (qDev) {\n    if (ssrCtx.$static$.$headNodes$.length > 0) {\n      logError(\n        'Missing <head>. Global styles could not be rendered. Please render a <head> element at the root of the app'\n      );\n    }\n  }\n  return rCtx;\n};\n\nconst renderGenerator = async (\n  node: JSXNode<typeof InternalSSRStream>,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number\n) => {\n  stream.write(FLUSH_COMMENT);\n  const generator = node.props.children;\n  let value: AsyncGenerator;\n  if (isFunction(generator)) {\n    const v = generator({\n      write(chunk) {\n        stream.write(chunk);\n        stream.write(FLUSH_COMMENT);\n      },\n    });\n    if (isPromise(v)) {\n      return v;\n    }\n    value = v;\n  } else {\n    value = generator;\n  }\n  for await (const chunk of value) {\n    await processData(chunk, rCtx, ssrCtx, stream, flags, undefined);\n    stream.write(FLUSH_COMMENT);\n  }\n};\n\nconst renderNodeVirtual = (\n  node: JSXNode<typeof Virtual>,\n  elCtx: QContext,\n  extraNodes: JSXNode<string>[] | undefined,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n) => {\n  const props = node.props;\n  const renderQrl = props[OnRenderProp];\n  if (renderQrl) {\n    elCtx.$componentQrl$ = renderQrl;\n    return renderSSRComponent(rCtx, ssrCtx, stream, elCtx, node, flags, beforeClose);\n  }\n  let virtualComment = '<!--qv' + renderVirtualAttributes(props);\n  const isSlot = QSlotS in props;\n  const key = node.key != null ? String(node.key) : null;\n  if (isSlot) {\n    assertDefined(rCtx.$cmpCtx$?.$id$, 'hostId must be defined for a slot');\n    virtualComment += ' q:sref=' + rCtx.$cmpCtx$.$id$;\n  }\n  if (key != null) {\n    virtualComment += ' q:key=' + key;\n  }\n  virtualComment += '-->';\n  stream.write(virtualComment);\n\n  if (extraNodes) {\n    for (const node of extraNodes) {\n      renderNodeElementSync(node.type, node.props, stream);\n    }\n  }\n  const promise = walkChildren(props.children, rCtx, ssrCtx, stream, flags);\n  return then(promise, () => {\n    // Fast path\n    if (!isSlot && !beforeClose) {\n      stream.write(CLOSE_VIRTUAL);\n      return;\n    }\n\n    let promise: ValueOrPromise<void>;\n    if (isSlot) {\n      assertDefined(key, 'key must be defined for a slot');\n      const content = ssrCtx.$projectedChildren$?.[key];\n      if (content) {\n        const [rCtx, sCtx] = ssrCtx.$projectedCtxs$!;\n        const newSlotRctx = pushRenderContext(rCtx);\n        newSlotRctx.$slotCtx$ = elCtx;\n        ssrCtx.$projectedChildren$![key] = undefined;\n        promise = processData(content, newSlotRctx, sCtx, stream, flags);\n      }\n    }\n    // Inject before close\n    if (beforeClose) {\n      promise = then(promise, () => beforeClose(stream));\n    }\n\n    return then(promise, () => {\n      stream.write(CLOSE_VIRTUAL);\n    });\n  });\n};\n\nconst CLOSE_VIRTUAL = `<!--/qv-->`;\n\nconst renderAttributes = (attributes: Record<string, string>): string => {\n  let text = '';\n  for (const prop of Object.keys(attributes)) {\n    if (prop === 'dangerouslySetInnerHTML') {\n      continue;\n    }\n    const value = attributes[prop];\n    if (value != null) {\n      text += ' ' + (value === '' ? prop : prop + '=\"' + value + '\"');\n    }\n  }\n  return text;\n};\n\nconst renderVirtualAttributes = (attributes: Record<string, string>): string => {\n  let text = '';\n  for (const prop of Object.keys(attributes)) {\n    if (prop === 'children') {\n      continue;\n    }\n    const value = attributes[prop];\n    if (value != null) {\n      text += ' ' + (value === '' ? prop : prop + '=' + value + '');\n    }\n  }\n  return text;\n};\n\nconst renderNodeElementSync = (\n  tagName: string,\n  attributes: Record<string, string>,\n  stream: StreamWriter\n) => {\n  stream.write('<' + tagName + renderAttributes(attributes) + '>');\n  const empty = !!emptyElements[tagName];\n  if (empty) {\n    return;\n  }\n\n  // Render innerHTML\n  const innerHTML = attributes.dangerouslySetInnerHTML;\n  if (innerHTML != null) {\n    stream.write(innerHTML);\n  }\n  stream.write(`</${tagName}>`);\n};\n\nconst renderSSRComponent = (\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  elCtx: QContext,\n  node: JSXNode<typeof Virtual>,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n): ValueOrPromise<void> => {\n  const props = node.props;\n  setComponentProps(rCtx, elCtx, props.props);\n  return then(executeComponent(rCtx, elCtx), (res) => {\n    const hostElement = elCtx.$element$;\n    const newRCtx = res.rCtx;\n    const invocationContext = newInvokeContext(ssrCtx.$static$.$locale$, hostElement, undefined);\n    invocationContext.$subscriber$ = hostElement;\n    invocationContext.$renderCtx$ = newRCtx;\n    const newSSrContext: SSRContext = {\n      ...ssrCtx,\n      $projectedChildren$: splitProjectedChildren(props.children, ssrCtx),\n      $projectedCtxs$: [rCtx, ssrCtx],\n      $invocationContext$: invocationContext,\n    };\n\n    const extraNodes: JSXNode<string>[] = [];\n    if (elCtx.$appendStyles$) {\n      const isHTML = !!(flags & IS_HTML);\n      const array = isHTML ? ssrCtx.$static$.$headNodes$ : extraNodes;\n      for (const style of elCtx.$appendStyles$) {\n        array.push(\n          jsx('style', {\n            [QStyle]: style.styleId,\n            hidden: '',\n            dangerouslySetInnerHTML: style.content,\n          })\n        );\n      }\n    }\n    const newID = getNextIndex(rCtx);\n    const scopeId = elCtx.$scopeIds$ ? serializeSStyle(elCtx.$scopeIds$) : undefined;\n    const processedNode = jsx(\n      node.type,\n      {\n        [QScopedStyle]: scopeId,\n        [ELEMENT_ID]: newID,\n        children: res.node,\n      },\n      node.key\n    );\n\n    elCtx.$id$ = newID;\n    ssrCtx.$static$.$contexts$.push(elCtx);\n\n    return renderNodeVirtual(\n      processedNode,\n      elCtx,\n      extraNodes,\n      newRCtx,\n      newSSrContext,\n      stream,\n      flags,\n      (stream) => {\n        if (elCtx.$flags$ & HOST_FLAG_NEED_ATTACH_LISTENER) {\n          const placeholderCtx = createSSRContext(1);\n          const listeners = placeholderCtx.li;\n          listeners.push(...elCtx.li);\n          elCtx.$flags$ &= ~HOST_FLAG_NEED_ATTACH_LISTENER;\n          placeholderCtx.$id$ = getNextIndex(rCtx);\n          const attributes: Record<string, string> = {\n            type: 'placeholder',\n            hidden: '',\n            'q:id': placeholderCtx.$id$,\n          };\n          ssrCtx.$static$.$contexts$.push(placeholderCtx);\n\n          const groups = groupListeners(listeners);\n          for (const listener of groups) {\n            const eventName = normalizeInvisibleEvents(listener[0]);\n            attributes[eventName] = serializeQRLs(listener[1], placeholderCtx);\n            addQwikEvent(eventName, rCtx.$static$.$containerState$);\n          }\n          renderNodeElementSync('script', attributes, stream);\n          logWarn(`Component has listeners attached, but it does not render any elements, injecting a new <script> element to attach listeners.\n          This is likely to the usage of useClientEffect$() in a component that renders no elements.`);\n        }\n        if (beforeClose) {\n          return then(renderQTemplates(rCtx, newSSrContext, stream), () => beforeClose(stream));\n        } else {\n          return renderQTemplates(rCtx, newSSrContext, stream);\n        }\n      }\n    );\n  });\n};\n\nconst renderQTemplates = (rCtx: RenderContext, ssrContext: SSRContext, stream: StreamWriter) => {\n  const projectedChildren = ssrContext.$projectedChildren$;\n  if (projectedChildren) {\n    const nodes = Object.keys(projectedChildren).map((slotName) => {\n      const value = projectedChildren[slotName];\n      if (value) {\n        return jsx('q:template', {\n          [QSlot]: slotName,\n          hidden: '',\n          'aria-hidden': 'true',\n          children: value,\n        });\n      }\n    });\n    return processData(nodes, rCtx, ssrContext!, stream, 0, undefined);\n  }\n};\n\nconst splitProjectedChildren = (children: any, ssrCtx: SSRContext) => {\n  const flatChildren = flatVirtualChildren(children, ssrCtx);\n  if (flatChildren === null) {\n    return undefined;\n  }\n  const slotMap: Record<string, any[]> = {};\n\n  for (const child of flatChildren) {\n    let slotName = '';\n    if (isJSXNode(child)) {\n      slotName = child.props[QSlot] ?? '';\n    }\n    let array = slotMap[slotName];\n    if (!array) {\n      slotMap[slotName] = array = [];\n    }\n    array.push(child);\n  }\n  return slotMap;\n};\n\nconst createSSRContext = (nodeType: 1 | 111) => {\n  const elm = {\n    nodeType,\n    [Q_CTX]: null,\n  };\n  seal(elm);\n  return createContext(elm as any);\n};\n\nconst renderNode = (\n  node: JSXNode,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n) => {\n  const tagName = node.type;\n  const hostCtx = rCtx.$cmpCtx$;\n  const dynamicChildren = hasDynamicChildren(node);\n  if (dynamicChildren && hostCtx) {\n    hostCtx.$flags$ |= HOST_FLAG_DYNAMIC;\n    const slotCtx = rCtx.$slotCtx$;\n    if (slotCtx) {\n      addDynamicSlot(hostCtx, slotCtx);\n    }\n  }\n  if (typeof tagName === 'string') {\n    const key = node.key;\n    const props = node.props;\n    const immutableMeta: Record<string, boolean | Signal> = (props as any)[_IMMUTABLE] ?? EMPTY_OBJ;\n    const elCtx = createSSRContext(1);\n    const elm = elCtx.$element$;\n    const isHead = tagName === 'head';\n    let openingElement = '<' + tagName;\n    let useSignal = false;\n    let classStr = '';\n    let htmlStr = null;\n    assertElement(elm);\n    if (qDev && props.class && props.className) {\n      throw new TypeError('Can only have one of class or className');\n    }\n    for (const prop of Object.keys(props)) {\n      if (prop === 'children' || prop === 'dangerouslySetInnerHTML') {\n        continue;\n      }\n      if (prop === 'ref') {\n        setRef(props[prop], elm);\n        continue;\n      }\n      let value = isSignal(immutableMeta[prop]) ? immutableMeta[prop] : props[prop];\n      if (isOnProp(prop)) {\n        setEvent(elCtx.li, prop, value, undefined);\n        continue;\n      }\n      const attrName = processPropKey(prop);\n      if (isSignal(value)) {\n        if (hostCtx) {\n          const hostEl = hostCtx.$element$ as QwikElement;\n          addSignalSub(1, hostEl, value, elm, attrName);\n          useSignal = true;\n        }\n        value = value.value;\n      }\n      if (prop.startsWith(PREVENT_DEFAULT)) {\n        addQwikEvent(prop.slice(PREVENT_DEFAULT.length), rCtx.$static$.$containerState$);\n      }\n      const attrValue = processPropValue(attrName, value);\n      if (attrValue != null) {\n        if (attrName === 'class') {\n          classStr = attrValue;\n        } else if (attrName === 'value' && tagName === 'textarea') {\n          htmlStr = escapeHtml(attrValue);\n        } else if (isSSRUnsafeAttr(attrName)) {\n          if (qDev) {\n            logError('Attribute value is unsafe for SSR');\n          }\n        } else {\n          openingElement +=\n            ' ' + (value === '' ? attrName : attrName + '=\"' + escapeAttr(attrValue) + '\"');\n        }\n      }\n    }\n    const listeners = elCtx.li;\n    if (hostCtx) {\n      if (qDev) {\n        if (tagName === 'html') {\n          throw qError(QError_canNotRenderHTML);\n        }\n      }\n      if (hostCtx.$scopeIds$?.length) {\n        const extra = hostCtx.$scopeIds$.join(' ');\n        classStr = classStr ? `${extra} ${classStr}` : extra;\n      }\n      if (hostCtx.$flags$ & HOST_FLAG_NEED_ATTACH_LISTENER) {\n        listeners.push(...hostCtx.li);\n        hostCtx.$flags$ &= ~HOST_FLAG_NEED_ATTACH_LISTENER;\n      }\n    }\n\n    // Reset HOST flags\n    if (qDev) {\n      if (flags & IS_PHASING) {\n        if (!phasingContent[tagName]) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because one of its ancestor is a <p> or a <pre>.\\n\nThis goes against the HTML spec: https://html.spec.whatwg.org/multipage/dom.html#phrasing-content-2`,\n            node\n          );\n        }\n      }\n      if (tagName === 'button') {\n        if (flags & IS_BUTTON) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because one of its ancestor is already a <button>.\\n\nThis goes against the HTML spec: https://html.spec.whatwg.org/multipage/dom.html#interactive-content`,\n            node\n          );\n        } else {\n          flags |= IS_BUTTON;\n        }\n      }\n      if (tagName === 'a') {\n        if (flags & IS_ANCHOR) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because one of its ancestor is already a <a>.\\n\nThis goes against the HTML spec: https://html.spec.whatwg.org/multipage/dom.html#interactive-content`,\n            node\n          );\n        } else {\n          flags |= IS_ANCHOR;\n        }\n      }\n      if (flags & IS_HEAD) {\n        if (!headContent[tagName]) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because it's not a valid children of the <head> element. https://html.spec.whatwg.org/multipage/dom.html#metadata-content`,\n            node\n          );\n        }\n      }\n      if (flags & IS_HTML) {\n        if (!htmlContent[tagName]) {\n          throw createJSXError(\n            `<${tagName}> can not be rendered because it's not a valid direct children of the <html> element, only <head> and <body> are allowed.`,\n            node\n          );\n        }\n      }\n      if (startPhasingContent[tagName]) {\n        flags |= IS_PHASING;\n      }\n    }\n    if (isHead) {\n      flags |= IS_HEAD;\n    }\n    if (invisibleElements[tagName]) {\n      flags |= IS_INVISIBLE;\n    }\n    if (textOnlyElements[tagName]) {\n      flags |= IS_TEXT;\n    }\n\n    if (classStr) {\n      openingElement += ' class=\"' + escapeAttr(classStr) + '\"';\n    }\n\n    if (listeners.length > 0) {\n      const groups = groupListeners(listeners);\n      const isInvisible = (flags & IS_INVISIBLE) !== 0;\n      for (const listener of groups) {\n        const eventName = isInvisible ? normalizeInvisibleEvents(listener[0]) : listener[0];\n        openingElement += ' ' + eventName + '=\"' + serializeQRLs(listener[1], elCtx) + '\"';\n        addQwikEvent(eventName, rCtx.$static$.$containerState$);\n      }\n    }\n    if (key != null) {\n      openingElement += ' q:key=\"' + key + '\"';\n    }\n    if ('ref' in props || useSignal || listeners.length > 0) {\n      if ('ref' in props || useSignal || listenersNeedId(listeners)) {\n        const newID = getNextIndex(rCtx);\n        openingElement += ' q:id=\"' + newID + '\"';\n        elCtx.$id$ = newID;\n      }\n      ssrCtx.$static$.$contexts$.push(elCtx);\n    }\n    if (flags & IS_HEAD) {\n      openingElement += ' q:head';\n    }\n    if (qDev && qInspector && node.dev) {\n      const sanitizedFileName = node?.dev?.fileName?.replace(/\\\\/g, '/');\n      if (sanitizedFileName) {\n        openingElement += ` data-qwik-inspector=\"${encodeURIComponent(sanitizedFileName)}:${\n          node.dev.lineNumber\n        }:${node.dev.columnNumber}\"`;\n      }\n    }\n    openingElement += '>';\n    stream.write(openingElement);\n\n    if (emptyElements[tagName]) {\n      return;\n    }\n\n    const innerHTML = props.dangerouslySetInnerHTML ?? htmlStr;\n    if (innerHTML != null) {\n      stream.write(String(innerHTML));\n      stream.write(`</${tagName}>`);\n      return;\n    }\n    if (tagName === 'html') {\n      flags |= IS_HTML;\n    } else {\n      flags &= ~IS_HTML;\n    }\n\n    const promise = processData(props.children, rCtx, ssrCtx, stream, flags);\n    return then(promise, () => {\n      // If head inject base styles\n      if (isHead) {\n        for (const node of ssrCtx.$static$.$headNodes$) {\n          renderNodeElementSync(node.type, node.props, stream);\n        }\n        ssrCtx.$static$.$headNodes$.length = 0;\n      }\n      // Fast path\n      if (!beforeClose) {\n        stream.write(`</${tagName}>`);\n        return;\n      }\n\n      // Inject before close\n      return then(beforeClose(stream), () => {\n        stream.write(`</${tagName}>`);\n      });\n    });\n  }\n\n  if (tagName === Virtual) {\n    const elCtx = createSSRContext(111);\n    elCtx.$parent$ = rCtx.$cmpCtx$;\n    elCtx.$slotParent$ = rCtx.$slotCtx$;\n    if (dynamicChildren) {\n      if (hostCtx) {\n        addDynamicSlot(hostCtx, elCtx);\n      }\n    }\n    return renderNodeVirtual(\n      node as JSXNode<typeof Virtual>,\n      elCtx,\n      undefined,\n      rCtx,\n      ssrCtx,\n      stream,\n      flags,\n      beforeClose\n    );\n  }\n\n  if (tagName === SSRRaw) {\n    stream.write((node as JSXNode<typeof SSRRaw>).props.data);\n    return;\n  }\n  if (tagName === InternalSSRStream) {\n    return renderGenerator(node as JSXNode<typeof InternalSSRStream>, rCtx, ssrCtx, stream, flags);\n  }\n\n  if (tagName === SSRHint && (node as JSXNode<typeof SSRHint>).props.dynamic === true) {\n    ssrCtx.$static$.$dynamic$ = true;\n  }\n  const res = invoke(ssrCtx.$invocationContext$, tagName, node.props, node.key);\n  return processData(res, rCtx, ssrCtx, stream, flags, beforeClose);\n};\n\nconst processData = (\n  node: any,\n  rCtx: RenderContext,\n  ssrCtx: SSRContext,\n  stream: StreamWriter,\n  flags: number,\n  beforeClose?: (stream: StreamWriter) => ValueOrPromise<void>\n): ValueOrPromise<void> => {\n  if (node == null || typeof node === 'boolean') {\n    return;\n  }\n  if (isString(node) || typeof node === 'number') {\n    stream.write(escapeHtml(String(node)));\n  } else if (isJSXNode(node)) {\n    return renderNode(node, rCtx, ssrCtx, stream, flags, beforeClose);\n  } else if (isArray(node)) {\n    return walkChildren(node, rCtx, ssrCtx, stream, flags);\n  } else if (isSignal(node)) {\n    const insideText = flags & IS_TEXT;\n    const hostEl = rCtx.$cmpCtx$?.$element$ as QwikElement;\n    let value;\n    if (hostEl) {\n      if (!insideText) {\n        value = node.value;\n        const id = getNextIndex(rCtx);\n        addSignalSub(2, hostEl, node, '#' + id, 'data');\n        stream.write(`<!--t=${id}-->${escapeHtml(jsxToString(value))}<!---->`);\n        return;\n      } else {\n        value = invoke(ssrCtx.$invocationContext$, () => node.value);\n      }\n    }\n    stream.write(escapeHtml(jsxToString(value)));\n    return;\n  } else if (isPromise(node)) {\n    stream.write(FLUSH_COMMENT);\n    return node.then((node) => processData(node, rCtx, ssrCtx, stream, flags, beforeClose));\n  } else {\n    logWarn('A unsupported value was passed to the JSX, skipping render. Value:', node);\n  }\n};\n\nconst walkChildren = (\n  children: any,\n  rCtx: RenderContext,\n  ssrContext: SSRContext,\n  stream: StreamWriter,\n  flags: number\n): ValueOrPromise<void> => {\n  if (children == null) {\n    return;\n  }\n  if (!isArray(children)) {\n    return processData(children, rCtx, ssrContext, stream, flags);\n  }\n  if (children.length === 1) {\n    return processData(children[0], rCtx, ssrContext, stream, flags);\n  }\n  if (children.length === 0) {\n    return;\n  }\n\n  let currentIndex = 0;\n  const buffers: string[][] = [];\n  return children.reduce((prevPromise, child, index) => {\n    const buffer: string[] = [];\n    buffers.push(buffer);\n    const localStream: StreamWriter = prevPromise\n      ? {\n          write(chunk) {\n            if (currentIndex === index) {\n              stream.write(chunk);\n            } else {\n              buffer.push(chunk);\n            }\n          },\n        }\n      : stream;\n\n    const rendered = processData(child, rCtx, ssrContext, localStream, flags);\n    const next = () => {\n      currentIndex++;\n      if (buffers.length > currentIndex) {\n        buffers[currentIndex].forEach((chunk) => stream.write(chunk));\n      }\n    };\n    if (isPromise(rendered) && prevPromise) {\n      return Promise.all([rendered, prevPromise]).then(next);\n    } else if (isPromise(rendered)) {\n      return rendered.then(next);\n    } else if (prevPromise) {\n      return prevPromise.then(next);\n    } else {\n      currentIndex++;\n      return undefined;\n    }\n  }, undefined);\n};\n\nconst flatVirtualChildren = (children: any, ssrCtx: SSRContext): any[] | null => {\n  if (children == null) {\n    return null;\n  }\n  const result = _flatVirtualChildren(children, ssrCtx);\n  const nodes = isArray(result) ? result : [result];\n  if (nodes.length === 0) {\n    return null;\n  }\n  return nodes;\n};\n\nconst _flatVirtualChildren = (children: any, ssrCtx: SSRContext): any => {\n  if (children == null) {\n    return null;\n  }\n  if (isArray(children)) {\n    return children.flatMap((c) => _flatVirtualChildren(c, ssrCtx));\n  } else if (\n    isJSXNode(children) &&\n    isFunction(children.type) &&\n    children.type !== SSRRaw &&\n    children.type !== InternalSSRStream &&\n    children.type !== Virtual\n  ) {\n    const res = invoke(ssrCtx.$invocationContext$, children.type, children.props, children.key);\n    return flatVirtualChildren(res, ssrCtx);\n  }\n  return children;\n};\n\nconst setComponentProps = (\n  rCtx: RenderContext,\n  elCtx: QContext,\n  expectProps: Record<string, any>\n) => {\n  const keys = Object.keys(expectProps);\n  const target = createPropsState();\n\n  elCtx.$props$ = createProxy(target, rCtx.$static$.$containerState$);\n\n  if (keys.length === 0) {\n    return;\n  }\n  const immutableMeta = ((target as any)[_IMMUTABLE] =\n    (expectProps as any)[_IMMUTABLE] ?? EMPTY_OBJ);\n  for (const prop of keys) {\n    if (prop === 'children' || prop === QSlot) {\n      continue;\n    }\n    if (isSignal(immutableMeta[prop])) {\n      target[_IMMUTABLE_PREFIX + prop] = immutableMeta[prop];\n    } else {\n      target[prop] = expectProps[prop];\n    }\n  }\n};\n\nconst processPropKey = (prop: string) => {\n  if (prop === 'htmlFor') {\n    return 'for';\n  }\n  return prop;\n};\n\nconst processPropValue = (prop: string, value: any): string | null => {\n  if (prop === 'style') {\n    return stringifyStyle(value);\n  }\n  if (prop === 'class') {\n    return serializeClass(value);\n  }\n  if (isAriaAttribute(prop) || prop === 'draggable' || prop === 'spellcheck') {\n    return value != null ? String(value) : value;\n  }\n  if (value === false || value == null) {\n    return null;\n  }\n  if (value === true) {\n    return '';\n  }\n  return String(value);\n};\n\nconst invisibleElements: Record<string, true | undefined> = {\n  head: true,\n  style: true,\n  script: true,\n  link: true,\n  meta: true,\n};\n\nconst textOnlyElements: Record<string, true | undefined> = {\n  title: true,\n  style: true,\n  script: true,\n  noframes: true,\n  textarea: true,\n};\n\nconst emptyElements: Record<string, true | undefined> = {\n  area: true,\n  base: true,\n  basefont: true,\n  bgsound: true,\n  br: true,\n  col: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true,\n};\n\nconst startPhasingContent: Record<string, true | undefined> = {\n  p: true,\n  pre: true,\n};\n\nconst htmlContent: Record<string, true | undefined> = {\n  head: true,\n  body: true,\n};\n\nconst headContent: Record<string, true | undefined> = {\n  meta: true,\n  title: true,\n  link: true,\n  style: true,\n  script: true,\n  noscript: true,\n  template: true,\n  base: true,\n};\n\nconst phasingContent: Record<string, true | undefined> = {\n  a: true,\n  abbr: true,\n  audio: true,\n  b: true,\n  bdo: true,\n  br: true,\n  button: true,\n  canvas: true,\n  cite: true,\n  code: true,\n  command: true,\n  data: true,\n  datalist: true,\n  dfn: true,\n  em: true,\n  embed: true,\n  i: true,\n  iframe: true,\n  img: true,\n  input: true,\n  kbd: true,\n  keygen: true,\n  label: true,\n  mark: true,\n  math: true,\n  meter: true,\n  noscript: true,\n  object: true,\n  output: true,\n  picture: true,\n  progress: true,\n  q: true,\n  ruby: true,\n  s: true,\n  samp: true,\n  script: true,\n  select: true,\n  small: true,\n  span: true,\n  strong: true,\n  sub: true,\n  sup: true,\n  svg: true,\n  textarea: true,\n  time: true,\n  u: true,\n  var: true,\n  video: true,\n  wbr: true,\n};\n\nexport interface ServerDocument {\n  nodeType: 9;\n  parentElement: null;\n  ownerDocument: null;\n  createElement(tagName: string): any;\n}\n\nconst ESCAPE_HTML = /[&<>]/g;\nconst ESCAPE_ATTRIBUTES = /[&\"]/g;\n\nconst escapeHtml = (s: string) => {\n  return s.replace(ESCAPE_HTML, (c) => {\n    switch (c) {\n      case '&':\n        return '&amp;';\n      case '<':\n        return '&lt;';\n      case '>':\n        return '&gt;';\n      default:\n        return '';\n    }\n  });\n};\n\nconst escapeAttr = (s: string) => {\n  return s.replace(ESCAPE_ATTRIBUTES, (c) => {\n    switch (c) {\n      case '&':\n        return '&amp;';\n      case '\"':\n        return '&quot;';\n      default:\n        return '';\n    }\n  });\n};\n\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/; // eslint-disable-line no-control-regex\nexport const isSSRUnsafeAttr = (name: string): boolean => {\n  return unsafeAttrCharRE.test(name);\n};\n\nconst listenersNeedId = (listeners: Listener[]) => {\n  return listeners.some((l) => l[1].$captureRef$ && l[1].$captureRef$.length > 0);\n};\n\nconst addDynamicSlot = (hostCtx: QContext, elCtx: QContext) => {\n  let dynamicSlots = hostCtx.$dynamicSlots$;\n  if (!dynamicSlots) {\n    hostCtx.$dynamicSlots$ = dynamicSlots = [];\n  }\n  if (!dynamicSlots.includes(elCtx)) {\n    dynamicSlots.push(elCtx);\n  }\n};\n\nconst normalizeInvisibleEvents = (eventName: string) => {\n  return eventName === 'on:qvisible' ? 'on-document:qinit' : eventName;\n};\n\nconst hasDynamicChildren = (node: JSXNode) => {\n  return (node.props as any)[_IMMUTABLE]?.children === false;\n};\n", "import type { JSXNode } from '@builder.io/qwik/jsx-runtime';\nimport { suite } from 'uvu';\nimport { equal, snapshot, unreachable, match } from 'uvu/assert';\nimport { format } from 'prettier';\n\nimport type { StreamWriter } from '../../../server/types';\nimport { component$ } from '../../component/component.public';\nimport { inlinedQrl } from '../../qrl/qrl';\nimport { $ } from '../../qrl/qrl.public';\nimport { createContext, useContext, useContextProvider } from '../../use/use-context';\nimport { useOn, useOnDocument, useOnWindow } from '../../use/use-on';\nimport { Ref, useRef } from '../../use/use-ref';\nimport { Resource, useResource$ } from '../../use/use-resource';\nimport { useStylesScopedQrl, useStylesQrl } from '../../use/use-styles';\nimport { useClientEffect$, useTask$ } from '../../use/use-task';\nimport { delay } from '../../util/promises';\nimport { SSRComment } from '../jsx/utils.public';\nimport { Slot } from '../jsx/slot.public';\nimport { jsx } from '../jsx/jsx-runtime';\nimport { renderSSR, RenderSSROptions } from './render-ssr';\nimport { useStore } from '../../use/use-store.public';\nimport { useSignal } from '../../use/use-signal';\n\nconst renderSSRSuite = suite('renderSSR');\nrenderSSRSuite('render attributes', async () => {\n  await testSSR(\n    <body id=\"stuff\" aria-required=\"true\" role=\"\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body id=\"stuff\" aria-required=\"true\" role></body></html>'\n  );\n});\n\nrenderSSRSuite('render aria value', async () => {\n  await testSSR(\n    <body\n      id=\"stuff\"\n      aria-required={true}\n      aria-busy={false}\n      role=\"\"\n      preventdefault:click\n      aria-hidden={undefined}\n    ></body>,\n    `\n        <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n          <body id=\"stuff\" aria-required=\"true\" aria-busy=\"false\" role preventdefault:click=\"\"></body>\n        </html>\n        `\n  );\n});\n\nrenderSSRSuite('render className', async () => {\n  await testSSR(\n    <body className=\"stuff\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body class=\"stuff\"></body></html>'\n  );\n});\n\nrenderSSRSuite('should not allow div inside p', async () => {\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <p>\n          <div></div>\n        </p>\n      </body>,\n      ''\n    );\n  });\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <p>\n          <span>\n            <div></div>\n          </span>\n        </p>\n      </body>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('should not allow button inside button', async () => {\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <button>\n          <button></button>\n        </button>\n      </body>,\n      ''\n    );\n  });\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <button>\n          <span>\n            <button></button>\n          </span>\n        </button>\n      </body>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('should not allow a inside a', async () => {\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <a>\n          <a></a>\n        </a>\n      </body>,\n      ''\n    );\n  });\n  await throws(async () => {\n    await testSSR(\n      <body>\n        <a>\n          <span>\n            <a></a>\n          </span>\n        </a>\n      </body>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('should not allow div inside html', async () => {\n  await throws(async () => {\n    await testSSR(<div></div>, '');\n  });\n});\n\nrenderSSRSuite('should not allow div inside head', async () => {\n  await throws(async () => {\n    await testSSR(\n      <head>\n        <div></div>\n      </head>,\n      ''\n    );\n  });\n});\n\nrenderSSRSuite('render class', async () => {\n  await testSSR(\n    <body\n      class={{\n        stuff: true,\n        other: false,\n        'm-0 p-2': true,\n      }}\n    ></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body class=\"stuff m-0 p-2\"></body></html>'\n  );\n\n  const Test = component$(() => {\n    // Extra spaces to ensure signal hasn't changed\n    const sigClass = useSignal(' myClass ');\n    return <div class={sigClass} />;\n  });\n  await testSSR(\n    <body>\n      <Test />\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        <div class=\"myClass\" q:id=\"1\"></div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n\n  await testSSR(\n    <body\n      class={['stuff', '', 'm-0 p-2', null, { active: 1 }, undefined, [{ container: 'yup' }]]}\n    ></body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body class=\"stuff m-0 p-2 active container\"></body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('render contentEditable', async () => {\n  await testSSR(\n    <body contentEditable=\"true\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body contentEditable=\"true\"></body></html>'\n  );\n});\n\nrenderSSRSuite('render draggable', async () => {\n  await testSSR(\n    <body>\n      <div draggable={true}></div>\n      <div draggable={false}></div>\n      <div draggable={undefined}></div>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <div draggable=\"true\"></div>\n        <div draggable=\"false\"></div>\n        <div></div>\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('render <textarea>', async () => {\n  await testSSR(\n    <body>\n      <textarea value=\"some text\"></textarea>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <textarea>some text</textarea>\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('render spellcheck', async () => {\n  await testSSR(\n    <body>\n      <div spellcheck={true}></div>\n      <div spellcheck={false}></div>\n      <div spellcheck={undefined}></div>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <div spellcheck=\"true\"></div>\n        <div spellcheck=\"false\"></div>\n        <div></div>\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('render styles', async () => {\n  await testSSR(\n    <body\n      style={{\n        'padding-top': '10px',\n        paddingBottom: '10px',\n        top: 0,\n        '--stuff-nu': -1,\n        '--stuff-hey': 'hey',\n        '--stuffCase': 'foo',\n      }}\n    ></body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body style=\"\n          padding-top: 10px;\n          padding-bottom: 10px;\n          top: 0;\n          --stuff-nu: -1;\n          --stuff-hey: hey;\n          --stuffCase: foo;\n        \"\n      ></body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('render fake click handler', async () => {\n  const Div = 'body' as any;\n  await testSSR(\n    <Div on:click=\"true\" onScroll=\"text\"></Div>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body on:click=\"true\" onScroll=\"text\"></body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('self closing elements', async () => {\n  await testSSR(\n    <body>\n      <input></input>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <input>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('single simple children', async () => {\n  await testSSR(\n    <body>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body>hola</body></html>'\n  );\n  await testSSR(\n    <body>{0}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body>0</body></html>'\n  );\n  await testSSR(\n    <body>{true}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  await testSSR(\n    <body>{false}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  await testSSR(\n    <body>{null}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  await testSSR(\n    <body>{undefined}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n});\n\nrenderSSRSuite('events', async () => {\n  await testSSR(\n    <body onClick$={() => console.warn('hol')}>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body on:click=\"/runtimeQRL#_\">hola</body></html>'\n  );\n  await testSSR(\n    <body document:onClick$={() => console.warn('hol')}>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body on-document:click=\"/runtimeQRL#_\">hola</body></html>'\n  );\n  await testSSR(\n    <body window:onClick$={() => console.warn('hol')}>hola</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body on-window:click=\"/runtimeQRL#_\">hola</body></html>'\n  );\n  await testSSR(\n    <body>\n      <input onInput$={() => console.warn('hol')} />\n    </body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><input on:input=\"/runtimeQRL#_\"></body></html>'\n  );\n});\n\nrenderSSRSuite('ref', async () => {\n  const ref = { current: undefined } as Ref<any>;\n  await testSSR(\n    <body ref={ref}></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body q:id=\"0\"></body></html>'\n  );\n});\nrenderSSRSuite('innerHTML', async () => {\n  await testSSR(\n    <body dangerouslySetInnerHTML=\"<p>hola</p>\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><p>hola</p></body></html>'\n  );\n  await testSSR(\n    <body dangerouslySetInnerHTML=\"\"></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n  const Div = 'body' as any;\n  await testSSR(\n    <Div dangerouslySetInnerHTML={0}></Div>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body>0</body></html>'\n  );\n  await testSSR(\n    <body>\n      <script dangerouslySetInnerHTML=\"() => null\"></script>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <script>\n          () => null\n        </script>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('single complex children', async () => {\n  await testSSR(\n    <div>\n      <p>hola</p>\n    </div>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><div><p>hola</p></div></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n  await testSSR(\n    <div>\n      hola {2}\n      <p>hola</p>\n    </div>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><div>hola 2<p>hola</p></div></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('single multiple children', async () => {\n  await testSSR(\n    <ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n      <li>6</li>\n      <li>7</li>\n      <li>8</li>\n    </ul>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('sanitazion', async () => {\n  await testSSR(\n    <body>\n      <div>{`.rule > thing{}`}</div>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <div>.rule &gt; thing{}</div>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using fragment', async () => {\n  await testSSR(\n    <ul>\n      <>\n        <li>1</li>\n        <li>2</li>\n      </>\n      <li>3</li>\n      <>\n        <li>4</li>\n        <>\n          <li>5</li>\n          <>\n            <>\n              <li>6</li>\n            </>\n          </>\n        </>\n        <li>7</li>\n      </>\n      <li>8</li>\n    </ul>,\n    '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\"><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul></container>',\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using promises', async () => {\n  await testSSR(\n    <body>{Promise.resolve('hola')}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><!--qkssr-f-->hola</body></html>'\n  );\n  await testSSR(\n    <body>{Promise.resolve(<p>hola</p>)}</body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body><!--qkssr-f--><p>hola</p></body></html>'\n  );\n\n  await testSSR(\n    <ul>\n      {Promise.resolve(<li>1</li>)}\n      <li>2</li>\n      {delay(100).then(() => (\n        <li>3</li>\n      ))}\n      {delay(10).then(() => (\n        <li>4</li>\n      ))}\n    </ul>,\n    [\n      '<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">',\n      '<ul>',\n      '<!--qkssr-f-->',\n      '<li>',\n      '1',\n      '</li>',\n      '<li>',\n      '2',\n      '</li>',\n      '<!--qkssr-f-->',\n      '<li>',\n      '3',\n      '</li>',\n      '<!--qkssr-f-->',\n      '<li>',\n      '4',\n      '</li>',\n      '</ul>',\n      '</container>',\n    ],\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('mixed children', async () => {\n  await testSSR(\n    <ul>\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n      {Promise.resolve(<li>3</li>)}\n      <li>4</li>\n      {delay(100).then(() => (\n        <li>5</li>\n      ))}\n      {delay(10).then(() => (\n        <li>6</li>\n      ))}\n    </ul>,\n    `\n        <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n        <ul>\n        <li>0</li>\n        <li>1</li>\n        <li>2</li>\n        <!--qkssr-f-->\n        <li>3</li>\n        <li>4</li>\n        <!--qkssr-f-->\n        <li>5</li>\n        <!--qkssr-f-->\n        <li>6</li>\n        </ul>\n        </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('DelayResource', async () => {\n  await testSSR(\n    <body>\n      <ul>\n        <DelayResource text=\"thing\" delay={100} />\n        <DelayResource text=\"thing\" delay={10} />\n      </ul>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n    <body>\n      <ul>\n        <!--qv q:id=0 q:key=sX:-->\n          <style q:style=\"fio5tb-0\" hidden>.cmp {background: blue}</style>\n          <div class=\"cmp\"><!--qkssr-f--><span>thing</span></div>\n        <!--/qv-->\n        <!--qv q:id=1 q:key=sX:-->\n          <div class=\"cmp\"><!--qkssr-f--><span>thing</span></div>\n        <!--/qv-->\n      </ul>\n    </body>\n  </html>`\n  );\n});\n\nrenderSSRSuite('using promises with DelayResource', async () => {\n  await testSSR(\n    <body>\n      <ul>\n        {delay(10).then(() => (\n          <li>thing</li>\n        ))}\n        <DelayResource text=\"thing\" delay={500} />\n      </ul>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n      <ul>\n        <!--qkssr-f-->\n        <li>thing</li>\n        <!--qv q:id=0 q:key=sX:-->\n          <style q:style=\"fio5tb-0\" hidden>.cmp {background: blue}</style>\n          <div class=\"cmp\"><!--qkssr-f--><span>thing</span></div>\n        <!--/qv-->\n      </ul>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using component', async () => {\n  await testSSR(\n    <MyCmp />,\n    `<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <section><div>MyCmp{}</div></section>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using component with key', async () => {\n  await testSSR(\n    <body>\n      <MyCmp key=\"hola\" />\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:hola-->\n        <section><div>MyCmp{}</div></section>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using component props', async () => {\n  await testSSR(\n    <MyCmp\n      id=\"12\"\n      host:prop=\"attribute\"\n      innerHTML=\"123\"\n      dangerouslySetInnerHTML=\"432\"\n      onClick=\"lazy.js\"\n      prop=\"12\"\n      q:slot=\"name\"\n    >\n      stuff\n    </MyCmp>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <section>\n        <div>MyCmp{\"id\":\"12\",\"host:prop\":\"attribute\",\"innerHTML\":\"123\",\"dangerouslySetInnerHTML\":\"432\",\"onClick\":\"lazy.js\",\"prop\":\"12\"}</div>\n      </section>\n      <q:template q:slot hidden aria-hidden=\"true\">stuff</q:template>\n      <!--/qv-->\n    </container>\n    `,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using component project content', async () => {\n  await testSSR(\n    <MyCmp>\n      <div>slot</div>\n    </MyCmp>,\n    `\n  <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n    <!--qv q:id=0 q:key=sX:-->\n    <section><div>MyCmp{}</div></section>\n    <q:template q:slot hidden aria-hidden=\"true\"><div>slot</div></q:template>\n    <!--/qv-->\n  </container>\n`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('using complex component', async () => {\n  await testSSR(\n    <body>\n      <MyCmpComplex></MyCmpComplex>\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        <div on:click=\"/runtimeQRL#_\" q:id=\"1\">\n          <button on:click=\"/runtimeQRL#_\">Click</button>\n          <!--qv q:s q:sref=0 q:key=--><!--/qv-->\n        </div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('using complex component with slot', async () => {\n  await testSSR(\n    <MyCmpComplex>Hola</MyCmpComplex>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <div on:click=\"/runtimeQRL#_\" q:id=\"1\">\n        <button on:click=\"/runtimeQRL#_\">Click</button>\n        <!--qv q:s q:sref=0 q:key=-->\n        Hola\n        <!--/qv-->\n      </div>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('<head>', async () => {\n  await testSSR(\n    <head>\n      <title>hola</title>\n      <>\n        <meta></meta>\n      </>\n    </head>,\n    `\n  <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n    <head q:head>\n      <title q:head>hola</title>\n      <meta q:head>\n    </head>\n  </html>`\n  );\n});\n\nrenderSSRSuite('named slots', async () => {\n  await testSSR(\n    <NamedSlot>\n      Text\n      <div q:slot=\"start\">START: 1</div>\n      <>\n        <div q:slot=\"end\">END: 1</div>\n        from\n        <div q:slot=\"start\">START: 2</div>\n      </>\n      <div q:slot=\"end\">END: 2</div>\n      default\n    </NamedSlot>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <div>\n        <!--qv q:s q:sref=0 q:key=start-->\n        <div q:slot=\"start\">START: 1</div>\n        <div q:slot=\"start\">START: 2</div>\n        <!--/qv-->\n        <div><!--qv q:s q:sref=0 q:key=-->Textfromdefault<!--/qv--></div>\n        <!--qv q:s q:sref=0 q:key=end-->\n        <div q:slot=\"end\">END: 1</div>\n        <div q:slot=\"end\">END: 2</div>\n        <!--/qv-->\n      </div>\n      <!--/qv-->\n    </container>\n`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('nested slots', async () => {\n  await testSSR(\n    <SimpleSlot name=\"root\">\n      <SimpleSlot name=\"level 1\">\n        <SimpleSlot name=\"level 2\">\n          BEFORE CONTENT\n          <div>Content</div>\n          AFTER CONTENT\n        </SimpleSlot>\n      </SimpleSlot>\n    </SimpleSlot>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n        <div id=\"root\">\n          Before root\n          <!--qv q:s q:sref=0 q:key=-->\n            <!--qv q:id=1 q:key=sX:-->\n            <div id=\"level 1\">\n              Before level 1\n              <!--qv q:s q:sref=1 q:key=-->\n                <!--qv q:id=2 q:key=sX:-->\n                  <div id=\"level 2\">\n                    Before level 2\n                    <!--qv q:s q:sref=2 q:key=-->\n                      BEFORE CONTENT\n                      <div>Content</div>\n                      AFTER CONTENT\n                    <!--/qv-->\n                    After level 2\n                  </div>\n                <!--/qv-->\n              <!--/qv-->\n              After level 1\n            </div>\n            <!--/qv-->\n          <!--/qv-->\n          After root\n        </div>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('mixes slots', async () => {\n  await testSSR(\n    <MixedSlot>Content</MixedSlot>,\n    `\n    <container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n      <!--qv q:id=1 q:key=sX:-->\n        <div id=\"1\">Before 1\n        <!--qv q:s q:sref=1 q:key=-->\n          <!--qv q:s q:sref=0 q:key=-->\n            Content\n          <!--/qv-->\n        <!--/qv-->\n        After 1\n      </div>\n      <!--/qv-->\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('component RenderSignals()', async () => {\n  await testSSR(\n    <RenderSignals />,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:id=0 q:key=sX:-->\n      <head q:head>\n        <title q:head>value</title>\n        <style q:head>\n          value\n        </style>\n        <script q:head>\n          value\n        </script>\n      </head>\n      <!--/qv-->\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useContextProvider()', async () => {\n  await testSSR(\n    <Context>\n      <ContextConsumer />\n    </Context>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:id=0 q:key=sX:-->\n        <!--qv q:s q:sref=0 q:key=-->\n          <!--qv q:id=1 q:key=sX:-->hello bye<!--/qv-->\n        <!--/qv-->\n        <!--qv q:id=2 q:key=sX:-->hello bye<!--/qv-->\n      <!--/qv-->\n    </html>`\n  );\n});\n\nrenderSSRSuite('component slotted context', async () => {\n  await testSSR(\n    <body>\n      <VariadicContext>\n        <ReadValue />\n        <ReadValue q:slot=\"start\" />\n        <ReadValue q:slot=\"end\" />\n      </VariadicContext>\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        <!--qv q:id=1 q:key=sX:-->\n        <!--qv q:s q:sref=1 q:key=-->\n        <!--qv q:s q:sref=0 q:key=start-->\n        <!--qv q:id=2 q:key=sX:-->\n        <span>start</span>\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--qv q:id=3 q:key=sX:-->\n        <!--qv q:s q:sref=3 q:key=-->\n        <!--qv q:s q:sref=0 q:key=-->\n        <!--qv q:id=4 q:key=sX:-->\n        <span>default</span>\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--qv q:id=5 q:key=sX:-->\n        <!--qv q:s q:sref=5 q:key=-->\n        <!--qv q:s q:sref=0 q:key=end-->\n        <!--qv q:id=6 q:key=sX:-->\n        <span>end</span>\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useOn()', async () => {\n  await testSSR(\n    <body>\n      <Events />\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n      <!--qv q:id=0 q:key=sX:-->\n      <div on:click=\"/runtimeQRL#_\\n/runtimeQRL#_\" on-window:click=\"/runtimeQRL#_\" on-document:click=\"/runtimeQRL#_\"></div>\n      <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useStyles()', async () => {\n  await testSSR(\n    <>\n      <body>\n        <Styles />\n      </body>\n    </>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n          <style q:style=\"17nc-0\" hidden>.host {color: red}</style>\n          <div class=\"host\">\n            Text\n          </div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useStylesScoped()', async () => {\n  await testSSR(\n    <>\n      <body>\n        <ScopedStyles1>\n          <div>projected</div>\n        </ScopedStyles1>\n      </body>\n    </>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:sstyle=\u2b50\ufe0f1d-0 q:id=0 q:key=sX:-->\n        <style q:style=\"1d-0\" hidden>\n          .host.\u2b50\ufe0f1d-0 {\n            color: red;\n          }\n        </style>\n        <div class=\"\u2b50\ufe0f1d-0 host\">\n          <div class=\"\u2b50\ufe0f1d-0 div\">\n            Scoped1\n            <!--qv q:s q:sref=0 q:key=-->\n            <div>projected</div>\n            <!--/qv-->\n            <p class=\"\u2b50\ufe0f1d-0\">Que tal?</p>\n          </div>\n          <!--qv q:sstyle=\u2b50\ufe0ff0gmsw-0 q:id=1 q:key=sX:-->\n          <style q:style=\"f0gmsw-0\" hidden>\n            .host.\u2b50\ufe0ff0gmsw-0 {\n              color: blue;\n            }\n          </style>\n          <div class=\"\u2b50\ufe0ff0gmsw-0 host\">\n            <div class=\"\u2b50\ufe0ff0gmsw-0\">\n              Scoped2\n              <p class=\"\u2b50\ufe0ff0gmsw-0\">Bien</p>\n            </div>\n          </div>\n          <!--/qv-->\n          <!--qv q:sstyle=\u2b50\ufe0ff0gmsw-0 q:id=2 q:key=sX:-->\n          <div class=\"\u2b50\ufe0ff0gmsw-0 host\">\n            <div class=\"\u2b50\ufe0ff0gmsw-0\">\n              Scoped2\n              <p class=\"\u2b50\ufe0ff0gmsw-0\">Bien</p>\n            </div>\n          </div>\n          <!--/qv-->\n        </div>\n        <!--/qv-->\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('component useStylesScoped() + slot', async () => {\n  await testSSR(\n    <>\n      <RootStyles></RootStyles>\n    </>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:sstyle=\u2b50\ufe0flkei4s-0 q:id=0 q:key=sX:-->\n      <body class=\"\u2b50\ufe0flkei4s-0\">\n        <!--qv q:sstyle=\u2b50\ufe0ftdblg1-0 q:id=1 q:key=sX:-->\n        <style q:style=\"tdblg1-0\" hidden>\n          .host.\u2b50\ufe0ftdblg1-0 {\n            background: green;\n          }\n        </style>\n        <div class=\"\u2b50\ufe0ftdblg1-0\">\n          <!--qv q:s q:sref=1 q:key=one-->\n          <div q:slot=\"one\" class=\"\u2b50\ufe0flkei4s-0\">One</div>\n          <!--/qv-->\n        </div>\n        <q:template q:slot=\"two\" hidden aria-hidden=\"true\" class=\"\u2b50\ufe0flkei4s-0\">\n          <div q:slot=\"two\" class=\"\u2b50\ufe0flkei4s-0\">Two</div>\n        </q:template>\n        <!--/qv-->\n      </body>\n      <!--/qv-->\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('component useClientEffect()', async () => {\n  await testSSR(\n    <UseClientEffect />,\n    `<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class=\"qc\ud83d\udce6\">\n      <!--qv q:id=0 q:key=sX:-->\n        <div on:qvisible=\"/runtimeQRL#_[0]\n/runtimeQRL#_[1]\" q:id=\"1\"></div>\n      <!--/qv-->\n    </container>`,\n    {\n      containerTagName: 'container',\n    }\n  );\n});\n\nrenderSSRSuite('component useClientEffect() without elements', async () => {\n  await testSSR(\n    <body>\n      <UseEmptyClientEffect />\n    </body>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qv q:id=0 q:key=sX:-->\n        Hola\n        <script type=\"placeholder\" hidden q:id=\"1\" on-document:qinit=\"/runtimeQRL#_[0]\\n/runtimeQRL#_[1]\"></script>\n        <!--/qv-->\n      </body>\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('component useClientEffect() inside <head>', async () => {\n  await testSSR(\n    <head>\n      <UseEmptyClientEffect />\n      <UseClientEffect as=\"style\" />\n    </head>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <head q:head>\n        <!--qv q:id=0 q:key=sX:-->\n        Hola\n        <script type=\"placeholder\" hidden q:id=\"1\" on-document:qinit=\"/runtimeQRL#_[0]\\n/runtimeQRL#_[1]\"></script>\n        <!--/qv-->\n        <!--qv q:id=2 q:key=sX:-->\n        <style on-document:qinit=\"/runtimeQRL#_[0]\\n/runtimeQRL#_[1]\" q:id=\"3\" q:head></style>\n        <!--/qv-->\n      </head>\n    </html>`\n  );\n});\n\nrenderSSRSuite('nested html', async () => {\n  await testSSR(\n    <>\n      <body></body>\n    </>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>`\n  );\n});\n\nrenderSSRSuite('root html component', async () => {\n  await testSSR(\n    <HeadCmp host:aria-hidden=\"true\">\n      <link></link>\n    </HeadCmp>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <!--qv q:id=0 q:key=sX:-->\n      <head on-document:qinit=\"/runtimeQRL#_[0]\" q:id=\"1\" q:head>\n        <title q:head>hola</title>\n        <!--qv q:s q:sref=0 q:key=-->\n        <link q:head />\n        <!--/qv-->\n      </head>\n      <!--/qv-->\n    </html>\n    `\n  );\n});\n\nrenderSSRSuite('containerTagName', async () => {\n  await testSSR(\n    <>\n      <Styles />\n      <UseClientEffect></UseClientEffect>\n      <section></section>\n    </>,\n    `<container q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" q:base=\"/manu/folder\" class=\"qc\ud83d\udce6\">\n      <link rel=\"stylesheet\" href=\"/global.css\">\n      <!--qv q:id=0 q:key=sX:-->\n        <style q:style=\"17nc-0\" hidden>.host {color: red}</style>\n        <div class=\"host\">Text</div>\n      <!--/qv-->\n      <!--qv q:id=1 q:key=sX:-->\n        <div on:qvisible=\"/runtimeQRL#_[0]\n/runtimeQRL#_[1]\" q:id=\"2\"></div>\n      <!--/qv-->\n      <section></section>\n    </container>`,\n    {\n      containerTagName: 'container',\n      base: '/manu/folder',\n      beforeContent: [jsx('link', { rel: 'stylesheet', href: '/global.css' })],\n    }\n  );\n});\n\nrenderSSRSuite('containerAttributes', async () => {\n  await testSSR(\n    <>\n      <body></body>\n    </>,\n    `\n    <html prefix=\"something\" q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n     <body></body>\n    </html>\n    `,\n    {\n      containerAttributes: {\n        prefix: 'something',\n      },\n    }\n  );\n  await testSSR(\n    <>\n      <div></div>\n    </>,\n    `\n    <app prefix=\"something\" q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" class='qc\ud83d\udce6 thing'>\n     <div></div>\n    </app>\n    `,\n    {\n      containerTagName: 'app',\n      containerAttributes: {\n        prefix: 'something',\n        class: 'thing',\n      },\n    }\n  );\n});\n\nrenderSSRSuite('ssr marks', async () => {\n  await testSSR(\n    <body>\n      {delay(100).then(() => (\n        <li>1</li>\n      ))}\n      {delay(10).then(() => (\n        <li>2</li>\n      ))}\n      <SSRComment data=\"here\" />\n      <div>\n        <SSRComment data=\"i am\" />\n      </div>\n      {delay(120).then(() => (\n        <li>3</li>\n      ))}\n    </body>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\">\n      <body>\n        <!--qkssr-f-->\n        <li>1</li>\n        <!--qkssr-f-->\n        <li>2</li>\n        <!--here-->\n        <div>\n          <!--i am-->\n        </div>\n        <!--qkssr-f-->\n        <li>3</li>\n      </body>\n    </html>`\n  );\n});\n\nrenderSSRSuite('html slot', async () => {\n  await testSSR(\n    <HtmlContext>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <title>Qwik</title>\n      </head>\n      <body>\n        <div></div>\n      </body>\n    </HtmlContext>,\n    `\n    <html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\" q:base=\"/manu/folder\">\n      <!--qv q:id=0 q:key=sX:-->\n      <!--qv q:s q:sref=0 q:key=-->\n      <head q:head>\n        <meta charset=\"utf-8\" q:head />\n        <title q:head>Qwik</title>\n        <link rel=\"stylesheet\" href=\"/global.css\" />\n        <style q:style=\"fio5tb-1\" hidden>\n          body {\n            background: blue;\n          }\n        </style>\n      </head>\n      <body>\n        <div></div>\n      </body>\n      <!--/qv-->\n      <!--/qv-->\n    </html>`,\n    {\n      beforeContent: [jsx('link', { rel: 'stylesheet', href: '/global.css' })],\n      base: '/manu/folder',\n    }\n  );\n});\n\nrenderSSRSuite('null component', async () => {\n  await testSSR(\n    <>\n      <NullCmp />\n    </>,\n    `<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><!--qv q:id=0 q:key=sX:--><!--/qv--></html>`\n  );\n});\n\nrenderSSRSuite('cleanse attribute name', async () => {\n  const o = {\n    '\"><script>alert(\"\u0ca0~\u0ca0\")</script>': 'xss',\n  };\n  await testSSR(\n    <body {...o}></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body></body></html>'\n  );\n});\n\nrenderSSRSuite('cleanse class attribute', async () => {\n  const o = {\n    class: '\"><script>alert(\"\u0ca0~\u0ca0\")</script>',\n  };\n  await testSSR(\n    <body {...o}></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body class=\"&quot;><script>alert(&quot;\u0ca0~\u0ca0&quot;)</script>\"></body></html>'\n  );\n});\n\nrenderSSRSuite('class emoji valid', async () => {\n  const o = {\n    class: 'package\ud83d\udce6',\n  };\n  await testSSR(\n    <body {...o}></body>,\n    '<html q:container=\"paused\" q:version=\"dev\" q:render=\"ssr-dev\"><body class=\"package\ud83d\udce6\"></body></html>'\n  );\n});\n\n// TODO\n// Merge props on host\n// - host events\n// - class\n// - style\n// Container with tagName\n// End-to-end with qwikcity\n// SVG rendering\n// Performance metrics\n\nrenderSSRSuite.run();\n\nexport const MyCmp = component$((props: Record<string, any>) => {\n  return (\n    <section>\n      <div>\n        MyCmp\n        {JSON.stringify(props)}\n      </div>\n    </section>\n  );\n});\n\nexport const MyCmpComplex = component$(() => {\n  const ref = useRef();\n  return (\n    <div ref={ref} onClick$={() => console.warn('from component')}>\n      <button onClick$={() => console.warn('click')}>Click</button>\n      <Slot></Slot>\n    </div>\n  );\n});\n\nexport const SimpleSlot = component$((props: { name: string }) => {\n  return (\n    <div id={props.name}>\n      Before {props.name}\n      <Slot></Slot>\n      After {props.name}\n    </div>\n  );\n});\n\nexport const MixedSlot = component$(() => {\n  return (\n    <SimpleSlot name=\"1\">\n      <Slot />\n    </SimpleSlot>\n  );\n});\n\nexport const NamedSlot = component$(() => {\n  return (\n    <div>\n      <Slot name=\"start\" />\n      <div>\n        <Slot></Slot>\n      </div>\n      <Slot name=\"end\" />\n    </div>\n  );\n});\n\nexport const Events = component$(() => {\n  useOn(\n    'click',\n    $(() => console.warn('click'))\n  );\n  useOnWindow(\n    'click',\n    $(() => console.warn('window:click'))\n  );\n  useOnDocument(\n    'click',\n    $(() => console.warn('document:click'))\n  );\n\n  return <div onClick$={() => console.warn('scroll')}></div>;\n});\n\nexport const Styles = component$(() => {\n  useStylesQrl(inlinedQrl('.host {color: red}', 'styles_987'));\n\n  return <div class=\"host\">Text</div>;\n});\n\nexport const ScopedStyles1 = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {color: red}', 'styles_scoped_1'));\n\n  return (\n    <div class=\"host\">\n      <div className=\"div\">\n        Scoped1\n        <Slot></Slot>\n        <p>Que tal?</p>\n      </div>\n      <ScopedStyles2 />\n      <ScopedStyles2 />\n    </div>\n  );\n});\n\nexport const ScopedStyles2 = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {color: blue}', '20_styles_scoped'));\n\n  return (\n    <div class=\"host\">\n      <div>\n        Scoped2\n        <p>Bien</p>\n      </div>\n    </div>\n  );\n});\n\nexport const RootStyles = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {background: blue}', '20_stylesscopedblue'));\n\n  return (\n    <body>\n      <ComponentA>\n        <div q:slot=\"one\">One</div>\n        <div q:slot=\"two\">Two</div>\n      </ComponentA>\n    </body>\n  );\n});\n\nexport const ComponentA = component$(() => {\n  useStylesScopedQrl(inlinedQrl('.host {background: green}', '20_stylesscopedgreen'));\n\n  return (\n    <div>\n      <Slot name=\"one\" />\n    </div>\n  );\n});\n\nconst CTX_INTERNAL = createContext<{ value: string }>('internal');\nconst CTX_QWIK_CITY = createContext<{ value: string }>('qwikcity');\nconst CTX_VALUE = createContext<{ value: string }>('value');\n\nexport const VariadicContext = component$(() => {\n  return (\n    <>\n      <ContextWithValue value=\"start\">\n        <Slot name=\"start\"></Slot>\n      </ContextWithValue>\n      <ContextWithValue value=\"default\">\n        <Slot></Slot>\n      </ContextWithValue>\n      <ContextWithValue value=\"end\">\n        <Slot name=\"end\"></Slot>\n      </ContextWithValue>\n    </>\n  );\n});\n\nexport const ReadValue = component$(() => {\n  const ctx = useContext(CTX_VALUE);\n  return <span>{ctx.value}</span>;\n});\n\nexport const ContextWithValue = component$((props: { value: string }) => {\n  const value = {\n    value: props.value,\n  };\n  useContextProvider(CTX_VALUE, value);\n  return (\n    <>\n      <Slot />\n    </>\n  );\n});\n\nexport const Context = component$(() => {\n  useContextProvider(CTX_INTERNAL, {\n    value: 'hello',\n  });\n  useContextProvider(CTX_QWIK_CITY, {\n    value: 'bye',\n  });\n  return (\n    <>\n      <Slot />\n      <ContextConsumer />\n    </>\n  );\n});\n\nexport const ContextConsumer = component$(() => {\n  const internal = useContext(CTX_INTERNAL);\n  const qwikCity = useContext(CTX_QWIK_CITY);\n\n  return (\n    <>\n      {internal.value} {qwikCity.value}\n    </>\n  );\n});\n\nexport const UseClientEffect = component$((props: any) => {\n  useClientEffect$(() => {\n    console.warn('client effect');\n  });\n  useClientEffect$(() => {\n    console.warn('second client effect');\n  });\n  useTask$(async () => {\n    await delay(10);\n  });\n\n  const Div = props.as ?? 'div';\n  return <Div />;\n});\n\nexport const UseEmptyClientEffect = component$(() => {\n  useClientEffect$(() => {\n    console.warn('client effect');\n  });\n  useClientEffect$(() => {\n    console.warn('second client effect');\n  });\n  useTask$(async () => {\n    await delay(10);\n  });\n\n  return <>Hola</>;\n});\n\nexport const HeadCmp = component$(() => {\n  useClientEffect$(() => {\n    console.warn('client effect');\n  });\n  return (\n    <head>\n      <title>hola</title>\n      <Slot></Slot>\n    </head>\n  );\n});\n\nexport const RenderSignals = component$(() => {\n  const signal = useSignal('value');\n  return (\n    <>\n      <head>\n        <title>{signal.value}</title>\n        <style>{signal.value}</style>\n        <script>{signal.value}</script>\n      </head>\n    </>\n  );\n});\n\nexport const HtmlContext = component$(() => {\n  const store = useStore({});\n  useStylesQrl(inlinedQrl(`body {background: blue}`, 'styles_DelayResource'));\n  useContextProvider(CTX_INTERNAL, store);\n\n  return <Slot />;\n});\n\nasync function testSSR(\n  node: JSXNode,\n  expected: string | string[],\n  opts?: Partial<RenderSSROptions>\n) {\n  const chunks: string[] = [];\n  const stream: StreamWriter = {\n    write(chunk) {\n      chunks.push(chunk);\n    },\n  };\n  await renderSSR(node, {\n    stream,\n    containerTagName: 'html',\n    containerAttributes: {},\n    ...opts,\n  });\n  if (typeof expected === 'string') {\n    const options = { parser: 'html', htmlWhitespaceSensitivity: 'ignore' } as const;\n    snapshot(\n      format(chunks.join(''), options),\n      format(expected.replace(/(\\n|^)\\s+/gm, ''), options)\n    );\n  } else {\n    equal(chunks, expected);\n  }\n}\n\nexport const DelayResource = component$((props: { text: string; delay: number }) => {\n  useStylesQrl(inlinedQrl(`.cmp {background: blue}`, 'styles_DelayResource'));\n\n  const resource = useResource$<string>(async ({ track }) => {\n    track(props, 'text');\n    await delay(props.delay);\n    return props.text;\n  });\n  return (\n    <div class=\"cmp\">\n      <Resource value={resource} onResolved={(value) => <span>{value}</span>} />\n    </div>\n  );\n});\n\nexport const NullCmp = component$(() => {\n  return null;\n});\n\nexport const EffectTransparent = component$(() => {\n  useClientEffect$(() => {\n    console.warn('log');\n  });\n  return <Slot />;\n});\n\nexport const EffectTransparentRoot = component$(() => {\n  useClientEffect$(() => {\n    console.warn('log');\n  });\n  return (\n    <EffectTransparent>\n      <section>Hello</section>\n    </EffectTransparent>\n  );\n});\n\nasync function throws<T>(fn: () => T, expected?: string | RegExp): Promise<void> {\n  try {\n    await fn();\n    unreachable('Expression should throw');\n  } catch (e) {\n    if (expected) {\n      match(String(e), expected);\n    }\n  }\n}\n"], "filenames": ["packages/qwik/src/core/render/ssr/render-ssr.ts", "packages/qwik/src/core/render/ssr/render-ssr.unit.tsx"], "buggy_code_start_loc": [546, 1264], "buggy_code_end_loc": [1075, 1264], "fixing_code_start_loc": [547, 1265], "fixing_code_end_loc": [1086, 1296], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Generic in GitHub repository builderio/qwik prior to 0.1.0-beta5.", "other": {"cve": {"id": "CVE-2023-0410", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-20T01:15:10.863", "lastModified": "2023-01-26T15:24:58.893", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Generic in GitHub repository builderio/qwik prior to 0.1.0-beta5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:builder:qwik:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.16.2", "matchCriteriaId": "B13AEEBE-C446-462A-A749-DE7FE17454A3"}]}]}], "references": [{"url": "https://github.com/builderio/qwik/commit/4b2f89dbbd2bc0a2c92eae1a49bdd186e589151a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2da583f0-7f66-4ba7-9bed-8e7229aa578e", "source": "security@huntr.dev", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/builderio/qwik/commit/4b2f89dbbd2bc0a2c92eae1a49bdd186e589151a"}}