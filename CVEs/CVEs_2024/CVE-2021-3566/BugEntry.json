{"buggy_code": ["/*\n * Tele-typewriter demuxer\n * Copyright (c) 2010 Peter Ross <pross@xvid.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Tele-typewriter demuxer\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/log.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/parseutils.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"sauce.h\"\n\ntypedef struct TtyDemuxContext {\n    AVClass *class;\n    int chars_per_frame;\n    uint64_t fsize;  /**< file size less metadata buffer */\n    int width, height; /**< Set by a private option. */\n    AVRational framerate; /**< Set by a private option. */\n} TtyDemuxContext;\n\n/**\n * Parse EFI header\n */\nstatic int efi_read(AVFormatContext *avctx, uint64_t start_pos)\n{\n    TtyDemuxContext *s = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    char buf[37];\n    int len;\n\n    avio_seek(pb, start_pos, SEEK_SET);\n    if (avio_r8(pb) != 0x1A)\n        return -1;\n\n#define GET_EFI_META(name,size) \\\n    len = avio_r8(pb); \\\n    if (len < 1 || len > size) \\\n        return -1; \\\n    if (avio_read(pb, buf, size) == size) { \\\n        buf[len] = 0; \\\n        av_dict_set(&avctx->metadata, name, buf, 0); \\\n    }\n\n    GET_EFI_META(\"filename\", 12)\n    GET_EFI_META(\"title\",    36)\n\n    s->fsize = start_pos;\n    return 0;\n}\n\nstatic int read_header(AVFormatContext *avctx)\n{\n    TtyDemuxContext *s = avctx->priv_data;\n    int ret = 0;\n    AVStream *st = avformat_new_stream(avctx, NULL);\n\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    st->codecpar->codec_tag   = 0;\n    st->codecpar->codec_type  = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id    = AV_CODEC_ID_ANSI;\n\n    st->codecpar->width  = s->width;\n    st->codecpar->height = s->height;\n    avpriv_set_pts_info(st, 60, s->framerate.den, s->framerate.num);\n    st->avg_frame_rate = s->framerate;\n\n    /* simulate tty display speed */\n    s->chars_per_frame = FFMAX(av_q2d(st->time_base)*s->chars_per_frame, 1);\n\n    if (avctx->pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        s->fsize = avio_size(avctx->pb);\n        st->duration = (s->fsize + s->chars_per_frame - 1) / s->chars_per_frame;\n\n        if (ff_sauce_read(avctx, &s->fsize, 0, 0) < 0)\n            efi_read(avctx, s->fsize - 51);\n\n        avio_seek(avctx->pb, 0, SEEK_SET);\n    }\n\nfail:\n    return ret;\n}\n\nstatic int read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    TtyDemuxContext *s = avctx->priv_data;\n    int n;\n\n    if (avio_feof(avctx->pb))\n        return AVERROR_EOF;\n\n    n = s->chars_per_frame;\n    if (s->fsize) {\n        // ignore metadata buffer\n        uint64_t p = avio_tell(avctx->pb);\n        if (p == s->fsize)\n            return AVERROR_EOF;\n        if (p + s->chars_per_frame > s->fsize)\n            n = s->fsize - p;\n    }\n\n    pkt->size = av_get_packet(avctx->pb, pkt, n);\n    if (pkt->size < 0)\n        return pkt->size;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    return 0;\n}\n\n#define OFFSET(x) offsetof(TtyDemuxContext, x)\n#define DEC AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"chars_per_frame\", \"\", offsetof(TtyDemuxContext, chars_per_frame), AV_OPT_TYPE_INT, {.i64 = 6000}, 1, INT_MAX, AV_OPT_FLAG_DECODING_PARAM},\n    { \"video_size\", \"A string describing frame size, such as 640x480 or hd720.\", OFFSET(width), AV_OPT_TYPE_IMAGE_SIZE, {.str = NULL}, 0, 0, DEC },\n    { \"framerate\", \"\", OFFSET(framerate), AV_OPT_TYPE_VIDEO_RATE, {.str = \"25\"}, 0, INT_MAX, DEC },\n    { NULL },\n};\n\nstatic const AVClass tty_demuxer_class = {\n    .class_name     = \"TTY demuxer\",\n    .item_name      = av_default_item_name,\n    .option         = options,\n    .version        = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_tty_demuxer = {\n    .name           = \"tty\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Tele-typewriter\"),\n    .priv_data_size = sizeof(TtyDemuxContext),\n    .read_header    = read_header,\n    .read_packet    = read_packet,\n    .extensions     = \"ans,art,asc,diz,ice,nfo,txt,vt\",\n    .priv_class     = &tty_demuxer_class,\n};\n"], "fixing_code": ["/*\n * Tele-typewriter demuxer\n * Copyright (c) 2010 Peter Ross <pross@xvid.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Tele-typewriter demuxer\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/log.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/parseutils.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"sauce.h\"\n\nstatic int isansicode(int x)\n{\n    return x == 0x1B || x == 0x0A || x == 0x0D || (x >= 0x20 && x < 0x7f);\n}\n\nstatic const char tty_extensions[31] = \"ans,art,asc,diz,ice,nfo,txt,vt\";\n\ntypedef struct TtyDemuxContext {\n    AVClass *class;\n    int chars_per_frame;\n    uint64_t fsize;  /**< file size less metadata buffer */\n    int width, height; /**< Set by a private option. */\n    AVRational framerate; /**< Set by a private option. */\n} TtyDemuxContext;\n\nstatic int read_probe(const AVProbeData *p)\n{\n    int cnt = 0;\n\n    for (int i = 0; i < p->buf_size; i++)\n        cnt += !!isansicode(p->buf[i]);\n\n    return (cnt * 100LL / p->buf_size) * (cnt > 400) *\n        !!av_match_ext(p->filename, tty_extensions);\n}\n\n/**\n * Parse EFI header\n */\nstatic int efi_read(AVFormatContext *avctx, uint64_t start_pos)\n{\n    TtyDemuxContext *s = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    char buf[37];\n    int len;\n\n    avio_seek(pb, start_pos, SEEK_SET);\n    if (avio_r8(pb) != 0x1A)\n        return -1;\n\n#define GET_EFI_META(name,size) \\\n    len = avio_r8(pb); \\\n    if (len < 1 || len > size) \\\n        return -1; \\\n    if (avio_read(pb, buf, size) == size) { \\\n        buf[len] = 0; \\\n        av_dict_set(&avctx->metadata, name, buf, 0); \\\n    }\n\n    GET_EFI_META(\"filename\", 12)\n    GET_EFI_META(\"title\",    36)\n\n    s->fsize = start_pos;\n    return 0;\n}\n\nstatic int read_header(AVFormatContext *avctx)\n{\n    TtyDemuxContext *s = avctx->priv_data;\n    int ret = 0;\n    AVStream *st = avformat_new_stream(avctx, NULL);\n\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    st->codecpar->codec_tag   = 0;\n    st->codecpar->codec_type  = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id    = AV_CODEC_ID_ANSI;\n\n    st->codecpar->width  = s->width;\n    st->codecpar->height = s->height;\n    avpriv_set_pts_info(st, 60, s->framerate.den, s->framerate.num);\n    st->avg_frame_rate = s->framerate;\n\n    /* simulate tty display speed */\n    s->chars_per_frame = FFMAX(av_q2d(st->time_base)*s->chars_per_frame, 1);\n\n    if (avctx->pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        s->fsize = avio_size(avctx->pb);\n        st->duration = (s->fsize + s->chars_per_frame - 1) / s->chars_per_frame;\n\n        if (ff_sauce_read(avctx, &s->fsize, 0, 0) < 0)\n            efi_read(avctx, s->fsize - 51);\n\n        avio_seek(avctx->pb, 0, SEEK_SET);\n    }\n\nfail:\n    return ret;\n}\n\nstatic int read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    TtyDemuxContext *s = avctx->priv_data;\n    int n;\n\n    if (avio_feof(avctx->pb))\n        return AVERROR_EOF;\n\n    n = s->chars_per_frame;\n    if (s->fsize) {\n        // ignore metadata buffer\n        uint64_t p = avio_tell(avctx->pb);\n        if (p == s->fsize)\n            return AVERROR_EOF;\n        if (p + s->chars_per_frame > s->fsize)\n            n = s->fsize - p;\n    }\n\n    pkt->size = av_get_packet(avctx->pb, pkt, n);\n    if (pkt->size < 0)\n        return pkt->size;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    return 0;\n}\n\n#define OFFSET(x) offsetof(TtyDemuxContext, x)\n#define DEC AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"chars_per_frame\", \"\", offsetof(TtyDemuxContext, chars_per_frame), AV_OPT_TYPE_INT, {.i64 = 6000}, 1, INT_MAX, AV_OPT_FLAG_DECODING_PARAM},\n    { \"video_size\", \"A string describing frame size, such as 640x480 or hd720.\", OFFSET(width), AV_OPT_TYPE_IMAGE_SIZE, {.str = NULL}, 0, 0, DEC },\n    { \"framerate\", \"\", OFFSET(framerate), AV_OPT_TYPE_VIDEO_RATE, {.str = \"25\"}, 0, INT_MAX, DEC },\n    { NULL },\n};\n\nstatic const AVClass tty_demuxer_class = {\n    .class_name     = \"TTY demuxer\",\n    .item_name      = av_default_item_name,\n    .option         = options,\n    .version        = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_tty_demuxer = {\n    .name           = \"tty\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Tele-typewriter\"),\n    .priv_data_size = sizeof(TtyDemuxContext),\n    .read_probe     = read_probe,\n    .read_header    = read_header,\n    .read_packet    = read_packet,\n    .extensions     = tty_extensions,\n    .priv_class     = &tty_demuxer_class,\n};\n"], "filenames": ["libavformat/tty.c"], "buggy_code_start_loc": [36], "buggy_code_end_loc": [159], "fixing_code_start_loc": [37], "fixing_code_end_loc": [178], "type": "NVD-CWE-noinfo", "message": "Prior to ffmpeg version 4.3, the tty demuxer did not have a 'read_probe' function assigned to it. By crafting a legitimate \"ffconcat\" file that references an image, followed by a file the triggers the tty demuxer, the contents of the second file will be copied into the output file verbatim (as long as the `-vcodec copy` option is passed to ffmpeg).", "other": {"cve": {"id": "CVE-2021-3566", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2021-08-05T21:15:12.783", "lastModified": "2022-12-21T15:01:19.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prior to ffmpeg version 4.3, the tty demuxer did not have a 'read_probe' function assigned to it. By crafting a legitimate \"ffconcat\" file that references an image, followed by a file the triggers the tty demuxer, the contents of the second file will be copied into the output file verbatim (as long as the `-vcodec copy` option is passed to ffmpeg)."}, {"lang": "es", "value": "Anterior a versi\u00f3n 4.3 de ffmpeg, el demuxer tty no ten\u00eda una funci\u00f3n \"read_probe\" asignada. Si se dise\u00f1a un archivo \"ffconcat\" leg\u00edtimo que haga referencia a una imagen, seguido de un archivo que desencadenar el demuxer tty, el contenido del segundo archivo se copiar\u00e1 en el archivo de salida literalmente (siempre que se pase la opci\u00f3n \"vcodec copy\" a ffmpeg)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3", "matchCriteriaId": "2E8B7EC2-C1C3-48C9-9868-FF10E7E1AA99"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/3bce9e9b3ea35c54bacccc793d7da99ea5157532#diff-74f6b92a0541378ad15de9c29c0a2b0c69881ad9ffc71abe568b88b535e00a7f", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/08/msg00018.html", "source": "patrick@puiterwijk.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3bce9e9b3ea35c54bacccc793d7da99ea5157532#diff-74f6b92a0541378ad15de9c29c0a2b0c69881ad9ffc71abe568b88b535e00a7f"}}