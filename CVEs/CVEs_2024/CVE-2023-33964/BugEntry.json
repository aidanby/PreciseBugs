{"buggy_code": ["package transaction\n\nimport (\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\t\"github.com/multiversx/mx-chain-go/common\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n)\n\nvar _ process.TransactionProcessor = (*metaTxProcessor)(nil)\n\n// txProcessor implements TransactionProcessor interface and can modify account states according to a transaction\ntype metaTxProcessor struct {\n\t*baseTxProcessor\n\ttxTypeHandler       process.TxTypeHandler\n\tenableEpochsHandler common.EnableEpochsHandler\n}\n\n// ArgsNewMetaTxProcessor defines the arguments needed for new meta tx processor\ntype ArgsNewMetaTxProcessor struct {\n\tHasher              hashing.Hasher\n\tMarshalizer         marshal.Marshalizer\n\tAccounts            state.AccountsAdapter\n\tPubkeyConv          core.PubkeyConverter\n\tShardCoordinator    sharding.Coordinator\n\tScProcessor         process.SmartContractProcessor\n\tTxTypeHandler       process.TxTypeHandler\n\tEconomicsFee        process.FeeHandler\n\tEnableEpochsHandler common.EnableEpochsHandler\n}\n\n// NewMetaTxProcessor creates a new txProcessor engine\nfunc NewMetaTxProcessor(args ArgsNewMetaTxProcessor) (*metaTxProcessor, error) {\n\n\tif check.IfNil(args.Accounts) {\n\t\treturn nil, process.ErrNilAccountsAdapter\n\t}\n\tif check.IfNil(args.PubkeyConv) {\n\t\treturn nil, process.ErrNilPubkeyConverter\n\t}\n\tif check.IfNil(args.ShardCoordinator) {\n\t\treturn nil, process.ErrNilShardCoordinator\n\t}\n\tif check.IfNil(args.ScProcessor) {\n\t\treturn nil, process.ErrNilSmartContractProcessor\n\t}\n\tif check.IfNil(args.TxTypeHandler) {\n\t\treturn nil, process.ErrNilTxTypeHandler\n\t}\n\tif check.IfNil(args.EconomicsFee) {\n\t\treturn nil, process.ErrNilEconomicsFeeHandler\n\t}\n\tif check.IfNil(args.EnableEpochsHandler) {\n\t\treturn nil, process.ErrNilEnableEpochsHandler\n\t}\n\n\tbaseTxProcess := &baseTxProcessor{\n\t\taccounts:            args.Accounts,\n\t\tshardCoordinator:    args.ShardCoordinator,\n\t\tpubkeyConv:          args.PubkeyConv,\n\t\teconomicsFee:        args.EconomicsFee,\n\t\thasher:              args.Hasher,\n\t\tmarshalizer:         args.Marshalizer,\n\t\tscProcessor:         args.ScProcessor,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\t// backwards compatibility\n\tbaseTxProcess.enableEpochsHandler.ResetPenalizedTooMuchGasFlag()\n\n\ttxProc := &metaTxProcessor{\n\t\tbaseTxProcessor:     baseTxProcess,\n\t\ttxTypeHandler:       args.TxTypeHandler,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\n\treturn txProc, nil\n}\n\n// ProcessTransaction modifies the account states in respect with the transaction data\nfunc (txProc *metaTxProcessor) ProcessTransaction(tx *transaction.Transaction) (vmcommon.ReturnCode, error) {\n\tif check.IfNil(tx) {\n\t\treturn 0, process.ErrNilTransaction\n\t}\n\n\tacntSnd, acntDst, err := txProc.getAccounts(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tprocess.DisplayProcessTxDetails(\n\t\t\"ProcessTransaction: sender account details\",\n\t\tacntSnd,\n\t\ttx,\n\t\ttxHash,\n\t\ttxProc.pubkeyConv,\n\t)\n\n\terr = txProc.checkTxValues(tx, acntSnd, acntDst, false)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\ttxType, _ := txProc.txTypeHandler.ComputeTransactionType(tx)\n\n\tswitch txType {\n\tcase process.SCDeployment:\n\t\treturn txProc.processSCDeployment(tx, tx.SndAddr)\n\tcase process.SCInvoking:\n\t\treturn txProc.processSCInvoking(tx, tx.SndAddr, tx.RcvAddr)\n\tcase process.BuiltInFunctionCall:\n\t\tif txProc.enableEpochsHandler.IsBuiltInFunctionOnMetaFlagEnabled() {\n\t\t\treturn txProc.processBuiltInFunctionCall(tx, tx.SndAddr, tx.RcvAddr)\n\t\t}\n\n\t\tif txProc.enableEpochsHandler.IsESDTFlagEnabled() {\n\t\t\treturn txProc.processSCInvoking(tx, tx.SndAddr, tx.RcvAddr)\n\t\t}\n\t}\n\n\tsnapshot := txProc.accounts.JournalLen()\n\terr = txProc.scProcessor.ProcessIfError(acntSnd, txHash, tx, process.ErrWrongTransaction.Error(), nil, snapshot, 0)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn vmcommon.UserError, nil\n}\n\n// VerifyTransaction verifies the account states in respect with the transaction data\nfunc (txProc *metaTxProcessor) VerifyTransaction(tx *transaction.Transaction) error {\n\tif check.IfNil(tx) {\n\t\treturn process.ErrNilTransaction\n\t}\n\n\tsenderAccount, receiverAccount, err := txProc.getAccounts(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn txProc.checkTxValues(tx, senderAccount, receiverAccount, false)\n}\n\nfunc (txProc *metaTxProcessor) processSCDeployment(\n\ttx *transaction.Transaction,\n\tadrSrc []byte,\n) (vmcommon.ReturnCode, error) {\n\t// getAccounts returns acntSrc not nil if the adrSrc is in the node shard, the same, acntDst will be not nil\n\t// if adrDst is in the node shard. If an error occurs it will be signaled in err variable.\n\tacntSrc, err := txProc.getAccountFromAddress(adrSrc)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.scProcessor.DeploySmartContract(tx, acntSrc)\n}\n\nfunc (txProc *metaTxProcessor) processSCInvoking(\n\ttx *transaction.Transaction,\n\tadrSrc, adrDst []byte,\n) (vmcommon.ReturnCode, error) {\n\t// getAccounts returns acntSrc not nil if the adrSrc is in the node shard, the same, acntDst will be not nil\n\t// if adrDst is in the node shard. If an error occurs it will be signaled in err variable.\n\tacntSrc, acntDst, err := txProc.getAccounts(adrSrc, adrDst)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.scProcessor.ExecuteSmartContractTransaction(tx, acntSrc, acntDst)\n}\n\nfunc (txProc *metaTxProcessor) processBuiltInFunctionCall(\n\ttx *transaction.Transaction,\n\tadrSrc, adrDst []byte,\n) (vmcommon.ReturnCode, error) {\n\tacntSrc, acntDst, err := txProc.getAccounts(adrSrc, adrDst)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.scProcessor.ExecuteBuiltInFunction(tx, acntSrc, acntDst)\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (txProc *metaTxProcessor) IsInterfaceNil() bool {\n\treturn txProc == nil\n}\n", "package transaction_test\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/process/coordinator\"\n\t\"github.com/multiversx/mx-chain-go/process/mock\"\n\ttxproc \"github.com/multiversx/mx-chain-go/process/transaction\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/hashingMocks\"\n\tstateMock \"github.com/multiversx/mx-chain-go/testscommon/state\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/builtInFunctions\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/parsers\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc createMockNewMetaTxArgs() txproc.ArgsNewMetaTxProcessor {\n\targs := txproc.ArgsNewMetaTxProcessor{\n\t\tHasher:              &hashingMocks.HasherMock{},\n\t\tMarshalizer:         &mock.MarshalizerMock{},\n\t\tAccounts:            &stateMock.AccountsStub{},\n\t\tPubkeyConv:          createMockPubkeyConverter(),\n\t\tShardCoordinator:    mock.NewOneShardCoordinatorMock(),\n\t\tScProcessor:         &testscommon.SCProcessorMock{},\n\t\tTxTypeHandler:       &testscommon.TxTypeHandlerMock{},\n\t\tEconomicsFee:        createFreeTxFeeHandler(),\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{},\n\t}\n\treturn args\n}\n\n// ------- NewMetaTxProcessor\n\nfunc TestNewMetaTxProcessor_NilAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilAccountsAdapter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilPubkeyConverterMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.PubkeyConv = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilPubkeyConverter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilShardCoordinatorMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.ShardCoordinator = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilShardCoordinator, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilSCProcessorShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.ScProcessor = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilSmartContractProcessor, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilTxTypeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.TxTypeHandler = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilTxTypeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilTxFeeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.EconomicsFee = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilEconomicsFeeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_OkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Nil(t, err)\n\tassert.NotNil(t, txProc)\n}\n\n// ------- ProcessTransaction\n\nfunc TestMetaTxProcessor_ProcessTransactionNilTxShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err := txProc.ProcessTransaction(nil)\n\tassert.Equal(t, process.ErrNilTransaction, err)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionMalfunctionAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\t_, err := txProc.ProcessTransaction(&tx)\n\tassert.NotNil(t, err)\n}\n\nfunc TestMetaTxProcessor_ProcessCheckNotPassShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\t// these values will trigger ErrHigherNonceInTransaction\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrHigherNonceInTransaction, err)\n}\n\nfunc TestMetaTxProcessor_ProcessMoveBalancesShouldCallProcessIfError(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tcalled := false\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\tcalled = true\n\t\t\treturn nil\n\t\t},\n\t}\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, nil, err)\n\tassert.True(t, called)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionScTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, nil\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionScTxShouldReturnErrWhenExecutionFails(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, process.ErrNoVM\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrNoVM, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionScTxShouldNotBeCalledWhenAdrDstIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, process.ErrNoVM\n\t}\n\tcalledIfError := false\n\tscProcessorMock.ProcessIfErrorCalled = func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\tcalledIfError = true\n\t\treturn nil\n\t}\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targsTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    createMockPubkeyConverter(),\n\t\tShardCoordinator:   shardCoordinator,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\tcomputeType, _ := coordinator.NewTxTypeHandler(argsTxTypeHandler)\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = computeType\n\targs.ShardCoordinator = shardCoordinator\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, nil, err)\n\tassert.False(t, wasCalled)\n\tassert.True(t, calledIfError)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionBuiltInCallTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, nil\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t\t},\n\t}\n\tenableEpochsHandlerStub := &testscommon.EnableEpochsHandlerStub{\n\t\tIsBuiltInFunctionOnMetaFlagEnabledField: false,\n\t\tIsESDTFlagEnabledField:                  true,\n\t}\n\targs.EnableEpochsHandler = enableEpochsHandlerStub\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n\n\tbuiltInCalled := false\n\tscProcessorMock.ExecuteBuiltInFunctionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\tbuiltInCalled = true\n\t\treturn 0, nil\n\t}\n\n\tenableEpochsHandlerStub.IsBuiltInFunctionOnMetaFlagEnabledField = true\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, builtInCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n"], "fixing_code": ["package transaction\n\nimport (\n\t\"errors\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/core/check\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-core-go/hashing\"\n\t\"github.com/multiversx/mx-chain-core-go/marshal\"\n\t\"github.com/multiversx/mx-chain-go/common\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n)\n\nvar _ process.TransactionProcessor = (*metaTxProcessor)(nil)\n\n// txProcessor implements TransactionProcessor interface and can modify account states according to a transaction\ntype metaTxProcessor struct {\n\t*baseTxProcessor\n\ttxTypeHandler       process.TxTypeHandler\n\tenableEpochsHandler common.EnableEpochsHandler\n}\n\n// ArgsNewMetaTxProcessor defines the arguments needed for new meta tx processor\ntype ArgsNewMetaTxProcessor struct {\n\tHasher              hashing.Hasher\n\tMarshalizer         marshal.Marshalizer\n\tAccounts            state.AccountsAdapter\n\tPubkeyConv          core.PubkeyConverter\n\tShardCoordinator    sharding.Coordinator\n\tScProcessor         process.SmartContractProcessor\n\tTxTypeHandler       process.TxTypeHandler\n\tEconomicsFee        process.FeeHandler\n\tEnableEpochsHandler common.EnableEpochsHandler\n}\n\n// NewMetaTxProcessor creates a new txProcessor engine\nfunc NewMetaTxProcessor(args ArgsNewMetaTxProcessor) (*metaTxProcessor, error) {\n\n\tif check.IfNil(args.Accounts) {\n\t\treturn nil, process.ErrNilAccountsAdapter\n\t}\n\tif check.IfNil(args.PubkeyConv) {\n\t\treturn nil, process.ErrNilPubkeyConverter\n\t}\n\tif check.IfNil(args.ShardCoordinator) {\n\t\treturn nil, process.ErrNilShardCoordinator\n\t}\n\tif check.IfNil(args.ScProcessor) {\n\t\treturn nil, process.ErrNilSmartContractProcessor\n\t}\n\tif check.IfNil(args.TxTypeHandler) {\n\t\treturn nil, process.ErrNilTxTypeHandler\n\t}\n\tif check.IfNil(args.EconomicsFee) {\n\t\treturn nil, process.ErrNilEconomicsFeeHandler\n\t}\n\tif check.IfNil(args.EnableEpochsHandler) {\n\t\treturn nil, process.ErrNilEnableEpochsHandler\n\t}\n\n\tbaseTxProcess := &baseTxProcessor{\n\t\taccounts:            args.Accounts,\n\t\tshardCoordinator:    args.ShardCoordinator,\n\t\tpubkeyConv:          args.PubkeyConv,\n\t\teconomicsFee:        args.EconomicsFee,\n\t\thasher:              args.Hasher,\n\t\tmarshalizer:         args.Marshalizer,\n\t\tscProcessor:         args.ScProcessor,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\t// backwards compatibility\n\tbaseTxProcess.enableEpochsHandler.ResetPenalizedTooMuchGasFlag()\n\n\ttxProc := &metaTxProcessor{\n\t\tbaseTxProcessor:     baseTxProcess,\n\t\ttxTypeHandler:       args.TxTypeHandler,\n\t\tenableEpochsHandler: args.EnableEpochsHandler,\n\t}\n\n\treturn txProc, nil\n}\n\n// ProcessTransaction modifies the account states in respect with the transaction data\nfunc (txProc *metaTxProcessor) ProcessTransaction(tx *transaction.Transaction) (vmcommon.ReturnCode, error) {\n\tif check.IfNil(tx) {\n\t\treturn 0, process.ErrNilTransaction\n\t}\n\n\tacntSnd, acntDst, err := txProc.getAccounts(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\ttxHash, err := core.CalculateHash(txProc.marshalizer, txProc.hasher, tx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tprocess.DisplayProcessTxDetails(\n\t\t\"ProcessTransaction: sender account details\",\n\t\tacntSnd,\n\t\ttx,\n\t\ttxHash,\n\t\ttxProc.pubkeyConv,\n\t)\n\n\terr = txProc.checkTxValues(tx, acntSnd, acntDst, false)\n\tif err != nil {\n\t\tif errors.Is(err, process.ErrUserNameDoesNotMatchInCrossShardTx) {\n\t\t\terrProcessIfErr := txProc.processIfTxErrorCrossShard(tx, err.Error())\n\t\t\tif errProcessIfErr != nil {\n\t\t\t\treturn 0, errProcessIfErr\n\t\t\t}\n\t\t\treturn vmcommon.UserError, nil\n\t\t}\n\t\treturn 0, err\n\t}\n\n\ttxType, _ := txProc.txTypeHandler.ComputeTransactionType(tx)\n\n\tswitch txType {\n\tcase process.SCDeployment:\n\t\treturn txProc.processSCDeployment(tx, tx.SndAddr)\n\tcase process.SCInvoking:\n\t\treturn txProc.processSCInvoking(tx, tx.SndAddr, tx.RcvAddr)\n\tcase process.BuiltInFunctionCall:\n\t\tif txProc.enableEpochsHandler.IsBuiltInFunctionOnMetaFlagEnabled() {\n\t\t\treturn txProc.processBuiltInFunctionCall(tx, tx.SndAddr, tx.RcvAddr)\n\t\t}\n\n\t\tif txProc.enableEpochsHandler.IsESDTFlagEnabled() {\n\t\t\treturn txProc.processSCInvoking(tx, tx.SndAddr, tx.RcvAddr)\n\t\t}\n\t}\n\n\tsnapshot := txProc.accounts.JournalLen()\n\terr = txProc.scProcessor.ProcessIfError(acntSnd, txHash, tx, process.ErrWrongTransaction.Error(), nil, snapshot, 0)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn vmcommon.UserError, nil\n}\n\n// VerifyTransaction verifies the account states in respect with the transaction data\nfunc (txProc *metaTxProcessor) VerifyTransaction(tx *transaction.Transaction) error {\n\tif check.IfNil(tx) {\n\t\treturn process.ErrNilTransaction\n\t}\n\n\tsenderAccount, receiverAccount, err := txProc.getAccounts(tx.SndAddr, tx.RcvAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn txProc.checkTxValues(tx, senderAccount, receiverAccount, false)\n}\n\nfunc (txProc *metaTxProcessor) processSCDeployment(\n\ttx *transaction.Transaction,\n\tadrSrc []byte,\n) (vmcommon.ReturnCode, error) {\n\t// getAccounts returns acntSrc not nil if the adrSrc is in the node shard, the same, acntDst will be not nil\n\t// if adrDst is in the node shard. If an error occurs it will be signaled in err variable.\n\tacntSrc, err := txProc.getAccountFromAddress(adrSrc)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.scProcessor.DeploySmartContract(tx, acntSrc)\n}\n\nfunc (txProc *metaTxProcessor) processSCInvoking(\n\ttx *transaction.Transaction,\n\tadrSrc, adrDst []byte,\n) (vmcommon.ReturnCode, error) {\n\t// getAccounts returns acntSrc not nil if the adrSrc is in the node shard, the same, acntDst will be not nil\n\t// if adrDst is in the node shard. If an error occurs it will be signaled in err variable.\n\tacntSrc, acntDst, err := txProc.getAccounts(adrSrc, adrDst)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.scProcessor.ExecuteSmartContractTransaction(tx, acntSrc, acntDst)\n}\n\nfunc (txProc *metaTxProcessor) processBuiltInFunctionCall(\n\ttx *transaction.Transaction,\n\tadrSrc, adrDst []byte,\n) (vmcommon.ReturnCode, error) {\n\tacntSrc, acntDst, err := txProc.getAccounts(adrSrc, adrDst)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn txProc.scProcessor.ExecuteBuiltInFunction(tx, acntSrc, acntDst)\n}\n\n// IsInterfaceNil returns true if there is no value under the interface\nfunc (txProc *metaTxProcessor) IsInterfaceNil() bool {\n\treturn txProc == nil\n}\n", "package transaction_test\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/multiversx/mx-chain-core-go/core\"\n\t\"github.com/multiversx/mx-chain-core-go/data\"\n\t\"github.com/multiversx/mx-chain-core-go/data/transaction\"\n\t\"github.com/multiversx/mx-chain-go/process\"\n\t\"github.com/multiversx/mx-chain-go/process/coordinator\"\n\t\"github.com/multiversx/mx-chain-go/process/mock\"\n\ttxproc \"github.com/multiversx/mx-chain-go/process/transaction\"\n\t\"github.com/multiversx/mx-chain-go/sharding\"\n\t\"github.com/multiversx/mx-chain-go/state\"\n\t\"github.com/multiversx/mx-chain-go/testscommon\"\n\t\"github.com/multiversx/mx-chain-go/testscommon/hashingMocks\"\n\tstateMock \"github.com/multiversx/mx-chain-go/testscommon/state\"\n\t\"github.com/multiversx/mx-chain-go/vm\"\n\tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/builtInFunctions\"\n\t\"github.com/multiversx/mx-chain-vm-common-go/parsers\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc createMockNewMetaTxArgs() txproc.ArgsNewMetaTxProcessor {\n\targs := txproc.ArgsNewMetaTxProcessor{\n\t\tHasher:              &hashingMocks.HasherMock{},\n\t\tMarshalizer:         &mock.MarshalizerMock{},\n\t\tAccounts:            &stateMock.AccountsStub{},\n\t\tPubkeyConv:          createMockPubkeyConverter(),\n\t\tShardCoordinator:    mock.NewOneShardCoordinatorMock(),\n\t\tScProcessor:         &testscommon.SCProcessorMock{},\n\t\tTxTypeHandler:       &testscommon.TxTypeHandlerMock{},\n\t\tEconomicsFee:        createFreeTxFeeHandler(),\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{},\n\t}\n\treturn args\n}\n\n// ------- NewMetaTxProcessor\n\nfunc TestNewMetaTxProcessor_NilAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilAccountsAdapter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilPubkeyConverterMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.PubkeyConv = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilPubkeyConverter, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilShardCoordinatorMockShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.ShardCoordinator = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilShardCoordinator, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilSCProcessorShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.ScProcessor = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilSmartContractProcessor, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilTxTypeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.TxTypeHandler = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilTxTypeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_NilTxFeeHandlerShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\targs.EconomicsFee = nil\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Equal(t, process.ErrNilEconomicsFeeHandler, err)\n\tassert.Nil(t, txProc)\n}\n\nfunc TestNewMetaTxProcessor_OkValsShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\ttxProc, err := txproc.NewMetaTxProcessor(args)\n\n\tassert.Nil(t, err)\n\tassert.NotNil(t, txProc)\n}\n\n// ------- ProcessTransaction\n\nfunc TestMetaTxProcessor_ProcessTransactionNilTxShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\targs := createMockNewMetaTxArgs()\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err := txProc.ProcessTransaction(nil)\n\tassert.Equal(t, process.ErrNilTransaction, err)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionMalfunctionAccountsShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\tadb := createAccountStub(nil, nil, nil, nil)\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\t_, err := txProc.ProcessTransaction(&tx)\n\tassert.NotNil(t, err)\n}\n\nfunc TestMetaTxProcessor_ProcessCheckNotPassShouldErr(t *testing.T) {\n\tt.Parallel()\n\n\t// these values will trigger ErrHigherNonceInTransaction\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 1\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrHigherNonceInTransaction, err)\n}\n\nfunc TestMetaTxProcessor_ProcessMoveBalancesShouldCallProcessIfError(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = []byte(\"DST\")\n\ttx.Value = big.NewInt(0)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tcalled := false\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\tcalled = true\n\t\t\treturn nil\n\t\t},\n\t}\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, nil, err)\n\tassert.True(t, called)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionScTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, nil\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionScTxShouldReturnErrWhenExecutionFails(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, process.ErrNoVM\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.SCInvoking, process.SCInvoking\n\t\t},\n\t}\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, process.ErrNoVM, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionScTxShouldNotBeCalledWhenAdrDstIsNotInNodeShard(t *testing.T) {\n\tt.Parallel()\n\n\tshardCoordinator := mock.NewOneShardCoordinatorMock()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\n\tshardCoordinator.ComputeIdCalled = func(address []byte) uint32 {\n\t\tif bytes.Equal(address, tx.RcvAddr) {\n\t\t\treturn 1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\tacntSrc.Balance = big.NewInt(45)\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, process.ErrNoVM\n\t}\n\tcalledIfError := false\n\tscProcessorMock.ProcessIfErrorCalled = func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\tcalledIfError = true\n\t\treturn nil\n\t}\n\n\tesdtTransferParser, _ := parsers.NewESDTTransferParser(&mock.MarshalizerMock{})\n\targsTxTypeHandler := coordinator.ArgNewTxTypeHandler{\n\t\tPubkeyConverter:    createMockPubkeyConverter(),\n\t\tShardCoordinator:   shardCoordinator,\n\t\tBuiltInFunctions:   builtInFunctions.NewBuiltInFunctionContainer(),\n\t\tArgumentParser:     parsers.NewCallArgsParser(),\n\t\tESDTTransferParser: esdtTransferParser,\n\t\tEnableEpochsHandler: &testscommon.EnableEpochsHandlerStub{\n\t\t\tIsESDTMetadataContinuousCleanupFlagEnabledField: true,\n\t\t},\n\t}\n\tcomputeType, _ := coordinator.NewTxTypeHandler(argsTxTypeHandler)\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = computeType\n\targs.ShardCoordinator = shardCoordinator\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Equal(t, nil, err)\n\tassert.False(t, wasCalled)\n\tassert.True(t, calledIfError)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionBuiltInCallTxShouldWork(t *testing.T) {\n\tt.Parallel()\n\n\tsaveAccountCalled := 0\n\n\ttx := transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = []byte(\"SRC\")\n\ttx.RcvAddr = generateRandomByteSlice(createMockPubkeyConverter().Len())\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntSrc, err := state.NewUserAccount(tx.SndAddr)\n\tassert.Nil(t, err)\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tacntSrc.Balance = big.NewInt(46)\n\tacntDst.SetCode([]byte{65})\n\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntSrc, acntDst)\n\tadb.SaveAccountCalled = func(account vmcommon.AccountHandler) error {\n\t\tsaveAccountCalled++\n\t\treturn nil\n\t}\n\tscProcessorMock := &testscommon.SCProcessorMock{}\n\n\twasCalled := false\n\tscProcessorMock.ExecuteSmartContractTransactionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\twasCalled = true\n\t\treturn 0, nil\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessorMock\n\targs.TxTypeHandler = &testscommon.TxTypeHandlerMock{\n\t\tComputeTransactionTypeCalled: func(tx data.TransactionHandler) (process.TransactionType, process.TransactionType) {\n\t\t\treturn process.BuiltInFunctionCall, process.BuiltInFunctionCall\n\t\t},\n\t}\n\tenableEpochsHandlerStub := &testscommon.EnableEpochsHandlerStub{\n\t\tIsBuiltInFunctionOnMetaFlagEnabledField: false,\n\t\tIsESDTFlagEnabledField:                  true,\n\t}\n\targs.EnableEpochsHandler = enableEpochsHandlerStub\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, wasCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n\n\tbuiltInCalled := false\n\tscProcessorMock.ExecuteBuiltInFunctionCalled = func(tx data.TransactionHandler, acntSrc, acntDst state.UserAccountHandler) (vmcommon.ReturnCode, error) {\n\t\tbuiltInCalled = true\n\t\treturn 0, nil\n\t}\n\n\tenableEpochsHandlerStub.IsBuiltInFunctionOnMetaFlagEnabledField = true\n\n\t_, err = txProc.ProcessTransaction(&tx)\n\tassert.Nil(t, err)\n\tassert.True(t, builtInCalled)\n\tassert.Equal(t, 0, saveAccountCalled)\n}\n\nfunc TestMetaTxProcessor_ProcessTransactionWithInvalidUsernameShouldNotError(t *testing.T) {\n\tt.Parallel()\n\n\ttx := &transaction.Transaction{}\n\ttx.Nonce = 0\n\ttx.SndAddr = bytes.Repeat([]byte{1}, 32)\n\ttx.RcvAddr = vm.GovernanceSCAddress\n\ttx.RcvUserName = []byte(\"username\")\n\ttx.Value = big.NewInt(45)\n\ttx.GasPrice = 1\n\ttx.GasLimit = 1\n\n\tacntDst, err := state.NewUserAccount(tx.RcvAddr)\n\tassert.Nil(t, err)\n\n\tcalled := false\n\tadb := createAccountStub(tx.SndAddr, tx.RcvAddr, acntDst, acntDst)\n\tscProcessor := &testscommon.SCProcessorMock{\n\t\tProcessIfErrorCalled: func(acntSnd state.UserAccountHandler, txHash []byte, tx data.TransactionHandler, returnCode string, returnMessage []byte, snapshot int, gasLocked uint64) error {\n\t\t\tcalled = true\n\t\t\treturn nil\n\t\t},\n\t}\n\n\targs := createMockNewMetaTxArgs()\n\targs.Accounts = adb\n\targs.ScProcessor = scProcessor\n\targs.ShardCoordinator, _ = sharding.NewMultiShardCoordinator(3, core.MetachainShardId)\n\ttxProc, _ := txproc.NewMetaTxProcessor(args)\n\n\terr = txProc.VerifyTransaction(tx)\n\tassert.Equal(t, err, process.ErrUserNameDoesNotMatchInCrossShardTx)\n\n\treturnCode, err := txProc.ProcessTransaction(tx)\n\tassert.Nil(t, err)\n\tassert.Equal(t, vmcommon.UserError, returnCode)\n\tassert.True(t, called)\n}\n"], "filenames": ["process/transaction/metaProcess.go", "process/transaction/metaProcess_test.go"], "buggy_code_start_loc": [3, 7], "buggy_code_end_loc": [110, 448], "fixing_code_start_loc": [4, 8], "fixing_code_end_loc": [120, 491], "type": "NVD-CWE-noinfo", "message": "mx-chain-go is an implementation of the MultiversX blockchain protocol written in the Go language. Metachain cannot process a cross-shard miniblock. Prior to version 1.4.16, an invalid transaction with the wrong username on metachain is not treated correctly on the metachain transaction processor. This is strictly a processing issue that could have happened on MultiversX chain. If an error like this had occurred, the metachain would have stopped notarizing blocks from the shard chains. The resuming of notarization is possible only after applying a patched binary version. A patch in version 1.4.16 introduces `processIfTxErrorCrossShard` for the metachain transaction processor. There are no known workarounds for this issue.\n", "other": {"cve": {"id": "CVE-2023-33964", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-31T18:15:09.437", "lastModified": "2023-06-07T14:32:11.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mx-chain-go is an implementation of the MultiversX blockchain protocol written in the Go language. Metachain cannot process a cross-shard miniblock. Prior to version 1.4.16, an invalid transaction with the wrong username on metachain is not treated correctly on the metachain transaction processor. This is strictly a processing issue that could have happened on MultiversX chain. If an error like this had occurred, the metachain would have stopped notarizing blocks from the shard chains. The resuming of notarization is possible only after applying a patched binary version. A patch in version 1.4.16 introduces `processIfTxErrorCrossShard` for the metachain transaction processor. There are no known workarounds for this issue.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:multiversx:mx-chain-go:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.4.16", "matchCriteriaId": "97C7E7E5-D0DE-497B-BE07-19D3948CB95B"}]}]}], "references": [{"url": "https://github.com/multiversx/mx-chain-go/commit/97295471465f4b5f79e51b32f8b7111f8d921606", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/multiversx/mx-chain-go/security/advisories/GHSA-7xpv-4pm9-xch2", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/multiversx/mx-chain-go/commit/97295471465f4b5f79e51b32f8b7111f8d921606"}}