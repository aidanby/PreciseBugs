{"buggy_code": ["/*\n * Copyright 2011 Tresys Technology, LLC. All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n * \n *    2. Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY TRESYS TECHNOLOGY, LLC ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL TRESYS TECHNOLOGY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of Tresys Technology, LLC.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#include <sepol/policydb/conditional.h>\n\n#include \"cil_internal.h\"\n#include \"cil_flavor.h\"\n#include \"cil_log.h\"\n#include \"cil_mem.h\"\n#include \"cil_tree.h\"\n#include \"cil_list.h\"\n#include \"cil_parser.h\"\n#include \"cil_build_ast.h\"\n#include \"cil_copy_ast.h\"\n#include \"cil_verify.h\"\n#include \"cil_strpool.h\"\n\nstruct cil_args_build {\n\tstruct cil_tree_node *ast;\n\tstruct cil_db *db;\n\tstruct cil_tree_node *tunif;\n\tstruct cil_tree_node *in;\n\tstruct cil_tree_node *macro;\n\tstruct cil_tree_node *boolif;\n};\n\nint cil_fill_list(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **list)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *curr;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_N_STRINGS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n \n\trc = __cil_verify_syntax(current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n \t}\n\n\tcil_list_init(list, flavor);\n\n\tfor (curr = current; curr != NULL; curr = curr->next) {\n\t\tcil_list_append(*list, CIL_STRING, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstatic int cil_allow_multiple_decls(struct cil_db *db, enum cil_flavor f_new, enum cil_flavor f_old)\n{\n\tif (f_new != f_old) {\n\t\treturn CIL_FALSE;\n\t}\n\n\tswitch (f_new) {\n\tcase CIL_TYPE:\n\tcase CIL_TYPEATTRIBUTE:\n\t\tif (db->multiple_decls) {\n\t\t\treturn CIL_TRUE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn CIL_FALSE;\n}\n\nint cil_add_decl_to_symtab(struct cil_db *db, symtab_t *symtab, hashtab_key_t key, struct cil_symtab_datum *datum, struct cil_tree_node *node)\n{\n\tint rc;\n\n\tif (symtab == NULL || datum == NULL || node == NULL) {\n\t\treturn SEPOL_ERR;\n\t}\n\n\trc = cil_symtab_insert(symtab, key, datum, node);\n\tif (rc == SEPOL_EEXIST) {\n\t\tstruct cil_symtab_datum *prev;\n\t\trc = cil_symtab_get_datum(symtab, key, &prev);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Re-declaration of %s %s, but previous declaration could not be found\\n\",cil_node_to_string(node), key);\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t\tif (!cil_allow_multiple_decls(db, node->flavor, FLAVOR(prev))) {\n\t\t\t/* multiple_decls not ok, ret error */\n\t\t\tstruct cil_tree_node *n = NODE(prev);\n\t\t\tcil_log(CIL_ERR, \"Re-declaration of %s %s\\n\",\n\t\t\t\tcil_node_to_string(node), key);\n\t\t\tcil_tree_log(node, CIL_ERR, \"Previous declaration of %s\",\n\t\t\t\t     cil_node_to_string(n));\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t\t/* multiple_decls is enabled and works for this datum type, add node */\n\t\tcil_list_append(prev->nodes, CIL_NODE, node);\n\t\tnode->data = prev;\n\t\tcil_symtab_datum_destroy(datum);\n\t\tfree(datum);\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_gen_node(struct cil_db *db, struct cil_tree_node *ast_node, struct cil_symtab_datum *datum, hashtab_key_t key, enum cil_sym_index sflavor, enum cil_flavor nflavor)\n{\n\tint rc = SEPOL_ERR;\n\tsymtab_t *symtab = NULL;\n\n\trc = cil_verify_name((const char*)key, nflavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_get_symtab(ast_node->parent, &symtab, sflavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = datum;\n\tast_node->flavor = nflavor;\n\n\trc = cil_add_decl_to_symtab(db, symtab, key, datum, ast_node);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (ast_node->parent->flavor == CIL_MACRO) {\n\t\trc = cil_verify_decl_does_not_shadow_macro_parameter(ast_node->parent->data, ast_node, key);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_clear_node(struct cil_tree_node *ast_node)\n{\n\tif (ast_node == NULL) {\n\t\treturn;\n\t}\n\n\tast_node->data = NULL;\n\tast_node->flavor = CIL_NONE;\n}\n\nint cil_gen_block(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint16_t is_abstract)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_block *block = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_block_init(&block);\n\n\tblock->is_abstract = is_abstract;\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)block, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_BLOCK);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad block declaration\");\n\tcil_destroy_block(block);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_block(struct cil_block *block)\n{\n\tstruct cil_list_item *item;\n\tstruct cil_tree_node *bi_node;\n\tstruct cil_blockinherit *inherit;\n\n\tif (block == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&block->datum);\n\tcil_symtab_array_destroy(block->symtab);\n\tif (block->bi_nodes != NULL) {\n\t\t/* unlink blockinherit->block */\n\t\tcil_list_for_each(item, block->bi_nodes) {\n\t\t\tbi_node = item->data;\n\t\t\t/* the conditions should always be true, but better be sure */\n\t\t\tif (bi_node->flavor == CIL_BLOCKINHERIT) {\n\t\t\t\tinherit = bi_node->data;\n\t\t\t\tif (inherit->block == block) {\n\t\t\t\t\tinherit->block = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcil_list_destroy(&block->bi_nodes, CIL_FALSE);\n\t}\n\n\tfree(block);\n}\n\nint cil_gen_blockinherit(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_blockinherit *inherit = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_blockinherit_init(&inherit);\n\n\tinherit->block_str = parse_current->next->data;\n\n\tast_node->data = inherit;\n\tast_node->flavor = CIL_BLOCKINHERIT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad blockinherit declaration\");\n\tcil_destroy_blockinherit(inherit);\n\treturn rc;\n}\n\nvoid cil_destroy_blockinherit(struct cil_blockinherit *inherit)\n{\n\tif (inherit == NULL) {\n\t\treturn;\n\t}\n\n\tif (inherit->block != NULL && inherit->block->bi_nodes != NULL) {\n\t\tstruct cil_tree_node *node;\n\t\tstruct cil_list_item *item;\n\n\t\tcil_list_for_each(item, inherit->block->bi_nodes) {\n\t\t\tnode = item->data;\n\t\t\tif (node->data == inherit) {\n\t\t\t\tcil_list_remove(inherit->block->bi_nodes, CIL_NODE, node, CIL_FALSE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(inherit);\n}\n\nint cil_gen_blockabstract(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_blockabstract *abstract = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_blockabstract_init(&abstract);\n\n\tabstract->block_str = parse_current->next->data;\n\n\tast_node->data = abstract;\n\tast_node->flavor = CIL_BLOCKABSTRACT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad blockabstract declaration\");\n\tcil_destroy_blockabstract(abstract);\n\treturn rc;\n}\n\nvoid cil_destroy_blockabstract(struct cil_blockabstract *abstract)\n{\n\tif (abstract == NULL) {\n\t\treturn;\n\t}\n\n\tfree(abstract);\n}\n\nint cil_gen_in(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_in *in = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_in_init(&in);\n\n\tin->block_str = parse_current->next->data;\n\n\tast_node->data = in;\n\tast_node->flavor = CIL_IN;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad in statement\");\n\tcil_destroy_in(in);\n\treturn rc;\n}\n\nvoid cil_destroy_in(struct cil_in *in)\n{\n\tif (in == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_array_destroy(in->symtab);\n\n\tfree(in);\n}\n\nint cil_gen_class(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST | CIL_SYN_EMPTY_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_class *class = NULL;\n\tstruct cil_tree_node *perms = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_class_init(&class);\n\n\tkey = parse_current->next->data;\n\tif (key == CIL_KEY_UNORDERED) {\n\t\tcil_log(CIL_ERR, \"'unordered' keyword is reserved and not a valid class name.\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)class, (hashtab_key_t)key, CIL_SYM_CLASSES, CIL_CLASS);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next != NULL) {\n\t\tperms = parse_current->next->next->cl_head;\n\t\trc = cil_gen_perm_nodes(db, perms, ast_node, CIL_PERM, &class->num_perms);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tif (class->num_perms > CIL_PERMS_PER_CLASS) {\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Too many permissions in class '%s'\", class->datum.name);\n\t\t\tgoto exit;\n\t\t}\n\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad class declaration\");\n\tcil_destroy_class(class);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_class(struct cil_class *class)\n{\n\tif (class == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&class->datum);\n\tcil_symtab_destroy(&class->perms);\n\n\tfree(class);\n}\n\nint cil_gen_classorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_classorder *classorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_list_item *head = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc !=  SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classorder_init(&classorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_CLASSORDER, &classorder->class_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\thead = classorder->class_list_str->head;\n\tcil_list_for_each(curr, classorder->class_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tif (curr == head && curr->next == NULL) {\n\t\t\t\tcil_log(CIL_ERR, \"Classorder 'unordered' keyword must be followed by one or more class.\\n\");\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t} else if (curr != head) {\n\t\t\t\tcil_log(CIL_ERR, \"Classorder can only use 'unordered' keyword as the first item in the list.\\n\");\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tast_node->data = classorder;\n\tast_node->flavor = CIL_CLASSORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classorder declaration\");\n\tcil_destroy_classorder(classorder);\n\treturn rc;\n}\n\nvoid cil_destroy_classorder(struct cil_classorder *classorder)\n{\n\tif (classorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (classorder->class_list_str != NULL) {\n\t\tcil_list_destroy(&classorder->class_list_str, 1);\n\t}\n\n\tfree(classorder);\n}\n\nint cil_gen_perm(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor, unsigned int *num_perms)\n{\n\tchar *key = NULL;\n\tstruct cil_perm *perm = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_perm_init(&perm);\n\n\tkey = parse_current->data;\n\tif (key == NULL) {\n\t\tcil_log(CIL_ERR, \"Bad permission\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)perm, (hashtab_key_t)key, CIL_SYM_PERMS, flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tperm->value = *num_perms;\n\t(*num_perms)++;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_destroy_perm(perm);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_perm(struct cil_perm *perm)\n{\n\tif (perm == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&perm->datum);\n\tcil_list_destroy(&perm->classperms, CIL_FALSE);\n\n\tfree(perm);\n}\n\nint cil_gen_perm_nodes(struct cil_db *db, struct cil_tree_node *current_perm, struct cil_tree_node *ast_node, enum cil_flavor flavor, unsigned int *num_perms)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *new_ast = NULL;\n\n\twhile(current_perm != NULL) {\n\t\tif (current_perm->cl_head != NULL) {\n\t\t\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_tree_node_init(&new_ast);\n\t\tnew_ast->parent = ast_node;\n\t\tnew_ast->line = current_perm->line;\n\t\tnew_ast->hll_line = current_perm->hll_line;\n\n\t\trc = cil_gen_perm(db, current_perm, new_ast, flavor, num_perms);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_node_destroy(&new_ast);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (ast_node->cl_head == NULL) {\n\t\t\tast_node->cl_head = new_ast;\n\t\t} else {\n\t\t\tast_node->cl_tail->next = new_ast;\n\t\t}\n\t\tast_node->cl_tail = new_ast;\n\n\t\tcurrent_perm = current_perm->next;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad permissions\\n\");\n\tcil_tree_children_destroy(ast_node);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nint cil_fill_perms(struct cil_tree_node *start_perm, struct cil_list **perms)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_N_STRINGS | CIL_SYN_N_LISTS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(start_perm->cl_head, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_expr(start_perm, CIL_PERM, perms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad permission list or expression\\n\");\n\treturn rc;\n}\n\nint cil_fill_classperms(struct cil_tree_node *parse_current, struct cil_classperms **cp)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classperms_init(cp);\n\n\t(*cp)->class_str = parse_current->data;\n\n\trc = cil_fill_perms(parse_current->next, &(*cp)->perm_strs);\n\tif (rc != SEPOL_OK) {\n\t\tcil_destroy_classperms(*cp);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad class-permissions\\n\");\n\t*cp = NULL;\n\treturn rc;\n}\n\nvoid cil_destroy_classperms(struct cil_classperms *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->perm_strs, CIL_TRUE);\n\tcil_list_destroy(&cp->perms, CIL_FALSE);\n\n\tfree(cp);\n}\n\nvoid cil_fill_classperms_set(struct cil_tree_node *parse_current, struct cil_classperms_set **cp_set)\n{\n\tcil_classperms_set_init(cp_set);\n\t(*cp_set)->set_str = parse_current->data;\n}\n\nvoid cil_destroy_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tfree(cp_set);\n}\n\nint cil_fill_classperms_list(struct cil_tree_node *parse_current, struct cil_list **cp_list)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *curr;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (parse_current == NULL || cp_list == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_init(cp_list, CIL_CLASSPERMS);\n\n\tcurr = parse_current->cl_head;\n\n\tif (curr == NULL) {\n\t\t/* Class-perms form: SET1 */\n\t\tstruct cil_classperms_set *new_cp_set;\n\t\tcil_fill_classperms_set(parse_current, &new_cp_set);\n\t\tcil_list_append(*cp_list, CIL_CLASSPERMS_SET, new_cp_set);\n\t} else if (curr->cl_head == NULL) {\n\t\t/* Class-perms form: (CLASS1 (PERM1 ...)) */\n\t\tstruct cil_classperms *new_cp;\n\t\trc = cil_fill_classperms(curr, &new_cp);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(*cp_list, CIL_CLASSPERMS, new_cp);\n\t} else {\n\t\tcil_log(CIL_ERR, \"Bad class-permissions list syntax\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Problem filling class-permissions list\\n\");\n\tcil_list_destroy(cp_list, CIL_TRUE);\n\treturn rc;\n}\n\nvoid cil_destroy_classperms_list(struct cil_list **cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL || *cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, *cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\tcil_destroy_classperms(curr->data);\n\t\t} else {\n\t\t\tcil_destroy_classperms_set(curr->data);\n\t\t}\n\t}\n\n\tcil_list_destroy(cp_list, CIL_FALSE);\n}\n\nint cil_gen_classpermission(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tchar *key = NULL;\n\tstruct cil_classpermission *cp = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classpermission_init(&cp);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)cp, (hashtab_key_t)key, CIL_SYM_CLASSPERMSETS, CIL_CLASSPERMISSION);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classpermission declaration\");\n\tcil_destroy_classpermission(cp);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tif (cp->datum.name != NULL) {\n\t\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n\t} else {\n\t\t/* anonymous classpermission from call */\n\t\tcil_destroy_classperms_list(&cp->classperms);\n\t}\n\n\tcil_symtab_datum_destroy(&cp->datum);\n\n\n\tfree(cp);\n}\n\nint cil_gen_classpermissionset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_classpermissionset *cps = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classpermissionset_init(&cps);\n\n\tcps->set_str = parse_current->next->data;\n\n\trc = cil_fill_classperms_list(parse_current->next->next, &cps->classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = cps;\n\tast_node->flavor = CIL_CLASSPERMISSIONSET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classpermissionset\");\n\tcil_destroy_classpermissionset(cps);\n\treturn rc;\n}\n\nvoid cil_destroy_classpermissionset(struct cil_classpermissionset *cps)\n{\n\tif (cps == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_classperms_list(&cps->classperms);\n\n\tfree(cps);\n}\n\nint cil_gen_map_class(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_class *map = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_class_init(&map);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)map, (hashtab_key_t)key, CIL_SYM_CLASSES, CIL_MAP_CLASS);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_perm_nodes(db, parse_current->next->next->cl_head, ast_node, CIL_MAP_PERM, &map->num_perms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad map class declaration\");\n\tcil_destroy_class(map);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nint cil_gen_classmapping(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_classmapping *mapping = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classmapping_init(&mapping);\n\n\tmapping->map_class_str = parse_current->next->data;\n\tmapping->map_perm_str = parse_current->next->next->data;\n\n\trc = cil_fill_classperms_list(parse_current->next->next->next, &mapping->classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = mapping;\n\tast_node->flavor = CIL_CLASSMAPPING;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classmapping declaration\");\n\tcil_destroy_classmapping(mapping);\n\treturn rc;\n}\n\nvoid cil_destroy_classmapping(struct cil_classmapping *mapping)\n{\n\tif (mapping == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_classperms_list(&mapping->classperms);\n\n\tfree(mapping);\n}\n\n// TODO try to merge some of this with cil_gen_class (helper function for both)\nint cil_gen_common(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_class *common = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_class_init(&common);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)common, (hashtab_key_t)key, CIL_SYM_COMMONS, CIL_COMMON);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_perm_nodes(db, parse_current->next->next->cl_head, ast_node, CIL_PERM, &common->num_perms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (common->num_perms > CIL_PERMS_PER_CLASS) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Too many permissions in common '%s'\", common->datum.name);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad common declaration\");\n\tcil_destroy_class(common);\n\tcil_clear_node(ast_node);\n\treturn rc;\n\n}\n\nint cil_gen_classcommon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_classcommon *clscom = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classcommon_init(&clscom);\n\n\tclscom->class_str = parse_current->next->data;\n\tclscom->common_str = parse_current->next->next->data;\n\n\tast_node->data = clscom;\n\tast_node->flavor = CIL_CLASSCOMMON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classcommon declaration\");\n\tcil_destroy_classcommon(clscom);\n\treturn rc;\n\n}\n\nvoid cil_destroy_classcommon(struct cil_classcommon *clscom)\n{\n\tif (clscom == NULL) {\n\t\treturn;\n\t}\n\n\tfree(clscom);\n}\n\nint cil_gen_sid(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_sid *sid = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sid_init(&sid);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)sid, (hashtab_key_t)key, CIL_SYM_SIDS, CIL_SID);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sid declaration\");\n\tcil_destroy_sid(sid);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_sid(struct cil_sid *sid)\n{\n\tif (sid == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&sid->datum);\n\tfree(sid);\n}\n\nint cil_gen_sidcontext(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_sidcontext *sidcon = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sidcontext_init(&sidcon);\n\n\tsidcon->sid_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tsidcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&sidcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, sidcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = sidcon;\n\tast_node->flavor = CIL_SIDCONTEXT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sidcontext declaration\");\n\tcil_destroy_sidcontext(sidcon);\n\treturn rc;\n}\n\nvoid cil_destroy_sidcontext(struct cil_sidcontext *sidcon)\n{\n\tif (sidcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (sidcon->context_str == NULL && sidcon->context != NULL) {\n\t\tcil_destroy_context(sidcon->context);\n\t}\n\n\tfree(sidcon);\n}\n\nint cil_gen_sidorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_sidorder *sidorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc !=  SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sidorder_init(&sidorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_SIDORDER, &sidorder->sid_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(curr, sidorder->sid_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tcil_log(CIL_ERR, \"Sidorder cannot be unordered.\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = sidorder;\n\tast_node->flavor = CIL_SIDORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sidorder declaration\");\n\tcil_destroy_sidorder(sidorder);\n\treturn rc;\n}\n\nvoid cil_destroy_sidorder(struct cil_sidorder *sidorder)\n{\n\tif (sidorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (sidorder->sid_list_str != NULL) {\n\t\tcil_list_destroy(&sidorder->sid_list_str, 1);\n\t}\n\n\tfree(sidorder);\n}\n\nint cil_gen_user(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_user *user = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_user_init(&user);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)user, (hashtab_key_t)key, CIL_SYM_USERS, CIL_USER);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad user declaration\");\n\tcil_destroy_user(user);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_user(struct cil_user *user)\n{\n\tif (user == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&user->datum);\n\tebitmap_destroy(user->roles);\n\tfree(user->roles);\n\tfree(user);\n}\n\nint cil_gen_userattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_userattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userattribute_init(&attr);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)attr, (hashtab_key_t)key, CIL_SYM_USERS, CIL_USERATTRIBUTE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userattribute declaration\");\n\tcil_destroy_userattribute(attr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_userattribute(struct cil_userattribute *attr)\n{\n\tstruct cil_list_item *expr = NULL;\n\tstruct cil_list_item *next = NULL;\n\n\tif (attr == NULL) {\n\t\treturn;\n\t}\n\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\texpr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tnext = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\n\tcil_symtab_datum_destroy(&attr->datum);\n\tebitmap_destroy(attr->users);\n\tfree(attr->users);\n\tfree(attr);\n}\n\nint cil_gen_userattributeset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userattributeset *attrset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userattributeset_init(&attrset);\n\n\tattrset->attr_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_USER, &attrset->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tast_node->data = attrset;\n\tast_node->flavor = CIL_USERATTRIBUTESET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userattributeset declaration\");\n\tcil_destroy_userattributeset(attrset);\n\n\treturn rc;\n}\n\nvoid cil_destroy_userattributeset(struct cil_userattributeset *attrset)\n{\n\tif (attrset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&attrset->str_expr, CIL_TRUE);\n\tcil_list_destroy(&attrset->datum_expr, CIL_FALSE);\n\n\tfree(attrset);\n}\n\nint cil_gen_userlevel(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userlevel *usrlvl = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userlevel_init(&usrlvl);\n\n\tusrlvl->user_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tusrlvl->level_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_level_init(&usrlvl->level);\n\n\t\trc = cil_fill_level(parse_current->next->next->cl_head, usrlvl->level);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = usrlvl;\n\tast_node->flavor = CIL_USERLEVEL;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userlevel declaration\");\n\tcil_destroy_userlevel(usrlvl);\n\treturn rc;\n}\n\nvoid cil_destroy_userlevel(struct cil_userlevel *usrlvl)\n{\n\tif (usrlvl == NULL) {\n\t\treturn;\n\t}\n\n\tif (usrlvl->level_str == NULL && usrlvl->level != NULL) {\n\t\tcil_destroy_level(usrlvl->level);\n\t}\n\n\tfree(usrlvl);\n}\n\nint cil_gen_userrange(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userrange *userrange = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userrange_init(&userrange);\n\n\tuserrange->user_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tuserrange->range_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&userrange->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->cl_head, userrange->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = userrange;\n\tast_node->flavor = CIL_USERRANGE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userrange declaration\");\n\tcil_destroy_userrange(userrange);\n\treturn rc;\n}\n\nvoid cil_destroy_userrange(struct cil_userrange *userrange)\n{\n\tif (userrange == NULL) {\n\t\treturn;\n\t}\n\n\tif (userrange->range_str == NULL && userrange->range != NULL) {\n\t\tcil_destroy_levelrange(userrange->range);\n\t}\n\n\tfree(userrange);\n}\n\nint cil_gen_userprefix(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userprefix *userprefix = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userprefix_init(&userprefix);\n\n\tuserprefix->user_str = parse_current->next->data;\n\tuserprefix->prefix_str = parse_current->next->next->data;\n\n\tast_node->data = userprefix;\n\tast_node->flavor = CIL_USERPREFIX;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userprefix declaration\");\n\tcil_destroy_userprefix(userprefix);\n\treturn rc;\n}\n\nvoid cil_destroy_userprefix(struct cil_userprefix *userprefix)\n{\n\tif (userprefix == NULL) {\n\t\treturn;\n\t}\n\n\tfree(userprefix);\n}\n\nint cil_gen_selinuxuser(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_selinuxuser *selinuxuser = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_selinuxuser_init(&selinuxuser);\n\n\tselinuxuser->name_str = parse_current->next->data;\n\tselinuxuser->user_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tselinuxuser->range_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&selinuxuser->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->next->cl_head, selinuxuser->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = selinuxuser;\n\tast_node->flavor = CIL_SELINUXUSER;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad selinuxuser declaration\");\n\tcil_destroy_selinuxuser(selinuxuser);\n\treturn rc;\n}\n\nint cil_gen_selinuxuserdefault(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_selinuxuser *selinuxuser = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_selinuxuser_init(&selinuxuser);\n\n\tselinuxuser->name_str = cil_strpool_add(\"__default__\");\n\tselinuxuser->user_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tselinuxuser->range_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&selinuxuser->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->cl_head, selinuxuser->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = selinuxuser;\n\tast_node->flavor = CIL_SELINUXUSERDEFAULT;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad selinuxuserdefault declaration\");\n\tcil_destroy_selinuxuser(selinuxuser);\n\treturn rc;\n}\n\nvoid cil_destroy_selinuxuser(struct cil_selinuxuser *selinuxuser)\n{\n\tif (selinuxuser == NULL) {\n\t\treturn;\n\t}\n\n\tif (selinuxuser->range_str == NULL && selinuxuser->range != NULL) {\n\t\tcil_destroy_levelrange(selinuxuser->range);\n\t}\n\n\tfree(selinuxuser);\n}\n\nint cil_gen_role(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_role *role = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_role_init(&role);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)role, (hashtab_key_t)key, CIL_SYM_ROLES, CIL_ROLE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad role declaration\");\n\tcil_destroy_role(role);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_role(struct cil_role *role)\n{\n\tif (role == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&role->datum);\n\tebitmap_destroy(role->types);\n\tfree(role->types);\n\tfree(role);\n}\n\nint cil_gen_roletype(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roletype *roletype = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roletype_init(&roletype);\n\n\troletype->role_str = parse_current->next->data;\n\troletype->type_str = parse_current->next->next->data;\n\n\tast_node->data = roletype;\n\tast_node->flavor = CIL_ROLETYPE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roletype declaration\");\n\tcil_destroy_roletype(roletype);\n\treturn rc;\n}\n\nvoid cil_destroy_roletype(struct cil_roletype *roletype)\n{\n\tif (roletype == NULL) {\n\t\treturn;\n\t}\n\n\tfree(roletype);\n}\n\nint cil_gen_userrole(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userrole *userrole = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userrole_init(&userrole);\n\n\tuserrole->user_str = parse_current->next->data;\n\tuserrole->role_str = parse_current->next->next->data;\n\n\tast_node->data = userrole;\n\tast_node->flavor = CIL_USERROLE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userrole declaration\");\n\tcil_destroy_userrole(userrole);\n\treturn rc;\n}\n\nvoid cil_destroy_userrole(struct cil_userrole *userrole)\n{\n\tif (userrole == NULL) {\n\t\treturn;\n\t}\n\n\tfree(userrole);\n}\n\nint cil_gen_roletransition(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roletransition *roletrans = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roletransition_init(&roletrans);\n\n\troletrans->src_str = parse_current->next->data;\n\troletrans->tgt_str = parse_current->next->next->data;\n\troletrans->obj_str = parse_current->next->next->next->data;\n\troletrans->result_str = parse_current->next->next->next->next->data;\n\n\tast_node->data = roletrans;\n\tast_node->flavor = CIL_ROLETRANSITION;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roletransition rule\");\n\tcil_destroy_roletransition(roletrans);\n\treturn rc;\n}\n\nvoid cil_destroy_roletransition(struct cil_roletransition *roletrans)\n{\n\tif (roletrans == NULL) {\n\t\treturn;\n\t}\n\n\tfree(roletrans);\n}\n\nint cil_gen_roleallow(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roleallow *roleallow = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roleallow_init(&roleallow);\n\n\troleallow->src_str = parse_current->next->data;\n\troleallow->tgt_str = parse_current->next->next->data;\n\n\tast_node->data = roleallow;\n\tast_node->flavor = CIL_ROLEALLOW;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roleallow rule\");\n\tcil_destroy_roleallow(roleallow);\n\treturn rc;\n}\n\nvoid cil_destroy_roleallow(struct cil_roleallow *roleallow)\n{\n\tif (roleallow == NULL) {\n\t\treturn;\n\t}\n\n\tfree(roleallow);\n}\n\nint cil_gen_roleattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_roleattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roleattribute_init(&attr);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)attr, (hashtab_key_t)key, CIL_SYM_ROLES, CIL_ROLEATTRIBUTE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roleattribute declaration\");\n\tcil_destroy_roleattribute(attr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_roleattribute(struct cil_roleattribute *attr)\n{\n\tif (attr == NULL) {\n\t\treturn;\n\t}\n\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\n\tcil_symtab_datum_destroy(&attr->datum);\n\tebitmap_destroy(attr->roles);\n\tfree(attr->roles);\n\tfree(attr);\n}\n\nint cil_gen_roleattributeset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roleattributeset *attrset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roleattributeset_init(&attrset);\n\n\tattrset->attr_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_ROLE, &attrset->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tast_node->data = attrset;\n\tast_node->flavor = CIL_ROLEATTRIBUTESET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roleattributeset declaration\");\n\tcil_destroy_roleattributeset(attrset);\n\n\treturn rc;\n}\n\nvoid cil_destroy_roleattributeset(struct cil_roleattributeset *attrset)\n{\n\tif (attrset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&attrset->str_expr, CIL_TRUE);\n\tcil_list_destroy(&attrset->datum_expr, CIL_FALSE);\n\n\tfree(attrset);\n}\n\nint cil_gen_avrule(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint32_t rule_kind)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_avrule *rule = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_avrule_init(&rule);\n\n\trule->is_extended = 0;\n\trule->rule_kind = rule_kind;\n\n\trule->src_str = parse_current->next->data;\n\trule->tgt_str = parse_current->next->next->data;\n\n\trc = cil_fill_classperms_list(parse_current->next->next->next, &rule->perms.classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = rule;\n\tast_node->flavor = CIL_AVRULE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad allow rule\");\n\tcil_destroy_avrule(rule);\n\treturn rc;\n}\n\nvoid cil_destroy_avrule(struct cil_avrule *rule)\n{\n\tif (rule == NULL) {\n\t\treturn;\n\t}\n\n\tif (!rule->is_extended) {\n\t\tcil_destroy_classperms_list(&rule->perms.classperms);\n\t} else {\n\t\tif (rule->perms.x.permx_str == NULL && rule->perms.x.permx != NULL) {\n\t\t\tcil_destroy_permissionx(rule->perms.x.permx);\n\t\t}\n\t}\n\n\tfree(rule);\n}\n\nint cil_fill_permissionx(struct cil_tree_node *parse_current, struct cil_permissionx *permx)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->data == CIL_KEY_IOCTL) {\n\t\tpermx->kind = CIL_PERMX_KIND_IOCTL;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Unknown permissionx kind, %s. Must be \\\"ioctl\\\"\\n\", (char *)parse_current->data);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tpermx->obj_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_PERMISSIONX, &permx->expr_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad permissionx content\");\n\treturn rc;\n}\n\nint cil_gen_permissionx(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_permissionx *permx = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_permissionx_init(&permx);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)permx, (hashtab_key_t)key, CIL_SYM_PERMX, CIL_PERMISSIONX);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_permissionx(parse_current->next->next->cl_head, permx);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad permissionx statement\");\n\tcil_destroy_permissionx(permx);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_permissionx(struct cil_permissionx *permx)\n{\n\tif (permx == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&permx->datum);\n\n\tcil_list_destroy(&permx->expr_str, CIL_TRUE);\n\tebitmap_destroy(permx->perms);\n\tfree(permx->perms);\n\tfree(permx);\n}\n\nint cil_gen_avrulex(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint32_t rule_kind)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_avrule *rule = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_avrule_init(&rule);\n\n\trule->is_extended = 1;\n\trule->rule_kind = rule_kind;\n\trule->src_str = parse_current->next->data;\n\trule->tgt_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\trule->perms.x.permx_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_permissionx_init(&rule->perms.x.permx);\n\n\t\trc = cil_fill_permissionx(parse_current->next->next->next->cl_head, rule->perms.x.permx);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = rule;\n\tast_node->flavor = CIL_AVRULEX;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad allowx rule\");\n\tcil_destroy_avrule(rule);\n\treturn rc;\n}\n\nint cil_gen_type_rule(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint32_t rule_kind)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_type_rule *rule = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_type_rule_init(&rule);\n\n\trule->rule_kind = rule_kind;\n\trule->src_str = parse_current->next->data;\n\trule->tgt_str = parse_current->next->next->data;\n\trule->obj_str = parse_current->next->next->next->data;\n\trule->result_str = parse_current->next->next->next->next->data;\n\n\tast_node->data = rule;\n\tast_node->flavor = CIL_TYPE_RULE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad type rule\");\n\tcil_destroy_type_rule(rule);\n\treturn rc;\n}\n\nvoid cil_destroy_type_rule(struct cil_type_rule *rule)\n{\n\tif (rule == NULL) {\n\t\treturn;\n\t}\n\n\tfree(rule);\n}\n\nint cil_gen_type(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_type *type = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_type_init(&type);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)type, (hashtab_key_t)key, CIL_SYM_TYPES, CIL_TYPE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad type declaration\");\n\tcil_destroy_type(type);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_type(struct cil_type *type)\n{\n\tif (type == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&type->datum);\n\tfree(type);\n}\n\nint cil_gen_typeattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_typeattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_typeattribute_init(&attr);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)attr, (hashtab_key_t)key, CIL_SYM_TYPES, CIL_TYPEATTRIBUTE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typeattribute declaration\");\n\tcil_destroy_typeattribute(attr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_typeattribute(struct cil_typeattribute *attr)\n{\n\tif (attr == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&attr->datum);\n\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\tebitmap_destroy(attr->types);\n\tfree(attr->types);\n\tfree(attr);\n}\n\nint cil_gen_bool(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, int tunableif)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_bool *boolean = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_bool_init(&boolean);\n\n\tkey = parse_current->next->data;\n\n\tif (parse_current->next->next->data == CIL_KEY_CONDTRUE) {\n\t\tboolean->value = CIL_TRUE;\n\t} else if (parse_current->next->next->data == CIL_KEY_CONDFALSE) {\n\t\tboolean->value = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)boolean, (hashtab_key_t)key, CIL_SYM_BOOLS, CIL_BOOL);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tif (tunableif) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunable (treated as a boolean due to preserve-tunables) declaration\");\n\t} else {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad boolean declaration\");\n\t}\n\tcil_destroy_bool(boolean);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_bool(struct cil_bool *boolean)\n{\n\tif (boolean == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&boolean->datum);\n\tfree(boolean);\n}\n\nint cil_gen_tunable(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_tunable *tunable = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_tunable_init(&tunable);\n\n\tkey = parse_current->next->data;\n\n\tif (parse_current->next->next->data == CIL_KEY_CONDTRUE) {\n\t\ttunable->value = CIL_TRUE;\n\t} else if (parse_current->next->next->data == CIL_KEY_CONDFALSE) {\n\t\ttunable->value = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)tunable, (hashtab_key_t)key, CIL_SYM_TUNABLES, CIL_TUNABLE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunable declaration\");\n\tcil_destroy_tunable(tunable);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_tunable(struct cil_tunable *tunable)\n{\n\tif (tunable == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&tunable->datum);\n\tfree(tunable);\n}\n\nstatic enum cil_flavor __cil_get_expr_operator_flavor(const char *op)\n{\n\tif (op == NULL) return CIL_NONE;\n\telse if (op == CIL_KEY_AND)   return CIL_AND;\n\telse if (op == CIL_KEY_OR)    return CIL_OR;\n\telse if (op == CIL_KEY_NOT)   return CIL_NOT;\n\telse if (op == CIL_KEY_EQ)    return CIL_EQ;    /* Only conditional */\n\telse if (op == CIL_KEY_NEQ)   return CIL_NEQ;   /* Only conditional */\n\telse if (op == CIL_KEY_XOR)   return CIL_XOR;\n\telse if (op == CIL_KEY_ALL)   return CIL_ALL;   /* Only set and permissionx */\n\telse if (op == CIL_KEY_RANGE) return CIL_RANGE; /* Only catset and permissionx */\n\telse return CIL_NONE;\n}\n\nstatic int __cil_fill_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list *expr);\n\nstatic int __cil_fill_expr_helper(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list *expr)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_flavor op;\n\n\top = __cil_get_expr_operator_flavor(current->data);\n\n\trc = cil_verify_expr_syntax(current, op, flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (op != CIL_NONE) {\n\t\tcil_list_append(expr, CIL_OP, (void *)op);\n\t\tcurrent = current->next;\n\t}\n\n\tfor (;current != NULL; current = current->next) {\n\t\trc = __cil_fill_expr(current, flavor, expr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstatic int __cil_fill_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list *expr)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (current->cl_head == NULL) {\n\t\tenum cil_flavor op = __cil_get_expr_operator_flavor(current->data);\n\t\tif (op != CIL_NONE) {\n\t\t\tcil_log(CIL_ERR, \"Operator (%s) not in an expression\\n\", (char*)current->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(expr, CIL_STRING, current->data);\n\t} else {\n\t\tstruct cil_list *sub_expr;\n\t\tcil_list_init(&sub_expr, flavor);\n\t\trc = __cil_fill_expr_helper(current->cl_head, flavor, sub_expr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_list_destroy(&sub_expr, CIL_TRUE);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(expr, CIL_LIST, sub_expr);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\nint cil_gen_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **expr)\n{\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(expr, flavor);\n\n\tif (current->cl_head == NULL) {\n\t\trc = __cil_fill_expr(current, flavor, *expr);\n\t} else {\n\t\trc = __cil_fill_expr_helper(current->cl_head, flavor, *expr);\n\t}\n\n\tif (rc != SEPOL_OK) {\n\t\tcil_list_destroy(expr, CIL_TRUE);\n\t\tcil_log(CIL_ERR, \"Bad expression\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic enum cil_flavor __cil_get_constraint_operator_flavor(const char *op)\n{\n\tif (op == CIL_KEY_AND)         return CIL_AND;\n\telse if (op == CIL_KEY_OR)     return CIL_OR;\n\telse if (op == CIL_KEY_NOT)    return CIL_NOT;\n\telse if (op == CIL_KEY_EQ)     return CIL_EQ;\n\telse if (op == CIL_KEY_NEQ)    return CIL_NEQ;\n\telse if (op == CIL_KEY_CONS_DOM)    return CIL_CONS_DOM;\n\telse if (op == CIL_KEY_CONS_DOMBY)  return CIL_CONS_DOMBY;\n\telse if (op == CIL_KEY_CONS_INCOMP) return CIL_CONS_INCOMP;\n\telse return CIL_NONE;\n}\n\nstatic enum cil_flavor __cil_get_constraint_operand_flavor(const char *operand)\n{\n\tif (operand == NULL) return CIL_LIST;\n\telse if (operand == CIL_KEY_CONS_T1) return CIL_CONS_T1;\n\telse if (operand == CIL_KEY_CONS_T2) return CIL_CONS_T2;\n\telse if (operand == CIL_KEY_CONS_T3) return CIL_CONS_T3;\n\telse if (operand == CIL_KEY_CONS_R1) return CIL_CONS_R1;\n\telse if (operand == CIL_KEY_CONS_R2) return CIL_CONS_R2;\n\telse if (operand == CIL_KEY_CONS_R3) return CIL_CONS_R3;\n\telse if (operand == CIL_KEY_CONS_U1) return CIL_CONS_U1;\n\telse if (operand == CIL_KEY_CONS_U2) return CIL_CONS_U2;\n\telse if (operand == CIL_KEY_CONS_U3) return CIL_CONS_U3;\n\telse if (operand == CIL_KEY_CONS_L1) return CIL_CONS_L1;\n\telse if (operand == CIL_KEY_CONS_L2) return CIL_CONS_L2;\n\telse if (operand == CIL_KEY_CONS_H1) return CIL_CONS_H1;\n\telse if (operand == CIL_KEY_CONS_H2) return CIL_CONS_H2;\n\telse return CIL_STRING;\n}\n\nstatic int __cil_fill_constraint_leaf_expr(struct cil_tree_node *current, enum cil_flavor expr_flavor, enum cil_flavor op, struct cil_list **leaf_expr)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_flavor leaf_expr_flavor = CIL_NONE;\n\tenum cil_flavor l_flavor = CIL_NONE;\n\tenum cil_flavor r_flavor = CIL_NONE;\n\n\tl_flavor = __cil_get_constraint_operand_flavor(current->next->data);\n\tr_flavor = __cil_get_constraint_operand_flavor(current->next->next->data);\n\n\tswitch (l_flavor) {\n\tcase CIL_CONS_U1:\n\tcase CIL_CONS_U2:\n\tcase CIL_CONS_U3:\n\t\tleaf_expr_flavor = CIL_USER;\n\t\tbreak;\n\tcase CIL_CONS_R1:\n\tcase CIL_CONS_R2:\n\tcase CIL_CONS_R3:\n\t\tleaf_expr_flavor = CIL_ROLE;\n\t\tbreak;\n\tcase CIL_CONS_T1:\n\tcase CIL_CONS_T2:\n\tcase CIL_CONS_T3:\n\t\tleaf_expr_flavor = CIL_TYPE;\n\t\tbreak;\n\tcase CIL_CONS_L1:\n\tcase CIL_CONS_L2:\n\tcase CIL_CONS_H1:\n\tcase CIL_CONS_H2:\n\t\tleaf_expr_flavor = CIL_LEVEL;\n\t\tbreak;\n\tdefault:\n\t\tcil_log(CIL_ERR, \"Invalid left operand (%s)\\n\", (char*)current->next->data);\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_constraint_leaf_expr_syntax(l_flavor, r_flavor, op, expr_flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_init(leaf_expr, leaf_expr_flavor);\n\n\tcil_list_append(*leaf_expr, CIL_OP, (void *)op);\n\n\tcil_list_append(*leaf_expr, CIL_CONS_OPERAND, (void *)l_flavor);\n\n\tif (r_flavor == CIL_STRING) {\n\t\tcil_list_append(*leaf_expr, CIL_STRING, current->next->next->data);\n\t} else if (r_flavor == CIL_LIST) {\n\t\tstruct cil_list *sub_list;\n\t\trc = cil_fill_list(current->next->next->cl_head, leaf_expr_flavor, &sub_list);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_list_destroy(leaf_expr, CIL_TRUE);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(*leaf_expr, CIL_LIST, sub_list);\n\t} else {\n\t\tcil_list_append(*leaf_expr, CIL_CONS_OPERAND, (void *)r_flavor);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\n\treturn SEPOL_ERR;\n}\n\nstatic int __cil_fill_constraint_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **expr)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_flavor op;\n\tstruct cil_list *lexpr;\n\tstruct cil_list *rexpr;\n\n\tif (current->data == NULL || current->cl_head != NULL) {\n\t\tcil_log(CIL_ERR, \"Expected a string at the start of the constraint expression\\n\");\n\t\tgoto exit;\n\t}\n\n\top = __cil_get_constraint_operator_flavor(current->data);\n\n\trc = cil_verify_constraint_expr_syntax(current, op);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tswitch (op) {\n\tcase CIL_EQ:\n\tcase CIL_NEQ:\n\tcase CIL_CONS_DOM:\n\tcase CIL_CONS_DOMBY:\n\tcase CIL_CONS_INCOMP:\n\t\trc = __cil_fill_constraint_leaf_expr(current, flavor, op, expr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase CIL_NOT:\n\t\trc = __cil_fill_constraint_expr(current->next->cl_head, flavor, &lexpr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_init(expr, flavor);\n\t\tcil_list_append(*expr, CIL_OP, (void *)op);\n\t\tcil_list_append(*expr, CIL_LIST, lexpr);\n\t\tbreak;\n\tdefault:\n\t\trc = __cil_fill_constraint_expr(current->next->cl_head, flavor, &lexpr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trc = __cil_fill_constraint_expr(current->next->next->cl_head, flavor, &rexpr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_list_destroy(&lexpr, CIL_TRUE);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_init(expr, flavor);\n\t\tcil_list_append(*expr, CIL_OP, (void *)op);\n\t\tcil_list_append(*expr, CIL_LIST, lexpr);\n\t\tcil_list_append(*expr, CIL_LIST, rexpr);\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\n\treturn rc;\n}\n\nint cil_gen_constraint_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **expr)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (current->cl_head == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_fill_constraint_expr(current->cl_head, flavor, expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\n\tcil_log(CIL_ERR, \"Bad expression tree for constraint\\n\");\n\treturn rc;\n}\n\nint cil_gen_boolif(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, int tunableif)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_booleanif *bif = NULL;\n\tstruct cil_tree_node *next = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_boolif_init(&bif);\n\tbif->preserved_tunable = tunableif;\n\n\trc = cil_gen_expr(parse_current->next, CIL_BOOL, &bif->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_conditional_blocks(parse_current->next->next);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t/* Destroying expr tree */\n\tnext = parse_current->next->next;\n\tcil_tree_subtree_destroy(parse_current->next);\n\tparse_current->next = next;\n\n\tast_node->flavor = CIL_BOOLEANIF;\n\tast_node->data = bif;\n\n\treturn SEPOL_OK;\n\nexit:\n\tif (tunableif) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunableif (treated as a booleanif due to preserve-tunables) declaration\");\n\t} else {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad booleanif declaration\");\n\t}\n\tcil_destroy_boolif(bif);\n\treturn rc;\n}\n\nvoid cil_destroy_boolif(struct cil_booleanif *bif)\n{\n\tif (bif == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&bif->str_expr, CIL_TRUE);\n\tcil_list_destroy(&bif->datum_expr, CIL_FALSE);\n\n\tfree(bif);\n}\n\nint cil_gen_tunif(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_tunableif *tif = NULL;\n\tstruct cil_tree_node *next = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_tunif_init(&tif);\n\n\trc = cil_gen_expr(parse_current->next, CIL_TUNABLE, &tif->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_conditional_blocks(parse_current->next->next);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t/* Destroying expr tree */\n\tnext = parse_current->next->next;\n\tcil_tree_subtree_destroy(parse_current->next);\n\tparse_current->next = next;\n\n\tast_node->flavor = CIL_TUNABLEIF;\n\tast_node->data = tif;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunableif declaration\");\n\tcil_destroy_tunif(tif);\n\treturn rc;\n}\n\nvoid cil_destroy_tunif(struct cil_tunableif *tif)\n{\n\tif (tif == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&tif->str_expr, CIL_TRUE);\n\tcil_list_destroy(&tif->datum_expr, CIL_FALSE);\n\n\tfree(tif);\n}\n\nint cil_gen_condblock(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_condblock *cb = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (ast_node->parent->flavor != CIL_BOOLEANIF && ast_node->parent->flavor != CIL_TUNABLEIF) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Conditional statements must be a direct child of a tunableif or booleanif statement.\\n\");\n\t\tgoto exit;\n\t}\n\n\tast_node->flavor = CIL_CONDBLOCK;\n\n\tcil_condblock_init(&cb);\n\tcb->flavor = flavor;\n\n\tast_node->data = cb;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s condition declaration\",\n\t\t(char*)parse_current->data);\n\tcil_destroy_condblock(cb);\n\treturn rc;\n}\n\nvoid cil_destroy_condblock(struct cil_condblock *cb)\n{\n\tif (cb == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_array_destroy(cb->symtab);\n\tfree(cb);\n}\n\nint cil_gen_alias(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_alias *alias = NULL;\n\tenum cil_sym_index sym_index;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_alias_init(&alias);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_flavor_to_symtab_index(flavor, &sym_index);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)alias, (hashtab_key_t)key, sym_index, flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s declaration\", (char*)parse_current->data);\n\tcil_destroy_alias(alias);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_alias(struct cil_alias *alias)\n{\n\tif (alias == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&alias->datum);\n\talias->actual = NULL;\n\n\tfree(alias);\n}\n\nint cil_gen_aliasactual(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_aliasactual *aliasactual = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif ((flavor == CIL_TYPEALIAS && parse_current->next->data == CIL_KEY_SELF) || parse_current->next->next->data == CIL_KEY_SELF) {\n\t\tcil_log(CIL_ERR, \"The keyword '%s' is reserved\\n\", CIL_KEY_SELF);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tcil_aliasactual_init(&aliasactual);\n\n\taliasactual->alias_str = parse_current->next->data;\n\n\taliasactual->actual_str = parse_current->next->next->data;\n\n\tast_node->data = aliasactual;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s association\", cil_node_to_string(parse_current));\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_aliasactual(struct cil_aliasactual *aliasactual)\n{\n\tif (aliasactual == NULL) {\n\t\treturn;\n\t}\n\n\tfree(aliasactual);\n}\n\nint cil_gen_typeattributeset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_typeattributeset *attrset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_typeattributeset_init(&attrset);\n\n\tattrset->attr_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_TYPE, &attrset->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tast_node->data = attrset;\n\tast_node->flavor = CIL_TYPEATTRIBUTESET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typeattributeset statement\");\n\tcil_destroy_typeattributeset(attrset);\n\treturn rc;\n}\n\nvoid cil_destroy_typeattributeset(struct cil_typeattributeset *attrset)\n{\n\tif (attrset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&attrset->str_expr, CIL_TRUE);\n\tcil_list_destroy(&attrset->datum_expr, CIL_FALSE);\n\n\tfree(attrset);\n}\n\nint cil_gen_expandtypeattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tchar *expand_str;\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_expandtypeattribute *expandattr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_expandtypeattribute_init(&expandattr);\n\n\tif (parse_current->next->cl_head == NULL) {\n\t\tcil_list_init(&expandattr->attr_strs, CIL_TYPE);\n\t\tcil_list_append(expandattr->attr_strs, CIL_STRING, parse_current->next->data);\n\t} else {\n\t\trc = cil_fill_list(parse_current->next->cl_head, CIL_TYPE, &expandattr->attr_strs);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\texpand_str = parse_current->next->next->data;\n\n\tif (expand_str == CIL_KEY_CONDTRUE) {\n\t\texpandattr->expand = CIL_TRUE;\n\t} else if (expand_str == CIL_KEY_CONDFALSE) {\n\t\texpandattr->expand = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\tgoto exit;\n\t}\n\n\tast_node->data = expandattr;\n\tast_node->flavor = CIL_EXPANDTYPEATTRIBUTE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad expandtypeattribute statement\");\n\tcil_destroy_expandtypeattribute(expandattr);\n\treturn rc;\n}\n\nvoid cil_destroy_expandtypeattribute(struct cil_expandtypeattribute *expandattr)\n{\n\tif (expandattr == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&expandattr->attr_strs, CIL_TRUE);\n\n\tcil_list_destroy(&expandattr->attr_datums, CIL_FALSE);\n\n\tfree(expandattr);\n}\n\nint cil_gen_typepermissive(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_typepermissive *typeperm = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_typepermissive_init(&typeperm);\n\n\ttypeperm->type_str = parse_current->next->data;\n\n\tast_node->data = typeperm;\n\tast_node->flavor = CIL_TYPEPERMISSIVE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typepermissive declaration\");\n\tcil_destroy_typepermissive(typeperm);\n\treturn rc;\n}\n\nvoid cil_destroy_typepermissive(struct cil_typepermissive *typeperm)\n{\n\tif (typeperm == NULL) {\n\t\treturn;\n\t}\n\n\tfree(typeperm);\n}\n\nint cil_gen_typetransition(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *s1, *s2, *s3, *s4, *s5;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL ) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ts1 = parse_current->next->data;\n\ts2 = parse_current->next->next->data;\n\ts3 = parse_current->next->next->next->data;\n\ts4 = parse_current->next->next->next->next->data;\n\ts5 = NULL;\n\n\tif (parse_current->next->next->next->next->next) {\n\t\tif (s4 == CIL_KEY_STAR) {\n\t\t\ts4 = parse_current->next->next->next->next->next->data;\n\t\t} else {\n\t\t\ts5 = parse_current->next->next->next->next->next->data;\n\t\t}\n\t}\n\n\tif (s5) {\n\t\tstruct cil_nametypetransition *nametypetrans = NULL;\n\n\t\tcil_nametypetransition_init(&nametypetrans);\n\n\t\tnametypetrans->src_str = s1;\n\t\tnametypetrans->tgt_str = s2;\n\t\tnametypetrans->obj_str = s3;\n\t\tnametypetrans->result_str = s5;\n\t\tnametypetrans->name_str = s4;\n\n\t\tast_node->data = nametypetrans;\n\t\tast_node->flavor = CIL_NAMETYPETRANSITION;\n\t} else {\n\t\tstruct cil_type_rule *rule = NULL;\n\n\t\tcil_type_rule_init(&rule);\n\n\t\trule->rule_kind = CIL_TYPE_TRANSITION;\n\t\trule->src_str = s1;\n\t\trule->tgt_str = s2;\n\t\trule->obj_str = s3;\n\t\trule->result_str = s4;\n\n\t\tast_node->data = rule;\n\t\tast_node->flavor = CIL_TYPE_RULE;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typetransition declaration\");\n\treturn rc;\n}\n\nvoid cil_destroy_name(struct cil_name *name)\n{\n\tif (name == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&name->datum);\n\tfree(name);\n}\n\nvoid cil_destroy_typetransition(struct cil_nametypetransition *nametypetrans)\n{\n\tif (nametypetrans == NULL) {\n\t\treturn;\n\t}\n\n\tfree(nametypetrans);\n}\n\nint cil_gen_rangetransition(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_rangetransition *rangetrans = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL ) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_rangetransition_init(&rangetrans);\n\n\trangetrans->src_str = parse_current->next->data;\n\trangetrans->exec_str = parse_current->next->next->data;\n\trangetrans->obj_str = parse_current->next->next->next->data;\n\n\trangetrans->range_str = NULL;\n\n\tif (parse_current->next->next->next->next->cl_head == NULL) {\n\t\trangetrans->range_str = parse_current->next->next->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&rangetrans->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->next->next->cl_head, rangetrans->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = rangetrans;\n\tast_node->flavor = CIL_RANGETRANSITION;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad rangetransition declaration\");\n\tcil_destroy_rangetransition(rangetrans);\n\treturn rc;\n}\n\nvoid cil_destroy_rangetransition(struct cil_rangetransition *rangetrans)\n{\n\tif (rangetrans == NULL) {\n\t\treturn;\n\t}\n\n\tif (rangetrans->range_str == NULL && rangetrans->range != NULL) {\n\t\tcil_destroy_levelrange(rangetrans->range);\n\t}\n\n\tfree(rangetrans);\n}\n\nint cil_gen_sensitivity(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_sens *sens = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sens_init(&sens);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)sens, (hashtab_key_t)key, CIL_SYM_SENS, CIL_SENS);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sensitivity declaration\");\n\tcil_destroy_sensitivity(sens);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_sensitivity(struct cil_sens *sens)\n{\n\tif (sens == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&sens->datum);\n\n\tcil_list_destroy(&sens->cats_list, CIL_FALSE);\n\n\tfree(sens);\n}\n\nint cil_gen_category(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_cat *cat = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_cat_init(&cat);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)cat, (hashtab_key_t)key, CIL_SYM_CATS, CIL_CAT);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad category declaration\");\n\tcil_destroy_category(cat);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_category(struct cil_cat *cat)\n{\n\tif (cat == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&cat->datum);\n\tfree(cat);\n}\n\nint cil_gen_catset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_catset *catset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_catset_init(&catset);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)catset, (hashtab_key_t)key, CIL_SYM_CATS, CIL_CATSET);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_cats(parse_current->next->next, &catset->cats);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad categoryset declaration\");\n\tcil_destroy_catset(catset);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_catset(struct cil_catset *catset)\n{\n\tif (catset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&catset->datum);\n\n\tcil_destroy_cats(catset->cats);\n\n\tfree(catset);\n}\n\nint cil_gen_catorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_catorder *catorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc !=  SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_catorder_init(&catorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_CATORDER, &catorder->cat_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(curr, catorder->cat_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tcil_log(CIL_ERR, \"Category order cannot be unordered.\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = catorder;\n\tast_node->flavor = CIL_CATORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad categoryorder declaration\");\n\tcil_destroy_catorder(catorder);\n\treturn rc;\n}\n\nvoid cil_destroy_catorder(struct cil_catorder *catorder)\n{\n\tif (catorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (catorder->cat_list_str != NULL) {\n\t\tcil_list_destroy(&catorder->cat_list_str, 1);\n\t}\n\n\tfree(catorder);\n}\n\nint cil_gen_sensitivityorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_sensorder *sensorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sensorder_init(&sensorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_SENSITIVITYORDER, &sensorder->sens_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(curr, sensorder->sens_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tcil_log(CIL_ERR, \"Sensitivy order cannot be unordered.\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = sensorder;\n\tast_node->flavor = CIL_SENSITIVITYORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sensitivityorder declaration\");\n\tcil_destroy_sensitivityorder(sensorder);\n\treturn rc;\n}\n\nvoid cil_destroy_sensitivityorder(struct cil_sensorder *sensorder)\n{\n\tif (sensorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (sensorder->sens_list_str != NULL) {\n\t\tcil_list_destroy(&sensorder->sens_list_str, CIL_TRUE);\n\t}\n\n\tfree(sensorder);\n}\n\nint cil_gen_senscat(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_senscat *senscat = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_senscat_init(&senscat);\n\n\tsenscat->sens_str = parse_current->next->data;\n\n\trc = cil_fill_cats(parse_current->next->next, &senscat->cats);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = senscat;\n\tast_node->flavor = CIL_SENSCAT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sensitivitycategory declaration\");\n\tcil_destroy_senscat(senscat);\n\treturn rc;\n}\n\nvoid cil_destroy_senscat(struct cil_senscat *senscat)\n{\n\tif (senscat == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_cats(senscat->cats);\n\n\tfree(senscat);\n}\n\nint cil_gen_level(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_level *level = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_level_init(&level);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)level, (hashtab_key_t)key, CIL_SYM_LEVELS, CIL_LEVEL);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_level(parse_current->next->next->cl_head, level);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad level declaration\");\n\tcil_destroy_level(level);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_level(struct cil_level *level)\n{\n\tif (level == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&level->datum);\n\n\tcil_destroy_cats(level->cats);\n\n\tfree(level);\n}\n\n/* low should be pointing to either the name of the low level or to an open paren for an anonymous low level */\nint cil_fill_levelrange(struct cil_tree_node *low, struct cil_levelrange *lvlrange)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\n\tif (low == NULL || lvlrange == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(low, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\n\t\tgoto exit;\n\t}\n\n\tif (low->cl_head == NULL) {\n\t\tlvlrange->low_str = low->data;\n\t} else {\n\t\tcil_level_init(&lvlrange->low);\n\t\trc = cil_fill_level(low->cl_head, lvlrange->low);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (low->next->cl_head == NULL) {\n\t\tlvlrange->high_str = low->next->data;\n\t} else {\n\t\tcil_level_init(&lvlrange->high);\n\t\trc = cil_fill_level(low->next->cl_head, lvlrange->high);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad levelrange\\n\");\n\treturn rc;\n}\n\nint cil_gen_levelrange(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_levelrange *lvlrange = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_levelrange_init(&lvlrange);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)lvlrange, (hashtab_key_t)key, CIL_SYM_LEVELRANGES, CIL_LEVELRANGE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_levelrange(parse_current->next->next->cl_head, lvlrange);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad levelrange declaration\");\n\tcil_destroy_levelrange(lvlrange);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_levelrange(struct cil_levelrange *lvlrange)\n{\n\tif (lvlrange == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&lvlrange->datum);\n\n\tif (lvlrange->low_str == NULL) {\n\t\tcil_destroy_level(lvlrange->low);\n\t}\n\n\tif (lvlrange->high_str == NULL) {\n\t\tcil_destroy_level(lvlrange->high);\n\t}\n\n\tfree(lvlrange);\n}\n\nint cil_gen_constrain(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_constrain *cons = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_constrain_init(&cons);\n\n\trc = cil_fill_classperms_list(parse_current->next, &cons->classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_constraint_expr(parse_current->next->next, flavor, &cons->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = cons;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad constrain declaration\");\n\tcil_destroy_constrain(cons);\n\treturn rc;\n}\n\nvoid cil_destroy_constrain(struct cil_constrain *cons)\n{\n\tif (cons == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_classperms_list(&cons->classperms);\n\tcil_list_destroy(&cons->str_expr, CIL_TRUE);\n\tcil_list_destroy(&cons->datum_expr, CIL_FALSE);\n\n\tfree(cons);\n}\n\nint cil_gen_validatetrans(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_validatetrans *validtrans = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_validatetrans_init(&validtrans);\n\n\tvalidtrans->class_str = parse_current->next->data;\n\n\trc = cil_gen_constraint_expr(parse_current->next->next, flavor, &validtrans->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = validtrans;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad validatetrans declaration\");\n\tcil_destroy_validatetrans(validtrans);\n\treturn rc;\n\n\n}\n\nvoid cil_destroy_validatetrans(struct cil_validatetrans *validtrans)\n{\n\tif (validtrans == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&validtrans->str_expr, CIL_TRUE);\n\tcil_list_destroy(&validtrans->datum_expr, CIL_FALSE);\n\n\tfree(validtrans);\n}\n\n/* Fills in context starting from user */\nint cil_fill_context(struct cil_tree_node *user_node, struct cil_context *context)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\n\tif (user_node == NULL || context == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(user_node, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcontext->user_str = user_node->data;\n\tcontext->role_str = user_node->next->data;\n\tcontext->type_str = user_node->next->next->data;\n\n\tcontext->range_str = NULL;\n\n\tif (user_node->next->next->next->cl_head == NULL) {\n\t\tcontext->range_str = user_node->next->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&context->range);\n\n\t\trc = cil_fill_levelrange(user_node->next->next->next->cl_head, context->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad context\\n\");\n\treturn rc;\n}\n\nint cil_gen_context(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_context *context = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_context_init(&context);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)context, (hashtab_key_t)key, CIL_SYM_CONTEXTS, CIL_CONTEXT);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_context(parse_current->next->next->cl_head, context);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad context declaration\");\n\tcil_destroy_context(context);\n\tcil_clear_node(ast_node);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_context(struct cil_context *context)\n{\n\tif (context == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&context->datum);;\n\n\tif (context->range_str == NULL && context->range != NULL) {\n\t\tcil_destroy_levelrange(context->range);\n\t}\n\n\tfree(context);\n}\n\nint cil_gen_filecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST | CIL_SYN_EMPTY_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_filecon *filecon = NULL;\n\tchar *type = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ttype = parse_current->next->next->data;\n\tcil_filecon_init(&filecon);\n\n\tfilecon->path_str = parse_current->next->data;\n\n\tif (type == CIL_KEY_FILE) {\n\t\tfilecon->type = CIL_FILECON_FILE;\n\t} else if (type == CIL_KEY_DIR) {\n\t\tfilecon->type = CIL_FILECON_DIR;\n\t} else if (type == CIL_KEY_CHAR) {\n\t\tfilecon->type = CIL_FILECON_CHAR;\n\t} else if (type == CIL_KEY_BLOCK) {\n\t\tfilecon->type = CIL_FILECON_BLOCK;\n\t} else if (type == CIL_KEY_SOCKET) {\n\t\tfilecon->type = CIL_FILECON_SOCKET;\n\t} else if (type == CIL_KEY_PIPE) {\n\t\tfilecon->type = CIL_FILECON_PIPE;\n\t} else if (type == CIL_KEY_SYMLINK) {\n\t\tfilecon->type = CIL_FILECON_SYMLINK;\n\t} else if (type == CIL_KEY_ANY) {\n\t\tfilecon->type = CIL_FILECON_ANY;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Invalid file type\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tfilecon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tif (parse_current->next->next->next->cl_head->next == NULL) {\n\t\t\tfilecon->context = NULL;\n\t\t} else {\n\t\t\tcil_context_init(&filecon->context);\n\n\t\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, filecon->context);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tast_node->data = filecon;\n\tast_node->flavor = CIL_FILECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad filecon declaration\");\n\tcil_destroy_filecon(filecon);\n\treturn rc;\n}\n\n//TODO: Should we be checking if the pointer is NULL when passed in?\nvoid cil_destroy_filecon(struct cil_filecon *filecon)\n{\n\tif (filecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (filecon->context_str == NULL && filecon->context != NULL) {\n\t\tcil_destroy_context(filecon->context);\n\t}\n\n\tfree(filecon);\n}\n\nint cil_gen_ibpkeycon(__attribute__((unused)) struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax) / sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_ibpkeycon *ibpkeycon = NULL;\n\n\tif (!parse_current || !ast_node)\n\t\tgoto exit;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\tcil_ibpkeycon_init(&ibpkeycon);\n\n\tibpkeycon->subnet_prefix_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head) {\n\t\tif (parse_current->next->next->cl_head->next &&\n\t\t    !parse_current->next->next->cl_head->next->next) {\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head, &ibpkeycon->pkey_low, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ibpkey specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head->next, &ibpkeycon->pkey_high, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ibpkey specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper ibpkey range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer(parse_current->next->next, &ibpkeycon->pkey_low, 0);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper ibpkey specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tibpkeycon->pkey_high = ibpkeycon->pkey_low;\n\t}\n\n\tif (!parse_current->next->next->next->cl_head) {\n\t\tibpkeycon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&ibpkeycon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, ibpkeycon->context);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\tast_node->data = ibpkeycon;\n\tast_node->flavor = CIL_IBPKEYCON;\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ibpkeycon declaration\");\n\tcil_destroy_ibpkeycon(ibpkeycon);\n\n\treturn rc;\n}\n\nvoid cil_destroy_ibpkeycon(struct cil_ibpkeycon *ibpkeycon)\n{\n\tif (!ibpkeycon)\n\t\treturn;\n\n\tif (!ibpkeycon->context_str && ibpkeycon->context)\n\t\tcil_destroy_context(ibpkeycon->context);\n\n\tfree(ibpkeycon);\n}\n\nint cil_gen_portcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_portcon *portcon = NULL;\n\tchar *proto;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_portcon_init(&portcon);\n\n\tproto = parse_current->next->data;\n\tif (proto == CIL_KEY_UDP) {\n\t\tportcon->proto = CIL_PROTOCOL_UDP;\n\t} else if (proto == CIL_KEY_TCP) {\n\t\tportcon->proto = CIL_PROTOCOL_TCP;\n\t} else if (proto == CIL_KEY_DCCP) {\n\t\tportcon->proto = CIL_PROTOCOL_DCCP;\n\t} else if (proto == CIL_KEY_SCTP) {\n\t\tportcon->proto = CIL_PROTOCOL_SCTP;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Invalid protocol\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->cl_head != NULL) {\n\t\tif (parse_current->next->next->cl_head->next != NULL\n\t\t&& parse_current->next->next->cl_head->next->next == NULL) {\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head, &portcon->port_low, 10);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper port specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head->next, &portcon->port_high, 10);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper port specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper port range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer(parse_current->next->next, &portcon->port_low, 10);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper port specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tportcon->port_high = portcon->port_low;\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL ) {\n\t\tportcon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&portcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, portcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = portcon;\n\tast_node->flavor = CIL_PORTCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad portcon declaration\");\n\tcil_destroy_portcon(portcon);\n\treturn rc;\n}\n\nvoid cil_destroy_portcon(struct cil_portcon *portcon)\n{\n\tif (portcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (portcon->context_str == NULL && portcon->context != NULL) {\n\t\tcil_destroy_context(portcon->context);\n\t}\n\n\tfree(portcon);\n}\n\nint cil_gen_nodecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_nodecon *nodecon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_nodecon_init(&nodecon);\n\n\tif (parse_current->next->cl_head == NULL ) {\n\t\tnodecon->addr_str = parse_current->next->data;\n\t} else {\n\t\tcil_ipaddr_init(&nodecon->addr);\n\n\t\trc = cil_fill_ipaddr(parse_current->next->cl_head, nodecon->addr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL ) {\n\t\tnodecon->mask_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_ipaddr_init(&nodecon->mask);\n\n\t\trc = cil_fill_ipaddr(parse_current->next->next->cl_head, nodecon->mask);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL ) {\n\t\tnodecon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&nodecon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, nodecon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = nodecon;\n\tast_node->flavor = CIL_NODECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad nodecon declaration\");\n\tcil_destroy_nodecon(nodecon);\n\treturn rc;\n}\n\nvoid cil_destroy_nodecon(struct cil_nodecon *nodecon)\n{\n\tif (nodecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (nodecon->addr_str == NULL && nodecon->addr != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->addr);\n\t}\n\n\tif (nodecon->mask_str == NULL && nodecon->mask != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->mask);\n\t}\n\n\tif (nodecon->context_str == NULL && nodecon->context != NULL) {\n\t\tcil_destroy_context(nodecon->context);\n\t}\n\n\tfree(nodecon);\n}\n\nint cil_gen_genfscon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_genfscon *genfscon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_genfscon_init(&genfscon);\n\n\tgenfscon->fs_str = parse_current->next->data;\n\tgenfscon->path_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL ) {\n\t\tgenfscon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&genfscon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, genfscon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = genfscon;\n\tast_node->flavor = CIL_GENFSCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad genfscon declaration\");\n\tcil_destroy_genfscon(genfscon);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_genfscon(struct cil_genfscon *genfscon)\n{\n\tif (genfscon == NULL) {\n\t\treturn;\n\t}\n\n\tif (genfscon->context_str == NULL && genfscon->context != NULL) {\n\t\tcil_destroy_context(genfscon->context);\n\t}\n\n\tfree(genfscon);\n}\n\n\nint cil_gen_netifcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_netifcon *netifcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_netifcon_init(&netifcon);\n\n\tnetifcon->interface_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tnetifcon->if_context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&netifcon->if_context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, netifcon->if_context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tnetifcon->packet_context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&netifcon->packet_context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, netifcon->packet_context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = netifcon;\n\tast_node->flavor = CIL_NETIFCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad netifcon declaration\");\n\tcil_destroy_netifcon(netifcon);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_netifcon(struct cil_netifcon *netifcon)\n{\n\tif (netifcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (netifcon->if_context_str == NULL && netifcon->if_context != NULL) {\n\t\tcil_destroy_context(netifcon->if_context);\n\t}\n\n\tif (netifcon->packet_context_str == NULL && netifcon->packet_context != NULL) {\n\t\tcil_destroy_context(netifcon->packet_context);\n\t}\n\n\tfree(netifcon);\n}\n\nint cil_gen_ibendportcon(__attribute__((unused)) struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax) / sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_ibendportcon *ibendportcon = NULL;\n\n\tif (!parse_current || !ast_node)\n\t\tgoto exit;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\tcil_ibendportcon_init(&ibendportcon);\n\n\tibendportcon->dev_name_str = parse_current->next->data;\n\n\trc = cil_fill_integer(parse_current->next->next, &ibendportcon->port, 10);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Improper ibendport port specified\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (!parse_current->next->next->next->cl_head) {\n\t\tibendportcon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&ibendportcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, ibendportcon->context);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\tast_node->data = ibendportcon;\n\tast_node->flavor = CIL_IBENDPORTCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ibendportcon declaration\");\n\tcil_destroy_ibendportcon(ibendportcon);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_ibendportcon(struct cil_ibendportcon *ibendportcon)\n{\n\tif (!ibendportcon)\n\t\treturn;\n\n\tif (!ibendportcon->context_str && ibendportcon->context)\n\t\tcil_destroy_context(ibendportcon->context);\n\n\tfree(ibendportcon);\n}\n\nint cil_gen_pirqcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_pirqcon *pirqcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_pirqcon_init(&pirqcon);\n\n\trc = cil_fill_integer(parse_current->next, &pirqcon->pirq, 10);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tpirqcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&pirqcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, pirqcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = pirqcon;\n\tast_node->flavor = CIL_PIRQCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad pirqcon declaration\");\n\tcil_destroy_pirqcon(pirqcon);\n\treturn rc;\n}\n\nvoid cil_destroy_pirqcon(struct cil_pirqcon *pirqcon)\n{\n\tif (pirqcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (pirqcon->context_str == NULL && pirqcon->context != NULL) {\n\t\tcil_destroy_context(pirqcon->context);\n\t}\n\n\tfree(pirqcon);\n}\n\nint cil_gen_iomemcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_iomemcon *iomemcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_iomemcon_init(&iomemcon);\n\n\tif (parse_current->next->cl_head != NULL) {\n\t\tif (parse_current->next->cl_head->next != NULL &&\n\t\t    parse_current->next->cl_head->next->next == NULL) {\n\t\t\trc = cil_fill_integer64(parse_current->next->cl_head, &iomemcon->iomem_low, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper iomem specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer64(parse_current->next->cl_head->next, &iomemcon->iomem_high, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper iomem specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper iomem range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer64(parse_current->next, &iomemcon->iomem_low, 0);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper iomem specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tiomemcon->iomem_high = iomemcon->iomem_low;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL ) {\n\t\tiomemcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&iomemcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, iomemcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = iomemcon;\n\tast_node->flavor = CIL_IOMEMCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad iomemcon declaration\");\n\tcil_destroy_iomemcon(iomemcon);\n\treturn rc;\n}\n\nvoid cil_destroy_iomemcon(struct cil_iomemcon *iomemcon)\n{\n\tif (iomemcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (iomemcon->context_str == NULL && iomemcon->context != NULL) {\n\t\tcil_destroy_context(iomemcon->context);\n\t}\n\n\tfree(iomemcon);\n}\n\nint cil_gen_ioportcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_ioportcon *ioportcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_ioportcon_init(&ioportcon);\n\n\tif (parse_current->next->cl_head != NULL) {\n\t\tif (parse_current->next->cl_head->next != NULL &&\n\t\t    parse_current->next->cl_head->next->next == NULL) {\n\t\t\trc = cil_fill_integer(parse_current->next->cl_head, &ioportcon->ioport_low, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ioport specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer(parse_current->next->cl_head->next, &ioportcon->ioport_high, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ioport specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper ioport range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer(parse_current->next, &ioportcon->ioport_low, 0);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper ioport specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tioportcon->ioport_high = ioportcon->ioport_low;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL ) {\n\t\tioportcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&ioportcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, ioportcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = ioportcon;\n\tast_node->flavor = CIL_IOPORTCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ioportcon declaration\");\n\tcil_destroy_ioportcon(ioportcon);\n\treturn rc;\n}\n\nvoid cil_destroy_ioportcon(struct cil_ioportcon *ioportcon)\n{\n\tif (ioportcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (ioportcon->context_str == NULL && ioportcon->context != NULL) {\n\t\tcil_destroy_context(ioportcon->context);\n\t}\n\n\tfree(ioportcon);\n}\n\nint cil_gen_pcidevicecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_pcidevicecon *pcidevicecon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_pcidevicecon_init(&pcidevicecon);\n\n\trc = cil_fill_integer(parse_current->next, &pcidevicecon->dev, 0);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tpcidevicecon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&pcidevicecon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, pcidevicecon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = pcidevicecon;\n\tast_node->flavor = CIL_PCIDEVICECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad pcidevicecon declaration\");\n\tcil_destroy_pcidevicecon(pcidevicecon);\n\treturn rc;\n}\n\nvoid cil_destroy_pcidevicecon(struct cil_pcidevicecon *pcidevicecon)\n{\n\tif (pcidevicecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (pcidevicecon->context_str == NULL && pcidevicecon->context != NULL) {\n\t\tcil_destroy_context(pcidevicecon->context);\n\t}\n\n\tfree(pcidevicecon);\n}\n\nint cil_gen_devicetreecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_devicetreecon *devicetreecon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_devicetreecon_init(&devicetreecon);\n\n\tdevicetreecon->path = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tdevicetreecon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&devicetreecon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, devicetreecon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = devicetreecon;\n\tast_node->flavor = CIL_DEVICETREECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad devicetreecon declaration\");\n\tcil_destroy_devicetreecon(devicetreecon);\n\treturn rc;\n}\n\nvoid cil_destroy_devicetreecon(struct cil_devicetreecon *devicetreecon)\n{\n\tif (devicetreecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (devicetreecon->context_str == NULL && devicetreecon->context != NULL) {\n\t\tcil_destroy_context(devicetreecon->context);\n\t}\n\n\tfree(devicetreecon);\n}\n\nint cil_gen_fsuse(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *type = NULL;\n\tstruct cil_fsuse *fsuse = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ttype = parse_current->next->data;\n\n\tcil_fsuse_init(&fsuse);\n\n\tif (type == CIL_KEY_XATTR) {\n\t\tfsuse->type = CIL_FSUSE_XATTR;\n\t} else if (type == CIL_KEY_TASK) {\n\t\tfsuse->type = CIL_FSUSE_TASK;\n\t} else if (type == CIL_KEY_TRANS) {\n\t\tfsuse->type = CIL_FSUSE_TRANS;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Invalid fsuse type\\n\");\n\t\tgoto exit;\n\t}\n\n\tfsuse->fs_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tfsuse->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&fsuse->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, fsuse->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = fsuse;\n\tast_node->flavor = CIL_FSUSE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad fsuse declaration\");\n\tcil_destroy_fsuse(fsuse);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_fsuse(struct cil_fsuse *fsuse)\n{\n\tif (fsuse == NULL) {\n\t\treturn;\n\t}\n\n\tif (fsuse->context_str == NULL && fsuse->context != NULL) {\n\t\tcil_destroy_context(fsuse->context);\n\t}\n\n\tfree(fsuse);\n}\n\nvoid cil_destroy_param(struct cil_param *param)\n{\n\tif (param == NULL) {\n\t\treturn;\n\t}\n\n\tfree(param);\n}\n\nint cil_gen_macro(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tchar *key = NULL;\n\tstruct cil_macro *macro = NULL;\n\tstruct cil_tree_node *macro_content = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST | CIL_SYN_EMPTY_LIST,\n\t\tCIL_SYN_N_LISTS | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/ sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc =__cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_macro_init(&macro);\n\n\tkey = parse_current->next->data;\n\n\tstruct cil_tree_node *current_item = parse_current->next->next->cl_head;\n\twhile (current_item != NULL) {\n\t\tenum cil_syntax param_syntax[] = {\n\t\t\tCIL_SYN_STRING,\n\t\t\tCIL_SYN_STRING,\n\t\t\tCIL_SYN_END\n\t\t};\n\t\tint param_syntax_len = sizeof(param_syntax)/sizeof(*param_syntax);\n\t\tchar *kind = NULL;\n\t\tstruct cil_param *param = NULL;\n\n\t\trc =__cil_verify_syntax(current_item->cl_head, param_syntax, param_syntax_len);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (macro->params == NULL) {\n\t\t\tcil_list_init(&macro->params, CIL_LIST_ITEM);\n\t\t}\n\n\t\tkind = current_item->cl_head->data;\n\t\tcil_param_init(&param);\n\n\t\tif (kind == CIL_KEY_TYPE) {\n\t\t\tparam->flavor = CIL_TYPE;\n\t\t} else if (kind == CIL_KEY_ROLE) {\n\t\t\tparam->flavor = CIL_ROLE;\n\t\t} else if (kind == CIL_KEY_USER) {\n\t\t\tparam->flavor = CIL_USER;\n\t\t} else if (kind == CIL_KEY_SENSITIVITY) {\n\t\t\tparam->flavor = CIL_SENS;\n\t\t} else if (kind == CIL_KEY_CATEGORY) {\n\t\t\tparam->flavor = CIL_CAT;\n\t\t} else if (kind == CIL_KEY_CATSET) {\n\t\t\tparam->flavor = CIL_CATSET;\n\t\t} else if (kind == CIL_KEY_LEVEL) {\n\t\t\tparam->flavor = CIL_LEVEL;\n\t\t} else if (kind == CIL_KEY_LEVELRANGE) {\n\t\t\tparam->flavor = CIL_LEVELRANGE;\n\t\t} else if (kind == CIL_KEY_CLASS) {\n\t\t\tparam->flavor = CIL_CLASS;\n\t\t} else if (kind == CIL_KEY_IPADDR) {\n\t\t\tparam->flavor = CIL_IPADDR;\n\t\t} else if (kind == CIL_KEY_MAP_CLASS) {\n\t\t\tparam->flavor = CIL_MAP_CLASS;\n\t\t} else if (kind == CIL_KEY_CLASSPERMISSION) {\n\t\t\tparam->flavor = CIL_CLASSPERMISSION;\n\t\t} else if (kind == CIL_KEY_BOOL) {\n\t\t\tparam->flavor = CIL_BOOL;\n\t\t} else if (kind == CIL_KEY_STRING) {\n\t\t\tparam->flavor = CIL_NAME;\n\t\t} else if (kind == CIL_KEY_NAME) {\n\t\t\tparam->flavor = CIL_NAME;\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"The kind %s is not allowed as a parameter\\n\",kind);\n\t\t\tcil_destroy_param(param);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tparam->str =  current_item->cl_head->next->data;\n\n\t\trc = cil_verify_name(param->str, param->flavor);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_destroy_param(param);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t//walk current list and check for duplicate parameters\n\t\tstruct cil_list_item *curr_param;\n\t\tcil_list_for_each(curr_param, macro->params) {\n\t\t\tif (param->str == ((struct cil_param*)curr_param->data)->str) {\n\t\t\t\tcil_log(CIL_ERR, \"Duplicate parameter\\n\");\n\t\t\t\tcil_destroy_param(param);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tcil_list_append(macro->params, CIL_PARAM, param);\n\n\t\tcurrent_item = current_item->next;\n\t}\n\n\t/* we don't want the tree walker to walk the macro parameters (they were just handled above), so the subtree is deleted, and the next pointer of the\n           node containing the macro name is updated to point to the start of the macro content */\n\tmacro_content = parse_current->next->next->next;\n\tcil_tree_subtree_destroy(parse_current->next->next);\n\tparse_current->next->next = macro_content;\n\tif (macro_content == NULL) {\n\t\t/* No statements in macro and macro parameter list was last node */\n\t\tparse_current->parent->cl_tail = parse_current->next;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)macro, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_MACRO);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad macro declaration\");\n\tcil_destroy_macro(macro);\n\tcil_clear_node(ast_node);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_macro(struct cil_macro *macro)\n{\n\tif (macro == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&macro->datum);\n\tcil_symtab_array_destroy(macro->symtab);\n\n\tif (macro->params != NULL) {\n\t\tcil_list_destroy(&macro->params, 1);\n\t}\n\n\tfree(macro);\n}\n\nint cil_gen_call(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST | CIL_SYN_EMPTY_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_call *call = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_call_init(&call);\n\n\tcall->macro_str = parse_current->next->data;\n\n\tif (parse_current->next->next != NULL) {\n\t\tcil_tree_init(&call->args_tree);\n\t\tcil_copy_ast(db, parse_current->next->next, call->args_tree->root);\n\t}\n\n\tast_node->data = call;\n\tast_node->flavor = CIL_CALL;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad macro call\");\n\tcil_destroy_call(call);\n\treturn rc;\n}\n\nvoid cil_destroy_call(struct cil_call *call)\n{\n\tif (call == NULL) {\n\t\treturn;\n\t}\n\n\tcall->macro = NULL;\n\n\tif (call->args_tree != NULL) {\n\t\tcil_tree_destroy(&call->args_tree);\n\t}\n\n\tif (call->args != NULL) {\n\t\tcil_list_destroy(&call->args, 1);\n\t}\n\n\tfree(call);\n}\n\nvoid cil_destroy_args(struct cil_args *args)\n{\n\tif (args == NULL) {\n\t\treturn;\n\t}\n\n\tif (args->arg_str != NULL) {\n\t\targs->arg_str = NULL;\n\t} else if (args->arg != NULL) {\n\t\tstruct cil_tree_node *node = args->arg->nodes->head->data;\n\t\tswitch (args->flavor) {\n\t\tcase CIL_NAME:\n\t\t\tbreak;\n\t\tcase CIL_CATSET:\n\t\t\tcil_destroy_catset((struct cil_catset *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\tcil_destroy_level((struct cil_level *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\tcil_destroy_levelrange((struct cil_levelrange *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_IPADDR:\n\t\t\tcil_destroy_ipaddr((struct cil_ipaddr *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSION:\n\t\t\tcil_destroy_classpermission((struct cil_classpermission *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcil_log(CIL_ERR, \"Destroying arg with the unexpected flavor=%d\\n\",args->flavor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targs->param_str = NULL;\n\targs->arg = NULL;\n\n\tfree(args);\n}\n\nint cil_gen_optional(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_optional *optional = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_optional_init(&optional);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)optional, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_OPTIONAL);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad optional\");\n\tcil_destroy_optional(optional);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_optional(struct cil_optional *optional)\n{\n\tif (optional == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&optional->datum);\n\tfree(optional);\n}\n\nint cil_gen_policycap(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_policycap *polcap = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_policycap_init(&polcap);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)polcap, (hashtab_key_t)key, CIL_SYM_POLICYCAPS, CIL_POLICYCAP);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad policycap statement\");\n\tcil_destroy_policycap(polcap);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_policycap(struct cil_policycap *polcap)\n{\n\tif (polcap == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&polcap->datum);\n\tfree(polcap);\n}\n\nint cil_gen_ipaddr(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_ipaddr *ipaddr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_ipaddr_init(&ipaddr);\n\n\tkey  = parse_current->next->data;\n\n\trc = cil_fill_ipaddr(parse_current->next->next, ipaddr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)ipaddr, (hashtab_key_t)key, CIL_SYM_IPADDRS, CIL_IPADDR);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ipaddr statement\");\n\tcil_destroy_ipaddr(ipaddr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_ipaddr(struct cil_ipaddr *ipaddr)\n{\n\tif (ipaddr == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&ipaddr->datum);\n\tfree(ipaddr);\n}\n\nint cil_fill_integer(struct cil_tree_node *int_node, uint32_t *integer, int base)\n{\n\tint rc = SEPOL_ERR;\n\tchar *endptr = NULL;\n\tunsigned long val;\n\n\tif (int_node == NULL || int_node->data == NULL || integer == NULL) {\n\t\tgoto exit;\n\t}\n\n\terrno = 0;\n\tval = strtoul(int_node->data, &endptr, base);\n\tif (errno != 0 || endptr == int_node->data || *endptr != '\\0') {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\t/* Ensure that the value fits a 32-bit integer without triggering -Wtype-limits */\n#if ULONG_MAX > UINT32_MAX\n\tif (val > UINT32_MAX) {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n#endif\n\n\t*integer = val;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Failed to create integer from string\\n\");\n\treturn rc;\n}\n\nint cil_fill_integer64(struct cil_tree_node *int_node, uint64_t *integer, int base)\n{\n\tint rc = SEPOL_ERR;\n\tchar *endptr = NULL;\n\tuint64_t val;\n\n\tif (int_node == NULL || int_node->data == NULL || integer == NULL) {\n\t\tgoto exit;\n\t}\n\n\terrno = 0;\n\tval = strtoull(int_node->data, &endptr, base);\n\tif (errno != 0 || endptr == int_node->data || *endptr != '\\0') {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\t*integer = val;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Failed to create integer from string\\n\");\n\treturn rc;\n}\n\nint cil_fill_ipaddr(struct cil_tree_node *addr_node, struct cil_ipaddr *addr)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (addr_node == NULL || addr_node->data == NULL || addr == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (addr_node->cl_head != NULL ||  addr_node->next != NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (strchr(addr_node->data, '.') != NULL) {\n\t\taddr->family = AF_INET;\n\t} else {\n\t\taddr->family = AF_INET6;\n\t}\n\n\trc = inet_pton(addr->family, addr_node->data, &addr->ip);\n\tif (rc != 1) {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad ip address or netmask\\n\"); \n\treturn rc;\n}\n\nint cil_fill_level(struct cil_tree_node *curr, struct cil_level *level)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (curr == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(curr, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tlevel->sens_str = curr->data;\n\tif (curr->next != NULL) {\n\t\trc = cil_fill_cats(curr->next, &level->cats);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad level\\n\");\n\treturn rc;\n}\n\nint cil_fill_cats(struct cil_tree_node *curr, struct cil_cats **cats)\n{\n\tint rc = SEPOL_ERR;\n\n\tcil_cats_init(cats);\n\n\trc = cil_gen_expr(curr, CIL_CAT, &(*cats)->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tcil_destroy_cats(*cats);\n\t\t*cats = NULL;\n\t}\n\n\treturn rc;\n}\n\nvoid cil_destroy_cats(struct cil_cats *cats)\n{\n\tif (cats == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cats->str_expr, CIL_TRUE);\n\n\tcil_list_destroy(&cats->datum_expr, CIL_FALSE);\n\n\tfree(cats);\n}\nint cil_gen_bounds(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_bounds *bounds = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_bounds_init(&bounds);\n\n\tbounds->parent_str = parse_current->next->data;\n\tbounds->child_str = parse_current->next->next->data;\n\n\tast_node->data = bounds;\n\n\tswitch (flavor) {\n\tcase CIL_USER:\n\t\tast_node->flavor = CIL_USERBOUNDS;\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tast_node->flavor = CIL_ROLEBOUNDS;\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tast_node->flavor = CIL_TYPEBOUNDS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad bounds declaration\");\n\tcil_destroy_bounds(bounds);\n\treturn rc;\n}\n\nvoid cil_destroy_bounds(struct cil_bounds *bounds)\n{\n\tif (bounds == NULL) {\n\t\treturn;\n\t}\n\n\tfree(bounds);\n}\n\nint cil_gen_default(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_default *def = NULL;\n\tchar *object;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_default_init(&def);\n\n\tdef->flavor = flavor;\n\n\tif (parse_current->next->cl_head == NULL) {\n\t\tcil_list_init(&def->class_strs, CIL_CLASS);\n\t\tcil_list_append(def->class_strs, CIL_STRING, parse_current->next->data);\n\t} else {\n\t\trc = cil_fill_list(parse_current->next->cl_head, CIL_CLASS, &def->class_strs);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tobject = parse_current->next->next->data;\n\tif (object == CIL_KEY_SOURCE) {\n\t\tdef->object = CIL_DEFAULT_SOURCE;\n\t} else if (object == CIL_KEY_TARGET) {\n\t\tdef->object = CIL_DEFAULT_TARGET;\n\t} else {\n\t\tcil_log(CIL_ERR,\"Expected either 'source' or 'target'\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = def;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s declaration\", cil_node_to_string(parse_current));\n\tcil_destroy_default(def);\n\treturn rc;\n}\n\nvoid cil_destroy_default(struct cil_default *def)\n{\n\tif (def == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&def->class_strs, CIL_TRUE);\n\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n\n\tfree(def);\n}\n\nint cil_gen_defaultrange(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_defaultrange *def = NULL;\n\tchar *object;\n\tchar *range;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_defaultrange_init(&def);\n\n\tif (parse_current->next->cl_head == NULL) {\n\t\tcil_list_init(&def->class_strs, CIL_CLASS);\n\t\tcil_list_append(def->class_strs, CIL_STRING, parse_current->next->data);\n\t} else {\n\t\trc = cil_fill_list(parse_current->next->cl_head, CIL_CLASS, &def->class_strs);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tobject = parse_current->next->next->data;\n\tif (object == CIL_KEY_SOURCE) {\n\t\trange = parse_current->next->next->next->data;\n\t\tif (range == CIL_KEY_LOW) {\n\t\t\tdef->object_range = CIL_DEFAULT_SOURCE_LOW;\n\t\t} else if (range == CIL_KEY_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_SOURCE_HIGH;\n\t\t} else if (range == CIL_KEY_LOW_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_SOURCE_LOW_HIGH;\n\t\t} else {\n\t\t\tcil_log(CIL_ERR,\"Expected 'low', 'high', or 'low-high'\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else if (object == CIL_KEY_TARGET) {\n\t\trange = parse_current->next->next->next->data;\n\t\tif (range == CIL_KEY_LOW) {\n\t\t\tdef->object_range = CIL_DEFAULT_TARGET_LOW;\n\t\t} else if (range == CIL_KEY_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_TARGET_HIGH;\n\t\t} else if (range == CIL_KEY_LOW_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_TARGET_LOW_HIGH;\n\t\t} else {\n\t\t\tcil_log(CIL_ERR,\"Expected 'low', 'high', or 'low-high'\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else if (object == CIL_KEY_GLBLUB) {\n\t\tdef->object_range = CIL_DEFAULT_GLBLUB;\n\t} else {\n\t\tcil_log(CIL_ERR,\"Expected \\'source\\', \\'target\\', or \\'glblub\\'\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = def;\n\tast_node->flavor = CIL_DEFAULTRANGE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad defaultrange declaration\");\n\tcil_destroy_defaultrange(def);\n\treturn rc;\n}\n\nvoid cil_destroy_defaultrange(struct cil_defaultrange *def)\n{\n\tif (def == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&def->class_strs, CIL_TRUE);\n\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n\n\tfree(def);\n}\n\nint cil_gen_handleunknown(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_handleunknown *unknown = NULL;\n\tchar *unknown_key;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_handleunknown_init(&unknown);\n\n\tunknown_key = parse_current->next->data;\n\tif (unknown_key == CIL_KEY_HANDLEUNKNOWN_ALLOW) {\n\t\tunknown->handle_unknown = SEPOL_ALLOW_UNKNOWN;\n\t} else if (unknown_key == CIL_KEY_HANDLEUNKNOWN_DENY) {\n\t\tunknown->handle_unknown = SEPOL_DENY_UNKNOWN;\n\t} else if (unknown_key == CIL_KEY_HANDLEUNKNOWN_REJECT) {\n\t\tunknown->handle_unknown = SEPOL_REJECT_UNKNOWN;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Expected either \\'%s\\', \\'%s\\', or \\'%s\\'\\n\", CIL_KEY_HANDLEUNKNOWN_ALLOW, CIL_KEY_HANDLEUNKNOWN_DENY, CIL_KEY_HANDLEUNKNOWN_REJECT);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = unknown;\n\tast_node->flavor = CIL_HANDLEUNKNOWN;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad handleunknown\");\n\tcil_destroy_handleunknown(unknown);\n\treturn rc;\n}\n\nvoid cil_destroy_handleunknown(struct cil_handleunknown *unk)\n{\n\tfree(unk);\n}\n\nint cil_gen_mls(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_mls *mls = NULL;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_mls_init(&mls);\n\n\tif (parse_current->next->data == CIL_KEY_CONDTRUE) {\n\t\tmls->value = CIL_TRUE;\n\t} else if (parse_current->next->data == CIL_KEY_CONDFALSE) {\n\t\tmls->value = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = mls;\n\tast_node->flavor = CIL_MLS;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad mls\");\n\tcil_destroy_mls(mls);\n\treturn rc;\n}\n\nvoid cil_destroy_mls(struct cil_mls *mls)\n{\n\tfree(mls);\n}\n\nint cil_gen_src_info(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\t/* No need to check syntax, because this is auto generated */\n\tstruct cil_src_info *info = NULL;\n\n\tif (parse_current->next == NULL || parse_current->next->next == NULL) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad <src_info>\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\tcil_src_info_init(&info);\n\n\tinfo->is_cil = (parse_current->next->data == CIL_KEY_SRC_CIL) ? CIL_TRUE : CIL_FALSE;\n\tinfo->path = parse_current->next->next->data;\n\n\tast_node->data = info;\n\tast_node->flavor = CIL_SRC_INFO;\n\n\treturn SEPOL_OK;\n}\n\nvoid cil_destroy_src_info(struct cil_src_info *info)\n{\n\tfree(info);\n}\n\nint __cil_build_ast_node_helper(struct cil_tree_node *parse_current, uint32_t *finished, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_db *db = args->db;\n\tstruct cil_tree_node *ast_current = args->ast;\n\tstruct cil_tree_node *tunif = args->tunif;\n\tstruct cil_tree_node *in = args->in;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *boolif = args->boolif;\n\tstruct cil_tree_node *ast_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current->parent->cl_head != parse_current) {\n\t\t/* ignore anything that isn't following a parenthesis */\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (parse_current->data == NULL) {\n\t\t/* the only time parenthesis can immediately following parenthesis is if\n\t\t * the parent is the root node */\n\t\tif (parse_current->parent->parent == NULL) {\n\t\t\trc = SEPOL_OK;\n\t\t} else {\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Keyword expected after open parenthesis\");\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (tunif != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found tunable\");\n\t\t\tcil_log(CIL_ERR, \"Tunables cannot be defined within tunableif statement\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tif (parse_current->data == CIL_KEY_IN) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found in-statement\");\n\t\t\tcil_log(CIL_ERR, \"in-statements cannot be defined within in-statements\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE ||\n\t\t\tparse_current->data == CIL_KEY_IN ||\n\t\t\tparse_current->data == CIL_KEY_BLOCK ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKINHERIT ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKABSTRACT ||\n\t\t\tparse_current->data == CIL_KEY_MACRO) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"%s is not allowed in macros\", (char *)parse_current->data);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (parse_current->data != CIL_KEY_TUNABLEIF &&\n\t\t\tparse_current->data != CIL_KEY_CALL &&\n\t\t\tparse_current->data != CIL_KEY_CONDTRUE &&\n\t\t\tparse_current->data != CIL_KEY_CONDFALSE &&\n\t\t\tparse_current->data != CIL_KEY_ALLOW &&\n\t\t\tparse_current->data != CIL_KEY_DONTAUDIT &&\n\t\t\tparse_current->data != CIL_KEY_AUDITALLOW &&\n\t\t\tparse_current->data != CIL_KEY_TYPETRANSITION &&\n\t\t\tparse_current->data != CIL_KEY_TYPECHANGE &&\n\t\t\tparse_current->data != CIL_KEY_TYPEMEMBER) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found %s\", (char*)parse_current->data);\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_log(CIL_ERR, \"%s cannot be defined within tunableif statement (treated as a booleanif due to preserve-tunables)\\n\",\n\t\t\t\t\t\t(char*)parse_current->data);\n\t\t\t} else {\n\t\t\t\tcil_log(CIL_ERR, \"%s cannot be defined within booleanif statement\\n\",\n\t\t\t\t\t\t(char*)parse_current->data);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tcil_tree_node_init(&ast_node);\n\n\tast_node->parent = ast_current;\n\tast_node->line = parse_current->line;\n\tast_node->hll_line = parse_current->hll_line;\n\n\tif (parse_current->data == CIL_KEY_BLOCK) {\n\t\trc = cil_gen_block(db, parse_current, ast_node, 0);\n\t} else if (parse_current->data == CIL_KEY_BLOCKINHERIT) {\n\t\trc = cil_gen_blockinherit(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_BLOCKABSTRACT) {\n\t\trc = cil_gen_blockabstract(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_IN) {\n\t\trc = cil_gen_in(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CLASS) {\n\t\trc = cil_gen_class(db, parse_current, ast_node);\n\t\t// To avoid parsing list of perms again\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSORDER) {\n\t\trc = cil_gen_classorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MAP_CLASS) {\n\t\trc = cil_gen_map_class(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSMAPPING) {\n\t\trc = cil_gen_classmapping(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSPERMISSION) {\n\t\trc = cil_gen_classpermission(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSPERMISSIONSET) {\n\t\trc = cil_gen_classpermissionset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_COMMON) {\n\t\trc = cil_gen_common(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSCOMMON) {\n\t\trc = cil_gen_classcommon(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SID) {\n\t\trc = cil_gen_sid(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SIDCONTEXT) {\n\t\trc = cil_gen_sidcontext(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SIDORDER) {\n\t\trc = cil_gen_sidorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USER) {\n\t\trc = cil_gen_user(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERATTRIBUTE) {\n\t\trc = cil_gen_userattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERATTRIBUTESET) {\n\t\trc = cil_gen_userattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERLEVEL) {\n\t\trc = cil_gen_userlevel(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERRANGE) {\n\t\trc = cil_gen_userrange(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_USER);\n\t} else if (parse_current->data == CIL_KEY_USERPREFIX) {\n\t\trc = cil_gen_userprefix(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SELINUXUSER) {\n\t\trc = cil_gen_selinuxuser(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SELINUXUSERDEFAULT) {\n\t\trc = cil_gen_selinuxuserdefault(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPE) {\n\t\trc = cil_gen_type(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPEATTRIBUTE) {\n\t\trc = cil_gen_typeattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPEATTRIBUTESET) {\n\t\trc = cil_gen_typeattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_EXPANDTYPEATTRIBUTE) {\n\t\trc = cil_gen_expandtypeattribute(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPEALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_TYPEALIAS);\n\t} else if (parse_current->data == CIL_KEY_TYPEALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_TYPEALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_TYPEBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_TYPE);\n\t} else if (parse_current->data == CIL_KEY_TYPEPERMISSIVE) {\n\t\trc = cil_gen_typepermissive(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_RANGETRANSITION) {\n\t\trc = cil_gen_rangetransition(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ROLE) {\n\t\trc = cil_gen_role(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERROLE) {\n\t\trc = cil_gen_userrole(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLETYPE) {\n\t\trc = cil_gen_roletype(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLETRANSITION) {\n\t\trc = cil_gen_roletransition(parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEALLOW) {\n\t\trc = cil_gen_roleallow(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEATTRIBUTE) {\n\t\trc = cil_gen_roleattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEATTRIBUTESET) {\n\t\trc = cil_gen_roleattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ROLEBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_ROLE);\n\t} else if (parse_current->data == CIL_KEY_BOOL) {\n\t\trc = cil_gen_bool(db, parse_current, ast_node, CIL_FALSE);\n\t} else if (parse_current->data == CIL_KEY_BOOLEANIF) {\n\t\trc = cil_gen_boolif(db, parse_current, ast_node, CIL_FALSE);\n\t} else if(parse_current->data == CIL_KEY_TUNABLE) {\n\t\tif (db->preserve_tunables) {\n\t\t\trc = cil_gen_bool(db, parse_current, ast_node, CIL_TRUE);\n\t\t} else {\n\t\t\trc = cil_gen_tunable(db, parse_current, ast_node);\n\t\t}\n\t} else if (parse_current->data == CIL_KEY_TUNABLEIF) {\n\t\tif (db->preserve_tunables) {\n\t\t\trc = cil_gen_boolif(db, parse_current, ast_node, CIL_TRUE);\n\t\t} else {\n\t\t\trc = cil_gen_tunif(db, parse_current, ast_node);\n\t\t}\n\t} else if (parse_current->data == CIL_KEY_CONDTRUE) {\n\t\trc = cil_gen_condblock(db, parse_current, ast_node, CIL_CONDTRUE);\n\t} else if (parse_current->data == CIL_KEY_CONDFALSE) {\n\t\trc = cil_gen_condblock(db, parse_current, ast_node, CIL_CONDFALSE);\n\t} else if (parse_current->data == CIL_KEY_ALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_ALLOWED);\n\t\t// So that the object and perms lists do not get parsed again\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_AUDITALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_AUDITALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DONTAUDIT) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_DONTAUDIT);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NEVERALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_NEVERALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_ALLOWED);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_AUDITALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_AUDITALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DONTAUDITX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_DONTAUDIT);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NEVERALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_NEVERALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PERMISSIONX) {\n\t\trc = cil_gen_permissionx(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPETRANSITION) {\n\t\trc = cil_gen_typetransition(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPECHANGE) {\n\t\trc = cil_gen_type_rule(parse_current, ast_node, CIL_TYPE_CHANGE);\n\t} else if (parse_current->data == CIL_KEY_TYPEMEMBER) {\n\t\trc = cil_gen_type_rule(parse_current, ast_node, CIL_TYPE_MEMBER);\n\t} else if (parse_current->data == CIL_KEY_SENSITIVITY) {\n\t\trc = cil_gen_sensitivity(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SENSALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_SENSALIAS);\n\t} else if (parse_current->data == CIL_KEY_SENSALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_SENSALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_CATEGORY) {\n\t\trc = cil_gen_category(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CATALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_CATALIAS);\n\t} else if (parse_current->data == CIL_KEY_CATALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_CATALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_CATSET) {\n\t\trc = cil_gen_catset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CATORDER) {\n\t\trc = cil_gen_catorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SENSITIVITYORDER) {\n\t\trc = cil_gen_sensitivityorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SENSCAT) {\n\t\trc = cil_gen_senscat(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_LEVEL) {\n\t\trc = cil_gen_level(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_LEVELRANGE) {\n\t\trc = cil_gen_levelrange(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CONSTRAIN) {\n\t\trc = cil_gen_constrain(db, parse_current, ast_node, CIL_CONSTRAIN);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLSCONSTRAIN) {\n\t\trc = cil_gen_constrain(db, parse_current, ast_node, CIL_MLSCONSTRAIN);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_VALIDATETRANS) {\n\t\trc = cil_gen_validatetrans(db, parse_current, ast_node, CIL_VALIDATETRANS);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLSVALIDATETRANS) {\n\t\trc = cil_gen_validatetrans(db, parse_current, ast_node, CIL_MLSVALIDATETRANS);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CONTEXT) {\n\t\trc = cil_gen_context(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_FILECON) {\n\t\trc = cil_gen_filecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IBPKEYCON) {\n\t\trc = cil_gen_ibpkeycon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IBENDPORTCON) {\n\t\trc = cil_gen_ibendportcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PORTCON) {\n\t\trc = cil_gen_portcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NODECON) {\n\t\trc = cil_gen_nodecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_GENFSCON) {\n\t\trc = cil_gen_genfscon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NETIFCON) {\n\t\trc = cil_gen_netifcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PIRQCON) {\n\t\trc = cil_gen_pirqcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IOMEMCON) {\n\t\trc = cil_gen_iomemcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IOPORTCON) {\n\t\trc = cil_gen_ioportcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PCIDEVICECON) {\n\t\trc = cil_gen_pcidevicecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEVICETREECON) {\n\t\trc = cil_gen_devicetreecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_FSUSE) {\n\t\trc = cil_gen_fsuse(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MACRO) {\n\t\trc = cil_gen_macro(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CALL) {\n\t\trc = cil_gen_call(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_POLICYCAP) {\n\t\trc = cil_gen_policycap(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_OPTIONAL) {\n\t\trc = cil_gen_optional(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_IPADDR) {\n\t\trc = cil_gen_ipaddr(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_DEFAULTUSER) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTUSER);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTROLE) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTROLE);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTTYPE) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTTYPE);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTRANGE) {\n\t\trc = cil_gen_defaultrange(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_HANDLEUNKNOWN) {\n\t\trc = cil_gen_handleunknown(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLS) {\n\t\trc = cil_gen_mls(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SRC_INFO) {\n\t\trc = cil_gen_src_info(parse_current, ast_node);\n\t} else {\n\t\tcil_log(CIL_ERR, \"Error: Unknown keyword %s\\n\", (char *)parse_current->data);\n\t\trc = SEPOL_ERR;\n\t}\n\n\tif (rc == SEPOL_OK) {\n\t\tif (ast_current->cl_head == NULL) {\n\t\t\tast_current->cl_head = ast_node;\n\t\t} else {\n\t\t\tast_current->cl_tail->next = ast_node;\n\t\t}\n\t\tast_current->cl_tail = ast_node;\n\t\tast_current = ast_node;\n\t\targs->ast = ast_current;\n\t} else {\n\t\tcil_tree_node_destroy(&ast_node);\n\t}\n\nexit:\n\treturn rc;\n}\n\nint __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\n\targs->ast = ast->parent;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\t// At this point we no longer have any need for parse_current or any of its\n\t// siblings; they have all been converted to the appropriate AST node. The\n\t// full parse tree will get deleted elsewhere, but in an attempt to\n\t// minimize memory usage (of which the parse tree uses a lot), start\n\t// deleting the parts we don't need now.\n\tcil_tree_children_destroy(parse_current->parent);\n\n\treturn SEPOL_OK;\n}\n\nint cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.boolif = NULL;\n\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n", "/*\n * Copyright 2011 Tresys Technology, LLC. All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n * \n *    2. Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY TRESYS TECHNOLOGY, LLC ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL TRESYS TECHNOLOGY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of Tresys Technology, LLC.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <sepol/policydb/conditional.h>\n\n#include \"cil_internal.h\"\n#include \"cil_flavor.h\"\n#include \"cil_log.h\"\n#include \"cil_mem.h\"\n#include \"cil_tree.h\"\n#include \"cil_list.h\"\n#include \"cil_build_ast.h\"\n#include \"cil_resolve_ast.h\"\n#include \"cil_reset_ast.h\"\n#include \"cil_copy_ast.h\"\n#include \"cil_verify.h\"\n#include \"cil_strpool.h\"\n#include \"cil_symtab.h\"\n\nstruct cil_args_resolve {\n\tstruct cil_db *db;\n\tenum cil_pass pass;\n\tuint32_t *changed;\n\tstruct cil_list *disabled_optionals;\n\tstruct cil_tree_node *block;\n\tstruct cil_tree_node *macro;\n\tstruct cil_tree_node *optional;\n\tstruct cil_tree_node *boolif;\n\tstruct cil_list *sidorder_lists;\n\tstruct cil_list *classorder_lists;\n\tstruct cil_list *unordered_classorder_lists;\n\tstruct cil_list *catorder_lists;\n\tstruct cil_list *sensitivityorder_lists;\n\tstruct cil_list *in_list;\n};\n\nstatic struct cil_name * __cil_insert_name(struct cil_db *db, hashtab_key_t key, struct cil_tree_node *ast_node)\n{\n\t/* Currently only used for typetransition file names.\n\t   But could be used for any string that is passed as a parameter.\n\t*/\n\tstruct cil_tree_node *parent = ast_node->parent;\n\tstruct cil_macro *macro = NULL;\n\tstruct cil_name *name;\n\tsymtab_t *symtab;\n\tenum cil_sym_index sym_index;\n\tstruct cil_symtab_datum *datum = NULL;\n\n\tif (parent->flavor == CIL_CALL) {\n\t\tstruct cil_call *call = parent->data;\n\t\tmacro = call->macro;\t\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\tmacro = parent->data;\n\t}\n\tif (macro != NULL && macro->params != NULL) {\n\t\tstruct cil_list_item *item;\n\t\tcil_list_for_each(item, macro->params) {\n\t\t\tif (((struct cil_param*)item->data)->str == key) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tcil_flavor_to_symtab_index(CIL_NAME, &sym_index);\n\tsymtab = &((struct cil_root *)db->ast->root->data)->symtab[sym_index];\n\n\tcil_symtab_get_datum(symtab, key, &datum);\n\tif (datum != NULL) {\n\t\treturn (struct cil_name *)datum;\n\t}\n\n\tcil_name_init(&name);\n\tcil_symtab_insert(symtab, key, (struct cil_symtab_datum *)name, ast_node);\n\tcil_list_append(db->names, CIL_NAME, name);\n\n\treturn name;\n}\n\nstatic int __cil_resolve_perms(symtab_t *class_symtab, symtab_t *common_symtab, struct cil_list *perm_strs, struct cil_list **perm_datums, enum cil_flavor class_flavor)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\n\tcil_list_init(perm_datums, perm_strs->flavor);\n\n\tcil_list_for_each(curr, perm_strs) {\n\t\tif (curr->flavor == CIL_LIST) {\n\t\t\tstruct cil_list *sub_list;\n\t\t\trc = __cil_resolve_perms(class_symtab, common_symtab, curr->data, &sub_list, class_flavor);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Failed to resolve permission list\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_append(*perm_datums, CIL_LIST, sub_list);\n\t\t} else if (curr->flavor == CIL_STRING) {\n\t\t\tstruct cil_symtab_datum *perm_datum = NULL;\n\t\t\trc = cil_symtab_get_datum(class_symtab, curr->data, &perm_datum);\n\t\t\tif (rc == SEPOL_ENOENT) {\n\t\t\t\tif (common_symtab) {\n\t\t\t\t\trc = cil_symtab_get_datum(common_symtab, curr->data, &perm_datum);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tif (class_flavor == CIL_MAP_CLASS) {\n\t\t\t\t\tcil_log(CIL_ERR, \"Failed to resolve permission %s for map class\\n\", (char*)curr->data);\n\t\t\t\t} else {\n\t\t\t\t\tcil_log(CIL_ERR, \"Failed to resolve permission %s\\n\", (char*)curr->data);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_append(*perm_datums, CIL_DATUM, perm_datum);\n\t\t} else {\n\t\t\tcil_list_append(*perm_datums, curr->flavor, curr->data);\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(perm_datums, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_classperms(struct cil_tree_node *current, struct cil_classperms *cp, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_symtab_datum *datum = NULL;\n\tsymtab_t *common_symtab = NULL;\n\tstruct cil_class *class;\n\n\trc = cil_resolve_name(current, cp->class_str, CIL_SYM_CLASSES, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)datum;\n\n\tif (class->common != NULL) {\n\t\tcommon_symtab = &class->common->perms;\n\t}\n\n\tcp->class = class;\n\n\trc = __cil_resolve_perms(&class->perms, common_symtab, cp->perm_strs, &cp->perms, FLAVOR(datum));\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classperms_set(struct cil_tree_node *current, struct cil_classperms_set *cp_set, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_symtab_datum *datum = NULL;\n\n\trc = cil_resolve_name(current, cp_set->set_str, CIL_SYM_CLASSPERMSETS, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tcp_set->set = (struct cil_classpermission*)datum;\n\n\t/* This could be an anonymous classpermission */\n\tif (datum->name == NULL) {\n\t\trc = cil_resolve_classperms_list(current, cp_set->set->classperms, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classperms_list(struct cil_tree_node *current, struct cil_list *cp_list, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\trc = cil_resolve_classperms(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\trc = cil_resolve_classperms_set(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classpermissionset(struct cil_tree_node *current, struct cil_classpermissionset *cps, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\tstruct cil_classpermission *cp;\n\n\trc = cil_resolve_name(current, cps->set_str, CIL_SYM_CLASSPERMSETS, args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_classperms_list(current, cps->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcp = (struct cil_classpermission *)datum;\n\n\tif (cp->classperms == NULL) {\n\t\tcil_list_init(&cp->classperms, CIL_CLASSPERMS);\n\t}\n\n\tcil_list_for_each(curr, cps->classperms) {\n\t\tcil_list_append(cp->classperms, curr->flavor, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_type_used(struct cil_symtab_datum *datum, int used)\n{\n\tstruct cil_typeattribute *attr = NULL;\n\n\tif (FLAVOR(datum) == CIL_TYPEATTRIBUTE) {\n\t\tattr = (struct cil_typeattribute*)datum;\n\t\tattr->used |= used;\n\t\tif ((attr->used & CIL_ATTR_EXPAND_TRUE) &&\n\t\t\t\t(attr->used & CIL_ATTR_EXPAND_FALSE)) {\n\t\t\tcil_log(CIL_WARN, \"Conflicting use of expandtypeattribute. \"\n\t\t\t\t\t\"Expandtypeattribute was set to both true or false for %s. \"\n\t\t\t\t\t\"Resolving to false. \\n\", attr->datum.name);\n\t\t\tattr->used &= ~CIL_ATTR_EXPAND_TRUE;\n\t\t}\n\t}\n}\n\nint cil_resolve_permissionx(struct cil_tree_node *current, struct cil_permissionx *permx, void *extra_args)\n{\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, permx->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tpermx->obj = (struct cil_class*)obj_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_avrule(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\n\tstruct cil_avrule *rule = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *permx_datum = NULL;\n\tint used;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, rule->src_str, CIL_SYM_TYPES, args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->src = src_datum;\n\t\t\n\tif (rule->tgt_str == CIL_KEY_SELF) {\n\t\trule->tgt = db->selftype;\n\t} else {\n\t\trc = cil_resolve_name(current, rule->tgt_str, CIL_SYM_TYPES, args, &tgt_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trule->tgt = tgt_datum;\n\t\tused = (rule->rule_kind == CIL_AVRULE_NEVERALLOW) ?\n\t\t\tCIL_ATTR_NEVERALLOW : CIL_ATTR_AVRULE;\n\t\tcil_type_used(src_datum, used); /* src not used if tgt is self */\n\t\tcil_type_used(tgt_datum, used);\n\t}\n\n\tif (!rule->is_extended) {\n\t\trc = cil_resolve_classperms_list(current, rule->perms.classperms, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tif (rule->perms.x.permx_str != NULL) {\n\t\t\trc = cil_resolve_name(current, rule->perms.x.permx_str, CIL_SYM_PERMX, args, &permx_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trule->perms.x.permx = (struct cil_permissionx*)permx_datum;\n\t\t} else {\n\t\t\trc = cil_resolve_permissionx(current, rule->perms.x.permx, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_type_rule(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_type_rule *rule = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *result_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, rule->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->src = src_datum;\n\n\trc = cil_resolve_name(current, rule->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, rule->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->obj = (struct cil_class*)obj_datum;\n\n\trc = cil_resolve_name(current, rule->result_str, CIL_SYM_TYPES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult_node = NODE(result_datum);\n\n\tif (result_node->flavor != CIL_TYPE) {\n\t\tcil_log(CIL_ERR, \"Type rule result must be a type [%d]\\n\",result_node->flavor);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\trule->result = result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_typeattributeset(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_typeattributeset *attrtypes = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_typeattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, attrtypes->attr_str, CIL_SYM_TYPES, extra_args, &attr_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tattr_node = NODE(attr_datum);\n\n\tif (attr_node->flavor != CIL_TYPEATTRIBUTE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Attribute type not an attribute\\n\");\n\t\tgoto exit;\n\t}\n\n\tattr = (struct cil_typeattribute*)attr_datum;\n\n\trc = cil_resolve_expr(CIL_TYPEATTRIBUTESET, attrtypes->str_expr, &attrtypes->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference(attr_datum, attrtypes->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (attr->expr_list == NULL) {\n\t\tcil_list_init(&attr->expr_list, CIL_TYPEATTRIBUTE);\n\t}\n\n\tcil_list_append(attr->expr_list, CIL_LIST, attrtypes->datum_expr);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_expandtypeattribute(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_expandtypeattribute *expandattr = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_list_item *curr;\n\tint used;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&expandattr->attr_datums, CIL_TYPE);\n\n\tcil_list_for_each(curr, expandattr->attr_strs) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_TYPES, extra_args, &attr_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tattr_node = NODE(attr_datum);\n\n\t\tif (attr_node->flavor != CIL_TYPEATTRIBUTE) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_log(CIL_ERR, \"Attribute type not an attribute\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tused = expandattr->expand ? CIL_ATTR_EXPAND_TRUE : CIL_ATTR_EXPAND_FALSE;\n\t\tcil_type_used(attr_datum, used);\n\t\tcil_list_append(expandattr->attr_datums, CIL_TYPE, attr_datum);\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\treturn rc;\n}\n\nint cil_resolve_aliasactual(struct cil_tree_node *current, void *extra_args, enum cil_flavor flavor, enum cil_flavor alias_flavor)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_sym_index sym_index;\n\tstruct cil_aliasactual *aliasactual = current->data;\n\tstruct cil_symtab_datum *alias_datum = NULL;\n\tstruct cil_symtab_datum *actual_datum = NULL;\n\tstruct cil_alias *alias;\n\n\trc = cil_flavor_to_symtab_index(flavor, &sym_index);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name_keep_aliases(current, aliasactual->alias_str, sym_index, extra_args, &alias_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (FLAVOR(alias_datum) != alias_flavor) {\n\t\tcil_log(CIL_ERR, \"%s is not an alias\\n\",alias_datum->name);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, aliasactual->actual_str, sym_index, extra_args, &actual_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (FLAVOR(actual_datum) != flavor && FLAVOR(actual_datum) != alias_flavor) {\n\t\tcil_log(CIL_ERR, \"%s is a %s, but aliases a %s\\n\", alias_datum->name, cil_node_to_string(NODE(alias_datum)), cil_node_to_string(NODE(actual_datum)));\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\talias = (struct cil_alias *)alias_datum;\n\n\tif (alias->actual != NULL) {\n\t\tcil_log(CIL_ERR, \"%s %s cannot bind more than one value\\n\", cil_node_to_string(NODE(alias_datum)), alias_datum->name);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\talias->actual = actual_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_alias_to_actual(struct cil_tree_node *current, enum cil_flavor flavor)\n{\n\tstruct cil_alias *alias = current->data;\n\tstruct cil_alias *a1 = current->data;\n\tstruct cil_alias *a2 = current->data;\n\tstruct cil_tree_node *a1_node = NULL;\n\tint steps = 0;\n\tint limit = 2;\n\n\tif (alias->actual == NULL) {\n\t\tcil_tree_log(current, CIL_ERR, \"Alias declared but not used\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\ta1_node = a1->datum.nodes->head->data;\n\n\twhile (flavor != a1_node->flavor) {\n\t\tif (a1->actual == NULL) {\n\t\t\tcil_tree_log(current, CIL_ERR, \"Alias %s references an unused alias %s\", alias->datum.name, a1->datum.name);\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t\ta1 = a1->actual;\n\t\ta1_node = a1->datum.nodes->head->data;\n\t\tsteps += 1;\n\n\t\tif (a1 == a2) {\n\t\t\tcil_log(CIL_ERR, \"Circular alias found: %s \", a1->datum.name);\n\t\t\ta1 = a1->actual;\n\t\t\twhile (a1 != a2) {\n\t\t\t\tcil_log(CIL_ERR, \"%s \", a1->datum.name);\n\t\t\t\ta1 = a1->actual;\n\t\t\t}\n\t\t\tcil_log(CIL_ERR,\"\\n\");\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\n\t\tif (steps == limit) {\n\t\t\tsteps = 0;\n\t\t\tlimit *= 2;\n\t\t\ta2 = a1;\n\t\t}\n\t}\n\n\talias->actual = a1;\n\n\treturn SEPOL_OK;\n}\n\nint cil_resolve_typepermissive(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_typepermissive *typeperm = current->data;\n\tstruct cil_symtab_datum *type_datum = NULL;\n\tstruct cil_tree_node *type_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, typeperm->type_str, CIL_SYM_TYPES, extra_args, &type_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ttype_node = NODE(type_datum);\n\n\tif (type_node->flavor != CIL_TYPE && type_node->flavor != CIL_TYPEALIAS) {\n\t\tcil_log(CIL_ERR, \"Typepermissive must be a type or type alias\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\ttypeperm->type = type_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_nametypetransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_nametypetransition *nametypetrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *name_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *result_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, nametypetrans->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->src = src_datum;\n\n\trc = cil_resolve_name(current, nametypetrans->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, nametypetrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->obj = (struct cil_class*)obj_datum;\n\n\tnametypetrans->name = __cil_insert_name(args->db, nametypetrans->name_str, current);\n\tif (nametypetrans->name == NULL) {\n\t\trc = cil_resolve_name(current, nametypetrans->name_str, CIL_SYM_NAMES, extra_args, &name_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnametypetrans->name = (struct cil_name *)name_datum;\n\t}\n\n\trc = cil_resolve_name(current, nametypetrans->result_str, CIL_SYM_TYPES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult_node = NODE(result_datum);\n\n\tif (result_node->flavor != CIL_TYPE && result_node->flavor != CIL_TYPEALIAS) {\n\t\tcil_log(CIL_ERR, \"typetransition result is not a type or type alias\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\tnametypetrans->result = result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_rangetransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_rangetransition *rangetrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *exec_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *range_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, rangetrans->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trangetrans->src = src_datum;\n\n\trc = cil_resolve_name(current, rangetrans->exec_str, CIL_SYM_TYPES, extra_args, &exec_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trangetrans->exec = exec_datum;\n\n\trc = cil_resolve_name(current, rangetrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trangetrans->obj = (struct cil_class*)obj_datum;\n\n\tif (rangetrans->range_str != NULL) {\n\t\trc = cil_resolve_name(current, rangetrans->range_str, CIL_SYM_LEVELRANGES, extra_args, &range_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trangetrans->range = (struct cil_levelrange*)range_datum;\n\n\t\t/* This could still be an anonymous levelrange even if range_str is set, if range_str is a param_str*/\n\t\tif (rangetrans->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, rangetrans->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = cil_resolve_levelrange(current, rangetrans->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint __class_update_perm_values(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_perm *perm = (struct cil_perm *)d;\n\n\tperm->value += *((int *)args);\n\n\treturn SEPOL_OK;\n}\n\nint cil_resolve_classcommon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_class *class = NULL;\n\tstruct cil_class *common = NULL;\n\tstruct cil_classcommon *clscom = current->data;\n\tstruct cil_symtab_datum *class_datum = NULL;\n\tstruct cil_symtab_datum *common_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, clscom->class_str, CIL_SYM_CLASSES, extra_args, &class_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, clscom->common_str, CIL_SYM_COMMONS, extra_args, &common_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)class_datum;\n\tcommon = (struct cil_class *)common_datum;\n\tif (class->common != NULL) {\n\t\tcil_log(CIL_ERR, \"class cannot be associeated with more than one common\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tclass->common = common;\n\n\tcil_symtab_map(&class->perms, __class_update_perm_values, &common->num_perms);\n\n\tclass->num_perms += common->num_perms;\n\tif (class->num_perms > CIL_PERMS_PER_CLASS) {\n\t\tcil_tree_log(current, CIL_ERR, \"Too many permissions in class '%s' when including common permissions\", class->datum.name);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classmapping(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_classmapping *mapping = current->data;\n\tstruct cil_class *map = NULL;\n\tstruct cil_perm *mp = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_list_item *curr;\n\n\trc = cil_resolve_name(current, mapping->map_class_str, CIL_SYM_CLASSES, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tmap = (struct cil_class*)datum;\n\n\trc = cil_symtab_get_datum(&map->perms, mapping->map_perm_str, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tmp = (struct cil_perm*)datum;\n\n\trc = cil_resolve_classperms_list(current, mapping->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (mp->classperms == NULL) {\n\t\tcil_list_init(&mp->classperms, CIL_CLASSPERMS);\n\t}\n\n\tcil_list_for_each(curr, mapping->classperms) {\n\t\tcil_list_append(mp->classperms, curr->flavor, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userrole(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userrole *userrole = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *role_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, userrole->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tuserrole->user = (struct cil_user*)user_datum;\n\n\trc = cil_resolve_name(current, userrole->role_str, CIL_SYM_ROLES, extra_args, &role_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tuserrole->role = role_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userlevel(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userlevel *usrlvl = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *lvl_datum = NULL;\n\tstruct cil_user *user = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, usrlvl->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Userlevel must be a user\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tuser = (struct cil_user*)user_datum;\n\n\tif (usrlvl->level_str != NULL) {\n\t\trc = cil_resolve_name(current, usrlvl->level_str, CIL_SYM_LEVELS, extra_args, &lvl_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tusrlvl->level = (struct cil_level*)lvl_datum;\n\t\tuser->dftlevel = usrlvl->level;\n\n\t\t/* This could still be an anonymous level even if level_str is set, if level_str is a param_str*/\n\t\tif (user->dftlevel->datum.name == NULL) {\n\t\t\trc = cil_resolve_level(current, user->dftlevel, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (usrlvl->level != NULL) {\n\t\trc = cil_resolve_level(current, usrlvl->level, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tuser->dftlevel = usrlvl->level;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userrange(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userrange *userrange = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *range_datum = NULL;\n\tstruct cil_user *user = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, userrange->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Userrange must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tuser = (struct cil_user*)user_datum;\n\n\tif (userrange->range_str != NULL) {\n\t\trc = cil_resolve_name(current, userrange->range_str, CIL_SYM_LEVELRANGES, extra_args, &range_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tuserrange->range = (struct cil_levelrange*)range_datum;\n\t\tuser->range = userrange->range;\n\n\t\t/* This could still be an anonymous levelrange even if levelrange_str is set, if levelrange_str is a param_str*/\n\t\tif (user->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, user->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (userrange->range != NULL) {\n\t\trc = cil_resolve_levelrange(current, userrange->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tuser->range = userrange->range;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userprefix(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userprefix *userprefix = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, userprefix->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Userprefix must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tuserprefix->user = (struct cil_user*)user_datum;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_selinuxuser(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_selinuxuser *selinuxuser = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *lvlrange_datum = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, selinuxuser->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Selinuxuser must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tselinuxuser->user = (struct cil_user*)user_datum;\n\n\tif (selinuxuser->range_str != NULL) {\n\t\trc = cil_resolve_name(current, selinuxuser->range_str, CIL_SYM_LEVELRANGES, extra_args, &lvlrange_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tselinuxuser->range = (struct cil_levelrange*)lvlrange_datum;\n\n\t\t/* This could still be an anonymous levelrange even if range_str is set, if range_str is a param_str*/\n\t\tif (selinuxuser->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, selinuxuser->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (selinuxuser->range != NULL) {\n\t\trc = cil_resolve_levelrange(current, selinuxuser->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roletype(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_roletype *roletype = current->data;\n\tstruct cil_symtab_datum *role_datum = NULL;\n\tstruct cil_symtab_datum *type_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, roletype->role_str, CIL_SYM_ROLES, extra_args, &role_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletype->role = (struct cil_role*)role_datum;\n\n\trc = cil_resolve_name(current, roletype->type_str, CIL_SYM_TYPES, extra_args, &type_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletype->type = (struct cil_type*)type_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roletransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_roletransition *roletrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, roletrans->src_str, CIL_SYM_ROLES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletrans->src = (struct cil_role*)src_datum;\n\n\trc = cil_resolve_name(current, roletrans->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletrans->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, roletrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletrans->obj = (struct cil_class*)obj_datum;\n\n\trc = cil_resolve_name(current, roletrans->result_str, CIL_SYM_ROLES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnode = NODE(result_datum);\n\tif (node->flavor != CIL_ROLE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"roletransition must result in a role, but %s is a %s\\n\", roletrans->result_str, cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\troletrans->result = (struct cil_role*)result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roleallow(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_roleallow *roleallow = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, roleallow->src_str, CIL_SYM_ROLES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troleallow->src = (struct cil_role*)src_datum;\n\n\trc = cil_resolve_name(current, roleallow->tgt_str, CIL_SYM_ROLES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troleallow->tgt = (struct cil_role*)tgt_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roleattributeset(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_roleattributeset *attrroles = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_roleattribute *attr = NULL;\n\n\trc = cil_resolve_name(current, attrroles->attr_str, CIL_SYM_ROLES, extra_args, &attr_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tattr_node = NODE(attr_datum);\n\n\tif (attr_node->flavor != CIL_ROLEATTRIBUTE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Attribute role not an attribute\\n\");\n\t\tgoto exit;\n\t}\n\tattr = (struct cil_roleattribute*)attr_datum;\n\n\trc = cil_resolve_expr(CIL_ROLEATTRIBUTESET, attrroles->str_expr, &attrroles->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference(attr_datum, attrroles->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (attr->expr_list == NULL) {\n\t\tcil_list_init(&attr->expr_list, CIL_ROLEATTRIBUTE);\n\t}\n\n\tcil_list_append(attr->expr_list, CIL_LIST, attrroles->datum_expr);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstruct cil_ordered_list {\n\tint merged;\n\tstruct cil_list *list;\n\tstruct cil_tree_node *node;\n};\n\nvoid __cil_ordered_list_init(struct cil_ordered_list **ordered)\n{\n\t*ordered = cil_malloc(sizeof(**ordered));\n\n\t(*ordered)->merged = CIL_FALSE;\n\t(*ordered)->list = NULL;\n\t(*ordered)->node = NULL;\n}\n\nvoid __cil_ordered_list_destroy(struct cil_ordered_list **ordered)\n{\n\tcil_list_destroy(&(*ordered)->list, CIL_FALSE);\n\t(*ordered)->node = NULL;\n\tfree(*ordered);\n\t*ordered = NULL;\n}\n\nvoid __cil_ordered_lists_destroy(struct cil_list **ordered_lists)\n{\n\tstruct cil_list_item *item = NULL;\n\n\tif (ordered_lists == NULL || *ordered_lists == NULL) {\n\t\treturn;\n\t}\n\n\titem = (*ordered_lists)->head;\n\twhile (item != NULL) {\n\t\tstruct cil_list_item *next = item->next;\n\t\tstruct cil_ordered_list *ordered = item->data;\n\t\t__cil_ordered_list_destroy(&ordered);\n\t\tfree(item);\n\t\titem = next;\n\t}\n\tfree(*ordered_lists);\n\t*ordered_lists = NULL;\n}\n\nvoid __cil_ordered_lists_reset(struct cil_list **ordered_lists)\n{\n\t__cil_ordered_lists_destroy(ordered_lists);\n\tcil_list_init(ordered_lists, CIL_LIST_ITEM);\n}\n\nstruct cil_list_item *__cil_ordered_item_insert(struct cil_list *old, struct cil_list_item *curr, struct cil_list_item *item)\n{\n\tif (item->flavor == CIL_SID) {\n\t\tstruct cil_sid *sid = item->data;\n\t\tif (sid->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"SID %s has already been merged into the ordered list\\n\", sid->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsid->ordered = CIL_TRUE;\n\t} else if (item->flavor == CIL_CLASS) {\n\t\tstruct cil_class *class = item->data;\n\t\tif (class->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"Class %s has already been merged into the ordered list\\n\", class->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tclass->ordered = CIL_TRUE;\n\t} else if (item->flavor == CIL_CAT) {\n\t\tstruct cil_cat *cat = item->data;\n\t\tif (cat->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"Category %s has already been merged into the ordered list\\n\", cat->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tcat->ordered = CIL_TRUE;\n\t} else if (item->flavor == CIL_SENS) {\n\t\tstruct cil_sens *sens = item->data;\n\t\tif (sens->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"Sensitivity %s has already been merged into the ordered list\\n\", sens->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsens->ordered = CIL_TRUE;\n\t}\n\n\treturn cil_list_insert(old, curr, item->flavor, item->data);\n}\n\nint __cil_ordered_list_insert(struct cil_list *old, struct cil_list_item *ocurr, struct cil_list_item *nstart, struct cil_list_item *nstop)\n{\n\tstruct cil_list_item *ncurr = NULL;\n\n\tfor (ncurr = nstart; ncurr != nstop; ncurr = ncurr->next) {\n\t\tocurr = __cil_ordered_item_insert(old, ocurr, ncurr);\n\t\tif (ocurr == NULL) {\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}\n\nstruct cil_list_item *__cil_ordered_find_match(struct cil_list_item *t, struct cil_list_item *i)\n{\n\twhile (i) {\n\t\tif (i->data == t->data) {\n\t\t\treturn i;\n\t\t}\n\t\ti = i->next;\n\t}\n\treturn NULL;\n}\n\nint __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nstatic int insert_unordered(struct cil_list *merged, struct cil_list *unordered)\n{\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_ordered_list *unordered_list = NULL;\n\tstruct cil_list_item *item = NULL;\n\tstruct cil_list_item *ret = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_for_each(curr, unordered) {\n\t\tunordered_list = curr->data;\n\n\t\tcil_list_for_each(item, unordered_list->list) {\n\t\t\tif (cil_list_contains(merged, item->data)) {\n\t\t\t\t/* item was declared in an ordered statement, which supersedes\n\t\t\t\t * all unordered statements */\n\t\t\t\tif (item->flavor == CIL_CLASS) {\n\t\t\t\t\tcil_log(CIL_WARN, \"Ignoring '%s' as it has already been declared in classorder.\\n\", ((struct cil_class*)(item->data))->datum.name);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = __cil_ordered_item_insert(merged, merged->tail, item);\n\t\t\tif (ret == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstruct cil_list *__cil_ordered_lists_merge_all(struct cil_list **ordered_lists, struct cil_list **unordered_lists)\n{\n\tstruct cil_list *composite = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint changed = CIL_TRUE;\n\tint waiting = 1;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&composite, CIL_LIST_ITEM);\n\n\twhile (waiting && changed == CIL_TRUE) {\n\t\tchanged = CIL_FALSE;\n\t\twaiting = 0;\n\t\tcil_list_for_each(curr, *ordered_lists) {\n\t\t\tstruct cil_ordered_list *ordered_list = curr->data;\n\t\t\tif (ordered_list->merged == CIL_FALSE) {\n\t\t\t\trc = __cil_ordered_lists_merge(composite, ordered_list->list);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t/* Can't merge yet */\n\t\t\t\t\twaiting++;\n\t\t\t\t} else {\n\t\t\t\t\tordered_list->merged = CIL_TRUE;\n\t\t\t\t\tchanged = CIL_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (waiting > 0 && changed == CIL_FALSE) {\n\t\t\tcil_list_for_each(curr, *ordered_lists) {\n\t\t\t\tstruct cil_ordered_list *ordered_list = curr->data;\n\t\t\t\tif (ordered_list->merged == CIL_FALSE) {\n\t\t\t\t\tcil_tree_log(ordered_list->node, CIL_ERR, \"Unable to merge ordered list\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (unordered_lists != NULL) {\n\t\trc = insert_unordered(composite, *unordered_lists);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t__cil_ordered_lists_destroy(ordered_lists);\n\t__cil_ordered_lists_destroy(unordered_lists);\n\n\treturn composite;\n\nexit:\n\t__cil_ordered_lists_destroy(ordered_lists);\n\t__cil_ordered_lists_destroy(unordered_lists);\n\tcil_list_destroy(&composite, CIL_FALSE);\n\treturn NULL;\n}\n\nint cil_resolve_classorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *classorder_list = args->classorder_lists;\n\tstruct cil_list *unordered_classorder_list = args->unordered_classorder_lists;\n\tstruct cil_classorder *classorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *class_list = NULL;\n\tint rc = SEPOL_ERR;\n\tint unordered = CIL_FALSE;\n\n\tcil_list_init(&new, CIL_CLASSORDER);\n\n\tcil_list_for_each(curr, classorder->class_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tunordered = CIL_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve class %s in classorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_CLASS, datum);\n\t}\n\n\t__cil_ordered_list_init(&class_list);\n\tclass_list->list = new;\n\tclass_list->node = current;\n\tif (unordered) {\n\t\tcil_list_append(unordered_classorder_list, CIL_CLASSORDER, class_list);\n\t} else {\n\t\tcil_list_append(classorder_list, CIL_CLASSORDER, class_list);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_sidorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *sidorder_list = args->sidorder_lists;\n\tstruct cil_sidorder *sidorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *ordered = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&new, CIL_SIDORDER);\n\n\tcil_list_for_each(curr, sidorder->sid_list_str) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_SIDS, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve sid %s in sidorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_SID, datum);\n\t}\n\n\t__cil_ordered_list_init(&ordered);\n\tordered->list = new;\n\tordered->node = current;\n\tcil_list_append(sidorder_list, CIL_SIDORDER, ordered);\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nvoid cil_set_cat_values(struct cil_list *ordered_cats, struct cil_db *db)\n{\n\tstruct cil_list_item *curr;\n\tint v = 0;\n\n\tcil_list_for_each(curr, ordered_cats) {\n\t\tstruct cil_cat *cat = curr->data;\n\t\tcat->value = v;\n\t\tv++;\n\t}\n\n\tdb->num_cats = v;\n}\n\nint cil_resolve_catorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *catorder_list = args->catorder_lists;\n\tstruct cil_catorder *catorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *cat_datum;\n\tstruct cil_cat *cat = NULL;\n\tstruct cil_ordered_list *ordered = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&new, CIL_CATORDER);\n\n\tcil_list_for_each(curr, catorder->cat_list_str) {\n\t\tstruct cil_tree_node *node = NULL;\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CATS, extra_args, &cat_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve category %s in categoryorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tnode = NODE(cat_datum);\n\t\tif (node->flavor != CIL_CAT) {\n\t\t\tcil_log(CIL_ERR, \"%s is not a category. Only categories are allowed in categoryorder statements\\n\", cat_datum->name);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t\tcat = (struct cil_cat *)cat_datum;\n\t\tcil_list_append(new, CIL_CAT, cat);\n\t}\n\n\t__cil_ordered_list_init(&ordered);\n\tordered->list = new;\n\tordered->node = current;\n\tcil_list_append(catorder_list, CIL_CATORDER, ordered);\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_sensitivityorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *sensitivityorder_list = args->sensitivityorder_lists;\n\tstruct cil_sensorder *sensorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *ordered = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&new, CIL_LIST_ITEM);\n\n\tcil_list_for_each(curr, sensorder->sens_list_str) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_SENS, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve sensitivty %s in sensitivityorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_SENS, datum);\n\t}\n\n\t__cil_ordered_list_init(&ordered);\n\tordered->list = new;\n\tordered->node = current;\n\tcil_list_append(sensitivityorder_list, CIL_SENSITIVITYORDER, ordered);\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_cats(struct cil_tree_node *current, struct cil_cats *cats, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_expr(CIL_CATSET, cats->str_expr, &cats->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\t\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\nint cil_resolve_catset(struct cil_tree_node *current, struct cil_catset *catset, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_cats(current, catset->cats, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference((struct cil_symtab_datum *)catset, catset->cats->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tcil_list_destroy(&catset->cats->datum_expr, CIL_FALSE);\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_senscat(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_senscat *senscat = current->data;\n\tstruct cil_symtab_datum *sens_datum;\n\tstruct cil_sens *sens = NULL;\n\n\trc = cil_resolve_name(current, (char*)senscat->sens_str, CIL_SYM_SENS, extra_args, &sens_datum);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to find sensitivity\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_cats(current, senscat->cats, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tsens = (struct cil_sens *)sens_datum;\n\n\tif (sens->cats_list == NULL ) {\n\t\tcil_list_init(&sens->cats_list, CIL_CAT);\n\t}\n\n\tcil_list_append(sens->cats_list, CIL_CAT, senscat->cats);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_level(struct cil_tree_node *current, struct cil_level *level, void *extra_args)\n{\n\tstruct cil_symtab_datum *sens_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, (char*)level->sens_str, CIL_SYM_SENS, extra_args, &sens_datum);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to find sensitivity\\n\");\n\t\tgoto exit;\n\t}\n\n\tlevel->sens = (struct cil_sens *)sens_datum;\n\n\tif (level->cats != NULL) {\n\t\trc = cil_resolve_cats(current, level->cats, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_levelrange(struct cil_tree_node *current, struct cil_levelrange *lvlrange, void *extra_args)\n{\n\tstruct cil_symtab_datum *low_datum = NULL;\n\tstruct cil_symtab_datum *high_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (lvlrange->low_str != NULL) {\n\t\trc = cil_resolve_name(current, lvlrange->low_str, CIL_SYM_LEVELS, extra_args, &low_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tlvlrange->low = (struct cil_level*)low_datum;\n\n\t\t/* This could still be an anonymous level even if low_str is set, if low_str is a param_str */\n\t\tif (lvlrange->low->datum.name == NULL) {\n\t\t\trc = cil_resolve_level(current, lvlrange->low, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (lvlrange->low != NULL) {\n\t\trc = cil_resolve_level(current, lvlrange->low, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (lvlrange->high_str != NULL) {\n\t\trc = cil_resolve_name(current, lvlrange->high_str, CIL_SYM_LEVELS, extra_args, &high_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tlvlrange->high = (struct cil_level*)high_datum;\n\n\t\t/* This could still be an anonymous level even if high_str is set, if high_str is a param_str */\n\t\tif (lvlrange->high->datum.name == NULL) {\n\t\t\trc = cil_resolve_level(current, lvlrange->high, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (lvlrange->high != NULL) {\n\t\trc = cil_resolve_level(current, lvlrange->high, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_constrain(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_constrain *cons = current->data;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_classperms_list(current, cons->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_expr(CIL_CONSTRAIN, cons->str_expr, &cons->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_validatetrans(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_validatetrans *validtrans = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_symtab_datum *class_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, validtrans->class_str, CIL_SYM_CLASSES, args, &class_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tvalidtrans->class = (struct cil_class*)class_datum;\n\n\trc = cil_resolve_expr(CIL_VALIDATETRANS, validtrans->str_expr, &validtrans->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_context(struct cil_tree_node *current, struct cil_context *context, void *extra_args)\n{\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *role_datum = NULL;\n\tstruct cil_symtab_datum *type_datum = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tstruct cil_symtab_datum *lvlrange_datum = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, context->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(user_datum);\n\n\tif (node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Context user must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tcontext->user = (struct cil_user*)user_datum;\n\n\trc = cil_resolve_name(current, context->role_str, CIL_SYM_ROLES, extra_args, &role_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(role_datum);\n\tif (node->flavor != CIL_ROLE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Context role not a role: %s\\n\", role_datum->fqn);\n\t\tgoto exit;\n\t}\n\n\tcontext->role = (struct cil_role*)role_datum;\n\n\trc = cil_resolve_name(current, context->type_str, CIL_SYM_TYPES, extra_args, &type_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(type_datum);\n\n\tif (node->flavor != CIL_TYPE && node->flavor != CIL_TYPEALIAS) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Type not a type or type alias\\n\");\n\t\tgoto exit;\n\t}\n\tcontext->type = type_datum;\n\n\tif (context->range_str != NULL) {\n\t\trc = cil_resolve_name(current, context->range_str, CIL_SYM_LEVELRANGES, extra_args, &lvlrange_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcontext->range = (struct cil_levelrange*)lvlrange_datum;\n\n\t\t/* This could still be an anonymous levelrange even if levelrange_str is set, if levelrange_str is a param_str*/\n\t\tif (context->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, context->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (context->range != NULL) {\n\t\trc = cil_resolve_levelrange(current, context->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_filecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_filecon *filecon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (filecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, filecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t\tfilecon->context = (struct cil_context*)context_datum;\n\t} else if (filecon->context != NULL) {\n\t\trc = cil_resolve_context(current, filecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_resolve_ibpkeycon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_ibpkeycon *ibpkeycon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (ibpkeycon->context_str) {\n\t\trc = cil_resolve_name(current, ibpkeycon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\n\t\tibpkeycon->context = (struct cil_context *)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, ibpkeycon->context, extra_args);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_portcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_portcon *portcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (portcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, portcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tportcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, portcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_genfscon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_genfscon *genfscon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (genfscon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, genfscon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tgenfscon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, genfscon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_nodecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_nodecon *nodecon = current->data;\n\tstruct cil_symtab_datum *addr_datum = NULL;\n\tstruct cil_symtab_datum *mask_datum = NULL;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nodecon->addr_str != NULL) {\n\t\trc = cil_resolve_name(current, nodecon->addr_str, CIL_SYM_IPADDRS, extra_args, &addr_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnodecon->addr = (struct cil_ipaddr*)addr_datum;\n\t}\n\n\tif (nodecon->mask_str != NULL) {\n\t\trc = cil_resolve_name(current, nodecon->mask_str, CIL_SYM_IPADDRS, extra_args, &mask_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnodecon->mask = (struct cil_ipaddr*)mask_datum;\n\t}\n\n\tif (nodecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, nodecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnodecon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, nodecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (nodecon->addr->family != nodecon->mask->family) {\n\t\tcil_log(CIL_ERR, \"Nodecon ip address not in the same family\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_netifcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_netifcon *netifcon = current->data;\n\tstruct cil_symtab_datum *ifcon_datum = NULL;\n\tstruct cil_symtab_datum *packcon_datum = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\tif (netifcon->if_context_str != NULL) {\n\t\trc = cil_resolve_name(current, netifcon->if_context_str, CIL_SYM_CONTEXTS, extra_args, &ifcon_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnetifcon->if_context = (struct cil_context*)ifcon_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, netifcon->if_context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (netifcon->packet_context_str != NULL) {\n\t\trc = cil_resolve_name(current, netifcon->packet_context_str, CIL_SYM_CONTEXTS, extra_args, &packcon_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnetifcon->packet_context = (struct cil_context*)packcon_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, netifcon->packet_context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_ibendportcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_ibendportcon *ibendportcon = current->data;\n\tstruct cil_symtab_datum *con_datum = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\tif (ibendportcon->context_str) {\n\t\trc = cil_resolve_name(current, ibendportcon->context_str, CIL_SYM_CONTEXTS, extra_args, &con_datum);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\n\t\tibendportcon->context = (struct cil_context *)con_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, ibendportcon->context, extra_args);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_pirqcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_pirqcon *pirqcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (pirqcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, pirqcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tpirqcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, pirqcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_iomemcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_iomemcon *iomemcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (iomemcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, iomemcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tiomemcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, iomemcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_ioportcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_ioportcon *ioportcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (ioportcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, ioportcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tioportcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, ioportcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_pcidevicecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_pcidevicecon *pcidevicecon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (pcidevicecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, pcidevicecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tpcidevicecon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, pcidevicecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_devicetreecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_devicetreecon *devicetreecon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (devicetreecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, devicetreecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tdevicetreecon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, devicetreecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_fsuse(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_fsuse *fsuse = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (fsuse->context_str != NULL) {\n\t\trc = cil_resolve_name(current, fsuse->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tfsuse->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, fsuse->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_sidcontext(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_sidcontext *sidcon = current->data;\n\tstruct cil_symtab_datum *sid_datum = NULL;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tstruct cil_sid *sid = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, sidcon->sid_str, CIL_SYM_SIDS, extra_args, &sid_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tsid = (struct cil_sid*)sid_datum;\n\n\tif (sidcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, sidcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tsidcon->context = (struct cil_context*)context_datum;\n\t} else if (sidcon->context != NULL) {\n\t\trc = cil_resolve_context(current, sidcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (sid->context != NULL) {\n\t\tcil_log(CIL_ERR, \"sid's cannot be associated with more than one context\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tsid->context = sidcon->context;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_blockinherit_link(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_blockinherit *inherit = current->data;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, inherit->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(block_datum);\n\n\tif (node->flavor != CIL_BLOCK) {\n\t\tcil_log(CIL_ERR, \"%s is not a block\\n\", cil_node_to_string(node));\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tinherit->block = (struct cil_block *)block_datum;\n\n\tif (inherit->block->bi_nodes == NULL) {\n\t\tcil_list_init(&inherit->block->bi_nodes, CIL_NODE);\n\t}\n\tcil_list_append(inherit->block->bi_nodes, CIL_NODE, current);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_print_recursive_blockinherit(struct cil_tree_node *bi_node, struct cil_tree_node *terminating_node)\n{\n\tstruct cil_list *trace = NULL;\n\tstruct cil_list_item *item = NULL;\n\tstruct cil_tree_node *curr = NULL;\n\n\tcil_list_init(&trace, CIL_NODE);\n\n\tfor (curr = bi_node; curr != terminating_node; curr = curr->parent) {\n\t\tif (curr->flavor == CIL_BLOCK) {\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t} else if (curr->flavor == CIL_BLOCKINHERIT) {\n\t\t\tif (curr != bi_node) {\n\t\t\t\tcil_list_prepend(trace, CIL_NODE, NODE(((struct cil_blockinherit *)curr->data)->block));\n\t\t\t}\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t} else {\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t}\n\t}\n\tcil_list_prepend(trace, CIL_NODE, terminating_node);\n\n\tcil_list_for_each(item, trace) {\n\t\tcurr = item->data;\n\t\tif (curr->flavor == CIL_BLOCK) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"block %s\", DATUM(curr->data)->name);\n\t\t} else if (curr->flavor == CIL_BLOCKINHERIT) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"blockinherit %s\", ((struct cil_blockinherit *)curr->data)->block_str);\n\t\t} else if (curr->flavor == CIL_OPTIONAL) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"optional %s\", DATUM(curr->data)->name);\n\t\t} else {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"%s\", cil_node_to_string(curr));\n\t\t}\n\t}\n\n\tcil_list_destroy(&trace, CIL_FALSE);\n}\n\nint cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)\n{\n\tstruct cil_tree_node *curr = NULL;\n\tstruct cil_blockinherit *bi = NULL;\n\tstruct cil_block *block = NULL;\n\tint rc = SEPOL_ERR;\n\n\tbi = bi_node->data;\n\n\tfor (curr = bi_node->parent; curr != NULL; curr = curr->parent) {\n\t\tif (curr->flavor != CIL_BLOCK) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock = curr->data;\n\n\t\tif (block != bi->block) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcil_log(CIL_ERR, \"Recursive blockinherit found:\\n\");\n\t\tcil_print_recursive_blockinherit(bi_node, curr);\n\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_blockinherit_copy(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_block *block = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tstruct cil_list_item *item = NULL;\n\tint rc = SEPOL_ERR;\n\n\t// This block is not inherited\n\tif (block->bi_nodes == NULL) {\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tdb = args->db;\n\n\t// Make sure this is the original block and not a merged block from a blockinherit\n\tif (current != block->datum.nodes->head->data) {\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(item, block->bi_nodes) {\n\t\trc = cil_check_recursive_blockinherit(item->data);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\trc = cil_copy_ast(db, current, item->data);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to copy block contents into blockinherit\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_blockabstract(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_blockabstract *abstract = current->data;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *block_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, abstract->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tblock_node = NODE(block_datum);\n\tif (block_node->flavor != CIL_BLOCK) {\n\t\tcil_log(CIL_ERR, \"Failed to resolve blockabstract to a block, rc: %d\\n\", rc);\n\t\tgoto exit;\n\t}\n\n\t((struct cil_block*)block_datum)->is_abstract = CIL_TRUE;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_in(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_in *in = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *block_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, in->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tblock_node = NODE(block_datum);\n\n\trc = cil_copy_ast(db, current, block_node);\n\tif (rc != SEPOL_OK) {\n\t\tcil_tree_log(current, CIL_ERR, \"Failed to copy in-statement\");\n\t\tgoto exit;\n\t}\n\n\tcil_tree_children_destroy(current);\n\tcurrent->cl_head = NULL;\n\tcurrent->cl_tail = NULL;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_in_list(void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *ins = args->in_list;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tstruct cil_tree_node *last_failed_node = NULL;\n\tstruct cil_in *in = NULL;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tint resolved = 0;\n\tint unresolved = 0;\n\tint rc = SEPOL_ERR;\n\n\tdo {\n\t\tresolved = 0;\n\t\tunresolved = 0;\n\n\t\tcil_list_for_each(curr, ins) {\n\t\t\tif (curr->flavor != CIL_NODE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnode = curr->data;\n\t\t\tin = node->data;\n\n\t\t\trc = cil_resolve_name(node, in->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tunresolved++;\n\t\t\t\tlast_failed_node = node;\n\t\t\t} else {\n\t\t\t\trc = cil_resolve_in(node, extra_args);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolved++;\n\t\t\t\tcurr->data = NULL;\n\t\t\t\tcurr->flavor = CIL_NONE;\n\t\t\t}\n\t\t}\n\n\t\tif (unresolved > 0 && resolved == 0) {\n\t\t\tcil_tree_log(last_failed_node, CIL_ERR, \"Failed to resolve in-statement\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t} while (unresolved > 0);\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\nint cil_resolve_bounds(struct cil_tree_node *current, void *extra_args, enum cil_flavor flavor, enum cil_flavor attr_flavor)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_bounds *bounds = current->data;\n\tenum cil_sym_index index;\n\tstruct cil_symtab_datum *parent_datum = NULL;\n\tstruct cil_symtab_datum *child_datum = NULL;\n\n\trc = cil_flavor_to_symtab_index(flavor, &index);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, bounds->parent_str, index, extra_args, &parent_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (FLAVOR(parent_datum) == attr_flavor) {\n\t\tcil_log(CIL_ERR, \"Bounds parent %s is an attribute\\n\", bounds->parent_str);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\n\trc = cil_resolve_name(current, bounds->child_str, index, extra_args, &child_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (FLAVOR(child_datum) == attr_flavor) {\n\t\tcil_log(CIL_ERR, \"Bounds child %s is an attribute\\n\", bounds->child_str);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tswitch (flavor) {\n\tcase CIL_USER: {\n\t\tstruct cil_user *user = (struct cil_user *)child_datum;\n\n\t\tif (user->bounds != NULL) {\n\t\t\tcil_tree_log(NODE(user->bounds), CIL_ERR, \"User %s already bound by parent\", bounds->child_str);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tuser->bounds = (struct cil_user *)parent_datum;\n\t\tbreak;\n\t}\n\tcase CIL_ROLE: {\n\t\tstruct cil_role *role = (struct cil_role *)child_datum;\n\n\t\tif (role->bounds != NULL) {\n\t\t\tcil_tree_log(NODE(role->bounds), CIL_ERR, \"Role %s already bound by parent\", bounds->child_str);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\trole->bounds = (struct cil_role *)parent_datum;\n\t\tbreak;\n\t}\n\tcase CIL_TYPE: {\n\t\tstruct cil_type *type = (struct cil_type *)child_datum;\n\n\t\tif (type->bounds != NULL) {\n\t\t\tcil_tree_log(NODE(type->bounds), CIL_ERR, \"Type %s already bound by parent\", bounds->child_str);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttype->bounds = (struct cil_type *)parent_datum;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(current, CIL_ERR, \"Bad bounds statement\");\n\treturn rc;\n}\n\nint cil_resolve_default(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_default *def = current->data;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\n\tcil_list_init(&def->class_datums, def->flavor);\n\n\tcil_list_for_each(curr, def->class_strs) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(def->class_datums, CIL_CLASS, datum);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_defaultrange(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_defaultrange *def = current->data;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\n\tcil_list_init(&def->class_datums, CIL_DEFAULTRANGE);\n\n\tcil_list_for_each(curr, def->class_strs) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(def->class_datums, CIL_CLASS, datum);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_print_recursive_call(struct cil_tree_node *call_node, struct cil_tree_node *terminating_node)\n{\n\tstruct cil_list *trace = NULL;\n\tstruct cil_list_item * item = NULL;\n\tstruct cil_tree_node *curr = NULL;\n\n\tcil_list_init(&trace, CIL_NODE);\n\n\tfor (curr = call_node; curr != terminating_node; curr = curr->parent) {\n\t\tif (curr->flavor == CIL_CALL) {\n\t\t\tif (curr != call_node) {\n\t\t\t\tcil_list_prepend(trace, CIL_NODE, NODE(((struct cil_call *)curr->data)->macro));\n\t\t\t}\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t}\n\t}\n\n\tif (terminating_node->flavor == CIL_MACRO) {\n\t\tcil_list_prepend(trace, CIL_NODE, terminating_node);\n\t} else {\n\t\tcil_list_prepend(trace, CIL_NODE, NODE(((struct cil_call *)terminating_node->data)->macro));\n\t}\n\n\tcil_list_for_each(item, trace) {\n\t\tcurr = item->data;\n\t\tif (curr->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"macro %s\", DATUM(curr->data)->name);\n\t\t} else {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"call %s\", ((struct cil_call *)curr->data)->macro_str);\n\t\t}\n\t}\n\n\tcil_list_destroy(&trace, CIL_FALSE);\n}\n\nint cil_check_recursive_call(struct cil_tree_node *call_node, struct cil_tree_node *macro_node)\n{\n\tstruct cil_tree_node *curr = NULL;\n\tstruct cil_call * call = NULL;\n\tint rc = SEPOL_ERR;\n\n\tfor (curr = call_node; curr != NULL; curr = curr->parent) {\n\t\tif (curr->flavor == CIL_CALL) {\n\t\t\tif (curr == call_node) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcall = curr->data;\n\t\t\tif (call->macro != macro_node->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (curr->flavor == CIL_MACRO) {\n\t\t\tif (curr != macro_node) {\n\t\t\t\trc = SEPOL_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcil_log(CIL_ERR, \"Recursive macro call found:\\n\");\n\t\tcil_print_recursive_call(call_node, curr);\n\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\nexit:\n\treturn rc;\n}\n\nint cil_resolve_call1(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_call *new_call = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tstruct cil_tree_node *macro_node = NULL;\n\tstruct cil_symtab_datum *macro_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, new_call->macro_str, CIL_SYM_BLOCKS, extra_args, &macro_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tmacro_node = NODE(macro_datum);\n\n\tif (macro_node->flavor != CIL_MACRO) {\n\t\tcil_tree_log(current, CIL_ERR, \"Failed to resolve %s to a macro\", new_call->macro_str);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\tnew_call->macro = (struct cil_macro*)macro_datum;\n\n\tif (new_call->macro->params != NULL ) {\n\n\t\tstruct cil_list_item *item;\n\t\tstruct cil_args *new_arg = NULL;\n\t\tstruct cil_tree_node *pc = NULL;\n\n\t\tif (new_call->args_tree == NULL) {\n\t\t\tcil_tree_log(current, CIL_ERR, \"Missing arguments\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpc = new_call->args_tree->root->cl_head;\n\n\t\tcil_list_init(&new_call->args, CIL_LIST_ITEM);\n\n\t\tcil_list_for_each(item, new_call->macro->params) {\n\t\t\tenum cil_flavor flavor = ((struct cil_param*)item->data)->flavor;\n\n\t\t\tif (pc == NULL) {\n\t\t\t\tcil_tree_log(current, CIL_ERR, \"Missing arguments\");\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (item->flavor != CIL_PARAM) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tcil_args_init(&new_arg);\n\n\t\t\tswitch (flavor) {\n\t\t\tcase CIL_NAME: {\n\t\t\t\tstruct cil_name *name;\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tname = __cil_insert_name(args->db, pc->data, current);\n\t\t\t\tif (name != NULL) {\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum *)name;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CIL_TYPE:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_ROLE:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_USER:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_SENS:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_CAT:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_BOOL:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_CATSET: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_catset *catset = NULL;\n\t\t\t\t\tstruct cil_tree_node *cat_node = NULL;\n\t\t\t\t\tcil_catset_init(&catset);\n\t\t\t\t\trc = cil_fill_cats(pc, &catset->cats);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_destroy_catset(catset);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&cat_node);\n\t\t\t\t\tcat_node->flavor = CIL_CATSET;\n\t\t\t\t\tcat_node->data = catset;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)catset)->nodes,\n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, cat_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)catset;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_LEVEL: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_level *level = NULL;\n\t\t\t\t\tstruct cil_tree_node *lvl_node = NULL;\n\t\t\t\t\tcil_level_init(&level);\n\n\t\t\t\t\trc = cil_fill_level(pc->cl_head, level);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous level, rc: %d\\n\", rc);\n\t\t\t\t\t\tcil_destroy_level(level);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&lvl_node);\n\t\t\t\t\tlvl_node->flavor = CIL_LEVEL;\n\t\t\t\t\tlvl_node->data = level;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)level)->nodes, \n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, lvl_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)level;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_LEVELRANGE: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_levelrange *range = NULL;\n\t\t\t\t\tstruct cil_tree_node *range_node = NULL;\n\t\t\t\t\tcil_levelrange_init(&range);\n\n\t\t\t\t\trc = cil_fill_levelrange(pc->cl_head, range);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous levelrange, rc: %d\\n\", rc);\n\t\t\t\t\t\tcil_destroy_levelrange(range);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&range_node);\n\t\t\t\t\trange_node->flavor = CIL_LEVELRANGE;\n\t\t\t\t\trange_node->data = range;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)range)->nodes, \n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, range_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)range;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_IPADDR: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_ipaddr *ipaddr = NULL;\n\t\t\t\t\tstruct cil_tree_node *addr_node = NULL;\n\t\t\t\t\tcil_ipaddr_init(&ipaddr);\n\n\t\t\t\t\trc = cil_fill_ipaddr(pc->cl_head, ipaddr);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous ip address, rc: %d\\n\", rc);\n\t\t\t\t\t\tcil_destroy_ipaddr(ipaddr);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&addr_node);\n\t\t\t\t\taddr_node->flavor = CIL_IPADDR;\n\t\t\t\t\taddr_node->data = ipaddr;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)ipaddr)->nodes,\n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, addr_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)ipaddr;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_CLASS:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_MAP_CLASS:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_CLASSPERMISSION: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_classpermission *cp = NULL;\n\t\t\t\t\tstruct cil_tree_node *cp_node = NULL;\n\n\t\t\t\t\tcil_classpermission_init(&cp);\n\t\t\t\t\trc = cil_fill_classperms_list(pc, &cp->classperms);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous classpermission\\n\");\n\t\t\t\t\t\tcil_destroy_classpermission(cp);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&cp_node);\n\t\t\t\t\tcp_node->flavor = CIL_CLASSPERMISSION;\n\t\t\t\t\tcp_node->data = cp;\n\t\t\t\t\tcil_list_append(cp->datum.nodes, CIL_LIST_ITEM, cp_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)cp;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tcil_log(CIL_ERR, \"Unexpected flavor: %d\\n\", \n\t\t\t\t\t\t(((struct cil_param*)item->data)->flavor));\n\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tnew_arg->param_str = ((struct cil_param*)item->data)->str;\n\t\t\tnew_arg->flavor = flavor;\n\n\t\t\tcil_list_append(new_call->args, CIL_ARGS, new_arg);\n\n\t\t\tpc = pc->next;\n\t\t}\n\n\t\tif (pc != NULL) {\n\t\t\tcil_tree_log(current, CIL_ERR, \"Unexpected arguments\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else if (new_call->args_tree != NULL) {\n\t\tcil_tree_log(current, CIL_ERR, \"Unexpected arguments\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tif (new_call->copied == 0) {\n\t\tnew_call->copied = 1;\n\n\t\trc = cil_check_recursive_call(current, macro_node);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\trc = cil_copy_ast(db, macro_node, current);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to copy macro, rc: %d\\n\", rc);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_call2(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_call *new_call = current->data;\n\tint rc = SEPOL_ERR;\n\tenum cil_sym_index sym_index = CIL_SYM_UNKNOWN;\n\tstruct cil_list_item *item;\n\n\tif (new_call->args == NULL) {\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(item, new_call->args) {\n\t\tstruct cil_args *arg = item->data;\n\t\tif (arg->arg == NULL && arg->arg_str == NULL) {\n\t\t\tcil_log(CIL_ERR, \"Arguments not created correctly\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tswitch (arg->flavor) {\n\t\tcase CIL_NAME:\n\t\t\tif (arg->arg != NULL) {\n\t\t\t\tcontinue; /* No need to resolve */\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_NAMES;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_LEVELS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_LEVELRANGES;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_CATSET:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_CATS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_IPADDR:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_IPADDRS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSION:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_CLASSPERMSETS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_TYPE:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_TYPES;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_ROLE:\n\t\t\tsym_index = CIL_SYM_ROLES;\n\t\t\tbreak;\n\t\tcase CIL_USER:\n\t\t\tsym_index = CIL_SYM_USERS;\n\t\t\tbreak;\n\t\tcase CIL_SENS:\n\t\t\tsym_index = CIL_SYM_SENS;\n\t\t\tbreak;\n\t\tcase CIL_CAT:\n\t\t\tsym_index = CIL_SYM_CATS;\n\t\t\tbreak;\n\t\tcase CIL_CLASS:\n\t\tcase CIL_MAP_CLASS:\n\t\t\tsym_index = CIL_SYM_CLASSES;\n\t\t\tbreak;\n\t\tcase CIL_BOOL:\n\t\t\tsym_index = CIL_SYM_BOOLS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (sym_index != CIL_SYM_UNKNOWN) {\n\t\t\trc = cil_resolve_name(current, arg->arg_str, sym_index, extra_args, &(arg->arg));\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_name_call_args(struct cil_call *call, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tstruct cil_list_item *item;\n\tenum cil_sym_index param_index = CIL_SYM_UNKNOWN;\n\tint rc = SEPOL_ERR;\n\n\tif (call == NULL || name == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (call->args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(item, call->args) {\n\t\tstruct cil_args * arg = item->data;\n\t\trc = cil_flavor_to_symtab_index(arg->flavor, &param_index);\n\t\tif (param_index == sym_index) {\n\t\t\tif (name == arg->param_str) {\n\t\t\t\t*datum = arg->arg;\n\t\t\t\trc = SEPOL_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_ERR;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_expr(enum cil_flavor expr_type, struct cil_list *str_expr, struct cil_list **datum_expr, struct cil_tree_node *parent, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *res_datum = NULL;\n\tenum cil_sym_index sym_index =  CIL_SYM_UNKNOWN;\n\n\tswitch (str_expr->flavor) {\n\tcase CIL_BOOL:\n\t\tsym_index = CIL_SYM_BOOLS;\n\t\tbreak;\n\tcase CIL_TUNABLE:\n\t\tsym_index = CIL_SYM_TUNABLES;\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tsym_index = CIL_SYM_TYPES;\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tsym_index = CIL_SYM_ROLES;\n\t\tbreak;\n\tcase CIL_USER:\n\t\tsym_index = CIL_SYM_USERS;\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tsym_index = CIL_SYM_CATS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcil_list_init(datum_expr, str_expr->flavor);\n\n\tcil_list_for_each(curr, str_expr) {\n\t\tswitch (curr->flavor) {\n\t\tcase CIL_STRING:\n\t\t\trc = cil_resolve_name(parent, curr->data, sym_index, extra_args, &res_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (sym_index == CIL_SYM_TYPES && (expr_type == CIL_CONSTRAIN || expr_type == CIL_VALIDATETRANS)) {\n\t\t\t\tcil_type_used(res_datum, CIL_ATTR_CONSTRAINT);\n\t\t\t}\n\n\t\t\tcil_list_append(*datum_expr, CIL_DATUM, res_datum);\n\t\t\tbreak;\n\t\tcase CIL_LIST: {\n\t\t\tstruct cil_list *datum_sub_expr;\n\t\t\trc = cil_resolve_expr(expr_type, curr->data, &datum_sub_expr, parent, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_list_destroy(&datum_sub_expr, CIL_TRUE);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_append(*datum_expr, CIL_LIST, datum_sub_expr);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcil_list_append(*datum_expr, curr->flavor, curr->data);\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t}\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_boolif(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_booleanif *bif = (struct cil_booleanif*)current->data;\n\n\trc = cil_resolve_expr(CIL_BOOLEANIF, bif->str_expr, &bif->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstatic int __cil_evaluate_tunable_expr(struct cil_list_item *curr);\n\nstatic int __cil_evaluate_tunable_expr_helper(struct cil_list_item *curr)\n{\n\tif (curr == NULL) {\n\t\treturn CIL_FALSE;\n\t} else if (curr->flavor == CIL_DATUM) {\n\t\tstruct cil_tunable *tun = curr->data;\n\t\treturn tun->value;\n\t} else if (curr->flavor == CIL_LIST) {\n\t\tstruct cil_list *l = curr->data;\n\t\treturn __cil_evaluate_tunable_expr(l->head);\n\t} else {\n\t\treturn CIL_FALSE;\n\t}\n}\n\nstatic int __cil_evaluate_tunable_expr(struct cil_list_item *curr)\n{\n\t/* Assumes expression is well-formed */\n\n\tif (curr == NULL) {\n\t\treturn CIL_FALSE;\n\t} else if (curr->flavor == CIL_OP) {\n\t\tuint16_t v1, v2;\n\t\tenum cil_flavor op_flavor = (enum cil_flavor)(uintptr_t)curr->data;\n\n\t\tv1 = __cil_evaluate_tunable_expr_helper(curr->next);\n\n\t\tif (op_flavor == CIL_NOT) return !v1;\n\n\t\tv2 = __cil_evaluate_tunable_expr_helper(curr->next->next);\n\n\t\tif (op_flavor == CIL_AND) return (v1 && v2);\n\t\telse if (op_flavor == CIL_OR) return (v1 || v2);\n\t\telse if (op_flavor == CIL_XOR) return (v1 ^ v2);\n\t\telse if (op_flavor == CIL_EQ) return (v1 == v2);\n\t\telse if (op_flavor == CIL_NEQ) return (v1 != v2);\n\t\telse return CIL_FALSE;\n\t} else {\n\t\tuint16_t v;\n\t\tfor (;curr; curr = curr->next) {\n\t\t\tv = __cil_evaluate_tunable_expr_helper(curr);\n\t\t\tif (v) return v;\n\t\t}\n\t\treturn CIL_FALSE;\n\t}\n}\n\nint cil_resolve_tunif(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tint rc = SEPOL_ERR;\n\tstruct cil_tunableif *tif = (struct cil_tunableif*)current->data;\n\tuint16_t result = CIL_FALSE;\n\tstruct cil_tree_node *true_node = NULL;\n\tstruct cil_tree_node *false_node = NULL;\n\tstruct cil_condblock *cb = NULL;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_expr(CIL_TUNABLEIF, tif->str_expr, &tif->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult = __cil_evaluate_tunable_expr(tif->datum_expr->head);\n\n\tif (current->cl_head != NULL && current->cl_head->flavor == CIL_CONDBLOCK) {\n\t\tcb = current->cl_head->data;\n\t\tif (cb->flavor == CIL_CONDTRUE) {\n\t\t\ttrue_node = current->cl_head;\n\t\t} else if (cb->flavor == CIL_CONDFALSE) {\n\t\t\tfalse_node = current->cl_head;\n\t\t}\n\t}\n\n\tif (current->cl_head != NULL && current->cl_head->next != NULL && current->cl_head->next->flavor == CIL_CONDBLOCK) {\n\t\tcb = current->cl_head->next->data;\n\t\tif (cb->flavor == CIL_CONDTRUE) {\n\t\t\ttrue_node = current->cl_head->next;\n\t\t} else if (cb->flavor == CIL_CONDFALSE) {\n\t\t\tfalse_node = current->cl_head->next;\n\t\t}\n\t}\n\n\tif (result == CIL_TRUE) {\n\t\tif (true_node != NULL) {\n\t\t\trc = cil_copy_ast(db, true_node, current->parent);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (false_node != NULL) {\n\t\t\trc = cil_copy_ast(db, false_node, current->parent);\n\t\t\tif (rc  != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tcil_tree_children_destroy(current);\n\tcurrent->cl_head = NULL;\n\tcurrent->cl_tail = NULL;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userattributeset(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_userattributeset *attrusers = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_userattribute *attr = NULL;\n\n\trc = cil_resolve_name(current, attrusers->attr_str, CIL_SYM_USERS, extra_args, &attr_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tattr_node = NODE(attr_datum);\n\n\tif (attr_node->flavor != CIL_USERATTRIBUTE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Attribute user not an attribute\\n\");\n\t\tgoto exit;\n\t}\n\tattr = (struct cil_userattribute*)attr_datum;\n\n\trc = cil_resolve_expr(CIL_USERATTRIBUTESET, attrusers->str_expr, &attrusers->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference(attr_datum, attrusers->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (attr->expr_list == NULL) {\n\t\tcil_list_init(&attr->expr_list, CIL_USERATTRIBUTE);\n\t}\n\n\tcil_list_append(attr->expr_list, CIL_LIST, attrusers->datum_expr);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint __cil_resolve_ast_node(struct cil_tree_node *node, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = 0;\n\tstruct cil_list *ins;\n\n\tif (node == NULL || args == NULL) {\n\t\tgoto exit;\n\t}\n\tins = args->in_list;\n\n\tpass = args->pass;\n\tswitch (pass) {\n\tcase CIL_PASS_TIF:\n\t\tif (node->flavor == CIL_TUNABLEIF) {\n\t\t\trc = cil_resolve_tunif(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_IN:\n\t\tif (node->flavor == CIL_IN) {\n\t\t\t// due to ordering issues, in statements are just gathered here and\n\t\t\t// resolved together in cil_resolve_in_list once all are found\n\t\t\tcil_list_prepend(ins, CIL_NODE, node);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_BLKIN_LINK:\n\t\tif (node->flavor == CIL_BLOCKINHERIT) {\n\t\t\trc = cil_resolve_blockinherit_link(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_BLKIN_COPY:\n\t\tif (node->flavor == CIL_BLOCK) {\n\t\t\trc = cil_resolve_blockinherit_copy(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_BLKABS:\n\t\tif (node->flavor == CIL_BLOCKABSTRACT) {\n\t\t\trc = cil_resolve_blockabstract(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MACRO:\n\t\tif (node->flavor == CIL_CALL && args->macro != NULL) {\n\t\t\trc = cil_resolve_call1(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_CALL1:\n\t\tif (node->flavor == CIL_CALL) {\n\t\t\trc = cil_resolve_call1(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_CALL2:\n\t\tif (node->flavor == CIL_CALL) {\n\t\t\trc = cil_resolve_call2(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_ALIAS1:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_TYPEALIASACTUAL:\n\t\t\trc = cil_resolve_aliasactual(node, args, CIL_TYPE, CIL_TYPEALIAS);\n\t\t\tbreak;\n\t\tcase CIL_SENSALIASACTUAL:\n\t\t\trc = cil_resolve_aliasactual(node, args, CIL_SENS, CIL_SENSALIAS);\n\t\t\tbreak;\n\t\tcase CIL_CATALIASACTUAL:\n\t\t\trc = cil_resolve_aliasactual(node, args, CIL_CAT, CIL_CATALIAS);\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_ALIAS2:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_TYPEALIAS:\n\t\t\trc = cil_resolve_alias_to_actual(node, CIL_TYPE);\n\t\t\tbreak;\n\t\tcase CIL_SENSALIAS:\n\t\t\trc = cil_resolve_alias_to_actual(node, CIL_SENS);\n\t\t\tbreak;\n\t\tcase CIL_CATALIAS:\n\t\t\trc = cil_resolve_alias_to_actual(node, CIL_CAT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MISC1:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_SIDORDER:\n\t\t\trc = cil_resolve_sidorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSORDER:\n\t\t\trc = cil_resolve_classorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CATORDER:\n\t\t\trc = cil_resolve_catorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_SENSITIVITYORDER:\n\t\t\trc = cil_resolve_sensitivityorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_BOOLEANIF:\n\t\t\trc = cil_resolve_boolif(node, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MLS:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_CATSET:\n\t\t\trc = cil_resolve_catset(node, (struct cil_catset*)node->data, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MISC2:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_SENSCAT:\n\t\t\trc = cil_resolve_senscat(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSCOMMON:\n\t\t\trc = cil_resolve_classcommon(node, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MISC3:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_TYPEATTRIBUTESET:\n\t\t\trc = cil_resolve_typeattributeset(node, args);\n\t\t\tbreak;\n\t\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\t\trc = cil_resolve_expandtypeattribute(node, args);\n\t\t\tbreak;\n\t\tcase CIL_TYPEBOUNDS:\n\t\t\trc = cil_resolve_bounds(node, args, CIL_TYPE, CIL_TYPEATTRIBUTE);\n\t\t\tbreak;\n\t\tcase CIL_TYPEPERMISSIVE:\n\t\t\trc = cil_resolve_typepermissive(node, args);\n\t\t\tbreak;\n\t\tcase CIL_NAMETYPETRANSITION:\n\t\t\trc = cil_resolve_nametypetransition(node, args);\n\t\t\tbreak;\n\t\tcase CIL_RANGETRANSITION:\n\t\t\trc = cil_resolve_rangetransition(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSIONSET:\n\t\t\trc = cil_resolve_classpermissionset(node, (struct cil_classpermissionset*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSMAPPING:\n\t\t\trc = cil_resolve_classmapping(node, args);\n\t\t\tbreak;\n\t\tcase CIL_AVRULE:\n\t\tcase CIL_AVRULEX:\n\t\t\trc = cil_resolve_avrule(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PERMISSIONX:\n\t\t\trc = cil_resolve_permissionx(node, (struct cil_permissionx*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_TYPE_RULE:\n\t\t\trc = cil_resolve_type_rule(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERROLE:\n\t\t\trc = cil_resolve_userrole(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERLEVEL:\n\t\t\trc = cil_resolve_userlevel(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERRANGE:\n\t\t\trc = cil_resolve_userrange(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERBOUNDS:\n\t\t\trc = cil_resolve_bounds(node, args, CIL_USER, CIL_USERATTRIBUTE);\n\t\t\tbreak;\n\t\tcase CIL_USERPREFIX:\n\t\t\trc = cil_resolve_userprefix(node, args);\n\t\t\tbreak;\n\t\tcase CIL_SELINUXUSER:\n\t\tcase CIL_SELINUXUSERDEFAULT:\n\t\t\trc = cil_resolve_selinuxuser(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLEATTRIBUTESET:\n\t\t\trc = cil_resolve_roleattributeset(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLETYPE:\n\t\t\trc = cil_resolve_roletype(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLETRANSITION:\n\t\t\trc = cil_resolve_roletransition(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLEALLOW:\n\t\t\trc = cil_resolve_roleallow(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLEBOUNDS:\n\t\t\trc = cil_resolve_bounds(node, args, CIL_ROLE, CIL_ROLEATTRIBUTE);\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\trc = cil_resolve_level(node, (struct cil_level*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\trc = cil_resolve_levelrange(node, (struct cil_levelrange*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_CONSTRAIN:\n\t\t\trc = cil_resolve_constrain(node, args);\n\t\t\tbreak;\n\t\tcase CIL_MLSCONSTRAIN:\n\t\t\trc = cil_resolve_constrain(node, args);\n\t\t\tbreak;\n\t\tcase CIL_VALIDATETRANS:\n\t\tcase CIL_MLSVALIDATETRANS:\n\t\t\trc = cil_resolve_validatetrans(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CONTEXT:\n\t\t\trc = cil_resolve_context(node, (struct cil_context*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_FILECON:\n\t\t\trc = cil_resolve_filecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IBPKEYCON:\n\t\t\trc = cil_resolve_ibpkeycon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PORTCON:\n\t\t\trc = cil_resolve_portcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_NODECON:\n\t\t\trc = cil_resolve_nodecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_GENFSCON:\n\t\t\trc = cil_resolve_genfscon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_NETIFCON:\n\t\t\trc = cil_resolve_netifcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IBENDPORTCON:\n\t\t\trc = cil_resolve_ibendportcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PIRQCON:\n\t\t\trc = cil_resolve_pirqcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IOMEMCON:\n\t\t\trc = cil_resolve_iomemcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IOPORTCON:\n\t\t\trc = cil_resolve_ioportcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PCIDEVICECON:\n\t\t\trc = cil_resolve_pcidevicecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_DEVICETREECON:\n\t\t\trc = cil_resolve_devicetreecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_FSUSE:\n\t\t\trc = cil_resolve_fsuse(node, args);\n\t\t\tbreak;\n\t\tcase CIL_SIDCONTEXT:\n\t\t\trc = cil_resolve_sidcontext(node, args);\n\t\t\tbreak;\n\t\tcase CIL_DEFAULTUSER:\n\t\tcase CIL_DEFAULTROLE:\n\t\tcase CIL_DEFAULTTYPE:\n\t\t\trc = cil_resolve_default(node, args);\n\t\t\tbreak;\n\t\tcase CIL_DEFAULTRANGE:\n\t\t\trc = cil_resolve_defaultrange(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERATTRIBUTESET:\n\t\t\trc = cil_resolve_userattributeset(node, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}\n\nint __cil_resolve_ast_node_helper(struct cil_tree_node *node, uint32_t *finished, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = args->pass;\n\tstruct cil_tree_node *block = args->block;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *optional = args->optional;\n\tstruct cil_tree_node *boolif = args->boolif;\n\n\tif (node == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (block != NULL) {\n\t\tif (node->flavor == CIL_CAT ||\n\t\t    node->flavor == CIL_SENS) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in blocks\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (node->flavor == CIL_BLOCK ||\n\t\t    node->flavor == CIL_BLOCKINHERIT ||\n\t\t    node->flavor == CIL_BLOCKABSTRACT ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in macros\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (optional != NULL) {\n\t\tif (node->flavor == CIL_TUNABLE ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\t/* tuanbles and macros are not allowed in optionals*/\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in optionals\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (node->flavor != CIL_TUNABLEIF &&\n\t\t\tnode->flavor != CIL_CALL &&\n\t\t\tnode->flavor != CIL_CONDBLOCK &&\n\t\t\tnode->flavor != CIL_AVRULE &&\n\t\t\tnode->flavor != CIL_TYPE_RULE &&\n\t\t\tnode->flavor != CIL_NAMETYPETRANSITION) {\n\t\t\trc = SEPOL_ERR;\n\t\t} else if (node->flavor == CIL_AVRULE) {\n\t\t\tstruct cil_avrule *rule = node->data;\n\t\t\tif (rule->rule_kind == CIL_AVRULE_NEVERALLOW) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t\tif (rc == SEPOL_ERR) {\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs (tunableif treated as a booleanif)\", cil_node_to_string(node));\n\t\t\t} else {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs\", cil_node_to_string(node));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_MACRO) {\n\t\tif (pass != CIL_PASS_TIF && pass != CIL_PASS_MACRO) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_BLOCK && ((((struct cil_block*)node->data)->is_abstract == CIL_TRUE) && (pass > CIL_PASS_BLKABS))) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\trc = __cil_resolve_ast_node(node, extra_args);\n\tif (rc == SEPOL_ENOENT) {\n\t\tenum cil_log_level lvl = CIL_ERR;\n\n\t\tif (optional != NULL) {\n\t\t\tlvl = CIL_INFO;\n\n\t\t\tstruct cil_optional *opt = (struct cil_optional *)optional->data;\n\t\t\tstruct cil_tree_node *opt_node = NODE(opt);;\n\t\t\t/* disable an optional if something failed to resolve */\n\t\t\topt->enabled = CIL_FALSE;\n\t\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\t\tcil_tree_log(opt_node, lvl, \"Disabling optional '%s'\", opt->datum.name);\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}\n\nint __cil_resolve_ast_first_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\n\tif (current == NULL || extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_BLOCK) {\n\t\targs->block = parent;\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\targs->macro = parent;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\targs->optional = parent;\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = parent;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_BLOCK) {\n\t\tstruct cil_tree_node *n = parent->parent;\n\t\targs->block = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_BLOCK) {\n\t\t\t\targs->block = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = parent->parent;\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_ast(struct cil_db *db, struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve extra_args;\n\tenum cil_pass pass = CIL_PASS_TIF;\n\tuint32_t changed = 0;\n\n\tif (db == NULL || current == NULL) {\n\t\treturn rc;\n\t}\n\n\textra_args.db = db;\n\textra_args.pass = pass;\n\textra_args.changed = &changed;\n\textra_args.block = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif= NULL;\n\textra_args.sidorder_lists = NULL;\n\textra_args.classorder_lists = NULL;\n\textra_args.unordered_classorder_lists = NULL;\n\textra_args.catorder_lists = NULL;\n\textra_args.sensitivityorder_lists = NULL;\n\textra_args.in_list = NULL;\n\n\tcil_list_init(&extra_args.disabled_optionals, CIL_NODE);\n\tcil_list_init(&extra_args.sidorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.classorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.unordered_classorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.catorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.sensitivityorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.in_list, CIL_IN);\n\tfor (pass = CIL_PASS_TIF; pass < CIL_PASS_NUM; pass++) {\n\t\textra_args.pass = pass;\n\t\trc = cil_tree_walk(current, __cil_resolve_ast_node_helper, __cil_resolve_ast_first_child_helper, __cil_resolve_ast_last_child_helper, &extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_INFO, \"Pass %i of resolution failed\\n\", pass);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (pass == CIL_PASS_IN) {\n\t\t\trc = cil_resolve_in_list(&extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_destroy(&extra_args.in_list, CIL_FALSE);\n\t\t}\n\n\t\tif (pass == CIL_PASS_MISC1) {\n\t\t\tdb->sidorder = __cil_ordered_lists_merge_all(&extra_args.sidorder_lists, NULL);\n\t\t\tif (db->sidorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tdb->classorder = __cil_ordered_lists_merge_all(&extra_args.classorder_lists, &extra_args.unordered_classorder_lists);\n\t\t\tif (db->classorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tdb->catorder = __cil_ordered_lists_merge_all(&extra_args.catorder_lists, NULL);\n\t\t\tif (db->catorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_set_cat_values(db->catorder, db);\n\t\t\tdb->sensitivityorder = __cil_ordered_lists_merge_all(&extra_args.sensitivityorder_lists, NULL);\n\t\t\tif (db->sensitivityorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_SID);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_CLASS);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_CAT);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_SENS);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (changed && (pass > CIL_PASS_CALL1)) {\n\t\t\tstruct cil_list_item *item;\n\t\t\t/* Need to re-resolve because an optional was disabled that contained\n\t\t\t * one or more declarations. We only need to reset to the call1 pass \n\t\t\t * because things done in the preceding passes aren't allowed in \n\t\t\t * optionals, and thus can't be disabled.\n\t\t\t * Note: set pass to CIL_PASS_CALL1 because the pass++ will increment \n\t\t\t * it to CIL_PASS_CALL2\n\t\t\t */\n\t\t\tcil_log(CIL_INFO, \"Resetting declarations\\n\");\n\n\t\t\tif (pass >= CIL_PASS_MISC1) {\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.sidorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.classorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.unordered_classorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.catorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.sensitivityorder_lists);\n\t\t\t\tcil_list_destroy(&db->sidorder, CIL_FALSE);\n\t\t\t\tcil_list_destroy(&db->classorder, CIL_FALSE);\n\t\t\t\tcil_list_destroy(&db->catorder, CIL_FALSE);\n\t\t\t\tcil_list_destroy(&db->sensitivityorder, CIL_FALSE);\n\t\t\t}\n\n\t\t\tpass = CIL_PASS_CALL1;\n\n\t\t\trc = cil_reset_ast(current);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Failed to reset declarations\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_for_each(item, extra_args.disabled_optionals) {\n\t\t\t\tcil_tree_children_destroy(item->data);\n\t\t\t}\n\t\t\tcil_list_destroy(&extra_args.disabled_optionals, CIL_FALSE);\n\t\t\tcil_list_init(&extra_args.disabled_optionals, CIL_NODE);\n\t\t\tchanged = 0;\n\t\t}\n\t}\n\n\trc = __cil_verify_initsids(db->sidorder);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\nexit:\n\t__cil_ordered_lists_destroy(&extra_args.sidorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.classorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.catorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.sensitivityorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.unordered_classorder_lists);\n\tcil_list_destroy(&extra_args.disabled_optionals, CIL_FALSE);\n\tcil_list_destroy(&extra_args.in_list, CIL_FALSE);\n\n\treturn rc;\n}\n\nstatic int __cil_resolve_name_with_root(struct cil_db *db, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tsymtab_t *symtab = &((struct cil_root *)db->ast->root->data)->symtab[sym_index];\n\n\treturn cil_symtab_get_datum(symtab, name, datum);\n}\n\nstatic int __cil_resolve_name_with_parents(struct cil_tree_node *node, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\tsymtab_t *symtab = NULL;\n\n\twhile (node != NULL && rc != SEPOL_OK) {\n\t\tswitch (node->flavor) {\n\t\tcase CIL_ROOT:\n\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase CIL_BLOCK:\n\t\t\tsymtab = &((struct cil_block*)node->data)->symtab[sym_index];\n\t\t\trc = cil_symtab_get_datum(symtab, name, datum);\n\t\t\tbreak;\n\t\tcase CIL_BLOCKINHERIT: {\n\t\t\tstruct cil_blockinherit *inherit = node->data;\n\t\t\trc = __cil_resolve_name_with_parents(node->parent, name, sym_index, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t/* Continue search in original block's parent */\n\t\t\t\trc = __cil_resolve_name_with_parents(NODE(inherit->block), name, sym_index, datum);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase CIL_MACRO: {\n\t\t\tstruct cil_macro *macro = node->data;\n\t\t\tsymtab = &macro->symtab[sym_index];\n\t\t\trc = cil_symtab_get_datum(symtab, name, datum);\n\t\t}\n\t\t\tbreak;\n\t\tcase CIL_CALL: {\n\t\t\tstruct cil_call *call = node->data;\n\t\t\trc = cil_resolve_name_call_args(call, name, sym_index, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t/* Continue search in macro's parent */\n\t\t\t\trc = __cil_resolve_name_with_parents(NODE(call->macro)->parent, name, sym_index, datum);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase CIL_IN:\n\t\t\t/* In block symtabs only exist before resolving the AST */\n\t\tcase CIL_CONDBLOCK:\n\t\t\t/* Cond block symtabs only exist before resolving the AST */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tnode = node->parent;\n\t}\n\nexit:\n\treturn rc;\n}\n\nstatic int __cil_resolve_name_helper(struct cil_db *db, struct cil_tree_node *node, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_resolve_name_with_parents(node, name, sym_index, datum);\n\tif (rc != SEPOL_OK) {\n\t\trc = __cil_resolve_name_with_root(db, name, sym_index, datum);\n\t}\n\treturn rc;\n}\n\nint cil_resolve_name(struct cil_tree_node *ast_node, char *name, enum cil_sym_index sym_index, void *extra_args, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *node = NULL;\n\n\trc = cil_resolve_name_keep_aliases(ast_node, name, sym_index, extra_args, datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t/* If this datum is an alias, then return the actual node\n\t * This depends on aliases already being processed\n\t */\n\tnode = NODE(*datum);\n\tif (node->flavor == CIL_TYPEALIAS || node->flavor == CIL_SENSALIAS\n\t\t|| node->flavor == CIL_CATALIAS) {\n\t\tstruct cil_alias *alias = (struct cil_alias *)(*datum);\n\t\tif (alias->actual) {\n\t\t\t*datum = alias->actual;\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_name_keep_aliases(struct cil_tree_node *ast_node, char *name, enum cil_sym_index sym_index, void *extra_args, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = args->db;\n\tstruct cil_tree_node *node = NULL;\n\n\tif (name == NULL) {\n\t\tcil_log(CIL_ERR, \"Invalid call to cil_resolve_name\\n\");\n\t\tgoto exit;\n\t}\n\n\t*datum = NULL;\n\n\tif (strchr(name,'.') == NULL) {\n\t\t/* No '.' in name */\n\t\trc = __cil_resolve_name_helper(db, ast_node->parent, name, sym_index, datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tchar *sp = NULL;\n\t\tchar *name_dup = cil_strdup(name);\n\t\tchar *current = strtok_r(name_dup, \".\", &sp);\n\t\tchar *next = strtok_r(NULL, \".\", &sp);\n\t\tsymtab_t *symtab = NULL;\n\n\t\tif (current == NULL) {\n\t\t\t/* Only dots */\n\t\t\tcil_tree_log(ast_node, CIL_ERR, \"Invalid name %s\", name);\n\t\t\tfree(name_dup);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tnode = ast_node;\n\t\tif (*name == '.') {\n\t\t\t/* Leading '.' */\n\t\t\tsymtab = &((struct cil_root *)db->ast->root->data)->symtab[CIL_SYM_BLOCKS];\n\t\t} else {\n\t\t\trc = __cil_resolve_name_helper(db, node->parent, current, CIL_SYM_BLOCKS, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tfree(name_dup);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsymtab = (*datum)->symtab;\n\t\t}\n\t\t/* Keep looking up blocks by name until only last part of name remains */\n\t\twhile (next != NULL) {\n\t\t\trc = cil_symtab_get_datum(symtab, current, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tfree(name_dup);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tnode = NODE(*datum);\n\t\t\tif (node->flavor == CIL_BLOCK) {\n\t\t\t\tsymtab = &((struct cil_block*)node->data)->symtab[CIL_SYM_BLOCKS];\n\t\t\t} else {\n\t\t\t\tif (ast_node->flavor != CIL_IN) {\n\t\t\t\t\tcil_log(CIL_WARN, \"Can only use %s name for name resolution in \\\"in\\\" blocks\\n\", cil_node_to_string(node));\n\t\t\t\t\tfree(name_dup);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif (node->flavor == CIL_MACRO) {\n\t\t\t\t\tstruct cil_macro *macro = node->data;\n\t\t\t\t\tsymtab = &macro->symtab[sym_index];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = next;\n\t\t\tnext = strtok_r(NULL, \".\", &sp);\n\t\t}\n\t\tsymtab = &(symtab[sym_index]);\n\t\trc = cil_symtab_get_datum(symtab, current, datum);\n\t\tfree(name_dup);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\tif (rc != SEPOL_OK) {\n\t\t*datum = NULL;\n\t}\n\n\treturn rc;\n}\n"], "fixing_code": ["/*\n * Copyright 2011 Tresys Technology, LLC. All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n * \n *    2. Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY TRESYS TECHNOLOGY, LLC ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL TRESYS TECHNOLOGY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of Tresys Technology, LLC.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#include <sepol/policydb/conditional.h>\n\n#include \"cil_internal.h\"\n#include \"cil_flavor.h\"\n#include \"cil_log.h\"\n#include \"cil_mem.h\"\n#include \"cil_tree.h\"\n#include \"cil_list.h\"\n#include \"cil_parser.h\"\n#include \"cil_build_ast.h\"\n#include \"cil_copy_ast.h\"\n#include \"cil_verify.h\"\n#include \"cil_strpool.h\"\n\nstruct cil_args_build {\n\tstruct cil_tree_node *ast;\n\tstruct cil_db *db;\n\tstruct cil_tree_node *tunif;\n\tstruct cil_tree_node *in;\n\tstruct cil_tree_node *macro;\n\tstruct cil_tree_node *optional;\n\tstruct cil_tree_node *boolif;\n};\n\nint cil_fill_list(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **list)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *curr;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_N_STRINGS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n \n\trc = __cil_verify_syntax(current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n \t}\n\n\tcil_list_init(list, flavor);\n\n\tfor (curr = current; curr != NULL; curr = curr->next) {\n\t\tcil_list_append(*list, CIL_STRING, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstatic int cil_allow_multiple_decls(struct cil_db *db, enum cil_flavor f_new, enum cil_flavor f_old)\n{\n\tif (f_new != f_old) {\n\t\treturn CIL_FALSE;\n\t}\n\n\tswitch (f_new) {\n\tcase CIL_TYPE:\n\tcase CIL_TYPEATTRIBUTE:\n\t\tif (db->multiple_decls) {\n\t\t\treturn CIL_TRUE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn CIL_FALSE;\n}\n\nint cil_add_decl_to_symtab(struct cil_db *db, symtab_t *symtab, hashtab_key_t key, struct cil_symtab_datum *datum, struct cil_tree_node *node)\n{\n\tint rc;\n\n\tif (symtab == NULL || datum == NULL || node == NULL) {\n\t\treturn SEPOL_ERR;\n\t}\n\n\trc = cil_symtab_insert(symtab, key, datum, node);\n\tif (rc == SEPOL_EEXIST) {\n\t\tstruct cil_symtab_datum *prev;\n\t\trc = cil_symtab_get_datum(symtab, key, &prev);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Re-declaration of %s %s, but previous declaration could not be found\\n\",cil_node_to_string(node), key);\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t\tif (!cil_allow_multiple_decls(db, node->flavor, FLAVOR(prev))) {\n\t\t\t/* multiple_decls not ok, ret error */\n\t\t\tstruct cil_tree_node *n = NODE(prev);\n\t\t\tcil_log(CIL_ERR, \"Re-declaration of %s %s\\n\",\n\t\t\t\tcil_node_to_string(node), key);\n\t\t\tcil_tree_log(node, CIL_ERR, \"Previous declaration of %s\",\n\t\t\t\t     cil_node_to_string(n));\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t\t/* multiple_decls is enabled and works for this datum type, add node */\n\t\tcil_list_append(prev->nodes, CIL_NODE, node);\n\t\tnode->data = prev;\n\t\tcil_symtab_datum_destroy(datum);\n\t\tfree(datum);\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_gen_node(struct cil_db *db, struct cil_tree_node *ast_node, struct cil_symtab_datum *datum, hashtab_key_t key, enum cil_sym_index sflavor, enum cil_flavor nflavor)\n{\n\tint rc = SEPOL_ERR;\n\tsymtab_t *symtab = NULL;\n\n\trc = cil_verify_name((const char*)key, nflavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_get_symtab(ast_node->parent, &symtab, sflavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = datum;\n\tast_node->flavor = nflavor;\n\n\trc = cil_add_decl_to_symtab(db, symtab, key, datum, ast_node);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (ast_node->parent->flavor == CIL_MACRO) {\n\t\trc = cil_verify_decl_does_not_shadow_macro_parameter(ast_node->parent->data, ast_node, key);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_clear_node(struct cil_tree_node *ast_node)\n{\n\tif (ast_node == NULL) {\n\t\treturn;\n\t}\n\n\tast_node->data = NULL;\n\tast_node->flavor = CIL_NONE;\n}\n\nint cil_gen_block(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint16_t is_abstract)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_block *block = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_block_init(&block);\n\n\tblock->is_abstract = is_abstract;\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)block, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_BLOCK);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad block declaration\");\n\tcil_destroy_block(block);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_block(struct cil_block *block)\n{\n\tstruct cil_list_item *item;\n\tstruct cil_tree_node *bi_node;\n\tstruct cil_blockinherit *inherit;\n\n\tif (block == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&block->datum);\n\tcil_symtab_array_destroy(block->symtab);\n\tif (block->bi_nodes != NULL) {\n\t\t/* unlink blockinherit->block */\n\t\tcil_list_for_each(item, block->bi_nodes) {\n\t\t\tbi_node = item->data;\n\t\t\t/* the conditions should always be true, but better be sure */\n\t\t\tif (bi_node->flavor == CIL_BLOCKINHERIT) {\n\t\t\t\tinherit = bi_node->data;\n\t\t\t\tif (inherit->block == block) {\n\t\t\t\t\tinherit->block = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcil_list_destroy(&block->bi_nodes, CIL_FALSE);\n\t}\n\n\tfree(block);\n}\n\nint cil_gen_blockinherit(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_blockinherit *inherit = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_blockinherit_init(&inherit);\n\n\tinherit->block_str = parse_current->next->data;\n\n\tast_node->data = inherit;\n\tast_node->flavor = CIL_BLOCKINHERIT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad blockinherit declaration\");\n\tcil_destroy_blockinherit(inherit);\n\treturn rc;\n}\n\nvoid cil_destroy_blockinherit(struct cil_blockinherit *inherit)\n{\n\tif (inherit == NULL) {\n\t\treturn;\n\t}\n\n\tif (inherit->block != NULL && inherit->block->bi_nodes != NULL) {\n\t\tstruct cil_tree_node *node;\n\t\tstruct cil_list_item *item;\n\n\t\tcil_list_for_each(item, inherit->block->bi_nodes) {\n\t\t\tnode = item->data;\n\t\t\tif (node->data == inherit) {\n\t\t\t\tcil_list_remove(inherit->block->bi_nodes, CIL_NODE, node, CIL_FALSE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(inherit);\n}\n\nint cil_gen_blockabstract(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_blockabstract *abstract = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_blockabstract_init(&abstract);\n\n\tabstract->block_str = parse_current->next->data;\n\n\tast_node->data = abstract;\n\tast_node->flavor = CIL_BLOCKABSTRACT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad blockabstract declaration\");\n\tcil_destroy_blockabstract(abstract);\n\treturn rc;\n}\n\nvoid cil_destroy_blockabstract(struct cil_blockabstract *abstract)\n{\n\tif (abstract == NULL) {\n\t\treturn;\n\t}\n\n\tfree(abstract);\n}\n\nint cil_gen_in(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_in *in = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_in_init(&in);\n\n\tin->block_str = parse_current->next->data;\n\n\tast_node->data = in;\n\tast_node->flavor = CIL_IN;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad in statement\");\n\tcil_destroy_in(in);\n\treturn rc;\n}\n\nvoid cil_destroy_in(struct cil_in *in)\n{\n\tif (in == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_array_destroy(in->symtab);\n\n\tfree(in);\n}\n\nint cil_gen_class(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST | CIL_SYN_EMPTY_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_class *class = NULL;\n\tstruct cil_tree_node *perms = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_class_init(&class);\n\n\tkey = parse_current->next->data;\n\tif (key == CIL_KEY_UNORDERED) {\n\t\tcil_log(CIL_ERR, \"'unordered' keyword is reserved and not a valid class name.\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)class, (hashtab_key_t)key, CIL_SYM_CLASSES, CIL_CLASS);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next != NULL) {\n\t\tperms = parse_current->next->next->cl_head;\n\t\trc = cil_gen_perm_nodes(db, perms, ast_node, CIL_PERM, &class->num_perms);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tif (class->num_perms > CIL_PERMS_PER_CLASS) {\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Too many permissions in class '%s'\", class->datum.name);\n\t\t\tgoto exit;\n\t\t}\n\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad class declaration\");\n\tcil_destroy_class(class);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_class(struct cil_class *class)\n{\n\tif (class == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&class->datum);\n\tcil_symtab_destroy(&class->perms);\n\n\tfree(class);\n}\n\nint cil_gen_classorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_classorder *classorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_list_item *head = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc !=  SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classorder_init(&classorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_CLASSORDER, &classorder->class_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\thead = classorder->class_list_str->head;\n\tcil_list_for_each(curr, classorder->class_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tif (curr == head && curr->next == NULL) {\n\t\t\t\tcil_log(CIL_ERR, \"Classorder 'unordered' keyword must be followed by one or more class.\\n\");\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t} else if (curr != head) {\n\t\t\t\tcil_log(CIL_ERR, \"Classorder can only use 'unordered' keyword as the first item in the list.\\n\");\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tast_node->data = classorder;\n\tast_node->flavor = CIL_CLASSORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classorder declaration\");\n\tcil_destroy_classorder(classorder);\n\treturn rc;\n}\n\nvoid cil_destroy_classorder(struct cil_classorder *classorder)\n{\n\tif (classorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (classorder->class_list_str != NULL) {\n\t\tcil_list_destroy(&classorder->class_list_str, 1);\n\t}\n\n\tfree(classorder);\n}\n\nint cil_gen_perm(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor, unsigned int *num_perms)\n{\n\tchar *key = NULL;\n\tstruct cil_perm *perm = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_perm_init(&perm);\n\n\tkey = parse_current->data;\n\tif (key == NULL) {\n\t\tcil_log(CIL_ERR, \"Bad permission\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)perm, (hashtab_key_t)key, CIL_SYM_PERMS, flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tperm->value = *num_perms;\n\t(*num_perms)++;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_destroy_perm(perm);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_perm(struct cil_perm *perm)\n{\n\tif (perm == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&perm->datum);\n\tcil_list_destroy(&perm->classperms, CIL_FALSE);\n\n\tfree(perm);\n}\n\nint cil_gen_perm_nodes(struct cil_db *db, struct cil_tree_node *current_perm, struct cil_tree_node *ast_node, enum cil_flavor flavor, unsigned int *num_perms)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *new_ast = NULL;\n\n\twhile(current_perm != NULL) {\n\t\tif (current_perm->cl_head != NULL) {\n\t\t\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_tree_node_init(&new_ast);\n\t\tnew_ast->parent = ast_node;\n\t\tnew_ast->line = current_perm->line;\n\t\tnew_ast->hll_line = current_perm->hll_line;\n\n\t\trc = cil_gen_perm(db, current_perm, new_ast, flavor, num_perms);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_node_destroy(&new_ast);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (ast_node->cl_head == NULL) {\n\t\t\tast_node->cl_head = new_ast;\n\t\t} else {\n\t\t\tast_node->cl_tail->next = new_ast;\n\t\t}\n\t\tast_node->cl_tail = new_ast;\n\n\t\tcurrent_perm = current_perm->next;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad permissions\\n\");\n\tcil_tree_children_destroy(ast_node);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nint cil_fill_perms(struct cil_tree_node *start_perm, struct cil_list **perms)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_N_STRINGS | CIL_SYN_N_LISTS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(start_perm->cl_head, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_expr(start_perm, CIL_PERM, perms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad permission list or expression\\n\");\n\treturn rc;\n}\n\nint cil_fill_classperms(struct cil_tree_node *parse_current, struct cil_classperms **cp)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classperms_init(cp);\n\n\t(*cp)->class_str = parse_current->data;\n\n\trc = cil_fill_perms(parse_current->next, &(*cp)->perm_strs);\n\tif (rc != SEPOL_OK) {\n\t\tcil_destroy_classperms(*cp);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad class-permissions\\n\");\n\t*cp = NULL;\n\treturn rc;\n}\n\nvoid cil_destroy_classperms(struct cil_classperms *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->perm_strs, CIL_TRUE);\n\tcil_list_destroy(&cp->perms, CIL_FALSE);\n\n\tfree(cp);\n}\n\nvoid cil_fill_classperms_set(struct cil_tree_node *parse_current, struct cil_classperms_set **cp_set)\n{\n\tcil_classperms_set_init(cp_set);\n\t(*cp_set)->set_str = parse_current->data;\n}\n\nvoid cil_destroy_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tfree(cp_set);\n}\n\nint cil_fill_classperms_list(struct cil_tree_node *parse_current, struct cil_list **cp_list)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *curr;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (parse_current == NULL || cp_list == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_init(cp_list, CIL_CLASSPERMS);\n\n\tcurr = parse_current->cl_head;\n\n\tif (curr == NULL) {\n\t\t/* Class-perms form: SET1 */\n\t\tstruct cil_classperms_set *new_cp_set;\n\t\tcil_fill_classperms_set(parse_current, &new_cp_set);\n\t\tcil_list_append(*cp_list, CIL_CLASSPERMS_SET, new_cp_set);\n\t} else if (curr->cl_head == NULL) {\n\t\t/* Class-perms form: (CLASS1 (PERM1 ...)) */\n\t\tstruct cil_classperms *new_cp;\n\t\trc = cil_fill_classperms(curr, &new_cp);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(*cp_list, CIL_CLASSPERMS, new_cp);\n\t} else {\n\t\tcil_log(CIL_ERR, \"Bad class-permissions list syntax\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Problem filling class-permissions list\\n\");\n\tcil_list_destroy(cp_list, CIL_TRUE);\n\treturn rc;\n}\n\nvoid cil_destroy_classperms_list(struct cil_list **cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL || *cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, *cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\tcil_destroy_classperms(curr->data);\n\t\t} else {\n\t\t\tcil_destroy_classperms_set(curr->data);\n\t\t}\n\t}\n\n\tcil_list_destroy(cp_list, CIL_FALSE);\n}\n\nint cil_gen_classpermission(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tchar *key = NULL;\n\tstruct cil_classpermission *cp = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classpermission_init(&cp);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)cp, (hashtab_key_t)key, CIL_SYM_CLASSPERMSETS, CIL_CLASSPERMISSION);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classpermission declaration\");\n\tcil_destroy_classpermission(cp);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tif (cp->datum.name != NULL) {\n\t\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n\t} else {\n\t\t/* anonymous classpermission from call */\n\t\tcil_destroy_classperms_list(&cp->classperms);\n\t}\n\n\tcil_symtab_datum_destroy(&cp->datum);\n\n\n\tfree(cp);\n}\n\nint cil_gen_classpermissionset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_classpermissionset *cps = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classpermissionset_init(&cps);\n\n\tcps->set_str = parse_current->next->data;\n\n\trc = cil_fill_classperms_list(parse_current->next->next, &cps->classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = cps;\n\tast_node->flavor = CIL_CLASSPERMISSIONSET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classpermissionset\");\n\tcil_destroy_classpermissionset(cps);\n\treturn rc;\n}\n\nvoid cil_destroy_classpermissionset(struct cil_classpermissionset *cps)\n{\n\tif (cps == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_classperms_list(&cps->classperms);\n\n\tfree(cps);\n}\n\nint cil_gen_map_class(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_class *map = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_class_init(&map);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)map, (hashtab_key_t)key, CIL_SYM_CLASSES, CIL_MAP_CLASS);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_perm_nodes(db, parse_current->next->next->cl_head, ast_node, CIL_MAP_PERM, &map->num_perms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad map class declaration\");\n\tcil_destroy_class(map);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nint cil_gen_classmapping(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_classmapping *mapping = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classmapping_init(&mapping);\n\n\tmapping->map_class_str = parse_current->next->data;\n\tmapping->map_perm_str = parse_current->next->next->data;\n\n\trc = cil_fill_classperms_list(parse_current->next->next->next, &mapping->classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = mapping;\n\tast_node->flavor = CIL_CLASSMAPPING;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classmapping declaration\");\n\tcil_destroy_classmapping(mapping);\n\treturn rc;\n}\n\nvoid cil_destroy_classmapping(struct cil_classmapping *mapping)\n{\n\tif (mapping == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_classperms_list(&mapping->classperms);\n\n\tfree(mapping);\n}\n\n// TODO try to merge some of this with cil_gen_class (helper function for both)\nint cil_gen_common(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_class *common = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_class_init(&common);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)common, (hashtab_key_t)key, CIL_SYM_COMMONS, CIL_COMMON);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_perm_nodes(db, parse_current->next->next->cl_head, ast_node, CIL_PERM, &common->num_perms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (common->num_perms > CIL_PERMS_PER_CLASS) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Too many permissions in common '%s'\", common->datum.name);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad common declaration\");\n\tcil_destroy_class(common);\n\tcil_clear_node(ast_node);\n\treturn rc;\n\n}\n\nint cil_gen_classcommon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_classcommon *clscom = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_classcommon_init(&clscom);\n\n\tclscom->class_str = parse_current->next->data;\n\tclscom->common_str = parse_current->next->next->data;\n\n\tast_node->data = clscom;\n\tast_node->flavor = CIL_CLASSCOMMON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad classcommon declaration\");\n\tcil_destroy_classcommon(clscom);\n\treturn rc;\n\n}\n\nvoid cil_destroy_classcommon(struct cil_classcommon *clscom)\n{\n\tif (clscom == NULL) {\n\t\treturn;\n\t}\n\n\tfree(clscom);\n}\n\nint cil_gen_sid(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_sid *sid = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sid_init(&sid);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)sid, (hashtab_key_t)key, CIL_SYM_SIDS, CIL_SID);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sid declaration\");\n\tcil_destroy_sid(sid);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_sid(struct cil_sid *sid)\n{\n\tif (sid == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&sid->datum);\n\tfree(sid);\n}\n\nint cil_gen_sidcontext(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_sidcontext *sidcon = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sidcontext_init(&sidcon);\n\n\tsidcon->sid_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tsidcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&sidcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, sidcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = sidcon;\n\tast_node->flavor = CIL_SIDCONTEXT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sidcontext declaration\");\n\tcil_destroy_sidcontext(sidcon);\n\treturn rc;\n}\n\nvoid cil_destroy_sidcontext(struct cil_sidcontext *sidcon)\n{\n\tif (sidcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (sidcon->context_str == NULL && sidcon->context != NULL) {\n\t\tcil_destroy_context(sidcon->context);\n\t}\n\n\tfree(sidcon);\n}\n\nint cil_gen_sidorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_sidorder *sidorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc !=  SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sidorder_init(&sidorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_SIDORDER, &sidorder->sid_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(curr, sidorder->sid_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tcil_log(CIL_ERR, \"Sidorder cannot be unordered.\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = sidorder;\n\tast_node->flavor = CIL_SIDORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sidorder declaration\");\n\tcil_destroy_sidorder(sidorder);\n\treturn rc;\n}\n\nvoid cil_destroy_sidorder(struct cil_sidorder *sidorder)\n{\n\tif (sidorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (sidorder->sid_list_str != NULL) {\n\t\tcil_list_destroy(&sidorder->sid_list_str, 1);\n\t}\n\n\tfree(sidorder);\n}\n\nint cil_gen_user(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_user *user = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_user_init(&user);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)user, (hashtab_key_t)key, CIL_SYM_USERS, CIL_USER);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad user declaration\");\n\tcil_destroy_user(user);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_user(struct cil_user *user)\n{\n\tif (user == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&user->datum);\n\tebitmap_destroy(user->roles);\n\tfree(user->roles);\n\tfree(user);\n}\n\nint cil_gen_userattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_userattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userattribute_init(&attr);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)attr, (hashtab_key_t)key, CIL_SYM_USERS, CIL_USERATTRIBUTE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userattribute declaration\");\n\tcil_destroy_userattribute(attr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_userattribute(struct cil_userattribute *attr)\n{\n\tstruct cil_list_item *expr = NULL;\n\tstruct cil_list_item *next = NULL;\n\n\tif (attr == NULL) {\n\t\treturn;\n\t}\n\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\texpr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tnext = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\n\tcil_symtab_datum_destroy(&attr->datum);\n\tebitmap_destroy(attr->users);\n\tfree(attr->users);\n\tfree(attr);\n}\n\nint cil_gen_userattributeset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userattributeset *attrset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userattributeset_init(&attrset);\n\n\tattrset->attr_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_USER, &attrset->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tast_node->data = attrset;\n\tast_node->flavor = CIL_USERATTRIBUTESET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userattributeset declaration\");\n\tcil_destroy_userattributeset(attrset);\n\n\treturn rc;\n}\n\nvoid cil_destroy_userattributeset(struct cil_userattributeset *attrset)\n{\n\tif (attrset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&attrset->str_expr, CIL_TRUE);\n\tcil_list_destroy(&attrset->datum_expr, CIL_FALSE);\n\n\tfree(attrset);\n}\n\nint cil_gen_userlevel(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userlevel *usrlvl = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userlevel_init(&usrlvl);\n\n\tusrlvl->user_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tusrlvl->level_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_level_init(&usrlvl->level);\n\n\t\trc = cil_fill_level(parse_current->next->next->cl_head, usrlvl->level);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = usrlvl;\n\tast_node->flavor = CIL_USERLEVEL;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userlevel declaration\");\n\tcil_destroy_userlevel(usrlvl);\n\treturn rc;\n}\n\nvoid cil_destroy_userlevel(struct cil_userlevel *usrlvl)\n{\n\tif (usrlvl == NULL) {\n\t\treturn;\n\t}\n\n\tif (usrlvl->level_str == NULL && usrlvl->level != NULL) {\n\t\tcil_destroy_level(usrlvl->level);\n\t}\n\n\tfree(usrlvl);\n}\n\nint cil_gen_userrange(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userrange *userrange = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userrange_init(&userrange);\n\n\tuserrange->user_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tuserrange->range_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&userrange->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->cl_head, userrange->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = userrange;\n\tast_node->flavor = CIL_USERRANGE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userrange declaration\");\n\tcil_destroy_userrange(userrange);\n\treturn rc;\n}\n\nvoid cil_destroy_userrange(struct cil_userrange *userrange)\n{\n\tif (userrange == NULL) {\n\t\treturn;\n\t}\n\n\tif (userrange->range_str == NULL && userrange->range != NULL) {\n\t\tcil_destroy_levelrange(userrange->range);\n\t}\n\n\tfree(userrange);\n}\n\nint cil_gen_userprefix(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userprefix *userprefix = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userprefix_init(&userprefix);\n\n\tuserprefix->user_str = parse_current->next->data;\n\tuserprefix->prefix_str = parse_current->next->next->data;\n\n\tast_node->data = userprefix;\n\tast_node->flavor = CIL_USERPREFIX;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userprefix declaration\");\n\tcil_destroy_userprefix(userprefix);\n\treturn rc;\n}\n\nvoid cil_destroy_userprefix(struct cil_userprefix *userprefix)\n{\n\tif (userprefix == NULL) {\n\t\treturn;\n\t}\n\n\tfree(userprefix);\n}\n\nint cil_gen_selinuxuser(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_selinuxuser *selinuxuser = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_selinuxuser_init(&selinuxuser);\n\n\tselinuxuser->name_str = parse_current->next->data;\n\tselinuxuser->user_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tselinuxuser->range_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&selinuxuser->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->next->cl_head, selinuxuser->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = selinuxuser;\n\tast_node->flavor = CIL_SELINUXUSER;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad selinuxuser declaration\");\n\tcil_destroy_selinuxuser(selinuxuser);\n\treturn rc;\n}\n\nint cil_gen_selinuxuserdefault(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_selinuxuser *selinuxuser = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_selinuxuser_init(&selinuxuser);\n\n\tselinuxuser->name_str = cil_strpool_add(\"__default__\");\n\tselinuxuser->user_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tselinuxuser->range_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&selinuxuser->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->cl_head, selinuxuser->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = selinuxuser;\n\tast_node->flavor = CIL_SELINUXUSERDEFAULT;\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad selinuxuserdefault declaration\");\n\tcil_destroy_selinuxuser(selinuxuser);\n\treturn rc;\n}\n\nvoid cil_destroy_selinuxuser(struct cil_selinuxuser *selinuxuser)\n{\n\tif (selinuxuser == NULL) {\n\t\treturn;\n\t}\n\n\tif (selinuxuser->range_str == NULL && selinuxuser->range != NULL) {\n\t\tcil_destroy_levelrange(selinuxuser->range);\n\t}\n\n\tfree(selinuxuser);\n}\n\nint cil_gen_role(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_role *role = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_role_init(&role);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)role, (hashtab_key_t)key, CIL_SYM_ROLES, CIL_ROLE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad role declaration\");\n\tcil_destroy_role(role);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_role(struct cil_role *role)\n{\n\tif (role == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&role->datum);\n\tebitmap_destroy(role->types);\n\tfree(role->types);\n\tfree(role);\n}\n\nint cil_gen_roletype(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roletype *roletype = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roletype_init(&roletype);\n\n\troletype->role_str = parse_current->next->data;\n\troletype->type_str = parse_current->next->next->data;\n\n\tast_node->data = roletype;\n\tast_node->flavor = CIL_ROLETYPE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roletype declaration\");\n\tcil_destroy_roletype(roletype);\n\treturn rc;\n}\n\nvoid cil_destroy_roletype(struct cil_roletype *roletype)\n{\n\tif (roletype == NULL) {\n\t\treturn;\n\t}\n\n\tfree(roletype);\n}\n\nint cil_gen_userrole(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_userrole *userrole = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_userrole_init(&userrole);\n\n\tuserrole->user_str = parse_current->next->data;\n\tuserrole->role_str = parse_current->next->next->data;\n\n\tast_node->data = userrole;\n\tast_node->flavor = CIL_USERROLE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad userrole declaration\");\n\tcil_destroy_userrole(userrole);\n\treturn rc;\n}\n\nvoid cil_destroy_userrole(struct cil_userrole *userrole)\n{\n\tif (userrole == NULL) {\n\t\treturn;\n\t}\n\n\tfree(userrole);\n}\n\nint cil_gen_roletransition(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roletransition *roletrans = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roletransition_init(&roletrans);\n\n\troletrans->src_str = parse_current->next->data;\n\troletrans->tgt_str = parse_current->next->next->data;\n\troletrans->obj_str = parse_current->next->next->next->data;\n\troletrans->result_str = parse_current->next->next->next->next->data;\n\n\tast_node->data = roletrans;\n\tast_node->flavor = CIL_ROLETRANSITION;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roletransition rule\");\n\tcil_destroy_roletransition(roletrans);\n\treturn rc;\n}\n\nvoid cil_destroy_roletransition(struct cil_roletransition *roletrans)\n{\n\tif (roletrans == NULL) {\n\t\treturn;\n\t}\n\n\tfree(roletrans);\n}\n\nint cil_gen_roleallow(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roleallow *roleallow = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roleallow_init(&roleallow);\n\n\troleallow->src_str = parse_current->next->data;\n\troleallow->tgt_str = parse_current->next->next->data;\n\n\tast_node->data = roleallow;\n\tast_node->flavor = CIL_ROLEALLOW;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roleallow rule\");\n\tcil_destroy_roleallow(roleallow);\n\treturn rc;\n}\n\nvoid cil_destroy_roleallow(struct cil_roleallow *roleallow)\n{\n\tif (roleallow == NULL) {\n\t\treturn;\n\t}\n\n\tfree(roleallow);\n}\n\nint cil_gen_roleattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_roleattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roleattribute_init(&attr);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)attr, (hashtab_key_t)key, CIL_SYM_ROLES, CIL_ROLEATTRIBUTE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roleattribute declaration\");\n\tcil_destroy_roleattribute(attr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_roleattribute(struct cil_roleattribute *attr)\n{\n\tif (attr == NULL) {\n\t\treturn;\n\t}\n\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\n\tcil_symtab_datum_destroy(&attr->datum);\n\tebitmap_destroy(attr->roles);\n\tfree(attr->roles);\n\tfree(attr);\n}\n\nint cil_gen_roleattributeset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_roleattributeset *attrset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_roleattributeset_init(&attrset);\n\n\tattrset->attr_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_ROLE, &attrset->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tast_node->data = attrset;\n\tast_node->flavor = CIL_ROLEATTRIBUTESET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad roleattributeset declaration\");\n\tcil_destroy_roleattributeset(attrset);\n\n\treturn rc;\n}\n\nvoid cil_destroy_roleattributeset(struct cil_roleattributeset *attrset)\n{\n\tif (attrset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&attrset->str_expr, CIL_TRUE);\n\tcil_list_destroy(&attrset->datum_expr, CIL_FALSE);\n\n\tfree(attrset);\n}\n\nint cil_gen_avrule(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint32_t rule_kind)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_avrule *rule = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_avrule_init(&rule);\n\n\trule->is_extended = 0;\n\trule->rule_kind = rule_kind;\n\n\trule->src_str = parse_current->next->data;\n\trule->tgt_str = parse_current->next->next->data;\n\n\trc = cil_fill_classperms_list(parse_current->next->next->next, &rule->perms.classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = rule;\n\tast_node->flavor = CIL_AVRULE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad allow rule\");\n\tcil_destroy_avrule(rule);\n\treturn rc;\n}\n\nvoid cil_destroy_avrule(struct cil_avrule *rule)\n{\n\tif (rule == NULL) {\n\t\treturn;\n\t}\n\n\tif (!rule->is_extended) {\n\t\tcil_destroy_classperms_list(&rule->perms.classperms);\n\t} else {\n\t\tif (rule->perms.x.permx_str == NULL && rule->perms.x.permx != NULL) {\n\t\t\tcil_destroy_permissionx(rule->perms.x.permx);\n\t\t}\n\t}\n\n\tfree(rule);\n}\n\nint cil_fill_permissionx(struct cil_tree_node *parse_current, struct cil_permissionx *permx)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->data == CIL_KEY_IOCTL) {\n\t\tpermx->kind = CIL_PERMX_KIND_IOCTL;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Unknown permissionx kind, %s. Must be \\\"ioctl\\\"\\n\", (char *)parse_current->data);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tpermx->obj_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_PERMISSIONX, &permx->expr_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad permissionx content\");\n\treturn rc;\n}\n\nint cil_gen_permissionx(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_permissionx *permx = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_permissionx_init(&permx);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)permx, (hashtab_key_t)key, CIL_SYM_PERMX, CIL_PERMISSIONX);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_permissionx(parse_current->next->next->cl_head, permx);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad permissionx statement\");\n\tcil_destroy_permissionx(permx);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_permissionx(struct cil_permissionx *permx)\n{\n\tif (permx == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&permx->datum);\n\n\tcil_list_destroy(&permx->expr_str, CIL_TRUE);\n\tebitmap_destroy(permx->perms);\n\tfree(permx->perms);\n\tfree(permx);\n}\n\nint cil_gen_avrulex(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint32_t rule_kind)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_avrule *rule = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_avrule_init(&rule);\n\n\trule->is_extended = 1;\n\trule->rule_kind = rule_kind;\n\trule->src_str = parse_current->next->data;\n\trule->tgt_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\trule->perms.x.permx_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_permissionx_init(&rule->perms.x.permx);\n\n\t\trc = cil_fill_permissionx(parse_current->next->next->next->cl_head, rule->perms.x.permx);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = rule;\n\tast_node->flavor = CIL_AVRULEX;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad allowx rule\");\n\tcil_destroy_avrule(rule);\n\treturn rc;\n}\n\nint cil_gen_type_rule(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, uint32_t rule_kind)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_type_rule *rule = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_type_rule_init(&rule);\n\n\trule->rule_kind = rule_kind;\n\trule->src_str = parse_current->next->data;\n\trule->tgt_str = parse_current->next->next->data;\n\trule->obj_str = parse_current->next->next->next->data;\n\trule->result_str = parse_current->next->next->next->next->data;\n\n\tast_node->data = rule;\n\tast_node->flavor = CIL_TYPE_RULE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad type rule\");\n\tcil_destroy_type_rule(rule);\n\treturn rc;\n}\n\nvoid cil_destroy_type_rule(struct cil_type_rule *rule)\n{\n\tif (rule == NULL) {\n\t\treturn;\n\t}\n\n\tfree(rule);\n}\n\nint cil_gen_type(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_type *type = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_type_init(&type);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)type, (hashtab_key_t)key, CIL_SYM_TYPES, CIL_TYPE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad type declaration\");\n\tcil_destroy_type(type);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_type(struct cil_type *type)\n{\n\tif (type == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&type->datum);\n\tfree(type);\n}\n\nint cil_gen_typeattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_typeattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_typeattribute_init(&attr);\n\n\tkey = parse_current->next->data;\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)attr, (hashtab_key_t)key, CIL_SYM_TYPES, CIL_TYPEATTRIBUTE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typeattribute declaration\");\n\tcil_destroy_typeattribute(attr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_typeattribute(struct cil_typeattribute *attr)\n{\n\tif (attr == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&attr->datum);\n\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\tebitmap_destroy(attr->types);\n\tfree(attr->types);\n\tfree(attr);\n}\n\nint cil_gen_bool(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, int tunableif)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_bool *boolean = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_bool_init(&boolean);\n\n\tkey = parse_current->next->data;\n\n\tif (parse_current->next->next->data == CIL_KEY_CONDTRUE) {\n\t\tboolean->value = CIL_TRUE;\n\t} else if (parse_current->next->next->data == CIL_KEY_CONDFALSE) {\n\t\tboolean->value = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)boolean, (hashtab_key_t)key, CIL_SYM_BOOLS, CIL_BOOL);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tif (tunableif) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunable (treated as a boolean due to preserve-tunables) declaration\");\n\t} else {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad boolean declaration\");\n\t}\n\tcil_destroy_bool(boolean);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_bool(struct cil_bool *boolean)\n{\n\tif (boolean == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&boolean->datum);\n\tfree(boolean);\n}\n\nint cil_gen_tunable(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_tunable *tunable = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_tunable_init(&tunable);\n\n\tkey = parse_current->next->data;\n\n\tif (parse_current->next->next->data == CIL_KEY_CONDTRUE) {\n\t\ttunable->value = CIL_TRUE;\n\t} else if (parse_current->next->next->data == CIL_KEY_CONDFALSE) {\n\t\ttunable->value = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)tunable, (hashtab_key_t)key, CIL_SYM_TUNABLES, CIL_TUNABLE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunable declaration\");\n\tcil_destroy_tunable(tunable);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_tunable(struct cil_tunable *tunable)\n{\n\tif (tunable == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&tunable->datum);\n\tfree(tunable);\n}\n\nstatic enum cil_flavor __cil_get_expr_operator_flavor(const char *op)\n{\n\tif (op == NULL) return CIL_NONE;\n\telse if (op == CIL_KEY_AND)   return CIL_AND;\n\telse if (op == CIL_KEY_OR)    return CIL_OR;\n\telse if (op == CIL_KEY_NOT)   return CIL_NOT;\n\telse if (op == CIL_KEY_EQ)    return CIL_EQ;    /* Only conditional */\n\telse if (op == CIL_KEY_NEQ)   return CIL_NEQ;   /* Only conditional */\n\telse if (op == CIL_KEY_XOR)   return CIL_XOR;\n\telse if (op == CIL_KEY_ALL)   return CIL_ALL;   /* Only set and permissionx */\n\telse if (op == CIL_KEY_RANGE) return CIL_RANGE; /* Only catset and permissionx */\n\telse return CIL_NONE;\n}\n\nstatic int __cil_fill_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list *expr);\n\nstatic int __cil_fill_expr_helper(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list *expr)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_flavor op;\n\n\top = __cil_get_expr_operator_flavor(current->data);\n\n\trc = cil_verify_expr_syntax(current, op, flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (op != CIL_NONE) {\n\t\tcil_list_append(expr, CIL_OP, (void *)op);\n\t\tcurrent = current->next;\n\t}\n\n\tfor (;current != NULL; current = current->next) {\n\t\trc = __cil_fill_expr(current, flavor, expr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstatic int __cil_fill_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list *expr)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (current->cl_head == NULL) {\n\t\tenum cil_flavor op = __cil_get_expr_operator_flavor(current->data);\n\t\tif (op != CIL_NONE) {\n\t\t\tcil_log(CIL_ERR, \"Operator (%s) not in an expression\\n\", (char*)current->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(expr, CIL_STRING, current->data);\n\t} else {\n\t\tstruct cil_list *sub_expr;\n\t\tcil_list_init(&sub_expr, flavor);\n\t\trc = __cil_fill_expr_helper(current->cl_head, flavor, sub_expr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_list_destroy(&sub_expr, CIL_TRUE);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(expr, CIL_LIST, sub_expr);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\nint cil_gen_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **expr)\n{\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(expr, flavor);\n\n\tif (current->cl_head == NULL) {\n\t\trc = __cil_fill_expr(current, flavor, *expr);\n\t} else {\n\t\trc = __cil_fill_expr_helper(current->cl_head, flavor, *expr);\n\t}\n\n\tif (rc != SEPOL_OK) {\n\t\tcil_list_destroy(expr, CIL_TRUE);\n\t\tcil_log(CIL_ERR, \"Bad expression\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic enum cil_flavor __cil_get_constraint_operator_flavor(const char *op)\n{\n\tif (op == CIL_KEY_AND)         return CIL_AND;\n\telse if (op == CIL_KEY_OR)     return CIL_OR;\n\telse if (op == CIL_KEY_NOT)    return CIL_NOT;\n\telse if (op == CIL_KEY_EQ)     return CIL_EQ;\n\telse if (op == CIL_KEY_NEQ)    return CIL_NEQ;\n\telse if (op == CIL_KEY_CONS_DOM)    return CIL_CONS_DOM;\n\telse if (op == CIL_KEY_CONS_DOMBY)  return CIL_CONS_DOMBY;\n\telse if (op == CIL_KEY_CONS_INCOMP) return CIL_CONS_INCOMP;\n\telse return CIL_NONE;\n}\n\nstatic enum cil_flavor __cil_get_constraint_operand_flavor(const char *operand)\n{\n\tif (operand == NULL) return CIL_LIST;\n\telse if (operand == CIL_KEY_CONS_T1) return CIL_CONS_T1;\n\telse if (operand == CIL_KEY_CONS_T2) return CIL_CONS_T2;\n\telse if (operand == CIL_KEY_CONS_T3) return CIL_CONS_T3;\n\telse if (operand == CIL_KEY_CONS_R1) return CIL_CONS_R1;\n\telse if (operand == CIL_KEY_CONS_R2) return CIL_CONS_R2;\n\telse if (operand == CIL_KEY_CONS_R3) return CIL_CONS_R3;\n\telse if (operand == CIL_KEY_CONS_U1) return CIL_CONS_U1;\n\telse if (operand == CIL_KEY_CONS_U2) return CIL_CONS_U2;\n\telse if (operand == CIL_KEY_CONS_U3) return CIL_CONS_U3;\n\telse if (operand == CIL_KEY_CONS_L1) return CIL_CONS_L1;\n\telse if (operand == CIL_KEY_CONS_L2) return CIL_CONS_L2;\n\telse if (operand == CIL_KEY_CONS_H1) return CIL_CONS_H1;\n\telse if (operand == CIL_KEY_CONS_H2) return CIL_CONS_H2;\n\telse return CIL_STRING;\n}\n\nstatic int __cil_fill_constraint_leaf_expr(struct cil_tree_node *current, enum cil_flavor expr_flavor, enum cil_flavor op, struct cil_list **leaf_expr)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_flavor leaf_expr_flavor = CIL_NONE;\n\tenum cil_flavor l_flavor = CIL_NONE;\n\tenum cil_flavor r_flavor = CIL_NONE;\n\n\tl_flavor = __cil_get_constraint_operand_flavor(current->next->data);\n\tr_flavor = __cil_get_constraint_operand_flavor(current->next->next->data);\n\n\tswitch (l_flavor) {\n\tcase CIL_CONS_U1:\n\tcase CIL_CONS_U2:\n\tcase CIL_CONS_U3:\n\t\tleaf_expr_flavor = CIL_USER;\n\t\tbreak;\n\tcase CIL_CONS_R1:\n\tcase CIL_CONS_R2:\n\tcase CIL_CONS_R3:\n\t\tleaf_expr_flavor = CIL_ROLE;\n\t\tbreak;\n\tcase CIL_CONS_T1:\n\tcase CIL_CONS_T2:\n\tcase CIL_CONS_T3:\n\t\tleaf_expr_flavor = CIL_TYPE;\n\t\tbreak;\n\tcase CIL_CONS_L1:\n\tcase CIL_CONS_L2:\n\tcase CIL_CONS_H1:\n\tcase CIL_CONS_H2:\n\t\tleaf_expr_flavor = CIL_LEVEL;\n\t\tbreak;\n\tdefault:\n\t\tcil_log(CIL_ERR, \"Invalid left operand (%s)\\n\", (char*)current->next->data);\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_constraint_leaf_expr_syntax(l_flavor, r_flavor, op, expr_flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_init(leaf_expr, leaf_expr_flavor);\n\n\tcil_list_append(*leaf_expr, CIL_OP, (void *)op);\n\n\tcil_list_append(*leaf_expr, CIL_CONS_OPERAND, (void *)l_flavor);\n\n\tif (r_flavor == CIL_STRING) {\n\t\tcil_list_append(*leaf_expr, CIL_STRING, current->next->next->data);\n\t} else if (r_flavor == CIL_LIST) {\n\t\tstruct cil_list *sub_list;\n\t\trc = cil_fill_list(current->next->next->cl_head, leaf_expr_flavor, &sub_list);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_list_destroy(leaf_expr, CIL_TRUE);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(*leaf_expr, CIL_LIST, sub_list);\n\t} else {\n\t\tcil_list_append(*leaf_expr, CIL_CONS_OPERAND, (void *)r_flavor);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\n\treturn SEPOL_ERR;\n}\n\nstatic int __cil_fill_constraint_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **expr)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_flavor op;\n\tstruct cil_list *lexpr;\n\tstruct cil_list *rexpr;\n\n\tif (current->data == NULL || current->cl_head != NULL) {\n\t\tcil_log(CIL_ERR, \"Expected a string at the start of the constraint expression\\n\");\n\t\tgoto exit;\n\t}\n\n\top = __cil_get_constraint_operator_flavor(current->data);\n\n\trc = cil_verify_constraint_expr_syntax(current, op);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tswitch (op) {\n\tcase CIL_EQ:\n\tcase CIL_NEQ:\n\tcase CIL_CONS_DOM:\n\tcase CIL_CONS_DOMBY:\n\tcase CIL_CONS_INCOMP:\n\t\trc = __cil_fill_constraint_leaf_expr(current, flavor, op, expr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase CIL_NOT:\n\t\trc = __cil_fill_constraint_expr(current->next->cl_head, flavor, &lexpr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_init(expr, flavor);\n\t\tcil_list_append(*expr, CIL_OP, (void *)op);\n\t\tcil_list_append(*expr, CIL_LIST, lexpr);\n\t\tbreak;\n\tdefault:\n\t\trc = __cil_fill_constraint_expr(current->next->cl_head, flavor, &lexpr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trc = __cil_fill_constraint_expr(current->next->next->cl_head, flavor, &rexpr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_list_destroy(&lexpr, CIL_TRUE);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_init(expr, flavor);\n\t\tcil_list_append(*expr, CIL_OP, (void *)op);\n\t\tcil_list_append(*expr, CIL_LIST, lexpr);\n\t\tcil_list_append(*expr, CIL_LIST, rexpr);\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\n\treturn rc;\n}\n\nint cil_gen_constraint_expr(struct cil_tree_node *current, enum cil_flavor flavor, struct cil_list **expr)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (current->cl_head == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_fill_constraint_expr(current->cl_head, flavor, expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\n\tcil_log(CIL_ERR, \"Bad expression tree for constraint\\n\");\n\treturn rc;\n}\n\nint cil_gen_boolif(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, int tunableif)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_booleanif *bif = NULL;\n\tstruct cil_tree_node *next = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_boolif_init(&bif);\n\tbif->preserved_tunable = tunableif;\n\n\trc = cil_gen_expr(parse_current->next, CIL_BOOL, &bif->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_conditional_blocks(parse_current->next->next);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t/* Destroying expr tree */\n\tnext = parse_current->next->next;\n\tcil_tree_subtree_destroy(parse_current->next);\n\tparse_current->next = next;\n\n\tast_node->flavor = CIL_BOOLEANIF;\n\tast_node->data = bif;\n\n\treturn SEPOL_OK;\n\nexit:\n\tif (tunableif) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunableif (treated as a booleanif due to preserve-tunables) declaration\");\n\t} else {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad booleanif declaration\");\n\t}\n\tcil_destroy_boolif(bif);\n\treturn rc;\n}\n\nvoid cil_destroy_boolif(struct cil_booleanif *bif)\n{\n\tif (bif == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&bif->str_expr, CIL_TRUE);\n\tcil_list_destroy(&bif->datum_expr, CIL_FALSE);\n\n\tfree(bif);\n}\n\nint cil_gen_tunif(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_tunableif *tif = NULL;\n\tstruct cil_tree_node *next = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_tunif_init(&tif);\n\n\trc = cil_gen_expr(parse_current->next, CIL_TUNABLE, &tif->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_conditional_blocks(parse_current->next->next);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t/* Destroying expr tree */\n\tnext = parse_current->next->next;\n\tcil_tree_subtree_destroy(parse_current->next);\n\tparse_current->next = next;\n\n\tast_node->flavor = CIL_TUNABLEIF;\n\tast_node->data = tif;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad tunableif declaration\");\n\tcil_destroy_tunif(tif);\n\treturn rc;\n}\n\nvoid cil_destroy_tunif(struct cil_tunableif *tif)\n{\n\tif (tif == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&tif->str_expr, CIL_TRUE);\n\tcil_list_destroy(&tif->datum_expr, CIL_FALSE);\n\n\tfree(tif);\n}\n\nint cil_gen_condblock(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_condblock *cb = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (ast_node->parent->flavor != CIL_BOOLEANIF && ast_node->parent->flavor != CIL_TUNABLEIF) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Conditional statements must be a direct child of a tunableif or booleanif statement.\\n\");\n\t\tgoto exit;\n\t}\n\n\tast_node->flavor = CIL_CONDBLOCK;\n\n\tcil_condblock_init(&cb);\n\tcb->flavor = flavor;\n\n\tast_node->data = cb;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s condition declaration\",\n\t\t(char*)parse_current->data);\n\tcil_destroy_condblock(cb);\n\treturn rc;\n}\n\nvoid cil_destroy_condblock(struct cil_condblock *cb)\n{\n\tif (cb == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_array_destroy(cb->symtab);\n\tfree(cb);\n}\n\nint cil_gen_alias(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_alias *alias = NULL;\n\tenum cil_sym_index sym_index;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_alias_init(&alias);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_flavor_to_symtab_index(flavor, &sym_index);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)alias, (hashtab_key_t)key, sym_index, flavor);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s declaration\", (char*)parse_current->data);\n\tcil_destroy_alias(alias);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_alias(struct cil_alias *alias)\n{\n\tif (alias == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&alias->datum);\n\talias->actual = NULL;\n\n\tfree(alias);\n}\n\nint cil_gen_aliasactual(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_aliasactual *aliasactual = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif ((flavor == CIL_TYPEALIAS && parse_current->next->data == CIL_KEY_SELF) || parse_current->next->next->data == CIL_KEY_SELF) {\n\t\tcil_log(CIL_ERR, \"The keyword '%s' is reserved\\n\", CIL_KEY_SELF);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tcil_aliasactual_init(&aliasactual);\n\n\taliasactual->alias_str = parse_current->next->data;\n\n\taliasactual->actual_str = parse_current->next->next->data;\n\n\tast_node->data = aliasactual;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s association\", cil_node_to_string(parse_current));\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_aliasactual(struct cil_aliasactual *aliasactual)\n{\n\tif (aliasactual == NULL) {\n\t\treturn;\n\t}\n\n\tfree(aliasactual);\n}\n\nint cil_gen_typeattributeset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_typeattributeset *attrset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_typeattributeset_init(&attrset);\n\n\tattrset->attr_str = parse_current->next->data;\n\n\trc = cil_gen_expr(parse_current->next->next, CIL_TYPE, &attrset->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tast_node->data = attrset;\n\tast_node->flavor = CIL_TYPEATTRIBUTESET;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typeattributeset statement\");\n\tcil_destroy_typeattributeset(attrset);\n\treturn rc;\n}\n\nvoid cil_destroy_typeattributeset(struct cil_typeattributeset *attrset)\n{\n\tif (attrset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&attrset->str_expr, CIL_TRUE);\n\tcil_list_destroy(&attrset->datum_expr, CIL_FALSE);\n\n\tfree(attrset);\n}\n\nint cil_gen_expandtypeattribute(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tchar *expand_str;\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_expandtypeattribute *expandattr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_expandtypeattribute_init(&expandattr);\n\n\tif (parse_current->next->cl_head == NULL) {\n\t\tcil_list_init(&expandattr->attr_strs, CIL_TYPE);\n\t\tcil_list_append(expandattr->attr_strs, CIL_STRING, parse_current->next->data);\n\t} else {\n\t\trc = cil_fill_list(parse_current->next->cl_head, CIL_TYPE, &expandattr->attr_strs);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\texpand_str = parse_current->next->next->data;\n\n\tif (expand_str == CIL_KEY_CONDTRUE) {\n\t\texpandattr->expand = CIL_TRUE;\n\t} else if (expand_str == CIL_KEY_CONDFALSE) {\n\t\texpandattr->expand = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\tgoto exit;\n\t}\n\n\tast_node->data = expandattr;\n\tast_node->flavor = CIL_EXPANDTYPEATTRIBUTE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad expandtypeattribute statement\");\n\tcil_destroy_expandtypeattribute(expandattr);\n\treturn rc;\n}\n\nvoid cil_destroy_expandtypeattribute(struct cil_expandtypeattribute *expandattr)\n{\n\tif (expandattr == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&expandattr->attr_strs, CIL_TRUE);\n\n\tcil_list_destroy(&expandattr->attr_datums, CIL_FALSE);\n\n\tfree(expandattr);\n}\n\nint cil_gen_typepermissive(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_typepermissive *typeperm = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_typepermissive_init(&typeperm);\n\n\ttypeperm->type_str = parse_current->next->data;\n\n\tast_node->data = typeperm;\n\tast_node->flavor = CIL_TYPEPERMISSIVE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typepermissive declaration\");\n\tcil_destroy_typepermissive(typeperm);\n\treturn rc;\n}\n\nvoid cil_destroy_typepermissive(struct cil_typepermissive *typeperm)\n{\n\tif (typeperm == NULL) {\n\t\treturn;\n\t}\n\n\tfree(typeperm);\n}\n\nint cil_gen_typetransition(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *s1, *s2, *s3, *s4, *s5;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL ) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ts1 = parse_current->next->data;\n\ts2 = parse_current->next->next->data;\n\ts3 = parse_current->next->next->next->data;\n\ts4 = parse_current->next->next->next->next->data;\n\ts5 = NULL;\n\n\tif (parse_current->next->next->next->next->next) {\n\t\tif (s4 == CIL_KEY_STAR) {\n\t\t\ts4 = parse_current->next->next->next->next->next->data;\n\t\t} else {\n\t\t\ts5 = parse_current->next->next->next->next->next->data;\n\t\t}\n\t}\n\n\tif (s5) {\n\t\tstruct cil_nametypetransition *nametypetrans = NULL;\n\n\t\tcil_nametypetransition_init(&nametypetrans);\n\n\t\tnametypetrans->src_str = s1;\n\t\tnametypetrans->tgt_str = s2;\n\t\tnametypetrans->obj_str = s3;\n\t\tnametypetrans->result_str = s5;\n\t\tnametypetrans->name_str = s4;\n\n\t\tast_node->data = nametypetrans;\n\t\tast_node->flavor = CIL_NAMETYPETRANSITION;\n\t} else {\n\t\tstruct cil_type_rule *rule = NULL;\n\n\t\tcil_type_rule_init(&rule);\n\n\t\trule->rule_kind = CIL_TYPE_TRANSITION;\n\t\trule->src_str = s1;\n\t\trule->tgt_str = s2;\n\t\trule->obj_str = s3;\n\t\trule->result_str = s4;\n\n\t\tast_node->data = rule;\n\t\tast_node->flavor = CIL_TYPE_RULE;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad typetransition declaration\");\n\treturn rc;\n}\n\nvoid cil_destroy_name(struct cil_name *name)\n{\n\tif (name == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&name->datum);\n\tfree(name);\n}\n\nvoid cil_destroy_typetransition(struct cil_nametypetransition *nametypetrans)\n{\n\tif (nametypetrans == NULL) {\n\t\treturn;\n\t}\n\n\tfree(nametypetrans);\n}\n\nint cil_gen_rangetransition(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_rangetransition *rangetrans = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL ) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_rangetransition_init(&rangetrans);\n\n\trangetrans->src_str = parse_current->next->data;\n\trangetrans->exec_str = parse_current->next->next->data;\n\trangetrans->obj_str = parse_current->next->next->next->data;\n\n\trangetrans->range_str = NULL;\n\n\tif (parse_current->next->next->next->next->cl_head == NULL) {\n\t\trangetrans->range_str = parse_current->next->next->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&rangetrans->range);\n\n\t\trc = cil_fill_levelrange(parse_current->next->next->next->next->cl_head, rangetrans->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = rangetrans;\n\tast_node->flavor = CIL_RANGETRANSITION;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad rangetransition declaration\");\n\tcil_destroy_rangetransition(rangetrans);\n\treturn rc;\n}\n\nvoid cil_destroy_rangetransition(struct cil_rangetransition *rangetrans)\n{\n\tif (rangetrans == NULL) {\n\t\treturn;\n\t}\n\n\tif (rangetrans->range_str == NULL && rangetrans->range != NULL) {\n\t\tcil_destroy_levelrange(rangetrans->range);\n\t}\n\n\tfree(rangetrans);\n}\n\nint cil_gen_sensitivity(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_sens *sens = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sens_init(&sens);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)sens, (hashtab_key_t)key, CIL_SYM_SENS, CIL_SENS);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sensitivity declaration\");\n\tcil_destroy_sensitivity(sens);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_sensitivity(struct cil_sens *sens)\n{\n\tif (sens == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&sens->datum);\n\n\tcil_list_destroy(&sens->cats_list, CIL_FALSE);\n\n\tfree(sens);\n}\n\nint cil_gen_category(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_cat *cat = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_cat_init(&cat);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)cat, (hashtab_key_t)key, CIL_SYM_CATS, CIL_CAT);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad category declaration\");\n\tcil_destroy_category(cat);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_category(struct cil_cat *cat)\n{\n\tif (cat == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&cat->datum);\n\tfree(cat);\n}\n\nint cil_gen_catset(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_catset *catset = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_catset_init(&catset);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)catset, (hashtab_key_t)key, CIL_SYM_CATS, CIL_CATSET);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_cats(parse_current->next->next, &catset->cats);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad categoryset declaration\");\n\tcil_destroy_catset(catset);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_catset(struct cil_catset *catset)\n{\n\tif (catset == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&catset->datum);\n\n\tcil_destroy_cats(catset->cats);\n\n\tfree(catset);\n}\n\nint cil_gen_catorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_catorder *catorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc !=  SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_catorder_init(&catorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_CATORDER, &catorder->cat_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(curr, catorder->cat_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tcil_log(CIL_ERR, \"Category order cannot be unordered.\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = catorder;\n\tast_node->flavor = CIL_CATORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad categoryorder declaration\");\n\tcil_destroy_catorder(catorder);\n\treturn rc;\n}\n\nvoid cil_destroy_catorder(struct cil_catorder *catorder)\n{\n\tif (catorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (catorder->cat_list_str != NULL) {\n\t\tcil_list_destroy(&catorder->cat_list_str, 1);\n\t}\n\n\tfree(catorder);\n}\n\nint cil_gen_sensitivityorder(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_sensorder *sensorder = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_sensorder_init(&sensorder);\n\n\trc = cil_fill_list(parse_current->next->cl_head, CIL_SENSITIVITYORDER, &sensorder->sens_list_str);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(curr, sensorder->sens_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tcil_log(CIL_ERR, \"Sensitivy order cannot be unordered.\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = sensorder;\n\tast_node->flavor = CIL_SENSITIVITYORDER;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sensitivityorder declaration\");\n\tcil_destroy_sensitivityorder(sensorder);\n\treturn rc;\n}\n\nvoid cil_destroy_sensitivityorder(struct cil_sensorder *sensorder)\n{\n\tif (sensorder == NULL) {\n\t\treturn;\n\t}\n\n\tif (sensorder->sens_list_str != NULL) {\n\t\tcil_list_destroy(&sensorder->sens_list_str, CIL_TRUE);\n\t}\n\n\tfree(sensorder);\n}\n\nint cil_gen_senscat(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_senscat *senscat = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_senscat_init(&senscat);\n\n\tsenscat->sens_str = parse_current->next->data;\n\n\trc = cil_fill_cats(parse_current->next->next, &senscat->cats);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = senscat;\n\tast_node->flavor = CIL_SENSCAT;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad sensitivitycategory declaration\");\n\tcil_destroy_senscat(senscat);\n\treturn rc;\n}\n\nvoid cil_destroy_senscat(struct cil_senscat *senscat)\n{\n\tif (senscat == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_cats(senscat->cats);\n\n\tfree(senscat);\n}\n\nint cil_gen_level(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_level *level = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_level_init(&level);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)level, (hashtab_key_t)key, CIL_SYM_LEVELS, CIL_LEVEL);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_level(parse_current->next->next->cl_head, level);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad level declaration\");\n\tcil_destroy_level(level);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_level(struct cil_level *level)\n{\n\tif (level == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&level->datum);\n\n\tcil_destroy_cats(level->cats);\n\n\tfree(level);\n}\n\n/* low should be pointing to either the name of the low level or to an open paren for an anonymous low level */\nint cil_fill_levelrange(struct cil_tree_node *low, struct cil_levelrange *lvlrange)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\n\tif (low == NULL || lvlrange == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(low, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\n\t\tgoto exit;\n\t}\n\n\tif (low->cl_head == NULL) {\n\t\tlvlrange->low_str = low->data;\n\t} else {\n\t\tcil_level_init(&lvlrange->low);\n\t\trc = cil_fill_level(low->cl_head, lvlrange->low);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (low->next->cl_head == NULL) {\n\t\tlvlrange->high_str = low->next->data;\n\t} else {\n\t\tcil_level_init(&lvlrange->high);\n\t\trc = cil_fill_level(low->next->cl_head, lvlrange->high);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad levelrange\\n\");\n\treturn rc;\n}\n\nint cil_gen_levelrange(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_levelrange *lvlrange = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_levelrange_init(&lvlrange);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)lvlrange, (hashtab_key_t)key, CIL_SYM_LEVELRANGES, CIL_LEVELRANGE);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_levelrange(parse_current->next->next->cl_head, lvlrange);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad levelrange declaration\");\n\tcil_destroy_levelrange(lvlrange);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_levelrange(struct cil_levelrange *lvlrange)\n{\n\tif (lvlrange == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&lvlrange->datum);\n\n\tif (lvlrange->low_str == NULL) {\n\t\tcil_destroy_level(lvlrange->low);\n\t}\n\n\tif (lvlrange->high_str == NULL) {\n\t\tcil_destroy_level(lvlrange->high);\n\t}\n\n\tfree(lvlrange);\n}\n\nint cil_gen_constrain(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_constrain *cons = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_constrain_init(&cons);\n\n\trc = cil_fill_classperms_list(parse_current->next, &cons->classperms);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_constraint_expr(parse_current->next->next, flavor, &cons->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = cons;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad constrain declaration\");\n\tcil_destroy_constrain(cons);\n\treturn rc;\n}\n\nvoid cil_destroy_constrain(struct cil_constrain *cons)\n{\n\tif (cons == NULL) {\n\t\treturn;\n\t}\n\n\tcil_destroy_classperms_list(&cons->classperms);\n\tcil_list_destroy(&cons->str_expr, CIL_TRUE);\n\tcil_list_destroy(&cons->datum_expr, CIL_FALSE);\n\n\tfree(cons);\n}\n\nint cil_gen_validatetrans(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_validatetrans *validtrans = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_validatetrans_init(&validtrans);\n\n\tvalidtrans->class_str = parse_current->next->data;\n\n\trc = cil_gen_constraint_expr(parse_current->next->next, flavor, &validtrans->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tast_node->data = validtrans;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad validatetrans declaration\");\n\tcil_destroy_validatetrans(validtrans);\n\treturn rc;\n\n\n}\n\nvoid cil_destroy_validatetrans(struct cil_validatetrans *validtrans)\n{\n\tif (validtrans == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&validtrans->str_expr, CIL_TRUE);\n\tcil_list_destroy(&validtrans->datum_expr, CIL_FALSE);\n\n\tfree(validtrans);\n}\n\n/* Fills in context starting from user */\nint cil_fill_context(struct cil_tree_node *user_node, struct cil_context *context)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\n\tif (user_node == NULL || context == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(user_node, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcontext->user_str = user_node->data;\n\tcontext->role_str = user_node->next->data;\n\tcontext->type_str = user_node->next->next->data;\n\n\tcontext->range_str = NULL;\n\n\tif (user_node->next->next->next->cl_head == NULL) {\n\t\tcontext->range_str = user_node->next->next->next->data;\n\t} else {\n\t\tcil_levelrange_init(&context->range);\n\n\t\trc = cil_fill_levelrange(user_node->next->next->next->cl_head, context->range);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad context\\n\");\n\treturn rc;\n}\n\nint cil_gen_context(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_context *context = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_context_init(&context);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)context, (hashtab_key_t)key, CIL_SYM_CONTEXTS, CIL_CONTEXT);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_fill_context(parse_current->next->next->cl_head, context);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad context declaration\");\n\tcil_destroy_context(context);\n\tcil_clear_node(ast_node);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_context(struct cil_context *context)\n{\n\tif (context == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&context->datum);;\n\n\tif (context->range_str == NULL && context->range != NULL) {\n\t\tcil_destroy_levelrange(context->range);\n\t}\n\n\tfree(context);\n}\n\nint cil_gen_filecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST | CIL_SYN_EMPTY_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_filecon *filecon = NULL;\n\tchar *type = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ttype = parse_current->next->next->data;\n\tcil_filecon_init(&filecon);\n\n\tfilecon->path_str = parse_current->next->data;\n\n\tif (type == CIL_KEY_FILE) {\n\t\tfilecon->type = CIL_FILECON_FILE;\n\t} else if (type == CIL_KEY_DIR) {\n\t\tfilecon->type = CIL_FILECON_DIR;\n\t} else if (type == CIL_KEY_CHAR) {\n\t\tfilecon->type = CIL_FILECON_CHAR;\n\t} else if (type == CIL_KEY_BLOCK) {\n\t\tfilecon->type = CIL_FILECON_BLOCK;\n\t} else if (type == CIL_KEY_SOCKET) {\n\t\tfilecon->type = CIL_FILECON_SOCKET;\n\t} else if (type == CIL_KEY_PIPE) {\n\t\tfilecon->type = CIL_FILECON_PIPE;\n\t} else if (type == CIL_KEY_SYMLINK) {\n\t\tfilecon->type = CIL_FILECON_SYMLINK;\n\t} else if (type == CIL_KEY_ANY) {\n\t\tfilecon->type = CIL_FILECON_ANY;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Invalid file type\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tfilecon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tif (parse_current->next->next->next->cl_head->next == NULL) {\n\t\t\tfilecon->context = NULL;\n\t\t} else {\n\t\t\tcil_context_init(&filecon->context);\n\n\t\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, filecon->context);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tast_node->data = filecon;\n\tast_node->flavor = CIL_FILECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad filecon declaration\");\n\tcil_destroy_filecon(filecon);\n\treturn rc;\n}\n\n//TODO: Should we be checking if the pointer is NULL when passed in?\nvoid cil_destroy_filecon(struct cil_filecon *filecon)\n{\n\tif (filecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (filecon->context_str == NULL && filecon->context != NULL) {\n\t\tcil_destroy_context(filecon->context);\n\t}\n\n\tfree(filecon);\n}\n\nint cil_gen_ibpkeycon(__attribute__((unused)) struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax) / sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_ibpkeycon *ibpkeycon = NULL;\n\n\tif (!parse_current || !ast_node)\n\t\tgoto exit;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\tcil_ibpkeycon_init(&ibpkeycon);\n\n\tibpkeycon->subnet_prefix_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head) {\n\t\tif (parse_current->next->next->cl_head->next &&\n\t\t    !parse_current->next->next->cl_head->next->next) {\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head, &ibpkeycon->pkey_low, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ibpkey specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head->next, &ibpkeycon->pkey_high, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ibpkey specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper ibpkey range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer(parse_current->next->next, &ibpkeycon->pkey_low, 0);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper ibpkey specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tibpkeycon->pkey_high = ibpkeycon->pkey_low;\n\t}\n\n\tif (!parse_current->next->next->next->cl_head) {\n\t\tibpkeycon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&ibpkeycon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, ibpkeycon->context);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\tast_node->data = ibpkeycon;\n\tast_node->flavor = CIL_IBPKEYCON;\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ibpkeycon declaration\");\n\tcil_destroy_ibpkeycon(ibpkeycon);\n\n\treturn rc;\n}\n\nvoid cil_destroy_ibpkeycon(struct cil_ibpkeycon *ibpkeycon)\n{\n\tif (!ibpkeycon)\n\t\treturn;\n\n\tif (!ibpkeycon->context_str && ibpkeycon->context)\n\t\tcil_destroy_context(ibpkeycon->context);\n\n\tfree(ibpkeycon);\n}\n\nint cil_gen_portcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_portcon *portcon = NULL;\n\tchar *proto;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_portcon_init(&portcon);\n\n\tproto = parse_current->next->data;\n\tif (proto == CIL_KEY_UDP) {\n\t\tportcon->proto = CIL_PROTOCOL_UDP;\n\t} else if (proto == CIL_KEY_TCP) {\n\t\tportcon->proto = CIL_PROTOCOL_TCP;\n\t} else if (proto == CIL_KEY_DCCP) {\n\t\tportcon->proto = CIL_PROTOCOL_DCCP;\n\t} else if (proto == CIL_KEY_SCTP) {\n\t\tportcon->proto = CIL_PROTOCOL_SCTP;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Invalid protocol\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->cl_head != NULL) {\n\t\tif (parse_current->next->next->cl_head->next != NULL\n\t\t&& parse_current->next->next->cl_head->next->next == NULL) {\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head, &portcon->port_low, 10);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper port specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer(parse_current->next->next->cl_head->next, &portcon->port_high, 10);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper port specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper port range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer(parse_current->next->next, &portcon->port_low, 10);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper port specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tportcon->port_high = portcon->port_low;\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL ) {\n\t\tportcon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&portcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, portcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = portcon;\n\tast_node->flavor = CIL_PORTCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad portcon declaration\");\n\tcil_destroy_portcon(portcon);\n\treturn rc;\n}\n\nvoid cil_destroy_portcon(struct cil_portcon *portcon)\n{\n\tif (portcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (portcon->context_str == NULL && portcon->context != NULL) {\n\t\tcil_destroy_context(portcon->context);\n\t}\n\n\tfree(portcon);\n}\n\nint cil_gen_nodecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_nodecon *nodecon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_nodecon_init(&nodecon);\n\n\tif (parse_current->next->cl_head == NULL ) {\n\t\tnodecon->addr_str = parse_current->next->data;\n\t} else {\n\t\tcil_ipaddr_init(&nodecon->addr);\n\n\t\trc = cil_fill_ipaddr(parse_current->next->cl_head, nodecon->addr);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL ) {\n\t\tnodecon->mask_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_ipaddr_init(&nodecon->mask);\n\n\t\trc = cil_fill_ipaddr(parse_current->next->next->cl_head, nodecon->mask);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL ) {\n\t\tnodecon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&nodecon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, nodecon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = nodecon;\n\tast_node->flavor = CIL_NODECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad nodecon declaration\");\n\tcil_destroy_nodecon(nodecon);\n\treturn rc;\n}\n\nvoid cil_destroy_nodecon(struct cil_nodecon *nodecon)\n{\n\tif (nodecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (nodecon->addr_str == NULL && nodecon->addr != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->addr);\n\t}\n\n\tif (nodecon->mask_str == NULL && nodecon->mask != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->mask);\n\t}\n\n\tif (nodecon->context_str == NULL && nodecon->context != NULL) {\n\t\tcil_destroy_context(nodecon->context);\n\t}\n\n\tfree(nodecon);\n}\n\nint cil_gen_genfscon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_genfscon *genfscon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_genfscon_init(&genfscon);\n\n\tgenfscon->fs_str = parse_current->next->data;\n\tgenfscon->path_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL ) {\n\t\tgenfscon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&genfscon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, genfscon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = genfscon;\n\tast_node->flavor = CIL_GENFSCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad genfscon declaration\");\n\tcil_destroy_genfscon(genfscon);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_genfscon(struct cil_genfscon *genfscon)\n{\n\tif (genfscon == NULL) {\n\t\treturn;\n\t}\n\n\tif (genfscon->context_str == NULL && genfscon->context != NULL) {\n\t\tcil_destroy_context(genfscon->context);\n\t}\n\n\tfree(genfscon);\n}\n\n\nint cil_gen_netifcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_netifcon *netifcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_netifcon_init(&netifcon);\n\n\tnetifcon->interface_str = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tnetifcon->if_context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&netifcon->if_context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, netifcon->if_context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tnetifcon->packet_context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&netifcon->packet_context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, netifcon->packet_context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = netifcon;\n\tast_node->flavor = CIL_NETIFCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad netifcon declaration\");\n\tcil_destroy_netifcon(netifcon);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_netifcon(struct cil_netifcon *netifcon)\n{\n\tif (netifcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (netifcon->if_context_str == NULL && netifcon->if_context != NULL) {\n\t\tcil_destroy_context(netifcon->if_context);\n\t}\n\n\tif (netifcon->packet_context_str == NULL && netifcon->packet_context != NULL) {\n\t\tcil_destroy_context(netifcon->packet_context);\n\t}\n\n\tfree(netifcon);\n}\n\nint cil_gen_ibendportcon(__attribute__((unused)) struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax) / sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_ibendportcon *ibendportcon = NULL;\n\n\tif (!parse_current || !ast_node)\n\t\tgoto exit;\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\tcil_ibendportcon_init(&ibendportcon);\n\n\tibendportcon->dev_name_str = parse_current->next->data;\n\n\trc = cil_fill_integer(parse_current->next->next, &ibendportcon->port, 10);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Improper ibendport port specified\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (!parse_current->next->next->next->cl_head) {\n\t\tibendportcon->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&ibendportcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, ibendportcon->context);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\tast_node->data = ibendportcon;\n\tast_node->flavor = CIL_IBENDPORTCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ibendportcon declaration\");\n\tcil_destroy_ibendportcon(ibendportcon);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_ibendportcon(struct cil_ibendportcon *ibendportcon)\n{\n\tif (!ibendportcon)\n\t\treturn;\n\n\tif (!ibendportcon->context_str && ibendportcon->context)\n\t\tcil_destroy_context(ibendportcon->context);\n\n\tfree(ibendportcon);\n}\n\nint cil_gen_pirqcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_pirqcon *pirqcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_pirqcon_init(&pirqcon);\n\n\trc = cil_fill_integer(parse_current->next, &pirqcon->pirq, 10);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tpirqcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&pirqcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, pirqcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = pirqcon;\n\tast_node->flavor = CIL_PIRQCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad pirqcon declaration\");\n\tcil_destroy_pirqcon(pirqcon);\n\treturn rc;\n}\n\nvoid cil_destroy_pirqcon(struct cil_pirqcon *pirqcon)\n{\n\tif (pirqcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (pirqcon->context_str == NULL && pirqcon->context != NULL) {\n\t\tcil_destroy_context(pirqcon->context);\n\t}\n\n\tfree(pirqcon);\n}\n\nint cil_gen_iomemcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_iomemcon *iomemcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_iomemcon_init(&iomemcon);\n\n\tif (parse_current->next->cl_head != NULL) {\n\t\tif (parse_current->next->cl_head->next != NULL &&\n\t\t    parse_current->next->cl_head->next->next == NULL) {\n\t\t\trc = cil_fill_integer64(parse_current->next->cl_head, &iomemcon->iomem_low, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper iomem specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer64(parse_current->next->cl_head->next, &iomemcon->iomem_high, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper iomem specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper iomem range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer64(parse_current->next, &iomemcon->iomem_low, 0);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper iomem specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tiomemcon->iomem_high = iomemcon->iomem_low;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL ) {\n\t\tiomemcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&iomemcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, iomemcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = iomemcon;\n\tast_node->flavor = CIL_IOMEMCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad iomemcon declaration\");\n\tcil_destroy_iomemcon(iomemcon);\n\treturn rc;\n}\n\nvoid cil_destroy_iomemcon(struct cil_iomemcon *iomemcon)\n{\n\tif (iomemcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (iomemcon->context_str == NULL && iomemcon->context != NULL) {\n\t\tcil_destroy_context(iomemcon->context);\n\t}\n\n\tfree(iomemcon);\n}\n\nint cil_gen_ioportcon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_ioportcon *ioportcon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_ioportcon_init(&ioportcon);\n\n\tif (parse_current->next->cl_head != NULL) {\n\t\tif (parse_current->next->cl_head->next != NULL &&\n\t\t    parse_current->next->cl_head->next->next == NULL) {\n\t\t\trc = cil_fill_integer(parse_current->next->cl_head, &ioportcon->ioport_low, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ioport specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trc = cil_fill_integer(parse_current->next->cl_head->next, &ioportcon->ioport_high, 0);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Improper ioport specified\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"Improper ioport range specified\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\trc = cil_fill_integer(parse_current->next, &ioportcon->ioport_low, 0);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Improper ioport specified\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tioportcon->ioport_high = ioportcon->ioport_low;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL ) {\n\t\tioportcon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&ioportcon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, ioportcon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = ioportcon;\n\tast_node->flavor = CIL_IOPORTCON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ioportcon declaration\");\n\tcil_destroy_ioportcon(ioportcon);\n\treturn rc;\n}\n\nvoid cil_destroy_ioportcon(struct cil_ioportcon *ioportcon)\n{\n\tif (ioportcon == NULL) {\n\t\treturn;\n\t}\n\n\tif (ioportcon->context_str == NULL && ioportcon->context != NULL) {\n\t\tcil_destroy_context(ioportcon->context);\n\t}\n\n\tfree(ioportcon);\n}\n\nint cil_gen_pcidevicecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_pcidevicecon *pcidevicecon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_pcidevicecon_init(&pcidevicecon);\n\n\trc = cil_fill_integer(parse_current->next, &pcidevicecon->dev, 0);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tpcidevicecon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&pcidevicecon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, pcidevicecon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = pcidevicecon;\n\tast_node->flavor = CIL_PCIDEVICECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad pcidevicecon declaration\");\n\tcil_destroy_pcidevicecon(pcidevicecon);\n\treturn rc;\n}\n\nvoid cil_destroy_pcidevicecon(struct cil_pcidevicecon *pcidevicecon)\n{\n\tif (pcidevicecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (pcidevicecon->context_str == NULL && pcidevicecon->context != NULL) {\n\t\tcil_destroy_context(pcidevicecon->context);\n\t}\n\n\tfree(pcidevicecon);\n}\n\nint cil_gen_devicetreecon(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tint rc = SEPOL_ERR;\n\tstruct cil_devicetreecon *devicetreecon = NULL;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_devicetreecon_init(&devicetreecon);\n\n\tdevicetreecon->path = parse_current->next->data;\n\n\tif (parse_current->next->next->cl_head == NULL) {\n\t\tdevicetreecon->context_str = parse_current->next->next->data;\n\t} else {\n\t\tcil_context_init(&devicetreecon->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->cl_head, devicetreecon->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = devicetreecon;\n\tast_node->flavor = CIL_DEVICETREECON;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad devicetreecon declaration\");\n\tcil_destroy_devicetreecon(devicetreecon);\n\treturn rc;\n}\n\nvoid cil_destroy_devicetreecon(struct cil_devicetreecon *devicetreecon)\n{\n\tif (devicetreecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (devicetreecon->context_str == NULL && devicetreecon->context != NULL) {\n\t\tcil_destroy_context(devicetreecon->context);\n\t}\n\n\tfree(devicetreecon);\n}\n\nint cil_gen_fsuse(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *type = NULL;\n\tstruct cil_fsuse *fsuse = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ttype = parse_current->next->data;\n\n\tcil_fsuse_init(&fsuse);\n\n\tif (type == CIL_KEY_XATTR) {\n\t\tfsuse->type = CIL_FSUSE_XATTR;\n\t} else if (type == CIL_KEY_TASK) {\n\t\tfsuse->type = CIL_FSUSE_TASK;\n\t} else if (type == CIL_KEY_TRANS) {\n\t\tfsuse->type = CIL_FSUSE_TRANS;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Invalid fsuse type\\n\");\n\t\tgoto exit;\n\t}\n\n\tfsuse->fs_str = parse_current->next->next->data;\n\n\tif (parse_current->next->next->next->cl_head == NULL) {\n\t\tfsuse->context_str = parse_current->next->next->next->data;\n\t} else {\n\t\tcil_context_init(&fsuse->context);\n\n\t\trc = cil_fill_context(parse_current->next->next->next->cl_head, fsuse->context);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tast_node->data = fsuse;\n\tast_node->flavor = CIL_FSUSE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad fsuse declaration\");\n\tcil_destroy_fsuse(fsuse);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_fsuse(struct cil_fsuse *fsuse)\n{\n\tif (fsuse == NULL) {\n\t\treturn;\n\t}\n\n\tif (fsuse->context_str == NULL && fsuse->context != NULL) {\n\t\tcil_destroy_context(fsuse->context);\n\t}\n\n\tfree(fsuse);\n}\n\nvoid cil_destroy_param(struct cil_param *param)\n{\n\tif (param == NULL) {\n\t\treturn;\n\t}\n\n\tfree(param);\n}\n\nint cil_gen_macro(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tchar *key = NULL;\n\tstruct cil_macro *macro = NULL;\n\tstruct cil_tree_node *macro_content = NULL;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST | CIL_SYN_EMPTY_LIST,\n\t\tCIL_SYN_N_LISTS | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/ sizeof(*syntax);\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc =__cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_macro_init(&macro);\n\n\tkey = parse_current->next->data;\n\n\tstruct cil_tree_node *current_item = parse_current->next->next->cl_head;\n\twhile (current_item != NULL) {\n\t\tenum cil_syntax param_syntax[] = {\n\t\t\tCIL_SYN_STRING,\n\t\t\tCIL_SYN_STRING,\n\t\t\tCIL_SYN_END\n\t\t};\n\t\tint param_syntax_len = sizeof(param_syntax)/sizeof(*param_syntax);\n\t\tchar *kind = NULL;\n\t\tstruct cil_param *param = NULL;\n\n\t\trc =__cil_verify_syntax(current_item->cl_head, param_syntax, param_syntax_len);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (macro->params == NULL) {\n\t\t\tcil_list_init(&macro->params, CIL_LIST_ITEM);\n\t\t}\n\n\t\tkind = current_item->cl_head->data;\n\t\tcil_param_init(&param);\n\n\t\tif (kind == CIL_KEY_TYPE) {\n\t\t\tparam->flavor = CIL_TYPE;\n\t\t} else if (kind == CIL_KEY_ROLE) {\n\t\t\tparam->flavor = CIL_ROLE;\n\t\t} else if (kind == CIL_KEY_USER) {\n\t\t\tparam->flavor = CIL_USER;\n\t\t} else if (kind == CIL_KEY_SENSITIVITY) {\n\t\t\tparam->flavor = CIL_SENS;\n\t\t} else if (kind == CIL_KEY_CATEGORY) {\n\t\t\tparam->flavor = CIL_CAT;\n\t\t} else if (kind == CIL_KEY_CATSET) {\n\t\t\tparam->flavor = CIL_CATSET;\n\t\t} else if (kind == CIL_KEY_LEVEL) {\n\t\t\tparam->flavor = CIL_LEVEL;\n\t\t} else if (kind == CIL_KEY_LEVELRANGE) {\n\t\t\tparam->flavor = CIL_LEVELRANGE;\n\t\t} else if (kind == CIL_KEY_CLASS) {\n\t\t\tparam->flavor = CIL_CLASS;\n\t\t} else if (kind == CIL_KEY_IPADDR) {\n\t\t\tparam->flavor = CIL_IPADDR;\n\t\t} else if (kind == CIL_KEY_MAP_CLASS) {\n\t\t\tparam->flavor = CIL_MAP_CLASS;\n\t\t} else if (kind == CIL_KEY_CLASSPERMISSION) {\n\t\t\tparam->flavor = CIL_CLASSPERMISSION;\n\t\t} else if (kind == CIL_KEY_BOOL) {\n\t\t\tparam->flavor = CIL_BOOL;\n\t\t} else if (kind == CIL_KEY_STRING) {\n\t\t\tparam->flavor = CIL_NAME;\n\t\t} else if (kind == CIL_KEY_NAME) {\n\t\t\tparam->flavor = CIL_NAME;\n\t\t} else {\n\t\t\tcil_log(CIL_ERR, \"The kind %s is not allowed as a parameter\\n\",kind);\n\t\t\tcil_destroy_param(param);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tparam->str =  current_item->cl_head->next->data;\n\n\t\trc = cil_verify_name(param->str, param->flavor);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_destroy_param(param);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t//walk current list and check for duplicate parameters\n\t\tstruct cil_list_item *curr_param;\n\t\tcil_list_for_each(curr_param, macro->params) {\n\t\t\tif (param->str == ((struct cil_param*)curr_param->data)->str) {\n\t\t\t\tcil_log(CIL_ERR, \"Duplicate parameter\\n\");\n\t\t\t\tcil_destroy_param(param);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tcil_list_append(macro->params, CIL_PARAM, param);\n\n\t\tcurrent_item = current_item->next;\n\t}\n\n\t/* we don't want the tree walker to walk the macro parameters (they were just handled above), so the subtree is deleted, and the next pointer of the\n           node containing the macro name is updated to point to the start of the macro content */\n\tmacro_content = parse_current->next->next->next;\n\tcil_tree_subtree_destroy(parse_current->next->next);\n\tparse_current->next->next = macro_content;\n\tif (macro_content == NULL) {\n\t\t/* No statements in macro and macro parameter list was last node */\n\t\tparse_current->parent->cl_tail = parse_current->next;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)macro, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_MACRO);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad macro declaration\");\n\tcil_destroy_macro(macro);\n\tcil_clear_node(ast_node);\n\treturn SEPOL_ERR;\n}\n\nvoid cil_destroy_macro(struct cil_macro *macro)\n{\n\tif (macro == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&macro->datum);\n\tcil_symtab_array_destroy(macro->symtab);\n\n\tif (macro->params != NULL) {\n\t\tcil_list_destroy(&macro->params, 1);\n\t}\n\n\tfree(macro);\n}\n\nint cil_gen_call(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_LIST | CIL_SYN_EMPTY_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_call *call = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_call_init(&call);\n\n\tcall->macro_str = parse_current->next->data;\n\n\tif (parse_current->next->next != NULL) {\n\t\tcil_tree_init(&call->args_tree);\n\t\tcil_copy_ast(db, parse_current->next->next, call->args_tree->root);\n\t}\n\n\tast_node->data = call;\n\tast_node->flavor = CIL_CALL;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad macro call\");\n\tcil_destroy_call(call);\n\treturn rc;\n}\n\nvoid cil_destroy_call(struct cil_call *call)\n{\n\tif (call == NULL) {\n\t\treturn;\n\t}\n\n\tcall->macro = NULL;\n\n\tif (call->args_tree != NULL) {\n\t\tcil_tree_destroy(&call->args_tree);\n\t}\n\n\tif (call->args != NULL) {\n\t\tcil_list_destroy(&call->args, 1);\n\t}\n\n\tfree(call);\n}\n\nvoid cil_destroy_args(struct cil_args *args)\n{\n\tif (args == NULL) {\n\t\treturn;\n\t}\n\n\tif (args->arg_str != NULL) {\n\t\targs->arg_str = NULL;\n\t} else if (args->arg != NULL) {\n\t\tstruct cil_tree_node *node = args->arg->nodes->head->data;\n\t\tswitch (args->flavor) {\n\t\tcase CIL_NAME:\n\t\t\tbreak;\n\t\tcase CIL_CATSET:\n\t\t\tcil_destroy_catset((struct cil_catset *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\tcil_destroy_level((struct cil_level *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\tcil_destroy_levelrange((struct cil_levelrange *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_IPADDR:\n\t\t\tcil_destroy_ipaddr((struct cil_ipaddr *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSION:\n\t\t\tcil_destroy_classpermission((struct cil_classpermission *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcil_log(CIL_ERR, \"Destroying arg with the unexpected flavor=%d\\n\",args->flavor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targs->param_str = NULL;\n\targs->arg = NULL;\n\n\tfree(args);\n}\n\nint cil_gen_optional(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_N_LISTS | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_optional *optional = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_optional_init(&optional);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)optional, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_OPTIONAL);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad optional\");\n\tcil_destroy_optional(optional);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_optional(struct cil_optional *optional)\n{\n\tif (optional == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&optional->datum);\n\tfree(optional);\n}\n\nint cil_gen_policycap(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_policycap *polcap = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_policycap_init(&polcap);\n\n\tkey = parse_current->next->data;\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)polcap, (hashtab_key_t)key, CIL_SYM_POLICYCAPS, CIL_POLICYCAP);\n\tif (rc != SEPOL_OK)\n\t\tgoto exit;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad policycap statement\");\n\tcil_destroy_policycap(polcap);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_policycap(struct cil_policycap *polcap)\n{\n\tif (polcap == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&polcap->datum);\n\tfree(polcap);\n}\n\nint cil_gen_ipaddr(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tchar *key = NULL;\n\tstruct cil_ipaddr *ipaddr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_ipaddr_init(&ipaddr);\n\n\tkey  = parse_current->next->data;\n\n\trc = cil_fill_ipaddr(parse_current->next->next, ipaddr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)ipaddr, (hashtab_key_t)key, CIL_SYM_IPADDRS, CIL_IPADDR);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad ipaddr statement\");\n\tcil_destroy_ipaddr(ipaddr);\n\tcil_clear_node(ast_node);\n\treturn rc;\n}\n\nvoid cil_destroy_ipaddr(struct cil_ipaddr *ipaddr)\n{\n\tif (ipaddr == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&ipaddr->datum);\n\tfree(ipaddr);\n}\n\nint cil_fill_integer(struct cil_tree_node *int_node, uint32_t *integer, int base)\n{\n\tint rc = SEPOL_ERR;\n\tchar *endptr = NULL;\n\tunsigned long val;\n\n\tif (int_node == NULL || int_node->data == NULL || integer == NULL) {\n\t\tgoto exit;\n\t}\n\n\terrno = 0;\n\tval = strtoul(int_node->data, &endptr, base);\n\tif (errno != 0 || endptr == int_node->data || *endptr != '\\0') {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\t/* Ensure that the value fits a 32-bit integer without triggering -Wtype-limits */\n#if ULONG_MAX > UINT32_MAX\n\tif (val > UINT32_MAX) {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n#endif\n\n\t*integer = val;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Failed to create integer from string\\n\");\n\treturn rc;\n}\n\nint cil_fill_integer64(struct cil_tree_node *int_node, uint64_t *integer, int base)\n{\n\tint rc = SEPOL_ERR;\n\tchar *endptr = NULL;\n\tuint64_t val;\n\n\tif (int_node == NULL || int_node->data == NULL || integer == NULL) {\n\t\tgoto exit;\n\t}\n\n\terrno = 0;\n\tval = strtoull(int_node->data, &endptr, base);\n\tif (errno != 0 || endptr == int_node->data || *endptr != '\\0') {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\t*integer = val;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Failed to create integer from string\\n\");\n\treturn rc;\n}\n\nint cil_fill_ipaddr(struct cil_tree_node *addr_node, struct cil_ipaddr *addr)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (addr_node == NULL || addr_node->data == NULL || addr == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (addr_node->cl_head != NULL ||  addr_node->next != NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (strchr(addr_node->data, '.') != NULL) {\n\t\taddr->family = AF_INET;\n\t} else {\n\t\taddr->family = AF_INET6;\n\t}\n\n\trc = inet_pton(addr->family, addr_node->data, &addr->ip);\n\tif (rc != 1) {\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad ip address or netmask\\n\"); \n\treturn rc;\n}\n\nint cil_fill_level(struct cil_tree_node *curr, struct cil_level *level)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\tif (curr == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(curr, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tlevel->sens_str = curr->data;\n\tif (curr->next != NULL) {\n\t\trc = cil_fill_cats(curr->next, &level->cats);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_log(CIL_ERR, \"Bad level\\n\");\n\treturn rc;\n}\n\nint cil_fill_cats(struct cil_tree_node *curr, struct cil_cats **cats)\n{\n\tint rc = SEPOL_ERR;\n\n\tcil_cats_init(cats);\n\n\trc = cil_gen_expr(curr, CIL_CAT, &(*cats)->str_expr);\n\tif (rc != SEPOL_OK) {\n\t\tcil_destroy_cats(*cats);\n\t\t*cats = NULL;\n\t}\n\n\treturn rc;\n}\n\nvoid cil_destroy_cats(struct cil_cats *cats)\n{\n\tif (cats == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cats->str_expr, CIL_TRUE);\n\n\tcil_list_destroy(&cats->datum_expr, CIL_FALSE);\n\n\tfree(cats);\n}\nint cil_gen_bounds(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_bounds *bounds = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL || parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_bounds_init(&bounds);\n\n\tbounds->parent_str = parse_current->next->data;\n\tbounds->child_str = parse_current->next->next->data;\n\n\tast_node->data = bounds;\n\n\tswitch (flavor) {\n\tcase CIL_USER:\n\t\tast_node->flavor = CIL_USERBOUNDS;\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tast_node->flavor = CIL_ROLEBOUNDS;\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tast_node->flavor = CIL_TYPEBOUNDS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad bounds declaration\");\n\tcil_destroy_bounds(bounds);\n\treturn rc;\n}\n\nvoid cil_destroy_bounds(struct cil_bounds *bounds)\n{\n\tif (bounds == NULL) {\n\t\treturn;\n\t}\n\n\tfree(bounds);\n}\n\nint cil_gen_default(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node, enum cil_flavor flavor)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_default *def = NULL;\n\tchar *object;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_default_init(&def);\n\n\tdef->flavor = flavor;\n\n\tif (parse_current->next->cl_head == NULL) {\n\t\tcil_list_init(&def->class_strs, CIL_CLASS);\n\t\tcil_list_append(def->class_strs, CIL_STRING, parse_current->next->data);\n\t} else {\n\t\trc = cil_fill_list(parse_current->next->cl_head, CIL_CLASS, &def->class_strs);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tobject = parse_current->next->next->data;\n\tif (object == CIL_KEY_SOURCE) {\n\t\tdef->object = CIL_DEFAULT_SOURCE;\n\t} else if (object == CIL_KEY_TARGET) {\n\t\tdef->object = CIL_DEFAULT_TARGET;\n\t} else {\n\t\tcil_log(CIL_ERR,\"Expected either 'source' or 'target'\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = def;\n\tast_node->flavor = flavor;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad %s declaration\", cil_node_to_string(parse_current));\n\tcil_destroy_default(def);\n\treturn rc;\n}\n\nvoid cil_destroy_default(struct cil_default *def)\n{\n\tif (def == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&def->class_strs, CIL_TRUE);\n\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n\n\tfree(def);\n}\n\nint cil_gen_defaultrange(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_defaultrange *def = NULL;\n\tchar *object;\n\tchar *range;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_LIST,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING | CIL_SYN_END,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_defaultrange_init(&def);\n\n\tif (parse_current->next->cl_head == NULL) {\n\t\tcil_list_init(&def->class_strs, CIL_CLASS);\n\t\tcil_list_append(def->class_strs, CIL_STRING, parse_current->next->data);\n\t} else {\n\t\trc = cil_fill_list(parse_current->next->cl_head, CIL_CLASS, &def->class_strs);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tobject = parse_current->next->next->data;\n\tif (object == CIL_KEY_SOURCE) {\n\t\trange = parse_current->next->next->next->data;\n\t\tif (range == CIL_KEY_LOW) {\n\t\t\tdef->object_range = CIL_DEFAULT_SOURCE_LOW;\n\t\t} else if (range == CIL_KEY_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_SOURCE_HIGH;\n\t\t} else if (range == CIL_KEY_LOW_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_SOURCE_LOW_HIGH;\n\t\t} else {\n\t\t\tcil_log(CIL_ERR,\"Expected 'low', 'high', or 'low-high'\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else if (object == CIL_KEY_TARGET) {\n\t\trange = parse_current->next->next->next->data;\n\t\tif (range == CIL_KEY_LOW) {\n\t\t\tdef->object_range = CIL_DEFAULT_TARGET_LOW;\n\t\t} else if (range == CIL_KEY_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_TARGET_HIGH;\n\t\t} else if (range == CIL_KEY_LOW_HIGH) {\n\t\t\tdef->object_range = CIL_DEFAULT_TARGET_LOW_HIGH;\n\t\t} else {\n\t\t\tcil_log(CIL_ERR,\"Expected 'low', 'high', or 'low-high'\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else if (object == CIL_KEY_GLBLUB) {\n\t\tdef->object_range = CIL_DEFAULT_GLBLUB;\n\t} else {\n\t\tcil_log(CIL_ERR,\"Expected \\'source\\', \\'target\\', or \\'glblub\\'\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = def;\n\tast_node->flavor = CIL_DEFAULTRANGE;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad defaultrange declaration\");\n\tcil_destroy_defaultrange(def);\n\treturn rc;\n}\n\nvoid cil_destroy_defaultrange(struct cil_defaultrange *def)\n{\n\tif (def == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&def->class_strs, CIL_TRUE);\n\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n\n\tfree(def);\n}\n\nint cil_gen_handleunknown(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_handleunknown *unknown = NULL;\n\tchar *unknown_key;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_handleunknown_init(&unknown);\n\n\tunknown_key = parse_current->next->data;\n\tif (unknown_key == CIL_KEY_HANDLEUNKNOWN_ALLOW) {\n\t\tunknown->handle_unknown = SEPOL_ALLOW_UNKNOWN;\n\t} else if (unknown_key == CIL_KEY_HANDLEUNKNOWN_DENY) {\n\t\tunknown->handle_unknown = SEPOL_DENY_UNKNOWN;\n\t} else if (unknown_key == CIL_KEY_HANDLEUNKNOWN_REJECT) {\n\t\tunknown->handle_unknown = SEPOL_REJECT_UNKNOWN;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Expected either \\'%s\\', \\'%s\\', or \\'%s\\'\\n\", CIL_KEY_HANDLEUNKNOWN_ALLOW, CIL_KEY_HANDLEUNKNOWN_DENY, CIL_KEY_HANDLEUNKNOWN_REJECT);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = unknown;\n\tast_node->flavor = CIL_HANDLEUNKNOWN;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad handleunknown\");\n\tcil_destroy_handleunknown(unknown);\n\treturn rc;\n}\n\nvoid cil_destroy_handleunknown(struct cil_handleunknown *unk)\n{\n\tfree(unk);\n}\n\nint cil_gen_mls(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_syntax syntax[] = {\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_STRING,\n\t\tCIL_SYN_END\n\t};\n\tint syntax_len = sizeof(syntax)/sizeof(*syntax);\n\tstruct cil_mls *mls = NULL;\n\n\tif (parse_current == NULL || ast_node == NULL) {\n\t\tgoto exit;\n\t}\n\n\trc = __cil_verify_syntax(parse_current, syntax, syntax_len);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcil_mls_init(&mls);\n\n\tif (parse_current->next->data == CIL_KEY_CONDTRUE) {\n\t\tmls->value = CIL_TRUE;\n\t} else if (parse_current->next->data == CIL_KEY_CONDFALSE) {\n\t\tmls->value = CIL_FALSE;\n\t} else {\n\t\tcil_log(CIL_ERR, \"Value must be either \\'true\\' or \\'false\\'\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tast_node->data = mls;\n\tast_node->flavor = CIL_MLS;\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(parse_current, CIL_ERR, \"Bad mls\");\n\tcil_destroy_mls(mls);\n\treturn rc;\n}\n\nvoid cil_destroy_mls(struct cil_mls *mls)\n{\n\tfree(mls);\n}\n\nint cil_gen_src_info(struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)\n{\n\t/* No need to check syntax, because this is auto generated */\n\tstruct cil_src_info *info = NULL;\n\n\tif (parse_current->next == NULL || parse_current->next->next == NULL) {\n\t\tcil_tree_log(parse_current, CIL_ERR, \"Bad <src_info>\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\tcil_src_info_init(&info);\n\n\tinfo->is_cil = (parse_current->next->data == CIL_KEY_SRC_CIL) ? CIL_TRUE : CIL_FALSE;\n\tinfo->path = parse_current->next->next->data;\n\n\tast_node->data = info;\n\tast_node->flavor = CIL_SRC_INFO;\n\n\treturn SEPOL_OK;\n}\n\nvoid cil_destroy_src_info(struct cil_src_info *info)\n{\n\tfree(info);\n}\n\nint __cil_build_ast_node_helper(struct cil_tree_node *parse_current, uint32_t *finished, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_db *db = args->db;\n\tstruct cil_tree_node *ast_current = args->ast;\n\tstruct cil_tree_node *tunif = args->tunif;\n\tstruct cil_tree_node *in = args->in;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *optional = args->optional;\n\tstruct cil_tree_node *boolif = args->boolif;\n\tstruct cil_tree_node *ast_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (parse_current->parent->cl_head != parse_current) {\n\t\t/* ignore anything that isn't following a parenthesis */\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t} else if (parse_current->data == NULL) {\n\t\t/* the only time parenthesis can immediately following parenthesis is if\n\t\t * the parent is the root node */\n\t\tif (parse_current->parent->parent == NULL) {\n\t\t\trc = SEPOL_OK;\n\t\t} else {\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Keyword expected after open parenthesis\");\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (tunif != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found tunable\");\n\t\t\tcil_log(CIL_ERR, \"Tunables cannot be defined within tunableif statement\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tif (parse_current->data == CIL_KEY_IN) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found in-statement\");\n\t\t\tcil_log(CIL_ERR, \"in-statements cannot be defined within in-statements\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE ||\n\t\t\tparse_current->data == CIL_KEY_IN ||\n\t\t\tparse_current->data == CIL_KEY_BLOCK ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKINHERIT ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKABSTRACT ||\n\t\t\tparse_current->data == CIL_KEY_MACRO) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"%s is not allowed in macros\", (char *)parse_current->data);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (optional != NULL) {\n\t\tif (parse_current->data == CIL_KEY_TUNABLE ||\n\t\t\tparse_current->data == CIL_KEY_IN ||\n\t\t\tparse_current->data == CIL_KEY_BLOCK ||\n\t\t\tparse_current->data == CIL_KEY_BLOCKABSTRACT ||\n\t\t\tparse_current->data == CIL_KEY_MACRO) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"%s is not allowed in optionals\", (char *)parse_current->data);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (parse_current->data != CIL_KEY_TUNABLEIF &&\n\t\t\tparse_current->data != CIL_KEY_CALL &&\n\t\t\tparse_current->data != CIL_KEY_CONDTRUE &&\n\t\t\tparse_current->data != CIL_KEY_CONDFALSE &&\n\t\t\tparse_current->data != CIL_KEY_ALLOW &&\n\t\t\tparse_current->data != CIL_KEY_DONTAUDIT &&\n\t\t\tparse_current->data != CIL_KEY_AUDITALLOW &&\n\t\t\tparse_current->data != CIL_KEY_TYPETRANSITION &&\n\t\t\tparse_current->data != CIL_KEY_TYPECHANGE &&\n\t\t\tparse_current->data != CIL_KEY_TYPEMEMBER) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_tree_log(parse_current, CIL_ERR, \"Found %s\", (char*)parse_current->data);\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_log(CIL_ERR, \"%s cannot be defined within tunableif statement (treated as a booleanif due to preserve-tunables)\\n\",\n\t\t\t\t\t\t(char*)parse_current->data);\n\t\t\t} else {\n\t\t\t\tcil_log(CIL_ERR, \"%s cannot be defined within booleanif statement\\n\",\n\t\t\t\t\t\t(char*)parse_current->data);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tcil_tree_node_init(&ast_node);\n\n\tast_node->parent = ast_current;\n\tast_node->line = parse_current->line;\n\tast_node->hll_line = parse_current->hll_line;\n\n\tif (parse_current->data == CIL_KEY_BLOCK) {\n\t\trc = cil_gen_block(db, parse_current, ast_node, 0);\n\t} else if (parse_current->data == CIL_KEY_BLOCKINHERIT) {\n\t\trc = cil_gen_blockinherit(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_BLOCKABSTRACT) {\n\t\trc = cil_gen_blockabstract(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_IN) {\n\t\trc = cil_gen_in(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CLASS) {\n\t\trc = cil_gen_class(db, parse_current, ast_node);\n\t\t// To avoid parsing list of perms again\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSORDER) {\n\t\trc = cil_gen_classorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MAP_CLASS) {\n\t\trc = cil_gen_map_class(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSMAPPING) {\n\t\trc = cil_gen_classmapping(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSPERMISSION) {\n\t\trc = cil_gen_classpermission(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSPERMISSIONSET) {\n\t\trc = cil_gen_classpermissionset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_COMMON) {\n\t\trc = cil_gen_common(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CLASSCOMMON) {\n\t\trc = cil_gen_classcommon(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SID) {\n\t\trc = cil_gen_sid(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SIDCONTEXT) {\n\t\trc = cil_gen_sidcontext(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SIDORDER) {\n\t\trc = cil_gen_sidorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USER) {\n\t\trc = cil_gen_user(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERATTRIBUTE) {\n\t\trc = cil_gen_userattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERATTRIBUTESET) {\n\t\trc = cil_gen_userattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERLEVEL) {\n\t\trc = cil_gen_userlevel(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERRANGE) {\n\t\trc = cil_gen_userrange(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_USERBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_USER);\n\t} else if (parse_current->data == CIL_KEY_USERPREFIX) {\n\t\trc = cil_gen_userprefix(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SELINUXUSER) {\n\t\trc = cil_gen_selinuxuser(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SELINUXUSERDEFAULT) {\n\t\trc = cil_gen_selinuxuserdefault(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPE) {\n\t\trc = cil_gen_type(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPEATTRIBUTE) {\n\t\trc = cil_gen_typeattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPEATTRIBUTESET) {\n\t\trc = cil_gen_typeattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_EXPANDTYPEATTRIBUTE) {\n\t\trc = cil_gen_expandtypeattribute(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPEALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_TYPEALIAS);\n\t} else if (parse_current->data == CIL_KEY_TYPEALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_TYPEALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_TYPEBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_TYPE);\n\t} else if (parse_current->data == CIL_KEY_TYPEPERMISSIVE) {\n\t\trc = cil_gen_typepermissive(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_RANGETRANSITION) {\n\t\trc = cil_gen_rangetransition(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ROLE) {\n\t\trc = cil_gen_role(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_USERROLE) {\n\t\trc = cil_gen_userrole(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLETYPE) {\n\t\trc = cil_gen_roletype(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLETRANSITION) {\n\t\trc = cil_gen_roletransition(parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEALLOW) {\n\t\trc = cil_gen_roleallow(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEATTRIBUTE) {\n\t\trc = cil_gen_roleattribute(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_ROLEATTRIBUTESET) {\n\t\trc = cil_gen_roleattributeset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ROLEBOUNDS) {\n\t\trc = cil_gen_bounds(db, parse_current, ast_node, CIL_ROLE);\n\t} else if (parse_current->data == CIL_KEY_BOOL) {\n\t\trc = cil_gen_bool(db, parse_current, ast_node, CIL_FALSE);\n\t} else if (parse_current->data == CIL_KEY_BOOLEANIF) {\n\t\trc = cil_gen_boolif(db, parse_current, ast_node, CIL_FALSE);\n\t} else if(parse_current->data == CIL_KEY_TUNABLE) {\n\t\tif (db->preserve_tunables) {\n\t\t\trc = cil_gen_bool(db, parse_current, ast_node, CIL_TRUE);\n\t\t} else {\n\t\t\trc = cil_gen_tunable(db, parse_current, ast_node);\n\t\t}\n\t} else if (parse_current->data == CIL_KEY_TUNABLEIF) {\n\t\tif (db->preserve_tunables) {\n\t\t\trc = cil_gen_boolif(db, parse_current, ast_node, CIL_TRUE);\n\t\t} else {\n\t\t\trc = cil_gen_tunif(db, parse_current, ast_node);\n\t\t}\n\t} else if (parse_current->data == CIL_KEY_CONDTRUE) {\n\t\trc = cil_gen_condblock(db, parse_current, ast_node, CIL_CONDTRUE);\n\t} else if (parse_current->data == CIL_KEY_CONDFALSE) {\n\t\trc = cil_gen_condblock(db, parse_current, ast_node, CIL_CONDFALSE);\n\t} else if (parse_current->data == CIL_KEY_ALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_ALLOWED);\n\t\t// So that the object and perms lists do not get parsed again\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_AUDITALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_AUDITALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DONTAUDIT) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_DONTAUDIT);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NEVERALLOW) {\n\t\trc = cil_gen_avrule(parse_current, ast_node, CIL_AVRULE_NEVERALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_ALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_ALLOWED);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_AUDITALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_AUDITALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DONTAUDITX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_DONTAUDIT);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NEVERALLOWX) {\n\t\trc = cil_gen_avrulex(parse_current, ast_node, CIL_AVRULE_NEVERALLOW);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PERMISSIONX) {\n\t\trc = cil_gen_permissionx(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_TYPETRANSITION) {\n\t\trc = cil_gen_typetransition(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_TYPECHANGE) {\n\t\trc = cil_gen_type_rule(parse_current, ast_node, CIL_TYPE_CHANGE);\n\t} else if (parse_current->data == CIL_KEY_TYPEMEMBER) {\n\t\trc = cil_gen_type_rule(parse_current, ast_node, CIL_TYPE_MEMBER);\n\t} else if (parse_current->data == CIL_KEY_SENSITIVITY) {\n\t\trc = cil_gen_sensitivity(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_SENSALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_SENSALIAS);\n\t} else if (parse_current->data == CIL_KEY_SENSALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_SENSALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_CATEGORY) {\n\t\trc = cil_gen_category(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CATALIAS) {\n\t\trc = cil_gen_alias(db, parse_current, ast_node, CIL_CATALIAS);\n\t} else if (parse_current->data == CIL_KEY_CATALIASACTUAL) {\n\t\trc = cil_gen_aliasactual(db, parse_current, ast_node, CIL_CATALIASACTUAL);\n\t} else if (parse_current->data == CIL_KEY_CATSET) {\n\t\trc = cil_gen_catset(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CATORDER) {\n\t\trc = cil_gen_catorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SENSITIVITYORDER) {\n\t\trc = cil_gen_sensitivityorder(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SENSCAT) {\n\t\trc = cil_gen_senscat(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_LEVEL) {\n\t\trc = cil_gen_level(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_LEVELRANGE) {\n\t\trc = cil_gen_levelrange(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CONSTRAIN) {\n\t\trc = cil_gen_constrain(db, parse_current, ast_node, CIL_CONSTRAIN);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLSCONSTRAIN) {\n\t\trc = cil_gen_constrain(db, parse_current, ast_node, CIL_MLSCONSTRAIN);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_VALIDATETRANS) {\n\t\trc = cil_gen_validatetrans(db, parse_current, ast_node, CIL_VALIDATETRANS);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLSVALIDATETRANS) {\n\t\trc = cil_gen_validatetrans(db, parse_current, ast_node, CIL_MLSVALIDATETRANS);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_CONTEXT) {\n\t\trc = cil_gen_context(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_FILECON) {\n\t\trc = cil_gen_filecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IBPKEYCON) {\n\t\trc = cil_gen_ibpkeycon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IBENDPORTCON) {\n\t\trc = cil_gen_ibendportcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PORTCON) {\n\t\trc = cil_gen_portcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NODECON) {\n\t\trc = cil_gen_nodecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_GENFSCON) {\n\t\trc = cil_gen_genfscon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_NETIFCON) {\n\t\trc = cil_gen_netifcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PIRQCON) {\n\t\trc = cil_gen_pirqcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IOMEMCON) {\n\t\trc = cil_gen_iomemcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_IOPORTCON) {\n\t\trc = cil_gen_ioportcon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_PCIDEVICECON) {\n\t\trc = cil_gen_pcidevicecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEVICETREECON) {\n\t\trc = cil_gen_devicetreecon(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_FSUSE) {\n\t\trc = cil_gen_fsuse(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MACRO) {\n\t\trc = cil_gen_macro(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_CALL) {\n\t\trc = cil_gen_call(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_POLICYCAP) {\n\t\trc = cil_gen_policycap(db, parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_OPTIONAL) {\n\t\trc = cil_gen_optional(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_IPADDR) {\n\t\trc = cil_gen_ipaddr(db, parse_current, ast_node);\n\t} else if (parse_current->data == CIL_KEY_DEFAULTUSER) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTUSER);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTROLE) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTROLE);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTTYPE) {\n\t\trc = cil_gen_default(parse_current, ast_node, CIL_DEFAULTTYPE);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_DEFAULTRANGE) {\n\t\trc = cil_gen_defaultrange(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_HANDLEUNKNOWN) {\n\t\trc = cil_gen_handleunknown(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_MLS) {\n\t\trc = cil_gen_mls(parse_current, ast_node);\n\t\t*finished = CIL_TREE_SKIP_NEXT;\n\t} else if (parse_current->data == CIL_KEY_SRC_INFO) {\n\t\trc = cil_gen_src_info(parse_current, ast_node);\n\t} else {\n\t\tcil_log(CIL_ERR, \"Error: Unknown keyword %s\\n\", (char *)parse_current->data);\n\t\trc = SEPOL_ERR;\n\t}\n\n\tif (rc == SEPOL_OK) {\n\t\tif (ast_current->cl_head == NULL) {\n\t\t\tast_current->cl_head = ast_node;\n\t\t} else {\n\t\t\tast_current->cl_tail->next = ast_node;\n\t\t}\n\t\tast_current->cl_tail = ast_node;\n\t\tast_current = ast_node;\n\t\targs->ast = ast_current;\n\t} else {\n\t\tcil_tree_node_destroy(&ast_node);\n\t}\n\nexit:\n\treturn rc;\n}\n\nint __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\n\targs->ast = ast->parent;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = ast->parent;\n\t\targs->optional = NULL;\n\t\t/* Optionals can be nested */\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\t// At this point we no longer have any need for parse_current or any of its\n\t// siblings; they have all been converted to the appropriate AST node. The\n\t// full parse tree will get deleted elsewhere, but in an attempt to\n\t// minimize memory usage (of which the parse tree uses a lot), start\n\t// deleting the parts we don't need now.\n\tcil_tree_children_destroy(parse_current->parent);\n\n\treturn SEPOL_OK;\n}\n\nint cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif = NULL;\n\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n", "/*\n * Copyright 2011 Tresys Technology, LLC. All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n * \n *    2. Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY TRESYS TECHNOLOGY, LLC ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL TRESYS TECHNOLOGY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of Tresys Technology, LLC.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <sepol/policydb/conditional.h>\n\n#include \"cil_internal.h\"\n#include \"cil_flavor.h\"\n#include \"cil_log.h\"\n#include \"cil_mem.h\"\n#include \"cil_tree.h\"\n#include \"cil_list.h\"\n#include \"cil_build_ast.h\"\n#include \"cil_resolve_ast.h\"\n#include \"cil_reset_ast.h\"\n#include \"cil_copy_ast.h\"\n#include \"cil_verify.h\"\n#include \"cil_strpool.h\"\n#include \"cil_symtab.h\"\n\nstruct cil_args_resolve {\n\tstruct cil_db *db;\n\tenum cil_pass pass;\n\tuint32_t *changed;\n\tstruct cil_list *disabled_optionals;\n\tstruct cil_tree_node *block;\n\tstruct cil_tree_node *macro;\n\tstruct cil_tree_node *optional;\n\tstruct cil_tree_node *boolif;\n\tstruct cil_list *sidorder_lists;\n\tstruct cil_list *classorder_lists;\n\tstruct cil_list *unordered_classorder_lists;\n\tstruct cil_list *catorder_lists;\n\tstruct cil_list *sensitivityorder_lists;\n\tstruct cil_list *in_list;\n};\n\nstatic struct cil_name * __cil_insert_name(struct cil_db *db, hashtab_key_t key, struct cil_tree_node *ast_node)\n{\n\t/* Currently only used for typetransition file names.\n\t   But could be used for any string that is passed as a parameter.\n\t*/\n\tstruct cil_tree_node *parent = ast_node->parent;\n\tstruct cil_macro *macro = NULL;\n\tstruct cil_name *name;\n\tsymtab_t *symtab;\n\tenum cil_sym_index sym_index;\n\tstruct cil_symtab_datum *datum = NULL;\n\n\tif (parent->flavor == CIL_CALL) {\n\t\tstruct cil_call *call = parent->data;\n\t\tmacro = call->macro;\t\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\tmacro = parent->data;\n\t}\n\tif (macro != NULL && macro->params != NULL) {\n\t\tstruct cil_list_item *item;\n\t\tcil_list_for_each(item, macro->params) {\n\t\t\tif (((struct cil_param*)item->data)->str == key) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tcil_flavor_to_symtab_index(CIL_NAME, &sym_index);\n\tsymtab = &((struct cil_root *)db->ast->root->data)->symtab[sym_index];\n\n\tcil_symtab_get_datum(symtab, key, &datum);\n\tif (datum != NULL) {\n\t\treturn (struct cil_name *)datum;\n\t}\n\n\tcil_name_init(&name);\n\tcil_symtab_insert(symtab, key, (struct cil_symtab_datum *)name, ast_node);\n\tcil_list_append(db->names, CIL_NAME, name);\n\n\treturn name;\n}\n\nstatic int __cil_resolve_perms(symtab_t *class_symtab, symtab_t *common_symtab, struct cil_list *perm_strs, struct cil_list **perm_datums, enum cil_flavor class_flavor)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\n\tcil_list_init(perm_datums, perm_strs->flavor);\n\n\tcil_list_for_each(curr, perm_strs) {\n\t\tif (curr->flavor == CIL_LIST) {\n\t\t\tstruct cil_list *sub_list;\n\t\t\trc = __cil_resolve_perms(class_symtab, common_symtab, curr->data, &sub_list, class_flavor);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Failed to resolve permission list\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_append(*perm_datums, CIL_LIST, sub_list);\n\t\t} else if (curr->flavor == CIL_STRING) {\n\t\t\tstruct cil_symtab_datum *perm_datum = NULL;\n\t\t\trc = cil_symtab_get_datum(class_symtab, curr->data, &perm_datum);\n\t\t\tif (rc == SEPOL_ENOENT) {\n\t\t\t\tif (common_symtab) {\n\t\t\t\t\trc = cil_symtab_get_datum(common_symtab, curr->data, &perm_datum);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tif (class_flavor == CIL_MAP_CLASS) {\n\t\t\t\t\tcil_log(CIL_ERR, \"Failed to resolve permission %s for map class\\n\", (char*)curr->data);\n\t\t\t\t} else {\n\t\t\t\t\tcil_log(CIL_ERR, \"Failed to resolve permission %s\\n\", (char*)curr->data);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_append(*perm_datums, CIL_DATUM, perm_datum);\n\t\t} else {\n\t\t\tcil_list_append(*perm_datums, curr->flavor, curr->data);\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(perm_datums, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_classperms(struct cil_tree_node *current, struct cil_classperms *cp, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_symtab_datum *datum = NULL;\n\tsymtab_t *common_symtab = NULL;\n\tstruct cil_class *class;\n\n\trc = cil_resolve_name(current, cp->class_str, CIL_SYM_CLASSES, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)datum;\n\n\tif (class->common != NULL) {\n\t\tcommon_symtab = &class->common->perms;\n\t}\n\n\tcp->class = class;\n\n\trc = __cil_resolve_perms(&class->perms, common_symtab, cp->perm_strs, &cp->perms, FLAVOR(datum));\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classperms_set(struct cil_tree_node *current, struct cil_classperms_set *cp_set, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_symtab_datum *datum = NULL;\n\n\trc = cil_resolve_name(current, cp_set->set_str, CIL_SYM_CLASSPERMSETS, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tcp_set->set = (struct cil_classpermission*)datum;\n\n\t/* This could be an anonymous classpermission */\n\tif (datum->name == NULL) {\n\t\trc = cil_resolve_classperms_list(current, cp_set->set->classperms, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classperms_list(struct cil_tree_node *current, struct cil_list *cp_list, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\trc = cil_resolve_classperms(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\trc = cil_resolve_classperms_set(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classpermissionset(struct cil_tree_node *current, struct cil_classpermissionset *cps, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\tstruct cil_classpermission *cp;\n\n\trc = cil_resolve_name(current, cps->set_str, CIL_SYM_CLASSPERMSETS, args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_classperms_list(current, cps->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcp = (struct cil_classpermission *)datum;\n\n\tif (cp->classperms == NULL) {\n\t\tcil_list_init(&cp->classperms, CIL_CLASSPERMS);\n\t}\n\n\tcil_list_for_each(curr, cps->classperms) {\n\t\tcil_list_append(cp->classperms, curr->flavor, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_type_used(struct cil_symtab_datum *datum, int used)\n{\n\tstruct cil_typeattribute *attr = NULL;\n\n\tif (FLAVOR(datum) == CIL_TYPEATTRIBUTE) {\n\t\tattr = (struct cil_typeattribute*)datum;\n\t\tattr->used |= used;\n\t\tif ((attr->used & CIL_ATTR_EXPAND_TRUE) &&\n\t\t\t\t(attr->used & CIL_ATTR_EXPAND_FALSE)) {\n\t\t\tcil_log(CIL_WARN, \"Conflicting use of expandtypeattribute. \"\n\t\t\t\t\t\"Expandtypeattribute was set to both true or false for %s. \"\n\t\t\t\t\t\"Resolving to false. \\n\", attr->datum.name);\n\t\t\tattr->used &= ~CIL_ATTR_EXPAND_TRUE;\n\t\t}\n\t}\n}\n\nint cil_resolve_permissionx(struct cil_tree_node *current, struct cil_permissionx *permx, void *extra_args)\n{\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, permx->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tpermx->obj = (struct cil_class*)obj_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_avrule(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\n\tstruct cil_avrule *rule = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *permx_datum = NULL;\n\tint used;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, rule->src_str, CIL_SYM_TYPES, args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->src = src_datum;\n\t\t\n\tif (rule->tgt_str == CIL_KEY_SELF) {\n\t\trule->tgt = db->selftype;\n\t} else {\n\t\trc = cil_resolve_name(current, rule->tgt_str, CIL_SYM_TYPES, args, &tgt_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trule->tgt = tgt_datum;\n\t\tused = (rule->rule_kind == CIL_AVRULE_NEVERALLOW) ?\n\t\t\tCIL_ATTR_NEVERALLOW : CIL_ATTR_AVRULE;\n\t\tcil_type_used(src_datum, used); /* src not used if tgt is self */\n\t\tcil_type_used(tgt_datum, used);\n\t}\n\n\tif (!rule->is_extended) {\n\t\trc = cil_resolve_classperms_list(current, rule->perms.classperms, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tif (rule->perms.x.permx_str != NULL) {\n\t\t\trc = cil_resolve_name(current, rule->perms.x.permx_str, CIL_SYM_PERMX, args, &permx_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trule->perms.x.permx = (struct cil_permissionx*)permx_datum;\n\t\t} else {\n\t\t\trc = cil_resolve_permissionx(current, rule->perms.x.permx, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_type_rule(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_type_rule *rule = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *result_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, rule->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->src = src_datum;\n\n\trc = cil_resolve_name(current, rule->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, rule->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->obj = (struct cil_class*)obj_datum;\n\n\trc = cil_resolve_name(current, rule->result_str, CIL_SYM_TYPES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult_node = NODE(result_datum);\n\n\tif (result_node->flavor != CIL_TYPE) {\n\t\tcil_log(CIL_ERR, \"Type rule result must be a type [%d]\\n\",result_node->flavor);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\trule->result = result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_typeattributeset(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_typeattributeset *attrtypes = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_typeattribute *attr = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, attrtypes->attr_str, CIL_SYM_TYPES, extra_args, &attr_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tattr_node = NODE(attr_datum);\n\n\tif (attr_node->flavor != CIL_TYPEATTRIBUTE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Attribute type not an attribute\\n\");\n\t\tgoto exit;\n\t}\n\n\tattr = (struct cil_typeattribute*)attr_datum;\n\n\trc = cil_resolve_expr(CIL_TYPEATTRIBUTESET, attrtypes->str_expr, &attrtypes->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference(attr_datum, attrtypes->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (attr->expr_list == NULL) {\n\t\tcil_list_init(&attr->expr_list, CIL_TYPEATTRIBUTE);\n\t}\n\n\tcil_list_append(attr->expr_list, CIL_LIST, attrtypes->datum_expr);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_expandtypeattribute(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_expandtypeattribute *expandattr = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_list_item *curr;\n\tint used;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&expandattr->attr_datums, CIL_TYPE);\n\n\tcil_list_for_each(curr, expandattr->attr_strs) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_TYPES, extra_args, &attr_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\tattr_node = NODE(attr_datum);\n\n\t\tif (attr_node->flavor != CIL_TYPEATTRIBUTE) {\n\t\t\trc = SEPOL_ERR;\n\t\t\tcil_log(CIL_ERR, \"Attribute type not an attribute\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tused = expandattr->expand ? CIL_ATTR_EXPAND_TRUE : CIL_ATTR_EXPAND_FALSE;\n\t\tcil_type_used(attr_datum, used);\n\t\tcil_list_append(expandattr->attr_datums, CIL_TYPE, attr_datum);\n\t}\n\n\treturn SEPOL_OK;\nexit:\n\treturn rc;\n}\n\nint cil_resolve_aliasactual(struct cil_tree_node *current, void *extra_args, enum cil_flavor flavor, enum cil_flavor alias_flavor)\n{\n\tint rc = SEPOL_ERR;\n\tenum cil_sym_index sym_index;\n\tstruct cil_aliasactual *aliasactual = current->data;\n\tstruct cil_symtab_datum *alias_datum = NULL;\n\tstruct cil_symtab_datum *actual_datum = NULL;\n\tstruct cil_alias *alias;\n\n\trc = cil_flavor_to_symtab_index(flavor, &sym_index);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name_keep_aliases(current, aliasactual->alias_str, sym_index, extra_args, &alias_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (FLAVOR(alias_datum) != alias_flavor) {\n\t\tcil_log(CIL_ERR, \"%s is not an alias\\n\",alias_datum->name);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, aliasactual->actual_str, sym_index, extra_args, &actual_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (FLAVOR(actual_datum) != flavor && FLAVOR(actual_datum) != alias_flavor) {\n\t\tcil_log(CIL_ERR, \"%s is a %s, but aliases a %s\\n\", alias_datum->name, cil_node_to_string(NODE(alias_datum)), cil_node_to_string(NODE(actual_datum)));\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\talias = (struct cil_alias *)alias_datum;\n\n\tif (alias->actual != NULL) {\n\t\tcil_log(CIL_ERR, \"%s %s cannot bind more than one value\\n\", cil_node_to_string(NODE(alias_datum)), alias_datum->name);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\talias->actual = actual_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_alias_to_actual(struct cil_tree_node *current, enum cil_flavor flavor)\n{\n\tstruct cil_alias *alias = current->data;\n\tstruct cil_alias *a1 = current->data;\n\tstruct cil_alias *a2 = current->data;\n\tstruct cil_tree_node *a1_node = NULL;\n\tint steps = 0;\n\tint limit = 2;\n\n\tif (alias->actual == NULL) {\n\t\tcil_tree_log(current, CIL_ERR, \"Alias declared but not used\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\ta1_node = a1->datum.nodes->head->data;\n\n\twhile (flavor != a1_node->flavor) {\n\t\tif (a1->actual == NULL) {\n\t\t\tcil_tree_log(current, CIL_ERR, \"Alias %s references an unused alias %s\", alias->datum.name, a1->datum.name);\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t\ta1 = a1->actual;\n\t\ta1_node = a1->datum.nodes->head->data;\n\t\tsteps += 1;\n\n\t\tif (a1 == a2) {\n\t\t\tcil_log(CIL_ERR, \"Circular alias found: %s \", a1->datum.name);\n\t\t\ta1 = a1->actual;\n\t\t\twhile (a1 != a2) {\n\t\t\t\tcil_log(CIL_ERR, \"%s \", a1->datum.name);\n\t\t\t\ta1 = a1->actual;\n\t\t\t}\n\t\t\tcil_log(CIL_ERR,\"\\n\");\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\n\t\tif (steps == limit) {\n\t\t\tsteps = 0;\n\t\t\tlimit *= 2;\n\t\t\ta2 = a1;\n\t\t}\n\t}\n\n\talias->actual = a1;\n\n\treturn SEPOL_OK;\n}\n\nint cil_resolve_typepermissive(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_typepermissive *typeperm = current->data;\n\tstruct cil_symtab_datum *type_datum = NULL;\n\tstruct cil_tree_node *type_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, typeperm->type_str, CIL_SYM_TYPES, extra_args, &type_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\ttype_node = NODE(type_datum);\n\n\tif (type_node->flavor != CIL_TYPE && type_node->flavor != CIL_TYPEALIAS) {\n\t\tcil_log(CIL_ERR, \"Typepermissive must be a type or type alias\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\ttypeperm->type = type_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_nametypetransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_nametypetransition *nametypetrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *name_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *result_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, nametypetrans->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->src = src_datum;\n\n\trc = cil_resolve_name(current, nametypetrans->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, nametypetrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->obj = (struct cil_class*)obj_datum;\n\n\tnametypetrans->name = __cil_insert_name(args->db, nametypetrans->name_str, current);\n\tif (nametypetrans->name == NULL) {\n\t\trc = cil_resolve_name(current, nametypetrans->name_str, CIL_SYM_NAMES, extra_args, &name_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnametypetrans->name = (struct cil_name *)name_datum;\n\t}\n\n\trc = cil_resolve_name(current, nametypetrans->result_str, CIL_SYM_TYPES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult_node = NODE(result_datum);\n\n\tif (result_node->flavor != CIL_TYPE && result_node->flavor != CIL_TYPEALIAS) {\n\t\tcil_log(CIL_ERR, \"typetransition result is not a type or type alias\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\tnametypetrans->result = result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_rangetransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_rangetransition *rangetrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *exec_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *range_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, rangetrans->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trangetrans->src = src_datum;\n\n\trc = cil_resolve_name(current, rangetrans->exec_str, CIL_SYM_TYPES, extra_args, &exec_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trangetrans->exec = exec_datum;\n\n\trc = cil_resolve_name(current, rangetrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trangetrans->obj = (struct cil_class*)obj_datum;\n\n\tif (rangetrans->range_str != NULL) {\n\t\trc = cil_resolve_name(current, rangetrans->range_str, CIL_SYM_LEVELRANGES, extra_args, &range_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trangetrans->range = (struct cil_levelrange*)range_datum;\n\n\t\t/* This could still be an anonymous levelrange even if range_str is set, if range_str is a param_str*/\n\t\tif (rangetrans->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, rangetrans->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = cil_resolve_levelrange(current, rangetrans->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint __class_update_perm_values(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_perm *perm = (struct cil_perm *)d;\n\n\tperm->value += *((int *)args);\n\n\treturn SEPOL_OK;\n}\n\nint cil_resolve_classcommon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_class *class = NULL;\n\tstruct cil_class *common = NULL;\n\tstruct cil_classcommon *clscom = current->data;\n\tstruct cil_symtab_datum *class_datum = NULL;\n\tstruct cil_symtab_datum *common_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, clscom->class_str, CIL_SYM_CLASSES, extra_args, &class_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, clscom->common_str, CIL_SYM_COMMONS, extra_args, &common_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)class_datum;\n\tcommon = (struct cil_class *)common_datum;\n\tif (class->common != NULL) {\n\t\tcil_log(CIL_ERR, \"class cannot be associeated with more than one common\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tclass->common = common;\n\n\tcil_symtab_map(&class->perms, __class_update_perm_values, &common->num_perms);\n\n\tclass->num_perms += common->num_perms;\n\tif (class->num_perms > CIL_PERMS_PER_CLASS) {\n\t\tcil_tree_log(current, CIL_ERR, \"Too many permissions in class '%s' when including common permissions\", class->datum.name);\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classmapping(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_classmapping *mapping = current->data;\n\tstruct cil_class *map = NULL;\n\tstruct cil_perm *mp = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_list_item *curr;\n\n\trc = cil_resolve_name(current, mapping->map_class_str, CIL_SYM_CLASSES, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tmap = (struct cil_class*)datum;\n\n\trc = cil_symtab_get_datum(&map->perms, mapping->map_perm_str, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tmp = (struct cil_perm*)datum;\n\n\trc = cil_resolve_classperms_list(current, mapping->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (mp->classperms == NULL) {\n\t\tcil_list_init(&mp->classperms, CIL_CLASSPERMS);\n\t}\n\n\tcil_list_for_each(curr, mapping->classperms) {\n\t\tcil_list_append(mp->classperms, curr->flavor, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userrole(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userrole *userrole = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *role_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, userrole->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tuserrole->user = (struct cil_user*)user_datum;\n\n\trc = cil_resolve_name(current, userrole->role_str, CIL_SYM_ROLES, extra_args, &role_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tuserrole->role = role_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userlevel(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userlevel *usrlvl = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *lvl_datum = NULL;\n\tstruct cil_user *user = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, usrlvl->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Userlevel must be a user\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tuser = (struct cil_user*)user_datum;\n\n\tif (usrlvl->level_str != NULL) {\n\t\trc = cil_resolve_name(current, usrlvl->level_str, CIL_SYM_LEVELS, extra_args, &lvl_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tusrlvl->level = (struct cil_level*)lvl_datum;\n\t\tuser->dftlevel = usrlvl->level;\n\n\t\t/* This could still be an anonymous level even if level_str is set, if level_str is a param_str*/\n\t\tif (user->dftlevel->datum.name == NULL) {\n\t\t\trc = cil_resolve_level(current, user->dftlevel, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (usrlvl->level != NULL) {\n\t\trc = cil_resolve_level(current, usrlvl->level, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tuser->dftlevel = usrlvl->level;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userrange(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userrange *userrange = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *range_datum = NULL;\n\tstruct cil_user *user = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, userrange->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Userrange must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tuser = (struct cil_user*)user_datum;\n\n\tif (userrange->range_str != NULL) {\n\t\trc = cil_resolve_name(current, userrange->range_str, CIL_SYM_LEVELRANGES, extra_args, &range_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tuserrange->range = (struct cil_levelrange*)range_datum;\n\t\tuser->range = userrange->range;\n\n\t\t/* This could still be an anonymous levelrange even if levelrange_str is set, if levelrange_str is a param_str*/\n\t\tif (user->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, user->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (userrange->range != NULL) {\n\t\trc = cil_resolve_levelrange(current, userrange->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tuser->range = userrange->range;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userprefix(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_userprefix *userprefix = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, userprefix->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Userprefix must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tuserprefix->user = (struct cil_user*)user_datum;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_selinuxuser(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_selinuxuser *selinuxuser = current->data;\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *lvlrange_datum = NULL;\n\tstruct cil_tree_node *user_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, selinuxuser->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tuser_node = NODE(user_datum);\n\n\tif (user_node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Selinuxuser must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tselinuxuser->user = (struct cil_user*)user_datum;\n\n\tif (selinuxuser->range_str != NULL) {\n\t\trc = cil_resolve_name(current, selinuxuser->range_str, CIL_SYM_LEVELRANGES, extra_args, &lvlrange_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tselinuxuser->range = (struct cil_levelrange*)lvlrange_datum;\n\n\t\t/* This could still be an anonymous levelrange even if range_str is set, if range_str is a param_str*/\n\t\tif (selinuxuser->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, selinuxuser->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (selinuxuser->range != NULL) {\n\t\trc = cil_resolve_levelrange(current, selinuxuser->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roletype(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_roletype *roletype = current->data;\n\tstruct cil_symtab_datum *role_datum = NULL;\n\tstruct cil_symtab_datum *type_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, roletype->role_str, CIL_SYM_ROLES, extra_args, &role_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletype->role = (struct cil_role*)role_datum;\n\n\trc = cil_resolve_name(current, roletype->type_str, CIL_SYM_TYPES, extra_args, &type_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletype->type = (struct cil_type*)type_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roletransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_roletransition *roletrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, roletrans->src_str, CIL_SYM_ROLES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletrans->src = (struct cil_role*)src_datum;\n\n\trc = cil_resolve_name(current, roletrans->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletrans->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, roletrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troletrans->obj = (struct cil_class*)obj_datum;\n\n\trc = cil_resolve_name(current, roletrans->result_str, CIL_SYM_ROLES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnode = NODE(result_datum);\n\tif (node->flavor != CIL_ROLE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"roletransition must result in a role, but %s is a %s\\n\", roletrans->result_str, cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\troletrans->result = (struct cil_role*)result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roleallow(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_roleallow *roleallow = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, roleallow->src_str, CIL_SYM_ROLES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troleallow->src = (struct cil_role*)src_datum;\n\n\trc = cil_resolve_name(current, roleallow->tgt_str, CIL_SYM_ROLES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\troleallow->tgt = (struct cil_role*)tgt_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_roleattributeset(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_roleattributeset *attrroles = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_roleattribute *attr = NULL;\n\n\trc = cil_resolve_name(current, attrroles->attr_str, CIL_SYM_ROLES, extra_args, &attr_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tattr_node = NODE(attr_datum);\n\n\tif (attr_node->flavor != CIL_ROLEATTRIBUTE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Attribute role not an attribute\\n\");\n\t\tgoto exit;\n\t}\n\tattr = (struct cil_roleattribute*)attr_datum;\n\n\trc = cil_resolve_expr(CIL_ROLEATTRIBUTESET, attrroles->str_expr, &attrroles->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference(attr_datum, attrroles->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (attr->expr_list == NULL) {\n\t\tcil_list_init(&attr->expr_list, CIL_ROLEATTRIBUTE);\n\t}\n\n\tcil_list_append(attr->expr_list, CIL_LIST, attrroles->datum_expr);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstruct cil_ordered_list {\n\tint merged;\n\tstruct cil_list *list;\n\tstruct cil_tree_node *node;\n};\n\nvoid __cil_ordered_list_init(struct cil_ordered_list **ordered)\n{\n\t*ordered = cil_malloc(sizeof(**ordered));\n\n\t(*ordered)->merged = CIL_FALSE;\n\t(*ordered)->list = NULL;\n\t(*ordered)->node = NULL;\n}\n\nvoid __cil_ordered_list_destroy(struct cil_ordered_list **ordered)\n{\n\tcil_list_destroy(&(*ordered)->list, CIL_FALSE);\n\t(*ordered)->node = NULL;\n\tfree(*ordered);\n\t*ordered = NULL;\n}\n\nvoid __cil_ordered_lists_destroy(struct cil_list **ordered_lists)\n{\n\tstruct cil_list_item *item = NULL;\n\n\tif (ordered_lists == NULL || *ordered_lists == NULL) {\n\t\treturn;\n\t}\n\n\titem = (*ordered_lists)->head;\n\twhile (item != NULL) {\n\t\tstruct cil_list_item *next = item->next;\n\t\tstruct cil_ordered_list *ordered = item->data;\n\t\t__cil_ordered_list_destroy(&ordered);\n\t\tfree(item);\n\t\titem = next;\n\t}\n\tfree(*ordered_lists);\n\t*ordered_lists = NULL;\n}\n\nvoid __cil_ordered_lists_reset(struct cil_list **ordered_lists)\n{\n\t__cil_ordered_lists_destroy(ordered_lists);\n\tcil_list_init(ordered_lists, CIL_LIST_ITEM);\n}\n\nstruct cil_list_item *__cil_ordered_item_insert(struct cil_list *old, struct cil_list_item *curr, struct cil_list_item *item)\n{\n\tif (item->flavor == CIL_SID) {\n\t\tstruct cil_sid *sid = item->data;\n\t\tif (sid->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"SID %s has already been merged into the ordered list\\n\", sid->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsid->ordered = CIL_TRUE;\n\t} else if (item->flavor == CIL_CLASS) {\n\t\tstruct cil_class *class = item->data;\n\t\tif (class->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"Class %s has already been merged into the ordered list\\n\", class->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tclass->ordered = CIL_TRUE;\n\t} else if (item->flavor == CIL_CAT) {\n\t\tstruct cil_cat *cat = item->data;\n\t\tif (cat->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"Category %s has already been merged into the ordered list\\n\", cat->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tcat->ordered = CIL_TRUE;\n\t} else if (item->flavor == CIL_SENS) {\n\t\tstruct cil_sens *sens = item->data;\n\t\tif (sens->ordered == CIL_TRUE) {\n\t\t\tcil_log(CIL_ERR, \"Sensitivity %s has already been merged into the ordered list\\n\", sens->datum.name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsens->ordered = CIL_TRUE;\n\t}\n\n\treturn cil_list_insert(old, curr, item->flavor, item->data);\n}\n\nint __cil_ordered_list_insert(struct cil_list *old, struct cil_list_item *ocurr, struct cil_list_item *nstart, struct cil_list_item *nstop)\n{\n\tstruct cil_list_item *ncurr = NULL;\n\n\tfor (ncurr = nstart; ncurr != nstop; ncurr = ncurr->next) {\n\t\tocurr = __cil_ordered_item_insert(old, ocurr, ncurr);\n\t\tif (ocurr == NULL) {\n\t\t\treturn SEPOL_ERR;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n}\n\nstruct cil_list_item *__cil_ordered_find_match(struct cil_list_item *t, struct cil_list_item *i)\n{\n\twhile (i) {\n\t\tif (i->data == t->data) {\n\t\t\treturn i;\n\t\t}\n\t\ti = i->next;\n\t}\n\treturn NULL;\n}\n\nint __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nstatic int insert_unordered(struct cil_list *merged, struct cil_list *unordered)\n{\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_ordered_list *unordered_list = NULL;\n\tstruct cil_list_item *item = NULL;\n\tstruct cil_list_item *ret = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_for_each(curr, unordered) {\n\t\tunordered_list = curr->data;\n\n\t\tcil_list_for_each(item, unordered_list->list) {\n\t\t\tif (cil_list_contains(merged, item->data)) {\n\t\t\t\t/* item was declared in an ordered statement, which supersedes\n\t\t\t\t * all unordered statements */\n\t\t\t\tif (item->flavor == CIL_CLASS) {\n\t\t\t\t\tcil_log(CIL_WARN, \"Ignoring '%s' as it has already been declared in classorder.\\n\", ((struct cil_class*)(item->data))->datum.name);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = __cil_ordered_item_insert(merged, merged->tail, item);\n\t\t\tif (ret == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstruct cil_list *__cil_ordered_lists_merge_all(struct cil_list **ordered_lists, struct cil_list **unordered_lists)\n{\n\tstruct cil_list *composite = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tint changed = CIL_TRUE;\n\tint waiting = 1;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&composite, CIL_LIST_ITEM);\n\n\twhile (waiting && changed == CIL_TRUE) {\n\t\tchanged = CIL_FALSE;\n\t\twaiting = 0;\n\t\tcil_list_for_each(curr, *ordered_lists) {\n\t\t\tstruct cil_ordered_list *ordered_list = curr->data;\n\t\t\tif (ordered_list->merged == CIL_FALSE) {\n\t\t\t\trc = __cil_ordered_lists_merge(composite, ordered_list->list);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t/* Can't merge yet */\n\t\t\t\t\twaiting++;\n\t\t\t\t} else {\n\t\t\t\t\tordered_list->merged = CIL_TRUE;\n\t\t\t\t\tchanged = CIL_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (waiting > 0 && changed == CIL_FALSE) {\n\t\t\tcil_list_for_each(curr, *ordered_lists) {\n\t\t\t\tstruct cil_ordered_list *ordered_list = curr->data;\n\t\t\t\tif (ordered_list->merged == CIL_FALSE) {\n\t\t\t\t\tcil_tree_log(ordered_list->node, CIL_ERR, \"Unable to merge ordered list\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (unordered_lists != NULL) {\n\t\trc = insert_unordered(composite, *unordered_lists);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t__cil_ordered_lists_destroy(ordered_lists);\n\t__cil_ordered_lists_destroy(unordered_lists);\n\n\treturn composite;\n\nexit:\n\t__cil_ordered_lists_destroy(ordered_lists);\n\t__cil_ordered_lists_destroy(unordered_lists);\n\tcil_list_destroy(&composite, CIL_FALSE);\n\treturn NULL;\n}\n\nint cil_resolve_classorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *classorder_list = args->classorder_lists;\n\tstruct cil_list *unordered_classorder_list = args->unordered_classorder_lists;\n\tstruct cil_classorder *classorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *class_list = NULL;\n\tint rc = SEPOL_ERR;\n\tint unordered = CIL_FALSE;\n\n\tcil_list_init(&new, CIL_CLASSORDER);\n\n\tcil_list_for_each(curr, classorder->class_list_str) {\n\t\tif (curr->data == CIL_KEY_UNORDERED) {\n\t\t\tunordered = CIL_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve class %s in classorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_CLASS, datum);\n\t}\n\n\t__cil_ordered_list_init(&class_list);\n\tclass_list->list = new;\n\tclass_list->node = current;\n\tif (unordered) {\n\t\tcil_list_append(unordered_classorder_list, CIL_CLASSORDER, class_list);\n\t} else {\n\t\tcil_list_append(classorder_list, CIL_CLASSORDER, class_list);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_sidorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *sidorder_list = args->sidorder_lists;\n\tstruct cil_sidorder *sidorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *ordered = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&new, CIL_SIDORDER);\n\n\tcil_list_for_each(curr, sidorder->sid_list_str) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_SIDS, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve sid %s in sidorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_SID, datum);\n\t}\n\n\t__cil_ordered_list_init(&ordered);\n\tordered->list = new;\n\tordered->node = current;\n\tcil_list_append(sidorder_list, CIL_SIDORDER, ordered);\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nvoid cil_set_cat_values(struct cil_list *ordered_cats, struct cil_db *db)\n{\n\tstruct cil_list_item *curr;\n\tint v = 0;\n\n\tcil_list_for_each(curr, ordered_cats) {\n\t\tstruct cil_cat *cat = curr->data;\n\t\tcat->value = v;\n\t\tv++;\n\t}\n\n\tdb->num_cats = v;\n}\n\nint cil_resolve_catorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *catorder_list = args->catorder_lists;\n\tstruct cil_catorder *catorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *cat_datum;\n\tstruct cil_cat *cat = NULL;\n\tstruct cil_ordered_list *ordered = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&new, CIL_CATORDER);\n\n\tcil_list_for_each(curr, catorder->cat_list_str) {\n\t\tstruct cil_tree_node *node = NULL;\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CATS, extra_args, &cat_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve category %s in categoryorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tnode = NODE(cat_datum);\n\t\tif (node->flavor != CIL_CAT) {\n\t\t\tcil_log(CIL_ERR, \"%s is not a category. Only categories are allowed in categoryorder statements\\n\", cat_datum->name);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t\tcat = (struct cil_cat *)cat_datum;\n\t\tcil_list_append(new, CIL_CAT, cat);\n\t}\n\n\t__cil_ordered_list_init(&ordered);\n\tordered->list = new;\n\tordered->node = current;\n\tcil_list_append(catorder_list, CIL_CATORDER, ordered);\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_sensitivityorder(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *sensitivityorder_list = args->sensitivityorder_lists;\n\tstruct cil_sensorder *sensorder = current->data;\n\tstruct cil_list *new = NULL;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_symtab_datum *datum = NULL;\n\tstruct cil_ordered_list *ordered = NULL;\n\tint rc = SEPOL_ERR;\n\n\tcil_list_init(&new, CIL_LIST_ITEM);\n\n\tcil_list_for_each(curr, sensorder->sens_list_str) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_SENS, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to resolve sensitivty %s in sensitivityorder\\n\", (char *)curr->data);\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(new, CIL_SENS, datum);\n\t}\n\n\t__cil_ordered_list_init(&ordered);\n\tordered->list = new;\n\tordered->node = current;\n\tcil_list_append(sensitivityorder_list, CIL_SENSITIVITYORDER, ordered);\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_list_destroy(&new, CIL_FALSE);\n\treturn rc;\n}\n\nint cil_resolve_cats(struct cil_tree_node *current, struct cil_cats *cats, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_expr(CIL_CATSET, cats->str_expr, &cats->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\t\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\nint cil_resolve_catset(struct cil_tree_node *current, struct cil_catset *catset, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_cats(current, catset->cats, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference((struct cil_symtab_datum *)catset, catset->cats->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tcil_list_destroy(&catset->cats->datum_expr, CIL_FALSE);\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_senscat(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_senscat *senscat = current->data;\n\tstruct cil_symtab_datum *sens_datum;\n\tstruct cil_sens *sens = NULL;\n\n\trc = cil_resolve_name(current, (char*)senscat->sens_str, CIL_SYM_SENS, extra_args, &sens_datum);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to find sensitivity\\n\");\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_cats(current, senscat->cats, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tsens = (struct cil_sens *)sens_datum;\n\n\tif (sens->cats_list == NULL ) {\n\t\tcil_list_init(&sens->cats_list, CIL_CAT);\n\t}\n\n\tcil_list_append(sens->cats_list, CIL_CAT, senscat->cats);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_level(struct cil_tree_node *current, struct cil_level *level, void *extra_args)\n{\n\tstruct cil_symtab_datum *sens_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, (char*)level->sens_str, CIL_SYM_SENS, extra_args, &sens_datum);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to find sensitivity\\n\");\n\t\tgoto exit;\n\t}\n\n\tlevel->sens = (struct cil_sens *)sens_datum;\n\n\tif (level->cats != NULL) {\n\t\trc = cil_resolve_cats(current, level->cats, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_levelrange(struct cil_tree_node *current, struct cil_levelrange *lvlrange, void *extra_args)\n{\n\tstruct cil_symtab_datum *low_datum = NULL;\n\tstruct cil_symtab_datum *high_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (lvlrange->low_str != NULL) {\n\t\trc = cil_resolve_name(current, lvlrange->low_str, CIL_SYM_LEVELS, extra_args, &low_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tlvlrange->low = (struct cil_level*)low_datum;\n\n\t\t/* This could still be an anonymous level even if low_str is set, if low_str is a param_str */\n\t\tif (lvlrange->low->datum.name == NULL) {\n\t\t\trc = cil_resolve_level(current, lvlrange->low, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (lvlrange->low != NULL) {\n\t\trc = cil_resolve_level(current, lvlrange->low, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (lvlrange->high_str != NULL) {\n\t\trc = cil_resolve_name(current, lvlrange->high_str, CIL_SYM_LEVELS, extra_args, &high_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tlvlrange->high = (struct cil_level*)high_datum;\n\n\t\t/* This could still be an anonymous level even if high_str is set, if high_str is a param_str */\n\t\tif (lvlrange->high->datum.name == NULL) {\n\t\t\trc = cil_resolve_level(current, lvlrange->high, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (lvlrange->high != NULL) {\n\t\trc = cil_resolve_level(current, lvlrange->high, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_constrain(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_constrain *cons = current->data;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_classperms_list(current, cons->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_expr(CIL_CONSTRAIN, cons->str_expr, &cons->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_validatetrans(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_validatetrans *validtrans = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_symtab_datum *class_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, validtrans->class_str, CIL_SYM_CLASSES, args, &class_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tvalidtrans->class = (struct cil_class*)class_datum;\n\n\trc = cil_resolve_expr(CIL_VALIDATETRANS, validtrans->str_expr, &validtrans->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_context(struct cil_tree_node *current, struct cil_context *context, void *extra_args)\n{\n\tstruct cil_symtab_datum *user_datum = NULL;\n\tstruct cil_symtab_datum *role_datum = NULL;\n\tstruct cil_symtab_datum *type_datum = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tstruct cil_symtab_datum *lvlrange_datum = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, context->user_str, CIL_SYM_USERS, extra_args, &user_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(user_datum);\n\n\tif (node->flavor != CIL_USER) {\n\t\tcil_log(CIL_ERR, \"Context user must be a user: %s\\n\", user_datum->fqn);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tcontext->user = (struct cil_user*)user_datum;\n\n\trc = cil_resolve_name(current, context->role_str, CIL_SYM_ROLES, extra_args, &role_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(role_datum);\n\tif (node->flavor != CIL_ROLE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Context role not a role: %s\\n\", role_datum->fqn);\n\t\tgoto exit;\n\t}\n\n\tcontext->role = (struct cil_role*)role_datum;\n\n\trc = cil_resolve_name(current, context->type_str, CIL_SYM_TYPES, extra_args, &type_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(type_datum);\n\n\tif (node->flavor != CIL_TYPE && node->flavor != CIL_TYPEALIAS) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Type not a type or type alias\\n\");\n\t\tgoto exit;\n\t}\n\tcontext->type = type_datum;\n\n\tif (context->range_str != NULL) {\n\t\trc = cil_resolve_name(current, context->range_str, CIL_SYM_LEVELRANGES, extra_args, &lvlrange_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcontext->range = (struct cil_levelrange*)lvlrange_datum;\n\n\t\t/* This could still be an anonymous levelrange even if levelrange_str is set, if levelrange_str is a param_str*/\n\t\tif (context->range->datum.name == NULL) {\n\t\t\trc = cil_resolve_levelrange(current, context->range, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else if (context->range != NULL) {\n\t\trc = cil_resolve_levelrange(current, context->range, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_filecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_filecon *filecon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (filecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, filecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t\tfilecon->context = (struct cil_context*)context_datum;\n\t} else if (filecon->context != NULL) {\n\t\trc = cil_resolve_context(current, filecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_resolve_ibpkeycon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_ibpkeycon *ibpkeycon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (ibpkeycon->context_str) {\n\t\trc = cil_resolve_name(current, ibpkeycon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\n\t\tibpkeycon->context = (struct cil_context *)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, ibpkeycon->context, extra_args);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_portcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_portcon *portcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (portcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, portcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tportcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, portcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_genfscon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_genfscon *genfscon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (genfscon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, genfscon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tgenfscon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, genfscon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_nodecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_nodecon *nodecon = current->data;\n\tstruct cil_symtab_datum *addr_datum = NULL;\n\tstruct cil_symtab_datum *mask_datum = NULL;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nodecon->addr_str != NULL) {\n\t\trc = cil_resolve_name(current, nodecon->addr_str, CIL_SYM_IPADDRS, extra_args, &addr_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnodecon->addr = (struct cil_ipaddr*)addr_datum;\n\t}\n\n\tif (nodecon->mask_str != NULL) {\n\t\trc = cil_resolve_name(current, nodecon->mask_str, CIL_SYM_IPADDRS, extra_args, &mask_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnodecon->mask = (struct cil_ipaddr*)mask_datum;\n\t}\n\n\tif (nodecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, nodecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnodecon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, nodecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (nodecon->addr->family != nodecon->mask->family) {\n\t\tcil_log(CIL_ERR, \"Nodecon ip address not in the same family\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_netifcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_netifcon *netifcon = current->data;\n\tstruct cil_symtab_datum *ifcon_datum = NULL;\n\tstruct cil_symtab_datum *packcon_datum = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\tif (netifcon->if_context_str != NULL) {\n\t\trc = cil_resolve_name(current, netifcon->if_context_str, CIL_SYM_CONTEXTS, extra_args, &ifcon_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnetifcon->if_context = (struct cil_context*)ifcon_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, netifcon->if_context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (netifcon->packet_context_str != NULL) {\n\t\trc = cil_resolve_name(current, netifcon->packet_context_str, CIL_SYM_CONTEXTS, extra_args, &packcon_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnetifcon->packet_context = (struct cil_context*)packcon_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, netifcon->packet_context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_ibendportcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_ibendportcon *ibendportcon = current->data;\n\tstruct cil_symtab_datum *con_datum = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\tif (ibendportcon->context_str) {\n\t\trc = cil_resolve_name(current, ibendportcon->context_str, CIL_SYM_CONTEXTS, extra_args, &con_datum);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\n\t\tibendportcon->context = (struct cil_context *)con_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, ibendportcon->context, extra_args);\n\t\tif (rc != SEPOL_OK)\n\t\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_pirqcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_pirqcon *pirqcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (pirqcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, pirqcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tpirqcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, pirqcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_iomemcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_iomemcon *iomemcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (iomemcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, iomemcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tiomemcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, iomemcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_ioportcon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_ioportcon *ioportcon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (ioportcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, ioportcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tioportcon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, ioportcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_pcidevicecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_pcidevicecon *pcidevicecon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (pcidevicecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, pcidevicecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tpcidevicecon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, pcidevicecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_devicetreecon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_devicetreecon *devicetreecon = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (devicetreecon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, devicetreecon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tdevicetreecon->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, devicetreecon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_fsuse(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_fsuse *fsuse = current->data;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (fsuse->context_str != NULL) {\n\t\trc = cil_resolve_name(current, fsuse->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tfsuse->context = (struct cil_context*)context_datum;\n\t} else {\n\t\trc = cil_resolve_context(current, fsuse->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_sidcontext(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_sidcontext *sidcon = current->data;\n\tstruct cil_symtab_datum *sid_datum = NULL;\n\tstruct cil_symtab_datum *context_datum = NULL;\n\tstruct cil_sid *sid = NULL;\n\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, sidcon->sid_str, CIL_SYM_SIDS, extra_args, &sid_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tsid = (struct cil_sid*)sid_datum;\n\n\tif (sidcon->context_str != NULL) {\n\t\trc = cil_resolve_name(current, sidcon->context_str, CIL_SYM_CONTEXTS, extra_args, &context_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tsidcon->context = (struct cil_context*)context_datum;\n\t} else if (sidcon->context != NULL) {\n\t\trc = cil_resolve_context(current, sidcon->context, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (sid->context != NULL) {\n\t\tcil_log(CIL_ERR, \"sid's cannot be associated with more than one context\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tsid->context = sidcon->context;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_blockinherit_link(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_blockinherit *inherit = current->data;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, inherit->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tnode = NODE(block_datum);\n\n\tif (node->flavor != CIL_BLOCK) {\n\t\tcil_log(CIL_ERR, \"%s is not a block\\n\", cil_node_to_string(node));\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tinherit->block = (struct cil_block *)block_datum;\n\n\tif (inherit->block->bi_nodes == NULL) {\n\t\tcil_list_init(&inherit->block->bi_nodes, CIL_NODE);\n\t}\n\tcil_list_append(inherit->block->bi_nodes, CIL_NODE, current);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_print_recursive_blockinherit(struct cil_tree_node *bi_node, struct cil_tree_node *terminating_node)\n{\n\tstruct cil_list *trace = NULL;\n\tstruct cil_list_item *item = NULL;\n\tstruct cil_tree_node *curr = NULL;\n\n\tcil_list_init(&trace, CIL_NODE);\n\n\tfor (curr = bi_node; curr != terminating_node; curr = curr->parent) {\n\t\tif (curr->flavor == CIL_BLOCK) {\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t} else if (curr->flavor == CIL_BLOCKINHERIT) {\n\t\t\tif (curr != bi_node) {\n\t\t\t\tcil_list_prepend(trace, CIL_NODE, NODE(((struct cil_blockinherit *)curr->data)->block));\n\t\t\t}\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t} else {\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t}\n\t}\n\tcil_list_prepend(trace, CIL_NODE, terminating_node);\n\n\tcil_list_for_each(item, trace) {\n\t\tcurr = item->data;\n\t\tif (curr->flavor == CIL_BLOCK) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"block %s\", DATUM(curr->data)->name);\n\t\t} else if (curr->flavor == CIL_BLOCKINHERIT) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"blockinherit %s\", ((struct cil_blockinherit *)curr->data)->block_str);\n\t\t} else if (curr->flavor == CIL_OPTIONAL) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"optional %s\", DATUM(curr->data)->name);\n\t\t} else {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"%s\", cil_node_to_string(curr));\n\t\t}\n\t}\n\n\tcil_list_destroy(&trace, CIL_FALSE);\n}\n\nint cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)\n{\n\tstruct cil_tree_node *curr = NULL;\n\tstruct cil_blockinherit *bi = NULL;\n\tstruct cil_block *block = NULL;\n\tint rc = SEPOL_ERR;\n\n\tbi = bi_node->data;\n\n\tfor (curr = bi_node->parent; curr != NULL; curr = curr->parent) {\n\t\tif (curr->flavor != CIL_BLOCK) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock = curr->data;\n\n\t\tif (block != bi->block) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcil_log(CIL_ERR, \"Recursive blockinherit found:\\n\");\n\t\tcil_print_recursive_blockinherit(bi_node, curr);\n\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_blockinherit_copy(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_block *block = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tstruct cil_list_item *item = NULL;\n\tint rc = SEPOL_ERR;\n\n\t// This block is not inherited\n\tif (block->bi_nodes == NULL) {\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tdb = args->db;\n\n\t// Make sure this is the original block and not a merged block from a blockinherit\n\tif (current != block->datum.nodes->head->data) {\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(item, block->bi_nodes) {\n\t\trc = cil_check_recursive_blockinherit(item->data);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\trc = cil_copy_ast(db, current, item->data);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to copy block contents into blockinherit\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_blockabstract(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_blockabstract *abstract = current->data;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *block_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, abstract->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tblock_node = NODE(block_datum);\n\tif (block_node->flavor != CIL_BLOCK) {\n\t\tcil_log(CIL_ERR, \"Failed to resolve blockabstract to a block, rc: %d\\n\", rc);\n\t\tgoto exit;\n\t}\n\n\t((struct cil_block*)block_datum)->is_abstract = CIL_TRUE;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_in(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_in *in = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tstruct cil_tree_node *block_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, in->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tblock_node = NODE(block_datum);\n\n\trc = cil_copy_ast(db, current, block_node);\n\tif (rc != SEPOL_OK) {\n\t\tcil_tree_log(current, CIL_ERR, \"Failed to copy in-statement\");\n\t\tgoto exit;\n\t}\n\n\tcil_tree_children_destroy(current);\n\tcurrent->cl_head = NULL;\n\tcurrent->cl_tail = NULL;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_in_list(void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list *ins = args->in_list;\n\tstruct cil_list_item *curr = NULL;\n\tstruct cil_tree_node *node = NULL;\n\tstruct cil_tree_node *last_failed_node = NULL;\n\tstruct cil_in *in = NULL;\n\tstruct cil_symtab_datum *block_datum = NULL;\n\tint resolved = 0;\n\tint unresolved = 0;\n\tint rc = SEPOL_ERR;\n\n\tdo {\n\t\tresolved = 0;\n\t\tunresolved = 0;\n\n\t\tcil_list_for_each(curr, ins) {\n\t\t\tif (curr->flavor != CIL_NODE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnode = curr->data;\n\t\t\tin = node->data;\n\n\t\t\trc = cil_resolve_name(node, in->block_str, CIL_SYM_BLOCKS, extra_args, &block_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tunresolved++;\n\t\t\t\tlast_failed_node = node;\n\t\t\t} else {\n\t\t\t\trc = cil_resolve_in(node, extra_args);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresolved++;\n\t\t\t\tcurr->data = NULL;\n\t\t\t\tcurr->flavor = CIL_NONE;\n\t\t\t}\n\t\t}\n\n\t\tif (unresolved > 0 && resolved == 0) {\n\t\t\tcil_tree_log(last_failed_node, CIL_ERR, \"Failed to resolve in-statement\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t} while (unresolved > 0);\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\nint cil_resolve_bounds(struct cil_tree_node *current, void *extra_args, enum cil_flavor flavor, enum cil_flavor attr_flavor)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_bounds *bounds = current->data;\n\tenum cil_sym_index index;\n\tstruct cil_symtab_datum *parent_datum = NULL;\n\tstruct cil_symtab_datum *child_datum = NULL;\n\n\trc = cil_flavor_to_symtab_index(flavor, &index);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, bounds->parent_str, index, extra_args, &parent_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (FLAVOR(parent_datum) == attr_flavor) {\n\t\tcil_log(CIL_ERR, \"Bounds parent %s is an attribute\\n\", bounds->parent_str);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\n\trc = cil_resolve_name(current, bounds->child_str, index, extra_args, &child_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tif (FLAVOR(child_datum) == attr_flavor) {\n\t\tcil_log(CIL_ERR, \"Bounds child %s is an attribute\\n\", bounds->child_str);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tswitch (flavor) {\n\tcase CIL_USER: {\n\t\tstruct cil_user *user = (struct cil_user *)child_datum;\n\n\t\tif (user->bounds != NULL) {\n\t\t\tcil_tree_log(NODE(user->bounds), CIL_ERR, \"User %s already bound by parent\", bounds->child_str);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tuser->bounds = (struct cil_user *)parent_datum;\n\t\tbreak;\n\t}\n\tcase CIL_ROLE: {\n\t\tstruct cil_role *role = (struct cil_role *)child_datum;\n\n\t\tif (role->bounds != NULL) {\n\t\t\tcil_tree_log(NODE(role->bounds), CIL_ERR, \"Role %s already bound by parent\", bounds->child_str);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\trole->bounds = (struct cil_role *)parent_datum;\n\t\tbreak;\n\t}\n\tcase CIL_TYPE: {\n\t\tstruct cil_type *type = (struct cil_type *)child_datum;\n\n\t\tif (type->bounds != NULL) {\n\t\t\tcil_tree_log(NODE(type->bounds), CIL_ERR, \"Type %s already bound by parent\", bounds->child_str);\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttype->bounds = (struct cil_type *)parent_datum;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\tcil_tree_log(current, CIL_ERR, \"Bad bounds statement\");\n\treturn rc;\n}\n\nint cil_resolve_default(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_default *def = current->data;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\n\tcil_list_init(&def->class_datums, def->flavor);\n\n\tcil_list_for_each(curr, def->class_strs) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(def->class_datums, CIL_CLASS, datum);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_defaultrange(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_defaultrange *def = current->data;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\n\tcil_list_init(&def->class_datums, CIL_DEFAULTRANGE);\n\n\tcil_list_for_each(curr, def->class_strs) {\n\t\trc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tcil_list_append(def->class_datums, CIL_CLASS, datum);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nvoid cil_print_recursive_call(struct cil_tree_node *call_node, struct cil_tree_node *terminating_node)\n{\n\tstruct cil_list *trace = NULL;\n\tstruct cil_list_item * item = NULL;\n\tstruct cil_tree_node *curr = NULL;\n\n\tcil_list_init(&trace, CIL_NODE);\n\n\tfor (curr = call_node; curr != terminating_node; curr = curr->parent) {\n\t\tif (curr->flavor == CIL_CALL) {\n\t\t\tif (curr != call_node) {\n\t\t\t\tcil_list_prepend(trace, CIL_NODE, NODE(((struct cil_call *)curr->data)->macro));\n\t\t\t}\n\t\t\tcil_list_prepend(trace, CIL_NODE, curr);\n\t\t}\n\t}\n\n\tif (terminating_node->flavor == CIL_MACRO) {\n\t\tcil_list_prepend(trace, CIL_NODE, terminating_node);\n\t} else {\n\t\tcil_list_prepend(trace, CIL_NODE, NODE(((struct cil_call *)terminating_node->data)->macro));\n\t}\n\n\tcil_list_for_each(item, trace) {\n\t\tcurr = item->data;\n\t\tif (curr->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"macro %s\", DATUM(curr->data)->name);\n\t\t} else {\n\t\t\tcil_tree_log(curr, CIL_ERR, \"call %s\", ((struct cil_call *)curr->data)->macro_str);\n\t\t}\n\t}\n\n\tcil_list_destroy(&trace, CIL_FALSE);\n}\n\nint cil_check_recursive_call(struct cil_tree_node *call_node, struct cil_tree_node *macro_node)\n{\n\tstruct cil_tree_node *curr = NULL;\n\tstruct cil_call * call = NULL;\n\tint rc = SEPOL_ERR;\n\n\tfor (curr = call_node; curr != NULL; curr = curr->parent) {\n\t\tif (curr->flavor == CIL_CALL) {\n\t\t\tif (curr == call_node) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcall = curr->data;\n\t\t\tif (call->macro != macro_node->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (curr->flavor == CIL_MACRO) {\n\t\t\tif (curr != macro_node) {\n\t\t\t\trc = SEPOL_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcil_log(CIL_ERR, \"Recursive macro call found:\\n\");\n\t\tcil_print_recursive_call(call_node, curr);\n\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\nexit:\n\treturn rc;\n}\n\nint cil_resolve_call1(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_call *new_call = current->data;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tstruct cil_tree_node *macro_node = NULL;\n\tstruct cil_symtab_datum *macro_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, new_call->macro_str, CIL_SYM_BLOCKS, extra_args, &macro_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tmacro_node = NODE(macro_datum);\n\n\tif (macro_node->flavor != CIL_MACRO) {\n\t\tcil_tree_log(current, CIL_ERR, \"Failed to resolve %s to a macro\", new_call->macro_str);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\tnew_call->macro = (struct cil_macro*)macro_datum;\n\n\tif (new_call->macro->params != NULL ) {\n\n\t\tstruct cil_list_item *item;\n\t\tstruct cil_args *new_arg = NULL;\n\t\tstruct cil_tree_node *pc = NULL;\n\n\t\tif (new_call->args_tree == NULL) {\n\t\t\tcil_tree_log(current, CIL_ERR, \"Missing arguments\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpc = new_call->args_tree->root->cl_head;\n\n\t\tcil_list_init(&new_call->args, CIL_LIST_ITEM);\n\n\t\tcil_list_for_each(item, new_call->macro->params) {\n\t\t\tenum cil_flavor flavor = ((struct cil_param*)item->data)->flavor;\n\n\t\t\tif (pc == NULL) {\n\t\t\t\tcil_tree_log(current, CIL_ERR, \"Missing arguments\");\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (item->flavor != CIL_PARAM) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tcil_args_init(&new_arg);\n\n\t\t\tswitch (flavor) {\n\t\t\tcase CIL_NAME: {\n\t\t\t\tstruct cil_name *name;\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tname = __cil_insert_name(args->db, pc->data, current);\n\t\t\t\tif (name != NULL) {\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum *)name;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CIL_TYPE:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_ROLE:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_USER:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_SENS:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_CAT:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_BOOL:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_CATSET: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_catset *catset = NULL;\n\t\t\t\t\tstruct cil_tree_node *cat_node = NULL;\n\t\t\t\t\tcil_catset_init(&catset);\n\t\t\t\t\trc = cil_fill_cats(pc, &catset->cats);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_destroy_catset(catset);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&cat_node);\n\t\t\t\t\tcat_node->flavor = CIL_CATSET;\n\t\t\t\t\tcat_node->data = catset;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)catset)->nodes,\n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, cat_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)catset;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_LEVEL: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_level *level = NULL;\n\t\t\t\t\tstruct cil_tree_node *lvl_node = NULL;\n\t\t\t\t\tcil_level_init(&level);\n\n\t\t\t\t\trc = cil_fill_level(pc->cl_head, level);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous level, rc: %d\\n\", rc);\n\t\t\t\t\t\tcil_destroy_level(level);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&lvl_node);\n\t\t\t\t\tlvl_node->flavor = CIL_LEVEL;\n\t\t\t\t\tlvl_node->data = level;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)level)->nodes, \n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, lvl_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)level;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_LEVELRANGE: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_levelrange *range = NULL;\n\t\t\t\t\tstruct cil_tree_node *range_node = NULL;\n\t\t\t\t\tcil_levelrange_init(&range);\n\n\t\t\t\t\trc = cil_fill_levelrange(pc->cl_head, range);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous levelrange, rc: %d\\n\", rc);\n\t\t\t\t\t\tcil_destroy_levelrange(range);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&range_node);\n\t\t\t\t\trange_node->flavor = CIL_LEVELRANGE;\n\t\t\t\t\trange_node->data = range;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)range)->nodes, \n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, range_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)range;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_IPADDR: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_ipaddr *ipaddr = NULL;\n\t\t\t\t\tstruct cil_tree_node *addr_node = NULL;\n\t\t\t\t\tcil_ipaddr_init(&ipaddr);\n\n\t\t\t\t\trc = cil_fill_ipaddr(pc->cl_head, ipaddr);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous ip address, rc: %d\\n\", rc);\n\t\t\t\t\t\tcil_destroy_ipaddr(ipaddr);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&addr_node);\n\t\t\t\t\taddr_node->flavor = CIL_IPADDR;\n\t\t\t\t\taddr_node->data = ipaddr;\n\t\t\t\t\tcil_list_append(((struct cil_symtab_datum*)ipaddr)->nodes,\n\t\t\t\t\t\t\t\t\tCIL_LIST_ITEM, addr_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)ipaddr;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CIL_CLASS:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_MAP_CLASS:\n\t\t\t\tif (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\tbreak;\n\t\t\tcase CIL_CLASSPERMISSION: {\n\t\t\t\tif (pc->cl_head != NULL) {\n\t\t\t\t\tstruct cil_classpermission *cp = NULL;\n\t\t\t\t\tstruct cil_tree_node *cp_node = NULL;\n\n\t\t\t\t\tcil_classpermission_init(&cp);\n\t\t\t\t\trc = cil_fill_classperms_list(pc, &cp->classperms);\n\t\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\t\tcil_log(CIL_ERR, \"Failed to create anonymous classpermission\\n\");\n\t\t\t\t\t\tcil_destroy_classpermission(cp);\n\t\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tcil_tree_node_init(&cp_node);\n\t\t\t\t\tcp_node->flavor = CIL_CLASSPERMISSION;\n\t\t\t\t\tcp_node->data = cp;\n\t\t\t\t\tcil_list_append(cp->datum.nodes, CIL_LIST_ITEM, cp_node);\n\t\t\t\t\tnew_arg->arg = (struct cil_symtab_datum*)cp;\n\t\t\t\t} else if (pc->data == NULL) {\n\t\t\t\t\tcil_tree_log(current, CIL_ERR, \"Invalid macro parameter\");\n\t\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t} else {\n\t\t\t\t\tnew_arg->arg_str = pc->data;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tcil_log(CIL_ERR, \"Unexpected flavor: %d\\n\", \n\t\t\t\t\t\t(((struct cil_param*)item->data)->flavor));\n\t\t\t\tcil_destroy_args(new_arg);\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tnew_arg->param_str = ((struct cil_param*)item->data)->str;\n\t\t\tnew_arg->flavor = flavor;\n\n\t\t\tcil_list_append(new_call->args, CIL_ARGS, new_arg);\n\n\t\t\tpc = pc->next;\n\t\t}\n\n\t\tif (pc != NULL) {\n\t\t\tcil_tree_log(current, CIL_ERR, \"Unexpected arguments\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t} else if (new_call->args_tree != NULL) {\n\t\tcil_tree_log(current, CIL_ERR, \"Unexpected arguments\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tif (new_call->copied == 0) {\n\t\tnew_call->copied = 1;\n\n\t\trc = cil_check_recursive_call(current, macro_node);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\n\t\trc = cil_copy_ast(db, macro_node, current);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_ERR, \"Failed to copy macro, rc: %d\\n\", rc);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_call2(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_call *new_call = current->data;\n\tint rc = SEPOL_ERR;\n\tenum cil_sym_index sym_index = CIL_SYM_UNKNOWN;\n\tstruct cil_list_item *item;\n\n\tif (new_call->args == NULL) {\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(item, new_call->args) {\n\t\tstruct cil_args *arg = item->data;\n\t\tif (arg->arg == NULL && arg->arg_str == NULL) {\n\t\t\tcil_log(CIL_ERR, \"Arguments not created correctly\\n\");\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tswitch (arg->flavor) {\n\t\tcase CIL_NAME:\n\t\t\tif (arg->arg != NULL) {\n\t\t\t\tcontinue; /* No need to resolve */\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_NAMES;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_LEVELS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_LEVELRANGES;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_CATSET:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_CATS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_IPADDR:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_IPADDRS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSION:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_CLASSPERMSETS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_TYPE:\n\t\t\tif (arg->arg_str == NULL && arg->arg != NULL) {\n\t\t\t\tcontinue; // anonymous, no need to resolve\n\t\t\t} else {\n\t\t\t\tsym_index = CIL_SYM_TYPES;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIL_ROLE:\n\t\t\tsym_index = CIL_SYM_ROLES;\n\t\t\tbreak;\n\t\tcase CIL_USER:\n\t\t\tsym_index = CIL_SYM_USERS;\n\t\t\tbreak;\n\t\tcase CIL_SENS:\n\t\t\tsym_index = CIL_SYM_SENS;\n\t\t\tbreak;\n\t\tcase CIL_CAT:\n\t\t\tsym_index = CIL_SYM_CATS;\n\t\t\tbreak;\n\t\tcase CIL_CLASS:\n\t\tcase CIL_MAP_CLASS:\n\t\t\tsym_index = CIL_SYM_CLASSES;\n\t\t\tbreak;\n\t\tcase CIL_BOOL:\n\t\t\tsym_index = CIL_SYM_BOOLS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (sym_index != CIL_SYM_UNKNOWN) {\n\t\t\trc = cil_resolve_name(current, arg->arg_str, sym_index, extra_args, &(arg->arg));\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_name_call_args(struct cil_call *call, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tstruct cil_list_item *item;\n\tenum cil_sym_index param_index = CIL_SYM_UNKNOWN;\n\tint rc = SEPOL_ERR;\n\n\tif (call == NULL || name == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (call->args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_list_for_each(item, call->args) {\n\t\tstruct cil_args * arg = item->data;\n\t\trc = cil_flavor_to_symtab_index(arg->flavor, &param_index);\n\t\tif (param_index == sym_index) {\n\t\t\tif (name == arg->param_str) {\n\t\t\t\t*datum = arg->arg;\n\t\t\t\trc = SEPOL_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_ERR;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_expr(enum cil_flavor expr_type, struct cil_list *str_expr, struct cil_list **datum_expr, struct cil_tree_node *parent, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *res_datum = NULL;\n\tenum cil_sym_index sym_index =  CIL_SYM_UNKNOWN;\n\n\tswitch (str_expr->flavor) {\n\tcase CIL_BOOL:\n\t\tsym_index = CIL_SYM_BOOLS;\n\t\tbreak;\n\tcase CIL_TUNABLE:\n\t\tsym_index = CIL_SYM_TUNABLES;\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tsym_index = CIL_SYM_TYPES;\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tsym_index = CIL_SYM_ROLES;\n\t\tbreak;\n\tcase CIL_USER:\n\t\tsym_index = CIL_SYM_USERS;\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tsym_index = CIL_SYM_CATS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcil_list_init(datum_expr, str_expr->flavor);\n\n\tcil_list_for_each(curr, str_expr) {\n\t\tswitch (curr->flavor) {\n\t\tcase CIL_STRING:\n\t\t\trc = cil_resolve_name(parent, curr->data, sym_index, extra_args, &res_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (sym_index == CIL_SYM_TYPES && (expr_type == CIL_CONSTRAIN || expr_type == CIL_VALIDATETRANS)) {\n\t\t\t\tcil_type_used(res_datum, CIL_ATTR_CONSTRAINT);\n\t\t\t}\n\n\t\t\tcil_list_append(*datum_expr, CIL_DATUM, res_datum);\n\t\t\tbreak;\n\t\tcase CIL_LIST: {\n\t\t\tstruct cil_list *datum_sub_expr;\n\t\t\trc = cil_resolve_expr(expr_type, curr->data, &datum_sub_expr, parent, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_list_destroy(&datum_sub_expr, CIL_TRUE);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_append(*datum_expr, CIL_LIST, datum_sub_expr);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcil_list_append(*datum_expr, curr->flavor, curr->data);\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t}\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_boolif(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_booleanif *bif = (struct cil_booleanif*)current->data;\n\n\trc = cil_resolve_expr(CIL_BOOLEANIF, bif->str_expr, &bif->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nstatic int __cil_evaluate_tunable_expr(struct cil_list_item *curr);\n\nstatic int __cil_evaluate_tunable_expr_helper(struct cil_list_item *curr)\n{\n\tif (curr == NULL) {\n\t\treturn CIL_FALSE;\n\t} else if (curr->flavor == CIL_DATUM) {\n\t\tstruct cil_tunable *tun = curr->data;\n\t\treturn tun->value;\n\t} else if (curr->flavor == CIL_LIST) {\n\t\tstruct cil_list *l = curr->data;\n\t\treturn __cil_evaluate_tunable_expr(l->head);\n\t} else {\n\t\treturn CIL_FALSE;\n\t}\n}\n\nstatic int __cil_evaluate_tunable_expr(struct cil_list_item *curr)\n{\n\t/* Assumes expression is well-formed */\n\n\tif (curr == NULL) {\n\t\treturn CIL_FALSE;\n\t} else if (curr->flavor == CIL_OP) {\n\t\tuint16_t v1, v2;\n\t\tenum cil_flavor op_flavor = (enum cil_flavor)(uintptr_t)curr->data;\n\n\t\tv1 = __cil_evaluate_tunable_expr_helper(curr->next);\n\n\t\tif (op_flavor == CIL_NOT) return !v1;\n\n\t\tv2 = __cil_evaluate_tunable_expr_helper(curr->next->next);\n\n\t\tif (op_flavor == CIL_AND) return (v1 && v2);\n\t\telse if (op_flavor == CIL_OR) return (v1 || v2);\n\t\telse if (op_flavor == CIL_XOR) return (v1 ^ v2);\n\t\telse if (op_flavor == CIL_EQ) return (v1 == v2);\n\t\telse if (op_flavor == CIL_NEQ) return (v1 != v2);\n\t\telse return CIL_FALSE;\n\t} else {\n\t\tuint16_t v;\n\t\tfor (;curr; curr = curr->next) {\n\t\t\tv = __cil_evaluate_tunable_expr_helper(curr);\n\t\t\tif (v) return v;\n\t\t}\n\t\treturn CIL_FALSE;\n\t}\n}\n\nint cil_resolve_tunif(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\tint rc = SEPOL_ERR;\n\tstruct cil_tunableif *tif = (struct cil_tunableif*)current->data;\n\tuint16_t result = CIL_FALSE;\n\tstruct cil_tree_node *true_node = NULL;\n\tstruct cil_tree_node *false_node = NULL;\n\tstruct cil_condblock *cb = NULL;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_expr(CIL_TUNABLEIF, tif->str_expr, &tif->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult = __cil_evaluate_tunable_expr(tif->datum_expr->head);\n\n\tif (current->cl_head != NULL && current->cl_head->flavor == CIL_CONDBLOCK) {\n\t\tcb = current->cl_head->data;\n\t\tif (cb->flavor == CIL_CONDTRUE) {\n\t\t\ttrue_node = current->cl_head;\n\t\t} else if (cb->flavor == CIL_CONDFALSE) {\n\t\t\tfalse_node = current->cl_head;\n\t\t}\n\t}\n\n\tif (current->cl_head != NULL && current->cl_head->next != NULL && current->cl_head->next->flavor == CIL_CONDBLOCK) {\n\t\tcb = current->cl_head->next->data;\n\t\tif (cb->flavor == CIL_CONDTRUE) {\n\t\t\ttrue_node = current->cl_head->next;\n\t\t} else if (cb->flavor == CIL_CONDFALSE) {\n\t\t\tfalse_node = current->cl_head->next;\n\t\t}\n\t}\n\n\tif (result == CIL_TRUE) {\n\t\tif (true_node != NULL) {\n\t\t\trc = cil_copy_ast(db, true_node, current->parent);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (false_node != NULL) {\n\t\t\trc = cil_copy_ast(db, false_node, current->parent);\n\t\t\tif (rc  != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tcil_tree_children_destroy(current);\n\tcurrent->cl_head = NULL;\n\tcurrent->cl_tail = NULL;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_userattributeset(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_userattributeset *attrusers = current->data;\n\tstruct cil_symtab_datum *attr_datum = NULL;\n\tstruct cil_tree_node *attr_node = NULL;\n\tstruct cil_userattribute *attr = NULL;\n\n\trc = cil_resolve_name(current, attrusers->attr_str, CIL_SYM_USERS, extra_args, &attr_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tattr_node = NODE(attr_datum);\n\n\tif (attr_node->flavor != CIL_USERATTRIBUTE) {\n\t\trc = SEPOL_ERR;\n\t\tcil_log(CIL_ERR, \"Attribute user not an attribute\\n\");\n\t\tgoto exit;\n\t}\n\tattr = (struct cil_userattribute*)attr_datum;\n\n\trc = cil_resolve_expr(CIL_USERATTRIBUTESET, attrusers->str_expr, &attrusers->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_verify_no_self_reference(attr_datum, attrusers->datum_expr);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tif (attr->expr_list == NULL) {\n\t\tcil_list_init(&attr->expr_list, CIL_USERATTRIBUTE);\n\t}\n\n\tcil_list_append(attr->expr_list, CIL_LIST, attrusers->datum_expr);\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint __cil_resolve_ast_node(struct cil_tree_node *node, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = 0;\n\tstruct cil_list *ins;\n\n\tif (node == NULL || args == NULL) {\n\t\tgoto exit;\n\t}\n\tins = args->in_list;\n\n\tpass = args->pass;\n\tswitch (pass) {\n\tcase CIL_PASS_TIF:\n\t\tif (node->flavor == CIL_TUNABLEIF) {\n\t\t\trc = cil_resolve_tunif(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_IN:\n\t\tif (node->flavor == CIL_IN) {\n\t\t\t// due to ordering issues, in statements are just gathered here and\n\t\t\t// resolved together in cil_resolve_in_list once all are found\n\t\t\tcil_list_prepend(ins, CIL_NODE, node);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_BLKIN_LINK:\n\t\tif (node->flavor == CIL_BLOCKINHERIT) {\n\t\t\trc = cil_resolve_blockinherit_link(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_BLKIN_COPY:\n\t\tif (node->flavor == CIL_BLOCK) {\n\t\t\trc = cil_resolve_blockinherit_copy(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_BLKABS:\n\t\tif (node->flavor == CIL_BLOCKABSTRACT) {\n\t\t\trc = cil_resolve_blockabstract(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MACRO:\n\t\tif (node->flavor == CIL_CALL && args->macro != NULL) {\n\t\t\trc = cil_resolve_call1(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_CALL1:\n\t\tif (node->flavor == CIL_CALL) {\n\t\t\trc = cil_resolve_call1(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_CALL2:\n\t\tif (node->flavor == CIL_CALL) {\n\t\t\trc = cil_resolve_call2(node, args);\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_ALIAS1:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_TYPEALIASACTUAL:\n\t\t\trc = cil_resolve_aliasactual(node, args, CIL_TYPE, CIL_TYPEALIAS);\n\t\t\tbreak;\n\t\tcase CIL_SENSALIASACTUAL:\n\t\t\trc = cil_resolve_aliasactual(node, args, CIL_SENS, CIL_SENSALIAS);\n\t\t\tbreak;\n\t\tcase CIL_CATALIASACTUAL:\n\t\t\trc = cil_resolve_aliasactual(node, args, CIL_CAT, CIL_CATALIAS);\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_ALIAS2:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_TYPEALIAS:\n\t\t\trc = cil_resolve_alias_to_actual(node, CIL_TYPE);\n\t\t\tbreak;\n\t\tcase CIL_SENSALIAS:\n\t\t\trc = cil_resolve_alias_to_actual(node, CIL_SENS);\n\t\t\tbreak;\n\t\tcase CIL_CATALIAS:\n\t\t\trc = cil_resolve_alias_to_actual(node, CIL_CAT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MISC1:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_SIDORDER:\n\t\t\trc = cil_resolve_sidorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSORDER:\n\t\t\trc = cil_resolve_classorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CATORDER:\n\t\t\trc = cil_resolve_catorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_SENSITIVITYORDER:\n\t\t\trc = cil_resolve_sensitivityorder(node, args);\n\t\t\tbreak;\n\t\tcase CIL_BOOLEANIF:\n\t\t\trc = cil_resolve_boolif(node, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MLS:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_CATSET:\n\t\t\trc = cil_resolve_catset(node, (struct cil_catset*)node->data, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MISC2:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_SENSCAT:\n\t\t\trc = cil_resolve_senscat(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSCOMMON:\n\t\t\trc = cil_resolve_classcommon(node, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CIL_PASS_MISC3:\n\t\tswitch (node->flavor) {\n\t\tcase CIL_TYPEATTRIBUTESET:\n\t\t\trc = cil_resolve_typeattributeset(node, args);\n\t\t\tbreak;\n\t\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\t\trc = cil_resolve_expandtypeattribute(node, args);\n\t\t\tbreak;\n\t\tcase CIL_TYPEBOUNDS:\n\t\t\trc = cil_resolve_bounds(node, args, CIL_TYPE, CIL_TYPEATTRIBUTE);\n\t\t\tbreak;\n\t\tcase CIL_TYPEPERMISSIVE:\n\t\t\trc = cil_resolve_typepermissive(node, args);\n\t\t\tbreak;\n\t\tcase CIL_NAMETYPETRANSITION:\n\t\t\trc = cil_resolve_nametypetransition(node, args);\n\t\t\tbreak;\n\t\tcase CIL_RANGETRANSITION:\n\t\t\trc = cil_resolve_rangetransition(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSIONSET:\n\t\t\trc = cil_resolve_classpermissionset(node, (struct cil_classpermissionset*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_CLASSMAPPING:\n\t\t\trc = cil_resolve_classmapping(node, args);\n\t\t\tbreak;\n\t\tcase CIL_AVRULE:\n\t\tcase CIL_AVRULEX:\n\t\t\trc = cil_resolve_avrule(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PERMISSIONX:\n\t\t\trc = cil_resolve_permissionx(node, (struct cil_permissionx*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_TYPE_RULE:\n\t\t\trc = cil_resolve_type_rule(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERROLE:\n\t\t\trc = cil_resolve_userrole(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERLEVEL:\n\t\t\trc = cil_resolve_userlevel(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERRANGE:\n\t\t\trc = cil_resolve_userrange(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERBOUNDS:\n\t\t\trc = cil_resolve_bounds(node, args, CIL_USER, CIL_USERATTRIBUTE);\n\t\t\tbreak;\n\t\tcase CIL_USERPREFIX:\n\t\t\trc = cil_resolve_userprefix(node, args);\n\t\t\tbreak;\n\t\tcase CIL_SELINUXUSER:\n\t\tcase CIL_SELINUXUSERDEFAULT:\n\t\t\trc = cil_resolve_selinuxuser(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLEATTRIBUTESET:\n\t\t\trc = cil_resolve_roleattributeset(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLETYPE:\n\t\t\trc = cil_resolve_roletype(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLETRANSITION:\n\t\t\trc = cil_resolve_roletransition(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLEALLOW:\n\t\t\trc = cil_resolve_roleallow(node, args);\n\t\t\tbreak;\n\t\tcase CIL_ROLEBOUNDS:\n\t\t\trc = cil_resolve_bounds(node, args, CIL_ROLE, CIL_ROLEATTRIBUTE);\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\trc = cil_resolve_level(node, (struct cil_level*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\trc = cil_resolve_levelrange(node, (struct cil_levelrange*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_CONSTRAIN:\n\t\t\trc = cil_resolve_constrain(node, args);\n\t\t\tbreak;\n\t\tcase CIL_MLSCONSTRAIN:\n\t\t\trc = cil_resolve_constrain(node, args);\n\t\t\tbreak;\n\t\tcase CIL_VALIDATETRANS:\n\t\tcase CIL_MLSVALIDATETRANS:\n\t\t\trc = cil_resolve_validatetrans(node, args);\n\t\t\tbreak;\n\t\tcase CIL_CONTEXT:\n\t\t\trc = cil_resolve_context(node, (struct cil_context*)node->data, args);\n\t\t\tbreak;\n\t\tcase CIL_FILECON:\n\t\t\trc = cil_resolve_filecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IBPKEYCON:\n\t\t\trc = cil_resolve_ibpkeycon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PORTCON:\n\t\t\trc = cil_resolve_portcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_NODECON:\n\t\t\trc = cil_resolve_nodecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_GENFSCON:\n\t\t\trc = cil_resolve_genfscon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_NETIFCON:\n\t\t\trc = cil_resolve_netifcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IBENDPORTCON:\n\t\t\trc = cil_resolve_ibendportcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PIRQCON:\n\t\t\trc = cil_resolve_pirqcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IOMEMCON:\n\t\t\trc = cil_resolve_iomemcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_IOPORTCON:\n\t\t\trc = cil_resolve_ioportcon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_PCIDEVICECON:\n\t\t\trc = cil_resolve_pcidevicecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_DEVICETREECON:\n\t\t\trc = cil_resolve_devicetreecon(node, args);\n\t\t\tbreak;\n\t\tcase CIL_FSUSE:\n\t\t\trc = cil_resolve_fsuse(node, args);\n\t\t\tbreak;\n\t\tcase CIL_SIDCONTEXT:\n\t\t\trc = cil_resolve_sidcontext(node, args);\n\t\t\tbreak;\n\t\tcase CIL_DEFAULTUSER:\n\t\tcase CIL_DEFAULTROLE:\n\t\tcase CIL_DEFAULTTYPE:\n\t\t\trc = cil_resolve_default(node, args);\n\t\t\tbreak;\n\t\tcase CIL_DEFAULTRANGE:\n\t\t\trc = cil_resolve_defaultrange(node, args);\n\t\t\tbreak;\n\t\tcase CIL_USERATTRIBUTESET:\n\t\t\trc = cil_resolve_userattributeset(node, args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}\n\nint __cil_resolve_ast_node_helper(struct cil_tree_node *node, uint32_t *finished, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = args->pass;\n\tstruct cil_tree_node *block = args->block;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *optional = args->optional;\n\tstruct cil_tree_node *boolif = args->boolif;\n\n\tif (node == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (block != NULL) {\n\t\tif (node->flavor == CIL_CAT ||\n\t\t    node->flavor == CIL_SENS) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in blocks\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (node->flavor == CIL_BLOCK ||\n\t\t    node->flavor == CIL_BLOCKINHERIT ||\n\t\t    node->flavor == CIL_BLOCKABSTRACT ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in macros\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (optional != NULL) {\n\t\tif (node->flavor == CIL_TUNABLE ||\n\t\t\tnode->flavor == CIL_IN ||\n\t\t\tnode->flavor == CIL_BLOCK ||\n\t\t\tnode->flavor == CIL_BLOCKABSTRACT ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in optionals\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (node->flavor != CIL_TUNABLEIF &&\n\t\t\tnode->flavor != CIL_CALL &&\n\t\t\tnode->flavor != CIL_CONDBLOCK &&\n\t\t\tnode->flavor != CIL_AVRULE &&\n\t\t\tnode->flavor != CIL_TYPE_RULE &&\n\t\t\tnode->flavor != CIL_NAMETYPETRANSITION) {\n\t\t\trc = SEPOL_ERR;\n\t\t} else if (node->flavor == CIL_AVRULE) {\n\t\t\tstruct cil_avrule *rule = node->data;\n\t\t\tif (rule->rule_kind == CIL_AVRULE_NEVERALLOW) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t\tif (rc == SEPOL_ERR) {\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs (tunableif treated as a booleanif)\", cil_node_to_string(node));\n\t\t\t} else {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs\", cil_node_to_string(node));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_MACRO) {\n\t\tif (pass != CIL_PASS_TIF && pass != CIL_PASS_MACRO) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_BLOCK && ((((struct cil_block*)node->data)->is_abstract == CIL_TRUE) && (pass > CIL_PASS_BLKABS))) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\trc = __cil_resolve_ast_node(node, extra_args);\n\tif (rc == SEPOL_ENOENT) {\n\t\tenum cil_log_level lvl = CIL_ERR;\n\n\t\tif (optional != NULL) {\n\t\t\tlvl = CIL_INFO;\n\n\t\t\tstruct cil_optional *opt = (struct cil_optional *)optional->data;\n\t\t\tstruct cil_tree_node *opt_node = NODE(opt);;\n\t\t\t/* disable an optional if something failed to resolve */\n\t\t\topt->enabled = CIL_FALSE;\n\t\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\t\tcil_tree_log(opt_node, lvl, \"Disabling optional '%s'\", opt->datum.name);\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}\n\nint __cil_resolve_ast_first_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\n\tif (current == NULL || extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_BLOCK) {\n\t\targs->block = parent;\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\targs->macro = parent;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\targs->optional = parent;\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = parent;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_BLOCK) {\n\t\tstruct cil_tree_node *n = parent->parent;\n\t\targs->block = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_BLOCK) {\n\t\t\t\targs->block = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = parent->parent;\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_ast(struct cil_db *db, struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve extra_args;\n\tenum cil_pass pass = CIL_PASS_TIF;\n\tuint32_t changed = 0;\n\n\tif (db == NULL || current == NULL) {\n\t\treturn rc;\n\t}\n\n\textra_args.db = db;\n\textra_args.pass = pass;\n\textra_args.changed = &changed;\n\textra_args.block = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif= NULL;\n\textra_args.sidorder_lists = NULL;\n\textra_args.classorder_lists = NULL;\n\textra_args.unordered_classorder_lists = NULL;\n\textra_args.catorder_lists = NULL;\n\textra_args.sensitivityorder_lists = NULL;\n\textra_args.in_list = NULL;\n\n\tcil_list_init(&extra_args.disabled_optionals, CIL_NODE);\n\tcil_list_init(&extra_args.sidorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.classorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.unordered_classorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.catorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.sensitivityorder_lists, CIL_LIST_ITEM);\n\tcil_list_init(&extra_args.in_list, CIL_IN);\n\tfor (pass = CIL_PASS_TIF; pass < CIL_PASS_NUM; pass++) {\n\t\textra_args.pass = pass;\n\t\trc = cil_tree_walk(current, __cil_resolve_ast_node_helper, __cil_resolve_ast_first_child_helper, __cil_resolve_ast_last_child_helper, &extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_log(CIL_INFO, \"Pass %i of resolution failed\\n\", pass);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (pass == CIL_PASS_IN) {\n\t\t\trc = cil_resolve_in_list(&extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_destroy(&extra_args.in_list, CIL_FALSE);\n\t\t}\n\n\t\tif (pass == CIL_PASS_MISC1) {\n\t\t\tdb->sidorder = __cil_ordered_lists_merge_all(&extra_args.sidorder_lists, NULL);\n\t\t\tif (db->sidorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tdb->classorder = __cil_ordered_lists_merge_all(&extra_args.classorder_lists, &extra_args.unordered_classorder_lists);\n\t\t\tif (db->classorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tdb->catorder = __cil_ordered_lists_merge_all(&extra_args.catorder_lists, NULL);\n\t\t\tif (db->catorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_set_cat_values(db->catorder, db);\n\t\t\tdb->sensitivityorder = __cil_ordered_lists_merge_all(&extra_args.sensitivityorder_lists, NULL);\n\t\t\tif (db->sensitivityorder == NULL) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_SID);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_CLASS);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_CAT);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\trc = __cil_verify_ordered(current, CIL_SENS);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (changed && (pass > CIL_PASS_CALL1)) {\n\t\t\tstruct cil_list_item *item;\n\t\t\t/* Need to re-resolve because an optional was disabled that contained\n\t\t\t * one or more declarations. We only need to reset to the call1 pass \n\t\t\t * because things done in the preceding passes aren't allowed in \n\t\t\t * optionals, and thus can't be disabled.\n\t\t\t * Note: set pass to CIL_PASS_CALL1 because the pass++ will increment \n\t\t\t * it to CIL_PASS_CALL2\n\t\t\t */\n\t\t\tcil_log(CIL_INFO, \"Resetting declarations\\n\");\n\n\t\t\tif (pass >= CIL_PASS_MISC1) {\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.sidorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.classorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.unordered_classorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.catorder_lists);\n\t\t\t\t__cil_ordered_lists_reset(&extra_args.sensitivityorder_lists);\n\t\t\t\tcil_list_destroy(&db->sidorder, CIL_FALSE);\n\t\t\t\tcil_list_destroy(&db->classorder, CIL_FALSE);\n\t\t\t\tcil_list_destroy(&db->catorder, CIL_FALSE);\n\t\t\t\tcil_list_destroy(&db->sensitivityorder, CIL_FALSE);\n\t\t\t}\n\n\t\t\tpass = CIL_PASS_CALL1;\n\n\t\t\trc = cil_reset_ast(current);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_log(CIL_ERR, \"Failed to reset declarations\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcil_list_for_each(item, extra_args.disabled_optionals) {\n\t\t\t\tcil_tree_children_destroy(item->data);\n\t\t\t}\n\t\t\tcil_list_destroy(&extra_args.disabled_optionals, CIL_FALSE);\n\t\t\tcil_list_init(&extra_args.disabled_optionals, CIL_NODE);\n\t\t\tchanged = 0;\n\t\t}\n\t}\n\n\trc = __cil_verify_initsids(db->sidorder);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\nexit:\n\t__cil_ordered_lists_destroy(&extra_args.sidorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.classorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.catorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.sensitivityorder_lists);\n\t__cil_ordered_lists_destroy(&extra_args.unordered_classorder_lists);\n\tcil_list_destroy(&extra_args.disabled_optionals, CIL_FALSE);\n\tcil_list_destroy(&extra_args.in_list, CIL_FALSE);\n\n\treturn rc;\n}\n\nstatic int __cil_resolve_name_with_root(struct cil_db *db, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tsymtab_t *symtab = &((struct cil_root *)db->ast->root->data)->symtab[sym_index];\n\n\treturn cil_symtab_get_datum(symtab, name, datum);\n}\n\nstatic int __cil_resolve_name_with_parents(struct cil_tree_node *node, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\tsymtab_t *symtab = NULL;\n\n\twhile (node != NULL && rc != SEPOL_OK) {\n\t\tswitch (node->flavor) {\n\t\tcase CIL_ROOT:\n\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase CIL_BLOCK:\n\t\t\tsymtab = &((struct cil_block*)node->data)->symtab[sym_index];\n\t\t\trc = cil_symtab_get_datum(symtab, name, datum);\n\t\t\tbreak;\n\t\tcase CIL_BLOCKINHERIT: {\n\t\t\tstruct cil_blockinherit *inherit = node->data;\n\t\t\trc = __cil_resolve_name_with_parents(node->parent, name, sym_index, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t/* Continue search in original block's parent */\n\t\t\t\trc = __cil_resolve_name_with_parents(NODE(inherit->block), name, sym_index, datum);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase CIL_MACRO: {\n\t\t\tstruct cil_macro *macro = node->data;\n\t\t\tsymtab = &macro->symtab[sym_index];\n\t\t\trc = cil_symtab_get_datum(symtab, name, datum);\n\t\t}\n\t\t\tbreak;\n\t\tcase CIL_CALL: {\n\t\t\tstruct cil_call *call = node->data;\n\t\t\trc = cil_resolve_name_call_args(call, name, sym_index, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t/* Continue search in macro's parent */\n\t\t\t\trc = __cil_resolve_name_with_parents(NODE(call->macro)->parent, name, sym_index, datum);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase CIL_IN:\n\t\t\t/* In block symtabs only exist before resolving the AST */\n\t\tcase CIL_CONDBLOCK:\n\t\t\t/* Cond block symtabs only exist before resolving the AST */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tnode = node->parent;\n\t}\n\nexit:\n\treturn rc;\n}\n\nstatic int __cil_resolve_name_helper(struct cil_db *db, struct cil_tree_node *node, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = __cil_resolve_name_with_parents(node, name, sym_index, datum);\n\tif (rc != SEPOL_OK) {\n\t\trc = __cil_resolve_name_with_root(db, name, sym_index, datum);\n\t}\n\treturn rc;\n}\n\nint cil_resolve_name(struct cil_tree_node *ast_node, char *name, enum cil_sym_index sym_index, void *extra_args, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_tree_node *node = NULL;\n\n\trc = cil_resolve_name_keep_aliases(ast_node, name, sym_index, extra_args, datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\t/* If this datum is an alias, then return the actual node\n\t * This depends on aliases already being processed\n\t */\n\tnode = NODE(*datum);\n\tif (node->flavor == CIL_TYPEALIAS || node->flavor == CIL_SENSALIAS\n\t\t|| node->flavor == CIL_CATALIAS) {\n\t\tstruct cil_alias *alias = (struct cil_alias *)(*datum);\n\t\tif (alias->actual) {\n\t\t\t*datum = alias->actual;\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_name_keep_aliases(struct cil_tree_node *ast_node, char *name, enum cil_sym_index sym_index, void *extra_args, struct cil_symtab_datum **datum)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = args->db;\n\tstruct cil_tree_node *node = NULL;\n\n\tif (name == NULL) {\n\t\tcil_log(CIL_ERR, \"Invalid call to cil_resolve_name\\n\");\n\t\tgoto exit;\n\t}\n\n\t*datum = NULL;\n\n\tif (strchr(name,'.') == NULL) {\n\t\t/* No '.' in name */\n\t\trc = __cil_resolve_name_helper(db, ast_node->parent, name, sym_index, datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tchar *sp = NULL;\n\t\tchar *name_dup = cil_strdup(name);\n\t\tchar *current = strtok_r(name_dup, \".\", &sp);\n\t\tchar *next = strtok_r(NULL, \".\", &sp);\n\t\tsymtab_t *symtab = NULL;\n\n\t\tif (current == NULL) {\n\t\t\t/* Only dots */\n\t\t\tcil_tree_log(ast_node, CIL_ERR, \"Invalid name %s\", name);\n\t\t\tfree(name_dup);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tnode = ast_node;\n\t\tif (*name == '.') {\n\t\t\t/* Leading '.' */\n\t\t\tsymtab = &((struct cil_root *)db->ast->root->data)->symtab[CIL_SYM_BLOCKS];\n\t\t} else {\n\t\t\trc = __cil_resolve_name_helper(db, node->parent, current, CIL_SYM_BLOCKS, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tfree(name_dup);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsymtab = (*datum)->symtab;\n\t\t}\n\t\t/* Keep looking up blocks by name until only last part of name remains */\n\t\twhile (next != NULL) {\n\t\t\trc = cil_symtab_get_datum(symtab, current, datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tfree(name_dup);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tnode = NODE(*datum);\n\t\t\tif (node->flavor == CIL_BLOCK) {\n\t\t\t\tsymtab = &((struct cil_block*)node->data)->symtab[CIL_SYM_BLOCKS];\n\t\t\t} else {\n\t\t\t\tif (ast_node->flavor != CIL_IN) {\n\t\t\t\t\tcil_log(CIL_WARN, \"Can only use %s name for name resolution in \\\"in\\\" blocks\\n\", cil_node_to_string(node));\n\t\t\t\t\tfree(name_dup);\n\t\t\t\t\trc = SEPOL_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif (node->flavor == CIL_MACRO) {\n\t\t\t\t\tstruct cil_macro *macro = node->data;\n\t\t\t\t\tsymtab = &macro->symtab[sym_index];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = next;\n\t\t\tnext = strtok_r(NULL, \".\", &sp);\n\t\t}\n\t\tsymtab = &(symtab[sym_index]);\n\t\trc = cil_symtab_get_datum(symtab, current, datum);\n\t\tfree(name_dup);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\tif (rc != SEPOL_OK) {\n\t\t*datum = NULL;\n\t}\n\n\treturn rc;\n}\n"], "filenames": ["libsepol/cil/src/cil_build_ast.c", "libsepol/cil/src/cil_resolve_ast.c"], "buggy_code_start_loc": [54, 3810], "buggy_code_end_loc": [6522, 3813], "fixing_code_start_loc": [55, 3811], "fixing_code_end_loc": [6555, 3814], "type": "CWE-125", "message": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.", "other": {"cve": {"id": "CVE-2021-36087", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:08.817", "lastModified": "2021-11-17T14:05:01.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block."}, {"lang": "es", "value": "El compilador CIL en SELinux 3.2 tiene una sobrelectura del b\u00fafer basada en el mont\u00f3n en ebitmap_match_any (llamado indirectamente desde cil_check_neverallow). Esto ocurre porque a veces no se comprueban las declaraciones no v\u00e1lidas en un bloque opcional"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:selinux_project:selinux:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "8B21B98E-38B6-4BA9-9FC9-761FF2A2CA39"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=32675", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/SELinuxProject/selinux/commit/340f0eb7f3673e8aacaf0a96cbfcd4d12a405521", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/selinux/OSV-2021-585.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U7ZYR3PIJ75N6U2IONJWCKZ5L2NKJTGR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/selinux/CAEN2sdqJKHvDzPnxS-J8grU8fSf32DDtx=kyh84OsCq_Vm+yaQ@mail.gmail.com/T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SELinuxProject/selinux/commit/340f0eb7f3673e8aacaf0a96cbfcd4d12a405521"}}