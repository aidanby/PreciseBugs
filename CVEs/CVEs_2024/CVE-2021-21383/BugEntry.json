{"buggy_code": ["const _ = require('lodash')\nconst cheerio = require('cheerio')\nconst uslug = require('uslug')\nconst pageHelper = require('../../../helpers/page')\nconst URL = require('url').URL\n\nconst mustacheRegExp = /(\\{|&#x7b;?){2}(.+?)(\\}|&#x7d;?){2}/i\n\n/* global WIKI */\n\nmodule.exports = {\n  async render() {\n    const $ = cheerio.load(this.input, {\n      decodeEntities: true\n    })\n\n    if ($.root().children().length < 1) {\n      return ''\n    }\n\n    // --------------------------------\n    // STEP: PRE\n    // --------------------------------\n\n    for (let child of _.reject(this.children, ['step', 'post'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      await renderer.init($, child.config)\n    }\n\n    // --------------------------------\n    // Detect internal / external links\n    // --------------------------------\n\n    let internalRefs = []\n    const reservedPrefixes = /^\\/[a-z]\\//i\n    const exactReservedPaths = /^\\/[a-z]$/i\n\n    const isHostSet = WIKI.config.host.length > 7 && WIKI.config.host !== 'http://'\n    if (!isHostSet) {\n      WIKI.logger.warn('Host is not set. You must set the Site Host under General in the Administration Area!')\n    }\n\n    $('a').each((i, elm) => {\n      let href = $(elm).attr('href')\n\n      // -> Ignore empty / anchor links, e-mail addresses, and telephone numbers\n      if (!href || href.length < 1 || href.indexOf('#') === 0 ||\n        href.indexOf('mailto:') === 0 || href.indexOf('tel:') === 0) {\n        return\n      }\n\n      // -> Strip host from local links\n      if (isHostSet && href.indexOf(WIKI.config.host) === 0) {\n        href = href.replace(WIKI.config.host, '')\n      }\n\n      // -> Assign local / external tag\n      if (href.indexOf('://') < 0) {\n        // -> Remove trailing slash\n        if (_.endsWith('/')) {\n          href = href.slice(0, -1)\n        }\n\n        // -> Check for system prefix\n        if (reservedPrefixes.test(href) || exactReservedPaths.test(href)) {\n          $(elm).addClass(`is-system-link`)\n        } else if (href.indexOf('.') >= 0) {\n          $(elm).addClass(`is-asset-link`)\n        } else {\n          let pagePath = null\n\n          // -> Add locale prefix if using namespacing\n          if (WIKI.config.lang.namespacing) {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${this.page.localeCode}/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${this.page.localeCode}/${href}` : `/${this.page.localeCode}/${this.page.path}/${href}`\n              }\n            } else if (href.charAt(3) !== '/') {\n              href = `/${this.page.localeCode}${href}`\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          } else {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${href}` : `/${this.page.path}/${href}`\n              }\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          }\n          // -> Save internal references\n          internalRefs.push({\n            localeCode: pagePath.locale,\n            path: pagePath.path\n          })\n\n          $(elm).addClass(`is-internal-link`)\n        }\n      } else {\n        $(elm).addClass(`is-external-link`)\n        if (this.config.openExternalLinkNewTab) {\n          $(elm).attr('target', '_blank')\n          $(elm).attr('rel', this.config.relAttributeExternalLink)\n        }\n      }\n\n      // -> Update element\n      $(elm).attr('href', href)\n    })\n\n    // --------------------------------\n    // Detect internal link states\n    // --------------------------------\n\n    const pastLinks = await this.page.$relatedQuery('links')\n\n    if (internalRefs.length > 0) {\n      // -> Find matching pages\n      const results = await WIKI.models.pages.query().column('id', 'path', 'localeCode').where(builder => {\n        internalRefs.forEach((ref, idx) => {\n          if (idx < 1) {\n            builder.where(ref)\n          } else {\n            builder.orWhere(ref)\n          }\n        })\n      })\n\n      // -> Apply tag to internal links for found pages\n      $('a.is-internal-link').each((i, elm) => {\n        const href = $(elm).attr('href')\n        let hrefObj = {}\n        try {\n          const parsedUrl = new URL(`http://x${href}`)\n          hrefObj = pageHelper.parsePath(parsedUrl.pathname)\n        } catch (err) {\n          return\n        }\n        if (_.some(results, r => {\n          return r.localeCode === hrefObj.locale && r.path === hrefObj.path\n        })) {\n          $(elm).addClass(`is-valid-page`)\n        } else {\n          $(elm).addClass(`is-invalid-page`)\n        }\n      })\n\n      // -> Add missing links\n      const missingLinks = _.differenceWith(internalRefs, pastLinks, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (missingLinks.length > 0) {\n        if (WIKI.config.db.type === 'postgres') {\n          await WIKI.models.pageLinks.query().insert(missingLinks.map(lnk => ({\n            pageId: this.page.id,\n            path: lnk.path,\n            localeCode: lnk.localeCode\n          })))\n        } else {\n          for (const lnk of missingLinks) {\n            await WIKI.models.pageLinks.query().insert({\n              pageId: this.page.id,\n              path: lnk.path,\n              localeCode: lnk.localeCode\n            })\n          }\n        }\n      }\n    }\n\n    // -> Remove outdated links\n    if (pastLinks) {\n      const outdatedLinks = _.differenceWith(pastLinks, internalRefs, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (outdatedLinks.length > 0) {\n        await WIKI.models.pageLinks.query().delete().whereIn('id', _.map(outdatedLinks, 'id'))\n      }\n    }\n\n    // --------------------------------\n    // Add header handles\n    // --------------------------------\n\n    let headers = []\n    $('h1,h2,h3,h4,h5,h6').each((i, elm) => {\n      if ($(elm).attr('id')) {\n        return\n      }\n      let headerSlug = uslug($(elm).text())\n\n      // -> Cannot start with a number (CSS selector limitation)\n      if (headerSlug.match(/^\\d/)) {\n        headerSlug = `h-${headerSlug}`\n      }\n\n      // -> Make sure header is unique\n      if (headers.indexOf(headerSlug) >= 0) {\n        let isUnique = false\n        let hIdx = 1\n        while (!isUnique) {\n          const headerSlugTry = `${headerSlug}-${hIdx}`\n          if (headers.indexOf(headerSlugTry) < 0) {\n            isUnique = true\n            headerSlug = headerSlugTry\n          }\n          hIdx++\n        }\n      }\n\n      // -> Add anchor\n      $(elm).attr('id', headerSlug).addClass('toc-header')\n      $(elm).prepend(`<a class=\"toc-anchor\" href=\"#${headerSlug}\">&#xB6;</a> `)\n\n      headers.push(headerSlug)\n    })\n\n    // --------------------------------\n    // Wrap root text nodes\n    // --------------------------------\n\n    $('body').contents().toArray().forEach(item => {\n      if (item.type === 'text' && item.parent.name === 'body') {\n        $(item).wrap('<div></div>')\n      }\n    })\n\n    // --------------------------------\n    // Escape mustache expresions\n    // --------------------------------\n\n    function iterateMustacheNode (node) {\n      const list = $(node).contents().toArray()\n      list.forEach(item => {\n        if (item.type === 'text') {\n          const rawText = $(item).text()\n          if (mustacheRegExp.test(rawText)) {\n            $(item).parent().attr('v-pre', true)\n          }\n        } else {\n          iterateMustacheNode(item)\n        }\n      })\n    }\n    iterateMustacheNode($.root())\n\n    // --------------------------------\n    // STEP: POST\n    // --------------------------------\n\n    let output = decodeEscape($.html('body').replace('<body>', '').replace('</body>', ''))\n\n    for (let child of _.sortBy(_.filter(this.children, ['step', 'post']), ['order'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      output = await renderer.init(output, child.config)\n    }\n\n    return output\n  }\n}\n\nfunction decodeEscape (string) {\n  return string.replace(/&#x([0-9a-f]{1,6});/ig, (entity, code) => {\n    code = parseInt(code, 16)\n\n    // Don't unescape ASCII characters, assuming they're encoded for a good reason\n    if (code < 0x80) return entity\n\n    return String.fromCodePoint(code)\n  })\n}\n"], "fixing_code": ["const _ = require('lodash')\nconst cheerio = require('cheerio')\nconst uslug = require('uslug')\nconst pageHelper = require('../../../helpers/page')\nconst URL = require('url').URL\n\nconst mustacheRegExp = /(\\{|&#x7b;?){2}(.+?)(\\}|&#x7d;?){2}/i\n\n/* global WIKI */\n\nmodule.exports = {\n  async render() {\n    const $ = cheerio.load(this.input, {\n      decodeEntities: true\n    })\n\n    if ($.root().children().length < 1) {\n      return ''\n    }\n\n    // --------------------------------\n    // STEP: PRE\n    // --------------------------------\n\n    for (let child of _.reject(this.children, ['step', 'post'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      await renderer.init($, child.config)\n    }\n\n    // --------------------------------\n    // Detect internal / external links\n    // --------------------------------\n\n    let internalRefs = []\n    const reservedPrefixes = /^\\/[a-z]\\//i\n    const exactReservedPaths = /^\\/[a-z]$/i\n\n    const isHostSet = WIKI.config.host.length > 7 && WIKI.config.host !== 'http://'\n    if (!isHostSet) {\n      WIKI.logger.warn('Host is not set. You must set the Site Host under General in the Administration Area!')\n    }\n\n    $('a').each((i, elm) => {\n      let href = $(elm).attr('href')\n\n      // -> Ignore empty / anchor links, e-mail addresses, and telephone numbers\n      if (!href || href.length < 1 || href.indexOf('#') === 0 ||\n        href.indexOf('mailto:') === 0 || href.indexOf('tel:') === 0) {\n        return\n      }\n\n      // -> Strip host from local links\n      if (isHostSet && href.indexOf(WIKI.config.host) === 0) {\n        href = href.replace(WIKI.config.host, '')\n      }\n\n      // -> Assign local / external tag\n      if (href.indexOf('://') < 0) {\n        // -> Remove trailing slash\n        if (_.endsWith('/')) {\n          href = href.slice(0, -1)\n        }\n\n        // -> Check for system prefix\n        if (reservedPrefixes.test(href) || exactReservedPaths.test(href)) {\n          $(elm).addClass(`is-system-link`)\n        } else if (href.indexOf('.') >= 0) {\n          $(elm).addClass(`is-asset-link`)\n        } else {\n          let pagePath = null\n\n          // -> Add locale prefix if using namespacing\n          if (WIKI.config.lang.namespacing) {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${this.page.localeCode}/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${this.page.localeCode}/${href}` : `/${this.page.localeCode}/${this.page.path}/${href}`\n              }\n            } else if (href.charAt(3) !== '/') {\n              href = `/${this.page.localeCode}${href}`\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          } else {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${href}` : `/${this.page.path}/${href}`\n              }\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          }\n          // -> Save internal references\n          internalRefs.push({\n            localeCode: pagePath.locale,\n            path: pagePath.path\n          })\n\n          $(elm).addClass(`is-internal-link`)\n        }\n      } else {\n        $(elm).addClass(`is-external-link`)\n        if (this.config.openExternalLinkNewTab) {\n          $(elm).attr('target', '_blank')\n          $(elm).attr('rel', this.config.relAttributeExternalLink)\n        }\n      }\n\n      // -> Update element\n      $(elm).attr('href', href)\n    })\n\n    // --------------------------------\n    // Detect internal link states\n    // --------------------------------\n\n    const pastLinks = await this.page.$relatedQuery('links')\n\n    if (internalRefs.length > 0) {\n      // -> Find matching pages\n      const results = await WIKI.models.pages.query().column('id', 'path', 'localeCode').where(builder => {\n        internalRefs.forEach((ref, idx) => {\n          if (idx < 1) {\n            builder.where(ref)\n          } else {\n            builder.orWhere(ref)\n          }\n        })\n      })\n\n      // -> Apply tag to internal links for found pages\n      $('a.is-internal-link').each((i, elm) => {\n        const href = $(elm).attr('href')\n        let hrefObj = {}\n        try {\n          const parsedUrl = new URL(`http://x${href}`)\n          hrefObj = pageHelper.parsePath(parsedUrl.pathname)\n        } catch (err) {\n          return\n        }\n        if (_.some(results, r => {\n          return r.localeCode === hrefObj.locale && r.path === hrefObj.path\n        })) {\n          $(elm).addClass(`is-valid-page`)\n        } else {\n          $(elm).addClass(`is-invalid-page`)\n        }\n      })\n\n      // -> Add missing links\n      const missingLinks = _.differenceWith(internalRefs, pastLinks, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (missingLinks.length > 0) {\n        if (WIKI.config.db.type === 'postgres') {\n          await WIKI.models.pageLinks.query().insert(missingLinks.map(lnk => ({\n            pageId: this.page.id,\n            path: lnk.path,\n            localeCode: lnk.localeCode\n          })))\n        } else {\n          for (const lnk of missingLinks) {\n            await WIKI.models.pageLinks.query().insert({\n              pageId: this.page.id,\n              path: lnk.path,\n              localeCode: lnk.localeCode\n            })\n          }\n        }\n      }\n    }\n\n    // -> Remove outdated links\n    if (pastLinks) {\n      const outdatedLinks = _.differenceWith(pastLinks, internalRefs, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (outdatedLinks.length > 0) {\n        await WIKI.models.pageLinks.query().delete().whereIn('id', _.map(outdatedLinks, 'id'))\n      }\n    }\n\n    // --------------------------------\n    // Add header handles\n    // --------------------------------\n\n    let headers = []\n    $('h1,h2,h3,h4,h5,h6').each((i, elm) => {\n      if ($(elm).attr('id')) {\n        return\n      }\n      let headerSlug = uslug($(elm).text())\n\n      // -> Cannot start with a number (CSS selector limitation)\n      if (headerSlug.match(/^\\d/)) {\n        headerSlug = `h-${headerSlug}`\n      }\n\n      // -> Make sure header is unique\n      if (headers.indexOf(headerSlug) >= 0) {\n        let isUnique = false\n        let hIdx = 1\n        while (!isUnique) {\n          const headerSlugTry = `${headerSlug}-${hIdx}`\n          if (headers.indexOf(headerSlugTry) < 0) {\n            isUnique = true\n            headerSlug = headerSlugTry\n          }\n          hIdx++\n        }\n      }\n\n      // -> Add anchor\n      $(elm).attr('id', headerSlug).addClass('toc-header')\n      $(elm).prepend(`<a class=\"toc-anchor\" href=\"#${headerSlug}\">&#xB6;</a> `)\n\n      headers.push(headerSlug)\n    })\n\n    // --------------------------------\n    // Wrap root text nodes\n    // --------------------------------\n\n    $('body').contents().toArray().forEach(item => {\n      if (item.type === 'text' && item.parent.name === 'body') {\n        $(item).wrap('<div></div>')\n      }\n    })\n\n    // --------------------------------\n    // Escape mustache expresions\n    // --------------------------------\n\n    function iterateMustacheNode (node) {\n      const list = $(node).contents().toArray()\n      list.forEach(item => {\n        if (item.type === 'text') {\n          const rawText = $(item).text()\n          if (mustacheRegExp.test(rawText)) {\n            $(item).parent().attr('v-pre', true)\n          }\n        } else {\n          iterateMustacheNode(item)\n        }\n      })\n    }\n    iterateMustacheNode($.root())\n\n    $('pre').each((idx, elm) => {\n      $(elm).attr('v-pre', true)\n    })\n\n    // --------------------------------\n    // STEP: POST\n    // --------------------------------\n\n    let output = decodeEscape($.html('body').replace('<body>', '').replace('</body>', ''))\n\n    for (let child of _.sortBy(_.filter(this.children, ['step', 'post']), ['order'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      output = await renderer.init(output, child.config)\n    }\n\n    return output\n  }\n}\n\nfunction decodeEscape (string) {\n  return string.replace(/&#x([0-9a-f]{1,6});/ig, (entity, code) => {\n    code = parseInt(code, 16)\n\n    // Don't unescape ASCII characters, assuming they're encoded for a good reason\n    if (code < 0x80) return entity\n\n    return String.fromCodePoint(code)\n  })\n}\n"], "filenames": ["server/modules/rendering/html-core/renderer.js"], "buggy_code_start_loc": [263], "buggy_code_end_loc": [263], "fixing_code_start_loc": [264], "fixing_code_end_loc": [268], "type": "CWE-79", "message": "Wiki.js an open-source wiki app built on Node.js. Wiki.js before version 2.5.191 is vulnerable to stored cross-site scripting through mustache expressions in code blocks. This vulnerability exists due to mustache expressions being parsed by Vue during content injection even though it is contained within a `<pre>` element. By creating a crafted wiki page, a malicious Wiki.js user may stage a stored cross-site scripting attack. This allows the attacker to execute malicious JavaScript when the page is viewed by other users. For an example see referenced GitHub Security Advisory. Commit 5ffa189383dd716f12b56b8cae2ba0d075996cf1 fixes this vulnerability by adding the v-pre directive to all `<pre>` tags during the render.", "other": {"cve": {"id": "CVE-2021-21383", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-18T17:15:13.947", "lastModified": "2021-03-24T14:00:10.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wiki.js an open-source wiki app built on Node.js. Wiki.js before version 2.5.191 is vulnerable to stored cross-site scripting through mustache expressions in code blocks. This vulnerability exists due to mustache expressions being parsed by Vue during content injection even though it is contained within a `<pre>` element. By creating a crafted wiki page, a malicious Wiki.js user may stage a stored cross-site scripting attack. This allows the attacker to execute malicious JavaScript when the page is viewed by other users. For an example see referenced GitHub Security Advisory. Commit 5ffa189383dd716f12b56b8cae2ba0d075996cf1 fixes this vulnerability by adding the v-pre directive to all `<pre>` tags during the render."}, {"lang": "es", "value": "Wiki.js una aplicaci\u00f3n wiki de c\u00f3digo abierto construida sobre Node.js.&#xa0;Wiki.js versiones anteriores a 2.5.191, es vulnerable a un ataque de tipo cross-site scripting almacenado por medio de expresiones mustache en bloques de c\u00f3digo.&#xa0;Esta vulnerabilidad se presenta debido a que las expresiones mustache eran analizadas por Vue durante la inyecci\u00f3n de contenido a pesar de que est\u00e1 contenida dentro de un elemento \"(pre)\".&#xa0;Al crear una p\u00e1gina wiki dise\u00f1ada, un usuario de Wiki.js malicioso puede organizar un ataque de tipo cross-site scripting almacenado.&#xa0;Esto permite al atacante ejecutar JavaScript malicioso cuando otros usuarios visualizan la p\u00e1gina.&#xa0;Para visualizar un ejemplo, consulte el Aviso de Seguridad de GitHub al que se hace referencia.&#xa0;Commit 5ffa189383dd716f12b56b8cae2ba0d075996cf1 corrige esta vulnerabilidad agregando la directiva v-pre a todas las etiquetas \"(pre)\" durante el renderizado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:requarks:wiki.js:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.191", "matchCriteriaId": "AE1BA27C-823D-4E0A-A478-1E8CE5EC2EC8"}]}]}], "references": [{"url": "https://github.com/Requarks/wiki/commit/5ffa189383dd716f12b56b8cae2ba0d075996cf1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/releases/tag/2.5.191", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/security/advisories/GHSA-6xx4-m8gx-826r", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Requarks/wiki/commit/5ffa189383dd716f12b56b8cae2ba0d075996cf1"}}