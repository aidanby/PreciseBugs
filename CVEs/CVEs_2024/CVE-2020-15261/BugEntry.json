{"buggy_code": ["/*\n * WindowsServiceControl.h - class for managing a Windows service\n *\n * Copyright (c) 2017-2020 Tobias Junghans <tobydox@veyon.io>\n *\n * This file is part of Veyon - https://veyon.io\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program (see COPYING); if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"WindowsCoreFunctions.h\"\n#include \"WindowsServiceControl.h\"\n\n\nWindowsServiceControl::WindowsServiceControl( const QString& name ) :\n\tm_name( name ),\n\tm_serviceManager( nullptr ),\n\tm_serviceHandle( nullptr )\n{\n\tm_serviceManager = OpenSCManager( nullptr, nullptr, SC_MANAGER_ALL_ACCESS );\n\n\tif( m_serviceManager )\n\t{\n\t\tm_serviceHandle = OpenService( m_serviceManager, WindowsCoreFunctions::toConstWCharArray( m_name ),\n\t\t\t\t\t\t\t\t\t   SERVICE_ALL_ACCESS );\n\t\tif( m_serviceHandle == nullptr )\n\t\t{\n\t\t\tvCritical() << \"could not open service\" << m_name;\n\t\t}\n\t}\n\telse\n\t{\n\t\tvCritical() << \"the Service Control Manager could not be contacted - service \" << m_name << \"can't be controlled.\";\n\t}\n}\n\n\n\nWindowsServiceControl::~WindowsServiceControl()\n{\n\tCloseServiceHandle( m_serviceHandle );\n\tCloseServiceHandle( m_serviceManager );\n}\n\n\n\nbool WindowsServiceControl::isRegistered()\n{\n\treturn m_serviceHandle != nullptr;\n}\n\n\n\nbool WindowsServiceControl::isRunning()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tSERVICE_STATUS status;\n\tif( QueryServiceStatus( m_serviceHandle, &status ) )\n\t{\n\t\treturn status.dwCurrentState == SERVICE_RUNNING;\n\t}\n\n\treturn false;\n}\n\n\n\nbool WindowsServiceControl::start()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tSERVICE_STATUS status;\n\tstatus.dwCurrentState = SERVICE_START_PENDING;\n\n\tif( StartService( m_serviceHandle, 0, nullptr ) )\n\t{\n\t\twhile( QueryServiceStatus( m_serviceHandle, &status ) )\n\t\t{\n\t\t\tif( status.dwCurrentState == SERVICE_START_PENDING )\n\t\t\t{\n\t\t\t\tSleep( 1000 );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( status.dwCurrentState != SERVICE_RUNNING )\n\t{\n\t\tvWarning() << \"service\" << m_name << \"could not be started.\";\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n\nbool WindowsServiceControl::stop()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tSERVICE_STATUS status;\n\n\t// Try to stop the service\n\tif( ControlService( m_serviceHandle, SERVICE_CONTROL_STOP, &status ) )\n\t{\n\t\twhile( QueryServiceStatus( m_serviceHandle, &status ) )\n\t\t{\n\t\t\tif( status.dwCurrentState == SERVICE_STOP_PENDING )\n\t\t\t{\n\t\t\t\tSleep( 1000 );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif( status.dwCurrentState != SERVICE_STOPPED )\n\t\t{\n\t\t\tvWarning() << \"service\" << m_name << \"could not be stopped.\";\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\n\nbool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t// SCManager database\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t// name of service\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),// name to display\n\t\t\t\tSERVICE_ALL_ACCESS,\t// desired access\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\t// service type\n\t\t\t\tSERVICE_AUTO_START,\t// start type\n\t\t\t\tSERVICE_ERROR_NORMAL,\t// error control type\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t// service's binary\n\t\t\t\tnullptr,\t\t\t// no load ordering group\n\t\t\t\tnullptr,\t\t\t// no tag identifier\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t// dependencies\n\t\t\t\tnullptr,\t\t\t// LocalSystem account\n\t\t\t\tnullptr );\t\t\t// no password\n\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\n\t// Everything went fine\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}\n\n\n\nbool WindowsServiceControl::uninstall()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tif( stop() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tif( DeleteService( m_serviceHandle ) == false )\n\t{\n\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be uninstalled.\" ).arg( m_name ) );\n\t\treturn false;\n\t}\n\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been uninstalled successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}\n\n\n\nint WindowsServiceControl::startType()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn InvalidStartType;\n\t}\n\n\tLPQUERY_SERVICE_CONFIG serviceConfig{nullptr};\n\tDWORD bufferSize = 0;\n\tDWORD bytesNeeded = 0;\n\n\tif( QueryServiceConfig( m_serviceHandle, nullptr, 0, &bytesNeeded ) == false )\n\t{\n\t\tif( GetLastError() == ERROR_INSUFFICIENT_BUFFER )\n\t\t{\n\t\t\tbufferSize = bytesNeeded;\n\t\t\tserviceConfig = LPQUERY_SERVICE_CONFIG(LocalAlloc(LMEM_FIXED, bufferSize));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn InvalidStartType;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn InvalidStartType;\n\t}\n\n\tif( QueryServiceConfig( m_serviceHandle, serviceConfig, bufferSize, &bytesNeeded ) == false )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tvCritical() << error;\n\t\tLocalFree( serviceConfig );\n\t\treturn InvalidStartType;\n\t}\n\n\tconst auto startType = serviceConfig->dwStartType;\n\n\tLocalFree( serviceConfig );\n\n\treturn startType;\n}\n\n\n\nbool WindowsServiceControl::setStartType( int startType )\n{\n\tif( checkService() == false || startType == InvalidStartType )\n\t{\n\t\treturn false;\n\t}\n\n\tif( ChangeServiceConfig( m_serviceHandle,\n\t\t\t\t\t\t\t SERVICE_NO_CHANGE,\t// dwServiceType\n\t\t\t\t\t\t\t static_cast<DWORD>( startType ),\n\t\t\t\t\t\t\t SERVICE_NO_CHANGE,\t// dwErrorControl\n\t\t\t\t\t\t\t nullptr,\t// lpBinaryPathName\n\t\t\t\t\t\t\t nullptr,\t// lpLoadOrderGroup\n\t\t\t\t\t\t\t nullptr,\t// lpdwTagId\n\t\t\t\t\t\t\t nullptr,\t// lpDependencies\n\t\t\t\t\t\t\t nullptr,\t// lpServiceStartName\n\t\t\t\t\t\t\t nullptr,\t// lpPassword\n\t\t\t\t\t\t\t nullptr\t// lpDisplayName\n\t\t\t\t\t\t\t ) == false )\n\t{\n\t\tvCritical() << qUtf8Printable( tr( \"The start type of service \\\"%1\\\" could not be changed.\" ).arg( m_name ) );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\nbool WindowsServiceControl::checkService() const\n{\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tvCritical() << qUtf8Printable( tr( \"Service \\\"%1\\\" could not be found.\" ).arg( m_name ) );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"], "fixing_code": ["/*\n * WindowsServiceControl.h - class for managing a Windows service\n *\n * Copyright (c) 2017-2020 Tobias Junghans <tobydox@veyon.io>\n *\n * This file is part of Veyon - https://veyon.io\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program (see COPYING); if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n *\n */\n\n#include \"WindowsCoreFunctions.h\"\n#include \"WindowsServiceControl.h\"\n\n\nWindowsServiceControl::WindowsServiceControl( const QString& name ) :\n\tm_name( name ),\n\tm_serviceManager( nullptr ),\n\tm_serviceHandle( nullptr )\n{\n\tm_serviceManager = OpenSCManager( nullptr, nullptr, SC_MANAGER_ALL_ACCESS );\n\n\tif( m_serviceManager )\n\t{\n\t\tm_serviceHandle = OpenService( m_serviceManager, WindowsCoreFunctions::toConstWCharArray( m_name ),\n\t\t\t\t\t\t\t\t\t   SERVICE_ALL_ACCESS );\n\t\tif( m_serviceHandle == nullptr )\n\t\t{\n\t\t\tvCritical() << \"could not open service\" << m_name;\n\t\t}\n\t}\n\telse\n\t{\n\t\tvCritical() << \"the Service Control Manager could not be contacted - service \" << m_name << \"can't be controlled.\";\n\t}\n}\n\n\n\nWindowsServiceControl::~WindowsServiceControl()\n{\n\tCloseServiceHandle( m_serviceHandle );\n\tCloseServiceHandle( m_serviceManager );\n}\n\n\n\nbool WindowsServiceControl::isRegistered()\n{\n\treturn m_serviceHandle != nullptr;\n}\n\n\n\nbool WindowsServiceControl::isRunning()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tSERVICE_STATUS status;\n\tif( QueryServiceStatus( m_serviceHandle, &status ) )\n\t{\n\t\treturn status.dwCurrentState == SERVICE_RUNNING;\n\t}\n\n\treturn false;\n}\n\n\n\nbool WindowsServiceControl::start()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tSERVICE_STATUS status;\n\tstatus.dwCurrentState = SERVICE_START_PENDING;\n\n\tif( StartService( m_serviceHandle, 0, nullptr ) )\n\t{\n\t\twhile( QueryServiceStatus( m_serviceHandle, &status ) )\n\t\t{\n\t\t\tif( status.dwCurrentState == SERVICE_START_PENDING )\n\t\t\t{\n\t\t\t\tSleep( 1000 );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( status.dwCurrentState != SERVICE_RUNNING )\n\t{\n\t\tvWarning() << \"service\" << m_name << \"could not be started.\";\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n\nbool WindowsServiceControl::stop()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tSERVICE_STATUS status;\n\n\t// Try to stop the service\n\tif( ControlService( m_serviceHandle, SERVICE_CONTROL_STOP, &status ) )\n\t{\n\t\twhile( QueryServiceStatus( m_serviceHandle, &status ) )\n\t\t{\n\t\t\tif( status.dwCurrentState == SERVICE_STOP_PENDING )\n\t\t\t{\n\t\t\t\tSleep( 1000 );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif( status.dwCurrentState != SERVICE_STOPPED )\n\t\t{\n\t\t\tvWarning() << \"service\" << m_name << \"could not be stopped.\";\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\n\nbool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tconst auto binaryPath = QStringLiteral(\"\\\"%1\\\"\").arg( QString( filePath ).replace( QLatin1Char('\"'), QString() ) );\n\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t// SCManager database\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t// name of service\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),// name to display\n\t\t\t\tSERVICE_ALL_ACCESS,\t// desired access\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\t// service type\n\t\t\t\tSERVICE_AUTO_START,\t// start type\n\t\t\t\tSERVICE_ERROR_NORMAL,\t// error control type\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( binaryPath ),\t\t// service's binary\n\t\t\t\tnullptr,\t\t\t// no load ordering group\n\t\t\t\tnullptr,\t\t\t// no tag identifier\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t// dependencies\n\t\t\t\tnullptr,\t\t\t// LocalSystem account\n\t\t\t\tnullptr );\t\t\t// no password\n\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\n\t// Everything went fine\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}\n\n\n\nbool WindowsServiceControl::uninstall()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tif( stop() == false )\n\t{\n\t\treturn false;\n\t}\n\n\tif( DeleteService( m_serviceHandle ) == false )\n\t{\n\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be uninstalled.\" ).arg( m_name ) );\n\t\treturn false;\n\t}\n\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been uninstalled successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}\n\n\n\nint WindowsServiceControl::startType()\n{\n\tif( checkService() == false )\n\t{\n\t\treturn InvalidStartType;\n\t}\n\n\tLPQUERY_SERVICE_CONFIG serviceConfig{nullptr};\n\tDWORD bufferSize = 0;\n\tDWORD bytesNeeded = 0;\n\n\tif( QueryServiceConfig( m_serviceHandle, nullptr, 0, &bytesNeeded ) == false )\n\t{\n\t\tif( GetLastError() == ERROR_INSUFFICIENT_BUFFER )\n\t\t{\n\t\t\tbufferSize = bytesNeeded;\n\t\t\tserviceConfig = LPQUERY_SERVICE_CONFIG(LocalAlloc(LMEM_FIXED, bufferSize));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn InvalidStartType;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn InvalidStartType;\n\t}\n\n\tif( QueryServiceConfig( m_serviceHandle, serviceConfig, bufferSize, &bytesNeeded ) == false )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tvCritical() << error;\n\t\tLocalFree( serviceConfig );\n\t\treturn InvalidStartType;\n\t}\n\n\tconst auto startType = serviceConfig->dwStartType;\n\n\tLocalFree( serviceConfig );\n\n\treturn startType;\n}\n\n\n\nbool WindowsServiceControl::setStartType( int startType )\n{\n\tif( checkService() == false || startType == InvalidStartType )\n\t{\n\t\treturn false;\n\t}\n\n\tif( ChangeServiceConfig( m_serviceHandle,\n\t\t\t\t\t\t\t SERVICE_NO_CHANGE,\t// dwServiceType\n\t\t\t\t\t\t\t static_cast<DWORD>( startType ),\n\t\t\t\t\t\t\t SERVICE_NO_CHANGE,\t// dwErrorControl\n\t\t\t\t\t\t\t nullptr,\t// lpBinaryPathName\n\t\t\t\t\t\t\t nullptr,\t// lpLoadOrderGroup\n\t\t\t\t\t\t\t nullptr,\t// lpdwTagId\n\t\t\t\t\t\t\t nullptr,\t// lpDependencies\n\t\t\t\t\t\t\t nullptr,\t// lpServiceStartName\n\t\t\t\t\t\t\t nullptr,\t// lpPassword\n\t\t\t\t\t\t\t nullptr\t// lpDisplayName\n\t\t\t\t\t\t\t ) == false )\n\t{\n\t\tvCritical() << qUtf8Printable( tr( \"The start type of service \\\"%1\\\" could not be changed.\" ).arg( m_name ) );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\nbool WindowsServiceControl::checkService() const\n{\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tvCritical() << qUtf8Printable( tr( \"Service \\\"%1\\\" could not be found.\" ).arg( m_name ) );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"], "filenames": ["plugins/platform/windows/WindowsServiceControl.cpp"], "buggy_code_start_loc": [160], "buggy_code_end_loc": [171], "fixing_code_start_loc": [161], "fixing_code_end_loc": [173], "type": "CWE-428", "message": "On Windows the Veyon Service before version 4.4.2 contains an unquoted service path vulnerability, allowing locally authenticated users with administrative privileges to run malicious executables with LocalSystem privileges. Since Veyon users (both students and teachers) usually don't have administrative privileges, this vulnerability is only dangerous in anyway unsafe setups. The problem has been fixed in version 4.4.2. As a workaround, the exploitation of the vulnerability can be prevented by revoking administrative privileges from all potentially untrustworthy users.", "other": {"cve": {"id": "CVE-2020-15261", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-19T22:15:13.093", "lastModified": "2022-10-18T20:13:47.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "On Windows the Veyon Service before version 4.4.2 contains an unquoted service path vulnerability, allowing locally authenticated users with administrative privileges to run malicious executables with LocalSystem privileges. Since Veyon users (both students and teachers) usually don't have administrative privileges, this vulnerability is only dangerous in anyway unsafe setups. The problem has been fixed in version 4.4.2. As a workaround, the exploitation of the vulnerability can be prevented by revoking administrative privileges from all potentially untrustworthy users."}, {"lang": "es", "value": "En Windows, Veyon Service versiones anteriores a 4.4.2, contiene una vulnerabilidad de ruta de servicio sin comillas, permitiendo a usuarios autenticados localmente con privilegios administrativos correr ejecutables maliciosos con privilegios de LocalSystem.&#xa0;Dado que los usuarios de Veyon (tanto estudiantes como profesores) generalmente no poseen privilegios administrativos, esta vulnerabilidad solo es peligrosa en configuraciones no seguras.&#xa0;El problema ha sido corregido en la versi\u00f3n 4.4.2.&#xa0;Como soluci\u00f3n alternativa, la explotaci\u00f3n de la vulnerabilidad puede ser evitada al revocar privilegios administrativos de todos los usuarios potencialmente no confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-428"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:veyon:veyon:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.2", "matchCriteriaId": "36CEA5B2-FC3F-4794-8882-CF617C45D839"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/162873/Veyon-4.4.1-Unquoted-Service-Path.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/veyon/veyon/commit/f231ec511b9a09f43f49b2c7bb7c60b8046276b1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/veyon/veyon/issues/657", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/veyon/veyon/security/advisories/GHSA-c8cc-x786-hqqp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/48246", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/49925", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/veyon/veyon/commit/f231ec511b9a09f43f49b2c7bb7c60b8046276b1"}}