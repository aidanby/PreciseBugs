{"buggy_code": ["#\n# rencode.pyx\n#\n# Copyright (C) 2010 Andrew Resch <andrewresch@gmail.com>\n#\n# rencode is free software.\n#\n# You may redistribute it and/or modify it under the terms of the\n# GNU General Public License, as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option)\n# any later version.\n#\n# rencode is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with deluge.    If not, write to:\n#     The Free Software Foundation, Inc.,\n#     51 Franklin Street, Fifth Floor\n#     Boston, MA  02110-1301, USA.\n#\n\nfrom __future__ import absolute_import\n\nimport sys\n\npy3 = sys.version_info[0] >= 3\nif py3:\n    unicode = str\n\nfrom cpython cimport bool\nfrom libc.stdlib cimport realloc, free\nfrom libc.string cimport memcpy\n\n__version__ = (\"Cython\", 1, 0, 6)\n\ncdef long long data_length = 0\ncdef bool _decode_utf8 = False\n\n# Determine host byte-order\ncdef bool big_endian = False\ncdef unsigned long number = 1\ncdef char *s = <char *>&number\nif s[0] == 0:\n    big_endian = True\n\ncdef enum:\n    # Default number of bits for serialized floats, either 32 or 64 (also a parameter for dumps()).\n    DEFAULT_FLOAT_BITS = 32\n    # Maximum length of integer when written as base 10 string.\n    MAX_INT_LENGTH = 64\n    # The bencode 'typecodes' such as i, d, etc have been extended and\n    # relocated on the base-256 character set.\n    CHR_LIST    = 59\n    CHR_DICT    = 60\n    CHR_INT     = 61\n    CHR_INT1    = 62\n    CHR_INT2    = 63\n    CHR_INT4    = 64\n    CHR_INT8    = 65\n    CHR_FLOAT32 = 66\n    CHR_FLOAT64 = 44\n    CHR_TRUE    = 67\n    CHR_FALSE   = 68\n    CHR_NONE    = 69\n    CHR_TERM    = 127\n    # Positive integers with value embedded in typecode.\n    INT_POS_FIXED_START = 0\n    INT_POS_FIXED_COUNT = 44\n    # Dictionaries with length embedded in typecode.\n    DICT_FIXED_START = 102\n    DICT_FIXED_COUNT = 25\n    # Negative integers with value embedded in typecode.\n    INT_NEG_FIXED_START = 70\n    INT_NEG_FIXED_COUNT = 32\n    # Strings with length embedded in typecode.\n    STR_FIXED_START = 128\n    STR_FIXED_COUNT = 64\n    # Lists with length embedded in typecode.\n    LIST_FIXED_START = STR_FIXED_START+STR_FIXED_COUNT\n    LIST_FIXED_COUNT = 64\n\ncdef char _float_bits\n\ncdef swap_byte_order_ushort(unsigned short *s):\n    s[0] = (s[0] >> 8) | (s[0] << 8)\n\ncdef swap_byte_order_short(char *c):\n    cdef short s\n    cdef char *p = <char *>&s\n    p[0] = c[1]\n    p[1] = c[0]\n    return s\n\ncdef swap_byte_order_uint(int *i):\n    i[0] = (i[0] >> 24) | ((i[0] << 8) & 0x00FF0000) | ((i[0] >> 8) & 0x0000FF00) | (i[0] << 24)\n\ncdef swap_byte_order_int(char *c):\n    cdef int i\n    cdef char *p = <char *>&i\n    p[0] = c[3]\n    p[1] = c[2]\n    p[2] = c[1]\n    p[3] = c[0]\n    return i\n\ncdef swap_byte_order_ulong_long(long long *l):\n    l[0] = (l[0] >> 56) | \\\n           ((l[0] << 40) & 0x00FF000000000000) | \\\n           ((l[0] << 24) & 0x0000FF0000000000) | \\\n           ((l[0] << 8) & 0x000000FF00000000) | \\\n           ((l[0] >> 8) & 0x00000000FF000000) | \\\n           ((l[0] >> 24) & 0x0000000000FF0000) | \\\n           ((l[0] >> 40) & 0x000000000000FF00) | \\\n           (l[0] << 56)\n\ncdef swap_byte_order_long_long(char *c):\n    cdef long long l\n    cdef char *p = <char *>&l\n    p[0] = c[7]\n    p[1] = c[6]\n    p[2] = c[5]\n    p[3] = c[4]\n    p[4] = c[3]\n    p[5] = c[2]\n    p[6] = c[1]\n    p[7] = c[0]\n    return l\n\ncdef swap_byte_order_float(char *c):\n    cdef float f\n    cdef char *p = <char *>&f\n    p[0] = c[3]\n    p[1] = c[2]\n    p[2] = c[1]\n    p[3] = c[0]\n    return f\n\ncdef swap_byte_order_double(char *c):\n    cdef double d\n    cdef char *p = <char *>&d\n    p[0] = c[7]\n    p[1] = c[6]\n    p[2] = c[5]\n    p[3] = c[4]\n    p[4] = c[3]\n    p[5] = c[2]\n    p[6] = c[1]\n    p[7] = c[0]\n    return d\n\ncdef write_buffer_char(char **buf, unsigned int *pos, char c):\n    buf[0] = <char*>realloc(buf[0], pos[0] + 1)\n    if buf[0] == NULL:\n        raise MemoryError(\"Error in realloc, 1 byte needed\")\n    memcpy(&buf[0][pos[0]], &c, 1)\n    pos[0] += 1\n\ncdef write_buffer(char **buf, unsigned int *pos, void* data, int size):\n    buf[0] = <char*>realloc(buf[0], pos[0] + size)\n    if buf[0] == NULL:\n        raise MemoryError(\"Error in realloc, %d bytes needed\", size)\n    memcpy(&buf[0][pos[0]], data, size)\n    pos[0] += size\n\ncdef encode_char(char **buf, unsigned int *pos, signed char x):\n    if 0 <= x < INT_POS_FIXED_COUNT:\n        write_buffer_char(buf, pos, INT_POS_FIXED_START + x)\n    elif -INT_NEG_FIXED_COUNT <= x < 0:\n        write_buffer_char(buf, pos, INT_NEG_FIXED_START - 1 - x)\n    elif -128 <= x < 128:\n        write_buffer_char(buf, pos, CHR_INT1)\n        write_buffer_char(buf, pos, x)\n\ncdef encode_short(char **buf, unsigned int *pos, short x):\n    write_buffer_char(buf, pos, CHR_INT2)\n    if not big_endian:\n        if x > 0:\n            swap_byte_order_ushort(<unsigned short*>&x)\n        else:\n            x = swap_byte_order_short(<char*>&x)\n\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_int(char **buf, unsigned int *pos, int x):\n    write_buffer_char(buf, pos, CHR_INT4)\n    if not big_endian:\n        if x > 0:\n            swap_byte_order_uint(&x)\n        else:\n            x = swap_byte_order_int(<char*>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_long_long(char **buf, unsigned int *pos, long long x):\n    write_buffer_char(buf, pos, CHR_INT8)\n    if not big_endian:\n        if x > 0:\n            swap_byte_order_ulong_long(&x)\n        else:\n            x = swap_byte_order_long_long(<char*>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_big_number(char **buf, unsigned int *pos, char *x):\n    write_buffer_char(buf, pos, CHR_INT)\n    write_buffer(buf, pos, x, len(x))\n    write_buffer_char(buf, pos, CHR_TERM)\n\ncdef encode_float32(char **buf, unsigned int *pos, float x):\n    write_buffer_char(buf, pos, CHR_FLOAT32)\n    if not big_endian:\n        x = swap_byte_order_float(<char *>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_float64(char **buf, unsigned int *pos, double x):\n    write_buffer_char(buf, pos, CHR_FLOAT64)\n    if not big_endian:\n        x = swap_byte_order_double(<char *>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_str(char **buf, unsigned int *pos, bytes x):\n    cdef char *p\n    cdef int lx = len(x)\n    if lx < STR_FIXED_COUNT:\n        write_buffer_char(buf, pos, STR_FIXED_START + lx)\n        write_buffer(buf, pos, <char *>x, lx)\n    else:\n        s = str(lx) + \":\"\n        if py3:\n            s = s.encode(\"ascii\")\n        p = s\n        write_buffer(buf, pos, p, len(s))\n        write_buffer(buf, pos, <char *>x, lx)\n\ncdef encode_none(char **buf, unsigned int *pos):\n    write_buffer_char(buf, pos, CHR_NONE)\n\ncdef encode_bool(char **buf, unsigned int *pos, bool x):\n    if x:\n        write_buffer_char(buf, pos, CHR_TRUE)\n    else:\n        write_buffer_char(buf, pos, CHR_FALSE)\n\ncdef encode_list(char **buf, unsigned int *pos, x):\n    if len(x) < LIST_FIXED_COUNT:\n        write_buffer_char(buf, pos, LIST_FIXED_START + len(x))\n        for i in x:\n            encode(buf, pos, i)\n    else:\n        write_buffer_char(buf, pos, CHR_LIST)\n        for i in x:\n            encode(buf, pos, i)\n        write_buffer_char(buf, pos, CHR_TERM)\n\ncdef encode_dict(char **buf, unsigned int *pos, x):\n    if len(x) < DICT_FIXED_COUNT:\n        write_buffer_char(buf, pos, DICT_FIXED_START + len(x))\n        for k, v in x.items():\n            encode(buf, pos, k)\n            encode(buf, pos, v)\n    else:\n        write_buffer_char(buf, pos, CHR_DICT)\n        for k, v in x.items():\n            encode(buf, pos, k)\n            encode(buf, pos, v)\n        write_buffer_char(buf, pos, CHR_TERM)\n\ncdef object MAX_SIGNED_INT = 2**31\ncdef object MIN_SIGNED_INT = -MAX_SIGNED_INT\n#note: negating the Python value avoids compiler problems\n#(negating the \"long long\" constant can make it unsigned with some compilers!)\ncdef object MAX_SIGNED_LONGLONG = int(2**63)\ncdef object MIN_SIGNED_LONGLONG = -MAX_SIGNED_LONGLONG\n\ncdef encode(char **buf, unsigned int *pos, data):\n    t = type(data)\n    if t == int or t == long:\n        if -128 <= data < 128:\n            encode_char(buf, pos, data)\n        elif -32768 <= data < 32768:\n            encode_short(buf, pos, data)\n        elif MIN_SIGNED_INT <= data < MAX_SIGNED_INT:\n            encode_int(buf, pos, data)\n        elif MIN_SIGNED_LONGLONG <= data < MAX_SIGNED_LONGLONG:\n            encode_long_long(buf, pos, data)\n        else:\n            s = str(data)\n            if py3:\n                s = s.encode(\"ascii\")\n            if len(s) >= MAX_INT_LENGTH:\n                raise ValueError(\"Number is longer than %d characters\" % MAX_INT_LENGTH)\n            encode_big_number(buf, pos, s)\n    elif t == float:\n        if _float_bits == 32:\n            encode_float32(buf, pos, data)\n        elif _float_bits == 64:\n            encode_float64(buf, pos, data)\n        else:\n            raise ValueError('Float bits (%d) is not 32 or 64' % _float_bits)\n\n    elif t == bytes:\n        encode_str(buf, pos, data)\n\n    elif t == unicode:\n        u = data.encode(\"utf8\")\n        encode_str(buf, pos, u)\n\n    elif t == type(None):\n        encode_none(buf, pos)\n\n    elif t == bool:\n        encode_bool(buf, pos, data)\n\n    elif t == list or t == tuple:\n        encode_list(buf, pos, data)\n\n    elif t == dict:\n        encode_dict(buf, pos, data)\n\n    else:\n        raise Exception(\"type %s not handled\" % t)\n\ndef dumps(data, float_bits=DEFAULT_FLOAT_BITS):\n    \"\"\"\n    Encode the object data into a string.\n\n    :param data: the object to encode\n    :type data: object\n\n    \"\"\"\n    global _float_bits\n    _float_bits = float_bits\n    cdef char *buf = NULL\n    cdef unsigned int pos = 0\n    encode(&buf, &pos, data)\n    ret = buf[:pos]\n    free(buf)\n    return ret\n\ncdef decode_char(char *data, unsigned int *pos):\n    cdef signed char c\n    check_pos(data, pos[0]+1)\n    memcpy(&c, &data[pos[0]+1], 1)\n    pos[0] += 2\n    return c\n\ncdef decode_short(char *data, unsigned int *pos):\n    cdef short s\n    check_pos(data, pos[0]+2)\n    memcpy(&s, &data[pos[0]+1], 2)\n    pos[0] += 3\n    if not big_endian:\n        s = swap_byte_order_short(<char*>&s)\n    return s\n\ncdef decode_int(char *data, unsigned int *pos):\n    cdef int i\n    check_pos(data, pos[0]+4)\n    memcpy(&i, &data[pos[0]+1], 4)\n    pos[0] += 5\n    if not big_endian:\n        i = swap_byte_order_int(<char*>&i)\n    return i\n\ncdef decode_long_long(char *data, unsigned int *pos):\n    cdef long long l\n    check_pos(data, pos[0]+8)\n    memcpy(&l, &data[pos[0]+1], 8)\n    pos[0] += 9\n    if not big_endian:\n        l = swap_byte_order_long_long(<char*>&l)\n    return l\n\ncdef decode_fixed_pos_int(char *data, unsigned int *pos):\n    pos[0] += 1\n    return data[pos[0] - 1] - INT_POS_FIXED_START\n\ncdef decode_fixed_neg_int(char *data, unsigned int *pos):\n    pos[0] += 1\n    return (data[pos[0] - 1] - INT_NEG_FIXED_START + 1)*-1\n\ncdef decode_big_number(char *data, unsigned int *pos):\n    pos[0] += 1\n    cdef int x = 18\n    check_pos(data, pos[0]+x)\n    while (data[pos[0]+x] != CHR_TERM):\n        x += 1\n        if x >= MAX_INT_LENGTH:\n            raise ValueError(\n                \"Number is longer than %d characters\" % MAX_INT_LENGTH)\n        check_pos(data, pos[0]+x)\n\n    big_number = int(data[pos[0]:pos[0]+x])\n    pos[0] += x + 1\n    return big_number\n\ncdef decode_float32(char *data, unsigned int *pos):\n    cdef float f\n    check_pos(data, pos[0]+4)\n    memcpy(&f, &data[pos[0]+1], 4)\n    pos[0] += 5\n    if not big_endian:\n        f = swap_byte_order_float(<char*>&f)\n    return f\n\ncdef decode_float64(char *data, unsigned int *pos):\n    cdef double d\n    check_pos(data, pos[0]+8)\n    memcpy(&d, &data[pos[0]+1], 8)\n    pos[0] += 9\n    if not big_endian:\n        d = swap_byte_order_double(<char*>&d)\n    return d\n\ncdef decode_fixed_str(char *data, unsigned int *pos):\n    cdef unsigned char size = data[pos[0]] - STR_FIXED_START + 1\n    check_pos(data, pos[0] + size - 1)\n    s = data[pos[0]+1:pos[0] + size]\n    pos[0] += size\n    return s\n\ncdef decode_str(char *data, unsigned int *pos):\n    cdef unsigned int x = 1\n    check_pos(data, pos[0]+x)\n    while (data[pos[0]+x] != 58):\n        x += 1\n        check_pos(data, pos[0]+x)\n\n    cdef int size = int(data[pos[0]:pos[0]+x])\n    pos[0] += x + 1\n    check_pos(data, pos[0] + size - 1)\n    s = data[pos[0]:pos[0] + size]\n    pos[0] += size\n    return s\n\ncdef decode_fixed_list(char *data, unsigned int *pos):\n    l = []\n    size = <unsigned char>data[pos[0]] - LIST_FIXED_START\n    pos[0] += 1\n    cdef int i\n    for i in range(size):\n        l.append(decode(data, pos))\n    return tuple(l)\n\ncdef decode_list(char *data, unsigned int *pos):\n    l = []\n    pos[0] += 1\n    while data[pos[0]] != CHR_TERM:\n        l.append(decode(data, pos))\n    pos[0] += 1\n    return tuple(l)\n\ncdef decode_fixed_dict(char *data, unsigned int *pos):\n    d = {}\n    size = <unsigned char>data[pos[0]] - DICT_FIXED_START\n    pos[0] += 1\n    cdef int i\n    for i in range(size):\n        key = decode(data, pos)\n        value = decode(data, pos)\n        d[key] = value\n    return d\n\ncdef decode_dict(char *data, unsigned int *pos):\n    d = {}\n    pos[0] += 1\n    check_pos(data, pos[0])\n    while data[pos[0]] != CHR_TERM:\n        key = decode(data, pos)\n        value = decode(data, pos)\n        d[key] = value\n    pos[0] += 1\n    return d\n\ncdef check_pos(char *data, unsigned int pos):\n    if pos >= data_length:\n        raise IndexError(\"Tried to access data[%d] but data len is: %d\" % (pos, data_length))\n\ncdef decode(char *data, unsigned int *pos):\n    if pos[0] >= data_length:\n        raise IndexError(\"Malformed rencoded string: data_length: %d pos: %d\" % (data_length, pos[0]))\n\n    cdef unsigned char typecode = data[pos[0]]\n    if typecode == CHR_INT1:\n        return decode_char(data, pos)\n    elif typecode == CHR_INT2:\n        return decode_short(data, pos)\n    elif typecode == CHR_INT4:\n        return decode_int(data, pos)\n    elif typecode == CHR_INT8:\n        return decode_long_long(data, pos)\n    elif INT_POS_FIXED_START <= typecode < INT_POS_FIXED_START + INT_POS_FIXED_COUNT:\n        return decode_fixed_pos_int(data, pos)\n    elif INT_NEG_FIXED_START <= typecode < INT_NEG_FIXED_START + INT_NEG_FIXED_COUNT:\n        return decode_fixed_neg_int(data, pos)\n    elif typecode == CHR_INT:\n        return decode_big_number(data, pos)\n    elif typecode == CHR_FLOAT32:\n        return decode_float32(data, pos)\n    elif typecode == CHR_FLOAT64:\n        return decode_float64(data, pos)\n    elif STR_FIXED_START <= typecode < STR_FIXED_START + STR_FIXED_COUNT:\n        s = decode_fixed_str(data, pos)\n        if _decode_utf8:\n            s = s.decode(\"utf8\")\n        return s\n    elif 49 <= typecode <= 57:\n        s = decode_str(data, pos)\n        if _decode_utf8:\n            s = s.decode(\"utf8\")\n        return s\n    elif typecode == CHR_NONE:\n        pos[0] += 1\n        return None\n    elif typecode == CHR_TRUE:\n        pos[0] += 1\n        return True\n    elif typecode == CHR_FALSE:\n        pos[0] += 1\n        return False\n    elif LIST_FIXED_START <= typecode < LIST_FIXED_START + LIST_FIXED_COUNT:\n        return decode_fixed_list(data, pos)\n    elif typecode == CHR_LIST:\n        return decode_list(data, pos)\n    elif DICT_FIXED_START <= typecode < DICT_FIXED_START + DICT_FIXED_COUNT:\n        return decode_fixed_dict(data, pos)\n    elif typecode == CHR_DICT:\n        return decode_dict(data, pos)\n\ndef loads(data, decode_utf8=False):\n    \"\"\"\n    Decodes the string into an object\n\n    :param data: the string to decode\n    :type data: string\n    :param decode_utf8: if True, will attempt to decode all str into unicode\n                        objects using utf8\n    :type decode_utf8: bool\n\n    \"\"\"\n    cdef unsigned int pos = 0\n    global data_length\n    data_length = len(data)\n    global _decode_utf8\n    _decode_utf8=decode_utf8\n    return decode(data, &pos)\n", "# -*- coding: utf-8 -*-\n#\n# test_rencode.py\n#\n# Copyright (C) 2010 Andrew Resch <andrewresch@gmail.com>\n#\n# rencode is free software.\n#\n# You may redistribute it and/or modify it under the terms of the\n# GNU General Public License, as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option)\n# any later version.\n#\n# rencode is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with rencode.    If not, write to:\n#     The Free Software Foundation, Inc.,\n#     51 Franklin Street, Fifth Floor\n#     Boston, MA  02110-1301, USA.\n#\n\nimport sys\n\nimport unittest\nfrom rencode import _rencode as rencode\nfrom rencode import rencode_orig\n\n\n# Hack to deal with python 2 and 3 differences with unicode literals.\nif sys.version < \"3\":\n    import codecs\n\n    def u(x):\n        return codecs.unicode_escape_decode(x)[0]\n\n\nelse:\n    unicode = str\n\n    def u(x):\n        return x\n\n\nclass TestRencode(unittest.TestCase):\n    def test_encode_fixed_pos_int(self):\n        self.assertEqual(rencode.dumps(1), rencode_orig.dumps(1))\n        self.assertEqual(rencode.dumps(40), rencode_orig.dumps(40))\n\n    def test_encode_fixed_neg_int(self):\n        self.assertEqual(rencode.dumps(-10), rencode_orig.dumps(-10))\n        self.assertEqual(rencode.dumps(-29), rencode_orig.dumps(-29))\n\n    def test_encode_int_char_size(self):\n        self.assertEqual(rencode.dumps(100), rencode_orig.dumps(100))\n        self.assertEqual(rencode.dumps(-100), rencode_orig.dumps(-100))\n\n    def test_encode_int_short_size(self):\n        self.assertEqual(rencode.dumps(27123), rencode_orig.dumps(27123))\n        self.assertEqual(rencode.dumps(-27123), rencode_orig.dumps(-27123))\n\n    def test_encode_int_int_size(self):\n        self.assertEqual(rencode.dumps(7483648), rencode_orig.dumps(7483648))\n        self.assertEqual(rencode.dumps(-7483648), rencode_orig.dumps(-7483648))\n\n    def test_encode_int_long_long_size(self):\n        self.assertEqual(\n            rencode.dumps(8223372036854775808), rencode_orig.dumps(8223372036854775808)\n        )\n        self.assertEqual(\n            rencode.dumps(-8223372036854775808),\n            rencode_orig.dumps(-8223372036854775808),\n        )\n\n    def test_encode_int_big_number(self):\n        n = int(\"9\" * 62)\n        self.assertEqual(rencode.dumps(n), rencode_orig.dumps(n))\n        self.assertRaises(ValueError, rencode.dumps, int(\"9\" * 65))\n\n    def test_encode_float_32bit(self):\n        self.assertEqual(rencode.dumps(1234.56), rencode_orig.dumps(1234.56))\n\n    def test_encode_float_64bit(self):\n        self.assertEqual(rencode.dumps(1234.56, 64), rencode_orig.dumps(1234.56, 64))\n\n    def test_encode_float_invalid_size(self):\n        self.assertRaises(ValueError, rencode.dumps, 1234.56, 36)\n\n    def test_encode_fixed_str(self):\n        self.assertEqual(rencode.dumps(b\"foobarbaz\"), rencode_orig.dumps(b\"foobarbaz\"))\n\n    def test_encode_str(self):\n        self.assertEqual(rencode.dumps(b\"f\" * 255), rencode_orig.dumps(b\"f\" * 255))\n        self.assertEqual(rencode.dumps(b\"\\0\"), rencode_orig.dumps(b\"\\0\"))\n\n    def test_encode_unicode(self):\n        self.assertEqual(rencode.dumps(u(\"f\u00f6\u00f6bar\")), rencode_orig.dumps(u(\"f\u00f6\u00f6bar\")))\n\n    def test_encode_none(self):\n        self.assertEqual(rencode.dumps(None), rencode_orig.dumps(None))\n\n    def test_encode_bool(self):\n        self.assertEqual(rencode.dumps(True), rencode_orig.dumps(True))\n        self.assertEqual(rencode.dumps(False), rencode_orig.dumps(False))\n\n    def test_encode_fixed_list(self):\n        l = [100, -234.01, b\"foobar\", u(\"b\u00e4z\")] * 4\n        self.assertEqual(rencode.dumps(l), rencode_orig.dumps(l))\n\n    def test_encode_list(self):\n        l = [100, -234.01, b\"foobar\", u(\"b\u00e4z\")] * 80\n        self.assertEqual(rencode.dumps(l), rencode_orig.dumps(l))\n\n    def test_encode_fixed_dict(self):\n        s = b\"abcdefghijk\"\n        d = dict(zip(s, [1234] * len(s)))\n        self.assertEqual(rencode.dumps(d), rencode_orig.dumps(d))\n\n    def test_encode_dict(self):\n        s = b\"abcdefghijklmnopqrstuvwxyz1234567890\"\n        d = dict(zip(s, [1234] * len(s)))\n        self.assertEqual(rencode.dumps(d), rencode_orig.dumps(d))\n\n    def test_decode_fixed_pos_int(self):\n        self.assertEqual(rencode.loads(rencode.dumps(10)), 10)\n\n    def test_decode_fixed_neg_int(self):\n        self.assertEqual(rencode.loads(rencode.dumps(-10)), -10)\n\n    def test_decode_char(self):\n        self.assertEqual(rencode.loads(rencode.dumps(100)), 100)\n        self.assertEqual(rencode.loads(rencode.dumps(-100)), -100)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([62])))\n\n    def test_decode_short(self):\n        self.assertEqual(rencode.loads(rencode.dumps(27123)), 27123)\n        self.assertEqual(rencode.loads(rencode.dumps(-27123)), -27123)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([63])))\n\n    def test_decode_int(self):\n        self.assertEqual(rencode.loads(rencode.dumps(7483648)), 7483648)\n        self.assertEqual(rencode.loads(rencode.dumps(-7483648)), -7483648)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([64])))\n\n    def test_decode_long_long(self):\n        self.assertEqual(\n            rencode.loads(rencode.dumps(8223372036854775808)), 8223372036854775808\n        )\n        self.assertEqual(\n            rencode.loads(rencode.dumps(-8223372036854775808)), -8223372036854775808\n        )\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([65])))\n\n    def test_decode_int_big_number(self):\n        n = int(b\"9\" * 62)\n        toobig = \"={x}\\x7f\".format(x=\"9\" * 65).encode()\n        self.assertEqual(rencode.loads(rencode.dumps(n)), n)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([61])))\n        self.assertRaises(ValueError, rencode.loads, toobig)\n\n    def test_decode_float_32bit(self):\n        f = rencode.dumps(1234.56)\n        self.assertEqual(rencode.loads(f), rencode_orig.loads(f))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([66])))\n\n    def test_decode_float_64bit(self):\n        f = rencode.dumps(1234.56, 64)\n        self.assertEqual(rencode.loads(f), rencode_orig.loads(f))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([44])))\n\n    def test_decode_fixed_str(self):\n        self.assertEqual(rencode.loads(rencode.dumps(b\"foobarbaz\")), b\"foobarbaz\")\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([130])))\n\n    def test_decode_str(self):\n        self.assertEqual(rencode.loads(rencode.dumps(b\"f\" * 255)), b\"f\" * 255)\n        self.assertRaises(IndexError, rencode.loads, b\"50\")\n\n    def test_decode_unicode(self):\n        self.assertEqual(\n            rencode.loads(rencode.dumps(u(\"f\u00f6\u00f6bar\"))), u(\"f\u00f6\u00f6bar\").encode(\"utf8\")\n        )\n\n    def test_decode_none(self):\n        self.assertEqual(rencode.loads(rencode.dumps(None)), None)\n\n    def test_decode_bool(self):\n        self.assertEqual(rencode.loads(rencode.dumps(True)), True)\n        self.assertEqual(rencode.loads(rencode.dumps(False)), False)\n\n    def test_decode_fixed_list(self):\n        l = [100, False, b\"foobar\", u(\"b\u00e4z\").encode(\"utf8\")] * 4\n        self.assertEqual(rencode.loads(rencode.dumps(l)), tuple(l))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([194])))\n\n    def test_decode_list(self):\n        l = [100, False, b\"foobar\", u(\"b\u00e4z\").encode(\"utf8\")] * 80\n        self.assertEqual(rencode.loads(rencode.dumps(l)), tuple(l))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([59])))\n\n    def test_decode_fixed_dict(self):\n        s = b\"abcdefghijk\"\n        d = dict(zip(s, [1234] * len(s)))\n        self.assertEqual(rencode.loads(rencode.dumps(d)), d)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([104])))\n\n    def test_decode_dict(self):\n        s = b\"abcdefghijklmnopqrstuvwxyz1234567890\"\n        d = dict(zip(s, [b\"foo\" * 120] * len(s)))\n        d2 = {b\"foo\": d, b\"bar\": d, b\"baz\": d}\n        self.assertEqual(rencode.loads(rencode.dumps(d2)), d2)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([60])))\n\n    def test_decode_str_bytes(self):\n        b = [202, 132, 100, 114, 97, 119, 1, 0, 0, 63, 1, 242, 63]\n        d = bytes(bytearray(b))\n        self.assertEqual(rencode.loads(rencode.dumps(d)), d)\n\n    def test_decode_str_nullbytes(self):\n        b = (\n            202,\n            132,\n            100,\n            114,\n            97,\n            119,\n            1,\n            0,\n            0,\n            63,\n            1,\n            242,\n            63,\n            1,\n            60,\n            132,\n            120,\n            50,\n            54,\n            52,\n            49,\n            51,\n            48,\n            58,\n            0,\n            0,\n            0,\n            1,\n            65,\n            154,\n            35,\n            215,\n            48,\n            204,\n            4,\n            35,\n            242,\n            3,\n            122,\n            218,\n            67,\n            192,\n            127,\n            40,\n            241,\n            127,\n            2,\n            86,\n            240,\n            63,\n            135,\n            177,\n            23,\n            119,\n            63,\n            31,\n            226,\n            248,\n            19,\n            13,\n            192,\n            111,\n            74,\n            126,\n            2,\n            15,\n            240,\n            31,\n            239,\n            48,\n            85,\n            238,\n            159,\n            155,\n            197,\n            241,\n            23,\n            119,\n            63,\n            2,\n            23,\n            245,\n            63,\n            24,\n            240,\n            86,\n            36,\n            176,\n            15,\n            187,\n            185,\n            248,\n            242,\n            255,\n            0,\n            126,\n            123,\n            141,\n            206,\n            60,\n            188,\n            1,\n            27,\n            254,\n            141,\n            169,\n            132,\n            93,\n            220,\n            252,\n            121,\n            184,\n            8,\n            31,\n            224,\n            63,\n            244,\n            226,\n            75,\n            224,\n            119,\n            135,\n            229,\n            248,\n            3,\n            243,\n            248,\n            220,\n            227,\n            203,\n            193,\n            3,\n            224,\n            127,\n            47,\n            134,\n            59,\n            5,\n            99,\n            249,\n            254,\n            35,\n            196,\n            127,\n            17,\n            252,\n            71,\n            136,\n            254,\n            35,\n            196,\n            112,\n            4,\n            177,\n            3,\n            63,\n            5,\n            220,\n        )\n        d = bytes(bytearray(b))\n        self.assertEqual(rencode.loads(rencode.dumps(d)), d)\n\n    def test_decode_utf8(self):\n        s = b\"foobarbaz\"\n        # no assertIsInstance with python2.6\n        d = rencode.loads(rencode.dumps(s), decode_utf8=True)\n        if not isinstance(d, unicode):\n            self.fail(\"%s is not an instance of %r\" % (repr(d), unicode))\n        s = rencode.dumps(b\"\\x56\\xe4foo\\xc3\")\n        self.assertRaises(UnicodeDecodeError, rencode.loads, s, decode_utf8=True)\n\n    def test_version_exposed(self):\n        assert rencode.__version__\n        assert rencode_orig.__version__\n        self.assertEqual(\n            rencode.__version__[1:],\n            rencode_orig.__version__[1:],\n            \"version number does not match\",\n        )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"], "fixing_code": ["#\n# rencode.pyx\n#\n# Copyright (C) 2010 Andrew Resch <andrewresch@gmail.com>\n#\n# rencode is free software.\n#\n# You may redistribute it and/or modify it under the terms of the\n# GNU General Public License, as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option)\n# any later version.\n#\n# rencode is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with deluge.    If not, write to:\n#     The Free Software Foundation, Inc.,\n#     51 Franklin Street, Fifth Floor\n#     Boston, MA  02110-1301, USA.\n#\n\nfrom __future__ import absolute_import\n\nimport sys\n\npy3 = sys.version_info[0] >= 3\nif py3:\n    unicode = str\n\nfrom cpython cimport bool\nfrom libc.stdlib cimport realloc, free\nfrom libc.string cimport memcpy\n\n__version__ = (\"Cython\", 1, 0, 6)\n\ncdef long long data_length = 0\ncdef bool _decode_utf8 = False\n\n# Determine host byte-order\ncdef bool big_endian = False\ncdef unsigned long number = 1\ncdef char *s = <char *>&number\nif s[0] == 0:\n    big_endian = True\n\ncdef enum:\n    # Default number of bits for serialized floats, either 32 or 64 (also a parameter for dumps()).\n    DEFAULT_FLOAT_BITS = 32\n    # Maximum length of integer when written as base 10 string.\n    MAX_INT_LENGTH = 64\n    # The bencode 'typecodes' such as i, d, etc have been extended and\n    # relocated on the base-256 character set.\n    CHR_LIST    = 59\n    CHR_DICT    = 60\n    CHR_INT     = 61\n    CHR_INT1    = 62\n    CHR_INT2    = 63\n    CHR_INT4    = 64\n    CHR_INT8    = 65\n    CHR_FLOAT32 = 66\n    CHR_FLOAT64 = 44\n    CHR_TRUE    = 67\n    CHR_FALSE   = 68\n    CHR_NONE    = 69\n    CHR_TERM    = 127\n    # Positive integers with value embedded in typecode.\n    INT_POS_FIXED_START = 0\n    INT_POS_FIXED_COUNT = 44\n    # Dictionaries with length embedded in typecode.\n    DICT_FIXED_START = 102\n    DICT_FIXED_COUNT = 25\n    # Negative integers with value embedded in typecode.\n    INT_NEG_FIXED_START = 70\n    INT_NEG_FIXED_COUNT = 32\n    # Strings with length embedded in typecode.\n    STR_FIXED_START = 128\n    STR_FIXED_COUNT = 64\n    # Lists with length embedded in typecode.\n    LIST_FIXED_START = STR_FIXED_START+STR_FIXED_COUNT\n    LIST_FIXED_COUNT = 64\n\ncdef char _float_bits\n\ncdef swap_byte_order_ushort(unsigned short *s):\n    s[0] = (s[0] >> 8) | (s[0] << 8)\n\ncdef swap_byte_order_short(char *c):\n    cdef short s\n    cdef char *p = <char *>&s\n    p[0] = c[1]\n    p[1] = c[0]\n    return s\n\ncdef swap_byte_order_uint(int *i):\n    i[0] = (i[0] >> 24) | ((i[0] << 8) & 0x00FF0000) | ((i[0] >> 8) & 0x0000FF00) | (i[0] << 24)\n\ncdef swap_byte_order_int(char *c):\n    cdef int i\n    cdef char *p = <char *>&i\n    p[0] = c[3]\n    p[1] = c[2]\n    p[2] = c[1]\n    p[3] = c[0]\n    return i\n\ncdef swap_byte_order_ulong_long(long long *l):\n    l[0] = (l[0] >> 56) | \\\n           ((l[0] << 40) & 0x00FF000000000000) | \\\n           ((l[0] << 24) & 0x0000FF0000000000) | \\\n           ((l[0] << 8) & 0x000000FF00000000) | \\\n           ((l[0] >> 8) & 0x00000000FF000000) | \\\n           ((l[0] >> 24) & 0x0000000000FF0000) | \\\n           ((l[0] >> 40) & 0x000000000000FF00) | \\\n           (l[0] << 56)\n\ncdef swap_byte_order_long_long(char *c):\n    cdef long long l\n    cdef char *p = <char *>&l\n    p[0] = c[7]\n    p[1] = c[6]\n    p[2] = c[5]\n    p[3] = c[4]\n    p[4] = c[3]\n    p[5] = c[2]\n    p[6] = c[1]\n    p[7] = c[0]\n    return l\n\ncdef swap_byte_order_float(char *c):\n    cdef float f\n    cdef char *p = <char *>&f\n    p[0] = c[3]\n    p[1] = c[2]\n    p[2] = c[1]\n    p[3] = c[0]\n    return f\n\ncdef swap_byte_order_double(char *c):\n    cdef double d\n    cdef char *p = <char *>&d\n    p[0] = c[7]\n    p[1] = c[6]\n    p[2] = c[5]\n    p[3] = c[4]\n    p[4] = c[3]\n    p[5] = c[2]\n    p[6] = c[1]\n    p[7] = c[0]\n    return d\n\ncdef write_buffer_char(char **buf, unsigned int *pos, char c):\n    buf[0] = <char*>realloc(buf[0], pos[0] + 1)\n    if buf[0] == NULL:\n        raise MemoryError(\"Error in realloc, 1 byte needed\")\n    memcpy(&buf[0][pos[0]], &c, 1)\n    pos[0] += 1\n\ncdef write_buffer(char **buf, unsigned int *pos, void* data, int size):\n    buf[0] = <char*>realloc(buf[0], pos[0] + size)\n    if buf[0] == NULL:\n        raise MemoryError(\"Error in realloc, %d bytes needed\", size)\n    memcpy(&buf[0][pos[0]], data, size)\n    pos[0] += size\n\ncdef encode_char(char **buf, unsigned int *pos, signed char x):\n    if 0 <= x < INT_POS_FIXED_COUNT:\n        write_buffer_char(buf, pos, INT_POS_FIXED_START + x)\n    elif -INT_NEG_FIXED_COUNT <= x < 0:\n        write_buffer_char(buf, pos, INT_NEG_FIXED_START - 1 - x)\n    elif -128 <= x < 128:\n        write_buffer_char(buf, pos, CHR_INT1)\n        write_buffer_char(buf, pos, x)\n\ncdef encode_short(char **buf, unsigned int *pos, short x):\n    write_buffer_char(buf, pos, CHR_INT2)\n    if not big_endian:\n        if x > 0:\n            swap_byte_order_ushort(<unsigned short*>&x)\n        else:\n            x = swap_byte_order_short(<char*>&x)\n\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_int(char **buf, unsigned int *pos, int x):\n    write_buffer_char(buf, pos, CHR_INT4)\n    if not big_endian:\n        if x > 0:\n            swap_byte_order_uint(&x)\n        else:\n            x = swap_byte_order_int(<char*>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_long_long(char **buf, unsigned int *pos, long long x):\n    write_buffer_char(buf, pos, CHR_INT8)\n    if not big_endian:\n        if x > 0:\n            swap_byte_order_ulong_long(&x)\n        else:\n            x = swap_byte_order_long_long(<char*>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_big_number(char **buf, unsigned int *pos, char *x):\n    write_buffer_char(buf, pos, CHR_INT)\n    write_buffer(buf, pos, x, len(x))\n    write_buffer_char(buf, pos, CHR_TERM)\n\ncdef encode_float32(char **buf, unsigned int *pos, float x):\n    write_buffer_char(buf, pos, CHR_FLOAT32)\n    if not big_endian:\n        x = swap_byte_order_float(<char *>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_float64(char **buf, unsigned int *pos, double x):\n    write_buffer_char(buf, pos, CHR_FLOAT64)\n    if not big_endian:\n        x = swap_byte_order_double(<char *>&x)\n    write_buffer(buf, pos, &x, sizeof(x))\n\ncdef encode_str(char **buf, unsigned int *pos, bytes x):\n    cdef char *p\n    cdef int lx = len(x)\n    if lx < STR_FIXED_COUNT:\n        write_buffer_char(buf, pos, STR_FIXED_START + lx)\n        write_buffer(buf, pos, <char *>x, lx)\n    else:\n        s = str(lx) + \":\"\n        if py3:\n            s = s.encode(\"ascii\")\n        p = s\n        write_buffer(buf, pos, p, len(s))\n        write_buffer(buf, pos, <char *>x, lx)\n\ncdef encode_none(char **buf, unsigned int *pos):\n    write_buffer_char(buf, pos, CHR_NONE)\n\ncdef encode_bool(char **buf, unsigned int *pos, bool x):\n    if x:\n        write_buffer_char(buf, pos, CHR_TRUE)\n    else:\n        write_buffer_char(buf, pos, CHR_FALSE)\n\ncdef encode_list(char **buf, unsigned int *pos, x):\n    if len(x) < LIST_FIXED_COUNT:\n        write_buffer_char(buf, pos, LIST_FIXED_START + len(x))\n        for i in x:\n            encode(buf, pos, i)\n    else:\n        write_buffer_char(buf, pos, CHR_LIST)\n        for i in x:\n            encode(buf, pos, i)\n        write_buffer_char(buf, pos, CHR_TERM)\n\ncdef encode_dict(char **buf, unsigned int *pos, x):\n    if len(x) < DICT_FIXED_COUNT:\n        write_buffer_char(buf, pos, DICT_FIXED_START + len(x))\n        for k, v in x.items():\n            encode(buf, pos, k)\n            encode(buf, pos, v)\n    else:\n        write_buffer_char(buf, pos, CHR_DICT)\n        for k, v in x.items():\n            encode(buf, pos, k)\n            encode(buf, pos, v)\n        write_buffer_char(buf, pos, CHR_TERM)\n\ncdef object MAX_SIGNED_INT = 2**31\ncdef object MIN_SIGNED_INT = -MAX_SIGNED_INT\n#note: negating the Python value avoids compiler problems\n#(negating the \"long long\" constant can make it unsigned with some compilers!)\ncdef object MAX_SIGNED_LONGLONG = int(2**63)\ncdef object MIN_SIGNED_LONGLONG = -MAX_SIGNED_LONGLONG\n\ncdef encode(char **buf, unsigned int *pos, data):\n    t = type(data)\n    if t == int or t == long:\n        if -128 <= data < 128:\n            encode_char(buf, pos, data)\n        elif -32768 <= data < 32768:\n            encode_short(buf, pos, data)\n        elif MIN_SIGNED_INT <= data < MAX_SIGNED_INT:\n            encode_int(buf, pos, data)\n        elif MIN_SIGNED_LONGLONG <= data < MAX_SIGNED_LONGLONG:\n            encode_long_long(buf, pos, data)\n        else:\n            s = str(data)\n            if py3:\n                s = s.encode(\"ascii\")\n            if len(s) >= MAX_INT_LENGTH:\n                raise ValueError(\"Number is longer than %d characters\" % MAX_INT_LENGTH)\n            encode_big_number(buf, pos, s)\n    elif t == float:\n        if _float_bits == 32:\n            encode_float32(buf, pos, data)\n        elif _float_bits == 64:\n            encode_float64(buf, pos, data)\n        else:\n            raise ValueError('Float bits (%d) is not 32 or 64' % _float_bits)\n\n    elif t == bytes:\n        encode_str(buf, pos, data)\n\n    elif t == unicode:\n        u = data.encode(\"utf8\")\n        encode_str(buf, pos, u)\n\n    elif t == type(None):\n        encode_none(buf, pos)\n\n    elif t == bool:\n        encode_bool(buf, pos, data)\n\n    elif t == list or t == tuple:\n        encode_list(buf, pos, data)\n\n    elif t == dict:\n        encode_dict(buf, pos, data)\n\n    else:\n        raise Exception(\"type %s not handled\" % t)\n\ndef dumps(data, float_bits=DEFAULT_FLOAT_BITS):\n    \"\"\"\n    Encode the object data into a string.\n\n    :param data: the object to encode\n    :type data: object\n\n    \"\"\"\n    global _float_bits\n    _float_bits = float_bits\n    cdef char *buf = NULL\n    cdef unsigned int pos = 0\n    encode(&buf, &pos, data)\n    ret = buf[:pos]\n    free(buf)\n    return ret\n\ncdef decode_char(char *data, unsigned int *pos):\n    cdef signed char c\n    check_pos(data, pos[0]+1)\n    memcpy(&c, &data[pos[0]+1], 1)\n    pos[0] += 2\n    return c\n\ncdef decode_short(char *data, unsigned int *pos):\n    cdef short s\n    check_pos(data, pos[0]+2)\n    memcpy(&s, &data[pos[0]+1], 2)\n    pos[0] += 3\n    if not big_endian:\n        s = swap_byte_order_short(<char*>&s)\n    return s\n\ncdef decode_int(char *data, unsigned int *pos):\n    cdef int i\n    check_pos(data, pos[0]+4)\n    memcpy(&i, &data[pos[0]+1], 4)\n    pos[0] += 5\n    if not big_endian:\n        i = swap_byte_order_int(<char*>&i)\n    return i\n\ncdef decode_long_long(char *data, unsigned int *pos):\n    cdef long long l\n    check_pos(data, pos[0]+8)\n    memcpy(&l, &data[pos[0]+1], 8)\n    pos[0] += 9\n    if not big_endian:\n        l = swap_byte_order_long_long(<char*>&l)\n    return l\n\ncdef decode_fixed_pos_int(char *data, unsigned int *pos):\n    pos[0] += 1\n    return data[pos[0] - 1] - INT_POS_FIXED_START\n\ncdef decode_fixed_neg_int(char *data, unsigned int *pos):\n    pos[0] += 1\n    return (data[pos[0] - 1] - INT_NEG_FIXED_START + 1)*-1\n\ncdef decode_big_number(char *data, unsigned int *pos):\n    pos[0] += 1\n    cdef int x = 18\n    check_pos(data, pos[0]+x)\n    while (data[pos[0]+x] != CHR_TERM):\n        x += 1\n        if x >= MAX_INT_LENGTH:\n            raise ValueError(\n                \"Number is longer than %d characters\" % MAX_INT_LENGTH)\n        check_pos(data, pos[0]+x)\n\n    big_number = int(data[pos[0]:pos[0]+x])\n    pos[0] += x + 1\n    return big_number\n\ncdef decode_float32(char *data, unsigned int *pos):\n    cdef float f\n    check_pos(data, pos[0]+4)\n    memcpy(&f, &data[pos[0]+1], 4)\n    pos[0] += 5\n    if not big_endian:\n        f = swap_byte_order_float(<char*>&f)\n    return f\n\ncdef decode_float64(char *data, unsigned int *pos):\n    cdef double d\n    check_pos(data, pos[0]+8)\n    memcpy(&d, &data[pos[0]+1], 8)\n    pos[0] += 9\n    if not big_endian:\n        d = swap_byte_order_double(<char*>&d)\n    return d\n\ncdef decode_fixed_str(char *data, unsigned int *pos):\n    cdef unsigned char size = data[pos[0]] - STR_FIXED_START + 1\n    check_pos(data, pos[0] + size - 1)\n    s = data[pos[0]+1:pos[0] + size]\n    pos[0] += size\n    return s\n\ncdef decode_str(char *data, unsigned int *pos):\n    cdef unsigned int x = 1\n    check_pos(data, pos[0]+x)\n    while (data[pos[0]+x] != 58):\n        x += 1\n        check_pos(data, pos[0]+x)\n\n    cdef int size = int(data[pos[0]:pos[0]+x])\n    pos[0] += x + 1\n    check_pos(data, pos[0] + size - 1)\n    s = data[pos[0]:pos[0] + size]\n    pos[0] += size\n    return s\n\ncdef decode_fixed_list(char *data, unsigned int *pos):\n    l = []\n    size = <unsigned char>data[pos[0]] - LIST_FIXED_START\n    pos[0] += 1\n    cdef int i\n    for i in range(size):\n        l.append(decode(data, pos))\n    return tuple(l)\n\ncdef decode_list(char *data, unsigned int *pos):\n    l = []\n    pos[0] += 1\n    while data[pos[0]] != CHR_TERM:\n        l.append(decode(data, pos))\n    pos[0] += 1\n    return tuple(l)\n\ncdef decode_fixed_dict(char *data, unsigned int *pos):\n    d = {}\n    size = <unsigned char>data[pos[0]] - DICT_FIXED_START\n    pos[0] += 1\n    cdef int i\n    for i in range(size):\n        key = decode(data, pos)\n        value = decode(data, pos)\n        d[key] = value\n    return d\n\ncdef decode_dict(char *data, unsigned int *pos):\n    d = {}\n    pos[0] += 1\n    check_pos(data, pos[0])\n    while data[pos[0]] != CHR_TERM:\n        key = decode(data, pos)\n        value = decode(data, pos)\n        d[key] = value\n    pos[0] += 1\n    return d\n\ncdef check_pos(char *data, unsigned int pos):\n    if pos >= data_length:\n        raise IndexError(\"Tried to access data[%d] but data len is: %d\" % (pos, data_length))\n\ncdef decode(char *data, unsigned int *pos):\n    if pos[0] >= data_length:\n        raise IndexError(\"Malformed rencoded string: data_length: %d pos: %d\" % (data_length, pos[0]))\n\n    cdef unsigned char typecode = data[pos[0]]\n    if typecode == CHR_INT1:\n        return decode_char(data, pos)\n    elif typecode == CHR_INT2:\n        return decode_short(data, pos)\n    elif typecode == CHR_INT4:\n        return decode_int(data, pos)\n    elif typecode == CHR_INT8:\n        return decode_long_long(data, pos)\n    elif INT_POS_FIXED_START <= typecode < INT_POS_FIXED_START + INT_POS_FIXED_COUNT:\n        return decode_fixed_pos_int(data, pos)\n    elif INT_NEG_FIXED_START <= typecode < INT_NEG_FIXED_START + INT_NEG_FIXED_COUNT:\n        return decode_fixed_neg_int(data, pos)\n    elif typecode == CHR_INT:\n        return decode_big_number(data, pos)\n    elif typecode == CHR_FLOAT32:\n        return decode_float32(data, pos)\n    elif typecode == CHR_FLOAT64:\n        return decode_float64(data, pos)\n    elif STR_FIXED_START <= typecode < STR_FIXED_START + STR_FIXED_COUNT:\n        s = decode_fixed_str(data, pos)\n        if _decode_utf8:\n            s = s.decode(\"utf8\")\n        return s\n    elif 49 <= typecode <= 57:\n        s = decode_str(data, pos)\n        if _decode_utf8:\n            s = s.decode(\"utf8\")\n        return s\n    elif typecode == CHR_NONE:\n        pos[0] += 1\n        return None\n    elif typecode == CHR_TRUE:\n        pos[0] += 1\n        return True\n    elif typecode == CHR_FALSE:\n        pos[0] += 1\n        return False\n    elif LIST_FIXED_START <= typecode < LIST_FIXED_START + LIST_FIXED_COUNT:\n        return decode_fixed_list(data, pos)\n    elif typecode == CHR_LIST:\n        return decode_list(data, pos)\n    elif DICT_FIXED_START <= typecode < DICT_FIXED_START + DICT_FIXED_COUNT:\n        return decode_fixed_dict(data, pos)\n    elif typecode == CHR_DICT:\n        return decode_dict(data, pos)\n    else:\n        raise ValueError(\"Invalid typecode: %d at pos: %d\" % (typecode, pos[0]))\n\ndef loads(data, decode_utf8=False):\n    \"\"\"\n    Decodes the string into an object\n\n    :param data: the string to decode\n    :type data: string\n    :param decode_utf8: if True, will attempt to decode all str into unicode\n                        objects using utf8\n    :type decode_utf8: bool\n\n    \"\"\"\n    cdef unsigned int pos = 0\n    global data_length\n    data_length = len(data)\n    global _decode_utf8\n    _decode_utf8=decode_utf8\n    return decode(data, &pos)\n", "# -*- coding: utf-8 -*-\n#\n# test_rencode.py\n#\n# Copyright (C) 2010 Andrew Resch <andrewresch@gmail.com>\n#\n# rencode is free software.\n#\n# You may redistribute it and/or modify it under the terms of the\n# GNU General Public License, as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option)\n# any later version.\n#\n# rencode is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with rencode.    If not, write to:\n#     The Free Software Foundation, Inc.,\n#     51 Franklin Street, Fifth Floor\n#     Boston, MA  02110-1301, USA.\n#\n\nimport sys\n\nimport unittest\nfrom rencode import _rencode as rencode\nfrom rencode import rencode_orig\n\n\n# Hack to deal with python 2 and 3 differences with unicode literals.\nif sys.version < \"3\":\n    import codecs\n\n    def u(x):\n        return codecs.unicode_escape_decode(x)[0]\n\n\nelse:\n    unicode = str\n\n    def u(x):\n        return x\n\n\nclass TestRencode(unittest.TestCase):\n    def test_encode_fixed_pos_int(self):\n        self.assertEqual(rencode.dumps(1), rencode_orig.dumps(1))\n        self.assertEqual(rencode.dumps(40), rencode_orig.dumps(40))\n\n    def test_encode_fixed_neg_int(self):\n        self.assertEqual(rencode.dumps(-10), rencode_orig.dumps(-10))\n        self.assertEqual(rencode.dumps(-29), rencode_orig.dumps(-29))\n\n    def test_encode_int_char_size(self):\n        self.assertEqual(rencode.dumps(100), rencode_orig.dumps(100))\n        self.assertEqual(rencode.dumps(-100), rencode_orig.dumps(-100))\n\n    def test_encode_int_short_size(self):\n        self.assertEqual(rencode.dumps(27123), rencode_orig.dumps(27123))\n        self.assertEqual(rencode.dumps(-27123), rencode_orig.dumps(-27123))\n\n    def test_encode_int_int_size(self):\n        self.assertEqual(rencode.dumps(7483648), rencode_orig.dumps(7483648))\n        self.assertEqual(rencode.dumps(-7483648), rencode_orig.dumps(-7483648))\n\n    def test_encode_int_long_long_size(self):\n        self.assertEqual(\n            rencode.dumps(8223372036854775808), rencode_orig.dumps(8223372036854775808)\n        )\n        self.assertEqual(\n            rencode.dumps(-8223372036854775808),\n            rencode_orig.dumps(-8223372036854775808),\n        )\n\n    def test_encode_int_big_number(self):\n        n = int(\"9\" * 62)\n        self.assertEqual(rencode.dumps(n), rencode_orig.dumps(n))\n        self.assertRaises(ValueError, rencode.dumps, int(\"9\" * 65))\n\n    def test_encode_float_32bit(self):\n        self.assertEqual(rencode.dumps(1234.56), rencode_orig.dumps(1234.56))\n\n    def test_encode_float_64bit(self):\n        self.assertEqual(rencode.dumps(1234.56, 64), rencode_orig.dumps(1234.56, 64))\n\n    def test_encode_float_invalid_size(self):\n        self.assertRaises(ValueError, rencode.dumps, 1234.56, 36)\n\n    def test_encode_fixed_str(self):\n        self.assertEqual(rencode.dumps(b\"foobarbaz\"), rencode_orig.dumps(b\"foobarbaz\"))\n\n    def test_encode_str(self):\n        self.assertEqual(rencode.dumps(b\"f\" * 255), rencode_orig.dumps(b\"f\" * 255))\n        self.assertEqual(rencode.dumps(b\"\\0\"), rencode_orig.dumps(b\"\\0\"))\n\n    def test_encode_unicode(self):\n        self.assertEqual(rencode.dumps(u(\"f\u00f6\u00f6bar\")), rencode_orig.dumps(u(\"f\u00f6\u00f6bar\")))\n\n    def test_encode_none(self):\n        self.assertEqual(rencode.dumps(None), rencode_orig.dumps(None))\n\n    def test_encode_bool(self):\n        self.assertEqual(rencode.dumps(True), rencode_orig.dumps(True))\n        self.assertEqual(rencode.dumps(False), rencode_orig.dumps(False))\n\n    def test_encode_fixed_list(self):\n        l = [100, -234.01, b\"foobar\", u(\"b\u00e4z\")] * 4\n        self.assertEqual(rencode.dumps(l), rencode_orig.dumps(l))\n\n    def test_encode_list(self):\n        l = [100, -234.01, b\"foobar\", u(\"b\u00e4z\")] * 80\n        self.assertEqual(rencode.dumps(l), rencode_orig.dumps(l))\n\n    def test_encode_fixed_dict(self):\n        s = b\"abcdefghijk\"\n        d = dict(zip(s, [1234] * len(s)))\n        self.assertEqual(rencode.dumps(d), rencode_orig.dumps(d))\n\n    def test_encode_dict(self):\n        s = b\"abcdefghijklmnopqrstuvwxyz1234567890\"\n        d = dict(zip(s, [1234] * len(s)))\n        self.assertEqual(rencode.dumps(d), rencode_orig.dumps(d))\n\n    def test_decode_fixed_pos_int(self):\n        self.assertEqual(rencode.loads(rencode.dumps(10)), 10)\n\n    def test_decode_fixed_neg_int(self):\n        self.assertEqual(rencode.loads(rencode.dumps(-10)), -10)\n\n    def test_decode_char(self):\n        self.assertEqual(rencode.loads(rencode.dumps(100)), 100)\n        self.assertEqual(rencode.loads(rencode.dumps(-100)), -100)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([62])))\n\n    def test_decode_short(self):\n        self.assertEqual(rencode.loads(rencode.dumps(27123)), 27123)\n        self.assertEqual(rencode.loads(rencode.dumps(-27123)), -27123)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([63])))\n\n    def test_decode_int(self):\n        self.assertEqual(rencode.loads(rencode.dumps(7483648)), 7483648)\n        self.assertEqual(rencode.loads(rencode.dumps(-7483648)), -7483648)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([64])))\n\n    def test_decode_long_long(self):\n        self.assertEqual(\n            rencode.loads(rencode.dumps(8223372036854775808)), 8223372036854775808\n        )\n        self.assertEqual(\n            rencode.loads(rencode.dumps(-8223372036854775808)), -8223372036854775808\n        )\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([65])))\n\n    def test_decode_int_big_number(self):\n        n = int(b\"9\" * 62)\n        toobig = \"={x}\\x7f\".format(x=\"9\" * 65).encode()\n        self.assertEqual(rencode.loads(rencode.dumps(n)), n)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([61])))\n        self.assertRaises(ValueError, rencode.loads, toobig)\n\n    def test_decode_float_32bit(self):\n        f = rencode.dumps(1234.56)\n        self.assertEqual(rencode.loads(f), rencode_orig.loads(f))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([66])))\n\n    def test_decode_float_64bit(self):\n        f = rencode.dumps(1234.56, 64)\n        self.assertEqual(rencode.loads(f), rencode_orig.loads(f))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([44])))\n\n    def test_decode_fixed_str(self):\n        self.assertEqual(rencode.loads(rencode.dumps(b\"foobarbaz\")), b\"foobarbaz\")\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([130])))\n\n    def test_decode_str(self):\n        self.assertEqual(rencode.loads(rencode.dumps(b\"f\" * 255)), b\"f\" * 255)\n        self.assertRaises(IndexError, rencode.loads, b\"50\")\n\n    def test_decode_unicode(self):\n        self.assertEqual(\n            rencode.loads(rencode.dumps(u(\"f\u00f6\u00f6bar\"))), u(\"f\u00f6\u00f6bar\").encode(\"utf8\")\n        )\n\n    def test_decode_none(self):\n        self.assertEqual(rencode.loads(rencode.dumps(None)), None)\n\n    def test_decode_bool(self):\n        self.assertEqual(rencode.loads(rencode.dumps(True)), True)\n        self.assertEqual(rencode.loads(rencode.dumps(False)), False)\n\n    def test_decode_fixed_list(self):\n        l = [100, False, b\"foobar\", u(\"b\u00e4z\").encode(\"utf8\")] * 4\n        self.assertEqual(rencode.loads(rencode.dumps(l)), tuple(l))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([194])))\n\n    def test_decode_list(self):\n        l = [100, False, b\"foobar\", u(\"b\u00e4z\").encode(\"utf8\")] * 80\n        self.assertEqual(rencode.loads(rencode.dumps(l)), tuple(l))\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([59])))\n\n    def test_decode_fixed_dict(self):\n        s = b\"abcdefghijk\"\n        d = dict(zip(s, [1234] * len(s)))\n        self.assertEqual(rencode.loads(rencode.dumps(d)), d)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([104])))\n\n    def test_decode_dict(self):\n        s = b\"abcdefghijklmnopqrstuvwxyz1234567890\"\n        d = dict(zip(s, [b\"foo\" * 120] * len(s)))\n        d2 = {b\"foo\": d, b\"bar\": d, b\"baz\": d}\n        self.assertEqual(rencode.loads(rencode.dumps(d2)), d2)\n        self.assertRaises(IndexError, rencode.loads, bytes(bytearray([60])))\n\n    def test_decode_str_bytes(self):\n        b = [202, 132, 100, 114, 97, 119, 1, 0, 0, 63, 1, 242, 63]\n        d = bytes(bytearray(b))\n        self.assertEqual(rencode.loads(rencode.dumps(d)), d)\n\n    def test_decode_str_nullbytes(self):\n        b = (\n            202,\n            132,\n            100,\n            114,\n            97,\n            119,\n            1,\n            0,\n            0,\n            63,\n            1,\n            242,\n            63,\n            1,\n            60,\n            132,\n            120,\n            50,\n            54,\n            52,\n            49,\n            51,\n            48,\n            58,\n            0,\n            0,\n            0,\n            1,\n            65,\n            154,\n            35,\n            215,\n            48,\n            204,\n            4,\n            35,\n            242,\n            3,\n            122,\n            218,\n            67,\n            192,\n            127,\n            40,\n            241,\n            127,\n            2,\n            86,\n            240,\n            63,\n            135,\n            177,\n            23,\n            119,\n            63,\n            31,\n            226,\n            248,\n            19,\n            13,\n            192,\n            111,\n            74,\n            126,\n            2,\n            15,\n            240,\n            31,\n            239,\n            48,\n            85,\n            238,\n            159,\n            155,\n            197,\n            241,\n            23,\n            119,\n            63,\n            2,\n            23,\n            245,\n            63,\n            24,\n            240,\n            86,\n            36,\n            176,\n            15,\n            187,\n            185,\n            248,\n            242,\n            255,\n            0,\n            126,\n            123,\n            141,\n            206,\n            60,\n            188,\n            1,\n            27,\n            254,\n            141,\n            169,\n            132,\n            93,\n            220,\n            252,\n            121,\n            184,\n            8,\n            31,\n            224,\n            63,\n            244,\n            226,\n            75,\n            224,\n            119,\n            135,\n            229,\n            248,\n            3,\n            243,\n            248,\n            220,\n            227,\n            203,\n            193,\n            3,\n            224,\n            127,\n            47,\n            134,\n            59,\n            5,\n            99,\n            249,\n            254,\n            35,\n            196,\n            127,\n            17,\n            252,\n            71,\n            136,\n            254,\n            35,\n            196,\n            112,\n            4,\n            177,\n            3,\n            63,\n            5,\n            220,\n        )\n        d = bytes(bytearray(b))\n        self.assertEqual(rencode.loads(rencode.dumps(d)), d)\n\n    def test_decode_utf8(self):\n        s = b\"foobarbaz\"\n        # no assertIsInstance with python2.6\n        d = rencode.loads(rencode.dumps(s), decode_utf8=True)\n        if not isinstance(d, unicode):\n            self.fail(\"%s is not an instance of %r\" % (repr(d), unicode))\n        s = rencode.dumps(b\"\\x56\\xe4foo\\xc3\")\n        self.assertRaises(UnicodeDecodeError, rencode.loads, s, decode_utf8=True)\n\n    def test_version_exposed(self):\n        assert rencode.__version__\n        assert rencode_orig.__version__\n        self.assertEqual(\n            rencode.__version__[1:],\n            rencode_orig.__version__[1:],\n            \"version number does not match\",\n        )\n\n    def test_invalid_typecode(self):\n        s = b\";\\x2f\\x7f\"\n        with self.assertRaises(ValueError):\n            rencode.loads(s)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"], "filenames": ["rencode/_rencode.pyx", "tests/test_rencode.py"], "buggy_code_start_loc": [529, 403], "buggy_code_end_loc": [529, 403], "fixing_code_start_loc": [530, 404], "fixing_code_end_loc": [532, 409], "type": "CWE-835", "message": "The rencode package through 1.0.6 for Python allows an infinite loop in typecode decoding (such as via ;\\x2f\\x7f), enabling a remote attack that consumes CPU and memory.", "other": {"cve": {"id": "CVE-2021-40839", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-10T02:15:07.933", "lastModified": "2022-02-22T14:48:41.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The rencode package through 1.0.6 for Python allows an infinite loop in typecode decoding (such as via ;\\x2f\\x7f), enabling a remote attack that consumes CPU and memory."}, {"lang": "es", "value": "El paquete rencode versiones hasta 1.0.6 para Python, permite un bucle infinito en la decodificaci\u00f3n de typecode (como por medio de ;x2f\\x7f), permitiendo un ataque remoto que consume CPU y memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rencode_project:rencode:*:*:*:*:*:python:*:*", "versionEndIncluding": "1.0.6", "matchCriteriaId": "F5EB73F9-FA9E-4B27-8EFE-698A89423808"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/aresch/rencode/commit/572ff74586d9b1daab904c6f7f7009ce0143bb75", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/aresch/rencode/pull/29", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BMVQRPDVSVZNGGX57CFKCYT3DEYO4QB6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MCLETLGVM5DBX6QNHQFW6TWGO5T3DENY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://pypi.org/project/rencode/#history", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/fulldisclosure/2021/Sep/16", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211008-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aresch/rencode/commit/572ff74586d9b1daab904c6f7f7009ce0143bb75"}}