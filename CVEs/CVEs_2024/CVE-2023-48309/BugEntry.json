{"buggy_code": ["import {\n  AuthorizationParameters,\n  generators,\n  OpenIDCallbackChecks,\n} from \"openid-client\"\nimport * as jwt from \"../../../jwt\"\n\nimport type { RequestInternal } from \"../..\"\nimport type { OAuthChecks } from \"../../../providers\"\nimport type { CookiesOptions, InternalOptions } from \"../../types\"\nimport type { Cookie } from \"../cookie\"\n\n/** Returns a signed cookie. */\nexport async function signCookie(\n  type: keyof CookiesOptions,\n  value: string,\n  maxAge: number,\n  options: InternalOptions<\"oauth\">\n): Promise<Cookie> {\n  const { cookies, logger } = options\n\n  logger.debug(`CREATE_${type.toUpperCase()}`, { value, maxAge })\n\n  const expires = new Date()\n  expires.setTime(expires.getTime() + maxAge * 1000)\n  return {\n    name: cookies[type].name,\n    value: await jwt.encode({ ...options.jwt, maxAge, token: { value } }),\n    options: { ...cookies[type].options, expires },\n  }\n}\n\nconst PKCE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const PKCE_CODE_CHALLENGE_METHOD = \"S256\"\nexport const pkce = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider?.checks?.includes(\"pkce\")) return\n    const code_verifier = generators.codeVerifier()\n    const value = generators.codeChallenge(code_verifier)\n    resParams.code_challenge = value\n    resParams.code_challenge_method = PKCE_CODE_CHALLENGE_METHOD\n\n    const maxAge =\n      options.cookies.pkceCodeVerifier.options.maxAge ?? PKCE_MAX_AGE\n\n    cookies.push(\n      await signCookie(\"pkceCodeVerifier\", code_verifier, maxAge, options)\n    )\n  },\n  /**\n   * Returns code_verifier if the provider is configured to use PKCE,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the code_verifier is missing or invalid.\n   * @see https://www.rfc-editor.org/rfc/rfc7636\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#pkce\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OAuthChecks\n  ): Promise<string | undefined> {\n    if (!options.provider?.checks?.includes(\"pkce\")) return\n\n    const codeVerifier = cookies?.[options.cookies.pkceCodeVerifier.name]\n\n    if (!codeVerifier)\n      throw new TypeError(\"PKCE code_verifier cookie was missing.\")\n\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: codeVerifier,\n    })) as any\n\n    if (!value?.value)\n      throw new TypeError(\"PKCE code_verifier value could not be parsed.\")\n\n    resCookies.push({\n      name: options.cookies.pkceCodeVerifier.name,\n      value: \"\",\n      options: { ...options.cookies.pkceCodeVerifier.options, maxAge: 0 },\n    })\n\n    checks.code_verifier = value.value\n  },\n}\n\nconst STATE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const state = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider.checks?.includes(\"state\")) return\n    const value = generators.state()\n    resParams.state = value\n    const maxAge = options.cookies.state.options.maxAge ?? STATE_MAX_AGE\n    cookies.push(await signCookie(\"state\", value, maxAge, options))\n  },\n  /**\n   * Returns state if the provider is configured to use state,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the state is missing or invalid.\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-10.12\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.1\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OAuthChecks\n  ) {\n    if (!options.provider.checks?.includes(\"state\")) return\n\n    const state = cookies?.[options.cookies.state.name]\n\n    if (!state) throw new TypeError(\"State cookie was missing.\")\n\n    const value = (await jwt.decode({ ...options.jwt, token: state })) as any\n\n    if (!value?.value) throw new TypeError(\"State value could not be parsed.\")\n\n    resCookies.push({\n      name: options.cookies.state.name,\n      value: \"\",\n      options: { ...options.cookies.state.options, maxAge: 0 },\n    })\n\n    checks.state = value.value\n  },\n}\n\nconst NONCE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const nonce = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider.checks?.includes(\"nonce\")) return\n    const value = generators.nonce()\n    resParams.nonce = value\n    const maxAge = options.cookies.nonce.options.maxAge ?? NONCE_MAX_AGE\n    cookies.push(await signCookie(\"nonce\", value, maxAge, options))\n  },\n  /**\n   * Returns nonce if the provider is configured to use nonce,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the nonce is missing or invalid.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OpenIDCallbackChecks\n  ): Promise<string | undefined> {\n    if (!options.provider?.checks?.includes(\"nonce\")) return\n\n    const nonce = cookies?.[options.cookies.nonce.name]\n    if (!nonce) throw new TypeError(\"Nonce cookie was missing.\")\n\n    const value = (await jwt.decode({ ...options.jwt, token: nonce })) as any\n\n    if (!value?.value) throw new TypeError(\"Nonce value could not be parsed.\")\n\n    resCookies.push({\n      name: options.cookies.nonce.name,\n      value: \"\",\n      options: { ...options.cookies.nonce.options, maxAge: 0 },\n    })\n\n    checks.nonce = value.value\n  },\n}\n", "import { EncryptJWT, jwtDecrypt } from \"jose\"\nimport hkdf from \"@panva/hkdf\"\nimport { v4 as uuid } from \"uuid\"\nimport { SessionStore } from \"../core/lib/cookie\"\nimport type { GetServerSidePropsContext, NextApiRequest } from \"next\"\nimport type { NextRequest } from \"next/server\"\nimport type { JWT, JWTDecodeParams, JWTEncodeParams, JWTOptions } from \"./types\"\nimport type { LoggerInstance } from \"..\"\n\nexport * from \"./types\"\n\nconst DEFAULT_MAX_AGE = 30 * 24 * 60 * 60 // 30 days\n\nconst now = () => (Date.now() / 1000) | 0\n\n/** Issues a JWT. By default, the JWT is encrypted using \"A256GCM\". */\nexport async function encode(params: JWTEncodeParams) {\n  const { token = {}, secret, maxAge = DEFAULT_MAX_AGE } = params\n  const encryptionSecret = await getDerivedEncryptionKey(secret)\n  return await new EncryptJWT(token)\n    .setProtectedHeader({ alg: \"dir\", enc: \"A256GCM\" })\n    .setIssuedAt()\n    .setExpirationTime(now() + maxAge)\n    .setJti(uuid())\n    .encrypt(encryptionSecret)\n}\n\n/** Decodes a NextAuth.js issued JWT. */\nexport async function decode(params: JWTDecodeParams): Promise<JWT | null> {\n  const { token, secret } = params\n  if (!token) return null\n  const encryptionSecret = await getDerivedEncryptionKey(secret)\n  const { payload } = await jwtDecrypt(token, encryptionSecret, {\n    clockTolerance: 15,\n  })\n  return payload\n}\n\nexport interface GetTokenParams<R extends boolean = false> {\n  /** The request containing the JWT either in the cookies or in the `Authorization` header. */\n  req: GetServerSidePropsContext[\"req\"] | NextRequest | NextApiRequest\n  /**\n   * Use secure prefix for cookie name, unless URL in `NEXTAUTH_URL` is http://\n   * or not set (e.g. development or test instance) case use unprefixed name\n   */\n  secureCookie?: boolean\n  /** If the JWT is in the cookie, what name `getToken()` should look for. */\n  cookieName?: string\n  /**\n   * `getToken()` will return the raw JWT if this is set to `true`\n   * @default false\n   */\n  raw?: R\n  /**\n   * The same `secret` used in the `NextAuth` configuration.\n   * Defaults to the `NEXTAUTH_SECRET` environment variable.\n   */\n  secret?: string\n  decode?: JWTOptions[\"decode\"]\n  logger?: LoggerInstance | Console\n}\n\n/**\n * Takes a NextAuth.js request (`req`) and returns either the NextAuth.js issued JWT's payload,\n * or the raw JWT string. We look for the JWT in the either the cookies, or the `Authorization` header.\n * [Documentation](https://next-auth.js.org/tutorials/securing-pages-and-api-routes#using-gettoken)\n */\nexport async function getToken<R extends boolean = false>(\n  params: GetTokenParams<R>\n): Promise<R extends true ? string : JWT | null> {\n  const {\n    req,\n    secureCookie = process.env.NEXTAUTH_URL?.startsWith(\"https://\") ??\n      !!process.env.VERCEL,\n    cookieName = secureCookie\n      ? \"__Secure-next-auth.session-token\"\n      : \"next-auth.session-token\",\n    raw,\n    decode: _decode = decode,\n    logger = console,\n    secret = process.env.NEXTAUTH_SECRET,\n  } = params\n\n  if (!req) throw new Error(\"Must pass `req` to JWT getToken()\")\n\n  const sessionStore = new SessionStore(\n    { name: cookieName, options: { secure: secureCookie } },\n    { cookies: req.cookies, headers: req.headers },\n    logger\n  )\n\n  let token = sessionStore.value\n\n  const authorizationHeader =\n    req.headers instanceof Headers\n      ? req.headers.get(\"authorization\")\n      : req.headers?.authorization\n\n  if (!token && authorizationHeader?.split(\" \")[0] === \"Bearer\") {\n    const urlEncodedToken = authorizationHeader.split(\" \")[1]\n    token = decodeURIComponent(urlEncodedToken)\n  }\n\n  // @ts-expect-error\n  if (!token) return null\n\n  // @ts-expect-error\n  if (raw) return token\n\n  try {\n    // @ts-expect-error\n    return await _decode({ token, secret })\n  } catch {\n    // @ts-expect-error\n    return null\n  }\n}\n\nasync function getDerivedEncryptionKey(secret: string | Buffer) {\n  return await hkdf(\n    \"sha256\",\n    secret,\n    \"\",\n    \"NextAuth.js Generated Encryption Key\",\n    32\n  )\n}\n", "import type { Awaitable } from \"..\"\n\nexport interface DefaultJWT extends Record<string, unknown> {\n  name?: string | null\n  email?: string | null\n  picture?: string | null\n  sub?: string\n}\n\n/**\n * Returned by the `jwt` callback and `getToken`, when using JWT sessions\n *\n * [`jwt` callback](https://next-auth.js.org/configuration/callbacks#jwt-callback) | [`getToken`](https://next-auth.js.org/tutorials/securing-pages-and-api-routes#using-gettoken)\n */\nexport interface JWT extends Record<string, unknown>, DefaultJWT {}\n\nexport interface JWTEncodeParams {\n  /** The JWT payload. */\n  token?: JWT\n  /** The secret used to encode the NextAuth.js issued JWT. */\n  secret: string | Buffer\n  /**\n   * The maximum age of the NextAuth.js issued JWT in seconds.\n   * @default 30 * 24 * 60 * 60 // 30 days\n   */\n  maxAge?: number\n}\n\nexport interface JWTDecodeParams {\n  /** The NextAuth.js issued JWT to be decoded */\n  token?: string\n  /** The secret used to decode the NextAuth.js issued JWT. */\n  secret: string | Buffer\n}\n\nexport interface JWTOptions {\n  /**\n   * The secret used to encode/decode the NextAuth.js issued JWT.\n   * @deprecated  Set the `NEXTAUTH_SECRET` environment variable or\n   * use the top-level `secret` option instead\n   */\n  secret: string\n  /**\n   * The maximum age of the NextAuth.js issued JWT in seconds.\n   * @default 30 * 24 * 60 * 60 // 30 days\n   */\n  maxAge: number\n  /** Override this method to control the NextAuth.js issued JWT encoding. */\n  encode: (params: JWTEncodeParams) => Awaitable<string>\n  /** Override this method to control the NextAuth.js issued JWT decoding. */\n  decode: (params: JWTDecodeParams) => Awaitable<JWT | null>\n}\n\nexport type Secret = string | Buffer\n"], "fixing_code": ["import {\n  AuthorizationParameters,\n  generators,\n  OpenIDCallbackChecks,\n} from \"openid-client\"\nimport * as jwt from \"../../../jwt\"\n\nimport type { RequestInternal } from \"../..\"\nimport type { OAuthChecks } from \"../../../providers\"\nimport type { CookiesOptions, InternalOptions } from \"../../types\"\nimport type { Cookie } from \"../cookie\"\n\n/** Returns a signed cookie. */\nexport async function signCookie(\n  type: keyof CookiesOptions,\n  value: string,\n  maxAge: number,\n  options: InternalOptions<\"oauth\">\n): Promise<Cookie> {\n  const { cookies, logger } = options\n\n  logger.debug(`CREATE_${type.toUpperCase()}`, { value, maxAge })\n\n  const { name } = cookies[type]\n  const expires = new Date()\n  expires.setTime(expires.getTime() + maxAge * 1000)\n  return {\n    name,\n    value: await jwt.encode({\n      ...options.jwt,\n      maxAge,\n      token: { value },\n      salt: name,\n    }),\n    options: { ...cookies[type].options, expires },\n  }\n}\n\nconst PKCE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const PKCE_CODE_CHALLENGE_METHOD = \"S256\"\nexport const pkce = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider?.checks?.includes(\"pkce\")) return\n    const code_verifier = generators.codeVerifier()\n    const value = generators.codeChallenge(code_verifier)\n    resParams.code_challenge = value\n    resParams.code_challenge_method = PKCE_CODE_CHALLENGE_METHOD\n\n    const maxAge =\n      options.cookies.pkceCodeVerifier.options.maxAge ?? PKCE_MAX_AGE\n\n    cookies.push(\n      await signCookie(\"pkceCodeVerifier\", code_verifier, maxAge, options)\n    )\n  },\n  /**\n   * Returns code_verifier if the provider is configured to use PKCE,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the code_verifier is missing or invalid.\n   * @see https://www.rfc-editor.org/rfc/rfc7636\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#pkce\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OAuthChecks\n  ): Promise<string | undefined> {\n    if (!options.provider?.checks?.includes(\"pkce\")) return\n\n    const codeVerifier = cookies?.[options.cookies.pkceCodeVerifier.name]\n\n    if (!codeVerifier)\n      throw new TypeError(\"PKCE code_verifier cookie was missing.\")\n\n    const { name } = options.cookies.pkceCodeVerifier\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: codeVerifier,\n      salt: name,\n    })) as any\n\n    if (!value?.value)\n      throw new TypeError(\"PKCE code_verifier value could not be parsed.\")\n\n    resCookies.push({\n      name,\n      value: \"\",\n      options: { ...options.cookies.pkceCodeVerifier.options, maxAge: 0 },\n    })\n\n    checks.code_verifier = value.value\n  },\n}\n\nconst STATE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const state = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider.checks?.includes(\"state\")) return\n    const value = generators.state()\n    resParams.state = value\n    const maxAge = options.cookies.state.options.maxAge ?? STATE_MAX_AGE\n    cookies.push(await signCookie(\"state\", value, maxAge, options))\n  },\n  /**\n   * Returns state if the provider is configured to use state,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the state is missing or invalid.\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-10.12\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.1\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OAuthChecks\n  ) {\n    if (!options.provider.checks?.includes(\"state\")) return\n\n    const state = cookies?.[options.cookies.state.name]\n\n    if (!state) throw new TypeError(\"State cookie was missing.\")\n\n    const { name } = options.cookies.state\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: state,\n      salt: name,\n    })) as any\n\n    if (!value?.value) throw new TypeError(\"State value could not be parsed.\")\n\n    resCookies.push({\n      name,\n      value: \"\",\n      options: { ...options.cookies.state.options, maxAge: 0 },\n    })\n\n    checks.state = value.value\n  },\n}\n\nconst NONCE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const nonce = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider.checks?.includes(\"nonce\")) return\n    const value = generators.nonce()\n    resParams.nonce = value\n    const maxAge = options.cookies.nonce.options.maxAge ?? NONCE_MAX_AGE\n    cookies.push(await signCookie(\"nonce\", value, maxAge, options))\n  },\n  /**\n   * Returns nonce if the provider is configured to use nonce,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the nonce is missing or invalid.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OpenIDCallbackChecks\n  ): Promise<string | undefined> {\n    if (!options.provider?.checks?.includes(\"nonce\")) return\n\n    const nonce = cookies?.[options.cookies.nonce.name]\n    if (!nonce) throw new TypeError(\"Nonce cookie was missing.\")\n\n    const { name } = options.cookies.nonce\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: nonce,\n      salt: name,\n    })) as any\n\n    if (!value?.value) throw new TypeError(\"Nonce value could not be parsed.\")\n\n    resCookies.push({\n      name,\n      value: \"\",\n      options: { ...options.cookies.nonce.options, maxAge: 0 },\n    })\n\n    checks.nonce = value.value\n  },\n}\n", "import { EncryptJWT, jwtDecrypt } from \"jose\"\nimport hkdf from \"@panva/hkdf\"\nimport { v4 as uuid } from \"uuid\"\nimport { SessionStore } from \"../core/lib/cookie\"\nimport type { GetServerSidePropsContext, NextApiRequest } from \"next\"\nimport type { NextRequest } from \"next/server\"\nimport type { JWT, JWTDecodeParams, JWTEncodeParams, JWTOptions } from \"./types\"\nimport type { LoggerInstance } from \"..\"\n\nexport * from \"./types\"\n\nconst DEFAULT_MAX_AGE = 30 * 24 * 60 * 60 // 30 days\n\nconst now = () => (Date.now() / 1000) | 0\n\n/** Issues a JWT. By default, the JWT is encrypted using \"A256GCM\". */\nexport async function encode(params: JWTEncodeParams) {\n  /** @note empty `salt` means a session token. See {@link JWTEncodeParams.salt}. */\n  const { token = {}, secret, maxAge = DEFAULT_MAX_AGE, salt = \"\" } = params\n  const encryptionSecret = await getDerivedEncryptionKey(secret, salt)\n  return await new EncryptJWT(token)\n    .setProtectedHeader({ alg: \"dir\", enc: \"A256GCM\" })\n    .setIssuedAt()\n    .setExpirationTime(now() + maxAge)\n    .setJti(uuid())\n    .encrypt(encryptionSecret)\n}\n\n/** Decodes a NextAuth.js issued JWT. */\nexport async function decode(params: JWTDecodeParams): Promise<JWT | null> {\n  /** @note empty `salt` means a session token. See {@link JWTDecodeParams.salt}. */\n  const { token, secret, salt = \"\" } = params\n  if (!token) return null\n  const encryptionSecret = await getDerivedEncryptionKey(secret, salt)\n  const { payload } = await jwtDecrypt(token, encryptionSecret, {\n    clockTolerance: 15,\n  })\n  return payload\n}\n\nexport interface GetTokenParams<R extends boolean = false> {\n  /** The request containing the JWT either in the cookies or in the `Authorization` header. */\n  req: GetServerSidePropsContext[\"req\"] | NextRequest | NextApiRequest\n  /**\n   * Use secure prefix for cookie name, unless URL in `NEXTAUTH_URL` is http://\n   * or not set (e.g. development or test instance) case use unprefixed name\n   */\n  secureCookie?: boolean\n  /** If the JWT is in the cookie, what name `getToken()` should look for. */\n  cookieName?: string\n  /**\n   * `getToken()` will return the raw JWT if this is set to `true`\n   * @default false\n   */\n  raw?: R\n  /**\n   * The same `secret` used in the `NextAuth` configuration.\n   * Defaults to the `NEXTAUTH_SECRET` environment variable.\n   */\n  secret?: string\n  decode?: JWTOptions[\"decode\"]\n  logger?: LoggerInstance | Console\n}\n\n/**\n * Takes a NextAuth.js request (`req`) and returns either the NextAuth.js issued JWT's payload,\n * or the raw JWT string. We look for the JWT in the either the cookies, or the `Authorization` header.\n * [Documentation](https://next-auth.js.org/tutorials/securing-pages-and-api-routes#using-gettoken)\n */\nexport async function getToken<R extends boolean = false>(\n  params: GetTokenParams<R>\n): Promise<R extends true ? string : JWT | null> {\n  const {\n    req,\n    secureCookie = process.env.NEXTAUTH_URL?.startsWith(\"https://\") ??\n      !!process.env.VERCEL,\n    cookieName = secureCookie\n      ? \"__Secure-next-auth.session-token\"\n      : \"next-auth.session-token\",\n    raw,\n    decode: _decode = decode,\n    logger = console,\n    secret = process.env.NEXTAUTH_SECRET,\n  } = params\n\n  if (!req) throw new Error(\"Must pass `req` to JWT getToken()\")\n\n  const sessionStore = new SessionStore(\n    { name: cookieName, options: { secure: secureCookie } },\n    { cookies: req.cookies, headers: req.headers },\n    logger\n  )\n\n  let token = sessionStore.value\n\n  const authorizationHeader =\n    req.headers instanceof Headers\n      ? req.headers.get(\"authorization\")\n      : req.headers?.authorization\n\n  if (!token && authorizationHeader?.split(\" \")[0] === \"Bearer\") {\n    const urlEncodedToken = authorizationHeader.split(\" \")[1]\n    token = decodeURIComponent(urlEncodedToken)\n  }\n\n  // @ts-expect-error\n  if (!token) return null\n\n  // @ts-expect-error\n  if (raw) return token\n\n  try {\n    // @ts-expect-error\n    return await _decode({ token, secret })\n  } catch {\n    // @ts-expect-error\n    return null\n  }\n}\n\nasync function getDerivedEncryptionKey(\n  keyMaterial: string | Buffer,\n  salt: string\n) {\n  return await hkdf(\n    \"sha256\",\n    keyMaterial,\n    salt,\n    `NextAuth.js Generated Encryption Key${salt ? ` (${salt})` : \"\"}`,\n    32\n  )\n}\n", "import type { Awaitable } from \"..\"\n\nexport interface DefaultJWT extends Record<string, unknown> {\n  name?: string | null\n  email?: string | null\n  picture?: string | null\n  sub?: string\n}\n\n/**\n * Returned by the `jwt` callback and `getToken`, when using JWT sessions\n *\n * [`jwt` callback](https://next-auth.js.org/configuration/callbacks#jwt-callback) | [`getToken`](https://next-auth.js.org/tutorials/securing-pages-and-api-routes#using-gettoken)\n */\nexport interface JWT extends Record<string, unknown>, DefaultJWT {}\n\nexport interface JWTEncodeParams {\n  /** The JWT payload. */\n  token?: JWT\n  /**\n   * Used in combination with `secret` when deriving the encryption secret for the various NextAuth.js-issued JWTs.\n   * @note When no `salt` is passed, we assume this is a session token.\n   * This is for backwards-compatibility with currently active sessions, so they won't be invalidated when upgrading the package.\n   */\n  salt?: string\n  /** The key material used to encode the NextAuth.js issued JWTs. Defaults to `NEXTAUTH_SECRET`. */\n  secret: string | Buffer\n  /**\n   * The maximum age of the NextAuth.js issued JWT in seconds.\n   * @default 30 * 24 * 60 * 60 // 30 days\n   */\n  maxAge?: number\n}\n\nexport interface JWTDecodeParams {\n  /** The NextAuth.js issued JWT to be decoded */\n  token?: string\n  /**\n   * Used in combination with `secret` when deriving the encryption secret for the various NextAuth.js-issued JWTs.\n   * @note When no `salt` is passed, we assume this is a session token.\n   * This is for backwards-compatibility with currently active sessions, so they won't be invalidated when upgrading the package.\n   */\n  salt?: string\n  /** The key material used to decode the NextAuth.js issued JWTs. Defaults to `NEXTAUTH_SECRET`. */\n  secret: string | Buffer\n}\n\nexport interface JWTOptions {\n  /**\n   * The secret used to encode/decode the NextAuth.js issued JWT.\n   * @deprecated  Set the `NEXTAUTH_SECRET` environment variable or\n   * use the top-level `secret` option instead\n   */\n  secret: string\n  /**\n   * The maximum age of the NextAuth.js issued JWT in seconds.\n   * @default 30 * 24 * 60 * 60 // 30 days\n   */\n  maxAge: number\n  /** Override this method to control the NextAuth.js issued JWT encoding. */\n  encode: (params: JWTEncodeParams) => Awaitable<string>\n  /** Override this method to control the NextAuth.js issued JWT decoding. */\n  decode: (params: JWTDecodeParams) => Awaitable<JWT | null>\n}\n\nexport type Secret = string | Buffer\n"], "filenames": ["packages/next-auth/src/core/lib/oauth/checks.ts", "packages/next-auth/src/jwt/index.ts", "packages/next-auth/src/jwt/types.ts"], "buggy_code_start_loc": [23, 18, 20], "buggy_code_end_loc": [175, 125, 33], "fixing_code_start_loc": [24, 18, 20], "fixing_code_end_loc": [193, 130, 45], "type": "CWE-285", "message": "NextAuth.js provides authentication for Next.js. `next-auth` applications prior to version 4.24.5 that rely on the default Middleware authorization are affected by a vulnerability. A bad actor could create an empty/mock user, by getting hold of a NextAuth.js-issued JWT from an interrupted OAuth sign-in flow (state, PKCE or nonce). Manually overriding the `next-auth.session-token` cookie value with this non-related JWT would let the user simulate a logged in user, albeit having no user information associated with it. (The only property on this user is an opaque randomly generated string). This vulnerability does not give access to other users' data, neither to resources that require proper authorization via scopes or other means. The created mock user has no information associated with it (ie. no name, email, access_token, etc.) This vulnerability can be exploited by bad actors to peek at logged in user states (e.g. dashboard layout). `next-auth` `v4.24.5` contains a patch for the vulnerability. As a workaround, using a custom authorization callback for Middleware, developers can manually do a basic authentication.", "other": {"cve": {"id": "CVE-2023-48309", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-20T19:15:09.243", "lastModified": "2023-11-25T02:18:34.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NextAuth.js provides authentication for Next.js. `next-auth` applications prior to version 4.24.5 that rely on the default Middleware authorization are affected by a vulnerability. A bad actor could create an empty/mock user, by getting hold of a NextAuth.js-issued JWT from an interrupted OAuth sign-in flow (state, PKCE or nonce). Manually overriding the `next-auth.session-token` cookie value with this non-related JWT would let the user simulate a logged in user, albeit having no user information associated with it. (The only property on this user is an opaque randomly generated string). This vulnerability does not give access to other users' data, neither to resources that require proper authorization via scopes or other means. The created mock user has no information associated with it (ie. no name, email, access_token, etc.) This vulnerability can be exploited by bad actors to peek at logged in user states (e.g. dashboard layout). `next-auth` `v4.24.5` contains a patch for the vulnerability. As a workaround, using a custom authorization callback for Middleware, developers can manually do a basic authentication."}, {"lang": "es", "value": "NextAuth.js proporciona autenticaci\u00f3n para Next.js. Las aplicaciones `next-auth` anteriores a la versi\u00f3n 4.24.5 que dependen de la autorizaci\u00f3n de Middleware predeterminada se ven afectadas por una vulnerabilidad. Un mal actor podr\u00eda crear un usuario vac\u00edo/simulado al obtener un JWT emitido por NextAuth.js a partir de un flujo de inicio de sesi\u00f3n de OAuth interrumpido (estado, PKCE o nonce). Anular manualmente el valor de la cookie `next-auth.session-token` con este JWT no relacionado permitir\u00eda al usuario simular un usuario que ha iniciado sesi\u00f3n, aunque no tenga informaci\u00f3n de usuario asociada. (La \u00fanica propiedad de este usuario es una cadena opaca generada aleatoriamente). Esta vulnerabilidad no da acceso a los datos de otros usuarios, ni a recursos que requieran la autorizaci\u00f3n adecuada a trav\u00e9s de alcances u otros medios. El usuario simulado creado no tiene informaci\u00f3n asociada (es decir, no tiene nombre, correo electr\u00f3nico, token de acceso, etc.). Los malos actores pueden aprovechar esta vulnerabilidad para echar un vistazo a los estados de los usuarios que han iniciado sesi\u00f3n (por ejemplo, el dise\u00f1o del panel). `next-auth` `v4.24.5` contiene un parche para la vulnerabilidad. Como workaround, al utilizar una devoluci\u00f3n de llamada de autorizaci\u00f3n personalizada para Middleware, los desarrolladores pueden realizar manualmente una autenticaci\u00f3n b\u00e1sica."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}, {"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextauth.js:next-auth:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.24.5", "matchCriteriaId": "A8790D4B-02DD-46E6-84FA-B1BA7F1C94E9"}]}]}], "references": [{"url": "https://authjs.dev/guides/basics/role-based-access-control", "source": "security-advisories@github.com", "tags": ["Technical Description"]}, {"url": "https://github.com/nextauthjs/next-auth/commit/d237059b6d0cb868c041ba18b698e0cee20a2f10", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nextauthjs/next-auth/security/advisories/GHSA-v64w-49xw-qq89", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://next-auth.js.org/configuration/nextjs#advanced-usage", "source": "security-advisories@github.com", "tags": ["Technical Description"]}, {"url": "https://next-auth.js.org/configuration/nextjs#middlewar", "source": "security-advisories@github.com", "tags": ["Technical Description"]}]}, "github_commit_url": "https://github.com/nextauthjs/next-auth/commit/d237059b6d0cb868c041ba18b698e0cee20a2f10"}}