{"buggy_code": ["/* radare - LGPL - Copyright 2009-2017 - pancake, nibble, dso */\n\n// TODO: dlopen library and show address\n\n#include <r_bin.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_io.h>\n#include <config.h>\n\nR_LIB_VERSION (r_bin);\n\n#define bprintf if(binfile->rbin->verbose)eprintf\n#define DB a->sdb;\n#define RBINLISTFREE(x)\\\n\tif (x) { \\\n\t\tr_list_free (x);\\\n\t\tx = NULL;\\\n\t}\n#define REBASE_PADDR(o, l, type_t)\\\n\tdo { \\\n\t\tRListIter *_it;\\\n\t\ttype_t *_el;\\\n\t\tr_list_foreach ((l), _it, _el) { \\\n\t\t\t_el->paddr += (o)->loadaddr;\\\n\t\t}\\\n\t} while (0)\n\n#define ARCHS_KEY \"archs\"\n\n#if !defined(R_BIN_STATIC_PLUGINS)\n#define R_BIN_STATIC_PLUGINS 0\n#endif\n#if !defined(R_BIN_XTR_STATIC_PLUGINS)\n#define R_BIN_XTR_STATIC_PLUGINS 0\n#endif\n\nstatic RBinPlugin *bin_static_plugins[] = { R_BIN_STATIC_PLUGINS, NULL };\nstatic RBinXtrPlugin *bin_xtr_static_plugins[] = { R_BIN_XTR_STATIC_PLUGINS, NULL };\n\nstatic int is_data_section(RBinFile *a, RBinSection *s);\nstatic RList *get_strings(RBinFile *a, int min, int dump);\nstatic void r_bin_object_delete_items(RBinObject *o);\nstatic void r_bin_object_free(void /*RBinObject*/ *o_);\n// static int r_bin_object_set_items(RBinFile *binfile, RBinObject *o);\nstatic int r_bin_file_set_bytes(RBinFile *binfile, const ut8 *bytes, ut64 sz, bool steal_ptr);\n//static int remove_bin_file_by_binfile (RBin *bin, RBinFile * binfile);\n//static void r_bin_free_bin_files (RBin *bin);\nstatic void r_bin_file_free(void /*RBinFile*/ *bf_);\nstatic RBinFile *r_bin_file_create_append(RBin *bin, const char *file,\n\t\t\t\t\t   const ut8 *bytes, ut64 sz,\n\t\t\t\t\t   ut64 file_sz, int rawstr, int fd,\n\t\t\t\t\t   const char *xtrname, bool steal_ptr);\n\nstatic RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr,\n\t\t\t\t\t    const char *filename,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, ut64 baseaddr,\n\t\t\t\t\t    ut64 loadaddr, int idx, int fd,\n\t\t\t\t\t    int rawstr);\n\nint r_bin_load_io_at_offset_as_sz(RBin *bin, int fd, ut64 baseaddr,\n\t\t\t\t   ut64 loadaddr, int xtr_idx, ut64 offset,\n\t\t\t\t   const char *name, ut64 sz);\n\nstatic RBinPlugin *r_bin_get_binplugin_by_name(RBin *bin, const char *name);\nstatic RBinXtrPlugin *r_bin_get_xtrplugin_by_name(RBin *bin, const char *name);\nstatic RBinPlugin *r_bin_get_binplugin_any(RBin *bin);\n\nstatic RBinObject *r_bin_object_new(RBinFile *binfile, RBinPlugin *plugin,\n\t\t\t\t     ut64 baseaddr, ut64 loadaddr, ut64 offset,\n\t\t\t\t     ut64 sz);\n\nstatic RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes,\n\t\t\t\t ut64 sz, ut64 file_sz, int rawstr, int fd,\n\t\t\t\t const char *xtrname, Sdb *sdb, bool steal_ptr);\n\nstatic RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, int rawstr,\n\t\t\t\t\t    ut64 baseaddr, ut64 loadaddr,\n\t\t\t\t\t    int fd, const char *pluginname,\n\t\t\t\t\t    const char *xtrname, ut64 offset,\n\t\t\t\t\t    bool steal_ptr);\n\nstatic int getoffset(RBin *bin, int type, int idx) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\tif (plugin && plugin->get_offset) {\n\t\treturn plugin->get_offset (a, type, idx);\n\t}\n\treturn -1;\n}\n\nstatic const char *getname(RBin *bin, int type, int idx) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\tif (plugin && plugin->get_name) {\n\t\treturn plugin->get_name (a, type, idx);\n\t}\n\treturn NULL;\n}\nstatic int r_bin_file_object_add(RBinFile *binfile, RBinObject *o) {\n\tif (!o) {\n\t\treturn false;\n\t}\n\tr_list_append (binfile->objs, o);\n\tr_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, o);\n\treturn true;\n}\n\nstatic void binobj_set_baddr(RBinObject *o, ut64 baddr) {\n\tif (!o || baddr == UT64_MAX) {\n\t\treturn;\n\t}\n\to->baddr_shift = baddr - o->baddr;\n}\n\nstatic ut64 binobj_a2b(RBinObject *o, ut64 addr) {\n\treturn addr + (o? o->baddr_shift: 0);\n}\n\nstatic void filterStrings (RBin *bin, RList *strings) {\n\tRBinString *ptr;\n\tRListIter *iter;\n\tr_list_foreach (strings, iter, ptr) {\n\t\tchar *dec = (char *)r_base64_decode_dyn (ptr->string, -1);\n\t\tif (dec) {\n\t\t\tchar *s = ptr->string;\n\t\t\tdo {\n\t\t\t\tchar *dec2 = (char *)r_base64_decode_dyn (s, -1);\n\t\t\t\tif (!dec2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!r_str_is_printable (dec2)) {\n\t\t\t\t\tfree (dec2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree (dec);\n\t\t\t\ts = dec = dec2;\n\t\t\t} while (true);\n\t\t\tif (r_str_is_printable (dec) && strlen (dec) > 3) {\n\t\t\t\tfree (ptr->string);\n\t\t\t\tptr->string = dec;\n\t\t\t\tptr->type = R_STRING_TYPE_BASE64;\n\t\t\t} else {\n\t\t\t\tfree (dec);\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_iobind(RBin *bin, RIO *io) {\n\tr_io_bind (io, &bin->iob);\n}\n\n// TODO: move these two function do a different file\nR_API RBinXtrData *r_bin_xtrdata_new(RBuffer *buf, ut64 offset, ut64 size,\n\t\t\t\t      ut32 file_count,\n\t\t\t\t      RBinXtrMetadata *metadata) {\n\tRBinXtrData *data = R_NEW0 (RBinXtrData);\n\tif (!data) {\n\t\treturn NULL;\n\t}\n\tdata->offset = offset;\n\tdata->size = size;\n\tdata->file_count = file_count;\n\tdata->metadata = metadata;\n\tdata->loaded = 0;\n\tdata->buffer = malloc (size + 1);\n\t// data->laddr = 0; /// XXX\n\tif (!data->buffer) {\n\t\tfree (data);\n\t\treturn NULL;\n\t}\n\tmemcpy (data->buffer, r_buf_buffer (buf), size);\n\tdata->buffer[size] = 0;\n\treturn data;\n}\n\nR_API const char *r_bin_string_type (int type) {\n\tswitch (type) {\n\tcase 'a': return \"ascii\";\n\tcase 'u': return \"utf8\";\n\tcase 'w': return \"utf16le\";\n\tcase 'W': return \"utf32le\";\n\tcase 'b': return \"base64\";\n\t}\n\treturn \"ascii\"; // XXX\n}\n\nR_API void r_bin_xtrdata_free(void /*RBinXtrData*/ *data_) {\n\tRBinXtrData *data = data_;\n\tif (data) {\n\t\tif (data->metadata) {\n\t\t\tfree (data->metadata->libname);\n\t\t\tfree (data->metadata->arch);\n\t\t\tfree (data->metadata->machine);\n\t\t\tfree (data->metadata);\n\t\t}\n\t\tfree (data->file);\n\t\tfree (data->buffer);\n\t\tfree (data);\n\t}\n}\n\nR_API RBinObject *r_bin_file_object_get_cur(RBinFile *binfile) {\n\treturn binfile? binfile->o: NULL;\n}\n\nR_API RBinObject *r_bin_object_get_cur(RBin *bin) {\n\treturn bin\n\t\t? r_bin_file_object_get_cur (r_bin_cur (bin))\n\t\t: NULL;\n}\n\nR_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *binfile) {\n\treturn binfile && binfile->o? binfile->o->plugin: NULL;\n}\n\nR_API int r_bin_file_cur_set_plugin(RBinFile *binfile, RBinPlugin *plugin) {\n\tif (binfile && binfile->o) {\n\t\tbinfile->o->plugin = plugin;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// maybe too big sometimes? 2KB of stack eaten here..\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n\nstatic int string_scan_range(RList *list, const ut8 *buf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type) {\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (!buf || !min) {\n\t\treturn -1;\n\t}\n\twhile (needle < to) {\n\t\trc = r_utf8_decode (buf + needle, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc;\n\t\t\tif ((to - needle) > 4) {\n\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\tif (is_wide32) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\n\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r)) {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (&tmp[i], r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\e\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 28) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes >= min) {\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\t// reduce false positives\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (list) {\n\t\t\t\tRBinString *new = R_NEW0 (RBinString);\n\t\t\t\tif (!new) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->type = str_type;\n\t\t\t\tnew->length = runes;\n\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t// TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->paddr = new->vaddr = str_start;\n\t\t\t\tnew->string = r_str_ndup ((const char *)tmp, i);\n\t\t\t\tr_list_append (list, new);\n\t\t\t} else {\n\t\t\t\t// DUMP TO STDOUT. raw dumping for rabin2 -zzz\n\t\t\t\tprintf (\"0x%08\" PFMT64x \" %s\\n\", str_start, tmp);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic void get_strings_range(RBinFile *arch, RList *list, int min, ut64 from, ut64 to) {\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (arch);\n\tRBinString *ptr;\n\tRListIter *it;\n\n\tif (!arch || !arch->buf || !arch->buf->buf) {\n\t\treturn;\n\t}\n\tif (!arch->rawstr) {\n\t\tif (!plugin || !plugin->info) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\t/* Some plugins return zero, fix it up */\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!to || to > arch->buf->length) {\n\t\tto = arch->buf->length;\n\t}\n\tif (arch->rawstr != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (arch->rbin->maxstrbuf && size && size > arch->rbin->maxstrbuf) {\n\t\t\tif (arch->rbin->verbose) {\n\t\t\t\teprintf (\"WARNING: bin_strings buffer is too big \"\n\t\t\t\t\t\"(0x%08\" PFMT64x\n\t\t\t\t\t\").\"\n\t\t\t\t\t\" Use -zzz or set bin.maxstrbuf \"\n\t\t\t\t\t\"(RABIN2_MAXSTRBUF) in r2 (rabin2)\\n\",\n\t\t\t\t\tsize);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (string_scan_range (list, arch->buf->buf, min, from, to, -1) < 0) {\n\t\treturn;\n\t}\n\tr_list_foreach (list, it, ptr) {\n\t\tRBinSection *s = r_bin_get_section_at (arch->o, ptr->paddr, false);\n\t\tif (s) {\n\t\t\tptr->vaddr = s->vaddr + (ptr->paddr - s->paddr);\n\t\t}\n\t}\n}\n\nstatic int is_data_section(RBinFile *a, RBinSection *s) {\n\tif (s->has_strings || s->is_data) {\n\t\treturn true;\n\t}\n\tif (s->is_data) {\n\t\treturn true;\n\t}\n \t// Rust\n\treturn (strstr (s->name, \"_const\") != NULL);\n}\n\nstatic RList *get_strings(RBinFile *a, int min, int dump) {\n\tRListIter *iter;\n\tRBinSection *section;\n\tRBinObject *o = a? a->o: NULL;\n\tRList *ret;\n\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tif (dump) {\n\t\t/* dump to stdout, not stored in list */\n\t\tret = NULL;\n\t} else {\n\t\tret = r_list_newf (r_bin_string_free);\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (o->sections && !r_list_empty (o->sections) && !a->rawstr) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (is_data_section (a, section)) {\n\t\t\t\tget_strings_range (a, ret, min, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tRBinString *s;\n\t\t\tRListIter *iter2;\n\t\t\t/* load objc/swift strings */\n\t\t\tconst int bits = (a->o && a->o->info) ? a->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\tif (!r_buf_read_at (\n\t\t\t\t\t\t    a->buf, section->paddr + i + cfstr_offs,\n\t\t\t\t\t\t    buf, sizeof (buf))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = buf;\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64)\n\t\t\t\t\t\t\t\t   ? r_read_le64 (p)\n\t\t\t\t\t\t\t\t   : r_read_le32 (p);\n\t\t\t\t\tr_list_foreach (ret, iter2, s) {\n\t\t\t\t\t\tif (s->vaddr == cstr_vaddr) {\n\t\t\t\t\t\t\tRBinString *new = R_NEW0 (RBinString);\n\t\t\t\t\t\t\tnew->type = s->type;\n\t\t\t\t\t\t\tnew->length = s->length;\n\t\t\t\t\t\t\tnew->size = s->size;\n\t\t\t\t\t\t\tnew->ordinal = s->ordinal;\n\t\t\t\t\t\t\tnew->paddr = new->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\tnew->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\tr_list_append (ret, new);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tget_strings_range (a, ret, min, 0, a->size);\n\t}\n\treturn ret;\n}\n\nR_API RList* r_bin_raw_strings(RBinFile *a, int min) {\n\tRList *l = NULL;\n\tif (a) {\n\t\tint tmp = a->rawstr;\n\t\ta->rawstr = 2;\n\t\tl = get_strings (a, min, 0);\n\t\ta->rawstr = tmp;\n\t}\n\treturn l;\n}\n\nR_API int r_bin_dump_strings(RBinFile *a, int min) {\n\tget_strings (a, min, 1);\n\treturn 0;\n}\n\n/* This is very slow if there are lot of symbols */\nR_API int r_bin_load_languages(RBinFile *binfile) {\n\tif (r_bin_lang_rust (binfile)) {\n\t\treturn R_BIN_NM_RUST;\n\t}\n\tif (r_bin_lang_swift (binfile)) {\n\t\treturn R_BIN_NM_SWIFT;\n\t}\n\tif (r_bin_lang_objc (binfile)) {\n\t\treturn R_BIN_NM_OBJC;\n\t}\n\tif (r_bin_lang_cxx (binfile)) {\n\t\treturn R_BIN_NM_CXX;\n\t}\n\tif (r_bin_lang_dlang (binfile)) {\n\t\treturn R_BIN_NM_DLANG;\n\t}\n\tif (r_bin_lang_msvc (binfile)) {\n\t\treturn R_BIN_NM_MSVC;\n\t}\n\treturn R_BIN_NM_NONE;\n}\n\nstatic void mem_free(void *data) {\n\tRBinMem *mem = (RBinMem *)data;\n\tif (mem && mem->mirrors) {\n\t\tmem->mirrors->free = mem_free;\n\t\tr_list_free (mem->mirrors);\n\t\tmem->mirrors = NULL;\n\t}\n\tfree (mem);\n}\n\nstatic void r_bin_object_delete_items(RBinObject *o) {\n\tut32 i = 0;\n\tif (!o) {\n\t\treturn;\n\t}\n\tr_list_free (o->entries);\n\tr_list_free (o->fields);\n\tr_list_free (o->imports);\n\tr_list_free (o->libs);\n\tr_list_free (o->relocs);\n\tr_list_free (o->sections);\n\tr_list_free (o->strings);\n\tr_list_free (o->symbols);\n\tr_list_free (o->classes);\n\tr_list_free (o->lines);\n\tsdb_free (o->kv);\n\tif (o->mem) {\n\t\to->mem->free = mem_free;\n\t}\n\tr_list_free (o->mem);\n\to->mem = NULL;\n\to->entries = NULL;\n\to->fields = NULL;\n\to->imports = NULL;\n\to->libs = NULL;\n\to->relocs = NULL;\n\to->sections = NULL;\n\to->strings = NULL;\n\to->symbols = NULL;\n\to->classes = NULL;\n\to->lines = NULL;\n\to->info = NULL;\n\to->kv = NULL;\n\tfor (i = 0; i < R_BIN_SYM_LAST; i++) {\n\t\tfree (o->binsym[i]);\n\t\to->binsym[i] = NULL;\n\t}\n}\n\nR_API void r_bin_info_free(RBinInfo *rb) {\n\tif (!rb) {\n\t\treturn;\n\t}\n\tfree (rb->intrp);\n\tfree (rb->file);\n\tfree (rb->type);\n\tfree (rb->bclass);\n\tfree (rb->rclass);\n\tfree (rb->arch);\n\tfree (rb->cpu);\n\tfree (rb->machine);\n\tfree (rb->os);\n\tfree (rb->subsystem);\n\tfree (rb->rpath);\n\tfree (rb->guid);\n\tfree (rb->debug_file_name);\n\tfree (rb);\n}\n\nR_API void r_bin_import_free(void *_imp) {\n\tRBinImport *imp = (RBinImport *)_imp;\n\tif (imp) {\n\t\tR_FREE (imp->name);\n\t\tR_FREE (imp->classname);\n\t\tR_FREE (imp->descriptor);\n\t\tfree (imp);\n\t}\n}\n\nR_API void r_bin_symbol_free(void *_sym) {\n\tRBinSymbol *sym = (RBinSymbol *)_sym;\n\tfree (sym->name);\n\tfree (sym->classname);\n\tfree (sym);\n}\n\nR_API void r_bin_string_free(void *_str) {\n\tRBinString *str = (RBinString *)_str;\n\tfree (str->string);\n\tfree (str);\n}\n\nstatic void r_bin_object_free(void /*RBinObject*/ *o_) {\n\tRBinObject *o = o_;\n\tif (!o) {\n\t\treturn;\n\t}\n\tr_bin_info_free (o->info);\n\tr_bin_object_delete_items (o);\n\tR_FREE (o);\n}\n\nstatic char *swiftField(const char *dn, const char *cn) {\n\tchar *p = strstr (dn, \".getter_\");\n\tif (!p) {\n\t\tp = strstr (dn, \".setter_\");\n\t\tif (!p) {\n\t\t\tp = strstr (dn, \".method_\");\n\t\t}\n\t}\n\tif (p) {\n\t\tchar *q = strstr (dn, cn);\n\t\tif (q && q[strlen (cn)] == '.') {\n\t\t\tq = strdup (q + strlen (cn) + 1);\n\t\t\tchar *r = strchr (q, '.');\n\t\t\tif (r) {\n\t\t\t\t*r = 0;\n\t\t\t}\n\t\t\treturn q;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_classes_from_symbols (RBinFile *bf, RBinObject *o) {\n\tRBinSymbol *sym;\n\tRListIter *iter;\n\tRList *symbols = o->symbols;\n\tRList *classes = o->classes;\n\tif (!classes) {\n\t\tclasses = r_list_newf ((RListFree)r_bin_class_free);\n\t}\n\tr_list_foreach (symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRBinClass *c = r_bin_class_new (bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// swift specific\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField (dn, cn);\n\t\t\tif (fn) {\n\t\t\t\t// eprintf (\"FIELD %s  %s\\n\", cn, fn);\n\t\t\t\tRBinField *f = r_bin_field_new (sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL);\n\t\t\t\tr_list_append (c->fields, f);\n\t\t\t\tfree (fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr (dn, \"..\");\n\t\t\t\tif (mn) {\n\t\t\t\t\t// eprintf (\"META %s  %s\\n\", sym->classname, mn);\n\t\t\t\t} else {\n\t\t\t\t\tchar *mn = strstr (dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\tmn += strlen (cn) + 1;\n\t\t\t\t\t\t// eprintf (\"METHOD %s  %s\\n\", sym->classname, mn);\n\t\t\t\t\t\tr_list_append (c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (r_list_empty (classes)) {\n\t\tr_list_free (classes);\n\t\treturn NULL;\n\t}\n\treturn classes;\n}\n\n// XXX - change this to RBinObject instead of RBinFile\n// makes no sense to pass in a binfile and set the RBinObject\n// kinda a clunky functions\nR_API int r_bin_object_set_items(RBinFile *binfile, RBinObject *o) {\n\tRBinObject *old_o;\n\tRBinPlugin *cp;\n\tint i, minlen;\n\tRBin *bin;\n\tif (!binfile || !o || !o->plugin) {\n\t\treturn false;\n\t}\n\tbin = binfile->rbin;\n\told_o = binfile->o;\n\tcp = o->plugin;\n\tif (binfile->rbin->minstrlen > 0) {\n\t\tminlen = binfile->rbin->minstrlen;\n\t} else {\n\t\tminlen = cp->minstrlen;\n\t}\n\tbinfile->o = o;\n\tif (cp->baddr) {\n\t\tut64 old_baddr = o->baddr;\n\t\to->baddr = cp->baddr (binfile);\n\t\tbinobj_set_baddr (o, old_baddr);\n\t}\n\tif (cp->boffset) {\n\t\to->boffset = cp->boffset (binfile);\n\t}\n\t// XXX: no way to get info from xtr pluginz?\n\t// Note, object size can not be set from here due to potential\n\t// inconsistencies\n\tif (cp->size) {\n\t\to->size = cp->size (binfile);\n\t}\n\tif (cp->binsym) {\n\t\tfor (i = 0; i < R_BIN_SYM_LAST; i++) {\n\t\t\to->binsym[i] = cp->binsym (binfile, i);\n\t\t\tif (o->binsym[i]) {\n\t\t\t\to->binsym[i]->paddr += o->loadaddr;\n\t\t\t}\n\t\t}\n\t}\n\tif (cp->entries) {\n\t\to->entries = cp->entries (binfile);\n\t\tREBASE_PADDR (o, o->entries, RBinAddr);\n\t}\n\tif (cp->fields) {\n\t\to->fields = cp->fields (binfile);\n\t\tif (o->fields) {\n\t\t\to->fields->free = r_bin_field_free;\n\t\t\tREBASE_PADDR (o, o->fields, RBinField);\n\t\t}\n\t}\n\tif (cp->imports) {\n\t\tr_list_free (o->imports);\n\t\to->imports = cp->imports (binfile);\n\t\tif (o->imports) {\n\t\t\to->imports->free = r_bin_import_free;\n\t\t}\n\t}\n\t//if (bin->filter_rules & (R_BIN_REQ_SYMBOLS | R_BIN_REQ_IMPORTS)) {\n\tif (true) {\n\t\tif (cp->symbols) {\n\t\t\to->symbols = cp->symbols (binfile);\n\t\t\tif (o->symbols) {\n\t\t\t\to->symbols->free = r_bin_symbol_free;\n\t\t\t\tREBASE_PADDR (o, o->symbols, RBinSymbol);\n\t\t\t\tif (bin->filter) {\n\t\t\t\t\tr_bin_filter_symbols (o->symbols);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//}\n\to->info = cp->info? cp->info (binfile): NULL;\n\tif (cp->libs) {\n\t\to->libs = cp->libs (binfile);\n\t}\n\tif (cp->sections) {\n\t\t// XXX sections are populated by call to size\n\t\tif (!o->sections) {\n\t\t\to->sections = cp->sections (binfile);\n\t\t}\n\t\tREBASE_PADDR (o, o->sections, RBinSection);\n\t\tif (bin->filter) {\n\t\t\tr_bin_filter_sections (o->sections);\n\t\t}\n\t}\n\tif (bin->filter_rules & (R_BIN_REQ_RELOCS | R_BIN_REQ_IMPORTS)) {\n\t\tif (cp->relocs) {\n\t\t\to->relocs = cp->relocs (binfile);\n\t\t\tREBASE_PADDR (o, o->relocs, RBinReloc);\n\t\t}\n\t}\n\tif (bin->filter_rules & R_BIN_REQ_STRINGS) {\n\t\tif (cp->strings) {\n\t\t\to->strings = cp->strings (binfile);\n\t\t} else {\n\t\t\to->strings = get_strings (binfile, minlen, 0);\n\t\t}\n\t\tif (bin->debase64) {\n\t\t\tfilterStrings (bin, o->strings);\n\t\t}\n\t\tREBASE_PADDR (o, o->strings, RBinString);\n\t}\n\tif (bin->filter_rules & R_BIN_REQ_CLASSES) {\n\t\tif (cp->classes) {\n\t\t\to->classes = cp->classes (binfile);\n\t\t\tif (r_bin_lang_swift (binfile)) {\n\t\t\t\to->classes = r_bin_classes_from_symbols (binfile, o);\n\t\t\t}\n\t\t} else {\n\t\t\to->classes = r_bin_classes_from_symbols (binfile, o);\n\t\t}\n\t\tif (bin->filter) {\n\t\t\tr_bin_filter_classes (o->classes);\n\t\t}\n\t}\n\tif (cp->lines) {\n\t\to->lines = cp->lines (binfile);\n\t}\n\tif (cp->get_sdb) {\n\t\tSdb* new_kv = cp->get_sdb (binfile);\n\t\tif (new_kv != o->kv) {\n\t\t\tsdb_free (o->kv);\n\t\t}\n\t\to->kv = new_kv;\n\t}\n\tif (cp->mem)  {\n\t\to->mem = cp->mem (binfile);\n\t}\n\tif (bin->filter_rules & (R_BIN_REQ_SYMBOLS | R_BIN_REQ_IMPORTS)) {\n\t\to->lang = r_bin_load_languages (binfile);\n\t}\n\tbinfile->o = old_o;\n\treturn true;\n}\n\n// XXX - this is a rather hacky way to do things, there may need to be a better\n// way.\nR_API int r_bin_load(RBin *bin, const char *file, ut64 baseaddr, ut64 loadaddr, int xtr_idx, int fd, int rawstr) {\n\tif (!bin) {\n\t\treturn false;\n\t}\n\t// ALIAS?\treturn r_bin_load_as (bin, file, baseaddr, loadaddr,\n\t// xtr_idx, fd, rawstr, 0, file);\n\tRIOBind *iob = &(bin->iob);\n\tif (!iob) {\n\t\treturn false;\n\t}\n\tif (!iob->io) {\n\t\tiob->io = r_io_new ();\t//wtf\n\t\tif (!iob->io) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->io_owned = true;\n\t\tr_io_bind (iob->io, &bin->iob);\t\t//memleak?\n\t\tiob = &bin->iob;\n\t}\n\tif (!iob->desc_get (iob->io, fd)) {\n\t\tfd = iob->fd_open (iob->io, file, R_IO_READ, 0644);\n\t}\n\tbin->rawstr = rawstr;\n\t// Use the current RIODesc otherwise r_io_map_select can swap them later on\n\tif (fd < 0) {\n\t\tr_io_free (iob->io);\n\t\tmemset (&bin->iob, 0, sizeof (bin->iob));\n\t\tbin->io_owned = false;\n\t\treturn false;\n\t}\n\t//Use the current RIODesc otherwise r_io_map_select can swap them later on\n\treturn r_bin_load_io (bin, fd, baseaddr, loadaddr, xtr_idx);\n}\n\nR_API int r_bin_load_as(RBin *bin, const char *file, ut64 baseaddr,\n\t\t\t ut64 loadaddr, int xtr_idx, int fd, int rawstr,\n\t\t\t int fileoffset, const char *name) {\n\tRIOBind *iob = &(bin->iob);\n\tif (!iob || !iob->io) {\n\t\treturn false;\n\t}\n\tif (fd < 0) {\n\t\tfd = iob->fd_open (iob->io, file, R_IO_READ, 0644);\n\t}\n\tif (fd < 0) {\n\t\treturn false;\n\t}\n\treturn r_bin_load_io_at_offset_as (bin, fd, baseaddr, loadaddr,\n\t\t\t\t\t\t  xtr_idx, fileoffset, name);\n}\n\nR_API int r_bin_reload(RBin *bin, int fd, ut64 baseaddr) {\n\tRIOBind *iob = &(bin->iob);\n\tRList *the_obj_list = NULL;\n\tint res = false;\n\tRBinFile *bf = NULL;\n\tut8 *buf_bytes = NULL;\n\tut64 sz = UT64_MAX;\n\n\tif (!iob || !iob->io) {\n\t\tres = false;\n\t\tgoto error;\n\t}\n\tconst char *name = iob->fd_get_name (iob->io, fd);\n\tbf = r_bin_file_find_by_name (bin, name);\n\tif (!bf) {\n\t\tres = false;\n\t\tgoto error;\n\t}\n\n\tthe_obj_list = bf->objs;\n\n\tbf->objs = r_list_newf ((RListFree)r_bin_object_free);\n\t// invalidate current object reference\n\tbf->o = NULL;\n\n\tsz = iob->fd_size (iob->io, fd);\n\tif (sz == UT64_MAX || sz > (64 * 1024 * 1024)) { \n\t\t// too big, probably wrong\n\t\teprintf (\"Too big\\n\");\n\t\tres = false;\n\t\tgoto error;\n\t}\n\tif (sz == UT64_MAX && iob->fd_is_dbg (iob->io, fd)) {\n\t\t// attempt a local open and read\n\t\t// This happens when a plugin like debugger does not have a\n\t\t// fixed size.\n\t\t// if there is no fixed size or its MAXED, there is no way to\n\t\t// definitively\n\t\t// load the bin-properly.  Many of the plugins require all\n\t\t// content and are not\n\t\t// stream based loaders\n\t\tint tfd = iob->fd_open (iob->io, name, R_IO_READ, 0);\n\t\tif (tfd < 0) {\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tsz = iob->fd_size (iob->io, tfd);\n\t\tif (sz == UT64_MAX) {\n\t\t\tiob->fd_close (iob->io, tfd);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\tiob->fd_close (iob->io, tfd);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!iob->read_at (iob->io, 0LL, buf_bytes, sz)) {\n\t\t\tfree (buf_bytes);\n\t\t\tiob->fd_close (iob->io, tfd);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tiob->fd_close (iob->io, tfd);\n\t} else {\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!iob->fd_read_at (iob->io, fd, 0LL, buf_bytes, sz)) {\n\t\t\tfree (buf_bytes);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tbool yes_plz_steal_ptr = true;\n\tr_bin_file_set_bytes (bf, buf_bytes, sz, yes_plz_steal_ptr);\n\n\tif (r_list_length (the_obj_list) == 1) {\n\t\tRBinObject *old_o = (RBinObject *)r_list_get_n (the_obj_list, 0);\n\t\tres = r_bin_load_io_at_offset_as (bin, fd, baseaddr,\n\t\t\t\t\t\told_o->loadaddr, 0, old_o->boffset, NULL);\n\t} else {\n\t\tRListIter *iter = NULL;\n\t\tRBinObject *old_o;\n\t\tr_list_foreach (the_obj_list, iter, old_o) {\n\t\t\t// XXX - naive. do we need a way to prevent multiple \"anys\" from being opened?\n\t\t\tres = r_bin_load_io_at_offset_as (bin, fd, baseaddr,\n\t\t\t\told_o->loadaddr, 0, old_o->boffset, old_o->plugin->name);\n\t\t}\n\t}\n\tbf->o = r_list_get_n (bf->objs, 0);\n\nerror:\n\tr_list_free (the_obj_list);\n\n\treturn res;\n}\n\nR_API int r_bin_load_io(RBin *bin, int fd, ut64 baseaddr, ut64 loadaddr, int xtr_idx) {\n\treturn r_bin_load_io_at_offset_as (bin, fd, baseaddr, loadaddr, xtr_idx, 0, NULL);\n}\n\nR_API int r_bin_load_io_at_offset_as_sz(RBin *bin, int fd, ut64 baseaddr,\n\t\tut64 loadaddr, int xtr_idx, ut64 offset, const char *name, ut64 sz) {\n\tRIOBind *iob = &(bin->iob);\n\tRIO *io = iob? iob->io: NULL;\n\tRListIter *it;\n\tut8 *buf_bytes = NULL;\n\tRBinXtrPlugin *xtr;\n\tut64 file_sz = UT64_MAX;\n\tRBinFile *binfile = NULL;\n\tint tfd = -1;\n\n\tif (!io || (fd < 0) || (st64)sz < 0) {\n\t\treturn false;\n\t}\n\tbool is_debugger = iob->fd_is_dbg (io, fd);\n\tconst char *fname = iob->fd_get_name (io, fd);\n\tif (loadaddr == UT64_MAX) {\n\t\tloadaddr = 0;\n\t}\n\tfile_sz = iob->fd_size (io, fd);\n\t// file_sz = UT64_MAX happens when attaching to frida:// and other non-debugger io plugins which results in double opening\n\tif (is_debugger && file_sz == UT64_MAX) {\n\t\ttfd = iob->fd_open (io, fname, R_IO_READ, 0644);\n\t\tif (tfd >= 1) {\n\t\t\tfile_sz = iob->fd_size (io, tfd);\n\t\t}\n\t}\n\tif (!sz) {\n\t\tsz = file_sz;\n\t}\n\n\tbin->file = fname;\n\tsz = R_MIN (file_sz, sz);\n\tif (!r_list_length (bin->binfiles)) {\n\t\tif (is_debugger) {\n\t\t\t//use the temporal RIODesc to read the content of the file instead\n\t\t\t//from the memory\n\t\t\tif (tfd >= 0) {\n\t\t\t\tbuf_bytes = calloc (1, sz + 1);\n\t\t\t\tiob->fd_read_at (io, tfd, 0, buf_bytes, sz);\n\t\t\t\t// iob->fd_close (io, tfd);\n\t\t\t}\n\t\t}\n\t}\n\tif (!buf_bytes) {\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\treturn false;\n\t\t}\n\t\tut64 seekaddr = is_debugger? baseaddr: loadaddr;\n\t\tif (!iob->fd_read_at (io, fd, seekaddr, buf_bytes, sz)) {\n\t\t\tsz = 0LL;\n\t\t}\n\t}\n\n\tif (!name && (st64)sz > 0) {\n\t\t// XXX - for the time being this is fine, but we may want to\n\t\t// change the name to something like\n\t\t// <xtr_name>:<bin_type_name>\n\t\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\t\tif (xtr && xtr->check_bytes (buf_bytes, sz)) {\n\t\t\t\tif (xtr && (xtr->extract_from_bytes || xtr->extractall_from_bytes)) {\n\t\t\t\t\tif (is_debugger && sz != file_sz) {\n\t\t\t\t\t\tR_FREE (buf_bytes);\n\t\t\t\t\t\tif (tfd < 0) {\n\t\t\t\t\t\t\ttfd = iob->fd_open (io, fname, R_IO_READ, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsz = iob->fd_size (io, tfd);\n\t\t\t\t\t\tif (sz != UT64_MAX) {\n\t\t\t\t\t\t\tbuf_bytes = calloc (1, sz + 1);\n\t\t\t\t\t\t\tif (buf_bytes) {\n\t\t\t\t\t\t\t\t(void) iob->fd_read_at (io, tfd, 0, buf_bytes, sz);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t//DOUBLECLOSE UAF : iob->fd_close (io, tfd);\n\t\t\t\t\t\ttfd = -1;\t// marking it closed\n\t\t\t\t\t} else if (sz != file_sz) {\n\t\t\t\t\t\t(void) iob->read_at (io, 0LL, buf_bytes, sz);\n\t\t\t\t\t}\n\t\t\t\t\tbinfile = r_bin_file_xtr_load_bytes (bin, xtr,\n\t\t\t\t\t\tfname, buf_bytes, sz, file_sz,\n\t\t\t\t\t\tbaseaddr, loadaddr, xtr_idx,\n\t\t\t\t\t\tfd, bin->rawstr);\n\t\t\t\t}\n\t\t\t\txtr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!binfile) {\n\t\tbool steal_ptr = true; // transfer buf_bytes ownership to binfile\n\t\tbinfile = r_bin_file_new_from_bytes (\n\t\t\tbin, fname, buf_bytes, sz, file_sz, bin->rawstr,\n\t\t\tbaseaddr, loadaddr, fd, name, NULL, offset, steal_ptr);\n\t}\n\treturn binfile? r_bin_file_set_cur_binfile (bin, binfile): false;\n}\n\nR_API bool r_bin_load_io_at_offset_as(RBin *bin, int fd, ut64 baseaddr,\n\t\tut64 loadaddr, int xtr_idx, ut64 offset, const char *name) {\n\t// adding file_sz to help reduce the performance impact on the system\n\t// in this case the number of bytes read will be limited to 2MB\n\t// (MIN_LOAD_SIZE)\n\t// if it fails, the whole file is loaded.\n\tconst ut64 MAX_LOAD_SIZE = 0;  // 0xfffff; //128 * (1 << 10 << 10);\n\tint res = r_bin_load_io_at_offset_as_sz (bin, fd, baseaddr,\n\t\tloadaddr, xtr_idx, offset, name, MAX_LOAD_SIZE);\n\tif (!res) {\n\t\tres = r_bin_load_io_at_offset_as_sz (bin, fd, baseaddr,\n\t\t\tloadaddr, xtr_idx, offset, name, UT64_MAX);\n\t}\n\treturn res;\n}\n\nR_API int r_bin_file_deref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_deref (bin, a);\n}\n\nR_API int r_bin_file_deref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tint res = false;\n\tif (a && !o) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t} else if (a && o->referenced - 1 < 1) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t\t// not thread safe\n\t} else if (o) {\n\t\to->referenced--;\n\t}\n\t// it is possible for a file not\n\t// to be bound to RBin and RBinFiles\n\t// XXX - is this an ok assumption?\n\tif (bin) bin->cur = NULL;\n\treturn res;\n}\n\nR_API int r_bin_file_ref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_ref (bin, a);\n}\n\nR_API int r_bin_file_ref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (a && o) {\n\t\to->referenced--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void r_bin_file_free(void /*RBinFile*/ *bf_) {\n\tRBinFile *a = bf_;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\n\tif (!a) {\n\t\treturn;\n\t}\n\n\t// Binary format objects are connected to the\n\t// RBinObject, so the plugin must destroy the\n\t// format data first\n\tif (plugin && plugin->destroy) {\n\t\tplugin->destroy (a);\n\t}\n\tif (a->curxtr && a->curxtr->destroy && a->xtr_obj) {\n\t\ta->curxtr->free_xtr ((void *)(a->xtr_obj));\n\t}\n\tr_buf_free (a->buf);\n\t// TODO: unset related sdb namespaces\n\tif (a && a->sdb_addrinfo) {\n\t\tsdb_free (a->sdb_addrinfo);\n\t\ta->sdb_addrinfo = NULL;\n\t}\n\tfree (a->file);\n\ta->o = NULL;\n\tr_list_free (a->objs);\n\tr_list_free (a->xtr_data);\n\tr_id_pool_kick_id (a->rbin->file_ids, a->id);\n\tmemset (a, 0, sizeof (RBinFile));\n\tfree (a);\n}\n\nstatic RBinFile *r_bin_file_create_append(RBin *bin, const char *file,\n\t\t\t\t\t   const ut8 *bytes, ut64 sz,\n\t\t\t\t\t   ut64 file_sz, int rawstr, int fd,\n\t\t\t\t\t   const char *xtrname, bool steal_ptr) {\n\tRBinFile *bf = r_bin_file_new (bin, file, bytes, sz, file_sz, rawstr,\n\t\t\t\t       fd, xtrname, bin->sdb, steal_ptr);\n\tif (bf) {\n\t\tr_list_append (bin->binfiles, bf);\n\t}\n\treturn bf;\n}\n\n// This function populate RBinFile->xtr_data, that information is enough to\n// create RBinObject when needed using r_bin_file_object_new_from_xtr_data\nstatic RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr,\n\t\t\t\t\t    const char *filename,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, ut64 baseaddr,\n\t\t\t\t\t    ut64 loadaddr, int idx, int fd,\n\t\t\t\t\t    int rawstr) {\n\tif (!bin || !bytes) {\n\t\treturn NULL;\n\t}\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_create_append (bin, filename, bytes, sz,\n\t\t\t\t\t       file_sz, rawstr, fd, xtr->name, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tif (bf->xtr_data) {\n\t\tr_list_free (bf->xtr_data);\n\t}\n\tif (xtr && bytes) {\n\t\tRList *xtr_data_list = xtr->extractall_from_bytes (bin, bytes, sz);\n\t\tRListIter *iter;\n\t\tRBinXtrData *xtr;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (xtr_data_list, iter, xtr) {\n\t\t\txtr->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\txtr->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t\tbf->loadaddr = loadaddr;\n\t\tbf->xtr_data = xtr_data_list ? xtr_data_list : NULL;\n\t}\n\treturn bf;\n}\n\nstatic RBinPlugin *r_bin_get_binplugin_by_name(RBin *bin, const char *name) {\n\tRBinPlugin *plugin;\n\tRListIter *it;\n\tif (bin && name) {\n\t\tr_list_foreach (bin->plugins, it, plugin) {\n\t\t\tif (!strcmp (plugin->name, name)) {\n\t\t\t\treturn plugin;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinPlugin *r_bin_get_binplugin_by_bytes(RBin *bin, const ut8 *bytes, ut64 sz) {\n\tRBinPlugin *plugin;\n\tRListIter *it;\n\tif (!bin || !bytes) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->plugins, it, plugin) {\n\t\tif (plugin->check_bytes && plugin->check_bytes (bytes, sz)) {\n\t\t\treturn plugin;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic RBinXtrPlugin *r_bin_get_xtrplugin_by_name(RBin *bin, const char *name) {\n\tRBinXtrPlugin *xtr;\n\tRListIter *it;\n\tif (!bin || !name) return NULL;\n\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\tif (!strcmp (xtr->name, name)) {\n\t\t\treturn xtr;\n\t\t}\n\t\t// must be set to null\n\t\txtr = NULL;\n\t}\n\treturn NULL;\n}\n\nstatic RBinPlugin *r_bin_get_binplugin_any(RBin *bin) {\n\treturn r_bin_get_binplugin_by_name (bin, \"any\");\n}\n\nstatic RBinObject *r_bin_object_new(RBinFile *binfile, RBinPlugin *plugin,\n\t\t\t\t     ut64 baseaddr, ut64 loadaddr, ut64 offset,\n\t\t\t\t     ut64 sz) {\n\tconst ut8 *bytes = binfile? r_buf_buffer (binfile->buf): NULL;\n\tut64 bytes_sz = binfile? r_buf_size (binfile->buf): 0;\n\tSdb *sdb = binfile? binfile->sdb: NULL;\n\tRBinObject *o = R_NEW0 (RBinObject);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\to->obj_size = bytes && (bytes_sz >= sz + offset)? sz: 0;\n\to->boffset = offset;\n\to->id = r_num_rand (0xfffff000);\n\to->kv = sdb_new0 ();\n\to->baddr = baseaddr;\n\to->baddr_shift = 0;\n\to->plugin = plugin;\n\to->loadaddr = loadaddr != UT64_MAX ? loadaddr : 0;\n\n\t// XXX more checking will be needed here\n\t// only use LoadBytes if buffer offset != 0\n\t// if (offset != 0 && bytes && plugin && plugin->load_bytes && (bytes_sz\n\t// >= sz + offset) ) {\n\tif (bytes && plugin && plugin->load_bytes && (bytes_sz >= sz + offset)) {\n\t\tut64 bsz = bytes_sz - offset;\n\t\tif (sz < bsz) {\n\t\t\tbsz = sz;\n\t\t}\n\t\to->bin_obj = plugin->load_bytes (binfile, bytes + offset, sz,\n\t\t\t\t\t\t loadaddr, sdb);\n\t\tif (!o->bin_obj) {\n\t\t\tbprintf (\n\t\t\t\t\"Error in r_bin_object_new: load_bytes failed \"\n\t\t\t\t\"for %s plugin\\n\",\n\t\t\t\tplugin->name);\n\t\t\tsdb_free (o->kv);\n\t\t\tfree (o);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (binfile && plugin && plugin->load) {\n\t\t// XXX - haha, this is a hack.\n\t\t// switching out the current object for the new\n\t\t// one to be processed\n\t\tRBinObject *old_o = binfile->o;\n\t\tbinfile->o = o;\n\t\tif (plugin->load (binfile)) {\n\t\t\tbinfile->sdb_info = o->kv;\n\t\t\t// mark as do not walk\n\t\t\tsdb_ns_set (binfile->sdb, \"info\", o->kv);\n\t\t} else {\n\t\t\tbinfile->o = old_o;\n\t\t}\n\t\to->obj_size = sz;\n\t} else {\n\t\tsdb_free (o->kv);\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\n\t// XXX - binfile could be null here meaning an improper load\n\t// XXX - object size cant be set here and needs to be set where\n\t// where the object is created from.  The reason for this is to prevent\n\t// mis-reporting when the file is loaded from impartial bytes or is\n\t// extracted\n\t// from a set of bytes in the file\n\tr_bin_object_set_items (binfile, o);\n\tr_bin_file_object_add (binfile, o);\n\n\t// XXX this is a very hacky alternative to rewriting the\n\t// RIO stuff, as discussed here:\n\treturn o;\n}\n\n#define LIMIT_SIZE 0\nstatic int r_bin_file_set_bytes(RBinFile *binfile, const ut8 *bytes, ut64 sz, bool steal_ptr) {\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tr_buf_free (binfile->buf);\n\tbinfile->buf = r_buf_new ();\n#if LIMIT_SIZE\n\tif (sz > 1024 * 1024) {\n\t\teprintf (\"Too big\\n\");\n\t\t// TODO: use r_buf_io instead of setbytes all the time to save memory\n\t\treturn NULL;\n\t}\n#else\n\tif (steal_ptr) {\n\t\tr_buf_set_bytes_steal (binfile->buf, bytes, sz);\n\t} else {\n\t\tr_buf_set_bytes (binfile->buf, bytes, sz);\n\t}\n#endif\n\treturn binfile->buf != NULL;\n}\n\nstatic RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes,\n\t\t\t\t ut64 sz, ut64 file_sz, int rawstr, int fd,\n\t\t\t\t const char *xtrname, Sdb *sdb, bool steal_ptr) {\n\tRBinFile *binfile = R_NEW0 (RBinFile);\n\tif (!binfile) {\n\t\treturn NULL;\n\t}\n\tif (!r_id_pool_grab_id (bin->file_ids, &binfile->id)) {\n\t\tif (steal_ptr) { // we own the ptr, free on error\n\t\t\tfree ((void*) bytes);\n\t\t}\n\t\tfree (binfile);\t\t//no id means no binfile\n\t\treturn NULL;\n\t}\n\tint res = r_bin_file_set_bytes (binfile, bytes, sz, steal_ptr);\n\tif (!res && steal_ptr) { // we own the ptr, free on error\n\t\tfree((void*) bytes);\n\t}\n\tbinfile->rbin = bin;\n\tbinfile->file = file? strdup (file): NULL;\n\tbinfile->rawstr = rawstr;\n\tbinfile->fd = fd;\n\tbinfile->curxtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\tbinfile->sdb = sdb;\n\tbinfile->size = file_sz;\n\tbinfile->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);\n\tbinfile->objs = r_list_newf ((RListFree)r_bin_object_free);\n\tbinfile->xtr_obj  = NULL;\n\n\tif (!binfile->buf) {\n\t\t//r_bin_file_free (binfile);\n\t\tbinfile->buf = r_buf_new ();\n\t\t//\treturn NULL;\n\t}\n\n\tif (sdb) {\n\t\tbinfile->sdb = sdb_ns (sdb, sdb_fmt (0, \"fd.%d\", fd), 1);\n\t\tsdb_set (binfile->sdb, \"archs\", \"0:0:x86:32\", 0); // x86??\n\t\t/* NOTE */\n\t\t/* Those refs++ are necessary because sdb_ns() doesnt rerefs all\n\t\t * sub-namespaces */\n\t\t/* And if any namespace is referenced backwards it gets\n\t\t * double-freed */\n\t\tbinfile->sdb_addrinfo = sdb_ns (binfile->sdb, \"addrinfo\", 1);\n\t\tbinfile->sdb_addrinfo->refs++;\n\t\tsdb_ns_set (sdb, \"cur\", binfile->sdb);\n\t\tbinfile->sdb->refs++;\n\t}\n\treturn binfile;\n}\n\nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf,\n\t\t\t\t\t\tut64 baseaddr, ut64 loadaddr,\n\t\t\t\t\t\tRBinXtrData *data) {\n\tRBinObject *o = NULL;\n\tRBinPlugin *plugin = NULL;\n\tut8* bytes;\n\tut64 offset = data? data->offset: 0;\n\tut64 sz = data ? data->size : 0;\n\tif (!data || !bf) {\n\t\treturn false;\n\t}\n\n\t// for right now the bytes used will just be the offest into the binfile\n\t// buffer\n\t// if the extraction requires some sort of transformation then this will\n\t// need to be fixed\n\t// here.\n\tbytes = data->buffer;\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tplugin = r_bin_get_binplugin_by_bytes (bin, (const ut8*)bytes, sz);\n\tif (!plugin) {\n\t\tplugin = r_bin_get_binplugin_any (bin);\n\t}\n\tr_buf_free (bf->buf);\n\tbf->buf = r_buf_new_with_bytes ((const ut8*)bytes, data->size);\n\t//r_bin_object_new append the new object into binfile\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o) {\n\t\treturn false;\n\t}\n\tif (o && !o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tfree (o->info->file);\n\tfree (o->info->arch);\n\tfree (o->info->machine);\n\tfree (o->info->type);\n\to->info->file = strdup (bf->file);\n\to->info->arch = strdup (data->metadata->arch);\n\to->info->machine = strdup (data->metadata->machine);\n\to->info->type = strdup (data->metadata->type);\n\to->info->bits = data->metadata->bits;\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\n\nstatic RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, int rawstr,\n\t\t\t\t\t    ut64 baseaddr, ut64 loadaddr,\n\t\t\t\t\t    int fd, const char *pluginname,\n\t\t\t\t\t    const char *xtrname, ut64 offset,\n\t\t\t\t\t    bool steal_ptr) {\n\tut8 binfile_created = false;\n\tRBinPlugin *plugin = NULL;\n\tRBinXtrPlugin *xtr = NULL;\n\tRBinObject *o = NULL;\n\tRBinFile *bf = NULL;\n\tif (sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\n\tif (xtrname) {\n\t\txtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\t}\n\n\tif (xtr && xtr->check_bytes (bytes, sz)) {\n\t\treturn r_bin_file_xtr_load_bytes (bin, xtr, file,\n\t\t\t\t\t\tbytes, sz, file_sz, baseaddr, loadaddr, 0,\n\t\t\t\t\t\tfd, rawstr);\n\t}\n\n\tif (!bf) {\n\t\tbf = r_bin_file_create_append (bin, file, bytes, sz, file_sz,\n\t\t\t\t\t       rawstr, fd, xtrname, steal_ptr);\n\t\tif (!bf) {\n\t\t\tif (!steal_ptr) { // we own the ptr, free on error\n\t\t\t\tfree ((void*) bytes);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tbinfile_created = true;\n\t}\n\n\tif (bin->force) {\n\t\tplugin = r_bin_get_binplugin_by_name (bin, bin->force);\n\t}\n\tif (!plugin) {\n\t\tif (pluginname) {\n\t\t\tplugin = r_bin_get_binplugin_by_name (bin, pluginname);\n\t\t}\n\t\tif (!plugin) {\n\t\t\tplugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);\n\t\t\tif (!plugin) {\n\t\t\t\tplugin = r_bin_get_binplugin_any (bin);\n\t\t\t}\n\t\t}\n\t}\n\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (o && !o->size) {\n\t\to->size = file_sz;\n\t}\n\n\tif (!o) {\n\t\tif (bf && binfile_created) {\n\t\t\tr_list_delete_data (bin->binfiles, bf);\n\t\t}\n\t\treturn NULL;\n\t}\n\t/* WTF */\n\tif (strcmp (plugin->name, \"any\")) {\n\t\tbf->narch = 1;\n\t}\n\n\t/* free unnecessary rbuffer (???) */\n\treturn bf;\n}\n\nstatic void plugin_free(RBinPlugin *p) {\n\tif (p && p->fini) {\n\t\tp->fini (NULL);\n\t}\n\tR_FREE (p);\n}\n\n// rename to r_bin_plugin_add like the rest\nR_API int r_bin_add(RBin *bin, RBinPlugin *foo) {\n\tRListIter *it;\n\tRBinPlugin *plugin;\n\tif (foo->init) {\n\t\tfoo->init (bin->user);\n\t}\n\tr_list_foreach (bin->plugins, it, plugin) {\n\t\tif (!strcmp (plugin->name, foo->name)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tplugin = R_NEW0 (RBinPlugin);\n\tmemcpy (plugin, foo, sizeof (RBinPlugin));\n\tr_list_append (bin->plugins, plugin);\n\treturn true;\n}\n\nR_API int r_bin_xtr_add(RBin *bin, RBinXtrPlugin *foo) {\n\tRListIter *it;\n\tRBinXtrPlugin *xtr;\n\n\tif (foo->init) {\n\t\tfoo->init (bin->user);\n\t}\n\t// avoid duplicates\n\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\tif (!strcmp (xtr->name, foo->name)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_list_append (bin->binxtrs, foo);\n\treturn true;\n}\n\nR_API void *r_bin_free(RBin *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->io_owned) {\n\t\tr_io_free (bin->iob.io);\n\t}\n\tbin->file = NULL;\n\tfree (bin->force);\n\tfree (bin->srcdir);\n\t//r_bin_free_bin_files (bin);\n\tr_list_free (bin->binfiles);\n\tr_list_free (bin->binxtrs);\n\tr_list_free (bin->plugins);\n\tsdb_free (bin->sdb);\n\tr_id_pool_free (bin->file_ids);\n\tmemset (bin, 0, sizeof (RBin));\n\tfree (bin);\n\treturn NULL;\n}\n\nstatic int r_bin_print_plugin_details(RBin *bin, RBinPlugin *bp, int json) {\n\tif (json == 'q') {\n\t\tbin->cb_printf (\"%s\\n\", bp->name);\n\t} else if (json) {\n\t\tbin->cb_printf (\n\t\t\t\"{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\"\\\"license\\\":\\\"%s\\\"}\\n\",\n\t\t\tbp->name, bp->desc, bp->license? bp->license: \"???\");\n\t} else {\n\t\tbin->cb_printf (\"Name: %s\\n\", bp->name);\n\t\tbin->cb_printf (\"Description: %s\\n\", bp->desc);\n\t\tif (bp->license) {\n\t\t\tbin->cb_printf (\"License: %s\\n\", bp->license);\n\t\t}\n\t\tif (bp->version) {\n\t\t\tbin->cb_printf (\"Version: %s\\n\", bp->version);\n\t\t}\n\t\tif (bp->author) {\n\t\t\tbin->cb_printf (\"Author: %s\\n\", bp->author);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int r_bin_print_xtrplugin_details(RBin *bin, RBinXtrPlugin *bx, int json) {\n\tif (json == 'q') {\n\t\tbin->cb_printf (\"%s\\n\", bx->name);\n\t} else if (json) {\n\t\tbin->cb_printf (\n\t\t\t\"{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\"\\\"license\\\":\\\"%s\\\"}\\n\",\n\t\t\tbx->name, bx->desc, bx->license? bx->license: \"???\");\n\t} else {\n\t\tbin->cb_printf (\"Name: %s\\n\", bx->name);\n\t\tbin->cb_printf (\"Description: %s\\n\", bx->desc);\n\t\tif (bx->license) {\n\t\t\tbin->cb_printf (\"License: %s\\n\", bx->license);\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_bin_list(RBin *bin, int json) {\n\tRListIter *it;\n\tRBinPlugin *bp;\n\tRBinXtrPlugin *bx;\n\n\tif (json == 'q') {\n\t\tr_list_foreach (bin->plugins, it, bp) {\n\t\t\tbin->cb_printf (\"%s\\n\", bp->name);\n\t\t}\n\t\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\t\tbin->cb_printf (\"%s\\n\", bx->name);\n\t\t}\n\t} else if (json) {\n\t\tint i;\n\n\t\ti = 0;\n\t\tbin->cb_printf (\"{\\\"bin\\\":[\");\n\t\tr_list_foreach (bin->plugins, it, bp) {\n\t\t\tbin->cb_printf (\n\t\t\t\t\"%s{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"license\\\":\\\"%s\\\"}\",\n\t\t\t\ti? \",\": \"\", bp->name, bp->desc, bp->license? bp->license: \"???\");\n\t\t\ti++;\n\t\t}\n\n\t\ti = 0;\n\t\tbin->cb_printf (\"],\\\"xtr\\\":[\");\n\t\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\t\tbin->cb_printf (\n\t\t\t\t\"%s{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"license\\\":\\\"%s\\\"}\",\n\t\t\t\ti? \",\": \"\", bx->name, bx->desc, bx->license? bx->license: \"???\");\n\t\t\ti++;\n\t\t}\n\t\tbin->cb_printf (\"]}\\n\");\n\t} else {\n\t\tr_list_foreach (bin->plugins, it, bp) {\n\t\t\tbin->cb_printf (\"bin  %-11s %s (%s) %s %s\\n\",\n\t\t\t\tbp->name, bp->desc, bp->license? bp->license: \"???\",\n\t\t\t\tbp->version? bp->version: \"\",\n\t\t\t\tbp->author? bp->author: \"\");\n\t\t}\n\t\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\t\tbin->cb_printf (\"xtr  %-11s %s (%s)\\n\", bx->name,\n\t\t\t\tbx->desc, bx->license? bx->license: \"???\");\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API int r_bin_list_plugin(RBin *bin, const char* name, int json) {\n\tRListIter *it;\n\tRBinPlugin *bp;\n\tRBinXtrPlugin *bx;\n\n\tr_list_foreach (bin->plugins, it, bp) {\n\t\tif (!r_str_cmp (name, bp->name, strlen (name))) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r_bin_print_plugin_details (bin, bp, json);\n\t}\n\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\tif (!r_str_cmp (name, bx->name, strlen (name))) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r_bin_print_xtrplugin_details (bin, bx, json);\n\t}\n\n\teprintf (\"cannot find plugin %s\\n\", name);\n\treturn false;\n}\n\nstatic ut64 binobj_get_baddr(RBinObject *o) {\n\treturn o? o->baddr + o->baddr_shift: UT64_MAX;\n}\n\nR_API ut64 r_binfile_get_baddr(RBinFile *binfile) {\n\treturn binfile? binobj_get_baddr (binfile->o): UT64_MAX;\n}\n\n/* returns the base address of bin or UT64_MAX in case of errors */\nR_API ut64 r_bin_get_baddr(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn binobj_get_baddr (o);\n}\n\n/* returns the load address of bin or UT64_MAX in case of errors */\nR_API ut64 r_bin_get_laddr(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->loadaddr: UT64_MAX;\n}\n\nR_API void r_bin_set_baddr(RBin *bin, ut64 baddr) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tbinobj_set_baddr (o, baddr);\n\t// XXX - update all the infos?\n}\n\nR_API ut64 r_bin_get_boffset(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->boffset: UT64_MAX;\n}\n\nR_API RBinAddr *r_bin_get_sym(RBin *bin, int sym) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (sym < 0 || sym >= R_BIN_SYM_LAST) {\n\t\treturn NULL;\n\t}\n\treturn o? o->binsym[sym]: NULL;\n}\n\n// XXX: those accessors are redundant\nR_API RList *r_bin_get_entries(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->entries: NULL;\n}\n\nR_API RList *r_bin_get_fields(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->fields: NULL;\n}\n\nR_API RList *r_bin_get_imports(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->imports: NULL;\n}\n\nR_API RBinInfo *r_bin_get_info(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->info: NULL;\n}\n\nR_API RList *r_bin_get_libs(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->libs: NULL;\n}\n\n\nR_API RList * r_bin_patch_relocs(RBin *bin) {\n\tstatic bool first = true;\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\t// r_bin_object_set_items set o->relocs but there we don't have access\n\t// to io\n\t// so we need to be run from bin_relocs, free the previous reloc and get\n\t// the patched ones\n\tif (first && o->plugin && o->plugin->patch_relocs) {\n\t\tRList *tmp = o->plugin->patch_relocs (bin);\n\t\tfirst = false;\n\t\tif (!tmp) {\n\t\t\treturn o->relocs;\n\t\t}\n\t\tr_list_free (o->relocs);\n\t\to->relocs = tmp;\n\t\tREBASE_PADDR (o, o->relocs, RBinReloc);\n\t\tfirst = false;\n\t\treturn o->relocs;\n\t}\n\treturn o->relocs;\n}\n\nR_API RList *r_bin_get_relocs(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->relocs: NULL;\n}\n\nR_API RList *r_bin_get_sections(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->sections: NULL;\n}\n\n// TODO: Move into section.c and rename it to r_io_section_get_at ()\nR_API RBinSection *r_bin_get_section_at(RBinObject *o, ut64 off, int va) {\n\tRBinSection *section;\n\tRListIter *iter;\n\tut64 from, to;\n\tif (o) {\n\t\t// TODO: must be O(1) .. use sdb here\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tfrom = va? binobj_a2b (o, section->vaddr): section->paddr;\n\t\t\tto = va? (binobj_a2b (o, section->vaddr) + section->vsize) :\n\t\t\t\t(section->paddr + section->size);\n\t\t\tif (off >= from && off < to) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_reset_strings(RBin *bin) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinObject *o = r_bin_cur_object (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\n\tif (!a || !o) {\n\t\treturn NULL;\n\t}\n\tif (o->strings) {\n\t\tr_list_free (o->strings);\n\t\to->strings = NULL;\n\t}\n\n\tif (bin->minstrlen <= 0) {\n\t\treturn NULL;\n\t}\n\ta->rawstr = bin->rawstr;\n\n\tif (plugin && plugin->strings) {\n\t\to->strings = plugin->strings (a);\n\t} else {\n\t\to->strings = get_strings (a, bin->minstrlen, 0);\n\t}\n\tif (bin->debase64) {\n\t\tfilterStrings (bin, o->strings);\n\t}\n\treturn o->strings;\n}\n\nR_API RList *r_bin_get_strings(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->strings: NULL;\n}\n\nR_API int r_bin_is_string(RBin *bin, ut64 va) {\n\tRBinString *string;\n\tRListIter *iter;\n\tRList *list;\n\tif (!(list = r_bin_get_strings (bin))) {\n\t\treturn false;\n\t}\n\tr_list_foreach (list, iter, string) {\n\t\tif (string->vaddr == va) {\n\t\t\treturn true;\n\t\t}\n\t\tif (string->vaddr > va) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n//callee must not free the symbol\nR_API RBinSymbol *r_bin_get_symbol_at_vaddr(RBin *bin, ut64 addr) {\n\t//use skiplist here\n\tRList *symbols = r_bin_get_symbols (bin);\n\tRListIter *iter;\n\tRBinSymbol *symbol;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (symbol->vaddr == addr) {\n\t\t\treturn symbol;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n//callee must not free the symbol\nR_API RBinSymbol *r_bin_get_symbol_at_paddr(RBin *bin, ut64 addr) {\n\t//use skiplist here\n\tRList *symbols = r_bin_get_symbols (bin);\n\tRListIter *iter;\n\tRBinSymbol *symbol;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (symbol->paddr == addr) {\n\t\t\treturn symbol;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_get_symbols(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->symbols: NULL;\n}\n\nR_API RList *r_bin_get_mem(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->mem: NULL;\n}\n\nR_API int r_bin_is_big_endian(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn (o && o->info)? o->info->big_endian: -1;\n}\n\nR_API int r_bin_is_stripped(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_STRIPPED & o->info->dbg_info): 1;\n}\n\nR_API int r_bin_is_static(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (o && r_list_length (o->libs) > 0)\n\t\treturn R_BIN_DBG_STATIC & o->info->dbg_info;\n\treturn true;\n}\n\n// TODO: Integrate with r_bin_dbg */\nR_API int r_bin_has_dbg_linenums(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_LINENUMS & o->info->dbg_info): false;\n}\n\nR_API int r_bin_has_dbg_syms(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_SYMS & o->info->dbg_info): false;\n}\n\nR_API int r_bin_has_dbg_relocs(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_RELOCS & o->info->dbg_info): false;\n}\n\nR_API RBin *r_bin_new() {\n\tint i;\n\tRBinXtrPlugin *static_xtr_plugin;\n\tRBin *bin = R_NEW0 (RBin);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->force = NULL;\n\tbin->filter_rules = UT64_MAX;\n\tbin->sdb = sdb_new0 ();\n\tbin->cb_printf = (PrintfCallback)printf;\n\tbin->plugins = r_list_newf ((RListFree)plugin_free);\n\tbin->minstrlen = 0;\n\tbin->want_dbginfo = true;\n\tbin->cur = NULL;\n\tbin->io_owned = false;\n\n\tbin->binfiles = r_list_newf ((RListFree)r_bin_file_free);\n\tfor (i = 0; bin_static_plugins[i]; i++) {\n\t\tr_bin_add (bin, bin_static_plugins[i]);\n\t}\n\tbin->binxtrs = r_list_new ();\n\tbin->binxtrs->free = free;\n\tfor (i = 0; bin_xtr_static_plugins[i]; i++) {\n\t\tstatic_xtr_plugin = R_NEW0 (RBinXtrPlugin);\n\t\tif (!static_xtr_plugin) {\n\t\t\tfree (bin);\n\t\t\treturn NULL;\n\t\t}\n\t\t*static_xtr_plugin = *bin_xtr_static_plugins[i];\n\t\tr_bin_xtr_add (bin, static_xtr_plugin);\n\t}\n\tbin->file_ids = r_id_pool_new (0, 0xffffffff);\n\treturn bin;\n}\n\nR_API int r_bin_use_arch(RBin *bin, const char *arch, int bits,\n\t\t\t  const char *name) {\n\tRBinFile *binfile = r_bin_file_find_by_arch_bits (bin, arch, bits, name);\n\tRBinObject *obj = NULL;\n\tif (binfile) {\n\t\tobj = r_bin_object_find_by_arch_bits (binfile, arch, bits, name);\n\t\tif (!obj) {\n\t\t\tif (binfile->xtr_data) {\n\t\t\t\tRBinXtrData *xtr_data = r_list_get_n (binfile->xtr_data, 0);\n\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (bin, binfile,\n\t\t\t\t\t\tUT64_MAX, r_bin_get_laddr (bin), xtr_data)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobj = r_list_get_n (binfile->objs, 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvoid *plugin = r_bin_get_binplugin_by_name (bin, name);\n\t\tif (plugin) {\n\t\t\tif (bin->cur) {\n\t\t\t\tbin->cur->curplugin = plugin;\n\t\t\t}\n\t\t\tbinfile = r_bin_file_new (bin, \"-\", NULL, 0, 0, 0, 999, NULL, NULL, false);\n\t\t\t// create object and set arch/bits\n\t\t\tobj = r_bin_object_new (binfile, plugin, 0, 0, 0, 1024);\n\t\t\tbinfile->o = obj;\n\t\t\tobj->info = R_NEW0 (RBinInfo);\n\t\t\tobj->info->arch = strdup (arch);\n\t\t\tobj->info->bits = bits;\n\t\t}\n\t}\n\treturn (binfile && r_bin_file_set_cur_binfile_obj (bin, binfile, obj));\n}\n\nR_API RBinObject *r_bin_object_find_by_arch_bits(RBinFile *binfile,\n\t\t\t\t\t\t  const char *arch, int bits,\n\t\t\t\t\t\t  const char *name) {\n\tRBinObject *obj = NULL;\n\tRListIter *iter = NULL;\n\tRBinInfo *info = NULL;\n\tr_list_foreach (binfile->objs, iter, obj) {\n\t\tinfo = obj->info;\n\t\tif (info && info->arch && info->file &&\n\t\t   (bits == info->bits) &&\n\t\t\t!strcmp (info->arch, arch) &&\n\t\t\t!strcmp (info->file, name)) {\n\t\t\tbreak;\n\t\t}\n\t\tobj = NULL;\n\t}\n\treturn obj;\n}\n\nR_API RBinFile *r_bin_file_find_by_arch_bits(RBin *bin, const char *arch,\n\t\t\t\t\t      int bits, const char *name) {\n\tRListIter *iter;\n\tRBinFile *binfile = NULL;\n\tRBinXtrData *xtr_data;\n\n\tif (!name || !arch) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tRListIter *iter_xtr;\n\t\tif (!binfile->xtr_data) {\n\t\t\tcontinue;\n\t\t}\n\t\t// look for sub-bins in Xtr Data and Load if we need to\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (xtr_data->metadata && xtr_data->metadata->arch) {\n\t\t\t\tchar *iter_arch = xtr_data->metadata->arch;\n\t\t\t\tint iter_bits = xtr_data->metadata->bits;\n\t\t\t\tif (bits == iter_bits && !strcmp (iter_arch, arch)) {\n\t\t\t\t\tif (!xtr_data->loaded) {\n\t\t\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (\n\t\t\t\t\t\t\t    bin, binfile, xtr_data->baddr,\n\t\t\t\t\t\t\t    xtr_data->laddr, xtr_data)) {\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn binfile;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn binfile;\n}\n\nR_API int r_bin_select(RBin *bin, const char *arch, int bits,\n\t\t\tconst char *name) {\n\tRBinFile *cur = r_bin_cur (bin), *binfile = NULL;\n\tRBinObject *obj = NULL;\n\tname = !name && cur? cur->file: name;\n\tbinfile = r_bin_file_find_by_arch_bits (bin, arch, bits, name);\n\tif (binfile && name) {\n\t\tobj = r_bin_object_find_by_arch_bits (binfile, arch, bits, name);\n\t}\n\treturn binfile && r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n}\n\nR_API int r_bin_select_object(RBinFile *binfile, const char *arch, int bits,\n\t\t\t       const char *name) {\n\tRBinObject *obj = binfile ? r_bin_object_find_by_arch_bits (\n\t\t\t\t\t    binfile, arch, bits, name) :\n\t\t\t\t    NULL;\n\treturn obj &&\n\t       r_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, obj);\n}\n\nstatic RBinObject *r_bin_file_object_find_by_id(RBinFile *binfile,\n\t\t\t\t\t\t ut32 binobj_id) {\n\tRBinObject *obj;\n\tRListIter *iter;\n\tif (binfile)  {\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tif (obj->id == binobj_id) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic RBinFile *r_bin_file_find_by_object_id(RBin *bin, ut32 binobj_id) {\n\tRListIter *iter;\n\tRBinFile *binfile;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (r_bin_file_object_find_by_id (binfile, binobj_id)) {\n\t\t\treturn binfile;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 binfile_id) {\n\tRBinFile *binfile = NULL;\n\tRListIter *iter = NULL;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (binfile->id == binfile_id) {\n\t\t\tbreak;\n\t\t}\n\t\tbinfile = NULL;\n\t}\n\treturn binfile;\n}\n\nR_API int r_bin_object_delete(RBin *bin, ut32 binfile_id, ut32 binobj_id) {\n\tRBinFile *binfile = NULL; //, *cbinfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tint res = false;\n\n#if 0\n\tif (binfile_id == UT32_MAX && binobj_id == UT32_MAX) {\n\t\treturn false;\n\t}\n#endif\n\tif (binfile_id == -1) {\n\t\tbinfile = r_bin_file_find_by_object_id (bin, binobj_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t} else if (binobj_id == -1) {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? binfile->o: NULL;\n\t} else {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t}\n\n\t// lazy way out, always leaving at least 1 bin object loaded\n\tif (binfile && (r_list_length (binfile->objs) > 1)) {\n\t\tbinfile->o = NULL;\n\t\tr_list_delete_data (binfile->objs, obj);\n\t\tobj = (RBinObject *)r_list_get_n (binfile->objs, 0);\n\t\tres = obj && binfile &&\n\t\t      r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n\t}\n\treturn res;\n}\n\nR_API int r_bin_select_by_ids(RBin *bin, ut32 binfile_id, ut32 binobj_id) {\n\tRBinFile *binfile = NULL;\n\tRBinObject *obj = NULL;\n\n\tif (binfile_id == UT32_MAX && binobj_id == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (binfile_id == -1) {\n\t\tbinfile = r_bin_file_find_by_object_id (bin, binobj_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t} else if (binobj_id == -1) {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? binfile->o: NULL;\n\t} else {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t}\n\tif (!binfile || !obj) {\n\t\treturn false;\n\t}\n\treturn obj && binfile && r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n}\n\nR_API int r_bin_select_idx(RBin *bin, const char *name, int idx) {\n\tRBinFile *nbinfile = NULL, *binfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tconst char *tname = !name && binfile? binfile->file: name;\n\tint res = false;\n\tif (!tname || !bin) {\n\t\treturn res;\n\t}\n\tnbinfile = r_bin_file_find_by_name_n (bin, tname, idx);\n\tobj = nbinfile? r_list_get_n (nbinfile->objs, idx): NULL;\n\treturn obj && nbinfile &&\n\t       r_bin_file_set_cur_binfile_obj (bin, nbinfile, obj);\n}\n\nstatic void list_xtr_archs(RBin *bin, int mode) {\n\tRBinFile *binfile = r_bin_cur (bin);\n\tif (binfile->xtr_data) {\n\t\tRListIter *iter_xtr;\n\t\tRBinXtrData *xtr_data;\n\t\tint bits, i = 0;\n\t\tchar *arch, *machine;\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (!xtr_data || !xtr_data->metadata ||\n\t\t\t    !xtr_data->metadata->arch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarch = xtr_data->metadata->arch;\n\t\t\tmachine = xtr_data->metadata->machine;\n\t\t\tbits = xtr_data->metadata->bits;\n\t\t\tswitch (mode) {\n\t\t\tcase 'q':\n\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tbin->cb_printf (\n\t\t\t\t\t\"%s{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d\n\t\t\t\t\t\",\\\"size\\\":\\\"%\" PFMT64d\n\t\t\t\t\t\",\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\ti++ ? \",\" : \"\", arch, bits,\n\t\t\t\t\txtr_data->offset, xtr_data->size,\n\t\t\t\t\tmachine);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x\n\t\t\t\t\t\t\" %\" PFMT64d \" %s_%i %s\\n\",\n\t\t\t\t\t\ti++, xtr_data->offset,\n\t\t\t\t\t\txtr_data->size, arch, bits,\n\t\t\t\t\t\tmachine);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_list_archs(RBin *bin, int mode) {\n\tRListIter *iter;\n\tint i = 0;\n\tchar unk[128];\n\tchar archline[128];\n\tRBinFile *binfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tconst char *name = binfile? binfile->file: NULL;\n\tint narch = binfile? binfile->narch: 0;\n\n\t//are we with xtr format?\n\tif (binfile && binfile->curxtr) {\n\t\tlist_xtr_archs (bin, mode);\n\t\treturn;\n\t}\n\tSdb *binfile_sdb = binfile? binfile->sdb: NULL;\n\tif (!binfile_sdb) {\n\t\teprintf (\"Cannot find SDB!\\n\");\n\t\treturn;\n\t} else if (!binfile) {\n\t\teprintf (\"Binary format not currently loaded!\\n\");\n\t\treturn;\n\t}\n\tsdb_unset (binfile_sdb, ARCHS_KEY, 0);\n\tif (mode == 'j') {\n\t\tbin->cb_printf (\"\\\"bins\\\":[\");\n\t}\n\tRBinFile *nbinfile = r_bin_file_find_by_name_n (bin, name, i);\n\tif (!nbinfile) {\n\t\treturn;\n\t}\n\ti = -1;\n\tr_list_foreach (nbinfile->objs, iter, obj) {\n\t\tRBinInfo *info = obj->info;\n\t\tchar bits = info? info->bits: 0;\n\t\tut64 boffset = obj->boffset;\n\t\tut32 obj_size = obj->obj_size;\n\t\tconst char *arch = info? info->arch: NULL;\n\t\tconst char *machine = info? info->machine: \"unknown_machine\";\n\n\t\ti++;\n\t\tif (!arch) {\n\t\t\tsnprintf (unk, sizeof (unk), \"unk_%d\", i);\n\t\t\tarch = unk;\n\t\t}\n\n\t\tif (info && narch > 1) {\n\t\t\tswitch (mode) {\n\t\t\tcase 'q':\n\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tbin->cb_printf (\"%s{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d \",\\\"size\\\":%d,\"\n\t\t\t\t\t\t\"\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\ti? \",\": \"\", arch, bits,\n\t\t\t\t\t\tboffset, obj_size, machine);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x \" %d %s_%i %s\\n\", i,\n\t\t\t\t\t\tboffset, obj_size, arch, bits, machine);\n\t\t\t}\n\t\t\tsnprintf (archline, sizeof (archline) - 1,\n\t\t\t\t\"0x%08\" PFMT64x \":%d:%s:%d:%s\",\n\t\t\t\tboffset, obj_size, arch, bits, machine);\n\t\t\t/// xxx machine not exported?\n\t\t\t//sdb_array_push (binfile_sdb, ARCHS_KEY, archline, 0);\n\t\t} else {\n\t\t\tif (info) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'q':\n\t\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tbin->cb_printf (\"%s{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d \",\\\"size\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\ti? \",\": \"\", arch, bits,\n\t\t\t\t\t\t\tboffset, obj_size, machine);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x \" %d %s_%d\\n\", i,\n\t\t\t\t\t\t\tboffset, obj_size, arch, bits);\n\t\t\t\t}\n\t\t\t\tsnprintf (archline, sizeof (archline),\n\t\t\t\t\t\"0x%08\" PFMT64x \":%d:%s:%d\",\n\t\t\t\t\tboffset, obj_size, arch, bits);\n\t\t\t} else if (nbinfile && mode) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'q':\n\t\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tbin->cb_printf (\"%s{\\\"arch\\\":\\\"unk_%d\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d \",\\\"size\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\ti? \",\": \"\", i, bits,\n\t\t\t\t\t\t\tboffset, obj_size, machine);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x \" %d unk_0\\n\", i,\n\t\t\t\t\t\t\tboffset, obj_size);\n\t\t\t\t}\n\t\t\t\tsnprintf (archline, sizeof (archline),\n\t\t\t\t\t\"0x%08\" PFMT64x \":%d:%s:%d\",\n\t\t\t\t\tboffset, obj_size, \"unk\", 0);\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Invalid RBinFile.\\n\");\n\t\t\t}\n\t\t\t//sdb_array_push (binfile_sdb, ARCHS_KEY, archline, 0);\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tbin->cb_printf (\"]\");\n\t}\n}\n\nR_API void r_bin_set_user_ptr(RBin *bin, void *user) {\n\tbin->user = user;\n}\n\nstatic RBinSection* _get_vsection_at(RBin *bin, ut64 vaddr) {\n\tRBinObject *cur = r_bin_object_get_cur (bin);\n\treturn r_bin_get_section_at (cur, vaddr, true);\n}\nR_API void r_bin_bind(RBin *bin, RBinBind *b) {\n\tif (b) {\n\t\tb->bin = bin;\n\t\tb->get_offset = getoffset;\n\t\tb->get_name = getname;\n\t\tb->get_sections = r_bin_get_sections;\n\t\tb->get_vsect_at = _get_vsection_at;\n\t}\n}\n\nR_API RBuffer *r_bin_create(RBin *bin, const ut8 *code, int codelen,\n\t\t\t     const ut8 *data, int datalen) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\tif (codelen < 0) {\n\t\tcodelen = 0;\n\t}\n\tif (datalen < 0) {\n\t\tdatalen = 0;\n\t}\n\tif (plugin && plugin->create) {\n\t\treturn plugin->create (bin, code, codelen, data, datalen);\n\t}\n\treturn NULL;\n}\n\nR_API RBuffer *r_bin_package(RBin *bin, const char *type, const char *file, RList *files) {\n\tif (!strcmp (type, \"zip\")) {\n#if 0\n\t\tint zep = 0;\n\t\tstruct zip * z = zip_open (file, 8 | 1, &zep);\n\t\tif (z) {\n\t\t\tRListIter *iter;\n\t\t\tconst char *f;\n\t\t\teprintf (\"zip file created\\n\");\n\t\t\tr_list_foreach (files, iter, f) {\n\t\t\t\tstruct zip_source *zs = NULL;\n\t\t\t\tzs = zip_source_file (z, f, 0, 1024);\n\t\t\t\tif (zs) {\n\t\t\t\t\teprintf (\"ADD %s\\n\", f);\n\t\t\t\t\tzip_add (z, f, zs);\n\t\t\t\t\tzip_source_free (zs);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot find file %s\\n\", f);\n\t\t\t\t}\n\t\t\t\teprintf (\"zS %p\\n\", zs);\n\t\t\t}\n\t\t\tzip_close (z);\n\t\t} else {\n\t\t\teprintf (\"Cannot create zip file\\n\");\n\t\t}\n#endif\n\t} else if (!strcmp (type, \"fat\")) {\n\t\tconst char *f;\n\t\tRListIter *iter;\n\t\tut32 num;\n\t\tut8 *num8 = (ut8*)&num;\n\t\tRBuffer *buf = r_buf_new_file (file, true);\n\t\tr_buf_write_at (buf, 0, (const ut8*)\"\\xca\\xfe\\xba\\xbe\", 4);\n\t\tint count = r_list_length (files);\n\n\t\tnum = r_read_be32 (&count);\n\t\tut64 from = 0x1000;\n\t\tr_buf_write_at (buf, 4, num8, 4);\n\t\tint off = 12;\n\t\tint item = 0;\n\t\tr_list_foreach (files, iter, f) {\n\t\t\tint f_len = 0;\n\t\t\tut8 *f_buf = (ut8 *)r_file_slurp (f, &f_len);\n\t\t\tif (f_buf && f_len >= 0) {\n\t\t\t\teprintf (\"ADD %s %d\\n\", f, f_len);\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot open %s\\n\", f);\n\t\t\t\tfree (f_buf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titem++;\n\t\t\t/* CPU */\n\t\t\tnum8[0] = f_buf[7];\n\t\t\tnum8[1] = f_buf[6];\n\t\t\tnum8[2] = f_buf[5];\n\t\t\tnum8[3] = f_buf[4];\n\t\t\tr_buf_write_at (buf, off - 4, num8, 4);\n\t\t\t/* SUBTYPE */\n\t\t\tnum8[0] = f_buf[11];\n\t\t\tnum8[1] = f_buf[10];\n\t\t\tnum8[2] = f_buf[9];\n\t\t\tnum8[3] = f_buf[8];\n\t\t\tr_buf_write_at (buf, off, num8, 4);\n\t\t\tut32 from32 = from;\n\t\t\t/* FROM */\n\t\t\tnum = r_read_be32 (&from32);\n\t\t\tr_buf_write_at (buf, off + 4, num8, 4);\n\t\t\tr_buf_write_at (buf, from, f_buf, f_len);\n\t\t\t/* SIZE */\n\t\t\tnum = r_read_be32 (&f_len);\n\t\t\tr_buf_write_at (buf, off + 8, num8, 4);\n\t\t\toff += 20;\n\t\t\tfrom += f_len + (f_len % 0x1000);\n\t\t\tfree (f_buf);\n\t\t}\n\t\tr_buf_free (buf);\n\t\treturn NULL;\n\t} else {\n\t\teprintf (\"Usage: rabin2 -X [fat|zip] [filename] [files ...]\\n\");\n\t}\n\treturn NULL;\n}\n\nR_API RBinObject *r_bin_get_object(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (o) {\n\t\to->referenced++;\n\t}\n\treturn o;\n}\n\nR_API RList * /*<RBinClass>*/ r_bin_get_classes(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->classes: NULL;\n}\n\nR_API void r_bin_class_free(RBinClass *c) {\n\tfree (c->name);\n\tfree (c->super);\n\tr_list_free (c->methods);\n\tr_list_free (c->fields);\n\tfree (c);\n}\n\nR_API RBinClass *r_bin_class_new(RBinFile *binfile, const char *name,\n\t\t\t\t  const char *super, int view) {\n\tRBinObject *o = binfile? binfile->o: NULL;\n\tRList *list = NULL;\n\tRBinClass *c;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tlist = o->classes;\n\tif (!name) {\n\t\treturn NULL;\n\t}\n\tc = r_bin_class_get (binfile, name);\n\tif (c) {\n\t\tif (super) {\n\t\t\tfree (c->super);\n\t\t\tc->super = strdup (super);\n\t\t}\n\t\treturn c;\n\t}\n\tc = R_NEW0 (RBinClass);\n\tif (!c) {\n\t\treturn NULL;\n\t}\n\tc->name = strdup (name);\n\tc->super = super? strdup (super): NULL;\n\tc->index = r_list_length (list);\n\tc->methods = r_list_new ();\n\tc->fields = r_list_new ();\n\tc->visibility = view;\n\tif (!list) {\n\t\tlist = o->classes = r_list_new ();\n\t}\n\tr_list_append (list, c);\n\treturn c;\n}\n\nR_API RBinClass *r_bin_class_get(RBinFile *binfile, const char *name) {\n\tif (!binfile || !binfile->o || !name) {\n\t\treturn NULL;\n\t}\n\tRBinClass *c;\n\tRListIter *iter;\n\tRList *list = binfile->o->classes;\n\tr_list_foreach (list, iter, c) {\n\t\tif (!strcmp (c->name, name)) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinSymbol *r_bin_class_add_method(RBinFile *binfile, const char *classname, const char *name, int nargs) {\n\tRBinClass *c = r_bin_class_get (binfile, classname);\n\tif (!c) {\n\t\tc = r_bin_class_new (binfile, classname, NULL, 0);\n\t\tif (!c) {\n\t\t\teprintf (\"Cannot allocate class %s\\n\", classname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tRBinSymbol *m;\n\tRListIter *iter;\n\tr_list_foreach (c->methods, iter, m) {\n\t\tif (!strcmp (m->name, name)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn NULL;\n\t}\n\tsym->name = strdup (name);\n\tr_list_append (c->methods, sym);\n\treturn sym;\n}\n\nR_API void r_bin_class_add_field(RBinFile *binfile, const char *classname, const char *name) {\n\t//TODO: add_field into class\n\t//eprintf (\"TODO add field: %s \\n\", name);\n}\n\n/* returns vaddr, rebased with the baseaddr of binfile, if va is enabled for\n * bin, paddr otherwise */\nR_API ut64 r_binfile_get_vaddr(RBinFile *binfile, ut64 paddr, ut64 vaddr) {\n\tint use_va = 0;\n\tif (binfile && binfile->o && binfile->o->info) {\n\t\tuse_va = binfile->o->info->has_va;\n\t}\n\treturn use_va? binobj_a2b (binfile->o, vaddr): paddr;\n}\n\n/* returns vaddr, rebased with the baseaddr of bin, if va is enabled for bin,\n * paddr otherwise */\nR_API ut64 r_bin_get_vaddr(RBin *bin, ut64 paddr, ut64 vaddr) {\n\tif (!bin || !bin->cur) {\n\t\treturn UT64_MAX;\n\t}\n\tif (paddr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\t/* hack to realign thumb symbols */\n\tif (bin->cur->o && bin->cur->o->info && bin->cur->o->info->arch) {\n\t\tif (bin->cur->o->info->bits == 16) {\n\t\t\tRBinSection *s = r_bin_get_section_at (bin->cur->o, paddr, false);\n\t\t\t// autodetect thumb\n\t\t\tif (s && s->srwx & 1 && strstr (s->name, \"text\")) {\n\t\t\t\tif (!strcmp (bin->cur->o->info->arch, \"arm\") && (vaddr & 1)) {\n\t\t\t\t\tvaddr = (vaddr >> 1) << 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn r_binfile_get_vaddr (bin->cur, paddr, vaddr);\n}\n\nR_API ut64 r_bin_a2b(RBin *bin, ut64 addr) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->baddr_shift + addr: addr;\n}\n\nR_API ut64 r_bin_get_size(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o ? o->size : 0;\n}\n\nR_API int r_bin_file_delete_all(RBin *bin) {\n\tint counter = 0;\n\tif (bin) {\n\t\tcounter = r_list_length (bin->binfiles);\n\t\tr_list_purge (bin->binfiles);\n\t\tbin->cur = NULL;\n\t}\n\treturn counter;\n}\n\nR_API int r_bin_file_delete(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tRBinFile *cur = r_bin_cur (bin);\n\tif (bin && cur) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\tif (cur->fd == bin_fd) {\n\t\t\t\t\t//avoiding UaF due to dead reference \n\t\t\t\t\tbin->cur = NULL;\n\t\t\t\t}\n\t\t\t\tr_list_delete (bin->binfiles, iter);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API RBinFile *r_bin_file_find_by_fd(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tif (bin) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\treturn bf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_name(RBin *bin, const char *name) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tif (!bin || !name) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tbreak;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_name_n(RBin *bin, const char *name, int idx) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tint i = 0;\n\tif (!bin) {\n\t\treturn bf;\n\t}\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tif (i == idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API int r_bin_file_set_cur_by_fd(RBin *bin, ut32 bin_fd) {\n\tRBinFile *bf = r_bin_file_find_by_fd (bin, bin_fd);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API int r_bin_file_set_cur_binfile_obj(RBin *bin, RBinFile *bf, RBinObject *obj) {\n\tRBinPlugin *plugin = NULL;\n\tif (!bin || !bf || !obj) {\n\t\treturn false;\n\t}\n\tbin->file = bf->file;\n\tbin->cur = bf;\n\tbin->narch = bf->narch;\n\tbf->o = obj;\n\tplugin = r_bin_file_cur_plugin (bf);\n\tif (bin->minstrlen < 1) {\n\t\tbin->minstrlen = plugin? plugin->minstrlen: bin->minstrlen;\n\t}\n\treturn true;\n}\n\nR_API int r_bin_file_set_cur_binfile(RBin *bin, RBinFile *bf) {\n\tRBinObject *obj = bf? bf->o: NULL;\n\treturn obj? r_bin_file_set_cur_binfile_obj (bin, bf, obj): false;\n}\n\nR_API int r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API RBinFile *r_bin_cur(RBin *bin) {\n\treturn bin? bin->cur: NULL;\n}\n\nR_API RBinObject *r_bin_cur_object(RBin *bin) {\n\tRBinFile *binfile = r_bin_cur (bin);\n\treturn binfile? binfile->o: NULL;\n}\n\nR_API void r_bin_force_plugin(RBin *bin, const char *name) {\n\tfree (bin->force);\n\tbin->force = (name && *name)? strdup (name): NULL;\n}\n\nR_API int r_bin_read_at(RBin *bin, ut64 addr, ut8 *buf, int size) {\n\tRIOBind *iob;\n\tif (!bin || !(iob = &(bin->iob))) {\n\t\treturn false;\n\t}\n\treturn iob->read_at (iob->io, addr, buf, size);\n}\n\nR_API int r_bin_write_at(RBin *bin, ut64 addr, const ut8 *buf, int size) {\n\tRIOBind *iob;\n\tif (!bin || !(iob = &(bin->iob))) {\n\t\treturn false;\n\t}\n\treturn iob->write_at (iob->io, addr, buf, size);\n}\n\nR_API const char *r_bin_entry_type_string(int etype) {\n\tswitch (etype) {\n\tcase R_BIN_ENTRY_TYPE_PROGRAM:\n\t\treturn \"program\";\n\tcase R_BIN_ENTRY_TYPE_MAIN:\n\t\treturn \"main\";\n\tcase R_BIN_ENTRY_TYPE_INIT:\n\t\treturn \"init\";\n\tcase R_BIN_ENTRY_TYPE_FINI:\n\t\treturn \"fini\";\n\tcase R_BIN_ENTRY_TYPE_TLS:\n\t\treturn \"tls\";\n\t}\n\treturn NULL;\n}\n\nR_API void r_bin_load_filter(RBin *bin, ut64 rules) {\n\tbin->filter_rules = rules;\n}\n\n/* RBinField */\nR_API RBinField *r_bin_field_new(ut64 paddr, ut64 vaddr, int size, const char *name, const char *comment, const char *format) {\n\tRBinField *ptr;\n\tif (!(ptr = R_NEW0 (RBinField))) {\n\t\treturn NULL;\n\t}\n\tptr->name = strdup (name);\n\tptr->comment = (comment && *comment)? strdup (comment): NULL;\n\tptr->format = (format && *format)? strdup (format): NULL;\n\tptr->paddr = paddr;\n\tptr->size = size;\n//\tptr->visibility = ???\n\tptr->vaddr = vaddr;\n\treturn ptr;\n}\n\n// use void* to honor the RListFree signature\nR_API void r_bin_field_free(void *_field) {\n\tRBinField *field = (RBinField*) _field;\n\tfree (field->name);\n\tfree (field->comment);\n\tfree (field->format);\n\tfree (field);\n}\n\nR_API const char *r_bin_get_meth_flag_string(ut64 flag, bool compact) {\n\tswitch (flag) {\n\tcase R_BIN_METH_CLASS:\n\t\treturn compact ? \"c\" : \"class\";\n\tcase R_BIN_METH_STATIC:\n\t\treturn compact ? \"s\" : \"static\";\n\tcase R_BIN_METH_PUBLIC:\n\t\treturn compact ? \"p\" : \"public\";\n\tcase R_BIN_METH_PRIVATE:\n\t\treturn compact ? \"P\" : \"private\";\n\tcase R_BIN_METH_PROTECTED:\n\t\treturn compact ? \"r\" : \"protected\";\n\tcase R_BIN_METH_INTERNAL:\n\t\treturn compact ? \"i\" : \"internal\";\n\tcase R_BIN_METH_OPEN:\n\t\treturn compact ? \"o\" : \"open\";\n\tcase R_BIN_METH_FILEPRIVATE:\n\t\treturn compact ? \"e\" : \"fileprivate\";\n\tcase R_BIN_METH_FINAL:\n\t\treturn compact ? \"f\" : \"final\";\n\tcase R_BIN_METH_VIRTUAL:\n\t\treturn compact ? \"v\" : \"virtual\";\n\tcase R_BIN_METH_CONST:\n\t\treturn compact ? \"k\" : \"const\";\n\tcase R_BIN_METH_MUTATING:\n\t\treturn compact ? \"m\" : \"mutating\";\n\tcase R_BIN_METH_ABSTRACT:\n\t\treturn compact ? \"a\" : \"abstract\";\n\tcase R_BIN_METH_SYNCHRONIZED:\n\t\treturn compact ? \"y\" : \"synchronized\";\n\tcase R_BIN_METH_NATIVE:\n\t\treturn compact ? \"n\" : \"native\";\n\tcase R_BIN_METH_BRIDGE:\n\t\treturn compact ? \"b\" : \"bridge\";\n\tcase R_BIN_METH_VARARGS:\n\t\treturn compact ? \"g\" : \"varargs\";\n\tcase R_BIN_METH_SYNTHETIC:\n\t\treturn compact ? \"h\" : \"synthetic\";\n\tcase R_BIN_METH_STRICT:\n\t\treturn compact ? \"t\" : \"strict\";\n\tcase R_BIN_METH_MIRANDA:\n\t\treturn compact ? \"A\" : \"miranda\";\n\tcase R_BIN_METH_CONSTRUCTOR:\n\t\treturn compact ? \"C\" : \"constructor\";\n\tcase R_BIN_METH_DECLARED_SYNCHRONIZED:\n\t\treturn compact ? \"Y\" : \"declared_synchronized\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2017 - pancake, nibble, dso */\n\n// TODO: dlopen library and show address\n\n#include <r_bin.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_io.h>\n#include <config.h>\n\nR_LIB_VERSION (r_bin);\n\n#define bprintf if(binfile->rbin->verbose)eprintf\n#define DB a->sdb;\n#define RBINLISTFREE(x)\\\n\tif (x) { \\\n\t\tr_list_free (x);\\\n\t\tx = NULL;\\\n\t}\n#define REBASE_PADDR(o, l, type_t)\\\n\tdo { \\\n\t\tRListIter *_it;\\\n\t\ttype_t *_el;\\\n\t\tr_list_foreach ((l), _it, _el) { \\\n\t\t\t_el->paddr += (o)->loadaddr;\\\n\t\t}\\\n\t} while (0)\n\n#define ARCHS_KEY \"archs\"\n\n#if !defined(R_BIN_STATIC_PLUGINS)\n#define R_BIN_STATIC_PLUGINS 0\n#endif\n#if !defined(R_BIN_XTR_STATIC_PLUGINS)\n#define R_BIN_XTR_STATIC_PLUGINS 0\n#endif\n\nstatic RBinPlugin *bin_static_plugins[] = { R_BIN_STATIC_PLUGINS, NULL };\nstatic RBinXtrPlugin *bin_xtr_static_plugins[] = { R_BIN_XTR_STATIC_PLUGINS, NULL };\n\nstatic int is_data_section(RBinFile *a, RBinSection *s);\nstatic RList *get_strings(RBinFile *a, int min, int dump);\nstatic void r_bin_object_delete_items(RBinObject *o);\nstatic void r_bin_object_free(void /*RBinObject*/ *o_);\n// static int r_bin_object_set_items(RBinFile *binfile, RBinObject *o);\nstatic int r_bin_file_set_bytes(RBinFile *binfile, const ut8 *bytes, ut64 sz, bool steal_ptr);\n//static int remove_bin_file_by_binfile (RBin *bin, RBinFile * binfile);\n//static void r_bin_free_bin_files (RBin *bin);\nstatic void r_bin_file_free(void /*RBinFile*/ *bf_);\nstatic RBinFile *r_bin_file_create_append(RBin *bin, const char *file,\n\t\t\t\t\t   const ut8 *bytes, ut64 sz,\n\t\t\t\t\t   ut64 file_sz, int rawstr, int fd,\n\t\t\t\t\t   const char *xtrname, bool steal_ptr);\n\nstatic RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr,\n\t\t\t\t\t    const char *filename,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, ut64 baseaddr,\n\t\t\t\t\t    ut64 loadaddr, int idx, int fd,\n\t\t\t\t\t    int rawstr);\n\nint r_bin_load_io_at_offset_as_sz(RBin *bin, int fd, ut64 baseaddr,\n\t\t\t\t   ut64 loadaddr, int xtr_idx, ut64 offset,\n\t\t\t\t   const char *name, ut64 sz);\n\nstatic RBinPlugin *r_bin_get_binplugin_by_name(RBin *bin, const char *name);\nstatic RBinXtrPlugin *r_bin_get_xtrplugin_by_name(RBin *bin, const char *name);\nstatic RBinPlugin *r_bin_get_binplugin_any(RBin *bin);\n\nstatic RBinObject *r_bin_object_new(RBinFile *binfile, RBinPlugin *plugin,\n\t\t\t\t     ut64 baseaddr, ut64 loadaddr, ut64 offset,\n\t\t\t\t     ut64 sz);\n\nstatic RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes,\n\t\t\t\t ut64 sz, ut64 file_sz, int rawstr, int fd,\n\t\t\t\t const char *xtrname, Sdb *sdb, bool steal_ptr);\n\nstatic RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, int rawstr,\n\t\t\t\t\t    ut64 baseaddr, ut64 loadaddr,\n\t\t\t\t\t    int fd, const char *pluginname,\n\t\t\t\t\t    const char *xtrname, ut64 offset,\n\t\t\t\t\t    bool steal_ptr);\n\nstatic int getoffset(RBin *bin, int type, int idx) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\tif (plugin && plugin->get_offset) {\n\t\treturn plugin->get_offset (a, type, idx);\n\t}\n\treturn -1;\n}\n\nstatic const char *getname(RBin *bin, int type, int idx) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\tif (plugin && plugin->get_name) {\n\t\treturn plugin->get_name (a, type, idx);\n\t}\n\treturn NULL;\n}\nstatic int r_bin_file_object_add(RBinFile *binfile, RBinObject *o) {\n\tif (!o) {\n\t\treturn false;\n\t}\n\tr_list_append (binfile->objs, o);\n\tr_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, o);\n\treturn true;\n}\n\nstatic void binobj_set_baddr(RBinObject *o, ut64 baddr) {\n\tif (!o || baddr == UT64_MAX) {\n\t\treturn;\n\t}\n\to->baddr_shift = baddr - o->baddr;\n}\n\nstatic ut64 binobj_a2b(RBinObject *o, ut64 addr) {\n\treturn addr + (o? o->baddr_shift: 0);\n}\n\nstatic void filterStrings (RBin *bin, RList *strings) {\n\tRBinString *ptr;\n\tRListIter *iter;\n\tr_list_foreach (strings, iter, ptr) {\n\t\tchar *dec = (char *)r_base64_decode_dyn (ptr->string, -1);\n\t\tif (dec) {\n\t\t\tchar *s = ptr->string;\n\t\t\tdo {\n\t\t\t\tchar *dec2 = (char *)r_base64_decode_dyn (s, -1);\n\t\t\t\tif (!dec2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!r_str_is_printable (dec2)) {\n\t\t\t\t\tfree (dec2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree (dec);\n\t\t\t\ts = dec = dec2;\n\t\t\t} while (true);\n\t\t\tif (r_str_is_printable (dec) && strlen (dec) > 3) {\n\t\t\t\tfree (ptr->string);\n\t\t\t\tptr->string = dec;\n\t\t\t\tptr->type = R_STRING_TYPE_BASE64;\n\t\t\t} else {\n\t\t\t\tfree (dec);\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_iobind(RBin *bin, RIO *io) {\n\tr_io_bind (io, &bin->iob);\n}\n\n// TODO: move these two function do a different file\nR_API RBinXtrData *r_bin_xtrdata_new(RBuffer *buf, ut64 offset, ut64 size,\n\t\t\t\t      ut32 file_count,\n\t\t\t\t      RBinXtrMetadata *metadata) {\n\tRBinXtrData *data = R_NEW0 (RBinXtrData);\n\tif (!data) {\n\t\treturn NULL;\n\t}\n\tdata->offset = offset;\n\tdata->size = size;\n\tdata->file_count = file_count;\n\tdata->metadata = metadata;\n\tdata->loaded = 0;\n\tdata->buffer = malloc (size + 1);\n\t// data->laddr = 0; /// XXX\n\tif (!data->buffer) {\n\t\tfree (data);\n\t\treturn NULL;\n\t}\n\tmemcpy (data->buffer, r_buf_buffer (buf), size);\n\tdata->buffer[size] = 0;\n\treturn data;\n}\n\nR_API const char *r_bin_string_type (int type) {\n\tswitch (type) {\n\tcase 'a': return \"ascii\";\n\tcase 'u': return \"utf8\";\n\tcase 'w': return \"utf16le\";\n\tcase 'W': return \"utf32le\";\n\tcase 'b': return \"base64\";\n\t}\n\treturn \"ascii\"; // XXX\n}\n\nR_API void r_bin_xtrdata_free(void /*RBinXtrData*/ *data_) {\n\tRBinXtrData *data = data_;\n\tif (data) {\n\t\tif (data->metadata) {\n\t\t\tfree (data->metadata->libname);\n\t\t\tfree (data->metadata->arch);\n\t\t\tfree (data->metadata->machine);\n\t\t\tfree (data->metadata);\n\t\t}\n\t\tfree (data->file);\n\t\tfree (data->buffer);\n\t\tfree (data);\n\t}\n}\n\nR_API RBinObject *r_bin_file_object_get_cur(RBinFile *binfile) {\n\treturn binfile? binfile->o: NULL;\n}\n\nR_API RBinObject *r_bin_object_get_cur(RBin *bin) {\n\treturn bin\n\t\t? r_bin_file_object_get_cur (r_bin_cur (bin))\n\t\t: NULL;\n}\n\nR_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *binfile) {\n\treturn binfile && binfile->o? binfile->o->plugin: NULL;\n}\n\nR_API int r_bin_file_cur_set_plugin(RBinFile *binfile, RBinPlugin *plugin) {\n\tif (binfile && binfile->o) {\n\t\tbinfile->o->plugin = plugin;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// maybe too big sometimes? 2KB of stack eaten here..\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n\nstatic int string_scan_range(RList *list, const ut8 *buf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type) {\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (!buf || !min) {\n\t\treturn -1;\n\t}\n\twhile (needle < to) {\n\t\trc = r_utf8_decode (buf + needle, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc;\n\t\t\tif ((to - needle) > 4) {\n\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\tif (is_wide32) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\n\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r)) {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (&tmp[i], r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\e\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 28) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes >= min) {\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\t// reduce false positives\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (list) {\n\t\t\t\tRBinString *new = R_NEW0 (RBinString);\n\t\t\t\tif (!new) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->type = str_type;\n\t\t\t\tnew->length = runes;\n\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t// TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\tif (str_start > 1) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\tif (str_start > 3) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->paddr = new->vaddr = str_start;\n\t\t\t\tnew->string = r_str_ndup ((const char *)tmp, i);\n\t\t\t\tr_list_append (list, new);\n\t\t\t} else {\n\t\t\t\t// DUMP TO STDOUT. raw dumping for rabin2 -zzz\n\t\t\t\tprintf (\"0x%08\" PFMT64x \" %s\\n\", str_start, tmp);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic void get_strings_range(RBinFile *arch, RList *list, int min, ut64 from, ut64 to) {\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (arch);\n\tRBinString *ptr;\n\tRListIter *it;\n\n\tif (!arch || !arch->buf || !arch->buf->buf) {\n\t\treturn;\n\t}\n\tif (!arch->rawstr) {\n\t\tif (!plugin || !plugin->info) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\t/* Some plugins return zero, fix it up */\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!to || to > arch->buf->length) {\n\t\tto = arch->buf->length;\n\t}\n\tif (arch->rawstr != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (arch->rbin->maxstrbuf && size && size > arch->rbin->maxstrbuf) {\n\t\t\tif (arch->rbin->verbose) {\n\t\t\t\teprintf (\"WARNING: bin_strings buffer is too big \"\n\t\t\t\t\t\"(0x%08\" PFMT64x\n\t\t\t\t\t\").\"\n\t\t\t\t\t\" Use -zzz or set bin.maxstrbuf \"\n\t\t\t\t\t\"(RABIN2_MAXSTRBUF) in r2 (rabin2)\\n\",\n\t\t\t\t\tsize);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (string_scan_range (list, arch->buf->buf, min, from, to, -1) < 0) {\n\t\treturn;\n\t}\n\tr_list_foreach (list, it, ptr) {\n\t\tRBinSection *s = r_bin_get_section_at (arch->o, ptr->paddr, false);\n\t\tif (s) {\n\t\t\tptr->vaddr = s->vaddr + (ptr->paddr - s->paddr);\n\t\t}\n\t}\n}\n\nstatic int is_data_section(RBinFile *a, RBinSection *s) {\n\tif (s->has_strings || s->is_data) {\n\t\treturn true;\n\t}\n\tif (s->is_data) {\n\t\treturn true;\n\t}\n \t// Rust\n\treturn (strstr (s->name, \"_const\") != NULL);\n}\n\nstatic RList *get_strings(RBinFile *a, int min, int dump) {\n\tRListIter *iter;\n\tRBinSection *section;\n\tRBinObject *o = a? a->o: NULL;\n\tRList *ret;\n\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tif (dump) {\n\t\t/* dump to stdout, not stored in list */\n\t\tret = NULL;\n\t} else {\n\t\tret = r_list_newf (r_bin_string_free);\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (o->sections && !r_list_empty (o->sections) && !a->rawstr) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (is_data_section (a, section)) {\n\t\t\t\tget_strings_range (a, ret, min, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tRBinString *s;\n\t\t\tRListIter *iter2;\n\t\t\t/* load objc/swift strings */\n\t\t\tconst int bits = (a->o && a->o->info) ? a->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\tif (!r_buf_read_at (\n\t\t\t\t\t\t    a->buf, section->paddr + i + cfstr_offs,\n\t\t\t\t\t\t    buf, sizeof (buf))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = buf;\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64)\n\t\t\t\t\t\t\t\t   ? r_read_le64 (p)\n\t\t\t\t\t\t\t\t   : r_read_le32 (p);\n\t\t\t\t\tr_list_foreach (ret, iter2, s) {\n\t\t\t\t\t\tif (s->vaddr == cstr_vaddr) {\n\t\t\t\t\t\t\tRBinString *new = R_NEW0 (RBinString);\n\t\t\t\t\t\t\tnew->type = s->type;\n\t\t\t\t\t\t\tnew->length = s->length;\n\t\t\t\t\t\t\tnew->size = s->size;\n\t\t\t\t\t\t\tnew->ordinal = s->ordinal;\n\t\t\t\t\t\t\tnew->paddr = new->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\tnew->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\tr_list_append (ret, new);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tget_strings_range (a, ret, min, 0, a->size);\n\t}\n\treturn ret;\n}\n\nR_API RList* r_bin_raw_strings(RBinFile *a, int min) {\n\tRList *l = NULL;\n\tif (a) {\n\t\tint tmp = a->rawstr;\n\t\ta->rawstr = 2;\n\t\tl = get_strings (a, min, 0);\n\t\ta->rawstr = tmp;\n\t}\n\treturn l;\n}\n\nR_API int r_bin_dump_strings(RBinFile *a, int min) {\n\tget_strings (a, min, 1);\n\treturn 0;\n}\n\n/* This is very slow if there are lot of symbols */\nR_API int r_bin_load_languages(RBinFile *binfile) {\n\tif (r_bin_lang_rust (binfile)) {\n\t\treturn R_BIN_NM_RUST;\n\t}\n\tif (r_bin_lang_swift (binfile)) {\n\t\treturn R_BIN_NM_SWIFT;\n\t}\n\tif (r_bin_lang_objc (binfile)) {\n\t\treturn R_BIN_NM_OBJC;\n\t}\n\tif (r_bin_lang_cxx (binfile)) {\n\t\treturn R_BIN_NM_CXX;\n\t}\n\tif (r_bin_lang_dlang (binfile)) {\n\t\treturn R_BIN_NM_DLANG;\n\t}\n\tif (r_bin_lang_msvc (binfile)) {\n\t\treturn R_BIN_NM_MSVC;\n\t}\n\treturn R_BIN_NM_NONE;\n}\n\nstatic void mem_free(void *data) {\n\tRBinMem *mem = (RBinMem *)data;\n\tif (mem && mem->mirrors) {\n\t\tmem->mirrors->free = mem_free;\n\t\tr_list_free (mem->mirrors);\n\t\tmem->mirrors = NULL;\n\t}\n\tfree (mem);\n}\n\nstatic void r_bin_object_delete_items(RBinObject *o) {\n\tut32 i = 0;\n\tif (!o) {\n\t\treturn;\n\t}\n\tr_list_free (o->entries);\n\tr_list_free (o->fields);\n\tr_list_free (o->imports);\n\tr_list_free (o->libs);\n\tr_list_free (o->relocs);\n\tr_list_free (o->sections);\n\tr_list_free (o->strings);\n\tr_list_free (o->symbols);\n\tr_list_free (o->classes);\n\tr_list_free (o->lines);\n\tsdb_free (o->kv);\n\tif (o->mem) {\n\t\to->mem->free = mem_free;\n\t}\n\tr_list_free (o->mem);\n\to->mem = NULL;\n\to->entries = NULL;\n\to->fields = NULL;\n\to->imports = NULL;\n\to->libs = NULL;\n\to->relocs = NULL;\n\to->sections = NULL;\n\to->strings = NULL;\n\to->symbols = NULL;\n\to->classes = NULL;\n\to->lines = NULL;\n\to->info = NULL;\n\to->kv = NULL;\n\tfor (i = 0; i < R_BIN_SYM_LAST; i++) {\n\t\tfree (o->binsym[i]);\n\t\to->binsym[i] = NULL;\n\t}\n}\n\nR_API void r_bin_info_free(RBinInfo *rb) {\n\tif (!rb) {\n\t\treturn;\n\t}\n\tfree (rb->intrp);\n\tfree (rb->file);\n\tfree (rb->type);\n\tfree (rb->bclass);\n\tfree (rb->rclass);\n\tfree (rb->arch);\n\tfree (rb->cpu);\n\tfree (rb->machine);\n\tfree (rb->os);\n\tfree (rb->subsystem);\n\tfree (rb->rpath);\n\tfree (rb->guid);\n\tfree (rb->debug_file_name);\n\tfree (rb);\n}\n\nR_API void r_bin_import_free(void *_imp) {\n\tRBinImport *imp = (RBinImport *)_imp;\n\tif (imp) {\n\t\tR_FREE (imp->name);\n\t\tR_FREE (imp->classname);\n\t\tR_FREE (imp->descriptor);\n\t\tfree (imp);\n\t}\n}\n\nR_API void r_bin_symbol_free(void *_sym) {\n\tRBinSymbol *sym = (RBinSymbol *)_sym;\n\tfree (sym->name);\n\tfree (sym->classname);\n\tfree (sym);\n}\n\nR_API void r_bin_string_free(void *_str) {\n\tRBinString *str = (RBinString *)_str;\n\tfree (str->string);\n\tfree (str);\n}\n\nstatic void r_bin_object_free(void /*RBinObject*/ *o_) {\n\tRBinObject *o = o_;\n\tif (!o) {\n\t\treturn;\n\t}\n\tr_bin_info_free (o->info);\n\tr_bin_object_delete_items (o);\n\tR_FREE (o);\n}\n\nstatic char *swiftField(const char *dn, const char *cn) {\n\tchar *p = strstr (dn, \".getter_\");\n\tif (!p) {\n\t\tp = strstr (dn, \".setter_\");\n\t\tif (!p) {\n\t\t\tp = strstr (dn, \".method_\");\n\t\t}\n\t}\n\tif (p) {\n\t\tchar *q = strstr (dn, cn);\n\t\tif (q && q[strlen (cn)] == '.') {\n\t\t\tq = strdup (q + strlen (cn) + 1);\n\t\t\tchar *r = strchr (q, '.');\n\t\t\tif (r) {\n\t\t\t\t*r = 0;\n\t\t\t}\n\t\t\treturn q;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_classes_from_symbols (RBinFile *bf, RBinObject *o) {\n\tRBinSymbol *sym;\n\tRListIter *iter;\n\tRList *symbols = o->symbols;\n\tRList *classes = o->classes;\n\tif (!classes) {\n\t\tclasses = r_list_newf ((RListFree)r_bin_class_free);\n\t}\n\tr_list_foreach (symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRBinClass *c = r_bin_class_new (bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// swift specific\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField (dn, cn);\n\t\t\tif (fn) {\n\t\t\t\t// eprintf (\"FIELD %s  %s\\n\", cn, fn);\n\t\t\t\tRBinField *f = r_bin_field_new (sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL);\n\t\t\t\tr_list_append (c->fields, f);\n\t\t\t\tfree (fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr (dn, \"..\");\n\t\t\t\tif (mn) {\n\t\t\t\t\t// eprintf (\"META %s  %s\\n\", sym->classname, mn);\n\t\t\t\t} else {\n\t\t\t\t\tchar *mn = strstr (dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\tmn += strlen (cn) + 1;\n\t\t\t\t\t\t// eprintf (\"METHOD %s  %s\\n\", sym->classname, mn);\n\t\t\t\t\t\tr_list_append (c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (r_list_empty (classes)) {\n\t\tr_list_free (classes);\n\t\treturn NULL;\n\t}\n\treturn classes;\n}\n\n// XXX - change this to RBinObject instead of RBinFile\n// makes no sense to pass in a binfile and set the RBinObject\n// kinda a clunky functions\nR_API int r_bin_object_set_items(RBinFile *binfile, RBinObject *o) {\n\tRBinObject *old_o;\n\tRBinPlugin *cp;\n\tint i, minlen;\n\tRBin *bin;\n\tif (!binfile || !o || !o->plugin) {\n\t\treturn false;\n\t}\n\tbin = binfile->rbin;\n\told_o = binfile->o;\n\tcp = o->plugin;\n\tif (binfile->rbin->minstrlen > 0) {\n\t\tminlen = binfile->rbin->minstrlen;\n\t} else {\n\t\tminlen = cp->minstrlen;\n\t}\n\tbinfile->o = o;\n\tif (cp->baddr) {\n\t\tut64 old_baddr = o->baddr;\n\t\to->baddr = cp->baddr (binfile);\n\t\tbinobj_set_baddr (o, old_baddr);\n\t}\n\tif (cp->boffset) {\n\t\to->boffset = cp->boffset (binfile);\n\t}\n\t// XXX: no way to get info from xtr pluginz?\n\t// Note, object size can not be set from here due to potential\n\t// inconsistencies\n\tif (cp->size) {\n\t\to->size = cp->size (binfile);\n\t}\n\tif (cp->binsym) {\n\t\tfor (i = 0; i < R_BIN_SYM_LAST; i++) {\n\t\t\to->binsym[i] = cp->binsym (binfile, i);\n\t\t\tif (o->binsym[i]) {\n\t\t\t\to->binsym[i]->paddr += o->loadaddr;\n\t\t\t}\n\t\t}\n\t}\n\tif (cp->entries) {\n\t\to->entries = cp->entries (binfile);\n\t\tREBASE_PADDR (o, o->entries, RBinAddr);\n\t}\n\tif (cp->fields) {\n\t\to->fields = cp->fields (binfile);\n\t\tif (o->fields) {\n\t\t\to->fields->free = r_bin_field_free;\n\t\t\tREBASE_PADDR (o, o->fields, RBinField);\n\t\t}\n\t}\n\tif (cp->imports) {\n\t\tr_list_free (o->imports);\n\t\to->imports = cp->imports (binfile);\n\t\tif (o->imports) {\n\t\t\to->imports->free = r_bin_import_free;\n\t\t}\n\t}\n\t//if (bin->filter_rules & (R_BIN_REQ_SYMBOLS | R_BIN_REQ_IMPORTS)) {\n\tif (true) {\n\t\tif (cp->symbols) {\n\t\t\to->symbols = cp->symbols (binfile);\n\t\t\tif (o->symbols) {\n\t\t\t\to->symbols->free = r_bin_symbol_free;\n\t\t\t\tREBASE_PADDR (o, o->symbols, RBinSymbol);\n\t\t\t\tif (bin->filter) {\n\t\t\t\t\tr_bin_filter_symbols (o->symbols);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//}\n\to->info = cp->info? cp->info (binfile): NULL;\n\tif (cp->libs) {\n\t\to->libs = cp->libs (binfile);\n\t}\n\tif (cp->sections) {\n\t\t// XXX sections are populated by call to size\n\t\tif (!o->sections) {\n\t\t\to->sections = cp->sections (binfile);\n\t\t}\n\t\tREBASE_PADDR (o, o->sections, RBinSection);\n\t\tif (bin->filter) {\n\t\t\tr_bin_filter_sections (o->sections);\n\t\t}\n\t}\n\tif (bin->filter_rules & (R_BIN_REQ_RELOCS | R_BIN_REQ_IMPORTS)) {\n\t\tif (cp->relocs) {\n\t\t\to->relocs = cp->relocs (binfile);\n\t\t\tREBASE_PADDR (o, o->relocs, RBinReloc);\n\t\t}\n\t}\n\tif (bin->filter_rules & R_BIN_REQ_STRINGS) {\n\t\tif (cp->strings) {\n\t\t\to->strings = cp->strings (binfile);\n\t\t} else {\n\t\t\to->strings = get_strings (binfile, minlen, 0);\n\t\t}\n\t\tif (bin->debase64) {\n\t\t\tfilterStrings (bin, o->strings);\n\t\t}\n\t\tREBASE_PADDR (o, o->strings, RBinString);\n\t}\n\tif (bin->filter_rules & R_BIN_REQ_CLASSES) {\n\t\tif (cp->classes) {\n\t\t\to->classes = cp->classes (binfile);\n\t\t\tif (r_bin_lang_swift (binfile)) {\n\t\t\t\to->classes = r_bin_classes_from_symbols (binfile, o);\n\t\t\t}\n\t\t} else {\n\t\t\to->classes = r_bin_classes_from_symbols (binfile, o);\n\t\t}\n\t\tif (bin->filter) {\n\t\t\tr_bin_filter_classes (o->classes);\n\t\t}\n\t}\n\tif (cp->lines) {\n\t\to->lines = cp->lines (binfile);\n\t}\n\tif (cp->get_sdb) {\n\t\tSdb* new_kv = cp->get_sdb (binfile);\n\t\tif (new_kv != o->kv) {\n\t\t\tsdb_free (o->kv);\n\t\t}\n\t\to->kv = new_kv;\n\t}\n\tif (cp->mem)  {\n\t\to->mem = cp->mem (binfile);\n\t}\n\tif (bin->filter_rules & (R_BIN_REQ_SYMBOLS | R_BIN_REQ_IMPORTS)) {\n\t\to->lang = r_bin_load_languages (binfile);\n\t}\n\tbinfile->o = old_o;\n\treturn true;\n}\n\n// XXX - this is a rather hacky way to do things, there may need to be a better\n// way.\nR_API int r_bin_load(RBin *bin, const char *file, ut64 baseaddr, ut64 loadaddr, int xtr_idx, int fd, int rawstr) {\n\tif (!bin) {\n\t\treturn false;\n\t}\n\t// ALIAS?\treturn r_bin_load_as (bin, file, baseaddr, loadaddr,\n\t// xtr_idx, fd, rawstr, 0, file);\n\tRIOBind *iob = &(bin->iob);\n\tif (!iob) {\n\t\treturn false;\n\t}\n\tif (!iob->io) {\n\t\tiob->io = r_io_new ();\t//wtf\n\t\tif (!iob->io) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->io_owned = true;\n\t\tr_io_bind (iob->io, &bin->iob);\t\t//memleak?\n\t\tiob = &bin->iob;\n\t}\n\tif (!iob->desc_get (iob->io, fd)) {\n\t\tfd = iob->fd_open (iob->io, file, R_IO_READ, 0644);\n\t}\n\tbin->rawstr = rawstr;\n\t// Use the current RIODesc otherwise r_io_map_select can swap them later on\n\tif (fd < 0) {\n\t\tr_io_free (iob->io);\n\t\tmemset (&bin->iob, 0, sizeof (bin->iob));\n\t\tbin->io_owned = false;\n\t\treturn false;\n\t}\n\t//Use the current RIODesc otherwise r_io_map_select can swap them later on\n\treturn r_bin_load_io (bin, fd, baseaddr, loadaddr, xtr_idx);\n}\n\nR_API int r_bin_load_as(RBin *bin, const char *file, ut64 baseaddr,\n\t\t\t ut64 loadaddr, int xtr_idx, int fd, int rawstr,\n\t\t\t int fileoffset, const char *name) {\n\tRIOBind *iob = &(bin->iob);\n\tif (!iob || !iob->io) {\n\t\treturn false;\n\t}\n\tif (fd < 0) {\n\t\tfd = iob->fd_open (iob->io, file, R_IO_READ, 0644);\n\t}\n\tif (fd < 0) {\n\t\treturn false;\n\t}\n\treturn r_bin_load_io_at_offset_as (bin, fd, baseaddr, loadaddr,\n\t\t\t\t\t\t  xtr_idx, fileoffset, name);\n}\n\nR_API int r_bin_reload(RBin *bin, int fd, ut64 baseaddr) {\n\tRIOBind *iob = &(bin->iob);\n\tRList *the_obj_list = NULL;\n\tint res = false;\n\tRBinFile *bf = NULL;\n\tut8 *buf_bytes = NULL;\n\tut64 sz = UT64_MAX;\n\n\tif (!iob || !iob->io) {\n\t\tres = false;\n\t\tgoto error;\n\t}\n\tconst char *name = iob->fd_get_name (iob->io, fd);\n\tbf = r_bin_file_find_by_name (bin, name);\n\tif (!bf) {\n\t\tres = false;\n\t\tgoto error;\n\t}\n\n\tthe_obj_list = bf->objs;\n\n\tbf->objs = r_list_newf ((RListFree)r_bin_object_free);\n\t// invalidate current object reference\n\tbf->o = NULL;\n\n\tsz = iob->fd_size (iob->io, fd);\n\tif (sz == UT64_MAX || sz > (64 * 1024 * 1024)) { \n\t\t// too big, probably wrong\n\t\teprintf (\"Too big\\n\");\n\t\tres = false;\n\t\tgoto error;\n\t}\n\tif (sz == UT64_MAX && iob->fd_is_dbg (iob->io, fd)) {\n\t\t// attempt a local open and read\n\t\t// This happens when a plugin like debugger does not have a\n\t\t// fixed size.\n\t\t// if there is no fixed size or its MAXED, there is no way to\n\t\t// definitively\n\t\t// load the bin-properly.  Many of the plugins require all\n\t\t// content and are not\n\t\t// stream based loaders\n\t\tint tfd = iob->fd_open (iob->io, name, R_IO_READ, 0);\n\t\tif (tfd < 0) {\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tsz = iob->fd_size (iob->io, tfd);\n\t\tif (sz == UT64_MAX) {\n\t\t\tiob->fd_close (iob->io, tfd);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\tiob->fd_close (iob->io, tfd);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!iob->read_at (iob->io, 0LL, buf_bytes, sz)) {\n\t\t\tfree (buf_bytes);\n\t\t\tiob->fd_close (iob->io, tfd);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tiob->fd_close (iob->io, tfd);\n\t} else {\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!iob->fd_read_at (iob->io, fd, 0LL, buf_bytes, sz)) {\n\t\t\tfree (buf_bytes);\n\t\t\tres = false;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tbool yes_plz_steal_ptr = true;\n\tr_bin_file_set_bytes (bf, buf_bytes, sz, yes_plz_steal_ptr);\n\n\tif (r_list_length (the_obj_list) == 1) {\n\t\tRBinObject *old_o = (RBinObject *)r_list_get_n (the_obj_list, 0);\n\t\tres = r_bin_load_io_at_offset_as (bin, fd, baseaddr,\n\t\t\t\t\t\told_o->loadaddr, 0, old_o->boffset, NULL);\n\t} else {\n\t\tRListIter *iter = NULL;\n\t\tRBinObject *old_o;\n\t\tr_list_foreach (the_obj_list, iter, old_o) {\n\t\t\t// XXX - naive. do we need a way to prevent multiple \"anys\" from being opened?\n\t\t\tres = r_bin_load_io_at_offset_as (bin, fd, baseaddr,\n\t\t\t\told_o->loadaddr, 0, old_o->boffset, old_o->plugin->name);\n\t\t}\n\t}\n\tbf->o = r_list_get_n (bf->objs, 0);\n\nerror:\n\tr_list_free (the_obj_list);\n\n\treturn res;\n}\n\nR_API int r_bin_load_io(RBin *bin, int fd, ut64 baseaddr, ut64 loadaddr, int xtr_idx) {\n\treturn r_bin_load_io_at_offset_as (bin, fd, baseaddr, loadaddr, xtr_idx, 0, NULL);\n}\n\nR_API int r_bin_load_io_at_offset_as_sz(RBin *bin, int fd, ut64 baseaddr,\n\t\tut64 loadaddr, int xtr_idx, ut64 offset, const char *name, ut64 sz) {\n\tRIOBind *iob = &(bin->iob);\n\tRIO *io = iob? iob->io: NULL;\n\tRListIter *it;\n\tut8 *buf_bytes = NULL;\n\tRBinXtrPlugin *xtr;\n\tut64 file_sz = UT64_MAX;\n\tRBinFile *binfile = NULL;\n\tint tfd = -1;\n\n\tif (!io || (fd < 0) || (st64)sz < 0) {\n\t\treturn false;\n\t}\n\tbool is_debugger = iob->fd_is_dbg (io, fd);\n\tconst char *fname = iob->fd_get_name (io, fd);\n\tif (loadaddr == UT64_MAX) {\n\t\tloadaddr = 0;\n\t}\n\tfile_sz = iob->fd_size (io, fd);\n\t// file_sz = UT64_MAX happens when attaching to frida:// and other non-debugger io plugins which results in double opening\n\tif (is_debugger && file_sz == UT64_MAX) {\n\t\ttfd = iob->fd_open (io, fname, R_IO_READ, 0644);\n\t\tif (tfd >= 1) {\n\t\t\tfile_sz = iob->fd_size (io, tfd);\n\t\t}\n\t}\n\tif (!sz) {\n\t\tsz = file_sz;\n\t}\n\n\tbin->file = fname;\n\tsz = R_MIN (file_sz, sz);\n\tif (!r_list_length (bin->binfiles)) {\n\t\tif (is_debugger) {\n\t\t\t//use the temporal RIODesc to read the content of the file instead\n\t\t\t//from the memory\n\t\t\tif (tfd >= 0) {\n\t\t\t\tbuf_bytes = calloc (1, sz + 1);\n\t\t\t\tiob->fd_read_at (io, tfd, 0, buf_bytes, sz);\n\t\t\t\t// iob->fd_close (io, tfd);\n\t\t\t}\n\t\t}\n\t}\n\tif (!buf_bytes) {\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\treturn false;\n\t\t}\n\t\tut64 seekaddr = is_debugger? baseaddr: loadaddr;\n\t\tif (!iob->fd_read_at (io, fd, seekaddr, buf_bytes, sz)) {\n\t\t\tsz = 0LL;\n\t\t}\n\t}\n\n\tif (!name && (st64)sz > 0) {\n\t\t// XXX - for the time being this is fine, but we may want to\n\t\t// change the name to something like\n\t\t// <xtr_name>:<bin_type_name>\n\t\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\t\tif (xtr && xtr->check_bytes (buf_bytes, sz)) {\n\t\t\t\tif (xtr && (xtr->extract_from_bytes || xtr->extractall_from_bytes)) {\n\t\t\t\t\tif (is_debugger && sz != file_sz) {\n\t\t\t\t\t\tR_FREE (buf_bytes);\n\t\t\t\t\t\tif (tfd < 0) {\n\t\t\t\t\t\t\ttfd = iob->fd_open (io, fname, R_IO_READ, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsz = iob->fd_size (io, tfd);\n\t\t\t\t\t\tif (sz != UT64_MAX) {\n\t\t\t\t\t\t\tbuf_bytes = calloc (1, sz + 1);\n\t\t\t\t\t\t\tif (buf_bytes) {\n\t\t\t\t\t\t\t\t(void) iob->fd_read_at (io, tfd, 0, buf_bytes, sz);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t//DOUBLECLOSE UAF : iob->fd_close (io, tfd);\n\t\t\t\t\t\ttfd = -1;\t// marking it closed\n\t\t\t\t\t} else if (sz != file_sz) {\n\t\t\t\t\t\t(void) iob->read_at (io, 0LL, buf_bytes, sz);\n\t\t\t\t\t}\n\t\t\t\t\tbinfile = r_bin_file_xtr_load_bytes (bin, xtr,\n\t\t\t\t\t\tfname, buf_bytes, sz, file_sz,\n\t\t\t\t\t\tbaseaddr, loadaddr, xtr_idx,\n\t\t\t\t\t\tfd, bin->rawstr);\n\t\t\t\t}\n\t\t\t\txtr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!binfile) {\n\t\tbool steal_ptr = true; // transfer buf_bytes ownership to binfile\n\t\tbinfile = r_bin_file_new_from_bytes (\n\t\t\tbin, fname, buf_bytes, sz, file_sz, bin->rawstr,\n\t\t\tbaseaddr, loadaddr, fd, name, NULL, offset, steal_ptr);\n\t}\n\treturn binfile? r_bin_file_set_cur_binfile (bin, binfile): false;\n}\n\nR_API bool r_bin_load_io_at_offset_as(RBin *bin, int fd, ut64 baseaddr,\n\t\tut64 loadaddr, int xtr_idx, ut64 offset, const char *name) {\n\t// adding file_sz to help reduce the performance impact on the system\n\t// in this case the number of bytes read will be limited to 2MB\n\t// (MIN_LOAD_SIZE)\n\t// if it fails, the whole file is loaded.\n\tconst ut64 MAX_LOAD_SIZE = 0;  // 0xfffff; //128 * (1 << 10 << 10);\n\tint res = r_bin_load_io_at_offset_as_sz (bin, fd, baseaddr,\n\t\tloadaddr, xtr_idx, offset, name, MAX_LOAD_SIZE);\n\tif (!res) {\n\t\tres = r_bin_load_io_at_offset_as_sz (bin, fd, baseaddr,\n\t\t\tloadaddr, xtr_idx, offset, name, UT64_MAX);\n\t}\n\treturn res;\n}\n\nR_API int r_bin_file_deref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_deref (bin, a);\n}\n\nR_API int r_bin_file_deref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tint res = false;\n\tif (a && !o) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t} else if (a && o->referenced - 1 < 1) {\n\t\t//r_list_delete_data (bin->binfiles, a);\n\t\tres = true;\n\t\t// not thread safe\n\t} else if (o) {\n\t\to->referenced--;\n\t}\n\t// it is possible for a file not\n\t// to be bound to RBin and RBinFiles\n\t// XXX - is this an ok assumption?\n\tif (bin) bin->cur = NULL;\n\treturn res;\n}\n\nR_API int r_bin_file_ref_by_bind(RBinBind *binb) {\n\tRBin *bin = binb? binb->bin: NULL;\n\tRBinFile *a = r_bin_cur (bin);\n\treturn r_bin_file_ref (bin, a);\n}\n\nR_API int r_bin_file_ref(RBin *bin, RBinFile *a) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (a && o) {\n\t\to->referenced--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void r_bin_file_free(void /*RBinFile*/ *bf_) {\n\tRBinFile *a = bf_;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\n\tif (!a) {\n\t\treturn;\n\t}\n\n\t// Binary format objects are connected to the\n\t// RBinObject, so the plugin must destroy the\n\t// format data first\n\tif (plugin && plugin->destroy) {\n\t\tplugin->destroy (a);\n\t}\n\tif (a->curxtr && a->curxtr->destroy && a->xtr_obj) {\n\t\ta->curxtr->free_xtr ((void *)(a->xtr_obj));\n\t}\n\tr_buf_free (a->buf);\n\t// TODO: unset related sdb namespaces\n\tif (a && a->sdb_addrinfo) {\n\t\tsdb_free (a->sdb_addrinfo);\n\t\ta->sdb_addrinfo = NULL;\n\t}\n\tfree (a->file);\n\ta->o = NULL;\n\tr_list_free (a->objs);\n\tr_list_free (a->xtr_data);\n\tr_id_pool_kick_id (a->rbin->file_ids, a->id);\n\tmemset (a, 0, sizeof (RBinFile));\n\tfree (a);\n}\n\nstatic RBinFile *r_bin_file_create_append(RBin *bin, const char *file,\n\t\t\t\t\t   const ut8 *bytes, ut64 sz,\n\t\t\t\t\t   ut64 file_sz, int rawstr, int fd,\n\t\t\t\t\t   const char *xtrname, bool steal_ptr) {\n\tRBinFile *bf = r_bin_file_new (bin, file, bytes, sz, file_sz, rawstr,\n\t\t\t\t       fd, xtrname, bin->sdb, steal_ptr);\n\tif (bf) {\n\t\tr_list_append (bin->binfiles, bf);\n\t}\n\treturn bf;\n}\n\n// This function populate RBinFile->xtr_data, that information is enough to\n// create RBinObject when needed using r_bin_file_object_new_from_xtr_data\nstatic RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr,\n\t\t\t\t\t    const char *filename,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, ut64 baseaddr,\n\t\t\t\t\t    ut64 loadaddr, int idx, int fd,\n\t\t\t\t\t    int rawstr) {\n\tif (!bin || !bytes) {\n\t\treturn NULL;\n\t}\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_create_append (bin, filename, bytes, sz,\n\t\t\t\t\t       file_sz, rawstr, fd, xtr->name, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tif (bf->xtr_data) {\n\t\tr_list_free (bf->xtr_data);\n\t}\n\tif (xtr && bytes) {\n\t\tRList *xtr_data_list = xtr->extractall_from_bytes (bin, bytes, sz);\n\t\tRListIter *iter;\n\t\tRBinXtrData *xtr;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (xtr_data_list, iter, xtr) {\n\t\t\txtr->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\txtr->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t\tbf->loadaddr = loadaddr;\n\t\tbf->xtr_data = xtr_data_list ? xtr_data_list : NULL;\n\t}\n\treturn bf;\n}\n\nstatic RBinPlugin *r_bin_get_binplugin_by_name(RBin *bin, const char *name) {\n\tRBinPlugin *plugin;\n\tRListIter *it;\n\tif (bin && name) {\n\t\tr_list_foreach (bin->plugins, it, plugin) {\n\t\t\tif (!strcmp (plugin->name, name)) {\n\t\t\t\treturn plugin;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinPlugin *r_bin_get_binplugin_by_bytes(RBin *bin, const ut8 *bytes, ut64 sz) {\n\tRBinPlugin *plugin;\n\tRListIter *it;\n\tif (!bin || !bytes) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->plugins, it, plugin) {\n\t\tif (plugin->check_bytes && plugin->check_bytes (bytes, sz)) {\n\t\t\treturn plugin;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic RBinXtrPlugin *r_bin_get_xtrplugin_by_name(RBin *bin, const char *name) {\n\tRBinXtrPlugin *xtr;\n\tRListIter *it;\n\tif (!bin || !name) return NULL;\n\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\tif (!strcmp (xtr->name, name)) {\n\t\t\treturn xtr;\n\t\t}\n\t\t// must be set to null\n\t\txtr = NULL;\n\t}\n\treturn NULL;\n}\n\nstatic RBinPlugin *r_bin_get_binplugin_any(RBin *bin) {\n\treturn r_bin_get_binplugin_by_name (bin, \"any\");\n}\n\nstatic RBinObject *r_bin_object_new(RBinFile *binfile, RBinPlugin *plugin,\n\t\t\t\t     ut64 baseaddr, ut64 loadaddr, ut64 offset,\n\t\t\t\t     ut64 sz) {\n\tconst ut8 *bytes = binfile? r_buf_buffer (binfile->buf): NULL;\n\tut64 bytes_sz = binfile? r_buf_size (binfile->buf): 0;\n\tSdb *sdb = binfile? binfile->sdb: NULL;\n\tRBinObject *o = R_NEW0 (RBinObject);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\to->obj_size = bytes && (bytes_sz >= sz + offset)? sz: 0;\n\to->boffset = offset;\n\to->id = r_num_rand (0xfffff000);\n\to->kv = sdb_new0 ();\n\to->baddr = baseaddr;\n\to->baddr_shift = 0;\n\to->plugin = plugin;\n\to->loadaddr = loadaddr != UT64_MAX ? loadaddr : 0;\n\n\t// XXX more checking will be needed here\n\t// only use LoadBytes if buffer offset != 0\n\t// if (offset != 0 && bytes && plugin && plugin->load_bytes && (bytes_sz\n\t// >= sz + offset) ) {\n\tif (bytes && plugin && plugin->load_bytes && (bytes_sz >= sz + offset)) {\n\t\tut64 bsz = bytes_sz - offset;\n\t\tif (sz < bsz) {\n\t\t\tbsz = sz;\n\t\t}\n\t\to->bin_obj = plugin->load_bytes (binfile, bytes + offset, sz,\n\t\t\t\t\t\t loadaddr, sdb);\n\t\tif (!o->bin_obj) {\n\t\t\tbprintf (\n\t\t\t\t\"Error in r_bin_object_new: load_bytes failed \"\n\t\t\t\t\"for %s plugin\\n\",\n\t\t\t\tplugin->name);\n\t\t\tsdb_free (o->kv);\n\t\t\tfree (o);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (binfile && plugin && plugin->load) {\n\t\t// XXX - haha, this is a hack.\n\t\t// switching out the current object for the new\n\t\t// one to be processed\n\t\tRBinObject *old_o = binfile->o;\n\t\tbinfile->o = o;\n\t\tif (plugin->load (binfile)) {\n\t\t\tbinfile->sdb_info = o->kv;\n\t\t\t// mark as do not walk\n\t\t\tsdb_ns_set (binfile->sdb, \"info\", o->kv);\n\t\t} else {\n\t\t\tbinfile->o = old_o;\n\t\t}\n\t\to->obj_size = sz;\n\t} else {\n\t\tsdb_free (o->kv);\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\n\t// XXX - binfile could be null here meaning an improper load\n\t// XXX - object size cant be set here and needs to be set where\n\t// where the object is created from.  The reason for this is to prevent\n\t// mis-reporting when the file is loaded from impartial bytes or is\n\t// extracted\n\t// from a set of bytes in the file\n\tr_bin_object_set_items (binfile, o);\n\tr_bin_file_object_add (binfile, o);\n\n\t// XXX this is a very hacky alternative to rewriting the\n\t// RIO stuff, as discussed here:\n\treturn o;\n}\n\n#define LIMIT_SIZE 0\nstatic int r_bin_file_set_bytes(RBinFile *binfile, const ut8 *bytes, ut64 sz, bool steal_ptr) {\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tr_buf_free (binfile->buf);\n\tbinfile->buf = r_buf_new ();\n#if LIMIT_SIZE\n\tif (sz > 1024 * 1024) {\n\t\teprintf (\"Too big\\n\");\n\t\t// TODO: use r_buf_io instead of setbytes all the time to save memory\n\t\treturn NULL;\n\t}\n#else\n\tif (steal_ptr) {\n\t\tr_buf_set_bytes_steal (binfile->buf, bytes, sz);\n\t} else {\n\t\tr_buf_set_bytes (binfile->buf, bytes, sz);\n\t}\n#endif\n\treturn binfile->buf != NULL;\n}\n\nstatic RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes,\n\t\t\t\t ut64 sz, ut64 file_sz, int rawstr, int fd,\n\t\t\t\t const char *xtrname, Sdb *sdb, bool steal_ptr) {\n\tRBinFile *binfile = R_NEW0 (RBinFile);\n\tif (!binfile) {\n\t\treturn NULL;\n\t}\n\tif (!r_id_pool_grab_id (bin->file_ids, &binfile->id)) {\n\t\tif (steal_ptr) { // we own the ptr, free on error\n\t\t\tfree ((void*) bytes);\n\t\t}\n\t\tfree (binfile);\t\t//no id means no binfile\n\t\treturn NULL;\n\t}\n\tint res = r_bin_file_set_bytes (binfile, bytes, sz, steal_ptr);\n\tif (!res && steal_ptr) { // we own the ptr, free on error\n\t\tfree((void*) bytes);\n\t}\n\tbinfile->rbin = bin;\n\tbinfile->file = file? strdup (file): NULL;\n\tbinfile->rawstr = rawstr;\n\tbinfile->fd = fd;\n\tbinfile->curxtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\tbinfile->sdb = sdb;\n\tbinfile->size = file_sz;\n\tbinfile->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);\n\tbinfile->objs = r_list_newf ((RListFree)r_bin_object_free);\n\tbinfile->xtr_obj  = NULL;\n\n\tif (!binfile->buf) {\n\t\t//r_bin_file_free (binfile);\n\t\tbinfile->buf = r_buf_new ();\n\t\t//\treturn NULL;\n\t}\n\n\tif (sdb) {\n\t\tbinfile->sdb = sdb_ns (sdb, sdb_fmt (0, \"fd.%d\", fd), 1);\n\t\tsdb_set (binfile->sdb, \"archs\", \"0:0:x86:32\", 0); // x86??\n\t\t/* NOTE */\n\t\t/* Those refs++ are necessary because sdb_ns() doesnt rerefs all\n\t\t * sub-namespaces */\n\t\t/* And if any namespace is referenced backwards it gets\n\t\t * double-freed */\n\t\tbinfile->sdb_addrinfo = sdb_ns (binfile->sdb, \"addrinfo\", 1);\n\t\tbinfile->sdb_addrinfo->refs++;\n\t\tsdb_ns_set (sdb, \"cur\", binfile->sdb);\n\t\tbinfile->sdb->refs++;\n\t}\n\treturn binfile;\n}\n\nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf,\n\t\t\t\t\t\tut64 baseaddr, ut64 loadaddr,\n\t\t\t\t\t\tRBinXtrData *data) {\n\tRBinObject *o = NULL;\n\tRBinPlugin *plugin = NULL;\n\tut8* bytes;\n\tut64 offset = data? data->offset: 0;\n\tut64 sz = data ? data->size : 0;\n\tif (!data || !bf) {\n\t\treturn false;\n\t}\n\n\t// for right now the bytes used will just be the offest into the binfile\n\t// buffer\n\t// if the extraction requires some sort of transformation then this will\n\t// need to be fixed\n\t// here.\n\tbytes = data->buffer;\n\tif (!bytes) {\n\t\treturn false;\n\t}\n\tplugin = r_bin_get_binplugin_by_bytes (bin, (const ut8*)bytes, sz);\n\tif (!plugin) {\n\t\tplugin = r_bin_get_binplugin_any (bin);\n\t}\n\tr_buf_free (bf->buf);\n\tbf->buf = r_buf_new_with_bytes ((const ut8*)bytes, data->size);\n\t//r_bin_object_new append the new object into binfile\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o) {\n\t\treturn false;\n\t}\n\tif (o && !o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tfree (o->info->file);\n\tfree (o->info->arch);\n\tfree (o->info->machine);\n\tfree (o->info->type);\n\to->info->file = strdup (bf->file);\n\to->info->arch = strdup (data->metadata->arch);\n\to->info->machine = strdup (data->metadata->machine);\n\to->info->type = strdup (data->metadata->type);\n\to->info->bits = data->metadata->bits;\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\n\nstatic RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file,\n\t\t\t\t\t    const ut8 *bytes, ut64 sz,\n\t\t\t\t\t    ut64 file_sz, int rawstr,\n\t\t\t\t\t    ut64 baseaddr, ut64 loadaddr,\n\t\t\t\t\t    int fd, const char *pluginname,\n\t\t\t\t\t    const char *xtrname, ut64 offset,\n\t\t\t\t\t    bool steal_ptr) {\n\tut8 binfile_created = false;\n\tRBinPlugin *plugin = NULL;\n\tRBinXtrPlugin *xtr = NULL;\n\tRBinObject *o = NULL;\n\tRBinFile *bf = NULL;\n\tif (sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\n\tif (xtrname) {\n\t\txtr = r_bin_get_xtrplugin_by_name (bin, xtrname);\n\t}\n\n\tif (xtr && xtr->check_bytes (bytes, sz)) {\n\t\treturn r_bin_file_xtr_load_bytes (bin, xtr, file,\n\t\t\t\t\t\tbytes, sz, file_sz, baseaddr, loadaddr, 0,\n\t\t\t\t\t\tfd, rawstr);\n\t}\n\n\tif (!bf) {\n\t\tbf = r_bin_file_create_append (bin, file, bytes, sz, file_sz,\n\t\t\t\t\t       rawstr, fd, xtrname, steal_ptr);\n\t\tif (!bf) {\n\t\t\tif (!steal_ptr) { // we own the ptr, free on error\n\t\t\t\tfree ((void*) bytes);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tbinfile_created = true;\n\t}\n\n\tif (bin->force) {\n\t\tplugin = r_bin_get_binplugin_by_name (bin, bin->force);\n\t}\n\tif (!plugin) {\n\t\tif (pluginname) {\n\t\t\tplugin = r_bin_get_binplugin_by_name (bin, pluginname);\n\t\t}\n\t\tif (!plugin) {\n\t\t\tplugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);\n\t\t\tif (!plugin) {\n\t\t\t\tplugin = r_bin_get_binplugin_any (bin);\n\t\t\t}\n\t\t}\n\t}\n\n\to = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (o && !o->size) {\n\t\to->size = file_sz;\n\t}\n\n\tif (!o) {\n\t\tif (bf && binfile_created) {\n\t\t\tr_list_delete_data (bin->binfiles, bf);\n\t\t}\n\t\treturn NULL;\n\t}\n\t/* WTF */\n\tif (strcmp (plugin->name, \"any\")) {\n\t\tbf->narch = 1;\n\t}\n\n\t/* free unnecessary rbuffer (???) */\n\treturn bf;\n}\n\nstatic void plugin_free(RBinPlugin *p) {\n\tif (p && p->fini) {\n\t\tp->fini (NULL);\n\t}\n\tR_FREE (p);\n}\n\n// rename to r_bin_plugin_add like the rest\nR_API int r_bin_add(RBin *bin, RBinPlugin *foo) {\n\tRListIter *it;\n\tRBinPlugin *plugin;\n\tif (foo->init) {\n\t\tfoo->init (bin->user);\n\t}\n\tr_list_foreach (bin->plugins, it, plugin) {\n\t\tif (!strcmp (plugin->name, foo->name)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tplugin = R_NEW0 (RBinPlugin);\n\tmemcpy (plugin, foo, sizeof (RBinPlugin));\n\tr_list_append (bin->plugins, plugin);\n\treturn true;\n}\n\nR_API int r_bin_xtr_add(RBin *bin, RBinXtrPlugin *foo) {\n\tRListIter *it;\n\tRBinXtrPlugin *xtr;\n\n\tif (foo->init) {\n\t\tfoo->init (bin->user);\n\t}\n\t// avoid duplicates\n\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\tif (!strcmp (xtr->name, foo->name)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_list_append (bin->binxtrs, foo);\n\treturn true;\n}\n\nR_API void *r_bin_free(RBin *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->io_owned) {\n\t\tr_io_free (bin->iob.io);\n\t}\n\tbin->file = NULL;\n\tfree (bin->force);\n\tfree (bin->srcdir);\n\t//r_bin_free_bin_files (bin);\n\tr_list_free (bin->binfiles);\n\tr_list_free (bin->binxtrs);\n\tr_list_free (bin->plugins);\n\tsdb_free (bin->sdb);\n\tr_id_pool_free (bin->file_ids);\n\tmemset (bin, 0, sizeof (RBin));\n\tfree (bin);\n\treturn NULL;\n}\n\nstatic int r_bin_print_plugin_details(RBin *bin, RBinPlugin *bp, int json) {\n\tif (json == 'q') {\n\t\tbin->cb_printf (\"%s\\n\", bp->name);\n\t} else if (json) {\n\t\tbin->cb_printf (\n\t\t\t\"{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\"\\\"license\\\":\\\"%s\\\"}\\n\",\n\t\t\tbp->name, bp->desc, bp->license? bp->license: \"???\");\n\t} else {\n\t\tbin->cb_printf (\"Name: %s\\n\", bp->name);\n\t\tbin->cb_printf (\"Description: %s\\n\", bp->desc);\n\t\tif (bp->license) {\n\t\t\tbin->cb_printf (\"License: %s\\n\", bp->license);\n\t\t}\n\t\tif (bp->version) {\n\t\t\tbin->cb_printf (\"Version: %s\\n\", bp->version);\n\t\t}\n\t\tif (bp->author) {\n\t\t\tbin->cb_printf (\"Author: %s\\n\", bp->author);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int r_bin_print_xtrplugin_details(RBin *bin, RBinXtrPlugin *bx, int json) {\n\tif (json == 'q') {\n\t\tbin->cb_printf (\"%s\\n\", bx->name);\n\t} else if (json) {\n\t\tbin->cb_printf (\n\t\t\t\"{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\"\\\"license\\\":\\\"%s\\\"}\\n\",\n\t\t\tbx->name, bx->desc, bx->license? bx->license: \"???\");\n\t} else {\n\t\tbin->cb_printf (\"Name: %s\\n\", bx->name);\n\t\tbin->cb_printf (\"Description: %s\\n\", bx->desc);\n\t\tif (bx->license) {\n\t\t\tbin->cb_printf (\"License: %s\\n\", bx->license);\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_bin_list(RBin *bin, int json) {\n\tRListIter *it;\n\tRBinPlugin *bp;\n\tRBinXtrPlugin *bx;\n\n\tif (json == 'q') {\n\t\tr_list_foreach (bin->plugins, it, bp) {\n\t\t\tbin->cb_printf (\"%s\\n\", bp->name);\n\t\t}\n\t\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\t\tbin->cb_printf (\"%s\\n\", bx->name);\n\t\t}\n\t} else if (json) {\n\t\tint i;\n\n\t\ti = 0;\n\t\tbin->cb_printf (\"{\\\"bin\\\":[\");\n\t\tr_list_foreach (bin->plugins, it, bp) {\n\t\t\tbin->cb_printf (\n\t\t\t\t\"%s{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"license\\\":\\\"%s\\\"}\",\n\t\t\t\ti? \",\": \"\", bp->name, bp->desc, bp->license? bp->license: \"???\");\n\t\t\ti++;\n\t\t}\n\n\t\ti = 0;\n\t\tbin->cb_printf (\"],\\\"xtr\\\":[\");\n\t\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\t\tbin->cb_printf (\n\t\t\t\t\"%s{\\\"name\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"license\\\":\\\"%s\\\"}\",\n\t\t\t\ti? \",\": \"\", bx->name, bx->desc, bx->license? bx->license: \"???\");\n\t\t\ti++;\n\t\t}\n\t\tbin->cb_printf (\"]}\\n\");\n\t} else {\n\t\tr_list_foreach (bin->plugins, it, bp) {\n\t\t\tbin->cb_printf (\"bin  %-11s %s (%s) %s %s\\n\",\n\t\t\t\tbp->name, bp->desc, bp->license? bp->license: \"???\",\n\t\t\t\tbp->version? bp->version: \"\",\n\t\t\t\tbp->author? bp->author: \"\");\n\t\t}\n\t\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\t\tbin->cb_printf (\"xtr  %-11s %s (%s)\\n\", bx->name,\n\t\t\t\tbx->desc, bx->license? bx->license: \"???\");\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API int r_bin_list_plugin(RBin *bin, const char* name, int json) {\n\tRListIter *it;\n\tRBinPlugin *bp;\n\tRBinXtrPlugin *bx;\n\n\tr_list_foreach (bin->plugins, it, bp) {\n\t\tif (!r_str_cmp (name, bp->name, strlen (name))) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r_bin_print_plugin_details (bin, bp, json);\n\t}\n\tr_list_foreach (bin->binxtrs, it, bx) {\n\t\tif (!r_str_cmp (name, bx->name, strlen (name))) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r_bin_print_xtrplugin_details (bin, bx, json);\n\t}\n\n\teprintf (\"cannot find plugin %s\\n\", name);\n\treturn false;\n}\n\nstatic ut64 binobj_get_baddr(RBinObject *o) {\n\treturn o? o->baddr + o->baddr_shift: UT64_MAX;\n}\n\nR_API ut64 r_binfile_get_baddr(RBinFile *binfile) {\n\treturn binfile? binobj_get_baddr (binfile->o): UT64_MAX;\n}\n\n/* returns the base address of bin or UT64_MAX in case of errors */\nR_API ut64 r_bin_get_baddr(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn binobj_get_baddr (o);\n}\n\n/* returns the load address of bin or UT64_MAX in case of errors */\nR_API ut64 r_bin_get_laddr(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->loadaddr: UT64_MAX;\n}\n\nR_API void r_bin_set_baddr(RBin *bin, ut64 baddr) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tbinobj_set_baddr (o, baddr);\n\t// XXX - update all the infos?\n}\n\nR_API ut64 r_bin_get_boffset(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->boffset: UT64_MAX;\n}\n\nR_API RBinAddr *r_bin_get_sym(RBin *bin, int sym) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (sym < 0 || sym >= R_BIN_SYM_LAST) {\n\t\treturn NULL;\n\t}\n\treturn o? o->binsym[sym]: NULL;\n}\n\n// XXX: those accessors are redundant\nR_API RList *r_bin_get_entries(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->entries: NULL;\n}\n\nR_API RList *r_bin_get_fields(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->fields: NULL;\n}\n\nR_API RList *r_bin_get_imports(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->imports: NULL;\n}\n\nR_API RBinInfo *r_bin_get_info(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->info: NULL;\n}\n\nR_API RList *r_bin_get_libs(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->libs: NULL;\n}\n\n\nR_API RList * r_bin_patch_relocs(RBin *bin) {\n\tstatic bool first = true;\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\t// r_bin_object_set_items set o->relocs but there we don't have access\n\t// to io\n\t// so we need to be run from bin_relocs, free the previous reloc and get\n\t// the patched ones\n\tif (first && o->plugin && o->plugin->patch_relocs) {\n\t\tRList *tmp = o->plugin->patch_relocs (bin);\n\t\tfirst = false;\n\t\tif (!tmp) {\n\t\t\treturn o->relocs;\n\t\t}\n\t\tr_list_free (o->relocs);\n\t\to->relocs = tmp;\n\t\tREBASE_PADDR (o, o->relocs, RBinReloc);\n\t\tfirst = false;\n\t\treturn o->relocs;\n\t}\n\treturn o->relocs;\n}\n\nR_API RList *r_bin_get_relocs(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->relocs: NULL;\n}\n\nR_API RList *r_bin_get_sections(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->sections: NULL;\n}\n\n// TODO: Move into section.c and rename it to r_io_section_get_at ()\nR_API RBinSection *r_bin_get_section_at(RBinObject *o, ut64 off, int va) {\n\tRBinSection *section;\n\tRListIter *iter;\n\tut64 from, to;\n\tif (o) {\n\t\t// TODO: must be O(1) .. use sdb here\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tfrom = va? binobj_a2b (o, section->vaddr): section->paddr;\n\t\t\tto = va? (binobj_a2b (o, section->vaddr) + section->vsize) :\n\t\t\t\t(section->paddr + section->size);\n\t\t\tif (off >= from && off < to) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_reset_strings(RBin *bin) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinObject *o = r_bin_cur_object (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\n\tif (!a || !o) {\n\t\treturn NULL;\n\t}\n\tif (o->strings) {\n\t\tr_list_free (o->strings);\n\t\to->strings = NULL;\n\t}\n\n\tif (bin->minstrlen <= 0) {\n\t\treturn NULL;\n\t}\n\ta->rawstr = bin->rawstr;\n\n\tif (plugin && plugin->strings) {\n\t\to->strings = plugin->strings (a);\n\t} else {\n\t\to->strings = get_strings (a, bin->minstrlen, 0);\n\t}\n\tif (bin->debase64) {\n\t\tfilterStrings (bin, o->strings);\n\t}\n\treturn o->strings;\n}\n\nR_API RList *r_bin_get_strings(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->strings: NULL;\n}\n\nR_API int r_bin_is_string(RBin *bin, ut64 va) {\n\tRBinString *string;\n\tRListIter *iter;\n\tRList *list;\n\tif (!(list = r_bin_get_strings (bin))) {\n\t\treturn false;\n\t}\n\tr_list_foreach (list, iter, string) {\n\t\tif (string->vaddr == va) {\n\t\t\treturn true;\n\t\t}\n\t\tif (string->vaddr > va) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\n//callee must not free the symbol\nR_API RBinSymbol *r_bin_get_symbol_at_vaddr(RBin *bin, ut64 addr) {\n\t//use skiplist here\n\tRList *symbols = r_bin_get_symbols (bin);\n\tRListIter *iter;\n\tRBinSymbol *symbol;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (symbol->vaddr == addr) {\n\t\t\treturn symbol;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n//callee must not free the symbol\nR_API RBinSymbol *r_bin_get_symbol_at_paddr(RBin *bin, ut64 addr) {\n\t//use skiplist here\n\tRList *symbols = r_bin_get_symbols (bin);\n\tRListIter *iter;\n\tRBinSymbol *symbol;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (symbol->paddr == addr) {\n\t\t\treturn symbol;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_get_symbols(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->symbols: NULL;\n}\n\nR_API RList *r_bin_get_mem(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->mem: NULL;\n}\n\nR_API int r_bin_is_big_endian(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn (o && o->info)? o->info->big_endian: -1;\n}\n\nR_API int r_bin_is_stripped(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_STRIPPED & o->info->dbg_info): 1;\n}\n\nR_API int r_bin_is_static(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (o && r_list_length (o->libs) > 0)\n\t\treturn R_BIN_DBG_STATIC & o->info->dbg_info;\n\treturn true;\n}\n\n// TODO: Integrate with r_bin_dbg */\nR_API int r_bin_has_dbg_linenums(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_LINENUMS & o->info->dbg_info): false;\n}\n\nR_API int r_bin_has_dbg_syms(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_SYMS & o->info->dbg_info): false;\n}\n\nR_API int r_bin_has_dbg_relocs(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? (R_BIN_DBG_RELOCS & o->info->dbg_info): false;\n}\n\nR_API RBin *r_bin_new() {\n\tint i;\n\tRBinXtrPlugin *static_xtr_plugin;\n\tRBin *bin = R_NEW0 (RBin);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->force = NULL;\n\tbin->filter_rules = UT64_MAX;\n\tbin->sdb = sdb_new0 ();\n\tbin->cb_printf = (PrintfCallback)printf;\n\tbin->plugins = r_list_newf ((RListFree)plugin_free);\n\tbin->minstrlen = 0;\n\tbin->want_dbginfo = true;\n\tbin->cur = NULL;\n\tbin->io_owned = false;\n\n\tbin->binfiles = r_list_newf ((RListFree)r_bin_file_free);\n\tfor (i = 0; bin_static_plugins[i]; i++) {\n\t\tr_bin_add (bin, bin_static_plugins[i]);\n\t}\n\tbin->binxtrs = r_list_new ();\n\tbin->binxtrs->free = free;\n\tfor (i = 0; bin_xtr_static_plugins[i]; i++) {\n\t\tstatic_xtr_plugin = R_NEW0 (RBinXtrPlugin);\n\t\tif (!static_xtr_plugin) {\n\t\t\tfree (bin);\n\t\t\treturn NULL;\n\t\t}\n\t\t*static_xtr_plugin = *bin_xtr_static_plugins[i];\n\t\tr_bin_xtr_add (bin, static_xtr_plugin);\n\t}\n\tbin->file_ids = r_id_pool_new (0, 0xffffffff);\n\treturn bin;\n}\n\nR_API int r_bin_use_arch(RBin *bin, const char *arch, int bits,\n\t\t\t  const char *name) {\n\tRBinFile *binfile = r_bin_file_find_by_arch_bits (bin, arch, bits, name);\n\tRBinObject *obj = NULL;\n\tif (binfile) {\n\t\tobj = r_bin_object_find_by_arch_bits (binfile, arch, bits, name);\n\t\tif (!obj) {\n\t\t\tif (binfile->xtr_data) {\n\t\t\t\tRBinXtrData *xtr_data = r_list_get_n (binfile->xtr_data, 0);\n\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (bin, binfile,\n\t\t\t\t\t\tUT64_MAX, r_bin_get_laddr (bin), xtr_data)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobj = r_list_get_n (binfile->objs, 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvoid *plugin = r_bin_get_binplugin_by_name (bin, name);\n\t\tif (plugin) {\n\t\t\tif (bin->cur) {\n\t\t\t\tbin->cur->curplugin = plugin;\n\t\t\t}\n\t\t\tbinfile = r_bin_file_new (bin, \"-\", NULL, 0, 0, 0, 999, NULL, NULL, false);\n\t\t\t// create object and set arch/bits\n\t\t\tobj = r_bin_object_new (binfile, plugin, 0, 0, 0, 1024);\n\t\t\tbinfile->o = obj;\n\t\t\tobj->info = R_NEW0 (RBinInfo);\n\t\t\tobj->info->arch = strdup (arch);\n\t\t\tobj->info->bits = bits;\n\t\t}\n\t}\n\treturn (binfile && r_bin_file_set_cur_binfile_obj (bin, binfile, obj));\n}\n\nR_API RBinObject *r_bin_object_find_by_arch_bits(RBinFile *binfile,\n\t\t\t\t\t\t  const char *arch, int bits,\n\t\t\t\t\t\t  const char *name) {\n\tRBinObject *obj = NULL;\n\tRListIter *iter = NULL;\n\tRBinInfo *info = NULL;\n\tr_list_foreach (binfile->objs, iter, obj) {\n\t\tinfo = obj->info;\n\t\tif (info && info->arch && info->file &&\n\t\t   (bits == info->bits) &&\n\t\t\t!strcmp (info->arch, arch) &&\n\t\t\t!strcmp (info->file, name)) {\n\t\t\tbreak;\n\t\t}\n\t\tobj = NULL;\n\t}\n\treturn obj;\n}\n\nR_API RBinFile *r_bin_file_find_by_arch_bits(RBin *bin, const char *arch,\n\t\t\t\t\t      int bits, const char *name) {\n\tRListIter *iter;\n\tRBinFile *binfile = NULL;\n\tRBinXtrData *xtr_data;\n\n\tif (!name || !arch) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tRListIter *iter_xtr;\n\t\tif (!binfile->xtr_data) {\n\t\t\tcontinue;\n\t\t}\n\t\t// look for sub-bins in Xtr Data and Load if we need to\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (xtr_data->metadata && xtr_data->metadata->arch) {\n\t\t\t\tchar *iter_arch = xtr_data->metadata->arch;\n\t\t\t\tint iter_bits = xtr_data->metadata->bits;\n\t\t\t\tif (bits == iter_bits && !strcmp (iter_arch, arch)) {\n\t\t\t\t\tif (!xtr_data->loaded) {\n\t\t\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (\n\t\t\t\t\t\t\t    bin, binfile, xtr_data->baddr,\n\t\t\t\t\t\t\t    xtr_data->laddr, xtr_data)) {\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn binfile;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn binfile;\n}\n\nR_API int r_bin_select(RBin *bin, const char *arch, int bits,\n\t\t\tconst char *name) {\n\tRBinFile *cur = r_bin_cur (bin), *binfile = NULL;\n\tRBinObject *obj = NULL;\n\tname = !name && cur? cur->file: name;\n\tbinfile = r_bin_file_find_by_arch_bits (bin, arch, bits, name);\n\tif (binfile && name) {\n\t\tobj = r_bin_object_find_by_arch_bits (binfile, arch, bits, name);\n\t}\n\treturn binfile && r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n}\n\nR_API int r_bin_select_object(RBinFile *binfile, const char *arch, int bits,\n\t\t\t       const char *name) {\n\tRBinObject *obj = binfile ? r_bin_object_find_by_arch_bits (\n\t\t\t\t\t    binfile, arch, bits, name) :\n\t\t\t\t    NULL;\n\treturn obj &&\n\t       r_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, obj);\n}\n\nstatic RBinObject *r_bin_file_object_find_by_id(RBinFile *binfile,\n\t\t\t\t\t\t ut32 binobj_id) {\n\tRBinObject *obj;\n\tRListIter *iter;\n\tif (binfile)  {\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tif (obj->id == binobj_id) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic RBinFile *r_bin_file_find_by_object_id(RBin *bin, ut32 binobj_id) {\n\tRListIter *iter;\n\tRBinFile *binfile;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (r_bin_file_object_find_by_id (binfile, binobj_id)) {\n\t\t\treturn binfile;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 binfile_id) {\n\tRBinFile *binfile = NULL;\n\tRListIter *iter = NULL;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (binfile->id == binfile_id) {\n\t\t\tbreak;\n\t\t}\n\t\tbinfile = NULL;\n\t}\n\treturn binfile;\n}\n\nR_API int r_bin_object_delete(RBin *bin, ut32 binfile_id, ut32 binobj_id) {\n\tRBinFile *binfile = NULL; //, *cbinfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tint res = false;\n\n#if 0\n\tif (binfile_id == UT32_MAX && binobj_id == UT32_MAX) {\n\t\treturn false;\n\t}\n#endif\n\tif (binfile_id == -1) {\n\t\tbinfile = r_bin_file_find_by_object_id (bin, binobj_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t} else if (binobj_id == -1) {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? binfile->o: NULL;\n\t} else {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t}\n\n\t// lazy way out, always leaving at least 1 bin object loaded\n\tif (binfile && (r_list_length (binfile->objs) > 1)) {\n\t\tbinfile->o = NULL;\n\t\tr_list_delete_data (binfile->objs, obj);\n\t\tobj = (RBinObject *)r_list_get_n (binfile->objs, 0);\n\t\tres = obj && binfile &&\n\t\t      r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n\t}\n\treturn res;\n}\n\nR_API int r_bin_select_by_ids(RBin *bin, ut32 binfile_id, ut32 binobj_id) {\n\tRBinFile *binfile = NULL;\n\tRBinObject *obj = NULL;\n\n\tif (binfile_id == UT32_MAX && binobj_id == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (binfile_id == -1) {\n\t\tbinfile = r_bin_file_find_by_object_id (bin, binobj_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t} else if (binobj_id == -1) {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? binfile->o: NULL;\n\t} else {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t}\n\tif (!binfile || !obj) {\n\t\treturn false;\n\t}\n\treturn obj && binfile && r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n}\n\nR_API int r_bin_select_idx(RBin *bin, const char *name, int idx) {\n\tRBinFile *nbinfile = NULL, *binfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tconst char *tname = !name && binfile? binfile->file: name;\n\tint res = false;\n\tif (!tname || !bin) {\n\t\treturn res;\n\t}\n\tnbinfile = r_bin_file_find_by_name_n (bin, tname, idx);\n\tobj = nbinfile? r_list_get_n (nbinfile->objs, idx): NULL;\n\treturn obj && nbinfile &&\n\t       r_bin_file_set_cur_binfile_obj (bin, nbinfile, obj);\n}\n\nstatic void list_xtr_archs(RBin *bin, int mode) {\n\tRBinFile *binfile = r_bin_cur (bin);\n\tif (binfile->xtr_data) {\n\t\tRListIter *iter_xtr;\n\t\tRBinXtrData *xtr_data;\n\t\tint bits, i = 0;\n\t\tchar *arch, *machine;\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (!xtr_data || !xtr_data->metadata ||\n\t\t\t    !xtr_data->metadata->arch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarch = xtr_data->metadata->arch;\n\t\t\tmachine = xtr_data->metadata->machine;\n\t\t\tbits = xtr_data->metadata->bits;\n\t\t\tswitch (mode) {\n\t\t\tcase 'q':\n\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tbin->cb_printf (\n\t\t\t\t\t\"%s{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d\n\t\t\t\t\t\",\\\"size\\\":\\\"%\" PFMT64d\n\t\t\t\t\t\",\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\ti++ ? \",\" : \"\", arch, bits,\n\t\t\t\t\txtr_data->offset, xtr_data->size,\n\t\t\t\t\tmachine);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x\n\t\t\t\t\t\t\" %\" PFMT64d \" %s_%i %s\\n\",\n\t\t\t\t\t\ti++, xtr_data->offset,\n\t\t\t\t\t\txtr_data->size, arch, bits,\n\t\t\t\t\t\tmachine);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_list_archs(RBin *bin, int mode) {\n\tRListIter *iter;\n\tint i = 0;\n\tchar unk[128];\n\tchar archline[128];\n\tRBinFile *binfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tconst char *name = binfile? binfile->file: NULL;\n\tint narch = binfile? binfile->narch: 0;\n\n\t//are we with xtr format?\n\tif (binfile && binfile->curxtr) {\n\t\tlist_xtr_archs (bin, mode);\n\t\treturn;\n\t}\n\tSdb *binfile_sdb = binfile? binfile->sdb: NULL;\n\tif (!binfile_sdb) {\n\t\teprintf (\"Cannot find SDB!\\n\");\n\t\treturn;\n\t} else if (!binfile) {\n\t\teprintf (\"Binary format not currently loaded!\\n\");\n\t\treturn;\n\t}\n\tsdb_unset (binfile_sdb, ARCHS_KEY, 0);\n\tif (mode == 'j') {\n\t\tbin->cb_printf (\"\\\"bins\\\":[\");\n\t}\n\tRBinFile *nbinfile = r_bin_file_find_by_name_n (bin, name, i);\n\tif (!nbinfile) {\n\t\treturn;\n\t}\n\ti = -1;\n\tr_list_foreach (nbinfile->objs, iter, obj) {\n\t\tRBinInfo *info = obj->info;\n\t\tchar bits = info? info->bits: 0;\n\t\tut64 boffset = obj->boffset;\n\t\tut32 obj_size = obj->obj_size;\n\t\tconst char *arch = info? info->arch: NULL;\n\t\tconst char *machine = info? info->machine: \"unknown_machine\";\n\n\t\ti++;\n\t\tif (!arch) {\n\t\t\tsnprintf (unk, sizeof (unk), \"unk_%d\", i);\n\t\t\tarch = unk;\n\t\t}\n\n\t\tif (info && narch > 1) {\n\t\t\tswitch (mode) {\n\t\t\tcase 'q':\n\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tbin->cb_printf (\"%s{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d \",\\\"size\\\":%d,\"\n\t\t\t\t\t\t\"\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\ti? \",\": \"\", arch, bits,\n\t\t\t\t\t\tboffset, obj_size, machine);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x \" %d %s_%i %s\\n\", i,\n\t\t\t\t\t\tboffset, obj_size, arch, bits, machine);\n\t\t\t}\n\t\t\tsnprintf (archline, sizeof (archline) - 1,\n\t\t\t\t\"0x%08\" PFMT64x \":%d:%s:%d:%s\",\n\t\t\t\tboffset, obj_size, arch, bits, machine);\n\t\t\t/// xxx machine not exported?\n\t\t\t//sdb_array_push (binfile_sdb, ARCHS_KEY, archline, 0);\n\t\t} else {\n\t\t\tif (info) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'q':\n\t\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tbin->cb_printf (\"%s{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d \",\\\"size\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\ti? \",\": \"\", arch, bits,\n\t\t\t\t\t\t\tboffset, obj_size, machine);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x \" %d %s_%d\\n\", i,\n\t\t\t\t\t\t\tboffset, obj_size, arch, bits);\n\t\t\t\t}\n\t\t\t\tsnprintf (archline, sizeof (archline),\n\t\t\t\t\t\"0x%08\" PFMT64x \":%d:%s:%d\",\n\t\t\t\t\tboffset, obj_size, arch, bits);\n\t\t\t} else if (nbinfile && mode) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'q':\n\t\t\t\t\tbin->cb_printf (\"%s\\n\", arch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tbin->cb_printf (\"%s{\\\"arch\\\":\\\"unk_%d\\\",\\\"bits\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"offset\\\":%\" PFMT64d \",\\\"size\\\":%d,\"\n\t\t\t\t\t\t\t\"\\\"machine\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\ti? \",\": \"\", i, bits,\n\t\t\t\t\t\t\tboffset, obj_size, machine);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbin->cb_printf (\"%03i 0x%08\" PFMT64x \" %d unk_0\\n\", i,\n\t\t\t\t\t\t\tboffset, obj_size);\n\t\t\t\t}\n\t\t\t\tsnprintf (archline, sizeof (archline),\n\t\t\t\t\t\"0x%08\" PFMT64x \":%d:%s:%d\",\n\t\t\t\t\tboffset, obj_size, \"unk\", 0);\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: Invalid RBinFile.\\n\");\n\t\t\t}\n\t\t\t//sdb_array_push (binfile_sdb, ARCHS_KEY, archline, 0);\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tbin->cb_printf (\"]\");\n\t}\n}\n\nR_API void r_bin_set_user_ptr(RBin *bin, void *user) {\n\tbin->user = user;\n}\n\nstatic RBinSection* _get_vsection_at(RBin *bin, ut64 vaddr) {\n\tRBinObject *cur = r_bin_object_get_cur (bin);\n\treturn r_bin_get_section_at (cur, vaddr, true);\n}\nR_API void r_bin_bind(RBin *bin, RBinBind *b) {\n\tif (b) {\n\t\tb->bin = bin;\n\t\tb->get_offset = getoffset;\n\t\tb->get_name = getname;\n\t\tb->get_sections = r_bin_get_sections;\n\t\tb->get_vsect_at = _get_vsection_at;\n\t}\n}\n\nR_API RBuffer *r_bin_create(RBin *bin, const ut8 *code, int codelen,\n\t\t\t     const ut8 *data, int datalen) {\n\tRBinFile *a = r_bin_cur (bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (a);\n\tif (codelen < 0) {\n\t\tcodelen = 0;\n\t}\n\tif (datalen < 0) {\n\t\tdatalen = 0;\n\t}\n\tif (plugin && plugin->create) {\n\t\treturn plugin->create (bin, code, codelen, data, datalen);\n\t}\n\treturn NULL;\n}\n\nR_API RBuffer *r_bin_package(RBin *bin, const char *type, const char *file, RList *files) {\n\tif (!strcmp (type, \"zip\")) {\n#if 0\n\t\tint zep = 0;\n\t\tstruct zip * z = zip_open (file, 8 | 1, &zep);\n\t\tif (z) {\n\t\t\tRListIter *iter;\n\t\t\tconst char *f;\n\t\t\teprintf (\"zip file created\\n\");\n\t\t\tr_list_foreach (files, iter, f) {\n\t\t\t\tstruct zip_source *zs = NULL;\n\t\t\t\tzs = zip_source_file (z, f, 0, 1024);\n\t\t\t\tif (zs) {\n\t\t\t\t\teprintf (\"ADD %s\\n\", f);\n\t\t\t\t\tzip_add (z, f, zs);\n\t\t\t\t\tzip_source_free (zs);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot find file %s\\n\", f);\n\t\t\t\t}\n\t\t\t\teprintf (\"zS %p\\n\", zs);\n\t\t\t}\n\t\t\tzip_close (z);\n\t\t} else {\n\t\t\teprintf (\"Cannot create zip file\\n\");\n\t\t}\n#endif\n\t} else if (!strcmp (type, \"fat\")) {\n\t\tconst char *f;\n\t\tRListIter *iter;\n\t\tut32 num;\n\t\tut8 *num8 = (ut8*)&num;\n\t\tRBuffer *buf = r_buf_new_file (file, true);\n\t\tr_buf_write_at (buf, 0, (const ut8*)\"\\xca\\xfe\\xba\\xbe\", 4);\n\t\tint count = r_list_length (files);\n\n\t\tnum = r_read_be32 (&count);\n\t\tut64 from = 0x1000;\n\t\tr_buf_write_at (buf, 4, num8, 4);\n\t\tint off = 12;\n\t\tint item = 0;\n\t\tr_list_foreach (files, iter, f) {\n\t\t\tint f_len = 0;\n\t\t\tut8 *f_buf = (ut8 *)r_file_slurp (f, &f_len);\n\t\t\tif (f_buf && f_len >= 0) {\n\t\t\t\teprintf (\"ADD %s %d\\n\", f, f_len);\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot open %s\\n\", f);\n\t\t\t\tfree (f_buf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titem++;\n\t\t\t/* CPU */\n\t\t\tnum8[0] = f_buf[7];\n\t\t\tnum8[1] = f_buf[6];\n\t\t\tnum8[2] = f_buf[5];\n\t\t\tnum8[3] = f_buf[4];\n\t\t\tr_buf_write_at (buf, off - 4, num8, 4);\n\t\t\t/* SUBTYPE */\n\t\t\tnum8[0] = f_buf[11];\n\t\t\tnum8[1] = f_buf[10];\n\t\t\tnum8[2] = f_buf[9];\n\t\t\tnum8[3] = f_buf[8];\n\t\t\tr_buf_write_at (buf, off, num8, 4);\n\t\t\tut32 from32 = from;\n\t\t\t/* FROM */\n\t\t\tnum = r_read_be32 (&from32);\n\t\t\tr_buf_write_at (buf, off + 4, num8, 4);\n\t\t\tr_buf_write_at (buf, from, f_buf, f_len);\n\t\t\t/* SIZE */\n\t\t\tnum = r_read_be32 (&f_len);\n\t\t\tr_buf_write_at (buf, off + 8, num8, 4);\n\t\t\toff += 20;\n\t\t\tfrom += f_len + (f_len % 0x1000);\n\t\t\tfree (f_buf);\n\t\t}\n\t\tr_buf_free (buf);\n\t\treturn NULL;\n\t} else {\n\t\teprintf (\"Usage: rabin2 -X [fat|zip] [filename] [files ...]\\n\");\n\t}\n\treturn NULL;\n}\n\nR_API RBinObject *r_bin_get_object(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\tif (o) {\n\t\to->referenced++;\n\t}\n\treturn o;\n}\n\nR_API RList * /*<RBinClass>*/ r_bin_get_classes(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->classes: NULL;\n}\n\nR_API void r_bin_class_free(RBinClass *c) {\n\tfree (c->name);\n\tfree (c->super);\n\tr_list_free (c->methods);\n\tr_list_free (c->fields);\n\tfree (c);\n}\n\nR_API RBinClass *r_bin_class_new(RBinFile *binfile, const char *name,\n\t\t\t\t  const char *super, int view) {\n\tRBinObject *o = binfile? binfile->o: NULL;\n\tRList *list = NULL;\n\tRBinClass *c;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tlist = o->classes;\n\tif (!name) {\n\t\treturn NULL;\n\t}\n\tc = r_bin_class_get (binfile, name);\n\tif (c) {\n\t\tif (super) {\n\t\t\tfree (c->super);\n\t\t\tc->super = strdup (super);\n\t\t}\n\t\treturn c;\n\t}\n\tc = R_NEW0 (RBinClass);\n\tif (!c) {\n\t\treturn NULL;\n\t}\n\tc->name = strdup (name);\n\tc->super = super? strdup (super): NULL;\n\tc->index = r_list_length (list);\n\tc->methods = r_list_new ();\n\tc->fields = r_list_new ();\n\tc->visibility = view;\n\tif (!list) {\n\t\tlist = o->classes = r_list_new ();\n\t}\n\tr_list_append (list, c);\n\treturn c;\n}\n\nR_API RBinClass *r_bin_class_get(RBinFile *binfile, const char *name) {\n\tif (!binfile || !binfile->o || !name) {\n\t\treturn NULL;\n\t}\n\tRBinClass *c;\n\tRListIter *iter;\n\tRList *list = binfile->o->classes;\n\tr_list_foreach (list, iter, c) {\n\t\tif (!strcmp (c->name, name)) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinSymbol *r_bin_class_add_method(RBinFile *binfile, const char *classname, const char *name, int nargs) {\n\tRBinClass *c = r_bin_class_get (binfile, classname);\n\tif (!c) {\n\t\tc = r_bin_class_new (binfile, classname, NULL, 0);\n\t\tif (!c) {\n\t\t\teprintf (\"Cannot allocate class %s\\n\", classname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tRBinSymbol *m;\n\tRListIter *iter;\n\tr_list_foreach (c->methods, iter, m) {\n\t\tif (!strcmp (m->name, name)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn NULL;\n\t}\n\tsym->name = strdup (name);\n\tr_list_append (c->methods, sym);\n\treturn sym;\n}\n\nR_API void r_bin_class_add_field(RBinFile *binfile, const char *classname, const char *name) {\n\t//TODO: add_field into class\n\t//eprintf (\"TODO add field: %s \\n\", name);\n}\n\n/* returns vaddr, rebased with the baseaddr of binfile, if va is enabled for\n * bin, paddr otherwise */\nR_API ut64 r_binfile_get_vaddr(RBinFile *binfile, ut64 paddr, ut64 vaddr) {\n\tint use_va = 0;\n\tif (binfile && binfile->o && binfile->o->info) {\n\t\tuse_va = binfile->o->info->has_va;\n\t}\n\treturn use_va? binobj_a2b (binfile->o, vaddr): paddr;\n}\n\n/* returns vaddr, rebased with the baseaddr of bin, if va is enabled for bin,\n * paddr otherwise */\nR_API ut64 r_bin_get_vaddr(RBin *bin, ut64 paddr, ut64 vaddr) {\n\tif (!bin || !bin->cur) {\n\t\treturn UT64_MAX;\n\t}\n\tif (paddr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\t/* hack to realign thumb symbols */\n\tif (bin->cur->o && bin->cur->o->info && bin->cur->o->info->arch) {\n\t\tif (bin->cur->o->info->bits == 16) {\n\t\t\tRBinSection *s = r_bin_get_section_at (bin->cur->o, paddr, false);\n\t\t\t// autodetect thumb\n\t\t\tif (s && s->srwx & 1 && strstr (s->name, \"text\")) {\n\t\t\t\tif (!strcmp (bin->cur->o->info->arch, \"arm\") && (vaddr & 1)) {\n\t\t\t\t\tvaddr = (vaddr >> 1) << 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn r_binfile_get_vaddr (bin->cur, paddr, vaddr);\n}\n\nR_API ut64 r_bin_a2b(RBin *bin, ut64 addr) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o? o->baddr_shift + addr: addr;\n}\n\nR_API ut64 r_bin_get_size(RBin *bin) {\n\tRBinObject *o = r_bin_cur_object (bin);\n\treturn o ? o->size : 0;\n}\n\nR_API int r_bin_file_delete_all(RBin *bin) {\n\tint counter = 0;\n\tif (bin) {\n\t\tcounter = r_list_length (bin->binfiles);\n\t\tr_list_purge (bin->binfiles);\n\t\tbin->cur = NULL;\n\t}\n\treturn counter;\n}\n\nR_API int r_bin_file_delete(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tRBinFile *cur = r_bin_cur (bin);\n\tif (bin && cur) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\tif (cur->fd == bin_fd) {\n\t\t\t\t\t//avoiding UaF due to dead reference \n\t\t\t\t\tbin->cur = NULL;\n\t\t\t\t}\n\t\t\t\tr_list_delete (bin->binfiles, iter);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API RBinFile *r_bin_file_find_by_fd(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\tif (bin) {\n\t\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\t\tif (bf && bf->fd == bin_fd) {\n\t\t\t\treturn bf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_name(RBin *bin, const char *name) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tif (!bin || !name) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tbreak;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_name_n(RBin *bin, const char *name, int idx) {\n\tRListIter *iter;\n\tRBinFile *bf = NULL;\n\tint i = 0;\n\tif (!bin) {\n\t\treturn bf;\n\t}\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->file && !strcmp (bf->file, name)) {\n\t\t\tif (i == idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tbf = NULL;\n\t}\n\treturn bf;\n}\n\nR_API int r_bin_file_set_cur_by_fd(RBin *bin, ut32 bin_fd) {\n\tRBinFile *bf = r_bin_file_find_by_fd (bin, bin_fd);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API int r_bin_file_set_cur_binfile_obj(RBin *bin, RBinFile *bf, RBinObject *obj) {\n\tRBinPlugin *plugin = NULL;\n\tif (!bin || !bf || !obj) {\n\t\treturn false;\n\t}\n\tbin->file = bf->file;\n\tbin->cur = bf;\n\tbin->narch = bf->narch;\n\tbf->o = obj;\n\tplugin = r_bin_file_cur_plugin (bf);\n\tif (bin->minstrlen < 1) {\n\t\tbin->minstrlen = plugin? plugin->minstrlen: bin->minstrlen;\n\t}\n\treturn true;\n}\n\nR_API int r_bin_file_set_cur_binfile(RBin *bin, RBinFile *bf) {\n\tRBinObject *obj = bf? bf->o: NULL;\n\treturn obj? r_bin_file_set_cur_binfile_obj (bin, bf, obj): false;\n}\n\nR_API int r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API RBinFile *r_bin_cur(RBin *bin) {\n\treturn bin? bin->cur: NULL;\n}\n\nR_API RBinObject *r_bin_cur_object(RBin *bin) {\n\tRBinFile *binfile = r_bin_cur (bin);\n\treturn binfile? binfile->o: NULL;\n}\n\nR_API void r_bin_force_plugin(RBin *bin, const char *name) {\n\tfree (bin->force);\n\tbin->force = (name && *name)? strdup (name): NULL;\n}\n\nR_API int r_bin_read_at(RBin *bin, ut64 addr, ut8 *buf, int size) {\n\tRIOBind *iob;\n\tif (!bin || !(iob = &(bin->iob))) {\n\t\treturn false;\n\t}\n\treturn iob->read_at (iob->io, addr, buf, size);\n}\n\nR_API int r_bin_write_at(RBin *bin, ut64 addr, const ut8 *buf, int size) {\n\tRIOBind *iob;\n\tif (!bin || !(iob = &(bin->iob))) {\n\t\treturn false;\n\t}\n\treturn iob->write_at (iob->io, addr, buf, size);\n}\n\nR_API const char *r_bin_entry_type_string(int etype) {\n\tswitch (etype) {\n\tcase R_BIN_ENTRY_TYPE_PROGRAM:\n\t\treturn \"program\";\n\tcase R_BIN_ENTRY_TYPE_MAIN:\n\t\treturn \"main\";\n\tcase R_BIN_ENTRY_TYPE_INIT:\n\t\treturn \"init\";\n\tcase R_BIN_ENTRY_TYPE_FINI:\n\t\treturn \"fini\";\n\tcase R_BIN_ENTRY_TYPE_TLS:\n\t\treturn \"tls\";\n\t}\n\treturn NULL;\n}\n\nR_API void r_bin_load_filter(RBin *bin, ut64 rules) {\n\tbin->filter_rules = rules;\n}\n\n/* RBinField */\nR_API RBinField *r_bin_field_new(ut64 paddr, ut64 vaddr, int size, const char *name, const char *comment, const char *format) {\n\tRBinField *ptr;\n\tif (!(ptr = R_NEW0 (RBinField))) {\n\t\treturn NULL;\n\t}\n\tptr->name = strdup (name);\n\tptr->comment = (comment && *comment)? strdup (comment): NULL;\n\tptr->format = (format && *format)? strdup (format): NULL;\n\tptr->paddr = paddr;\n\tptr->size = size;\n//\tptr->visibility = ???\n\tptr->vaddr = vaddr;\n\treturn ptr;\n}\n\n// use void* to honor the RListFree signature\nR_API void r_bin_field_free(void *_field) {\n\tRBinField *field = (RBinField*) _field;\n\tfree (field->name);\n\tfree (field->comment);\n\tfree (field->format);\n\tfree (field);\n}\n\nR_API const char *r_bin_get_meth_flag_string(ut64 flag, bool compact) {\n\tswitch (flag) {\n\tcase R_BIN_METH_CLASS:\n\t\treturn compact ? \"c\" : \"class\";\n\tcase R_BIN_METH_STATIC:\n\t\treturn compact ? \"s\" : \"static\";\n\tcase R_BIN_METH_PUBLIC:\n\t\treturn compact ? \"p\" : \"public\";\n\tcase R_BIN_METH_PRIVATE:\n\t\treturn compact ? \"P\" : \"private\";\n\tcase R_BIN_METH_PROTECTED:\n\t\treturn compact ? \"r\" : \"protected\";\n\tcase R_BIN_METH_INTERNAL:\n\t\treturn compact ? \"i\" : \"internal\";\n\tcase R_BIN_METH_OPEN:\n\t\treturn compact ? \"o\" : \"open\";\n\tcase R_BIN_METH_FILEPRIVATE:\n\t\treturn compact ? \"e\" : \"fileprivate\";\n\tcase R_BIN_METH_FINAL:\n\t\treturn compact ? \"f\" : \"final\";\n\tcase R_BIN_METH_VIRTUAL:\n\t\treturn compact ? \"v\" : \"virtual\";\n\tcase R_BIN_METH_CONST:\n\t\treturn compact ? \"k\" : \"const\";\n\tcase R_BIN_METH_MUTATING:\n\t\treturn compact ? \"m\" : \"mutating\";\n\tcase R_BIN_METH_ABSTRACT:\n\t\treturn compact ? \"a\" : \"abstract\";\n\tcase R_BIN_METH_SYNCHRONIZED:\n\t\treturn compact ? \"y\" : \"synchronized\";\n\tcase R_BIN_METH_NATIVE:\n\t\treturn compact ? \"n\" : \"native\";\n\tcase R_BIN_METH_BRIDGE:\n\t\treturn compact ? \"b\" : \"bridge\";\n\tcase R_BIN_METH_VARARGS:\n\t\treturn compact ? \"g\" : \"varargs\";\n\tcase R_BIN_METH_SYNTHETIC:\n\t\treturn compact ? \"h\" : \"synthetic\";\n\tcase R_BIN_METH_STRICT:\n\t\treturn compact ? \"t\" : \"strict\";\n\tcase R_BIN_METH_MIRANDA:\n\t\treturn compact ? \"A\" : \"miranda\";\n\tcase R_BIN_METH_CONSTRUCTOR:\n\t\treturn compact ? \"C\" : \"constructor\";\n\tcase R_BIN_METH_DECLARED_SYNCHRONIZED:\n\t\treturn compact ? \"Y\" : \"declared_synchronized\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n"], "filenames": ["libr/bin/bin.c"], "buggy_code_start_loc": [355], "buggy_code_end_loc": [365], "fixing_code_start_loc": [355], "fixing_code_end_loc": [365], "type": "CWE-125", "message": "In radare 2.0.1, an out-of-bounds read vulnerability exists in string_scan_range() in libr/bin/bin.c when doing a string search.", "other": {"cve": {"id": "CVE-2017-16358", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-01T17:29:00.430", "lastModified": "2017-11-13T16:26:39.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In radare 2.0.1, an out-of-bounds read vulnerability exists in string_scan_range() in libr/bin/bin.c when doing a string search."}, {"lang": "es", "value": "Existe una vulnerabilidad de lectura fuera de l\u00edmites en radare 2.0.1 en string_scan_range() en libr/bin/bin.c cuando se realiza una b\u00fasqueda de cadena."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "E5B4DFB4-18C8-413E-8953-1E7359DAC6EE"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/d31c4d3cbdbe01ea3ded16a584de94149ecd31d9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/8748", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/d31c4d3cbdbe01ea3ded16a584de94149ecd31d9"}}