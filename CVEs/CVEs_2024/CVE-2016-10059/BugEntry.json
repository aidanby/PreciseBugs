{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/constitute.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/option-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/token.h\"\n#include \"magick/utility.h\"\n#include \"magick/xml-tree.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxBufferExtent  16384\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MaxBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageWarning,(char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,(char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ > JPEGExcessiveWarnings)\n        JPEGErrorHandler(jpeg_info);\n      ThrowBinaryException(CorruptImageWarning,(char *) message,\n        image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) GetStringInfoLength(comment); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  *p='\\0';\n  error_manager->profile=NULL;\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=(ssize_t) GetStringInfoLength(profile)-1; i >= 0; i--)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MaxTextExtent];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    (void) GetCharacter(jpeg_info);\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0;  i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MaxTextExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MaxTextExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MaxTextExtent);\n      if ((length > 5) && (LocaleNCompare((char *) p,\"http:\",5) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile);\n          for (j=0; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MaxTextExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if (previous_profile != (const StringInfo *) NULL)\n    {\n      size_t\n        length;\n\n      length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t) i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image)\n{\n  char\n    sampling_factor[MaxTextExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) &&\n      (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  static const char\n    description[] = \"Joint Photographic Experts Group JFIF format\";\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=SetMagickInfo(\"JPE\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPS\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"PJPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MaxBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MaxBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  ssize_t\n    j;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MaxBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MaxBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MaxBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MaxBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    register unsigned char\n      *p;\n\n    profile=GetImageProfile(image,name);\n    p=GetStringInfoDatum(custom_profile);\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65533L)\n      {\n        length=MagickMin(GetStringInfoLength(profile)-i,65533L);\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile)+i,\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) CopyMagickMemory(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) CopyMagickMemory(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) CopyMagickMemory(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n    if (LocaleCompare(name,\"XMP\") == 0)\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(\"http://ns.adobe.com/xap/1.0/ \");\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[28]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MaxTextExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=(&image->exception);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case GRAYColorspace:\n    case Rec601LumaColorspace:\n    case Rec709LumaColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,&image->exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->x_resolution,image->y_resolution);\n  if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->x_resolution;\n      jpeg_info.Y_density=(UINT16) image->y_resolution;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderWarning,\"LosslessToLossyJPEGConversion\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      jpeg_info=CloneImageInfo(image_info);\n      jpeg_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          jpeg_image->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(jpeg_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            (void) WriteJPEGImage(jpeg_info,jpeg_image);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      jpeg_info=DestroyImageInfo(jpeg_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\");\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if (colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\");\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        case Rec601LumaColorspace:\n        case Rec709LumaColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\");\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(p));\n            p++;\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const PixelPacket\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(\n                GetPixelLuma(image,p)));\n              p++;\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const IndexPacket\n              *indexes;\n\n            register const PixelPacket\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            q=jpeg_pixels;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(indexes+x))));\n              p++;\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const PixelPacket\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n        if (p == (const PixelPacket *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(\n            GetPixelLuma(image,p)))/scale);\n          p++;\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(p))/scale);\n            p++;\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const IndexPacket\n            *indexes;\n\n          register const PixelPacket\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=jpeg_pixels;\n          indexes=GetVirtualIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(p))/\n              scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(p))/\n              scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(p))/\n              scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-\n              GetPixelIndex(indexes+x))/scale);\n            p++;\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/constitute.h\"\n#include \"magick/draw.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resize.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/static.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/thread_.h\"\n#include \"magick/token.h\"\n#include \"magick/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include \"tiffconf.h\"\n# endif\n# include \"tiff.h\"\n# include \"tiffio.h\"\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadSingleSampleMethod,\n  ReadRGBAMethod,\n  ReadCMYKAMethod,\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 0, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n#endif  /* MAGICKCORE_TIFF_DELEGATE */\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *),\n  WritePTIFImage(const ImageInfo *,Image *),\n  WriteTIFFImage(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(size_t) (image->x_resolution+0.5));\n  length=WriteLSBLong(file,1);\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    (void) fputc(c,file);\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MaxTextExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MaxTextExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MaxTextExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MaxTextExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MaxTextExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MaxTextExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic void TIFFGetProfiles(TIFF *tiff,Image *image,MagickBooleanType ping)\n{\n  uint32\n    length;\n\n  unsigned char\n    *profile;\n\n  length=0;\n  if (ping == MagickFalse)\n    {\n#if defined(TIFFTAG_ICCPROFILE)\n      if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"icc\",profile,(ssize_t) length);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n      if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n      if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          (void) ReadProfile(image,\"iptc\",profile,4L*length);\n        }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n      if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length);\n#endif\n      if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length);\n    }\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length);\n}\n\nstatic void TIFFGetProperties(TIFF *tiff,Image *image)\n{\n  char\n    message[MaxTextExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:artist\",text);\n  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:copyright\",text);\n  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:timestamp\",text);\n  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:document\",text);\n  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text);\n  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n    (void) SetImageProperty(image,\"comment\",text);\n  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:make\",text);\n  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:model\",text);\n  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n    {\n      if (count >= MaxTextExtent)\n        count=MaxTextExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n    (void) SetImageProperty(image,\"label\",text);\n  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:software\",text);\n  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n    {\n      if (count >= MaxTextExtent)\n        count=MaxTextExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message);\n    }\n  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n    {\n      if (count >= MaxTextExtent)\n        count=MaxTextExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\");\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\");\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\");\n        break;\n      }\n      default:\n        break;\n    }\n  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n    {\n      (void) FormatLocaleString(message,MaxTextExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message);\n    }\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MaxTextExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  sans=NULL;\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,&sans,&sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MaxTextExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,&sans,&sans) == 1)\n              (void) FormatLocaleString(value,MaxTextExtent,\"%d\",shorty);\n          }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              &sans,&sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MaxTextExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%g\",(double) floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,size_t bits_per_sample,\n  tsample_t sample,ssize_t row,tdata_t scanline)\n{\n  int32\n    status;\n\n  (void) bits_per_sample;\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MaxTextExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MaxTextExtent,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MaxTextExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    **value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /* only support 8 bit for now */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /* Search for Adobe APP14 JPEG Marker */\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value))\n    return(ReadRGBAMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadRGBAMethod);\n  method=ReadRGBAMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  if (IsGrayImage(image,&image->exception) != MagickFalse)\n    info.channels=(image->matte != MagickFalse ? 2UL : 1UL);\n  else\n    if (image->storage_class == PseudoClass)\n      info.channels=(image->matte != MagickFalse ? 2UL : 1UL);\n    else\n      {\n        if (image->colorspace != CMYKColorspace)\n          info.channels=(image->matte != MagickFalse ? 4UL : 3UL);\n        else\n          info.channels=(image->matte != MagickFalse ? 5UL : 4UL);\n      }\n  (void) ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  InheritException(exception,&layers->exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n      Generate blank images for subimage specification (e.g. image.tif[4].\n      We need to check the number of directores because it is possible that\n      the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  do\n  {\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\nRestoreMSCWarning\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      SetImageColorspace(image,GRAYColorspace);\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      SetImageColorspace(image,CMYKColorspace);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      SetImageColorspace(image,LabColorspace);\n    TIFFGetProfiles(tiff,image,image_info->ping);\n    TIFFGetProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      TIFFGetEXIFProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->x_resolution-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->y_resolution-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_YCBCRSUBSAMPLING,\n             &horizontal,&vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n      default: image->compression=RLECompression; break;\n    }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n               (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n          }\n      }\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n        if (image->matte == MagickFalse)\n          image->depth=GetImageDepth(image,exception);\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            {\n              quantum_info=DestroyQuantumInfo(quantum_info);\n              break;\n            }\n        goto next_tiff_frame;\n      }\n    method=ReadGenericMethod;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        method=ReadStripMethod;\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n      }\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))\n      method=ReadRGBAMethod;\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))\n      method=ReadCMYKAMethod;\n    if ((photometric != PHOTOMETRIC_RGB) &&\n        (photometric != PHOTOMETRIC_CIELAB) &&\n        (photometric != PHOTOMETRIC_SEPARATED))\n      method=ReadGenericMethod;\n    if (image->storage_class == PseudoClass)\n      method=ReadSingleSampleMethod;\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      method=ReadSingleSampleMethod;\n    if ((photometric != PHOTOMETRIC_SEPARATED) &&\n        (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (compress_tag == COMPRESSION_JBIG)\n      method=ReadStripMethod;\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      method=ReadTileMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    pixels=GetQuantumPixels(quantum_info);\n    switch (method)\n    {\n      case ReadSingleSampleMethod:\n      {\n        /*\n          Convert TIFF image to PseudoClass MIFF image.\n        */\n        quantum_type=IndexQuantum;\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class != PseudoClass)\n              {\n                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                  GrayAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n            else\n              {\n                quantum_type=IndexAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n          }\n        else\n          if (image->storage_class != PseudoClass)\n            {\n              quantum_type=GrayQuantum;\n              pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n            }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadRGBAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->matte != MagickFalse)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadCMYKAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register PixelPacket\n              *magick_restrict q;\n\n            int\n              status;\n\n            status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)\n              pixels);\n            if (status == -1)\n              break;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (image->colorspace != CMYKColorspace)\n              switch (i)\n              {\n                case 0: quantum_type=RedQuantum; break;\n                case 1: quantum_type=GreenQuantum; break;\n                case 2: quantum_type=BlueQuantum; break;\n                case 3: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            else\n              switch (i)\n              {\n                case 0: quantum_type=CyanQuantum; break;\n                case 1: quantum_type=MagentaQuantum; break;\n                case 2: quantum_type=YellowQuantum; break;\n                case 3: quantum_type=BlackQuantum; break;\n                case 4: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadYCCKMethod:\n      {\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register IndexPacket\n            *indexes;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register uint32\n          *p;\n\n        /*\n          Convert stripped TIFF image to DirectClass MIFF image.\n        */\n        i=0;\n        p=(uint32 *) NULL;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          if (i == 0)\n            {\n              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)\n                break;\n              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)\n                image->rows-y);\n            }\n          i--;\n          p=((uint32 *) pixels)+image->columns*i;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              (TIFFGetR(*p))));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              (TIFFGetG(*p))));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              (TIFFGetB(*p))));\n            if (image->matte != MagickFalse)\n              SetPixelOpacity(q,ScaleCharToQuantum((unsigned char)\n                (TIFFGetA(*p))));\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register uint32\n          *p;\n\n        uint32\n          *tile_pixels,\n          columns,\n          rows;\n\n        size_t\n          number_pixels;\n\n        /*\n          Convert tiled TIFF image to DirectClass MIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(CoderError,\"ImageIsNotTiled\");\n          }\n        (void) SetImageStorageClass(image,DirectClass);\n        number_pixels=columns*rows;\n        tile_pixels=(uint32 *) AcquireQuantumMemory(number_pixels,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (uint32 *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (y=0; y < (ssize_t) image->rows; y+=rows)\n        {\n          PixelPacket\n            *tile;\n\n          register ssize_t\n            x;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          size_t\n            columns_remaining,\n            rows_remaining;\n\n          rows_remaining=image->rows-y;\n          if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n            rows_remaining=rows;\n          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,\n            exception);\n          if (tile == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=columns)\n          {\n            size_t\n              column,\n              row;\n\n            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)\n              break;\n            columns_remaining=image->columns-x;\n            if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n              columns_remaining=columns;\n            p=tile_pixels+(rows-rows_remaining)*columns;\n            q=tile+(image->columns*(rows_remaining-1)+x);\n            for (row=rows_remaining; row > 0; row--)\n            {\n              if (image->matte != MagickFalse)\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)));\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)));\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)));\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetA(*p)));\n                  q++;\n                  p++;\n                }\n              else\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)));\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)));\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)));\n                  q++;\n                  p++;\n                }\n              p+=columns-columns_remaining;\n              q-=(image->columns+columns_remaining);\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *pixel_info;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)\n            (number_pixels*sizeof(uint32))))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n          sizeof(uint32));\n        if (pixel_info == (MemoryInfo *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        p=pixels+number_pixels-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (status != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while (status != MagickFalse);\n  TIFFClose(tiff);\n  TIFFReadPhotoshopLayers(image,image_info,exception);\n  if (image_info->number_scenes != 0)\n  {\n    if (image_info->scene >= GetImageListLength(image))\n    {\n      /* Subimage was not found in the Photoshop layer */\n      image = DestroyImageList(image);\n      return((Image *)NULL);\n    }\n  }\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MaxTextExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=SetMagickInfo(\"GROUP4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->raw=MagickTrue;\n  entry->endian_support=MagickTrue;\n  entry->adjoin=MagickFalse;\n  entry->format_type=ImplicitFormatType;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Raw CCITT Group4\");\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"PTIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Pyramid encoded TIFF\");\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->stealth=MagickTrue;\n  entry->description=ConstantString(TIFFDescription);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(TIFFDescription);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TIFF64\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Tagged Image File Format (64-bit)\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  DestroySemaphoreInfo(&tiff_semaphore);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(&image->exception,FileOpenError,\n        \"UnableToCreateTemporaryFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MaxTextExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType);\n  (void) SetImageDepth(image,1);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      InheritException(&image->exception,&huffman_image->exception);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  exception=(&image->exception);\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\");\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution.x=next->x_resolution;\n    resolution.y=next->y_resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2.0;\n      resolution.y/=2.0;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,image->blur,\n        exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->x_resolution=resolution.x;\n      pyramid_image->y_resolution=resolution.y;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\");\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  /*\n    Write pyramid-encoded TIFF image.\n  */\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  status=WriteTIFFImage(write_info,GetFirstImageInList(images));\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,TIFF *tiff,\n  TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    return(MagickTrue);\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) CopyMagickMemory(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (tiff_info->tile_geometry.height*\n    tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n      \n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n#if !defined(TIFFDefaultStripSize)\n#define TIFFDefaultStripSize(tiff,request)  (8192UL/TIFFScanlineSize(tiff))\n#endif\n\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  uint32\n    rows_per_strip;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,&image->exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType);\n        (void) SetImageDepth(image,1);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass);\n        (void) SetImageDepth(image,8);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            CoderError,\"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,&image->exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass);\n              (void) SetImageDepth(image,8);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorMatteType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,&image->exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) && (image->matte == MagickFalse))\n                  SetImageMonochrome(image,&image->exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->matte != MagickFalse)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    rows_per_strip=TIFFDefaultStripSize(tiff,0);\n    option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n    if (option != (const char *) NULL)\n      rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        rows_per_strip+=(16-(rows_per_strip % 16));\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\");\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n      {\n        rows_per_strip=(uint32) image->rows;\n        break;\n      }\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if (rows_per_strip < 1)\n      rows_per_strip=1;\n    if ((image->rows/rows_per_strip) >= (1UL << 15))\n      rows_per_strip=(uint32) (image->rows >> 15);\n    (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n    if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->x_resolution);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->y_resolution);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            CoderError,\"TIFF: negative image positions unsupported\",\"%s\",\n            image->filename);\n        if ((image->page.x > 0) && (image->x_resolution > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->x_resolution);\n          }\n        if ((image->page.y > 0) && (image->y_resolution > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->y_resolution);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=GetQuantumPixels(quantum_info);\n    tiff_info.scanline=GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->matte != MagickFalse)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,quantum_type,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,RedQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,GreenQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,BlueQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->matte != MagickFalse)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const PixelPacket\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,\n                  &image->exception);\n                if (p == (const PixelPacket *) NULL)\n                  break;\n                (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,&image->exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->matte != MagickFalse)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->matte != MagickFalse)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,&image->exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/constitute.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/option-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/token.h\"\n#include \"magick/utility.h\"\n#include \"magick/xml-tree.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxBufferExtent  16384\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MaxBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageWarning,(char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,(char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ > JPEGExcessiveWarnings)\n        JPEGErrorHandler(jpeg_info);\n      ThrowBinaryException(CorruptImageWarning,(char *) message,\n        image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) GetStringInfoLength(comment); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  *p='\\0';\n  error_manager->profile=NULL;\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=(ssize_t) GetStringInfoLength(profile)-1; i >= 0; i--)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MaxTextExtent];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    (void) GetCharacter(jpeg_info);\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0;  i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MaxTextExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MaxTextExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MaxTextExtent);\n      if ((length > 5) && (LocaleNCompare((char *) p,\"http:\",5) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile);\n          for (j=0; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MaxTextExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if (previous_profile != (const StringInfo *) NULL)\n    {\n      size_t\n        length;\n\n      length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t) i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image)\n{\n  char\n    sampling_factor[MaxTextExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MaxTextExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  static const char\n    description[] = \"Joint Photographic Experts Group JFIF format\";\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=SetMagickInfo(\"JPE\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPS\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"PJPEG\");\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->thread_support=NoThreadSupport;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(description);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  entry->module=ConstantString(\"JPEG\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MaxBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MaxBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  ssize_t\n    j;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MaxBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MaxBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MaxBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MaxBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    register unsigned char\n      *p;\n\n    profile=GetImageProfile(image,name);\n    p=GetStringInfoDatum(custom_profile);\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65533L)\n      {\n        length=MagickMin(GetStringInfoLength(profile)-i,65533L);\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile)+i,\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) CopyMagickMemory(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) CopyMagickMemory(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) CopyMagickMemory(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n    if (LocaleCompare(name,\"XMP\") == 0)\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(\"http://ns.adobe.com/xap/1.0/ \");\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[28]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MaxTextExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=(&image->exception);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case GRAYColorspace:\n    case Rec601LumaColorspace:\n    case Rec709LumaColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,&image->exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->x_resolution,image->y_resolution);\n  if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->x_resolution;\n      jpeg_info.Y_density=(UINT16) image->y_resolution;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderWarning,\"LosslessToLossyJPEGConversion\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      jpeg_info=CloneImageInfo(image_info);\n      jpeg_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          jpeg_image->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(jpeg_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            (void) WriteJPEGImage(jpeg_info,jpeg_image);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      jpeg_info=DestroyImageInfo(jpeg_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\");\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if (colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\");\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",&image->exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        case Rec601LumaColorspace:\n        case Rec709LumaColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\");\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(p));\n            p++;\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const PixelPacket\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(\n                GetPixelLuma(image,p)));\n              p++;\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const IndexPacket\n              *indexes;\n\n            register const PixelPacket\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            q=jpeg_pixels;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(indexes+x))));\n              p++;\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const PixelPacket\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n        if (p == (const PixelPacket *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(\n            GetPixelLuma(image,p)))/scale);\n          p++;\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(p))/scale);\n            p++;\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const IndexPacket\n            *indexes;\n\n          register const PixelPacket\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=jpeg_pixels;\n          indexes=GetVirtualIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(p))/\n              scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(p))/\n              scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(p))/\n              scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-\n              GetPixelIndex(indexes+x))/scale);\n            p++;\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/constitute.h\"\n#include \"magick/draw.h\"\n#include \"magick/enhance.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resize.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/static.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/thread_.h\"\n#include \"magick/token.h\"\n#include \"magick/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include \"tiffconf.h\"\n# endif\n# include \"tiff.h\"\n# include \"tiffio.h\"\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadSingleSampleMethod,\n  ReadRGBAMethod,\n  ReadCMYKAMethod,\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 0, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n#endif  /* MAGICKCORE_TIFF_DELEGATE */\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *),\n  WritePTIFImage(const ImageInfo *,Image *),\n  WriteTIFFImage(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(size_t) (image->x_resolution+0.5));\n  length=WriteLSBLong(file,1);\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    (void) fputc(c,file);\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MaxTextExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MaxTextExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MaxTextExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MaxTextExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MaxTextExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MaxTextExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic void TIFFGetProfiles(TIFF *tiff,Image *image,MagickBooleanType ping)\n{\n  uint32\n    length;\n\n  unsigned char\n    *profile;\n\n  length=0;\n  if (ping == MagickFalse)\n    {\n#if defined(TIFFTAG_ICCPROFILE)\n      if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"icc\",profile,(ssize_t) length);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n      if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n      if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          (void) ReadProfile(image,\"iptc\",profile,4L*length);\n        }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n      if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length);\n#endif\n      if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length);\n    }\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length);\n}\n\nstatic void TIFFGetProperties(TIFF *tiff,Image *image)\n{\n  char\n    message[MaxTextExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:artist\",text);\n  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:copyright\",text);\n  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:timestamp\",text);\n  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:document\",text);\n  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text);\n  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n    (void) SetImageProperty(image,\"comment\",text);\n  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:make\",text);\n  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:model\",text);\n  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n    {\n      if (count >= MaxTextExtent)\n        count=MaxTextExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n    (void) SetImageProperty(image,\"label\",text);\n  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:software\",text);\n  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n    {\n      if (count >= MaxTextExtent)\n        count=MaxTextExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message);\n    }\n  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n    {\n      if (count >= MaxTextExtent)\n        count=MaxTextExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\");\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\");\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\");\n        break;\n      }\n      default:\n        break;\n    }\n  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n    {\n      (void) FormatLocaleString(message,MaxTextExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message);\n    }\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MaxTextExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  sans=NULL;\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,&sans,&sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MaxTextExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,&sans,&sans) == 1)\n              (void) FormatLocaleString(value,MaxTextExtent,\"%d\",shorty);\n          }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              &sans,&sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MaxTextExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%g\",(double) floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MaxTextExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,size_t bits_per_sample,\n  tsample_t sample,ssize_t row,tdata_t scanline)\n{\n  int32\n    status;\n\n  (void) bits_per_sample;\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MaxTextExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MaxTextExtent,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MaxTextExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    **value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /* only support 8 bit for now */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /* Search for Adobe APP14 JPEG Marker */\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value))\n    return(ReadRGBAMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadRGBAMethod);\n  method=ReadRGBAMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  if (IsGrayImage(image,&image->exception) != MagickFalse)\n    info.channels=(image->matte != MagickFalse ? 2UL : 1UL);\n  else\n    if (image->storage_class == PseudoClass)\n      info.channels=(image->matte != MagickFalse ? 2UL : 1UL);\n    else\n      {\n        if (image->colorspace != CMYKColorspace)\n          info.channels=(image->matte != MagickFalse ? 4UL : 3UL);\n        else\n          info.channels=(image->matte != MagickFalse ? 5UL : 4UL);\n      }\n  (void) ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  InheritException(exception,&layers->exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n      Generate blank images for subimage specification (e.g. image.tif[4].\n      We need to check the number of directores because it is possible that\n      the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        }\n    }\n  do\n  {\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\nRestoreMSCWarning\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\");\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\");\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      SetImageColorspace(image,GRAYColorspace);\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      SetImageColorspace(image,CMYKColorspace);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      SetImageColorspace(image,LabColorspace);\n    TIFFGetProfiles(tiff,image,image_info->ping);\n    TIFFGetProperties(tiff,image);\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n      TIFFGetEXIFProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->x_resolution-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->y_resolution-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_YCBCRSUBSAMPLING,\n             &horizontal,&vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\",\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n      default: image->compression=RLECompression; break;\n    }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n               (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\");\n          }\n      }\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n        if (image->matte == MagickFalse)\n          image->depth=GetImageDepth(image,exception);\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            {\n              quantum_info=DestroyQuantumInfo(quantum_info);\n              break;\n            }\n        goto next_tiff_frame;\n      }\n    method=ReadGenericMethod;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        method=ReadStripMethod;\n        (void) FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n      }\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))\n      method=ReadRGBAMethod;\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))\n      method=ReadCMYKAMethod;\n    if ((photometric != PHOTOMETRIC_RGB) &&\n        (photometric != PHOTOMETRIC_CIELAB) &&\n        (photometric != PHOTOMETRIC_SEPARATED))\n      method=ReadGenericMethod;\n    if (image->storage_class == PseudoClass)\n      method=ReadSingleSampleMethod;\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      method=ReadSingleSampleMethod;\n    if ((photometric != PHOTOMETRIC_SEPARATED) &&\n        (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (compress_tag == COMPRESSION_JBIG)\n      method=ReadStripMethod;\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      method=ReadTileMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    pixels=GetQuantumPixels(quantum_info);\n    switch (method)\n    {\n      case ReadSingleSampleMethod:\n      {\n        /*\n          Convert TIFF image to PseudoClass MIFF image.\n        */\n        quantum_type=IndexQuantum;\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class != PseudoClass)\n              {\n                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                  GrayAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n            else\n              {\n                quantum_type=IndexAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n          }\n        else\n          if (image->storage_class != PseudoClass)\n            {\n              quantum_type=GrayQuantum;\n              pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n            }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadRGBAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->matte != MagickFalse)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->matte != MagickFalse)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadCMYKAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register PixelPacket\n              *magick_restrict q;\n\n            int\n              status;\n\n            status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)\n              pixels);\n            if (status == -1)\n              break;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            if (image->colorspace != CMYKColorspace)\n              switch (i)\n              {\n                case 0: quantum_type=RedQuantum; break;\n                case 1: quantum_type=GreenQuantum; break;\n                case 2: quantum_type=BlueQuantum; break;\n                case 3: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            else\n              switch (i)\n              {\n                case 0: quantum_type=CyanQuantum; break;\n                case 1: quantum_type=MagentaQuantum; break;\n                case 2: quantum_type=YellowQuantum; break;\n                case 3: quantum_type=BlackQuantum; break;\n                case 4: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadYCCKMethod:\n      {\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register IndexPacket\n            *indexes;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));\n            q++;\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register uint32\n          *p;\n\n        /*\n          Convert stripped TIFF image to DirectClass MIFF image.\n        */\n        i=0;\n        p=(uint32 *) NULL;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          if (i == 0)\n            {\n              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)\n                break;\n              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)\n                image->rows-y);\n            }\n          i--;\n          p=((uint32 *) pixels)+image->columns*i;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              (TIFFGetR(*p))));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              (TIFFGetG(*p))));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              (TIFFGetB(*p))));\n            if (image->matte != MagickFalse)\n              SetPixelOpacity(q,ScaleCharToQuantum((unsigned char)\n                (TIFFGetA(*p))));\n            p++;\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register uint32\n          *p;\n\n        uint32\n          *tile_pixels,\n          columns,\n          rows;\n\n        /*\n          Convert tiled TIFF image to DirectClass MIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(CoderError,\"ImageIsNotTiled\");\n          }\n        (void) SetImageStorageClass(image,DirectClass);\n        number_pixels=(MagickSizeType) columns*rows;\n        if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)\n            (number_pixels*sizeof(uint32))))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        tile_pixels=(uint32 *) AcquireQuantumMemory(number_pixels,\n          sizeof(*tile_pixels));\n        if (tile_pixels == (uint32 *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (y=0; y < (ssize_t) image->rows; y+=rows)\n        {\n          PixelPacket\n            *tile;\n\n          register ssize_t\n            x;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          size_t\n            columns_remaining,\n            rows_remaining;\n\n          rows_remaining=image->rows-y;\n          if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n            rows_remaining=rows;\n          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,\n            exception);\n          if (tile == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=columns)\n          {\n            size_t\n              column,\n              row;\n\n            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)\n              break;\n            columns_remaining=image->columns-x;\n            if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n              columns_remaining=columns;\n            p=tile_pixels+(rows-rows_remaining)*columns;\n            q=tile+(image->columns*(rows_remaining-1)+x);\n            for (row=rows_remaining; row > 0; row--)\n            {\n              if (image->matte != MagickFalse)\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)));\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)));\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)));\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetA(*p)));\n                  q++;\n                  p++;\n                }\n              else\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)));\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)));\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)));\n                  q++;\n                  p++;\n                }\n              p+=columns-columns_remaining;\n              q-=(image->columns+columns_remaining);\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *pixel_info;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        if ((number_pixels*sizeof(uint32)) != (MagickSizeType) ((size_t)\n            (number_pixels*sizeof(uint32))))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n          sizeof(uint32));\n        if (pixel_info == (MemoryInfo *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        p=pixels+number_pixels-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register PixelPacket\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (status != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while (status != MagickFalse);\n  TIFFClose(tiff);\n  TIFFReadPhotoshopLayers(image,image_info,exception);\n  if (image_info->number_scenes != 0)\n  {\n    if (image_info->scene >= GetImageListLength(image))\n    {\n      /* Subimage was not found in the Photoshop layer */\n      image = DestroyImageList(image);\n      return((Image *)NULL);\n    }\n  }\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MaxTextExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=SetMagickInfo(\"GROUP4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->raw=MagickTrue;\n  entry->endian_support=MagickTrue;\n  entry->adjoin=MagickFalse;\n  entry->format_type=ImplicitFormatType;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Raw CCITT Group4\");\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"PTIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Pyramid encoded TIFF\");\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TIF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->stealth=MagickTrue;\n  entry->description=ConstantString(TIFFDescription);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(TIFFDescription);\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TIFF64\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->adjoin=MagickFalse;\n  entry->endian_support=MagickTrue;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Tagged Image File Format (64-bit)\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  entry->module=ConstantString(\"TIFF\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  DestroySemaphoreInfo(&tiff_semaphore);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(&image->exception,FileOpenError,\n        \"UnableToCreateTemporaryFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MaxTextExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType);\n  (void) SetImageDepth(image,1);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      InheritException(&image->exception,&huffman_image->exception);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  exception=(&image->exception);\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\");\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution.x=next->x_resolution;\n    resolution.y=next->y_resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2.0;\n      resolution.y/=2.0;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,image->blur,\n        exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->x_resolution=resolution.x;\n      pyramid_image->y_resolution=resolution.y;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\");\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  /*\n    Write pyramid-encoded TIFF image.\n  */\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  status=WriteTIFFImage(write_info,GetFirstImageInList(images));\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,TIFF *tiff,\n  TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    return(MagickTrue);\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) CopyMagickMemory(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (tiff_info->tile_geometry.height*\n    tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n      \n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n#if !defined(TIFFDefaultStripSize)\n#define TIFFDefaultStripSize(tiff,request)  (8192UL/TIFFScanlineSize(tiff))\n#endif\n\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  uint32\n    rows_per_strip;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,&image->exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType);\n        (void) SetImageDepth(image,1);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass);\n        (void) SetImageDepth(image,8);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            CoderError,\"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,&image->exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass);\n              (void) SetImageDepth(image,8);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorMatteType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,&image->exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) && (image->matte == MagickFalse))\n                  SetImageMonochrome(image,&image->exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->matte != MagickFalse)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    rows_per_strip=TIFFDefaultStripSize(tiff,0);\n    option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n    if (option != (const char *) NULL)\n      rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        rows_per_strip+=(16-(rows_per_strip % 16));\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\");\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n      {\n        rows_per_strip=(uint32) image->rows;\n        break;\n      }\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if (rows_per_strip < 1)\n      rows_per_strip=1;\n    if ((image->rows/rows_per_strip) >= (1UL << 15))\n      rows_per_strip=(uint32) (image->rows >> 15);\n    (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n    if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->x_resolution);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->y_resolution);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            CoderError,\"TIFF: negative image positions unsupported\",\"%s\",\n            image->filename);\n        if ((image->page.x > 0) && (image->x_resolution > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->x_resolution);\n          }\n        if ((image->page.y > 0) && (image->y_resolution > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->y_resolution);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=GetQuantumPixels(quantum_info);\n    tiff_info.scanline=GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->matte != MagickFalse)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,quantum_type,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,RedQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,GreenQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,BlueQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->matte != MagickFalse)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const PixelPacket\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,\n                  &image->exception);\n                if (p == (const PixelPacket *) NULL)\n                  break;\n                (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,&image->exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->matte != MagickFalse)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->matte != MagickFalse)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,&image->exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n#endif\n"], "filenames": ["coders/jpeg.c", "coders/tiff.c"], "buggy_code_start_loc": [1238, 1897], "buggy_code_end_loc": [1240, 1911], "fixing_code_start_loc": [1238, 1896], "fixing_code_end_loc": [1239, 1914], "type": "CWE-119", "message": "Buffer overflow in coders/tiff.c in ImageMagick before 6.9.4-1 allows remote attackers to cause a denial of service (application crash) or have unspecified other impact via a crafted TIFF file.", "other": {"cve": {"id": "CVE-2016-10059", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T17:59:00.797", "lastModified": "2017-03-25T01:59:00.767", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in coders/tiff.c in ImageMagick before 6.9.4-1 allows remote attackers to cause a denial of service (application crash) or have unspecified other impact via a crafted TIFF file."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en coders/tiff.c en ImageMagick en versiones anteriores a 6.9.4-1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) u otro impacto no especificado a trav\u00e9s de un archivo TIFF manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.4-0", "matchCriteriaId": "334644D6-86C2-4AF8-A211-2B247F78C788"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00028.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95206", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410469", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/58cf5bf4fade82e3b510e8f3463a967278a3e410", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/58cf5bf4fade82e3b510e8f3463a967278a3e410"}}