{"buggy_code": ["/*\n * Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"../virtual/virtual_stream_encoder.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce110/dce110_timing_generator.h\"\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce100/dce100_hw_sequencer.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_10_0_d.h\"\n#include \"dce/dce_10_0_sh_mask.h\"\n\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_i2c.h\"\n\n#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT\n#include \"gmc/gmc_8_2_d.h\"\n#include \"gmc/gmc_8_2_sh_mask.h\"\n#endif\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\nstatic const struct dce110_timing_generator_offsets dce100_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE100_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE100(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE100_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST_DCE_BASE(id),\\\n\t.AFMT_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5),\n\tstream_enc_regs(6)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_100_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_100(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_100(_MASK)\n};\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(id)\\\n[id] = {\\\n\tCS_COMMON_REG_LIST_DCE_100_110(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0),\n\tclk_src_regs(1),\n\tclk_src_regs(2)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define DCFE_MEM_PWR_CTRL_REG_BASE 0x1b03\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps res_cap = {\n\t.num_timing_generator = 6,\n\t.num_audio = 6,\n\t.num_stream_encoder = 6,\n\t.num_pll = 3,\n\t.num_ddc = 6,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x1918\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct timing_generator *dce100_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce100_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id], &se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE10_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE10_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE10_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce100_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce100_stream_encoder_create,\n\t.create_hwseq = dce100_hwseq_create,\n};\n\n#define mi_inst_regs(id) { \\\n\tMI_DCE8_REG_LIST(id), \\\n\t.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \\\n}\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE8_MASK_SH_LIST(__SHIFT),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE8_MASK_SH_LIST(_MASK),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK\n};\n\nstatic struct mem_input *dce100_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\tdce_mi->wa.single_head_rdreq_dmif_limit = 2;\n\treturn &dce_mi->base;\n}\n\nstatic void dce100_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce100_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\treturn &transform->base;\n}\n\nstatic struct input_pixel_processor *dce100_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 300000,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true\n};\n\nstruct link_encoder *dce100_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstruct output_pixel_processor *dce100_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce100_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstruct dce_i2c_hw *dce100_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce100_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce100_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce100_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL)\n\t\t\tdce100_clock_source_destroy(&pool->base.clock_sources[i]);\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce100_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL)\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\t\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL)\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc  *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nbool dce100_validate_bandwidth(\n\tstruct dc  *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tint i;\n\tbool at_least_one_pipe = false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].stream)\n\t\t\tat_least_one_pipe = true;\n\t}\n\n\tif (at_least_one_pipe) {\n\t\t/* TODO implement when needed but for now hardcode max value*/\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 681000;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;\n\t} else {\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 0;\n\t}\n\n\treturn true;\n}\n\nstatic bool dce100_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce100_validate_global(\n\t\tstruct dc  *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce100_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nenum dc_status dce100_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_clock_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic void dce100_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nenum dc_status dce100_validate_plane(const struct dc_plane_state *plane_state, struct dc_caps *caps)\n{\n\n\tif (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\treturn DC_OK;\n\n\treturn DC_FAIL_SURFACE_VALIDATE;\n}\n\nstruct stream_encoder *dce100_find_first_free_match_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tint j = -1;\n\tstruct dc_link *link = stream->link;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (!res_ctx->is_stream_enc_acquired[i] &&\n\t\t\t\tpool->stream_enc[i]) {\n\t\t\t/* Store first available for MST second display\n\t\t\t * in daisy chain use case\n\t\t\t */\n\t\t\tj = i;\n\t\t\tif (pool->stream_enc[i]->id ==\n\t\t\t\t\tlink->link_enc->preferred_engine)\n\t\t\t\treturn pool->stream_enc[i];\n\t\t}\n\t}\n\n\t/*\n\t * below can happen in cases when stream encoder is acquired:\n\t * 1) for second MST display in chain, so preferred engine already\n\t * acquired;\n\t * 2) for another link, which preferred engine already acquired by any\n\t * MST configuration.\n\t *\n\t * If signal is of DP type and preferred engine not found, return last available\n\t *\n\t * TODO - This is just a patch up and a generic solution is\n\t * required for non DP connectors.\n\t */\n\n\tif (j >= 0 && link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT)\n\t\treturn pool->stream_enc[j];\n\n\treturn NULL;\n}\n\nstatic const struct resource_funcs dce100_res_pool_funcs = {\n\t.destroy = dce100_destroy_resource_pool,\n\t.link_enc_create = dce100_link_encoder_create,\n\t.validate_bandwidth = dce100_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce100_add_stream_to_ctx,\n\t.validate_global = dce100_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce100_find_first_free_match_stream_enc_for_link\n};\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dce100_res_pool_funcs;\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[2] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 3;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 2;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t\t&abm_regs,\n\t\t\t\t&abm_shift,\n\t\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\t/*************************************************\n\t*  Resource + asic cap harcoding                *\n\t*************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap.num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\tdc->caps.disable_dp_clk_share = true;\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] =\n\t\t\tdce100_timing_generator_create(\n\t\t\t\tctx,\n\t\t\t\ti,\n\t\t\t\t&dce100_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce100_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce100_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce100_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce100_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce100_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce100_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce100_hw_sequencer_construct(dc);\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\n", "/*\n * Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce110/dce110_timing_generator.h\"\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce110/dce110_timing_generator_v.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce110/dce110_mem_input_v.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce110/dce110_transform_v.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce110/dce110_opp_v.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_i2c.h\"\n\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n#include \"dce110/dce110_compressor.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n\n#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT\n#include \"gmc/gmc_8_2_d.h\"\n#include \"gmc/gmc_8_2_sh_mask.h\"\n#endif\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\n#ifndef DPHY_RX_FAST_TRAINING_CAPABLE\n\t#define DPHY_RX_FAST_TRAINING_CAPABLE 0x1\n#endif\n\nstatic const struct dce110_timing_generator_offsets dce110_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE110_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_110_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_110(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_110(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n/* AG TBD Needs to be reduced back to 3 pipes once dce10 hw sequencer implemented. */\n\n\n#define clk_src_regs(id)\\\n[id] = {\\\n\tCS_COMMON_REG_LIST_DCE_100_110(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0),\n\tclk_src_regs(1),\n\tclk_src_regs(2)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps carrizo_resource_cap = {\n\t\t.num_timing_generator = 3,\n\t\t.num_video_plane = 1,\n\t\t.num_audio = 3,\n\t\t.num_stream_encoder = 3,\n\t\t.num_pll = 2,\n\t\t.num_ddc = 3,\n};\n\nstatic const struct resource_caps stoney_resource_cap = {\n\t\t.num_timing_generator = 2,\n\t\t.num_video_plane = 1,\n\t\t.num_audio = 3,\n\t\t.num_stream_encoder = 3,\n\t\t.num_pll = 2,\n\t\t.num_ddc = 3,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t\t.type = DC_PLANE_TYPE_DCE_RGB,\n\t\t.blends_with_below = true,\n\t\t.blends_with_above = true,\n\t\t.per_pixel_alpha = 1,\n\n\t\t.pixel_format_support = {\n\t\t\t\t.argb8888 = true,\n\t\t\t\t.nv12 = false,\n\t\t\t\t.fp16 = false\n\t\t},\n\n\t\t.max_upscale_factor = {\n\t\t\t\t.argb8888 = 16000,\n\t\t\t\t.nv12 = 1,\n\t\t\t\t.fp16 = 1\n\t\t},\n\n\t\t.max_downscale_factor = {\n\t\t\t\t.argb8888 = 250,\n\t\t\t\t.nv12 = 1,\n\t\t\t\t.fp16 = 1\n\t\t}\n};\n\nstatic const struct dc_plane_cap underlay_plane_cap = {\n\t\t.type = DC_PLANE_TYPE_DCE_UNDERLAY,\n\t\t.blends_with_above = true,\n\t\t.per_pixel_alpha = 1,\n\n\t\t.pixel_format_support = {\n\t\t\t\t.argb8888 = false,\n\t\t\t\t.nv12 = true,\n\t\t\t\t.fp16 = false\n\t\t},\n\n\t\t.max_upscale_factor = {\n\t\t\t\t.argb8888 = 1,\n\t\t\t\t.nv12 = 16000,\n\t\t\t\t.fp16 = 1\n\t\t},\n\n\t\t.max_downscale_factor = {\n\t\t\t\t.argb8888 = 1,\n\t\t\t\t.nv12 = 250,\n\t\t\t\t.fp16 = 1\n\t\t}\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x4819\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct timing_generator *dce110_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce110_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_stoney_reg = {\n\t\tHWSEQ_ST_REG_LIST()\n};\n\nstatic const struct dce_hwseq_registers hwseq_cz_reg = {\n\t\tHWSEQ_CZ_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE11_MASK_SH_LIST(__SHIFT),\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE11_MASK_SH_LIST(_MASK),\n};\n\nstatic struct dce_hwseq *dce110_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = ASIC_REV_IS_STONEY(ctx->asic_id.hw_internal_rev) ?\n\t\t\t\t&hwseq_stoney_reg : &hwseq_cz_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t\thws->wa.blnd_crtc_trigger = true;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce110_stream_encoder_create,\n\t.create_hwseq = dce110_hwseq_create,\n};\n\n#define mi_inst_regs(id) { \\\n\tMI_DCE11_REG_LIST(id), \\\n\t.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \\\n}\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE11_MASK_SH_LIST(__SHIFT),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE11_MASK_SH_LIST(_MASK),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK\n};\n\n\nstatic struct mem_input *dce110_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\tdce_mi->wa.single_head_rdreq_dmif_limit = 3;\n\treturn &dce_mi->base;\n}\n\nstatic void dce110_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce110_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\treturn &transform->base;\n}\n\nstatic struct input_pixel_processor *dce110_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 300000,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true\n};\n\nstatic struct link_encoder *dce110_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstatic struct output_pixel_processor *dce110_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce110_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dce110_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce100_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce110_clock_source_destroy(struct clock_source **clk_src)\n{\n\tstruct dce110_clk_src *dce110_clk_src;\n\n\tif (!clk_src)\n\t\treturn;\n\n\tdce110_clk_src = TO_DCE110_CLK_SRC(*clk_src);\n\n\tkfree(dce110_clk_src->dp_ss_params);\n\tkfree(dce110_clk_src->hdmi_ss_params);\n\tkfree(dce110_clk_src->dvi_ss_params);\n\n\tkfree(dce110_clk_src);\n\t*clk_src = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce110_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce110_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce110_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\n\nstatic void get_pixel_clock_parameters(\n\tconst struct pipe_ctx *pipe_ctx,\n\tstruct pixel_clk_params *pixel_clk_params)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\n\t/*TODO: is this halved for YCbCr 420? in that case we might want to move\n\t * the pixel clock normalization for hdmi up to here instead of doing it\n\t * in pll_adjust_pix_clk\n\t */\n\tpixel_clk_params->requested_pix_clk_100hz = stream->timing.pix_clk_100hz;\n\tpixel_clk_params->encoder_object_id = stream->link->link_enc->id;\n\tpixel_clk_params->signal_type = pipe_ctx->stream->signal;\n\tpixel_clk_params->controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\t/* TODO: un-hardcode*/\n\tpixel_clk_params->requested_sym_clk = LINK_RATE_LOW *\n\t\t\t\t\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\tpixel_clk_params->flags.ENABLE_SS = 0;\n\tpixel_clk_params->color_depth =\n\t\tstream->timing.display_color_depth;\n\tpixel_clk_params->flags.DISPLAY_BLANKED = 1;\n\tpixel_clk_params->flags.SUPPORT_YCBCR420 = (stream->timing.pixel_encoding ==\n\t\t\tPIXEL_ENCODING_YCBCR420);\n\tpixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422) {\n\t\tpixel_clk_params->color_depth = COLOR_DEPTH_888;\n\t}\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420) {\n\t\tpixel_clk_params->requested_pix_clk_100hz  = pixel_clk_params->requested_pix_clk_100hz / 2;\n\t}\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tpixel_clk_params->requested_pix_clk_100hz *= 2;\n\n}\n\nvoid dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx)\n{\n\tget_pixel_clock_parameters(pipe_ctx, &pipe_ctx->stream_res.pix_clk_params);\n\tpipe_ctx->clock_source->funcs->get_pix_clk_dividers(\n\t\tpipe_ctx->clock_source,\n\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t&pipe_ctx->pll_settings);\n\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t&pipe_ctx->stream->bit_depth_params);\n\tpipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;\n}\n\nstatic bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigned int underlay_idx)\n{\n\tif (pipe_ctx->pipe_idx != underlay_idx)\n\t\treturn true;\n\tif (!pipe_ctx->plane_state)\n\t\treturn false;\n\tif (pipe_ctx->plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\treturn false;\n\treturn true;\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (!is_surface_pixel_format_supported(pipe_ctx,\n\t\t\tdc->res_pool->underlay_pipe_index))\n\t\treturn DC_SURFACE_PIXEL_FORMAT_UNSUPPORTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\t/* TODO: validate audio ASIC caps, encoder */\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nstatic bool dce110_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tbool result = false;\n\n\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\"%s: start\",\n\t\t__func__);\n\n\tif (bw_calcs(\n\t\t\tdc->ctx,\n\t\t\tdc->bw_dceip,\n\t\t\tdc->bw_vbios,\n\t\t\tcontext->res_ctx.pipe_ctx,\n\t\t\tdc->res_pool->pipe_count,\n\t\t\t&context->bw_ctx.bw.dce))\n\t\tresult =  true;\n\n\tif (!result)\n\t\tDC_LOG_BANDWIDTH_VALIDATION(\"%s: %dx%d@%d Bandwidth validation failed!\\n\",\n\t\t\t__func__,\n\t\t\tcontext->streams[0]->timing.h_addressable,\n\t\t\tcontext->streams[0]->timing.v_addressable,\n\t\t\tcontext->streams[0]->timing.pix_clk_100hz / 10);\n\n\tif (memcmp(&dc->current_state->bw_ctx.bw.dce,\n\t\t\t&context->bw_ctx.bw.dce, sizeof(context->bw_ctx.bw.dce))) {\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\t\"%s: finish,\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d stutter_mode_enable: %d\\n\"\n\t\t\t\"cstate: %d pstate: %d nbpstate: %d sync: %d dispclk: %d\\n\"\n\t\t\t\"sclk: %d sclk_sleep: %d yclk: %d blackout_recovery_time_us: %d\\n\"\n\t\t\t,\n\t\t\t__func__,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_mode_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync,\n\t\t\tcontext->bw_ctx.bw.dce.dispclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_deep_sleep_khz,\n\t\t\tcontext->bw_ctx.bw.dce.yclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us);\n\t}\n\treturn result;\n}\n\nenum dc_status dce110_validate_plane(const struct dc_plane_state *plane_state,\n\t\t\t\t     struct dc_caps *caps)\n{\n\tif (((plane_state->dst_rect.width * 2) < plane_state->src_rect.width) ||\n\t    ((plane_state->dst_rect.height * 2) < plane_state->src_rect.height))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic bool dce110_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i, j;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 2)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < context->stream_status[i].plane_count; j++) {\n\t\t\tstruct dc_plane_state *plane =\n\t\t\t\tcontext->stream_status[i].plane_states[j];\n\n\t\t\t/* underlay validation */\n\t\t\tif (plane->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\n\t\t\t\tif ((plane->src_rect.width > 1920 ||\n\t\t\t\t\tplane->src_rect.height > 1080))\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* we don't have the logic to support underlay\n\t\t\t\t * only yet so block the use case where we get\n\t\t\t\t * NV12 plane as top layer\n\t\t\t\t */\n\t\t\t\tif (j == 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* irrespective of plane format,\n\t\t\t\t * stream should be RGB encoded\n\t\t\t\t */\n\t\t\t\tif (context->streams[i]->timing.pixel_encoding\n\t\t\t\t\t\t!= PIXEL_ENCODING_RGB)\n\t\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce110_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce110_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status dce110_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic struct pipe_ctx *dce110_acquire_underlay(\n\t\tstruct dc_state *context,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct dc *dc = stream->ctx->dc;\n\tstruct resource_context *res_ctx = &context->res_ctx;\n\tunsigned int underlay_idx = pool->underlay_pipe_index;\n\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];\n\n\tif (res_ctx->pipe_ctx[underlay_idx].stream)\n\t\treturn NULL;\n\n\tpipe_ctx->stream_res.tg = pool->timing_generators[underlay_idx];\n\tpipe_ctx->plane_res.mi = pool->mis[underlay_idx];\n\t/*pipe_ctx->plane_res.ipp = res_ctx->pool->ipps[underlay_idx];*/\n\tpipe_ctx->plane_res.xfm = pool->transforms[underlay_idx];\n\tpipe_ctx->stream_res.opp = pool->opps[underlay_idx];\n\tpipe_ctx->pipe_idx = underlay_idx;\n\n\tpipe_ctx->stream = stream;\n\n\tif (!dc->current_state->res_ctx.pipe_ctx[underlay_idx].stream) {\n\t\tstruct tg_color black_color = {0};\n\t\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\n\t\tdc->hwss.enable_display_power_gating(\n\t\t\t\tdc,\n\t\t\t\tpipe_ctx->stream_res.tg->inst,\n\t\t\t\tdcb, PIPE_GATING_CONTROL_DISABLE);\n\n\t\t/*\n\t\t * This is for powering on underlay, so crtc does not\n\t\t * need to be enabled\n\t\t */\n\n\t\tpipe_ctx->stream_res.tg->funcs->program_timing(pipe_ctx->stream_res.tg,\n\t\t\t\t&stream->timing,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\tfalse);\n\n\t\tpipe_ctx->stream_res.tg->funcs->enable_advanced_request(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\ttrue,\n\t\t\t\t&stream->timing);\n\n\t\tpipe_ctx->plane_res.mi->funcs->allocate_mem_input(pipe_ctx->plane_res.mi,\n\t\t\t\tstream->timing.h_total,\n\t\t\t\tstream->timing.v_total,\n\t\t\t\tstream->timing.pix_clk_100hz / 10,\n\t\t\t\tcontext->stream_count);\n\n\t\tcolor_space_to_black_color(dc,\n\t\t\t\tCOLOR_SPACE_YCBCR601, &black_color);\n\t\tpipe_ctx->stream_res.tg->funcs->set_blank_color(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t&black_color);\n\t}\n\n\treturn pipe_ctx;\n}\n\nstatic void dce110_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstruct stream_encoder *dce110_find_first_free_match_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tint j = -1;\n\tstruct dc_link *link = stream->link;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (!res_ctx->is_stream_enc_acquired[i] &&\n\t\t\t\tpool->stream_enc[i]) {\n\t\t\t/* Store first available for MST second display\n\t\t\t * in daisy chain use case\n\t\t\t */\n\t\t\tj = i;\n\t\t\tif (pool->stream_enc[i]->id ==\n\t\t\t\t\tlink->link_enc->preferred_engine)\n\t\t\t\treturn pool->stream_enc[i];\n\t\t}\n\t}\n\n\t/*\n\t * For CZ and later, we can allow DIG FE and BE to differ for all display types\n\t */\n\n\tif (j >= 0)\n\t\treturn pool->stream_enc[j];\n\n\treturn NULL;\n}\n\n\nstatic const struct resource_funcs dce110_res_pool_funcs = {\n\t.destroy = dce110_destroy_resource_pool,\n\t.link_enc_create = dce110_link_encoder_create,\n\t.validate_bandwidth = dce110_validate_bandwidth,\n\t.validate_plane = dce110_validate_plane,\n\t.acquire_idle_pipe_for_layer = dce110_acquire_underlay,\n\t.add_stream_to_ctx = dce110_add_stream_to_ctx,\n\t.validate_global = dce110_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic bool underlay_create(struct dc_context *ctx, struct resource_pool *pool)\n{\n\tstruct dce110_timing_generator *dce110_tgv = kzalloc(sizeof(*dce110_tgv),\n\t\t\t\t\t\t\t     GFP_KERNEL);\n\tstruct dce_transform *dce110_xfmv = kzalloc(sizeof(*dce110_xfmv),\n\t\t\t\t\t\t    GFP_KERNEL);\n\tstruct dce_mem_input *dce110_miv = kzalloc(sizeof(*dce110_miv),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tstruct dce110_opp *dce110_oppv = kzalloc(sizeof(*dce110_oppv),\n\t\t\t\t\t\t GFP_KERNEL);\n\n\tif (!dce110_tgv || !dce110_xfmv || !dce110_miv || !dce110_oppv) {\n\t\tkfree(dce110_tgv);\n\t\tkfree(dce110_xfmv);\n\t\tkfree(dce110_miv);\n\t\tkfree(dce110_oppv);\n\t\treturn false;\n\t}\n\n\tdce110_opp_v_construct(dce110_oppv, ctx);\n\n\tdce110_timing_generator_v_construct(dce110_tgv, ctx);\n\tdce110_mem_input_v_construct(dce110_miv, ctx);\n\tdce110_transform_v_construct(dce110_xfmv, ctx);\n\n\tpool->opps[pool->pipe_count] = &dce110_oppv->base;\n\tpool->timing_generators[pool->pipe_count] = &dce110_tgv->base;\n\tpool->mis[pool->pipe_count] = &dce110_miv->base;\n\tpool->transforms[pool->pipe_count] = &dce110_xfmv->base;\n\tpool->pipe_count++;\n\n\t/* update the public caps to indicate an underlay is available */\n\tctx->dc->caps.max_slave_planes = 1;\n\tctx->dc->caps.max_slave_planes = 1;\n\n\treturn true;\n}\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels clks = {0};\n\n\t/*do system clock*/\n\tdm_pp_get_clock_levels_by_type(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t&clks);\n\t/* convert all the clock fro kHz to fix point mHz */\n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels/8], 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*2/8], 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*3/8], 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*4/8], 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*5/8], 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*6/8], 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0], 1000);\n\tdc->sclk_lvls = clks;\n\n\t/*do display clock*/\n\tdm_pp_get_clock_levels_by_type(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_DISPLAY_CLK,\n\t\t\t&clks);\n\tdc->bw_vbios->high_voltage_max_dispclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\tdc->bw_vbios->mid_voltage_max_dispclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels>>1], 1000);\n\tdc->bw_vbios->low_voltage_max_dispclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0], 1000);\n\n\t/*do memory clock*/\n\tdm_pp_get_clock_levels_by_type(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&clks);\n\n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tclks.clocks_in_khz[0] * MEMORY_TYPE_MULTIPLIER_CZ, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tclks.clocks_in_khz[clks.num_levels>>1] * MEMORY_TYPE_MULTIPLIER_CZ,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tclks.clocks_in_khz[clks.num_levels-1] * MEMORY_TYPE_MULTIPLIER_CZ,\n\t\t1000);\n}\n\nconst struct resource_caps *dce110_resource_cap(\n\tstruct hw_asic_id *asic_id)\n{\n\tif (ASIC_REV_IS_STONEY(asic_id->hw_internal_rev))\n\t\treturn &stoney_resource_cap;\n\telse\n\t\treturn &carrizo_resource_cap;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool,\n\tstruct hw_asic_id asic_id)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = dce110_resource_cap(&ctx->asic_id);\n\tpool->base.funcs = &dce110_res_pool_funcs;\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.underlay_pipe_index = pool->base.pipe_count;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 150;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.is_apu = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0,\n\t\t\t\t\t\t&clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1,\n\t\t\t\t\t\t&clk_src_regs[1], false);\n\n\t\tpool->base.clk_src_count = 2;\n\n\t\t/* TODO: find out if CZ support 3 PLLs */\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce110_timing_generator_create(\n\t\t\t\tctx, i, &dce110_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce110_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce110_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce110_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce110_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce110_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce110_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tif (dc->config.fbc_support)\n\t\tdc->fbc_compressor = dce110_compressor_create(ctx);\n\n\tif (!underlay_create(ctx, &pool->base))\n\t\tgoto res_create_fail;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce110_hw_sequencer_construct(dc);\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < pool->base.underlay_pipe_index; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.planes[pool->base.underlay_pipe_index] = underlay_plane_cap;\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce110/dce110_timing_generator.h\"\n\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_clock_source.h\"\n\n#include \"dce/dce_hwseq.h\"\n#include \"dce112/dce112_hw_sequencer.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_11_2_d.h\"\n#include \"dce/dce_11_2_sh_mask.h\"\n\n#include \"dce100/dce100_resource.h\"\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\nenum dce112_clk_src_array_id {\n\tDCE112_CLK_SRC_PLL0,\n\tDCE112_CLK_SRC_PLL1,\n\tDCE112_CLK_SRC_PLL2,\n\tDCE112_CLK_SRC_PLL3,\n\tDCE112_CLK_SRC_PLL4,\n\tDCE112_CLK_SRC_PLL5,\n\n\tDCE112_CLK_SRC_TOTAL\n};\n\nstatic const struct dce110_timing_generator_offsets dce112_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE110_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE112(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE112(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_112_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5)\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(index, id)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCE_112(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps polaris_10_resource_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 8, /* why 8? 6 combo PHY PLL + 2 regular PLLs? */\n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps polaris_11_resource_cap = {\n\t\t.num_timing_generator = 5,\n\t\t.num_audio = 5,\n\t\t.num_stream_encoder = 5,\n\t\t.num_pll = 8, /* why 8? 6 combo PHY PLL + 2 regular PLLs? */\n\t\t.num_ddc = 5,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x4819\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\n\nstatic struct timing_generator *dce112_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce112_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE112_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE112_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE112_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce112_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce112_stream_encoder_create,\n\t.create_hwseq = dce112_hwseq_create,\n};\n\n#define mi_inst_regs(id) { MI_DCE11_2_REG_LIST(id) }\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE11_2_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE11_2_MASK_SH_LIST(_MASK)\n};\n\nstatic struct mem_input *dce112_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce112_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\treturn &dce_mi->base;\n}\n\nstatic void dce112_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce112_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->lb_memory_size = 0x1404; /*5124*/\n\treturn &transform->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstruct link_encoder *dce112_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstatic struct input_pixel_processor *dce112_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstruct output_pixel_processor *dce112_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce112_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dce112_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce112_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce112_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce112_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL) {\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce112_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce112_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\nstatic struct clock_source *find_matching_pll(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tconst struct dc_stream_state *const stream)\n{\n\tswitch (stream->link->link_enc->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL0];\n\tcase TRANSMITTER_UNIPHY_B:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL1];\n\tcase TRANSMITTER_UNIPHY_C:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL2];\n\tcase TRANSMITTER_UNIPHY_D:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL3];\n\tcase TRANSMITTER_UNIPHY_E:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL4];\n\tcase TRANSMITTER_UNIPHY_F:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL5];\n\tdefault:\n\t\treturn NULL;\n\t};\n\n\treturn 0;\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nbool dce112_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tbool result = false;\n\n\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\"%s: start\",\n\t\t__func__);\n\n\tif (bw_calcs(\n\t\t\tdc->ctx,\n\t\t\tdc->bw_dceip,\n\t\t\tdc->bw_vbios,\n\t\t\tcontext->res_ctx.pipe_ctx,\n\t\t\tdc->res_pool->pipe_count,\n\t\t\t&context->bw_ctx.bw.dce))\n\t\tresult = true;\n\n\tif (!result)\n\t\tDC_LOG_BANDWIDTH_VALIDATION(\n\t\t\t\"%s: Bandwidth validation failed!\",\n\t\t\t__func__);\n\n\tif (memcmp(&dc->current_state->bw_ctx.bw.dce,\n\t\t\t&context->bw_ctx.bw.dce, sizeof(context->bw_ctx.bw.dce))) {\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\t\"%s: finish,\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d stutter_mode_enable: %d\\n\"\n\t\t\t\"cstate: %d pstate: %d nbpstate: %d sync: %d dispclk: %d\\n\"\n\t\t\t\"sclk: %d sclk_sleep: %d yclk: %d blackout_recovery_time_us: %d\\n\"\n\t\t\t,\n\t\t\t__func__,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_mode_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync,\n\t\t\tcontext->bw_ctx.bw.dce.dispclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_deep_sleep_khz,\n\t\t\tcontext->bw_ctx.bw.dce.yclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us);\n\t}\n\treturn result;\n}\n\nenum dc_status resource_map_phy_clock_resources(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\n\t/* acquire new resources */\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(\n\t\t\t&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)\n\t\t|| dc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->clock_source =\n\t\t\t\tdc->res_pool->dp_clock_source;\n\telse\n\t\tpipe_ctx->clock_source = find_matching_pll(\n\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\tstream);\n\n\tif (pipe_ctx->clock_source == NULL)\n\t\treturn DC_NO_CLOCK_SOURCE_RESOURCE;\n\n\tresource_reference_clock_source(\n\t\t&context->res_ctx,\n\t\tdc->res_pool,\n\t\tpipe_ctx->clock_source);\n\n\treturn DC_OK;\n}\n\nstatic bool dce112_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce112_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nenum dc_status dce112_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce112_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic void dce112_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce112_res_pool_funcs = {\n\t.destroy = dce112_destroy_resource_pool,\n\t.link_enc_create = dce112_link_encoder_create,\n\t.validate_bandwidth = dce112_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce112_add_stream_to_ctx,\n\t.validate_global = dce112_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels_with_latency eng_clks = {0};\n\tstruct dm_pp_clock_levels_with_latency mem_clks = {0};\n\tstruct dm_pp_wm_sets_with_clock_ranges clk_ranges = {0};\n\tstruct dm_pp_clock_levels clks = {0};\n\tint memory_type_multiplier = MEMORY_TYPE_MULTIPLIER_CZ;\n\n\tif (dc->bw_vbios && dc->bw_vbios->memory_type == bw_def_hbm)\n\t\tmemory_type_multiplier = MEMORY_TYPE_HBM;\n\n\t/*do system clock  TODO PPLIB: after PPLIB implement,\n\t * then remove old way\n\t */\n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t&eng_clks)) {\n\n\t\t/* This is only for temporary */\n\t\tdm_pp_get_clock_levels_by_type(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t\t&clks);\n\t\t/* convert all the clock fro kHz to fix point mHz */\n\t\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\t\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels/8], 1000);\n\t\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*2/8], 1000);\n\t\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*3/8], 1000);\n\t\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*4/8], 1000);\n\t\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*5/8], 1000);\n\t\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*6/8], 1000);\n\t\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[0], 1000);\n\n\t\t/*do memory clock*/\n\t\tdm_pp_get_clock_levels_by_type(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t\t&clks);\n\n\t\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0] * memory_type_multiplier, 1000);\n\t\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels>>1] * memory_type_multiplier,\n\t\t\t1000);\n\t\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1] * memory_type_multiplier,\n\t\t\t1000);\n\n\t\treturn;\n\t}\n\n\t/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */\n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\teng_clks.data[0].clocks_in_khz, 1000);\n\n\t/*do memory clock*/\n\tdm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&mem_clks);\n\n\t/* we don't need to call PPLIB for validation clock since they\n\t * also give us the highest sclk and highest mclk (UMA clock).\n\t * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):\n\t * YCLK = UMACLK*m_memoryTypeMultiplier\n\t */\n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[0].clocks_in_khz * memory_type_multiplier, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels-1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\n\t/* Now notify PPLib/SMU about which Watermarks sets they should select\n\t * depending on DPM state they are in. And update BW MGR GFX Engine and\n\t * Memory clock member variables for Watermarks calculations for each\n\t * Watermark Set\n\t */\n\tclk_ranges.num_wm_sets = 4;\n\tclk_ranges.wm_clk_ranges[0].wm_set_id = WM_SET_A;\n\tclk_ranges.wm_clk_ranges[0].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[0].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[1].wm_set_id = WM_SET_B;\n\tclk_ranges.wm_clk_ranges[1].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[1].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[1].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[2].wm_set_id = WM_SET_C;\n\tclk_ranges.wm_clk_ranges[2].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[2].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[2].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;\n\n\tclk_ranges.wm_clk_ranges[3].wm_set_id = WM_SET_D;\n\tclk_ranges.wm_clk_ranges[3].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[3].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;\n\n\t/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */\n\tdm_pp_notify_wm_clock_changes(dc->ctx, &clk_ranges);\n}\n\nconst struct resource_caps *dce112_resource_cap(\n\tstruct hw_asic_id *asic_id)\n{\n\tif (ASIC_REV_IS_POLARIS11_M(asic_id->hw_internal_rev) ||\n\t    ASIC_REV_IS_POLARIS12_V(asic_id->hw_internal_rev))\n\t\treturn &polaris_11_resource_cap;\n\telse\n\t\treturn &polaris_10_resource_cap;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = dce112_resource_cap(&ctx->asic_id);\n\tpool->base.funcs = &dce112_res_pool_funcs;\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL0] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL1] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL2] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL3] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL4] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL5] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =  dce112_clock_source_create(\n\t\tctx, ctx->dc_bios,\n\t\tCLOCK_SOURCE_ID_DP_DTO, &clk_src_regs[0], true);\n\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] =\n\t\t\t\tdce112_timing_generator_create(\n\t\t\t\t\tctx,\n\t\t\t\t\ti,\n\t\t\t\t\t&dce112_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce112_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce112_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce112_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce112_opp_create(\n\t\t\tctx,\n\t\t\ti);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce112_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce112_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t  &res_create_funcs))\n\t\tgoto res_create_fail;\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\t/* Create hardware sequencer */\n\tdce112_hw_sequencer_construct(dc);\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2012-15 Advanced Micro Devices, Inc.cls\n*\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n\n#include \"stream_encoder.h\"\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce120_resource.h\"\n\n#include \"dce112/dce112_resource.h\"\n\n#include \"dce110/dce110_resource.h\"\n#include \"../virtual/virtual_stream_encoder.h\"\n#include \"dce120_timing_generator.h\"\n#include \"irq/dce120/irq_service_dce120.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_mem_input.h\"\n\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dce120/dce120_hw_sequencer.h\"\n#include \"dce/dce_transform.h\"\n#include \"clk_mgr.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n\n#include \"dce/dce_12_0_offset.h\"\n#include \"dce/dce_12_0_sh_mask.h\"\n#include \"soc15_hw_ip.h\"\n#include \"vega10_ip_offset.h\"\n#include \"nbio/nbio_6_1_offset.h\"\n#include \"mmhub/mmhub_9_4_0_offset.h\"\n#include \"mmhub/mmhub_9_4_0_sh_mask.h\"\n#include \"reg_helper.h\"\n\n#include \"dce100/dce100_resource.h\"\n\n#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL\t\t0x210f\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL\t\t0x220f\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL\t\t0x230f\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL\t\t0x240f\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL\t\t0x250f\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL\t\t0x260f\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL\t\t0x270f\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n#endif\n\nenum dce120_clk_src_array_id {\n\tDCE120_CLK_SRC_PLL0,\n\tDCE120_CLK_SRC_PLL1,\n\tDCE120_CLK_SRC_PLL2,\n\tDCE120_CLK_SRC_PLL3,\n\tDCE120_CLK_SRC_PLL4,\n\tDCE120_CLK_SRC_PLL5,\n\n\tDCE120_CLK_SRC_TOTAL\n};\n\nstatic const struct dce110_timing_generator_offsets dce120_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t}\n};\n\n/* begin *********************\n * macros to expend register list macro defined in HW object header file */\n\n#define BASE_INNER(seg) \\\n\tDCE_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE_INNER(seg) \\\n\tNBIF_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE(seg) \\\n\tNBIO_BASE_INNER(seg)\n\n/* compile time expand base address. */\n#define BASE(seg) \\\n\tBASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define SRI(reg_name, block, id)\\\n\t.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n/* MMHUB */\n#define MMHUB_BASE_INNER(seg) \\\n\tMMHUB_BASE__INST0_SEG ## seg\n\n#define MMHUB_BASE(seg) \\\n\tMMHUB_BASE_INNER(seg)\n\n#define MMHUB_SR(reg_name)\\\n\t\t.reg_name = MMHUB_BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n/* macros to expend register list macro defined in HW object header file\n * end *********************/\n\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE120_MASK_SH_LIST_SOC_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE120_MASK_SH_LIST_SOC_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_SOC_BASE(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_SOC_BASE(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE120_REG_LIST(id), \\\n\tSRI(DP_DPHY_INTERNAL_CTRL, DP, id) \\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE120(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE120(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_120_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_120(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_120(_MASK)\n};\n #define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5)\n};\n\n#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\\\n\t\tAUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(index, id)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCE_112(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\nstruct output_pixel_processor *dce120_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\nstruct dce_aux *dce120_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dce120_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce112_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3 + NBIO_BASE(mmBIOS_SCRATCH_3_BASE_IDX),\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6 + NBIO_BASE(mmBIOS_SCRATCH_6_BASE_IDX)\n};\n\nstatic const struct resource_caps res_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 7,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 6,\n\t\t.num_ddc = 6,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\nstatic const struct dc_debug_options debug_defaults = {\n\t\t.disable_clock_gate = true,\n};\n\nstatic struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void dce120_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\n\nstatic bool dce120_hw_sequencer_create(struct dc *dc)\n{\n\t/* All registers used by dce11.2 match those in dce11 in offset and\n\t * structure\n\t */\n\tdce120_hw_sequencer_construct(dc);\n\n\t/*TODO\tMove to separate file and Override what is needed */\n\n\treturn true;\n}\n\nstatic struct timing_generator *dce120_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce120_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic void dce120_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce120_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.irqs != NULL) {\n\t\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL) {\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.audio_count; i++) {\n\t\tif (pool->base.audios[i])\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL)\n\t\t\tdce120_clock_source_destroy(\n\t\t\t\t&pool->base.clock_sources[i]);\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce120_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tuint32_t reg_val = dm_read_reg_soc15(ctx, mmCC_DC_MISC_STRAPS, 0);\n\n\tstraps->audio_stream_number = get_reg_field_value(reg_val,\n\t\t\t\t\t\t\t  CC_DC_MISC_STRAPS,\n\t\t\t\t\t\t\t  AUDIO_STREAM_NUMBER);\n\tstraps->hdmi_disable = get_reg_field_value(reg_val,\n\t\t\t\t\t\t   CC_DC_MISC_STRAPS,\n\t\t\t\t\t\t   HDMI_DISABLE);\n\n\treg_val = dm_read_reg_soc15(ctx, mmDC_PINSTRAPS, 0);\n\tstraps->dc_pinstraps_audio = get_reg_field_value(reg_val,\n\t\t\t\t\t\t\t DC_PINSTRAPS,\n\t\t\t\t\t\t\t DC_PINSTRAPS_AUDIO);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true,\n};\n\nstatic struct link_encoder *dce120_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\n\treturn &enc110->base;\n}\n\nstatic struct input_pixel_processor *dce120_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic struct stream_encoder *dce120_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE120_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE12_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE12_MASK_SH_LIST(_MASK)\n};\n\n/* HWSEQ regs for VG20 */\nstatic const struct dce_hwseq_registers dce121_hwseq_reg = {\n\t\tHWSEQ_VG20_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift dce121_hwseq_shift = {\n\t\tHWSEQ_VG20_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask dce121_hwseq_mask = {\n\t\tHWSEQ_VG20_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce120_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic struct dce_hwseq *dce121_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &dce121_hwseq_reg;\n\t\thws->shifts = &dce121_hwseq_shift;\n\t\thws->masks = &dce121_hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce120_stream_encoder_create,\n\t.create_hwseq = dce120_hwseq_create,\n};\n\nstatic const struct resource_create_funcs dce121_res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce120_stream_encoder_create,\n\t.create_hwseq = dce121_hwseq_create,\n};\n\n\n#define mi_inst_regs(id) { MI_DCE12_REG_LIST(id) }\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE12_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE12_MASK_SH_LIST(_MASK)\n};\n\nstatic struct mem_input *dce120_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce120_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\treturn &dce_mi->base;\n}\n\nstatic struct transform *dce120_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->lb_memory_size = 0x1404; /*5124*/\n\treturn &transform->base;\n}\n\nstatic void dce120_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce120_res_pool_funcs = {\n\t.destroy = dce120_destroy_resource_pool,\n\t.link_enc_create = dce120_link_encoder_create,\n\t.validate_bandwidth = dce112_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce112_add_stream_to_ctx,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels_with_latency eng_clks = {0};\n\tstruct dm_pp_clock_levels_with_latency mem_clks = {0};\n\tstruct dm_pp_wm_sets_with_clock_ranges clk_ranges = {0};\n\tint i;\n\tunsigned int clk;\n\tunsigned int latency;\n\t/*original logic in dal3*/\n\tint memory_type_multiplier = MEMORY_TYPE_MULTIPLIER_CZ;\n\n\t/*do system clock*/\n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t\t&eng_clks) || eng_clks.num_levels == 0) {\n\n\t\teng_clks.num_levels = 8;\n\t\tclk = 300000;\n\n\t\tfor (i = 0; i < eng_clks.num_levels; i++) {\n\t\t\teng_clks.data[i].clocks_in_khz = clk;\n\t\t\tclk += 100000;\n\t\t}\n\t}\n\n\t/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */\n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\teng_clks.data[0].clocks_in_khz, 1000);\n\n\t/*do memory clock*/\n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&mem_clks) || mem_clks.num_levels == 0) {\n\n\t\tmem_clks.num_levels = 3;\n\t\tclk = 250000;\n\t\tlatency = 45;\n\n\t\tfor (i = 0; i < eng_clks.num_levels; i++) {\n\t\t\tmem_clks.data[i].clocks_in_khz = clk;\n\t\t\tmem_clks.data[i].latency_in_us = latency;\n\t\t\tclk += 500000;\n\t\t\tlatency -= 5;\n\t\t}\n\n\t}\n\n\t/* we don't need to call PPLIB for validation clock since they\n\t * also give us the highest sclk and highest mclk (UMA clock).\n\t * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):\n\t * YCLK = UMACLK*m_memoryTypeMultiplier\n\t */\n\tif (dc->bw_vbios->memory_type == bw_def_hbm)\n\t\tmemory_type_multiplier = MEMORY_TYPE_HBM;\n\n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[0].clocks_in_khz * memory_type_multiplier, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels-1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\n\t/* Now notify PPLib/SMU about which Watermarks sets they should select\n\t * depending on DPM state they are in. And update BW MGR GFX Engine and\n\t * Memory clock member variables for Watermarks calculations for each\n\t * Watermark Set\n\t */\n\tclk_ranges.num_wm_sets = 4;\n\tclk_ranges.wm_clk_ranges[0].wm_set_id = WM_SET_A;\n\tclk_ranges.wm_clk_ranges[0].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[0].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[1].wm_set_id = WM_SET_B;\n\tclk_ranges.wm_clk_ranges[1].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[1].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[1].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[2].wm_set_id = WM_SET_C;\n\tclk_ranges.wm_clk_ranges[2].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[2].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[2].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;\n\n\tclk_ranges.wm_clk_ranges[3].wm_set_id = WM_SET_D;\n\tclk_ranges.wm_clk_ranges[3].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[3].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;\n\n\t/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */\n\tdm_pp_notify_wm_clock_changes(dc->ctx, &clk_ranges);\n}\n\nstatic uint32_t read_pipe_fuses(struct dc_context *ctx)\n{\n\tuint32_t value = dm_read_reg_soc15(ctx, mmCC_DC_PIPE_DIS, 0);\n\t/* VG20 support max 6 pipes */\n\tvalue = value & 0x3f;\n\treturn value;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tint j;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct irq_service_init_data irq_init_data;\n\tstatic const struct resource_create_funcs *res_funcs;\n\tbool is_vg20 = ASICREV_IS_VEGA20_P(ctx->asic_id.hw_internal_rev);\n\tuint32_t pipe_fuses;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dce120_res_pool_funcs;\n\n\t/* TODO: Fill more data from GreenlandAsicCapability.cpp */\n\tpool->base.pipe_count = res_cap.num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\tdc->caps.psp_setup_panel_mode = true;\n\n\tdc->debug = debug_defaults;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL0] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL1] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL2] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL3] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL4] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL5] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCE120_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_ID_DP_DTO,\n\t\t\t\t&clk_src_regs[0], true);\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto clk_src_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\n\tirq_init_data.ctx = dc->ctx;\n\tpool->base.irqs = dal_irq_service_dce120_create(&irq_init_data);\n\tif (!pool->base.irqs)\n\t\tgoto irqs_create_fail;\n\n\t/* VG20: Pipe harvesting enabled, retrieve valid pipe fuses */\n\tif (is_vg20)\n\t\tpipe_fuses = read_pipe_fuses(ctx);\n\n\t/* index to valid pipe resource */\n\tj = 0;\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (is_vg20) {\n\t\t\tif ((pipe_fuses & (1 << i)) != 0) {\n\t\t\t\tdm_error(\"DC: skip invalid pipe %d!\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpool->base.timing_generators[j] =\n\t\t\t\tdce120_timing_generator_create(\n\t\t\t\t\tctx,\n\t\t\t\t\ti,\n\t\t\t\t\t&dce120_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto controller_create_fail;\n\t\t}\n\n\t\tpool->base.mis[j] = dce120_mem_input_create(ctx, i);\n\n\t\tif (pool->base.mis[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto controller_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[j] = dce120_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto controller_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[j] = dce120_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[j] = dce120_opp_create(\n\t\t\tctx,\n\t\t\ti);\n\t\tif (pool->base.opps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t}\n\n\t\t/* check next valid pipe */\n\t\tj++;\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce120_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce120_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\t/* valid pipe num */\n\tpool->base.pipe_count = j;\n\tpool->base.timing_generator_count = j;\n\n\tif (is_vg20)\n\t\tres_funcs = &dce121_res_create_funcs;\n\telse\n\t\tres_funcs = &res_create_funcs;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base, res_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tif (!dce120_hw_sequencer_create(dc))\n\t\tgoto controller_create_fail;\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nirqs_create_fail:\ncontroller_create_fail:\nclk_src_create_fail:\nres_create_fail:\n\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n * Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dce/dce_8_0_d.h\"\n#include \"dce/dce_8_0_sh_mask.h\"\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"irq/dce80/irq_service_dce80.h\"\n#include \"dce110/dce110_timing_generator.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce80/dce80_timing_generator.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce80/dce80_hw_sequencer.h\"\n#include \"dce100/dce100_resource.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_i2c.h\"\n/* TODO remove this include */\n\n#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT\n#include \"gmc/gmc_7_1_d.h\"\n#include \"gmc/gmc_7_1_sh_mask.h\"\n#endif\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n#define mmDP_DPHY_INTERNAL_CTRL                         0x1CDE\n#define mmDP0_DP_DPHY_INTERNAL_CTRL                     0x1CDE\n#define mmDP1_DP_DPHY_INTERNAL_CTRL                     0x1FDE\n#define mmDP2_DP_DPHY_INTERNAL_CTRL                     0x42DE\n#define mmDP3_DP_DPHY_INTERNAL_CTRL                     0x45DE\n#define mmDP4_DP_DPHY_INTERNAL_CTRL                     0x48DE\n#define mmDP5_DP_DPHY_INTERNAL_CTRL                     0x4BDE\n#define mmDP6_DP_DPHY_INTERNAL_CTRL                     0x4EDE\n#endif\n\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x1CCE\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x1CCE\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x1FCE\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x42CE\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x45CE\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x48CE\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4BCE\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x4ECE\n#endif\n\n\n#ifndef mmHPD_DC_HPD_CONTROL\n\t#define mmHPD_DC_HPD_CONTROL                            0x189A\n\t#define mmHPD0_DC_HPD_CONTROL                           0x189A\n\t#define mmHPD1_DC_HPD_CONTROL                           0x18A2\n\t#define mmHPD2_DC_HPD_CONTROL                           0x18AA\n\t#define mmHPD3_DC_HPD_CONTROL                           0x18B2\n\t#define mmHPD4_DC_HPD_CONTROL                           0x18BA\n\t#define mmHPD5_DC_HPD_CONTROL                           0x18C2\n#endif\n\n#define DCE11_DIG_FE_CNTL 0x4a00\n#define DCE11_DIG_BE_CNTL 0x4a47\n#define DCE11_DP_SEC 0x4ac3\n\nstatic const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {\n\t\t{\n\t\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp =  (mmGRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_COMMON_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE80(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE80(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE80(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\taux_regs(0),\n\taux_regs(1),\n\taux_regs(2),\n\taux_regs(3),\n\taux_regs(4),\n\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE80_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST_DCE_BASE(id),\\\n\t.AFMT_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5),\n\tstream_enc_regs(6)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_80_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_80(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_80(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(id)\\\n[id] = {\\\n\tCS_COMMON_REG_LIST_DCE_80(id),\\\n}\n\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0),\n\tclk_src_regs(1),\n\tclk_src_regs(2)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps res_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 3,\n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps res_cap_81 = {\n\t\t.num_timing_generator = 4,\n\t\t.num_audio = 7,\n\t\t.num_stream_encoder = 7,\n\t\t.num_pll = 3,\n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps res_cap_83 = {\n\t\t.num_timing_generator = 2,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 2,\n\t\t.num_ddc = 2,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE80_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE80(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE80(_MASK)\n};\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x1918\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct timing_generator *dce80_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce80_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct output_pixel_processor *dce80_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce80_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstruct dce_i2c_hw *dce80_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\n\nstruct dce_i2c_sw *dce80_i2c_sw_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_i2c_sw *dce_i2c_sw =\n\t\tkzalloc(sizeof(struct dce_i2c_sw), GFP_KERNEL);\n\n\tif (!dce_i2c_sw)\n\t\treturn NULL;\n\n\tdce_i2c_sw_construct(dce_i2c_sw, ctx);\n\n\treturn dce_i2c_sw;\n}\nstatic struct stream_encoder *dce80_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE8_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE8_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE8_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce80_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce80_stream_encoder_create,\n\t.create_hwseq = dce80_hwseq_create,\n};\n\n#define mi_inst_regs(id) { \\\n\tMI_DCE8_REG_LIST(id), \\\n\t.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \\\n}\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE8_MASK_SH_LIST(__SHIFT),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE8_MASK_SH_LIST(_MASK),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK\n};\n\nstatic struct mem_input *dce80_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\tdce_mi->wa.single_head_rdreq_dmif_limit = 2;\n\treturn &dce_mi->base;\n}\n\nstatic void dce80_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce80_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->prescaler_on = false;\n\treturn &transform->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 297000,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true\n};\n\nstruct link_encoder *dce80_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstruct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce80_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic struct input_pixel_processor *dce80_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce80_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce80_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce80_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\nbool dce80_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tint i;\n\tbool at_least_one_pipe = false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].stream)\n\t\t\tat_least_one_pipe = true;\n\t}\n\n\tif (at_least_one_pipe) {\n\t\t/* TODO implement when needed but for now hardcode max value*/\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 681000;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;\n\t} else {\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 0;\n\t}\n\n\treturn true;\n}\n\nstatic bool dce80_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce80_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce80_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic void dce80_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce80_res_pool_funcs = {\n\t.destroy = dce80_destroy_resource_pool,\n\t.link_enc_create = dce80_link_encoder_create,\n\t.validate_bandwidth = dce80_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce100_add_stream_to_ctx,\n\t.validate_global = dce80_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce100_find_first_free_match_stream_enc_for_link\n};\n\nstatic bool dce80_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dce80_res_pool_funcs;\n\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap.num_timing_generator;\n\tpool->base.timing_generator_count = res_cap.num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[2] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 3;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 2;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce80_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce80_timing_generator_create(\n\t\t\t\tctx, i, &dce80_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce80_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce80_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce80_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce80_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce80_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);\n\t\tif (pool->base.sw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create sw i2c!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.disable_dp_clk_share = true;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce80_hw_sequencer_construct(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce80_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce80_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic bool dce81_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap_81;\n\tpool->base.funcs = &dce80_res_pool_funcs;\n\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap_81.num_timing_generator;\n\tpool->base.timing_generator_count = res_cap_81.num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.is_apu = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[2] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 3;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 2;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce80_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce80_timing_generator_create(\n\t\t\t\tctx, i, &dce80_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce80_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce80_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce80_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce80_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce80_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);\n\t\tif (pool->base.sw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create sw i2c!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.disable_dp_clk_share = true;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce80_hw_sequencer_construct(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce81_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce81_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic bool dce83_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap_83;\n\tpool->base.funcs = &dce80_res_pool_funcs;\n\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap_83.num_timing_generator;\n\tpool->base.timing_generator_count = res_cap_83.num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.is_apu = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[1], false);\n\t\tpool->base.clk_src_count = 2;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[1], false);\n\t\tpool->base.clk_src_count = 1;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce80_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce80_timing_generator_create(\n\t\t\t\tctx, i, &dce80_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce80_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce80_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce80_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce80_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce80_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);\n\t\tif (pool->base.sw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create sw i2c!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.disable_dp_clk_share = true;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce80_hw_sequencer_construct(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce83_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce83_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2016 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n#include \"dc.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dcn10_resource.h\"\n#include \"dcn10_ipp.h\"\n#include \"dcn10_mpc.h\"\n#include \"irq/dcn10/irq_service_dcn10.h\"\n#include \"dcn10_dpp.h\"\n#include \"dcn10_optc.h\"\n#include \"dcn10_hw_sequencer.h\"\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dcn10_opp.h\"\n#include \"dcn10_link_encoder.h\"\n#include \"dcn10_stream_encoder.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"virtual/virtual_stream_encoder.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce112/dce112_resource.h\"\n#include \"dcn10_hubp.h\"\n#include \"dcn10_hubbub.h\"\n\n#include \"soc15_hw_ip.h\"\n#include \"vega10_ip_offset.h\"\n\n#include \"dcn/dcn_1_0_offset.h\"\n#include \"dcn/dcn_1_0_sh_mask.h\"\n\n#include \"nbio/nbio_7_0_offset.h\"\n\n#include \"mmhub/mmhub_9_1_offset.h\"\n#include \"mmhub/mmhub_9_1_sh_mask.h\"\n\n#include \"reg_helper.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n\nconst struct _vcs_dpi_ip_params_st dcn1_0_ip = {\n\t.rob_buffer_size_kbytes = 64,\n\t.det_buffer_size_kbytes = 164,\n\t.dpte_buffer_size_in_pte_reqs_luma = 42,\n\t.dpp_output_buffer_pixels = 2560,\n\t.opp_output_buffer_lines = 1,\n\t.pixel_chunk_size_kbytes = 8,\n\t.pte_enable = 1,\n\t.pte_chunk_size_kbytes = 2,\n\t.meta_chunk_size_kbytes = 2,\n\t.writeback_chunk_size_kbytes = 2,\n\t.line_buffer_size_bits = 589824,\n\t.max_line_buffer_lines = 12,\n\t.IsLineBufferBppFixed = 0,\n\t.LineBufferFixedBpp = -1,\n\t.writeback_luma_buffer_size_kbytes = 12,\n\t.writeback_chroma_buffer_size_kbytes = 8,\n\t.max_num_dpp = 4,\n\t.max_num_wb = 2,\n\t.max_dchub_pscl_bw_pix_per_clk = 4,\n\t.max_pscl_lb_bw_pix_per_clk = 2,\n\t.max_lb_vscl_bw_pix_per_clk = 4,\n\t.max_vscl_hscl_bw_pix_per_clk = 4,\n\t.max_hscl_ratio = 4,\n\t.max_vscl_ratio = 4,\n\t.hscl_mults = 4,\n\t.vscl_mults = 4,\n\t.max_hscl_taps = 8,\n\t.max_vscl_taps = 8,\n\t.dispclk_ramp_margin_percent = 1,\n\t.underscan_factor = 1.10,\n\t.min_vblank_lines = 14,\n\t.dppclk_delay_subtotal = 90,\n\t.dispclk_delay_subtotal = 42,\n\t.dcfclk_cstate_latency = 10,\n\t.max_inter_dcn_tile_repeaters = 8,\n\t.can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one = 0,\n\t.bug_forcing_LC_req_same_size_fixed = 0,\n};\n\nconst struct _vcs_dpi_soc_bounding_box_st dcn1_0_soc = {\n\t.sr_exit_time_us = 9.0,\n\t.sr_enter_plus_exit_time_us = 11.0,\n\t.urgent_latency_us = 4.0,\n\t.writeback_latency_us = 12.0,\n\t.ideal_dram_bw_after_urgent_percent = 80.0,\n\t.max_request_size_bytes = 256,\n\t.downspread_percent = 0.5,\n\t.dram_page_open_time_ns = 50.0,\n\t.dram_rw_turnaround_time_ns = 17.5,\n\t.dram_return_buffer_per_channel_bytes = 8192,\n\t.round_trip_ping_latency_dcfclk_cycles = 128,\n\t.urgent_out_of_order_return_per_channel_bytes = 256,\n\t.channel_interleave_bytes = 256,\n\t.num_banks = 8,\n\t.num_chans = 2,\n\t.vmm_page_size_bytes = 4096,\n\t.dram_clock_change_latency_us = 17.0,\n\t.writeback_dram_clock_change_latency_us = 23.0,\n\t.return_bus_width_bytes = 64,\n};\n\n#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL\t\t0x210f\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL\t\t0x220f\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL\t\t0x230f\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL\t\t0x240f\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL\t\t0x250f\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL\t\t0x260f\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL\t\t0x270f\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n#endif\n\n\nenum dcn10_clk_src_array_id {\n\tDCN10_CLK_SRC_PLL0,\n\tDCN10_CLK_SRC_PLL1,\n\tDCN10_CLK_SRC_PLL2,\n\tDCN10_CLK_SRC_PLL3,\n\tDCN10_CLK_SRC_TOTAL,\n\tDCN101_CLK_SRC_TOTAL = DCN10_CLK_SRC_PLL3\n};\n\n/* begin *********************\n * macros to expend register list macro defined in HW object header file */\n\n/* DCN */\n#define BASE_INNER(seg) \\\n\tDCE_BASE__INST0_SEG ## seg\n\n#define BASE(seg) \\\n\tBASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define SRI(reg_name, block, id)\\\n\t.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n/* NBIO */\n#define NBIO_BASE_INNER(seg) \\\n\tNBIF_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE(seg) \\\n\tNBIO_BASE_INNER(seg)\n\n#define NBIO_SR(reg_name)\\\n\t\t.reg_name = NBIO_BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n/* MMHUB */\n#define MMHUB_BASE_INNER(seg) \\\n\tMMHUB_BASE__INST0_SEG ## seg\n\n#define MMHUB_BASE(seg) \\\n\tMMHUB_BASE_INNER(seg)\n\n#define MMHUB_SR(reg_name)\\\n\t\t.reg_name = MMHUB_BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n/* macros to expend register list macro defined in HW object header file\n * end *********************/\n\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCN10_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCN10(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCN10_REG_LIST(0)\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_DCN_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n};\n\nstatic const struct dcn10_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\t\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n};\n\n#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\\\n\t\tAUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCN10_REG_LIST(id), \\\n\tSRI(DP_DPHY_INTERNAL_CTRL, DP, id) \\\n}\n\nstatic const struct dcn10_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3)\n};\n\nstatic const struct dcn10_link_enc_shift le_shift = {\n\t\tLINK_ENCODER_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_link_enc_mask le_mask = {\n\t\tLINK_ENCODER_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\tIPP_REG_LIST_DCN10(id),\\\n}\n\nstatic const struct dcn10_ipp_registers ipp_regs[] = {\n\tipp_regs(0),\n\tipp_regs(1),\n\tipp_regs(2),\n\tipp_regs(3),\n};\n\nstatic const struct dcn10_ipp_shift ipp_shift = {\n\t\tIPP_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_ipp_mask ipp_mask = {\n\t\tIPP_MASK_SH_LIST_DCN10(_MASK),\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_REG_LIST_DCN10(id),\\\n}\n\nstatic const struct dcn10_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n};\n\nstatic const struct dcn10_opp_shift opp_shift = {\n\t\tOPP_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_opp_mask opp_mask = {\n\t\tOPP_MASK_SH_LIST_DCN10(_MASK),\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define tf_regs(id)\\\n[id] = {\\\n\tTF_REG_LIST_DCN10(id),\\\n}\n\nstatic const struct dcn_dpp_registers tf_regs[] = {\n\ttf_regs(0),\n\ttf_regs(1),\n\ttf_regs(2),\n\ttf_regs(3),\n};\n\nstatic const struct dcn_dpp_shift tf_shift = {\n\tTF_REG_LIST_SH_MASK_DCN10(__SHIFT),\n\tTF_DEBUG_REG_LIST_SH_DCN10\n\n};\n\nstatic const struct dcn_dpp_mask tf_mask = {\n\tTF_REG_LIST_SH_MASK_DCN10(_MASK),\n\tTF_DEBUG_REG_LIST_MASK_DCN10\n};\n\nstatic const struct dcn_mpc_registers mpc_regs = {\n\t\tMPC_COMMON_REG_LIST_DCN1_0(0),\n\t\tMPC_COMMON_REG_LIST_DCN1_0(1),\n\t\tMPC_COMMON_REG_LIST_DCN1_0(2),\n\t\tMPC_COMMON_REG_LIST_DCN1_0(3),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(0),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(1),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(2),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(3)\n};\n\nstatic const struct dcn_mpc_shift mpc_shift = {\n\tMPC_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)\n};\n\nstatic const struct dcn_mpc_mask mpc_mask = {\n\tMPC_COMMON_MASK_SH_LIST_DCN1_0(_MASK),\n};\n\n#define tg_regs(id)\\\n[id] = {TG_COMMON_REG_LIST_DCN1_0(id)}\n\nstatic const struct dcn_optc_registers tg_regs[] = {\n\ttg_regs(0),\n\ttg_regs(1),\n\ttg_regs(2),\n\ttg_regs(3),\n};\n\nstatic const struct dcn_optc_shift tg_shift = {\n\tTG_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)\n};\n\nstatic const struct dcn_optc_mask tg_mask = {\n\tTG_COMMON_MASK_SH_LIST_DCN1_0(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t\tNBIO_SR(BIOS_SCRATCH_3),\n\t\tNBIO_SR(BIOS_SCRATCH_6)\n};\n\n#define hubp_regs(id)\\\n[id] = {\\\n\tHUBP_REG_LIST_DCN10(id)\\\n}\n\nstatic const struct dcn_mi_registers hubp_regs[] = {\n\thubp_regs(0),\n\thubp_regs(1),\n\thubp_regs(2),\n\thubp_regs(3),\n};\n\nstatic const struct dcn_mi_shift hubp_shift = {\n\t\tHUBP_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn_mi_mask hubp_mask = {\n\t\tHUBP_MASK_SH_LIST_DCN10(_MASK)\n};\n\nstatic const struct dcn_hubbub_registers hubbub_reg = {\n\t\tHUBBUB_REG_LIST_DCN10(0)\n};\n\nstatic const struct dcn_hubbub_shift hubbub_shift = {\n\t\tHUBBUB_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn_hubbub_mask hubbub_mask = {\n\t\tHUBBUB_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define clk_src_regs(index, pllid)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCN1_0(index, pllid),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN1_0(_MASK)\n};\n\nstatic const struct resource_caps res_cap = {\n\t\t.num_timing_generator = 4,\n\t\t.num_opp = 4,\n\t\t.num_video_plane = 4,\n\t\t.num_audio = 4,\n\t\t.num_stream_encoder = 4,\n\t\t.num_pll = 4,\n\t\t.num_ddc = 4,\n};\n\nstatic const struct resource_caps rv2_res_cap = {\n\t\t.num_timing_generator = 3,\n\t\t.num_opp = 3,\n\t\t.num_video_plane = 3,\n\t\t.num_audio = 3,\n\t\t.num_stream_encoder = 3,\n\t\t.num_pll = 3,\n\t\t.num_ddc = 4,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCN_UNIVERSAL,\n\t.blends_with_above = true,\n\t.blends_with_below = true,\n\t.per_pixel_alpha = true,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = true,\n\t\t\t.fp16 = true\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 16000,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 250,\n\t\t\t.fp16 = 1\n\t}\n};\n\nstatic const struct dc_debug_options debug_defaults_drv = {\n\t\t.sanity_checks = true,\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = false,\n\t\t.clock_trace = true,\n\n\t\t/* raven smu dones't allow 0 disp clk,\n\t\t * smu min disp clk limit is 50Mhz\n\t\t * keep min disp clk 100Mhz avoid smu hang\n\t\t */\n\t\t.min_disp_clk_khz = 100000,\n\n\t\t.disable_pplib_clock_request = false,\n\t\t.disable_pplib_wm_range = false,\n\t\t.pplib_wm_report_mode = WM_REPORT_DEFAULT,\n\t\t.pipe_split_policy = MPC_SPLIT_AVOID_MULT_DISP,\n\t\t.force_single_disp_pipe_split = true,\n\t\t.disable_dcc = DCC_ENABLE,\n\t\t.voltage_align_fclk = true,\n\t\t.disable_stereo_support = true,\n\t\t.vsr_support = true,\n\t\t.performance_trace = false,\n\t\t.az_endpoint_mute_only = true,\n\t\t.recovery_enabled = false, /*enable this by default after testing.*/\n\t\t.max_downscale_src_width = 3840,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nstatic const struct dc_debug_options debug_defaults_diags = {\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = true,\n\t\t.clock_trace = true,\n\t\t.disable_stutter = true,\n\t\t.disable_pplib_clock_request = true,\n\t\t.disable_pplib_wm_range = true,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nstatic void dcn10_dpp_destroy(struct dpp **dpp)\n{\n\tkfree(TO_DCN10_DPP(*dpp));\n\t*dpp = NULL;\n}\n\nstatic struct dpp *dcn10_dpp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn10_dpp *dpp =\n\t\tkzalloc(sizeof(struct dcn10_dpp), GFP_KERNEL);\n\n\tif (!dpp)\n\t\treturn NULL;\n\n\tdpp1_construct(dpp, ctx, inst,\n\t\t       &tf_regs[inst], &tf_shift, &tf_mask);\n\treturn &dpp->base;\n}\n\nstatic struct input_pixel_processor *dcn10_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn10_ipp *ipp =\n\t\tkzalloc(sizeof(struct dcn10_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn10_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\n\nstatic struct output_pixel_processor *dcn10_opp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn10_opp *opp =\n\t\tkzalloc(sizeof(struct dcn10_opp), GFP_KERNEL);\n\n\tif (!opp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn10_opp_construct(opp, ctx, inst,\n\t\t\t&opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dcn10_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dcn10_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdcn1_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstatic struct mpc *dcn10_mpc_create(struct dc_context *ctx)\n{\n\tstruct dcn10_mpc *mpc10 = kzalloc(sizeof(struct dcn10_mpc),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!mpc10)\n\t\treturn NULL;\n\n\tdcn10_mpc_construct(mpc10, ctx,\n\t\t\t&mpc_regs,\n\t\t\t&mpc_shift,\n\t\t\t&mpc_mask,\n\t\t\t4);\n\n\treturn &mpc10->base;\n}\n\nstatic struct hubbub *dcn10_hubbub_create(struct dc_context *ctx)\n{\n\tstruct dcn10_hubbub *dcn10_hubbub = kzalloc(sizeof(struct dcn10_hubbub),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!dcn10_hubbub)\n\t\treturn NULL;\n\n\thubbub1_construct(&dcn10_hubbub->base, ctx,\n\t\t\t&hubbub_reg,\n\t\t\t&hubbub_shift,\n\t\t\t&hubbub_mask);\n\n\treturn &dcn10_hubbub->base;\n}\n\nstatic struct timing_generator *dcn10_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance)\n{\n\tstruct optc *tgn10 =\n\t\tkzalloc(sizeof(struct optc), GFP_KERNEL);\n\n\tif (!tgn10)\n\t\treturn NULL;\n\n\ttgn10->base.inst = instance;\n\ttgn10->base.ctx = ctx;\n\n\ttgn10->tg_regs = &tg_regs[instance];\n\ttgn10->tg_shift = &tg_shift;\n\ttgn10->tg_mask = &tg_mask;\n\n\tdcn10_timing_generator_init(tgn10);\n\n\treturn &tgn10->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstruct link_encoder *dcn10_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dcn10_link_encoder *enc10 =\n\t\tkzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);\n\n\tif (!enc10)\n\t\treturn NULL;\n\n\tdcn10_link_encoder_construct(enc10,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source],\n\t\t\t\t      &le_shift,\n\t\t\t\t      &le_mask);\n\n\treturn &enc10->base;\n}\n\nstruct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tgeneric_reg_get(ctx, mmDC_PINSTRAPS + BASE(mmDC_PINSTRAPS_BASE_IDX),\n\t\tFN(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO), &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct stream_encoder *dcn10_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn10_stream_encoder *enc1 =\n\t\tkzalloc(sizeof(struct dcn10_stream_encoder), GFP_KERNEL);\n\n\tif (!enc1)\n\t\treturn NULL;\n\n\tdcn10_stream_encoder_construct(enc1, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc1->base;\n}\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCN1_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCN1_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCN1_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dcn10_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t\thws->wa.DEGVIDCN10_253 = true;\n\t\thws->wa.false_optc_underflow = true;\n\t\thws->wa.DEGVIDCN10_254 = true;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dcn10_stream_encoder_create,\n\t.create_hwseq = dcn10_hwseq_create,\n};\n\nstatic const struct resource_create_funcs res_create_maximus_funcs = {\n\t.read_dce_straps = NULL,\n\t.create_audio = NULL,\n\t.create_stream_encoder = NULL,\n\t.create_hwseq = dcn10_hwseq_create,\n};\n\nvoid dcn10_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic struct pp_smu_funcs *dcn10_pp_smu_create(struct dc_context *ctx)\n{\n\tstruct pp_smu_funcs *pp_smu = kzalloc(sizeof(*pp_smu), GFP_KERNEL);\n\n\tif (!pp_smu)\n\t\treturn pp_smu;\n\n\tdm_pp_get_funcs(ctx, pp_smu);\n\treturn pp_smu;\n}\n\nstatic void destruct(struct dcn10_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL) {\n\t\t\tkfree(DCN10STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t\t\tpool->base.stream_enc[i] = NULL;\n\t\t}\n\t}\n\n\tif (pool->base.mpc != NULL) {\n\t\tkfree(TO_DCN10_MPC(pool->base.mpc));\n\t\tpool->base.mpc = NULL;\n\t}\n\n\tif (pool->base.hubbub != NULL) {\n\t\tkfree(pool->base.hubbub);\n\t\tpool->base.hubbub = NULL;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tpool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.dpps[i] != NULL)\n\t\t\tdcn10_dpp_destroy(&pool->base.dpps[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tpool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.hubps[i] != NULL) {\n\t\t\tkfree(TO_DCN10_HUBP(pool->base.hubps[i]));\n\t\t\tpool->base.hubps[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.irqs != NULL) {\n\t\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCN10TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.audio_count; i++) {\n\t\tif (pool->base.audios[i])\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdcn10_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t\tpool->base.clock_sources[i] = NULL;\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL) {\n\t\tdcn10_clock_source_destroy(&pool->base.dp_clock_source);\n\t\tpool->base.dp_clock_source = NULL;\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tkfree(pool->base.pp_smu);\n}\n\nstatic struct hubp *dcn10_hubp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn10_hubp *hubp1 =\n\t\tkzalloc(sizeof(struct dcn10_hubp), GFP_KERNEL);\n\n\tif (!hubp1)\n\t\treturn NULL;\n\n\tdcn10_hubp_construct(hubp1, ctx, inst,\n\t\t\t     &hubp_regs[inst], &hubp_shift, &hubp_mask);\n\treturn &hubp1->base;\n}\n\nstatic void get_pixel_clock_parameters(\n\tconst struct pipe_ctx *pipe_ctx,\n\tstruct pixel_clk_params *pixel_clk_params)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tpixel_clk_params->requested_pix_clk_100hz = stream->timing.pix_clk_100hz;\n\tpixel_clk_params->encoder_object_id = stream->link->link_enc->id;\n\tpixel_clk_params->signal_type = pipe_ctx->stream->signal;\n\tpixel_clk_params->controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\t/* TODO: un-hardcode*/\n\tpixel_clk_params->requested_sym_clk = LINK_RATE_LOW *\n\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\tpixel_clk_params->flags.ENABLE_SS = 0;\n\tpixel_clk_params->color_depth =\n\t\tstream->timing.display_color_depth;\n\tpixel_clk_params->flags.DISPLAY_BLANKED = 1;\n\tpixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;\n\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\tpixel_clk_params->color_depth = COLOR_DEPTH_888;\n\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tpixel_clk_params->requested_pix_clk_100hz  /= 2;\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tpixel_clk_params->requested_pix_clk_100hz *= 2;\n\n}\n\nstatic void build_clamping_params(struct dc_stream_state *stream)\n{\n\tstream->clamping.clamping_level = CLAMPING_FULL_RANGE;\n\tstream->clamping.c_depth = stream->timing.display_color_depth;\n\tstream->clamping.pixel_encoding = stream->timing.pixel_encoding;\n}\n\nstatic void build_pipe_hw_param(struct pipe_ctx *pipe_ctx)\n{\n\n\tget_pixel_clock_parameters(pipe_ctx, &pipe_ctx->stream_res.pix_clk_params);\n\n\tpipe_ctx->clock_source->funcs->get_pix_clk_dividers(\n\t\tpipe_ctx->clock_source,\n\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t&pipe_ctx->pll_settings);\n\n\tpipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;\n\n\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t\t\t&pipe_ctx->stream->bit_depth_params);\n\tbuild_clamping_params(pipe_ctx->stream);\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\t/*TODO Seems unneeded anymore */\n\t/*\tif (old_context && resource_is_stream_unchanged(old_context, stream)) {\n\t\t\tif (stream != NULL && old_context->streams[i] != NULL) {\n\t\t\t\t todo: shouldn't have to copy missing parameter here\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tstream->clamping.pixel_encoding =\n\t\t\t\t\t\tstream->timing.pixel_encoding;\n\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tbuild_clamping_params(stream);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t*/\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tbuild_pipe_hw_param(pipe_ctx);\n\treturn DC_OK;\n}\n\nenum dc_status dcn10_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(\n\t\tstruct dc_state *context,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct resource_context *res_ctx = &context->res_ctx;\n\tstruct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);\n\tstruct pipe_ctx *idle_pipe = find_idle_secondary_pipe(res_ctx, pool, head_pipe);\n\n\tif (!head_pipe) {\n\t\tASSERT(0);\n\t\treturn NULL;\n\t}\n\n\tif (!idle_pipe)\n\t\treturn NULL;\n\n\tidle_pipe->stream = head_pipe->stream;\n\tidle_pipe->stream_res.tg = head_pipe->stream_res.tg;\n\tidle_pipe->stream_res.abm = head_pipe->stream_res.abm;\n\tidle_pipe->stream_res.opp = head_pipe->stream_res.opp;\n\n\tidle_pipe->plane_res.hubp = pool->hubps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.ipp = pool->ipps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.dpp = pool->dpps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.mpcc_inst = pool->dpps[idle_pipe->pipe_idx]->inst;\n\n\treturn idle_pipe;\n}\n\nstatic bool dcn10_get_dcc_compression_cap(const struct dc *dc,\n\t\tconst struct dc_dcc_surface_param *input,\n\t\tstruct dc_surface_dcc_cap *output)\n{\n\treturn dc->res_pool->hubbub->funcs->get_dcc_compression_cap(\n\t\t\tdc->res_pool->hubbub,\n\t\t\tinput,\n\t\t\toutput);\n}\n\nstatic void dcn10_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dcn10_resource_pool *dcn10_pool = TO_DCN10_RES_POOL(*pool);\n\n\tdestruct(dcn10_pool);\n\tkfree(dcn10_pool);\n\t*pool = NULL;\n}\n\nstatic enum dc_status dcn10_validate_plane(const struct dc_plane_state *plane_state, struct dc_caps *caps)\n{\n\tif (plane_state->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN\n\t\t\t&& caps->max_video_width != 0\n\t\t\t&& plane_state->src_rect.width > caps->max_video_width)\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status dcn10_validate_global(struct dc *dc, struct dc_state *context)\n{\n\tint i, j;\n\tbool video_down_scaled = false;\n\tbool video_large = false;\n\tbool desktop_large = false;\n\tbool dcc_disabled = false;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 2)\n\t\t\treturn DC_FAIL_UNSUPPORTED_1;\n\n\t\tfor (j = 0; j < context->stream_status[i].plane_count; j++) {\n\t\t\tstruct dc_plane_state *plane =\n\t\t\t\tcontext->stream_status[i].plane_states[j];\n\n\n\t\t\tif (plane->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\n\t\t\t\tif (plane->src_rect.width > plane->dst_rect.width ||\n\t\t\t\t\t\tplane->src_rect.height > plane->dst_rect.height)\n\t\t\t\t\tvideo_down_scaled = true;\n\n\t\t\t\tif (plane->src_rect.width >= 3840)\n\t\t\t\t\tvideo_large = true;\n\n\t\t\t} else {\n\t\t\t\tif (plane->src_rect.width >= 3840)\n\t\t\t\t\tdesktop_large = true;\n\t\t\t\tif (!plane->dcc.enable)\n\t\t\t\t\tdcc_disabled = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Workaround: On DCN10 there is UMC issue that causes underflow when\n\t * playing 4k video on 4k desktop with video downscaled and single channel\n\t * memory\n\t */\n\tif (video_large && desktop_large && video_down_scaled && dcc_disabled &&\n\t\t\tdc->dcn_soc->number_of_channels == 1)\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status dcn10_get_default_swizzle_mode(struct dc_plane_state *plane_state)\n{\n\tenum dc_status result = DC_OK;\n\n\tenum surface_pixel_format surf_pix_format = plane_state->format;\n\tunsigned int bpp = resource_pixel_format_to_bpp(surf_pix_format);\n\n\tenum swizzle_mode_values swizzle = DC_SW_LINEAR;\n\n\tif (bpp == 64)\n\t\tswizzle = DC_SW_64KB_D;\n\telse\n\t\tswizzle = DC_SW_64KB_S;\n\n\tplane_state->tiling_info.gfx9.swizzle = swizzle;\n\treturn result;\n}\n\nstruct stream_encoder *dcn10_find_first_free_match_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tint j = -1;\n\tstruct dc_link *link = stream->link;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (!res_ctx->is_stream_enc_acquired[i] &&\n\t\t\t\tpool->stream_enc[i]) {\n\t\t\t/* Store first available for MST second display\n\t\t\t * in daisy chain use case\n\t\t\t */\n\t\t\tj = i;\n\t\t\tif (pool->stream_enc[i]->id ==\n\t\t\t\t\tlink->link_enc->preferred_engine)\n\t\t\t\treturn pool->stream_enc[i];\n\t\t}\n\t}\n\n\t/*\n\t * For CZ and later, we can allow DIG FE and BE to differ for all display types\n\t */\n\n\tif (j >= 0)\n\t\treturn pool->stream_enc[j];\n\n\treturn NULL;\n}\n\nstatic const struct dc_cap_funcs cap_funcs = {\n\t.get_dcc_compression_cap = dcn10_get_dcc_compression_cap\n};\n\nstatic const struct resource_funcs dcn10_res_pool_funcs = {\n\t.destroy = dcn10_destroy_resource_pool,\n\t.link_enc_create = dcn10_link_encoder_create,\n\t.validate_bandwidth = dcn_validate_bandwidth,\n\t.acquire_idle_pipe_for_layer = dcn10_acquire_idle_pipe_for_layer,\n\t.validate_plane = dcn10_validate_plane,\n\t.validate_global = dcn10_validate_global,\n\t.add_stream_to_ctx = dcn10_add_stream_to_ctx,\n\t.get_default_swizzle_mode = dcn10_get_default_swizzle_mode,\n\t.find_first_free_match_stream_enc_for_link = dcn10_find_first_free_match_stream_enc_for_link\n};\n\nstatic uint32_t read_pipe_fuses(struct dc_context *ctx)\n{\n\tuint32_t value = dm_read_reg_soc15(ctx, mmCC_DC_PIPE_DIS, 0);\n\t/* RV1 support max 4 pipes */\n\tvalue = value & 0xf;\n\treturn value;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dcn10_resource_pool *pool)\n{\n\tint i;\n\tint j;\n\tstruct dc_context *ctx = dc->ctx;\n\tuint32_t pipe_fuses = read_pipe_fuses(ctx);\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tif (ctx->dce_version == DCN_VERSION_1_01)\n\t\tpool->base.res_cap = &rv2_res_cap;\n\telse\n\t\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dcn10_res_pool_funcs;\n\n\t/*\n\t * TODO fill in from actual raven resource when we create\n\t * more than virtual encoder\n\t */\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\t/* max pipe num for ASIC before check pipe fuses */\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_01)\n\t\tpool->base.pipe_count = 3;\n\tdc->caps.max_video_width = 3840;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 256;\n\tdc->caps.max_slave_planes = 1;\n\tdc->caps.is_apu = true;\n\tdc->caps.post_blend_color_processing = false;\n\t/* Raven DP PHY HBR2 eye diagram pattern is not stable. Use TP4 */\n\tdc->caps.force_dp_tps4_for_cp2520 = true;\n\n\tif (dc->ctx->dce_environment == DCE_ENV_PRODUCTION_DRV)\n\t\tdc->debug = debug_defaults_drv;\n\telse\n\t\tdc->debug = debug_defaults_diags;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCN10_CLK_SRC_PLL0] =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCN10_CLK_SRC_PLL1] =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCN10_CLK_SRC_PLL2] =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_0) {\n\t\tpool->base.clock_sources[DCN10_CLK_SRC_PLL3] =\n\t\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t\t&clk_src_regs[3], false);\n\t}\n\n\tpool->base.clk_src_count = DCN10_CLK_SRC_TOTAL;\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_01)\n\t\tpool->base.clk_src_count = DCN101_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_ID_DP_DTO,\n\t\t\t\t/* todo: not reuse phy_pll registers */\n\t\t\t\t&clk_src_regs[0], true);\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dcn10_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto fail;\n\t}\n\n\tdml_init_instance(&dc->dml, &dcn1_0_soc, &dcn1_0_ip, DML_PROJECT_RAVEN1);\n\tmemcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults));\n\tmemcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults));\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_01) {\n\t\tstruct dcn_soc_bounding_box *dcn_soc = dc->dcn_soc;\n\t\tstruct dcn_ip_params *dcn_ip = dc->dcn_ip;\n\t\tstruct display_mode_lib *dml = &dc->dml;\n\n\t\tdml->ip.max_num_dpp = 3;\n\t\t/* TODO how to handle 23.84? */\n\t\tdcn_soc->dram_clock_change_latency = 23;\n\t\tdcn_ip->max_num_dpp = 3;\n\t}\n\tif (ASICREV_IS_RV1_F0(dc->ctx->asic_id.hw_internal_rev)) {\n\t\tdc->dcn_soc->urgent_latency = 3;\n\t\tdc->debug.disable_dmcu = true;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 41.60f;\n\t}\n\n\n\tdc->dcn_soc->number_of_channels = dc->ctx->asic_id.vram_width / ddr4_dram_width;\n\tASSERT(dc->dcn_soc->number_of_channels < 3);\n\tif (dc->dcn_soc->number_of_channels == 0)/*old sbios bug*/\n\t\tdc->dcn_soc->number_of_channels = 2;\n\n\tif (dc->dcn_soc->number_of_channels == 1) {\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 19.2f;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 = 17.066f;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 = 14.933f;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 = 12.8f;\n\t\tif (ASICREV_IS_RV1_F0(dc->ctx->asic_id.hw_internal_rev)) {\n\t\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 20.80f;\n\t\t}\n\t}\n\n\tpool->base.pp_smu = dcn10_pp_smu_create(ctx);\n\n\t/*\n\t * Right now SMU/PPLIB and DAL all have the AZ D3 force PME notification *\n\t * implemented. So AZ D3 should work.For issue 197007.                   *\n\t */\n\tif (pool->base.pp_smu != NULL\n\t\t\t&& pool->base.pp_smu->rv_funcs.set_pme_wa_enable != NULL)\n\t\tdc->debug.az_endpoint_mute_only = false;\n\n\tif (!dc->debug.disable_pplib_clock_request)\n\t\tdcn_bw_update_from_pplib(dc);\n\tdcn_bw_sync_calcs_and_dml(dc);\n\tif (!dc->debug.disable_pplib_wm_range) {\n\t\tdc->res_pool = &pool->base;\n\t\tdcn_bw_notify_pplib_of_wm_ranges(dc);\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dcn10_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto fail;\n\t}\n\n\t/* index to valid pipe resource  */\n\tj = 0;\n\t/* mem input -> ipp -> dpp -> opp -> TG */\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\t/* if pipe is disabled, skip instance of HW pipe,\n\t\t * i.e, skip ASIC register instance\n\t\t */\n\t\tif ((pipe_fuses & (1 << i)) != 0)\n\t\t\tcontinue;\n\n\t\tpool->base.hubps[j] = dcn10_hubp_create(ctx, i);\n\t\tif (pool->base.hubps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.ipps[j] = dcn10_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.dpps[j] = dcn10_dpp_create(ctx, i);\n\t\tif (pool->base.dpps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create dpp!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.opps[j] = dcn10_opp_create(ctx, i);\n\t\tif (pool->base.opps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.timing_generators[j] = dcn10_timing_generator_create(\n\t\t\t\tctx, i);\n\t\tif (pool->base.timing_generators[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check next valid pipe */\n\t\tj++;\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dcn10_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dcn10_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create hw i2c!!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\t/* valid pipe num */\n\tpool->base.pipe_count = j;\n\tpool->base.timing_generator_count = j;\n\n\t/* within dml lib, it is hard code to 4. If ASIC pipe is fused,\n\t * the value may be changed\n\t */\n\tdc->dml.ip.max_num_dpp = pool->base.pipe_count;\n\tdc->dcn_ip->max_num_dpp = pool->base.pipe_count;\n\n\tpool->base.mpc = dcn10_mpc_create(ctx);\n\tif (pool->base.mpc == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create mpc!\\n\");\n\t\tgoto fail;\n\t}\n\n\tpool->base.hubbub = dcn10_hubbub_create(ctx);\n\tif (pool->base.hubbub == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create hubbub!\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t(!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment) ?\n\t\t\t&res_create_funcs : &res_create_maximus_funcs)))\n\t\t\tgoto fail;\n\n\tdcn10_hw_sequencer_construct(dc);\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->cap_funcs = cap_funcs;\n\n\treturn true;\n\nfail:\n\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2016 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n#include \"dc.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dcn20/dcn20_resource.h\"\n\n#include \"dcn10/dcn10_hubp.h\"\n#include \"dcn10/dcn10_ipp.h\"\n#include \"dcn20_hubbub.h\"\n#include \"dcn20_mpc.h\"\n#include \"dcn20_hubp.h\"\n#include \"irq/dcn20/irq_service_dcn20.h\"\n#include \"dcn20_dpp.h\"\n#include \"dcn20_optc.h\"\n#include \"dcn20_hwseq.h\"\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dcn10/dcn10_resource.h\"\n#include \"dcn20_opp.h\"\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n#include \"dcn20_dsc.h\"\n#endif\n\n#include \"dcn20_link_encoder.h\"\n#include \"dcn20_stream_encoder.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"virtual/virtual_stream_encoder.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dml/display_mode_vba.h\"\n#include \"dcn20_dccg.h\"\n#include \"dcn20_vmid.h\"\n\n#include \"navi10_ip_offset.h\"\n\n#include \"dcn/dcn_2_0_0_offset.h\"\n#include \"dcn/dcn_2_0_0_sh_mask.h\"\n\n#include \"nbio/nbio_2_3_offset.h\"\n\n#include \"dcn20/dcn20_dwb.h\"\n#include \"dcn20/dcn20_mmhubbub.h\"\n\n#include \"mmhub/mmhub_2_0_0_offset.h\"\n#include \"mmhub/mmhub_2_0_0_sh_mask.h\"\n\n#include \"reg_helper.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n#include \"vm_helper.h\"\n\n#include \"amdgpu_socbb.h\"\n\n/* NV12 SOC BB is currently in FW, mark SW bounding box invalid. */\n#define SOC_BOUNDING_BOX_VALID false\n#define DC_LOGGER_INIT(logger)\n\nstruct _vcs_dpi_ip_params_st dcn2_0_ip = {\n\t.odm_capable = 1,\n\t.gpuvm_enable = 0,\n\t.hostvm_enable = 0,\n\t.gpuvm_max_page_table_levels = 4,\n\t.hostvm_max_page_table_levels = 4,\n\t.hostvm_cached_page_table_levels = 0,\n\t.pte_group_size_bytes = 2048,\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t.num_dsc = 6,\n#else\n\t.num_dsc = 0,\n#endif\n\t.rob_buffer_size_kbytes = 168,\n\t.det_buffer_size_kbytes = 164,\n\t.dpte_buffer_size_in_pte_reqs_luma = 84,\n\t.pde_proc_buffer_size_64k_reqs = 48,\n\t.dpp_output_buffer_pixels = 2560,\n\t.opp_output_buffer_lines = 1,\n\t.pixel_chunk_size_kbytes = 8,\n\t.pte_chunk_size_kbytes = 2,\n\t.meta_chunk_size_kbytes = 2,\n\t.writeback_chunk_size_kbytes = 2,\n\t.line_buffer_size_bits = 789504,\n\t.is_line_buffer_bpp_fixed = 0,\n\t.line_buffer_fixed_bpp = 0,\n\t.dcc_supported = true,\n\t.max_line_buffer_lines = 12,\n\t.writeback_luma_buffer_size_kbytes = 12,\n\t.writeback_chroma_buffer_size_kbytes = 8,\n\t.writeback_chroma_line_buffer_width_pixels = 4,\n\t.writeback_max_hscl_ratio = 1,\n\t.writeback_max_vscl_ratio = 1,\n\t.writeback_min_hscl_ratio = 1,\n\t.writeback_min_vscl_ratio = 1,\n\t.writeback_max_hscl_taps = 12,\n\t.writeback_max_vscl_taps = 12,\n\t.writeback_line_buffer_luma_buffer_size = 0,\n\t.writeback_line_buffer_chroma_buffer_size = 14643,\n\t.cursor_buffer_size = 8,\n\t.cursor_chunk_size = 2,\n\t.max_num_otg = 6,\n\t.max_num_dpp = 6,\n\t.max_num_wb = 1,\n\t.max_dchub_pscl_bw_pix_per_clk = 4,\n\t.max_pscl_lb_bw_pix_per_clk = 2,\n\t.max_lb_vscl_bw_pix_per_clk = 4,\n\t.max_vscl_hscl_bw_pix_per_clk = 4,\n\t.max_hscl_ratio = 8,\n\t.max_vscl_ratio = 8,\n\t.hscl_mults = 4,\n\t.vscl_mults = 4,\n\t.max_hscl_taps = 8,\n\t.max_vscl_taps = 8,\n\t.dispclk_ramp_margin_percent = 1,\n\t.underscan_factor = 1.10,\n\t.min_vblank_lines = 32, //\n\t.dppclk_delay_subtotal = 77, //\n\t.dppclk_delay_scl_lb_only = 16,\n\t.dppclk_delay_scl = 50,\n\t.dppclk_delay_cnvc_formatter = 8,\n\t.dppclk_delay_cnvc_cursor = 6,\n\t.dispclk_delay_subtotal = 87, //\n\t.dcfclk_cstate_latency = 10, // SRExitTime\n\t.max_inter_dcn_tile_repeaters = 8,\n\n\t.xfc_supported = true,\n\t.xfc_fill_bw_overhead_percent = 10.0,\n\t.xfc_fill_constant_bytes = 0,\n};\n\nstruct _vcs_dpi_soc_bounding_box_st dcn2_0_soc = {\n\t/* Defaults that get patched on driver load from firmware. */\n\t.clock_limits = {\n\t\t\t{\n\t\t\t\t.state = 0,\n\t\t\t\t.dcfclk_mhz = 560.0,\n\t\t\t\t.fabricclk_mhz = 560.0,\n\t\t\t\t.dispclk_mhz = 513.0,\n\t\t\t\t.dppclk_mhz = 513.0,\n\t\t\t\t.phyclk_mhz = 540.0,\n\t\t\t\t.socclk_mhz = 560.0,\n\t\t\t\t.dscclk_mhz = 171.0,\n\t\t\t\t.dram_speed_mts = 8960.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 1,\n\t\t\t\t.dcfclk_mhz = 694.0,\n\t\t\t\t.fabricclk_mhz = 694.0,\n\t\t\t\t.dispclk_mhz = 642.0,\n\t\t\t\t.dppclk_mhz = 642.0,\n\t\t\t\t.phyclk_mhz = 600.0,\n\t\t\t\t.socclk_mhz = 694.0,\n\t\t\t\t.dscclk_mhz = 214.0,\n\t\t\t\t.dram_speed_mts = 11104.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 2,\n\t\t\t\t.dcfclk_mhz = 875.0,\n\t\t\t\t.fabricclk_mhz = 875.0,\n\t\t\t\t.dispclk_mhz = 734.0,\n\t\t\t\t.dppclk_mhz = 734.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 875.0,\n\t\t\t\t.dscclk_mhz = 245.0,\n\t\t\t\t.dram_speed_mts = 14000.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 3,\n\t\t\t\t.dcfclk_mhz = 1000.0,\n\t\t\t\t.fabricclk_mhz = 1000.0,\n\t\t\t\t.dispclk_mhz = 1100.0,\n\t\t\t\t.dppclk_mhz = 1100.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 1000.0,\n\t\t\t\t.dscclk_mhz = 367.0,\n\t\t\t\t.dram_speed_mts = 16000.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 4,\n\t\t\t\t.dcfclk_mhz = 1200.0,\n\t\t\t\t.fabricclk_mhz = 1200.0,\n\t\t\t\t.dispclk_mhz = 1284.0,\n\t\t\t\t.dppclk_mhz = 1284.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 1200.0,\n\t\t\t\t.dscclk_mhz = 428.0,\n\t\t\t\t.dram_speed_mts = 16000.0,\n\t\t\t},\n\t\t\t/*Extra state, no dispclk ramping*/\n\t\t\t{\n\t\t\t\t.state = 5,\n\t\t\t\t.dcfclk_mhz = 1200.0,\n\t\t\t\t.fabricclk_mhz = 1200.0,\n\t\t\t\t.dispclk_mhz = 1284.0,\n\t\t\t\t.dppclk_mhz = 1284.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 1200.0,\n\t\t\t\t.dscclk_mhz = 428.0,\n\t\t\t\t.dram_speed_mts = 16000.0,\n\t\t\t},\n\t\t},\n\t.num_states = 5,\n\t.sr_exit_time_us = 8.6,\n\t.sr_enter_plus_exit_time_us = 10.9,\n\t.urgent_latency_us = 4.0,\n\t.urgent_latency_pixel_data_only_us = 4.0,\n\t.urgent_latency_pixel_mixed_with_vm_data_us = 4.0,\n\t.urgent_latency_vm_data_only_us = 4.0,\n\t.urgent_out_of_order_return_per_channel_pixel_only_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_pixel_and_vm_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_vm_only_bytes = 4096,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_only = 40.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm = 40.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_vm_only = 40.0,\n\t.max_avg_sdp_bw_use_normal_percent = 40.0,\n\t.max_avg_dram_bw_use_normal_percent = 40.0,\n\t.writeback_latency_us = 12.0,\n\t.ideal_dram_bw_after_urgent_percent = 40.0,\n\t.max_request_size_bytes = 256,\n\t.dram_channel_width_bytes = 2,\n\t.fabric_datapath_to_dcn_data_return_bytes = 64,\n\t.dcn_downspread_percent = 0.5,\n\t.downspread_percent = 0.38,\n\t.dram_page_open_time_ns = 50.0,\n\t.dram_rw_turnaround_time_ns = 17.5,\n\t.dram_return_buffer_per_channel_bytes = 8192,\n\t.round_trip_ping_latency_dcfclk_cycles = 131,\n\t.urgent_out_of_order_return_per_channel_bytes = 256,\n\t.channel_interleave_bytes = 256,\n\t.num_banks = 8,\n\t.num_chans = 16,\n\t.vmm_page_size_bytes = 4096,\n\t.dram_clock_change_latency_us = 404.0,\n\t.dummy_pstate_latency_us = 5.0,\n\t.writeback_dram_clock_change_latency_us = 23.0,\n\t.return_bus_width_bytes = 64,\n\t.dispclk_dppclk_vco_speed_mhz = 3850,\n\t.xfc_bus_transport_time_us = 20,\n\t.xfc_xbuf_latency_tolerance_us = 4,\n\t.use_urgent_burst_bw = 0\n};\n\nstruct _vcs_dpi_soc_bounding_box_st dcn2_0_nv12_soc = { 0 };\n\n#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL\t\t0x210f\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL\t\t0x220f\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL\t\t0x230f\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL\t\t0x240f\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL\t\t0x250f\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL\t\t0x260f\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL\t\t0x270f\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n#endif\n\n\nenum dcn20_clk_src_array_id {\n\tDCN20_CLK_SRC_PLL0,\n\tDCN20_CLK_SRC_PLL1,\n\tDCN20_CLK_SRC_PLL2,\n\tDCN20_CLK_SRC_PLL3,\n\tDCN20_CLK_SRC_PLL4,\n\tDCN20_CLK_SRC_PLL5,\n\tDCN20_CLK_SRC_TOTAL\n};\n\n/* begin *********************\n * macros to expend register list macro defined in HW object header file */\n\n/* DCN */\n/* TODO awful hack. fixup dcn20_dwb.h */\n#undef BASE_INNER\n#define BASE_INNER(seg) DCN_BASE__INST0_SEG ## seg\n\n#define BASE(seg) BASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define SRI(reg_name, block, id)\\\n\t.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n#define SRIR(var_name, reg_name, block, id)\\\n\t.var_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n#define DCCG_SRII(reg_name, block, id)\\\n\t.block ## _ ## reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n/* NBIO */\n#define NBIO_BASE_INNER(seg) \\\n\tNBIO_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE(seg) \\\n\tNBIO_BASE_INNER(seg)\n\n#define NBIO_SR(reg_name)\\\n\t\t.reg_name = NBIO_BASE(mm ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## reg_name\n\n/* MMHUB */\n#define MMHUB_BASE_INNER(seg) \\\n\tMMHUB_BASE__INST0_SEG ## seg\n\n#define MMHUB_BASE(seg) \\\n\tMMHUB_BASE_INNER(seg)\n\n#define MMHUB_SR(reg_name)\\\n\t\t.reg_name = MMHUB_BASE(mmMM ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmmMM ## reg_name\n\nstatic const struct bios_registers bios_regs = {\n\t\tNBIO_SR(BIOS_SCRATCH_3),\n\t\tNBIO_SR(BIOS_SCRATCH_6)\n};\n\n#define clk_src_regs(index, pllid)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCN2_0(index, pllid),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCN10_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCN10(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCN20_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\t\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\n#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\\\n\t\tAUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_DCN2_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5),\n};\n\nstatic const struct dcn10_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn10_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN20(_MASK)\n};\n\n\n#define aux_regs(id)\\\n[id] = {\\\n\tDCN2_AUX_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id, phyid)\\\n[id] = {\\\n\tLE_DCN10_REG_LIST(id), \\\n\tUNIPHY_DCN2_REG_LIST(phyid), \\\n\tSRI(DP_DPHY_INTERNAL_CTRL, DP, id) \\\n}\n\nstatic const struct dcn10_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0, A),\n\tlink_regs(1, B),\n\tlink_regs(2, C),\n\tlink_regs(3, D),\n\tlink_regs(4, E),\n\tlink_regs(5, F)\n};\n\nstatic const struct dcn10_link_enc_shift le_shift = {\n\tLINK_ENCODER_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn10_link_enc_mask le_mask = {\n\tLINK_ENCODER_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\tIPP_REG_LIST_DCN20(id),\\\n}\n\nstatic const struct dcn10_ipp_registers ipp_regs[] = {\n\tipp_regs(0),\n\tipp_regs(1),\n\tipp_regs(2),\n\tipp_regs(3),\n\tipp_regs(4),\n\tipp_regs(5),\n};\n\nstatic const struct dcn10_ipp_shift ipp_shift = {\n\t\tIPP_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn10_ipp_mask ipp_mask = {\n\t\tIPP_MASK_SH_LIST_DCN20(_MASK),\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_REG_LIST_DCN20(id),\\\n}\n\nstatic const struct dcn20_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5),\n};\n\nstatic const struct dcn20_opp_shift opp_shift = {\n\t\tOPP_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn20_opp_mask opp_mask = {\n\t\tOPP_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST0(id), \\\n\t.AUXN_IMPCAL = 0, \\\n\t.AUXP_IMPCAL = 0, \\\n\t.AUX_RESET_MASK = DP_AUX0_AUX_CONTROL__AUX_RESET_MASK, \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define tf_regs(id)\\\n[id] = {\\\n\tTF_REG_LIST_DCN20(id),\\\n}\n\nstatic const struct dcn2_dpp_registers tf_regs[] = {\n\ttf_regs(0),\n\ttf_regs(1),\n\ttf_regs(2),\n\ttf_regs(3),\n\ttf_regs(4),\n\ttf_regs(5),\n};\n\nstatic const struct dcn2_dpp_shift tf_shift = {\n\t\tTF_REG_LIST_SH_MASK_DCN20(__SHIFT)\n};\n\nstatic const struct dcn2_dpp_mask tf_mask = {\n\t\tTF_REG_LIST_SH_MASK_DCN20(_MASK)\n};\n\n#define dwbc_regs_dcn2(id)\\\n[id] = {\\\n\tDWBC_COMMON_REG_LIST_DCN2_0(id),\\\n\t\t}\n\nstatic const struct dcn20_dwbc_registers dwbc20_regs[] = {\n\tdwbc_regs_dcn2(0),\n};\n\nstatic const struct dcn20_dwbc_shift dwbc20_shift = {\n\tDWBC_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn20_dwbc_mask dwbc20_mask = {\n\tDWBC_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\n#define mcif_wb_regs_dcn2(id)\\\n[id] = {\\\n\tMCIF_WB_COMMON_REG_LIST_DCN2_0(id),\\\n\t\t}\n\nstatic const struct dcn20_mmhubbub_registers mcif_wb20_regs[] = {\n\tmcif_wb_regs_dcn2(0),\n};\n\nstatic const struct dcn20_mmhubbub_shift mcif_wb20_shift = {\n\tMCIF_WB_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn20_mmhubbub_mask mcif_wb20_mask = {\n\tMCIF_WB_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\nstatic const struct dcn20_mpc_registers mpc_regs = {\n\t\tMPC_REG_LIST_DCN2_0(0),\n\t\tMPC_REG_LIST_DCN2_0(1),\n\t\tMPC_REG_LIST_DCN2_0(2),\n\t\tMPC_REG_LIST_DCN2_0(3),\n\t\tMPC_REG_LIST_DCN2_0(4),\n\t\tMPC_REG_LIST_DCN2_0(5),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(0),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(1),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(2),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(3),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(4),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(5),\n};\n\nstatic const struct dcn20_mpc_shift mpc_shift = {\n\tMPC_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn20_mpc_mask mpc_mask = {\n\tMPC_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\n#define tg_regs(id)\\\n[id] = {TG_COMMON_REG_LIST_DCN2_0(id)}\n\n\nstatic const struct dcn_optc_registers tg_regs[] = {\n\ttg_regs(0),\n\ttg_regs(1),\n\ttg_regs(2),\n\ttg_regs(3),\n\ttg_regs(4),\n\ttg_regs(5)\n};\n\nstatic const struct dcn_optc_shift tg_shift = {\n\tTG_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn_optc_mask tg_mask = {\n\tTG_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\n#define hubp_regs(id)\\\n[id] = {\\\n\tHUBP_REG_LIST_DCN20(id)\\\n}\n\nstatic const struct dcn_hubp2_registers hubp_regs[] = {\n\t\thubp_regs(0),\n\t\thubp_regs(1),\n\t\thubp_regs(2),\n\t\thubp_regs(3),\n\t\thubp_regs(4),\n\t\thubp_regs(5)\n};\n\nstatic const struct dcn_hubp2_shift hubp_shift = {\n\t\tHUBP_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn_hubp2_mask hubp_mask = {\n\t\tHUBP_MASK_SH_LIST_DCN20(_MASK)\n};\n\nstatic const struct dcn_hubbub_registers hubbub_reg = {\n\t\tHUBBUB_REG_LIST_DCN20(0)\n};\n\nstatic const struct dcn_hubbub_shift hubbub_shift = {\n\t\tHUBBUB_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn_hubbub_mask hubbub_mask = {\n\t\tHUBBUB_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define vmid_regs(id)\\\n[id] = {\\\n\t\tDCN20_VMID_REG_LIST(id)\\\n}\n\nstatic const struct dcn_vmid_registers vmid_regs[] = {\n\tvmid_regs(0),\n\tvmid_regs(1),\n\tvmid_regs(2),\n\tvmid_regs(3),\n\tvmid_regs(4),\n\tvmid_regs(5),\n\tvmid_regs(6),\n\tvmid_regs(7),\n\tvmid_regs(8),\n\tvmid_regs(9),\n\tvmid_regs(10),\n\tvmid_regs(11),\n\tvmid_regs(12),\n\tvmid_regs(13),\n\tvmid_regs(14),\n\tvmid_regs(15)\n};\n\nstatic const struct dcn20_vmid_shift vmid_shifts = {\n\t\tDCN20_VMID_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dcn20_vmid_mask vmid_masks = {\n\t\tDCN20_VMID_MASK_SH_LIST(_MASK)\n};\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n#define dsc_regsDCN20(id)\\\n[id] = {\\\n\tDSC_REG_LIST_DCN20(id)\\\n}\n\nstatic const struct dcn20_dsc_registers dsc_regs[] = {\n\tdsc_regsDCN20(0),\n\tdsc_regsDCN20(1),\n\tdsc_regsDCN20(2),\n\tdsc_regsDCN20(3),\n\tdsc_regsDCN20(4),\n\tdsc_regsDCN20(5)\n};\n\nstatic const struct dcn20_dsc_shift dsc_shift = {\n\tDSC_REG_LIST_SH_MASK_DCN20(__SHIFT)\n};\n\nstatic const struct dcn20_dsc_mask dsc_mask = {\n\tDSC_REG_LIST_SH_MASK_DCN20(_MASK)\n};\n#endif\n\nstatic const struct dccg_registers dccg_regs = {\n\t\tDCCG_REG_LIST_DCN2()\n};\n\nstatic const struct dccg_shift dccg_shift = {\n\t\tDCCG_MASK_SH_LIST_DCN2(__SHIFT)\n};\n\nstatic const struct dccg_mask dccg_mask = {\n\t\tDCCG_MASK_SH_LIST_DCN2(_MASK)\n};\n\nstatic const struct resource_caps res_cap_nv10 = {\n\t\t.num_timing_generator = 6,\n\t\t.num_opp = 6,\n\t\t.num_video_plane = 6,\n\t\t.num_audio = 7,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 6,\n\t\t.num_dwb = 1,\n\t\t.num_ddc = 6,\n\t\t.num_vmid = 16,\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t\t.num_dsc = 6,\n#endif\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCN_UNIVERSAL,\n\t.blends_with_above = true,\n\t.blends_with_below = true,\n\t.per_pixel_alpha = true,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = true,\n\t\t\t.fp16 = true\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 16000,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 250,\n\t\t\t.fp16 = 1\n\t}\n};\nstatic const struct resource_caps res_cap_nv14 = {\n\t\t.num_timing_generator = 5,\n\t\t.num_opp = 5,\n\t\t.num_video_plane = 5,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 5,\n\t\t.num_pll = 5,\n\t\t.num_dwb = 0,\n\t\t.num_ddc = 5,\n};\n\nstatic const struct dc_debug_options debug_defaults_drv = {\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = false,\n\t\t.clock_trace = true,\n\t\t.disable_pplib_clock_request = true,\n\t\t.pipe_split_policy = MPC_SPLIT_DYNAMIC,\n\t\t.force_single_disp_pipe_split = true,\n\t\t.disable_dcc = DCC_ENABLE,\n\t\t.vsr_support = true,\n\t\t.performance_trace = false,\n\t\t.max_downscale_src_width = 5120,/*upto 5K*/\n\t\t.disable_pplib_wm_range = false,\n\t\t.scl_reset_length10 = true,\n\t\t.sanity_checks = false,\n\t\t.disable_tri_buf = true,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nstatic const struct dc_debug_options debug_defaults_diags = {\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = true,\n\t\t.clock_trace = true,\n\t\t.disable_dpp_power_gate = true,\n\t\t.disable_hubp_power_gate = true,\n\t\t.disable_clock_gate = true,\n\t\t.disable_pplib_clock_request = true,\n\t\t.disable_pplib_wm_range = true,\n\t\t.disable_stutter = true,\n\t\t.scl_reset_length10 = true,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nvoid dcn20_dpp_destroy(struct dpp **dpp)\n{\n\tkfree(TO_DCN20_DPP(*dpp));\n\t*dpp = NULL;\n}\n\nstruct dpp *dcn20_dpp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn20_dpp *dpp =\n\t\tkzalloc(sizeof(struct dcn20_dpp), GFP_KERNEL);\n\n\tif (!dpp)\n\t\treturn NULL;\n\n\tif (dpp2_construct(dpp, ctx, inst,\n\t\t\t&tf_regs[inst], &tf_shift, &tf_mask))\n\t\treturn &dpp->base;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(dpp);\n\treturn NULL;\n}\n\nstruct input_pixel_processor *dcn20_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn10_ipp *ipp =\n\t\tkzalloc(sizeof(struct dcn10_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn20_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\n\nstruct output_pixel_processor *dcn20_opp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn20_opp *opp =\n\t\tkzalloc(sizeof(struct dcn20_opp), GFP_KERNEL);\n\n\tif (!opp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn20_opp_construct(opp, ctx, inst,\n\t\t\t&opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dcn20_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCN2(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCN2(_MASK)\n};\n\nstruct dce_i2c_hw *dcn20_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdcn2_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct mpc *dcn20_mpc_create(struct dc_context *ctx)\n{\n\tstruct dcn20_mpc *mpc20 = kzalloc(sizeof(struct dcn20_mpc),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!mpc20)\n\t\treturn NULL;\n\n\tdcn20_mpc_construct(mpc20, ctx,\n\t\t\t&mpc_regs,\n\t\t\t&mpc_shift,\n\t\t\t&mpc_mask,\n\t\t\t6);\n\n\treturn &mpc20->base;\n}\n\nstruct hubbub *dcn20_hubbub_create(struct dc_context *ctx)\n{\n\tint i;\n\tstruct dcn20_hubbub *hubbub = kzalloc(sizeof(struct dcn20_hubbub),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!hubbub)\n\t\treturn NULL;\n\n\thubbub2_construct(hubbub, ctx,\n\t\t\t&hubbub_reg,\n\t\t\t&hubbub_shift,\n\t\t\t&hubbub_mask);\n\n\tfor (i = 0; i < res_cap_nv10.num_vmid; i++) {\n\t\tstruct dcn20_vmid *vmid = &hubbub->vmid[i];\n\n\t\tvmid->ctx = ctx;\n\n\t\tvmid->regs = &vmid_regs[i];\n\t\tvmid->shifts = &vmid_shifts;\n\t\tvmid->masks = &vmid_masks;\n\t}\n\n\treturn &hubbub->base;\n}\n\nstruct timing_generator *dcn20_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance)\n{\n\tstruct optc *tgn10 =\n\t\tkzalloc(sizeof(struct optc), GFP_KERNEL);\n\n\tif (!tgn10)\n\t\treturn NULL;\n\n\ttgn10->base.inst = instance;\n\ttgn10->base.ctx = ctx;\n\n\ttgn10->tg_regs = &tg_regs[instance];\n\ttgn10->tg_shift = &tg_shift;\n\ttgn10->tg_mask = &tg_mask;\n\n\tdcn20_timing_generator_init(tgn10);\n\n\treturn &tgn10->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = true,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstruct link_encoder *dcn20_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dcn20_link_encoder *enc20 =\n\t\tkzalloc(sizeof(struct dcn20_link_encoder), GFP_KERNEL);\n\n\tif (!enc20)\n\t\treturn NULL;\n\n\tdcn20_link_encoder_construct(enc20,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source],\n\t\t\t\t      &le_shift,\n\t\t\t\t      &le_mask);\n\n\treturn &enc20->enc10.base;\n}\n\nstruct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tgeneric_reg_get(ctx, mmDC_PINSTRAPS + BASE(mmDC_PINSTRAPS_BASE_IDX),\n\t\tFN(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO), &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *dcn20_create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstruct stream_encoder *dcn20_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn10_stream_encoder *enc1 =\n\t\tkzalloc(sizeof(struct dcn10_stream_encoder), GFP_KERNEL);\n\n\tif (!enc1)\n\t\treturn NULL;\n\n\tdcn20_stream_encoder_construct(enc1, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\n\treturn &enc1->base;\n}\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCN2_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCN2_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCN2_MASK_SH_LIST(_MASK)\n};\n\nstruct dce_hwseq *dcn20_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = dcn20_create_audio,\n\t.create_stream_encoder = dcn20_stream_encoder_create,\n\t.create_hwseq = dcn20_hwseq_create,\n};\n\nstatic const struct resource_create_funcs res_create_maximus_funcs = {\n\t.read_dce_straps = NULL,\n\t.create_audio = NULL,\n\t.create_stream_encoder = NULL,\n\t.create_hwseq = dcn20_hwseq_create,\n};\n\nvoid dcn20_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\nstruct display_stream_compressor *dcn20_dsc_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn20_dsc *dsc =\n\t\tkzalloc(sizeof(struct dcn20_dsc), GFP_KERNEL);\n\n\tif (!dsc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdsc2_construct(dsc, ctx, inst, &dsc_regs[inst], &dsc_shift, &dsc_mask);\n\treturn &dsc->base;\n}\n\nvoid dcn20_dsc_destroy(struct display_stream_compressor **dsc)\n{\n\tkfree(container_of(*dsc, struct dcn20_dsc, base));\n\t*dsc = NULL;\n}\n\n#endif\n\nstatic void destruct(struct dcn20_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL) {\n\t\t\tkfree(DCN10STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t\t\tpool->base.stream_enc[i] = NULL;\n\t\t}\n\t}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tfor (i = 0; i < pool->base.res_cap->num_dsc; i++) {\n\t\tif (pool->base.dscs[i] != NULL)\n\t\t\tdcn20_dsc_destroy(&pool->base.dscs[i]);\n\t}\n#endif\n\n\tif (pool->base.mpc != NULL) {\n\t\tkfree(TO_DCN20_MPC(pool->base.mpc));\n\t\tpool->base.mpc = NULL;\n\t}\n\tif (pool->base.hubbub != NULL) {\n\t\tkfree(pool->base.hubbub);\n\t\tpool->base.hubbub = NULL;\n\t}\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.dpps[i] != NULL)\n\t\t\tdcn20_dpp_destroy(&pool->base.dpps[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tpool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.hubps[i] != NULL) {\n\t\t\tkfree(TO_DCN20_HUBP(pool->base.hubps[i]));\n\t\t\tpool->base.hubps[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.irqs != NULL) {\n\t\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_opp; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tpool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_timing_generator; i++) {\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCN10TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_dwb; i++) {\n\t\tif (pool->base.dwbc[i] != NULL) {\n\t\t\tkfree(TO_DCN20_DWBC(pool->base.dwbc[i]));\n\t\t\tpool->base.dwbc[i] = NULL;\n\t\t}\n\t\tif (pool->base.mcif_wb[i] != NULL) {\n\t\t\tkfree(TO_DCN20_MMHUBBUB(pool->base.mcif_wb[i]));\n\t\t\tpool->base.mcif_wb[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.audio_count; i++) {\n\t\tif (pool->base.audios[i])\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdcn20_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t\tpool->base.clock_sources[i] = NULL;\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL) {\n\t\tdcn20_clock_source_destroy(&pool->base.dp_clock_source);\n\t\tpool->base.dp_clock_source = NULL;\n\t}\n\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.dccg != NULL)\n\t\tdcn_dccg_destroy(&pool->base.dccg);\n\n\tif (pool->base.pp_smu != NULL)\n\t\tdcn20_pp_smu_destroy(&pool->base.pp_smu);\n\n}\n\nstruct hubp *dcn20_hubp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn20_hubp *hubp2 =\n\t\tkzalloc(sizeof(struct dcn20_hubp), GFP_KERNEL);\n\n\tif (!hubp2)\n\t\treturn NULL;\n\n\tif (hubp2_construct(hubp2, ctx, inst,\n\t\t\t&hubp_regs[inst], &hubp_shift, &hubp_mask))\n\t\treturn &hubp2->base;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(hubp2);\n\treturn NULL;\n}\n\nstatic void get_pixel_clock_parameters(\n\tstruct pipe_ctx *pipe_ctx,\n\tstruct pixel_clk_params *pixel_clk_params)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\topp_cnt++;\n\n\tpixel_clk_params->requested_pix_clk_100hz = stream->timing.pix_clk_100hz;\n\tpixel_clk_params->encoder_object_id = stream->link->link_enc->id;\n\tpixel_clk_params->signal_type = pipe_ctx->stream->signal;\n\tpixel_clk_params->controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\t/* TODO: un-hardcode*/\n\tpixel_clk_params->requested_sym_clk = LINK_RATE_LOW *\n\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\tpixel_clk_params->flags.ENABLE_SS = 0;\n\tpixel_clk_params->color_depth =\n\t\tstream->timing.display_color_depth;\n\tpixel_clk_params->flags.DISPLAY_BLANKED = 1;\n\tpixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;\n\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\tpixel_clk_params->color_depth = COLOR_DEPTH_888;\n\n\tif (opp_cnt == 4)\n\t\tpixel_clk_params->requested_pix_clk_100hz /= 4;\n\telse if (optc1_is_two_pixels_per_containter(&stream->timing) || opp_cnt == 2)\n\t\tpixel_clk_params->requested_pix_clk_100hz /= 2;\n\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tpixel_clk_params->requested_pix_clk_100hz *= 2;\n\n}\n\nstatic void build_clamping_params(struct dc_stream_state *stream)\n{\n\tstream->clamping.clamping_level = CLAMPING_FULL_RANGE;\n\tstream->clamping.c_depth = stream->timing.display_color_depth;\n\tstream->clamping.pixel_encoding = stream->timing.pixel_encoding;\n}\n\nstatic enum dc_status build_pipe_hw_param(struct pipe_ctx *pipe_ctx)\n{\n\n\tget_pixel_clock_parameters(pipe_ctx, &pipe_ctx->stream_res.pix_clk_params);\n\n\tpipe_ctx->clock_source->funcs->get_pix_clk_dividers(\n\t\tpipe_ctx->clock_source,\n\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t&pipe_ctx->pll_settings);\n\n\tpipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;\n\n\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t\t\t&pipe_ctx->stream->bit_depth_params);\n\tbuild_clamping_params(pipe_ctx->stream);\n\n\treturn DC_OK;\n}\n\nenum dc_status dcn20_build_mapped_resource(const struct dc *dc, struct dc_state *context, struct dc_stream_state *stream)\n{\n\tenum dc_status status = DC_OK;\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\t/*TODO Seems unneeded anymore */\n\t/*\tif (old_context && resource_is_stream_unchanged(old_context, stream)) {\n\t\t\tif (stream != NULL && old_context->streams[i] != NULL) {\n\t\t\t\t todo: shouldn't have to copy missing parameter here\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tstream->clamping.pixel_encoding =\n\t\t\t\t\t\tstream->timing.pixel_encoding;\n\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tbuild_clamping_params(stream);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t*/\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\n\tstatus = build_pipe_hw_param(pipe_ctx);\n\n\treturn status;\n}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\nstatic void acquire_dsc(struct resource_context *res_ctx,\n\t\t\tconst struct resource_pool *pool,\n\t\t\tstruct display_stream_compressor **dsc)\n{\n\tint i;\n\n\tASSERT(*dsc == NULL);\n\t*dsc = NULL;\n\n\t/* Find first free DSC */\n\tfor (i = 0; i < pool->res_cap->num_dsc; i++)\n\t\tif (!res_ctx->is_dsc_acquired[i]) {\n\t\t\t*dsc = pool->dscs[i];\n\t\t\tres_ctx->is_dsc_acquired[i] = true;\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void release_dsc(struct resource_context *res_ctx,\n\t\t\tconst struct resource_pool *pool,\n\t\t\tstruct display_stream_compressor **dsc)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->res_cap->num_dsc; i++)\n\t\tif (pool->dscs[i] == *dsc) {\n\t\t\tres_ctx->is_dsc_acquired[i] = false;\n\t\t\t*dsc = NULL;\n\t\t\tbreak;\n\t\t}\n}\n\n#endif\n\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\nstatic enum dc_status add_dsc_to_stream_resource(struct dc *dc,\n\t\tstruct dc_state *dc_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_OK;\n\tint i;\n\tconst struct resource_pool *pool = dc->res_pool;\n\n\t/* Get a DSC if required and available */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &dc_ctx->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream != dc_stream)\n\t\t\tcontinue;\n\n\t\tacquire_dsc(&dc_ctx->res_ctx, pool, &pipe_ctx->stream_res.dsc);\n\n\t\t/* The number of DSCs can be less than the number of pipes */\n\t\tif (!pipe_ctx->stream_res.dsc) {\n\t\t\tdm_output_to_console(\"No DSCs available\\n\");\n\t\t\tresult = DC_NO_DSC_RESOURCE;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n\nstatic enum dc_status remove_dsc_from_stream_resource(struct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (new_ctx->res_ctx.pipe_ctx[i].stream == dc_stream && !new_ctx->res_ctx.pipe_ctx[i].top_pipe) {\n\t\t\tpipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe_ctx->stream_res.dsc)\n\t\t\t\trelease_dsc(&new_ctx->res_ctx, dc->res_pool, &pipe_ctx->stream_res.dsc);\n\t\t}\n\t}\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\telse\n\t\treturn DC_OK;\n}\n#endif\n\n\nenum dc_status dcn20_add_stream_to_ctx(struct dc *dc, struct dc_state *new_ctx, struct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t/* Get a DSC if required and available */\n\tif (result == DC_OK && dc_stream->timing.flags.DSC)\n\t\tresult = add_dsc_to_stream_resource(dc, new_ctx, dc_stream);\n#endif\n\n\tif (result == DC_OK)\n\t\tresult = dcn20_build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\n\nenum dc_status dcn20_remove_stream_from_ctx(struct dc *dc, struct dc_state *new_ctx, struct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_OK;\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tresult = remove_dsc_from_stream_resource(dc, new_ctx, dc_stream);\n#endif\n\n\treturn result;\n}\n\n\nstatic void swizzle_to_dml_params(\n\t\tenum swizzle_mode_values swizzle,\n\t\tunsigned int *sw_mode)\n{\n\tswitch (swizzle) {\n\tcase DC_SW_LINEAR:\n\t\t*sw_mode = dm_sw_linear;\n\t\tbreak;\n\tcase DC_SW_4KB_S:\n\t\t*sw_mode = dm_sw_4kb_s;\n\t\tbreak;\n\tcase DC_SW_4KB_S_X:\n\t\t*sw_mode = dm_sw_4kb_s_x;\n\t\tbreak;\n\tcase DC_SW_4KB_D:\n\t\t*sw_mode = dm_sw_4kb_d;\n\t\tbreak;\n\tcase DC_SW_4KB_D_X:\n\t\t*sw_mode = dm_sw_4kb_d_x;\n\t\tbreak;\n\tcase DC_SW_64KB_S:\n\t\t*sw_mode = dm_sw_64kb_s;\n\t\tbreak;\n\tcase DC_SW_64KB_S_X:\n\t\t*sw_mode = dm_sw_64kb_s_x;\n\t\tbreak;\n\tcase DC_SW_64KB_S_T:\n\t\t*sw_mode = dm_sw_64kb_s_t;\n\t\tbreak;\n\tcase DC_SW_64KB_D:\n\t\t*sw_mode = dm_sw_64kb_d;\n\t\tbreak;\n\tcase DC_SW_64KB_D_X:\n\t\t*sw_mode = dm_sw_64kb_d_x;\n\t\tbreak;\n\tcase DC_SW_64KB_D_T:\n\t\t*sw_mode = dm_sw_64kb_d_t;\n\t\tbreak;\n\tcase DC_SW_64KB_R_X:\n\t\t*sw_mode = dm_sw_64kb_r_x;\n\t\tbreak;\n\tcase DC_SW_VAR_S:\n\t\t*sw_mode = dm_sw_var_s;\n\t\tbreak;\n\tcase DC_SW_VAR_S_X:\n\t\t*sw_mode = dm_sw_var_s_x;\n\t\tbreak;\n\tcase DC_SW_VAR_D:\n\t\t*sw_mode = dm_sw_var_d;\n\t\tbreak;\n\tcase DC_SW_VAR_D_X:\n\t\t*sw_mode = dm_sw_var_d_x;\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0); /* Not supported */\n\t\tbreak;\n\t}\n}\n\nstatic bool dcn20_split_stream_for_odm(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct pipe_ctx *prev_odm_pipe,\n\t\tstruct pipe_ctx *next_odm_pipe)\n{\n\tint pipe_idx = next_odm_pipe->pipe_idx;\n\n\t*next_odm_pipe = *prev_odm_pipe;\n\n\tnext_odm_pipe->pipe_idx = pipe_idx;\n\tnext_odm_pipe->plane_res.mi = pool->mis[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.hubp = pool->hubps[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.ipp = pool->ipps[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.xfm = pool->transforms[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.dpp = pool->dpps[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.mpcc_inst = pool->dpps[next_odm_pipe->pipe_idx]->inst;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tnext_odm_pipe->stream_res.dsc = NULL;\n#endif\n\tif (prev_odm_pipe->next_odm_pipe && prev_odm_pipe->next_odm_pipe != next_odm_pipe) {\n\t\tASSERT(!next_odm_pipe->next_odm_pipe);\n\t\tnext_odm_pipe->next_odm_pipe = prev_odm_pipe->next_odm_pipe;\n\t\tnext_odm_pipe->next_odm_pipe->prev_odm_pipe = next_odm_pipe;\n\t}\n\tprev_odm_pipe->next_odm_pipe = next_odm_pipe;\n\tnext_odm_pipe->prev_odm_pipe = prev_odm_pipe;\n\tASSERT(next_odm_pipe->top_pipe == NULL);\n\n\tif (prev_odm_pipe->plane_state) {\n\t\tstruct scaler_data *sd = &prev_odm_pipe->plane_res.scl_data;\n\t\tint new_width;\n\n\t\t/* HACTIVE halved for odm combine */\n\t\tsd->h_active /= 2;\n\t\t/* Calculate new vp and recout for left pipe */\n\t\t/* Need at least 16 pixels width per side */\n\t\tif (sd->recout.x + 16 >= sd->h_active)\n\t\t\treturn false;\n\t\tnew_width = sd->h_active - sd->recout.x;\n\t\tsd->viewport.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz, sd->recout.width - new_width));\n\t\tsd->viewport_c.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz_c, sd->recout.width - new_width));\n\t\tsd->recout.width = new_width;\n\n\t\t/* Calculate new vp and recout for right pipe */\n\t\tsd = &next_odm_pipe->plane_res.scl_data;\n\t\t/* HACTIVE halved for odm combine */\n\t\tsd->h_active /= 2;\n\t\t/* Need at least 16 pixels width per side */\n\t\tif (new_width <= 16)\n\t\t\treturn false;\n\t\tnew_width = sd->recout.width + sd->recout.x - sd->h_active;\n\t\tsd->viewport.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz, sd->recout.width - new_width));\n\t\tsd->viewport_c.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz_c, sd->recout.width - new_width));\n\t\tsd->recout.width = new_width;\n\t\tsd->viewport.x += dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz, sd->h_active - sd->recout.x));\n\t\tsd->viewport_c.x += dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz_c, sd->h_active - sd->recout.x));\n\t\tsd->recout.x = 0;\n\t}\n\tnext_odm_pipe->stream_res.opp = pool->opps[next_odm_pipe->pipe_idx];\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tif (next_odm_pipe->stream->timing.flags.DSC == 1) {\n\t\tacquire_dsc(res_ctx, pool, &next_odm_pipe->stream_res.dsc);\n\t\tASSERT(next_odm_pipe->stream_res.dsc);\n\t\tif (next_odm_pipe->stream_res.dsc == NULL)\n\t\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}\n\nstatic void dcn20_split_stream_for_mpc(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct pipe_ctx *primary_pipe,\n\t\tstruct pipe_ctx *secondary_pipe)\n{\n\tint pipe_idx = secondary_pipe->pipe_idx;\n\tstruct pipe_ctx *sec_bot_pipe = secondary_pipe->bottom_pipe;\n\n\t*secondary_pipe = *primary_pipe;\n\tsecondary_pipe->bottom_pipe = sec_bot_pipe;\n\n\tsecondary_pipe->pipe_idx = pipe_idx;\n\tsecondary_pipe->plane_res.mi = pool->mis[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.hubp = pool->hubps[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.ipp = pool->ipps[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.xfm = pool->transforms[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.dpp = pool->dpps[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.mpcc_inst = pool->dpps[secondary_pipe->pipe_idx]->inst;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tsecondary_pipe->stream_res.dsc = NULL;\n#endif\n\tif (primary_pipe->bottom_pipe && primary_pipe->bottom_pipe != secondary_pipe) {\n\t\tASSERT(!secondary_pipe->bottom_pipe);\n\t\tsecondary_pipe->bottom_pipe = primary_pipe->bottom_pipe;\n\t\tsecondary_pipe->bottom_pipe->top_pipe = secondary_pipe;\n\t}\n\tprimary_pipe->bottom_pipe = secondary_pipe;\n\tsecondary_pipe->top_pipe = primary_pipe;\n\n\tASSERT(primary_pipe->plane_state);\n\tresource_build_scaling_params(primary_pipe);\n\tresource_build_scaling_params(secondary_pipe);\n}\n\nvoid dcn20_populate_dml_writeback_from_context(\n\t\tstruct dc *dc, struct resource_context *res_ctx, display_e2e_pipe_params_st *pipes)\n{\n\tint pipe_cnt, i;\n\n\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_writeback_info *wb_info = &res_ctx->pipe_ctx[i].stream->writeback_info[0];\n\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\t/* Set writeback information */\n\t\tpipes[pipe_cnt].dout.wb_enable = (wb_info->wb_enabled == true) ? 1 : 0;\n\t\tpipes[pipe_cnt].dout.num_active_wb++;\n\t\tpipes[pipe_cnt].dout.wb.wb_src_height = wb_info->dwb_params.cnv_params.crop_height;\n\t\tpipes[pipe_cnt].dout.wb.wb_src_width = wb_info->dwb_params.cnv_params.crop_width;\n\t\tpipes[pipe_cnt].dout.wb.wb_dst_width = wb_info->dwb_params.dest_width;\n\t\tpipes[pipe_cnt].dout.wb.wb_dst_height = wb_info->dwb_params.dest_height;\n\t\tpipes[pipe_cnt].dout.wb.wb_htaps_luma = 1;\n\t\tpipes[pipe_cnt].dout.wb.wb_vtaps_luma = 1;\n\t\tpipes[pipe_cnt].dout.wb.wb_htaps_chroma = wb_info->dwb_params.scaler_taps.h_taps_c;\n\t\tpipes[pipe_cnt].dout.wb.wb_vtaps_chroma = wb_info->dwb_params.scaler_taps.v_taps_c;\n\t\tpipes[pipe_cnt].dout.wb.wb_hratio = 1.0;\n\t\tpipes[pipe_cnt].dout.wb.wb_vratio = 1.0;\n\t\tif (wb_info->dwb_params.out_format == dwb_scaler_mode_yuv420) {\n\t\t\tif (wb_info->dwb_params.output_depth == DWB_OUTPUT_PIXEL_DEPTH_8BPC)\n\t\t\t\tpipes[pipe_cnt].dout.wb.wb_pixel_format = dm_420_8;\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].dout.wb.wb_pixel_format = dm_420_10;\n\t\t} else\n\t\t\tpipes[pipe_cnt].dout.wb.wb_pixel_format = dm_444_32;\n\n\t\tpipe_cnt++;\n\t}\n\n}\n\nint dcn20_populate_dml_pipes_from_context(\n\t\tstruct dc *dc, struct resource_context *res_ctx, display_e2e_pipe_params_st *pipes)\n{\n\tint pipe_cnt, i;\n\tbool synchronized_vblank = true;\n\n\tfor (i = 0, pipe_cnt = -1; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tif (pipe_cnt < 0) {\n\t\t\tpipe_cnt = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!resource_are_streams_timing_synchronizable(\n\t\t\t\tres_ctx->pipe_ctx[pipe_cnt].stream,\n\t\t\t\tres_ctx->pipe_ctx[i].stream)) {\n\t\t\tsynchronized_vblank = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_crtc_timing *timing = &res_ctx->pipe_ctx[i].stream->timing;\n\t\tint output_bpc;\n\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\t/* todo:\n\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_enable = 0;\n\t\tpipes[pipe_cnt].pipe.src.dcc = 0;\n\t\tpipes[pipe_cnt].pipe.src.vm = 0;*/\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t\tpipes[pipe_cnt].dout.dsc_enable = res_ctx->pipe_ctx[i].stream->timing.flags.DSC;\n\t\t/* todo: rotation?*/\n\t\tpipes[pipe_cnt].dout.dsc_slices = res_ctx->pipe_ctx[i].stream->timing.dsc_cfg.num_slices_h;\n#endif\n\t\tif (res_ctx->pipe_ctx[i].stream->use_dynamic_meta) {\n\t\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_enable = true;\n\t\t\t/* 1/2 vblank */\n\t\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_lines_before_active =\n\t\t\t\t(timing->v_total - timing->v_addressable\n\t\t\t\t\t- timing->v_border_top - timing->v_border_bottom) / 2;\n\t\t\t/* 36 bytes dp, 32 hdmi */\n\t\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_xmit_bytes =\n\t\t\t\tdc_is_dp_signal(res_ctx->pipe_ctx[i].stream->signal) ? 36 : 32;\n\t\t}\n\t\tpipes[pipe_cnt].pipe.src.dcc = false;\n\t\tpipes[pipe_cnt].pipe.src.dcc_rate = 1;\n\t\tpipes[pipe_cnt].pipe.dest.synchronized_vblank_all_planes = synchronized_vblank;\n\t\tpipes[pipe_cnt].pipe.dest.hblank_start = timing->h_total - timing->h_front_porch;\n\t\tpipes[pipe_cnt].pipe.dest.hblank_end = pipes[pipe_cnt].pipe.dest.hblank_start\n\t\t\t\t- timing->h_addressable\n\t\t\t\t- timing->h_border_left\n\t\t\t\t- timing->h_border_right;\n\t\tpipes[pipe_cnt].pipe.dest.vblank_start = timing->v_total - timing->v_front_porch;\n\t\tpipes[pipe_cnt].pipe.dest.vblank_end = pipes[pipe_cnt].pipe.dest.vblank_start\n\t\t\t\t- timing->v_addressable\n\t\t\t\t- timing->v_border_top\n\t\t\t\t- timing->v_border_bottom;\n\t\tpipes[pipe_cnt].pipe.dest.htotal = timing->h_total;\n\t\tpipes[pipe_cnt].pipe.dest.vtotal = timing->v_total;\n\t\tpipes[pipe_cnt].pipe.dest.hactive = timing->h_addressable;\n\t\tpipes[pipe_cnt].pipe.dest.vactive = timing->v_addressable;\n\t\tpipes[pipe_cnt].pipe.dest.interlaced = timing->flags.INTERLACE;\n\t\tpipes[pipe_cnt].pipe.dest.pixel_rate_mhz = timing->pix_clk_100hz/10000.0;\n\t\tif (timing->timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\t\tpipes[pipe_cnt].pipe.dest.pixel_rate_mhz *= 2;\n\t\tpipes[pipe_cnt].pipe.dest.otg_inst = res_ctx->pipe_ctx[i].stream_res.tg->inst;\n\t\tpipes[pipe_cnt].dout.dp_lanes = 4;\n\t\tpipes[pipe_cnt].pipe.dest.vtotal_min = res_ctx->pipe_ctx[i].stream->adjust.v_total_min;\n\t\tpipes[pipe_cnt].pipe.dest.vtotal_max = res_ctx->pipe_ctx[i].stream->adjust.v_total_max;\n\t\tpipes[pipe_cnt].pipe.dest.odm_combine = res_ctx->pipe_ctx[i].prev_odm_pipe\n\t\t\t\t\t\t\t|| res_ctx->pipe_ctx[i].next_odm_pipe;\n\t\tpipes[pipe_cnt].pipe.src.hsplit_grp = res_ctx->pipe_ctx[i].pipe_idx;\n\t\tif (res_ctx->pipe_ctx[i].top_pipe && res_ctx->pipe_ctx[i].top_pipe->plane_state\n\t\t\t\t== res_ctx->pipe_ctx[i].plane_state)\n\t\t\tpipes[pipe_cnt].pipe.src.hsplit_grp = res_ctx->pipe_ctx[i].top_pipe->pipe_idx;\n\t\telse if (res_ctx->pipe_ctx[i].prev_odm_pipe) {\n\t\t\tstruct pipe_ctx *first_pipe = res_ctx->pipe_ctx[i].prev_odm_pipe;\n\n\t\t\twhile (first_pipe->prev_odm_pipe)\n\t\t\t\tfirst_pipe = first_pipe->prev_odm_pipe;\n\t\t\tpipes[pipe_cnt].pipe.src.hsplit_grp = first_pipe->pipe_idx;\n\t\t}\n\n\t\tswitch (res_ctx->pipe_ctx[i].stream->signal) {\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_dp;\n\t\t\tbreak;\n\t\tcase SIGNAL_TYPE_EDP:\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_edp;\n\t\t\tbreak;\n\t\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\t\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_hdmi;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* In case there is no signal, set dp with 4 lanes to allow max config */\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_dp;\n\t\t\tpipes[pipe_cnt].dout.dp_lanes = 4;\n\t\t}\n\n\t\tswitch (res_ctx->pipe_ctx[i].stream->timing.display_color_depth) {\n\t\tcase COLOR_DEPTH_666:\n\t\t\toutput_bpc = 6;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_888:\n\t\t\toutput_bpc = 8;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\toutput_bpc = 10;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\toutput_bpc = 12;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_141414:\n\t\t\toutput_bpc = 14;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\toutput_bpc = 16;\n\t\t\tbreak;\n#ifdef CONFIG_DRM_AMD_DC_DCN2_0\n\t\tcase COLOR_DEPTH_999:\n\t\t\toutput_bpc = 9;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_111111:\n\t\t\toutput_bpc = 11;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\toutput_bpc = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (res_ctx->pipe_ctx[i].stream->timing.pixel_encoding) {\n\t\tcase PIXEL_ENCODING_RGB:\n\t\tcase PIXEL_ENCODING_YCBCR444:\n\t\t\tpipes[pipe_cnt].dout.output_format = dm_444;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = output_bpc * 3;\n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR420:\n\t\t\tpipes[pipe_cnt].dout.output_format = dm_420;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = (output_bpc * 3) / 2;\n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR422:\n\t\t\tif (true) /* todo */\n\t\t\t\tpipes[pipe_cnt].dout.output_format = dm_s422;\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].dout.output_format = dm_n422;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = output_bpc * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpipes[pipe_cnt].dout.output_format = dm_444;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = output_bpc * 3;\n\t\t}\n\n\t\t/* todo: default max for now, until there is logic reflecting this in dc*/\n\t\tpipes[pipe_cnt].dout.output_bpc = 12;\n\t\t/*\n\t\t * Use max cursor settings for calculations to minimize\n\t\t * bw calculations due to cursor on/off\n\t\t */\n\t\tpipes[pipe_cnt].pipe.src.num_cursors = 2;\n\t\tpipes[pipe_cnt].pipe.src.cur0_src_width = 256;\n\t\tpipes[pipe_cnt].pipe.src.cur0_bpp = dm_cur_32bit;\n\t\tpipes[pipe_cnt].pipe.src.cur1_src_width = 256;\n\t\tpipes[pipe_cnt].pipe.src.cur1_bpp = dm_cur_32bit;\n\n\t\tif (!res_ctx->pipe_ctx[i].plane_state) {\n\t\t\tpipes[pipe_cnt].pipe.src.source_scan = dm_horz;\n\t\t\tpipes[pipe_cnt].pipe.src.sw_mode = dm_sw_linear;\n\t\t\tpipes[pipe_cnt].pipe.src.macro_tile_size = dm_64k_tile;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_width = timing->h_addressable;\n\t\t\tif (pipes[pipe_cnt].pipe.src.viewport_width > 1920)\n\t\t\t\tpipes[pipe_cnt].pipe.src.viewport_width = 1920;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_height = timing->v_addressable;\n\t\t\tif (pipes[pipe_cnt].pipe.src.viewport_height > 1080)\n\t\t\t\tpipes[pipe_cnt].pipe.src.viewport_height = 1080;\n\t\t\tpipes[pipe_cnt].pipe.src.data_pitch = ((pipes[pipe_cnt].pipe.src.viewport_width + 63) / 64) * 64; /* linear sw only */\n\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_32;\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_width = pipes[pipe_cnt].pipe.src.viewport_width; /*vp_width/hratio*/\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_height = pipes[pipe_cnt].pipe.src.viewport_height; /*vp_height/vratio*/\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width = pipes[pipe_cnt].pipe.dest.recout_width;  /*when is_hsplit != 1*/\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height = pipes[pipe_cnt].pipe.dest.recout_height; /*when is_hsplit != 1*/\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.lb_depth = dm_lb_16;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.hscl_ratio = 1.0;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.vscl_ratio = 1.0;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.scl_enable = 0; /*Lb only or Full scl*/\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.htaps = 1;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.vtaps = 1;\n\t\t\tpipes[pipe_cnt].pipe.src.is_hsplit = 0;\n\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine = 0;\n\t\t\tpipes[pipe_cnt].pipe.dest.vtotal_min = timing->v_total;\n\t\t\tpipes[pipe_cnt].pipe.dest.vtotal_max = timing->v_total;\n\t\t} else {\n\t\t\tstruct dc_plane_state *pln = res_ctx->pipe_ctx[i].plane_state;\n\t\t\tstruct scaler_data *scl = &res_ctx->pipe_ctx[i].plane_res.scl_data;\n\n\t\t\tpipes[pipe_cnt].pipe.src.immediate_flip = pln->flip_immediate;\n\t\t\tpipes[pipe_cnt].pipe.src.is_hsplit = (res_ctx->pipe_ctx[i].bottom_pipe\n\t\t\t\t\t&& res_ctx->pipe_ctx[i].bottom_pipe->plane_state == pln)\n\t\t\t\t\t|| (res_ctx->pipe_ctx[i].top_pipe\n\t\t\t\t\t&& res_ctx->pipe_ctx[i].top_pipe->plane_state == pln);\n\t\t\tpipes[pipe_cnt].pipe.src.source_scan = pln->rotation == ROTATION_ANGLE_90\n\t\t\t\t\t|| pln->rotation == ROTATION_ANGLE_270 ? dm_vert : dm_horz;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_y_y = scl->viewport.y;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_y_c = scl->viewport_c.y;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_width = scl->viewport.width;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_width_c = scl->viewport_c.width;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_height = scl->viewport.height;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_height_c = scl->viewport_c.height;\n\t\t\tif (pln->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\t\t\t\tpipes[pipe_cnt].pipe.src.data_pitch = pln->plane_size.surface_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.data_pitch_c = pln->plane_size.chroma_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.meta_pitch = pln->dcc.meta_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.meta_pitch_c = pln->dcc.meta_pitch_c;\n\t\t\t} else {\n\t\t\t\tpipes[pipe_cnt].pipe.src.data_pitch = pln->plane_size.surface_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.meta_pitch = pln->dcc.meta_pitch;\n\t\t\t}\n\t\t\tpipes[pipe_cnt].pipe.src.dcc = pln->dcc.enable;\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_width = scl->recout.width;\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_height = scl->recout.height;\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width = scl->recout.width;\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height = scl->recout.height;\n\t\t\tif (res_ctx->pipe_ctx[i].bottom_pipe && res_ctx->pipe_ctx[i].bottom_pipe->plane_state == pln) {\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].bottom_pipe->plane_res.scl_data.recout.width;\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].bottom_pipe->plane_res.scl_data.recout.height;\n\t\t\t} else if (res_ctx->pipe_ctx[i].top_pipe && res_ctx->pipe_ctx[i].top_pipe->plane_state == pln) {\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].top_pipe->plane_res.scl_data.recout.width;\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].top_pipe->plane_res.scl_data.recout.height;\n\t\t\t}\n\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.lb_depth = dm_lb_16;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.hscl_ratio = (double) scl->ratios.horz.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.hscl_ratio_c = (double) scl->ratios.horz_c.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.vscl_ratio = (double) scl->ratios.vert.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.vscl_ratio_c = (double) scl->ratios.vert_c.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.scl_enable =\n\t\t\t\t\tscl->ratios.vert.value != dc_fixpt_one.value\n\t\t\t\t\t|| scl->ratios.horz.value != dc_fixpt_one.value\n\t\t\t\t\t|| scl->ratios.vert_c.value != dc_fixpt_one.value\n\t\t\t\t\t|| scl->ratios.horz_c.value != dc_fixpt_one.value /*Lb only or Full scl*/\n\t\t\t\t\t|| dc->debug.always_scale; /*support always scale*/\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.htaps = scl->taps.h_taps;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.htaps_c = scl->taps.h_taps_c;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.vtaps = scl->taps.v_taps;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.vtaps_c = scl->taps.v_taps_c;\n\n\t\t\tpipes[pipe_cnt].pipe.src.macro_tile_size =\n\t\t\t\t\tswizzle_mode_to_macro_tile_size(pln->tiling_info.gfx9.swizzle);\n\t\t\tswizzle_to_dml_params(pln->tiling_info.gfx9.swizzle,\n\t\t\t\t\t&pipes[pipe_cnt].pipe.src.sw_mode);\n\n\t\t\tswitch (pln->format) {\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_420_8;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_420_10;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_64;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_16;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpipe_cnt++;\n\t}\n\n\t/* populate writeback information */\n\tdc->res_pool->funcs->populate_dml_writeback_from_context(dc, res_ctx, pipes);\n\n\treturn pipe_cnt;\n}\n\nunsigned int dcn20_calc_max_scaled_time(\n\t\tunsigned int time_per_pixel,\n\t\tenum mmhubbub_wbif_mode mode,\n\t\tunsigned int urgent_watermark)\n{\n\tunsigned int time_per_byte = 0;\n\tunsigned int total_y_free_entry = 0x200; /* two memory piece for luma */\n\tunsigned int total_c_free_entry = 0x140; /* two memory piece for chroma */\n\tunsigned int small_free_entry, max_free_entry;\n\tunsigned int buf_lh_capability;\n\tunsigned int max_scaled_time;\n\n\tif (mode == PACKED_444) /* packed mode */\n\t\ttime_per_byte = time_per_pixel/4;\n\telse if (mode == PLANAR_420_8BPC)\n\t\ttime_per_byte  = time_per_pixel;\n\telse if (mode == PLANAR_420_10BPC) /* p010 */\n\t\ttime_per_byte  = time_per_pixel * 819/1024;\n\n\tif (time_per_byte == 0)\n\t\ttime_per_byte = 1;\n\n\tsmall_free_entry  = (total_y_free_entry > total_c_free_entry) ? total_c_free_entry : total_y_free_entry;\n\tmax_free_entry    = (mode == PACKED_444) ? total_y_free_entry + total_c_free_entry : small_free_entry;\n\tbuf_lh_capability = max_free_entry*time_per_byte*32/16; /* there is 4bit fraction */\n\tmax_scaled_time   = buf_lh_capability - urgent_watermark;\n\treturn max_scaled_time;\n}\n\nvoid dcn20_set_mcif_arb_params(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint pipe_cnt)\n{\n\tenum mmhubbub_wbif_mode wbif_mode;\n\tstruct mcif_arb_params *wb_arb_params;\n\tint i, j, k, dwb_pipe;\n\n\t/* Writeback MCIF_WB arbitration parameters */\n\tdwb_pipe = 0;\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < MAX_DWB_PIPES; j++) {\n\t\t\tif (context->res_ctx.pipe_ctx[i].stream->writeback_info[j].wb_enabled == false)\n\t\t\t\tcontinue;\n\n\t\t\t//wb_arb_params = &context->res_ctx.pipe_ctx[i].stream->writeback_info[j].mcif_arb_params;\n\t\t\twb_arb_params = &context->bw_ctx.bw.dcn.bw_writeback.mcif_wb_arb[dwb_pipe];\n\n\t\t\tif (context->res_ctx.pipe_ctx[i].stream->writeback_info[j].dwb_params.out_format == dwb_scaler_mode_yuv420) {\n\t\t\t\tif (context->res_ctx.pipe_ctx[i].stream->writeback_info[j].dwb_params.output_depth == DWB_OUTPUT_PIXEL_DEPTH_8BPC)\n\t\t\t\t\twbif_mode = PLANAR_420_8BPC;\n\t\t\t\telse\n\t\t\t\t\twbif_mode = PLANAR_420_10BPC;\n\t\t\t} else\n\t\t\t\twbif_mode = PACKED_444;\n\n\t\t\tfor (k = 0; k < sizeof(wb_arb_params->cli_watermark)/sizeof(wb_arb_params->cli_watermark[0]); k++) {\n\t\t\t\twb_arb_params->cli_watermark[k] = get_wm_writeback_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\t\t\twb_arb_params->pstate_watermark[k] = get_wm_writeback_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\t\t}\n\t\t\twb_arb_params->time_per_pixel = 16.0 / context->res_ctx.pipe_ctx[i].stream->phy_pix_clk; /* 4 bit fraction, ms */\n\t\t\twb_arb_params->slice_lines = 32;\n\t\t\twb_arb_params->arbitration_slice = 2;\n\t\t\twb_arb_params->max_scaled_time = dcn20_calc_max_scaled_time(wb_arb_params->time_per_pixel,\n\t\t\t\twbif_mode,\n\t\t\t\twb_arb_params->cli_watermark[0]); /* assume 4 watermark sets have the same value */\n\n\t\t\tdwb_pipe++;\n\n\t\t\tif (dwb_pipe >= MAX_DWB_PIPES)\n\t\t\t\treturn;\n\t\t}\n\t\tif (dwb_pipe >= MAX_DWB_PIPES)\n\t\t\treturn;\n\t}\n}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\nstatic bool dcn20_validate_dsc(struct dc *dc, struct dc_state *new_ctx)\n{\n\tint i;\n\n\t/* Validate DSC config, dsc count validation is already done */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];\n\t\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\t\tstruct dsc_config dsc_cfg;\n\t\tstruct pipe_ctx *odm_pipe;\n\t\tint opp_cnt = 1;\n\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\t\topp_cnt++;\n\n\t\t/* Only need to validate top pipe */\n\t\tif (pipe_ctx->top_pipe || pipe_ctx->prev_odm_pipe || !stream || !stream->timing.flags.DSC)\n\t\t\tcontinue;\n\n\t\tdsc_cfg.pic_width = (stream->timing.h_addressable + stream->timing.h_border_left\n\t\t\t\t+ stream->timing.h_border_right) / opp_cnt;\n\t\tdsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top\n\t\t\t\t+ stream->timing.v_border_bottom;\n\t\tdsc_cfg.pixel_encoding = stream->timing.pixel_encoding;\n\t\tdsc_cfg.color_depth = stream->timing.display_color_depth;\n\t\tdsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;\n\n\t\tif (!pipe_ctx->stream_res.dsc->funcs->dsc_validate_stream(pipe_ctx->stream_res.dsc, &dsc_cfg))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n#endif\n\nstatic struct pipe_ctx *dcn20_find_secondary_pipe(struct dc *dc,\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tconst struct pipe_ctx *primary_pipe)\n{\n\tstruct pipe_ctx *secondary_pipe = NULL;\n\n\tif (dc && primary_pipe) {\n\t\tint j;\n\t\tint preferred_pipe_idx = 0;\n\n\t\t/* first check the prev dc state:\n\t\t * if this primary pipe has a bottom pipe in prev. state\n\t\t * and if the bottom pipe is still available (which it should be),\n\t\t * pick that pipe as secondary\n\t\t * Same logic applies for ODM pipes. Since mpo is not allowed with odm\n\t\t * check in else case.\n\t\t */\n\t\tif (dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].bottom_pipe) {\n\t\t\tpreferred_pipe_idx = dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].bottom_pipe->pipe_idx;\n\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t}\n\t\t} else if (dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].next_odm_pipe) {\n\t\t\tpreferred_pipe_idx = dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].next_odm_pipe->pipe_idx;\n\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if this primary pipe does not have a bottom pipe in prev. state\n\t\t * start backward and find a pipe that did not used to be a bottom pipe in\n\t\t * prev. dc state. This way we make sure we keep the same assignment as\n\t\t * last state and will not have to reprogram every pipe\n\t\t */\n\t\tif (secondary_pipe == NULL) {\n\t\t\tfor (j = dc->res_pool->pipe_count - 1; j >= 0; j--) {\n\t\t\t\tif (dc->current_state->res_ctx.pipe_ctx[j].top_pipe == NULL) {\n\t\t\t\t\tpreferred_pipe_idx = j;\n\n\t\t\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We should never hit this assert unless assignments are shuffled around\n\t\t * if this happens we will prob. hit a vsync tdr\n\t\t */\n\t\tASSERT(secondary_pipe);\n\t\t/*\n\t\t * search backwards for the second pipe to keep pipe\n\t\t * assignment more consistent\n\t\t */\n\t\tif (secondary_pipe == NULL) {\n\t\t\tfor (j = dc->res_pool->pipe_count - 1; j >= 0; j--) {\n\t\t\t\tpreferred_pipe_idx = j;\n\n\t\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn secondary_pipe;\n}\n\nbool dcn20_fast_validate_bw(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint *pipe_cnt_out,\n\t\tint *pipe_split_from,\n\t\tint *vlevel_out)\n{\n\tbool out = false;\n\n\tint pipe_cnt, i, pipe_idx, vlevel, vlevel_unsplit;\n\tbool odm_capable = context->bw_ctx.dml.ip.odm_capable;\n\tbool force_split = false;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tbool failed_non_odm_dsc = false;\n#endif\n\tint split_threshold = dc->res_pool->pipe_count / 2;\n\tbool avoid_split = dc->debug.pipe_split_policy != MPC_SPLIT_DYNAMIC;\n\n\n\tASSERT(pipes);\n\tif (!pipes)\n\t\treturn false;\n\n\t/* merge previously split odm pipes since mode support needs to make the decision */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *odm_pipe = pipe->next_odm_pipe;\n\n\t\tif (pipe->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tpipe->next_odm_pipe = NULL;\n\t\twhile (odm_pipe) {\n\t\t\tstruct pipe_ctx *next_odm_pipe = odm_pipe->next_odm_pipe;\n\n\t\t\todm_pipe->plane_state = NULL;\n\t\t\todm_pipe->stream = NULL;\n\t\t\todm_pipe->top_pipe = NULL;\n\t\t\todm_pipe->bottom_pipe = NULL;\n\t\t\todm_pipe->prev_odm_pipe = NULL;\n\t\t\todm_pipe->next_odm_pipe = NULL;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t\t\tif (odm_pipe->stream_res.dsc)\n\t\t\t\trelease_dsc(&context->res_ctx, dc->res_pool, &odm_pipe->stream_res.dsc);\n#endif\n\t\t\t/* Clear plane_res and stream_res */\n\t\t\tmemset(&odm_pipe->plane_res, 0, sizeof(odm_pipe->plane_res));\n\t\t\tmemset(&odm_pipe->stream_res, 0, sizeof(odm_pipe->stream_res));\n\t\t\todm_pipe = next_odm_pipe;\n\t\t}\n\t\tif (pipe->plane_state)\n\t\t\tresource_build_scaling_params(pipe);\n\t}\n\n\t/* merge previously mpc split pipes since mode support needs to make the decision */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;\n\n\t\tif (!hsplit_pipe || hsplit_pipe->plane_state != pipe->plane_state)\n\t\t\tcontinue;\n\n\t\tpipe->bottom_pipe = hsplit_pipe->bottom_pipe;\n\t\tif (hsplit_pipe->bottom_pipe)\n\t\t\thsplit_pipe->bottom_pipe->top_pipe = pipe;\n\t\thsplit_pipe->plane_state = NULL;\n\t\thsplit_pipe->stream = NULL;\n\t\thsplit_pipe->top_pipe = NULL;\n\t\thsplit_pipe->bottom_pipe = NULL;\n\n\t\t/* Clear plane_res and stream_res */\n\t\tmemset(&hsplit_pipe->plane_res, 0, sizeof(hsplit_pipe->plane_res));\n\t\tmemset(&hsplit_pipe->stream_res, 0, sizeof(hsplit_pipe->stream_res));\n\t\tif (pipe->plane_state)\n\t\t\tresource_build_scaling_params(pipe);\n\t}\n\n\tif (dc->res_pool->funcs->populate_dml_pipes)\n\t\tpipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc,\n\t\t\t&context->res_ctx, pipes);\n\telse\n\t\tpipe_cnt = dcn20_populate_dml_pipes_from_context(dc,\n\t\t\t&context->res_ctx, pipes);\n\n\t*pipe_cnt_out = pipe_cnt;\n\n\tif (!pipe_cnt) {\n\t\tout = true;\n\t\tgoto validate_out;\n\t}\n\n\tcontext->bw_ctx.dml.ip.odm_capable = 0;\n\n\tvlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\tcontext->bw_ctx.dml.ip.odm_capable = odm_capable;\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t/* 1 dsc per stream dsc validation */\n\tif (vlevel <= context->bw_ctx.dml.soc.num_states)\n\t\tif (!dcn20_validate_dsc(dc, context)) {\n\t\t\tfailed_non_odm_dsc = true;\n\t\t\tvlevel = context->bw_ctx.dml.soc.num_states + 1;\n\t\t}\n#endif\n\n\tif (vlevel > context->bw_ctx.dml.soc.num_states && odm_capable)\n\t\tvlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\tif (vlevel > context->bw_ctx.dml.soc.num_states)\n\t\tgoto validate_fail;\n\n\tif ((context->stream_count > split_threshold && dc->current_state->stream_count <= split_threshold)\n\t\t|| (context->stream_count <= split_threshold && dc->current_state->stream_count > split_threshold))\n\t\tcontext->commit_hints.full_update_needed = true;\n\n\t/*initialize pipe_just_split_from to invalid idx*/\n\tfor (i = 0; i < MAX_PIPES; i++)\n\t\tpipe_split_from[i] = -1;\n\n\t/* Single display only conditionals get set here */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tbool exit_loop = false;\n\n\t\tif (!pipe->stream || pipe->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (dc->debug.force_single_disp_pipe_split) {\n\t\t\tif (!force_split)\n\t\t\t\tforce_split = true;\n\t\t\telse {\n\t\t\t\tforce_split = false;\n\t\t\t\texit_loop = true;\n\t\t\t}\n\t\t}\n\t\tif (dc->debug.pipe_split_policy == MPC_SPLIT_AVOID_MULT_DISP) {\n\t\t\tif (avoid_split)\n\t\t\t\tavoid_split = false;\n\t\t\telse {\n\t\t\t\tavoid_split = true;\n\t\t\t\texit_loop = true;\n\t\t\t}\n\t\t}\n\t\tif (exit_loop)\n\t\t\tbreak;\n\t}\n\n\tif (context->stream_count > split_threshold)\n\t\tavoid_split = true;\n\n\tvlevel_unsplit = vlevel;\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\tfor (; vlevel_unsplit <= context->bw_ctx.dml.soc.num_states; vlevel_unsplit++)\n\t\t\tif (context->bw_ctx.dml.vba.NoOfDPP[vlevel_unsplit][0][pipe_idx] == 1)\n\t\t\t\tbreak;\n\t\tpipe_idx++;\n\t}\n\n\tfor (i = 0, pipe_idx = -1; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;\n\t\tbool need_split = true;\n\t\tbool need_split3d;\n\n\t\tif (!pipe->stream || pipe_split_from[i] >= 0)\n\t\t\tcontinue;\n\n\t\tpipe_idx++;\n\n\t\tif (dc->debug.force_odm_combine & (1 << pipe->stream_res.tg->inst)) {\n\t\t\tforce_split = true;\n\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx] = true;\n\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_idx] = true;\n\t\t}\n\t\tif (force_split && context->bw_ctx.dml.vba.NoOfDPP[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] == 1)\n\t\t\tcontext->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] /= 2;\n\t\tif (!pipe->top_pipe && !pipe->plane_state && context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx]) {\n\t\t\thsplit_pipe = dcn20_find_secondary_pipe(dc, &context->res_ctx, dc->res_pool, pipe);\n\t\t\tASSERT(hsplit_pipe);\n\t\t\tif (!dcn20_split_stream_for_odm(\n\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe, hsplit_pipe))\n\t\t\t\tgoto validate_fail;\n\t\t\tpipe_split_from[hsplit_pipe->pipe_idx] = pipe_idx;\n\t\t\tdcn20_build_mapped_resource(dc, context, pipe->stream);\n\t\t}\n\n\t\tif (!pipe->plane_state)\n\t\t\tcontinue;\n\t\t/* Skip 2nd half of already split pipe */\n\t\tif (pipe->top_pipe && pipe->plane_state == pipe->top_pipe->plane_state)\n\t\t\tcontinue;\n\n\t\tneed_split3d = ((pipe->stream->view_format ==\n\t\t\t\tVIEW_3D_FORMAT_SIDE_BY_SIDE ||\n\t\t\t\tpipe->stream->view_format ==\n\t\t\t\tVIEW_3D_FORMAT_TOP_AND_BOTTOM) &&\n\t\t\t\t(pipe->stream->timing.timing_3d_format ==\n\t\t\t\tTIMING_3D_FORMAT_TOP_AND_BOTTOM ||\n\t\t\t\t pipe->stream->timing.timing_3d_format ==\n\t\t\t\tTIMING_3D_FORMAT_SIDE_BY_SIDE));\n\n\t\tif (avoid_split && vlevel_unsplit <= context->bw_ctx.dml.soc.num_states && !force_split && !need_split3d) {\n\t\t\tneed_split = false;\n\t\t\tvlevel = vlevel_unsplit;\n\t\t\tcontext->bw_ctx.dml.vba.maxMpcComb = 0;\n\t\t} else\n\t\t\tneed_split = context->bw_ctx.dml.vba.NoOfDPP[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] == 2;\n\n\t\t/* We do not support mpo + odm at the moment */\n\t\tif (hsplit_pipe && hsplit_pipe->plane_state != pipe->plane_state\n\t\t\t\t&& context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx])\n\t\t\tgoto validate_fail;\n\n\t\tif (need_split3d || need_split || force_split) {\n\t\t\tif (!hsplit_pipe || hsplit_pipe->plane_state != pipe->plane_state) {\n\t\t\t\t/* pipe not split previously needs split */\n\t\t\t\thsplit_pipe = dcn20_find_secondary_pipe(dc, &context->res_ctx, dc->res_pool, pipe);\n\t\t\t\tASSERT(hsplit_pipe || force_split);\n\t\t\t\tif (!hsplit_pipe)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx]) {\n\t\t\t\t\tif (!dcn20_split_stream_for_odm(\n\t\t\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\t\t\tpipe, hsplit_pipe))\n\t\t\t\t\t\tgoto validate_fail;\n\t\t\t\t} else\n\t\t\t\t\tdcn20_split_stream_for_mpc(\n\t\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\t\tpipe, hsplit_pipe);\n\t\t\t\tpipe_split_from[hsplit_pipe->pipe_idx] = pipe_idx;\n\t\t\t}\n\t\t} else if (hsplit_pipe && hsplit_pipe->plane_state == pipe->plane_state) {\n\t\t\t/* merge should already have been done */\n\t\t\tASSERT(0);\n\t\t}\n\t}\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t/* Actual dsc count per stream dsc validation*/\n\tif (failed_non_odm_dsc && !dcn20_validate_dsc(dc, context)) {\n\t\tcontext->bw_ctx.dml.vba.ValidationStatus[context->bw_ctx.dml.vba.soc.num_states] =\n\t\t\t\tDML_FAIL_DSC_VALIDATION_FAILURE;\n\t\tgoto validate_fail;\n\t}\n#endif\n\n\t*vlevel_out = vlevel;\n\n\tout = true;\n\tgoto validate_out;\n\nvalidate_fail:\n\tout = false;\n\nvalidate_out:\n\treturn out;\n}\n\nvoid dcn20_calculate_wm(\n\t\tstruct dc *dc, struct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint *out_pipe_cnt,\n\t\tint *pipe_split_from,\n\t\tint vlevel)\n{\n\tint pipe_cnt, i, pipe_idx;\n\n\tfor (i = 0, pipe_idx = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tpipes[pipe_cnt].clks_cfg.refclk_mhz = dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000.0;\n\t\tpipes[pipe_cnt].clks_cfg.dispclk_mhz = context->bw_ctx.dml.vba.RequiredDISPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\n\t\tif (pipe_split_from[i] < 0) {\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz =\n\t\t\t\t\tcontext->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx];\n\t\t\tif (context->bw_ctx.dml.vba.BlendingAndTiming[pipe_idx] == pipe_idx)\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine =\n\t\t\t\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_idx];\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine = 0;\n\t\t\tpipe_idx++;\n\t\t} else {\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz =\n\t\t\t\t\tcontext->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_split_from[i]];\n\t\t\tif (context->bw_ctx.dml.vba.BlendingAndTiming[pipe_split_from[i]] == pipe_split_from[i])\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine =\n\t\t\t\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_split_from[i]];\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine = 0;\n\t\t}\n\n\t\tif (dc->config.forced_clocks) {\n\t\t\tpipes[pipe_cnt].clks_cfg.dispclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dispclk_mhz;\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dppclk_mhz;\n\t\t}\n\t\tif (dc->debug.min_disp_clk_khz > pipes[pipe_cnt].clks_cfg.dispclk_mhz * 1000)\n\t\t\tpipes[pipe_cnt].clks_cfg.dispclk_mhz = dc->debug.min_disp_clk_khz / 1000.0;\n\t\tif (dc->debug.min_dpp_clk_khz > pipes[pipe_cnt].clks_cfg.dppclk_mhz * 1000)\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz = dc->debug.min_dpp_clk_khz / 1000.0;\n\n\t\tpipe_cnt++;\n\t}\n\n\tif (pipe_cnt != pipe_idx) {\n\t\tif (dc->res_pool->funcs->populate_dml_pipes)\n\t\t\tpipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc,\n\t\t\t\t&context->res_ctx, pipes);\n\t\telse\n\t\t\tpipe_cnt = dcn20_populate_dml_pipes_from_context(dc,\n\t\t\t\t&context->res_ctx, pipes);\n\t}\n\n\t*out_pipe_cnt = pipe_cnt;\n\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].dcfclk_mhz;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].socclk_mhz;\n\n\t/* only pipe 0 is read for voltage and dcf/soc clocks */\n\tif (vlevel < 1) {\n\t\tpipes[0].clks_cfg.voltage = 1;\n\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[1].dcfclk_mhz;\n\t\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[1].socclk_mhz;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.b.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tif (vlevel < 2) {\n\t\tpipes[0].clks_cfg.voltage = 2;\n\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].dcfclk_mhz;\n\t\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].socclk_mhz;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.c.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tif (vlevel < 3) {\n\t\tpipes[0].clks_cfg.voltage = 3;\n\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].dcfclk_mhz;\n\t\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].socclk_mhz;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.d.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].dcfclk_mhz;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].socclk_mhz;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n}\n\nvoid dcn20_calculate_dlg_params(\n\t\tstruct dc *dc, struct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint pipe_cnt,\n\t\tint vlevel)\n{\n\tint i, j, pipe_idx, pipe_idx_unsplit;\n\tbool visited[MAX_PIPES] = { 0 };\n\n\t/* Writeback MCIF_WB arbitration parameters */\n\tdc->res_pool->funcs->set_mcif_arb_params(dc, context, pipes, pipe_cnt);\n\n\tcontext->bw_ctx.bw.dcn.clk.dispclk_khz = context->bw_ctx.dml.vba.DISPCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.dcfclk_khz = context->bw_ctx.dml.vba.DCFCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.socclk_khz = context->bw_ctx.dml.vba.SOCCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz = context->bw_ctx.dml.vba.DRAMSpeed * 1000 / 16;\n\tcontext->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz = context->bw_ctx.dml.vba.DCFCLKDeepSleep * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.fclk_khz = 0;\n\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support =\n\t\tcontext->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb]\n\t\t\t\t\t\t\t!= dm_dram_clock_change_unsupported;\n\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = 0;\n\n\t/*\n\t * An artifact of dml pipe split/odm is that pipes get merged back together for\n\t * calculation. Therefore we need to only extract for first pipe in ascending index order\n\t * and copy into the other split half.\n\t */\n\tfor (i = 0, pipe_idx = 0, pipe_idx_unsplit = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tif (!visited[pipe_idx]) {\n\t\t\tdisplay_pipe_source_params_st *src = &pipes[pipe_idx_unsplit].pipe.src;\n\t\t\tdisplay_pipe_dest_params_st *dst = &pipes[pipe_idx_unsplit].pipe.dest;\n\n\t\t\tdst->vstartup_start = context->bw_ctx.dml.vba.VStartup[pipe_idx_unsplit];\n\t\t\tdst->vupdate_offset = context->bw_ctx.dml.vba.VUpdateOffsetPix[pipe_idx_unsplit];\n\t\t\tdst->vupdate_width = context->bw_ctx.dml.vba.VUpdateWidthPix[pipe_idx_unsplit];\n\t\t\tdst->vready_offset = context->bw_ctx.dml.vba.VReadyOffsetPix[pipe_idx_unsplit];\n\t\t\t/*\n\t\t\t * j iterates inside pipes array, unlike i which iterates inside\n\t\t\t * pipe_ctx array\n\t\t\t */\n\t\t\tif (src->is_hsplit)\n\t\t\t\tfor (j = pipe_idx + 1; j < pipe_cnt; j++) {\n\t\t\t\t\tdisplay_pipe_source_params_st *src_j = &pipes[j].pipe.src;\n\t\t\t\t\tdisplay_pipe_dest_params_st *dst_j = &pipes[j].pipe.dest;\n\n\t\t\t\t\tif (src_j->is_hsplit && !visited[j]\n\t\t\t\t\t\t\t&& src->hsplit_grp == src_j->hsplit_grp) {\n\t\t\t\t\t\tdst_j->vstartup_start = context->bw_ctx.dml.vba.VStartup[pipe_idx_unsplit];\n\t\t\t\t\t\tdst_j->vupdate_offset = context->bw_ctx.dml.vba.VUpdateOffsetPix[pipe_idx_unsplit];\n\t\t\t\t\t\tdst_j->vupdate_width = context->bw_ctx.dml.vba.VUpdateWidthPix[pipe_idx_unsplit];\n\t\t\t\t\t\tdst_j->vready_offset = context->bw_ctx.dml.vba.VReadyOffsetPix[pipe_idx_unsplit];\n\t\t\t\t\t\tvisited[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tvisited[pipe_idx] = true;\n\t\t\tpipe_idx_unsplit++;\n\t\t}\n\t\tpipe_idx++;\n\t}\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\tif (context->bw_ctx.bw.dcn.clk.dppclk_khz < pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000)\n\t\t\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000;\n\t\tcontext->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz =\n\t\t\t\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz * 1000;\n\t\tASSERT(visited[pipe_idx]);\n\t\tcontext->res_ctx.pipe_ctx[i].pipe_dlg_param = pipes[pipe_idx].pipe.dest;\n\t\tpipe_idx++;\n\t}\n\t/*save a original dppclock copy*/\n\tcontext->bw_ctx.bw.dcn.clk.bw_dppclk_khz = context->bw_ctx.bw.dcn.clk.dppclk_khz;\n\tcontext->bw_ctx.bw.dcn.clk.bw_dispclk_khz = context->bw_ctx.bw.dcn.clk.dispclk_khz;\n\tcontext->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz = context->bw_ctx.dml.soc.clock_limits[vlevel].dppclk_mhz * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.max_supported_dispclk_khz = context->bw_ctx.dml.soc.clock_limits[vlevel].dispclk_mhz * 1000;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tbool cstate_en = context->bw_ctx.dml.vba.PrefetchMode[vlevel][context->bw_ctx.dml.vba.maxMpcComb] != 2;\n\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tcontext->bw_ctx.dml.funcs.rq_dlg_get_dlg_reg(&context->bw_ctx.dml,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].dlg_regs,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].ttu_regs,\n\t\t\t\tpipes,\n\t\t\t\tpipe_cnt,\n\t\t\t\tpipe_idx,\n\t\t\t\tcstate_en,\n\t\t\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support,\n\t\t\t\tfalse, false, false);\n\n\t\tcontext->bw_ctx.dml.funcs.rq_dlg_get_rq_reg(&context->bw_ctx.dml,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].rq_regs,\n\t\t\t\tpipes[pipe_idx].pipe);\n\t\tpipe_idx++;\n\t}\n}\n\nstatic bool dcn20_validate_bandwidth_internal(struct dc *dc, struct dc_state *context,\n\t\tbool fast_validate)\n{\n\tbool out = false;\n\n\tBW_VAL_TRACE_SETUP();\n\n\tint vlevel = 0;\n\tint pipe_split_from[MAX_PIPES];\n\tint pipe_cnt = 0;\n\tdisplay_e2e_pipe_params_st *pipes = kzalloc(dc->res_pool->pipe_count * sizeof(display_e2e_pipe_params_st), GFP_KERNEL);\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tBW_VAL_TRACE_COUNT();\n\n\tout = dcn20_fast_validate_bw(dc, context, pipes, &pipe_cnt, pipe_split_from, &vlevel);\n\n\tif (pipe_cnt == 0)\n\t\tgoto validate_out;\n\n\tif (!out)\n\t\tgoto validate_fail;\n\n\tBW_VAL_TRACE_END_VOLTAGE_LEVEL();\n\n\tif (fast_validate) {\n\t\tBW_VAL_TRACE_SKIP(fast);\n\t\tgoto validate_out;\n\t}\n\n\tdcn20_calculate_wm(dc, context, pipes, &pipe_cnt, pipe_split_from, vlevel);\n\tdcn20_calculate_dlg_params(dc, context, pipes, pipe_cnt, vlevel);\n\n\tBW_VAL_TRACE_END_WATERMARKS();\n\n\tgoto validate_out;\n\nvalidate_fail:\n\tDC_LOG_WARNING(\"Mode Validation Warning: %s failed validation.\\n\",\n\t\tdml_get_status_message(context->bw_ctx.dml.vba.ValidationStatus[context->bw_ctx.dml.vba.soc.num_states]));\n\n\tBW_VAL_TRACE_SKIP(fail);\n\tout = false;\n\nvalidate_out:\n\tkfree(pipes);\n\n\tBW_VAL_TRACE_FINISH();\n\n\treturn out;\n}\n\n\nbool dcn20_validate_bandwidth(struct dc *dc, struct dc_state *context,\n\t\tbool fast_validate)\n{\n\tbool voltage_supported = false;\n\tbool full_pstate_supported = false;\n\tbool dummy_pstate_supported = false;\n\tdouble p_state_latency_us = context->bw_ctx.dml.soc.dram_clock_change_latency_us;\n\n\tif (fast_validate)\n\t\treturn dcn20_validate_bandwidth_internal(dc, context, true);\n\n\n\t// Best case, we support full UCLK switch latency\n\tvoltage_supported = dcn20_validate_bandwidth_internal(dc, context, false);\n\tfull_pstate_supported = context->bw_ctx.bw.dcn.clk.p_state_change_support;\n\n\tif (context->bw_ctx.dml.soc.dummy_pstate_latency_us == 0 ||\n\t\t(voltage_supported && full_pstate_supported)) {\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = true;\n\t\tgoto restore_dml_state;\n\t}\n\n\t// Fallback: Try to only support G6 temperature read latency\n\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = context->bw_ctx.dml.soc.dummy_pstate_latency_us;\n\n\tvoltage_supported = dcn20_validate_bandwidth_internal(dc, context, false);\n\tdummy_pstate_supported = context->bw_ctx.bw.dcn.clk.p_state_change_support;\n\n\tif (voltage_supported && dummy_pstate_supported) {\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = false;\n\t\tgoto restore_dml_state;\n\t}\n\n\t// ERROR: fallback is supposed to always work.\n\tASSERT(false);\n\nrestore_dml_state:\n\tmemcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));\n\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = p_state_latency_us;\n\n\treturn voltage_supported;\n}\n\nstruct pipe_ctx *dcn20_acquire_idle_pipe_for_layer(\n\t\tstruct dc_state *state,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct resource_context *res_ctx = &state->res_ctx;\n\tstruct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);\n\tstruct pipe_ctx *idle_pipe = find_idle_secondary_pipe(res_ctx, pool, head_pipe);\n\n\tif (!head_pipe)\n\t\tASSERT(0);\n\n\tif (!idle_pipe)\n\t\treturn NULL;\n\n\tidle_pipe->stream = head_pipe->stream;\n\tidle_pipe->stream_res.tg = head_pipe->stream_res.tg;\n\tidle_pipe->stream_res.opp = head_pipe->stream_res.opp;\n\n\tidle_pipe->plane_res.hubp = pool->hubps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.ipp = pool->ipps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.dpp = pool->dpps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.mpcc_inst = pool->dpps[idle_pipe->pipe_idx]->inst;\n\n\treturn idle_pipe;\n}\n\nbool dcn20_get_dcc_compression_cap(const struct dc *dc,\n\t\tconst struct dc_dcc_surface_param *input,\n\t\tstruct dc_surface_dcc_cap *output)\n{\n\treturn dc->res_pool->hubbub->funcs->get_dcc_compression_cap(\n\t\t\tdc->res_pool->hubbub,\n\t\t\tinput,\n\t\t\toutput);\n}\n\nstatic void dcn20_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dcn20_resource_pool *dcn20_pool = TO_DCN20_RES_POOL(*pool);\n\n\tdestruct(dcn20_pool);\n\tkfree(dcn20_pool);\n\t*pool = NULL;\n}\n\n\nstatic struct dc_cap_funcs cap_funcs = {\n\t.get_dcc_compression_cap = dcn20_get_dcc_compression_cap\n};\n\n\nenum dc_status dcn20_get_default_swizzle_mode(struct dc_plane_state *plane_state)\n{\n\tenum dc_status result = DC_OK;\n\n\tenum surface_pixel_format surf_pix_format = plane_state->format;\n\tunsigned int bpp = resource_pixel_format_to_bpp(surf_pix_format);\n\n\tenum swizzle_mode_values swizzle = DC_SW_LINEAR;\n\n\tif (bpp == 64)\n\t\tswizzle = DC_SW_64KB_D;\n\telse\n\t\tswizzle = DC_SW_64KB_S;\n\n\tplane_state->tiling_info.gfx9.swizzle = swizzle;\n\treturn result;\n}\n\nstatic struct resource_funcs dcn20_res_pool_funcs = {\n\t.destroy = dcn20_destroy_resource_pool,\n\t.link_enc_create = dcn20_link_encoder_create,\n\t.validate_bandwidth = dcn20_validate_bandwidth,\n\t.acquire_idle_pipe_for_layer = dcn20_acquire_idle_pipe_for_layer,\n\t.add_stream_to_ctx = dcn20_add_stream_to_ctx,\n\t.remove_stream_from_ctx = dcn20_remove_stream_from_ctx,\n\t.populate_dml_writeback_from_context = dcn20_populate_dml_writeback_from_context,\n\t.get_default_swizzle_mode = dcn20_get_default_swizzle_mode,\n\t.set_mcif_arb_params = dcn20_set_mcif_arb_params,\n\t.find_first_free_match_stream_enc_for_link = dcn10_find_first_free_match_stream_enc_for_link\n};\n\nbool dcn20_dwbc_create(struct dc_context *ctx, struct resource_pool *pool)\n{\n\tint i;\n\tuint32_t pipe_count = pool->res_cap->num_dwb;\n\n\tASSERT(pipe_count > 0);\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tstruct dcn20_dwbc *dwbc20 = kzalloc(sizeof(struct dcn20_dwbc),\n\t\t\t\t\t\t    GFP_KERNEL);\n\n\t\tif (!dwbc20) {\n\t\t\tdm_error(\"DC: failed to create dwbc20!\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tdcn20_dwbc_construct(dwbc20, ctx,\n\t\t\t\t&dwbc20_regs[i],\n\t\t\t\t&dwbc20_shift,\n\t\t\t\t&dwbc20_mask,\n\t\t\t\ti);\n\t\tpool->dwbc[i] = &dwbc20->base;\n\t}\n\treturn true;\n}\n\nbool dcn20_mmhubbub_create(struct dc_context *ctx, struct resource_pool *pool)\n{\n\tint i;\n\tuint32_t pipe_count = pool->res_cap->num_dwb;\n\n\tASSERT(pipe_count > 0);\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tstruct dcn20_mmhubbub *mcif_wb20 = kzalloc(sizeof(struct dcn20_mmhubbub),\n\t\t\t\t\t\t    GFP_KERNEL);\n\n\t\tif (!mcif_wb20) {\n\t\t\tdm_error(\"DC: failed to create mcif_wb20!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tdcn20_mmhubbub_construct(mcif_wb20, ctx,\n\t\t\t\t&mcif_wb20_regs[i],\n\t\t\t\t&mcif_wb20_shift,\n\t\t\t\t&mcif_wb20_mask,\n\t\t\t\ti);\n\n\t\tpool->mcif_wb[i] = &mcif_wb20->base;\n\t}\n\treturn true;\n}\n\nstruct pp_smu_funcs *dcn20_pp_smu_create(struct dc_context *ctx)\n{\n\tstruct pp_smu_funcs *pp_smu = kzalloc(sizeof(*pp_smu), GFP_KERNEL);\n\n\tif (!pp_smu)\n\t\treturn pp_smu;\n\n\tdm_pp_get_funcs(ctx, pp_smu);\n\n\tif (pp_smu->ctx.ver != PP_SMU_VER_NV)\n\t\tpp_smu = memset(pp_smu, 0, sizeof(struct pp_smu_funcs));\n\n\treturn pp_smu;\n}\n\nvoid dcn20_pp_smu_destroy(struct pp_smu_funcs **pp_smu)\n{\n\tif (pp_smu && *pp_smu) {\n\t\tkfree(*pp_smu);\n\t\t*pp_smu = NULL;\n\t}\n}\n\nstatic void cap_soc_clocks(\n\t\tstruct _vcs_dpi_soc_bounding_box_st *bb,\n\t\tstruct pp_smu_nv_clock_table max_clocks)\n{\n\tint i;\n\n\t// First pass - cap all clocks higher than the reported max\n\tfor (i = 0; i < bb->num_states; i++) {\n\t\tif ((bb->clock_limits[i].dcfclk_mhz > (max_clocks.dcfClockInKhz / 1000))\n\t\t\t\t&& max_clocks.dcfClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dcfclk_mhz = (max_clocks.dcfClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dram_speed_mts > (max_clocks.uClockInKhz / 1000) * 16)\n\t\t\t\t\t\t&& max_clocks.uClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dram_speed_mts = (max_clocks.uClockInKhz / 1000) * 16;\n\n\t\tif ((bb->clock_limits[i].fabricclk_mhz > (max_clocks.fabricClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.fabricClockInKhz != 0)\n\t\t\tbb->clock_limits[i].fabricclk_mhz = (max_clocks.fabricClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dispclk_mhz > (max_clocks.displayClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.displayClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dispclk_mhz = (max_clocks.displayClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dppclk_mhz > (max_clocks.dppClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.dppClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dppclk_mhz = (max_clocks.dppClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].phyclk_mhz > (max_clocks.phyClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.phyClockInKhz != 0)\n\t\t\tbb->clock_limits[i].phyclk_mhz = (max_clocks.phyClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].socclk_mhz > (max_clocks.socClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.socClockInKhz != 0)\n\t\t\tbb->clock_limits[i].socclk_mhz = (max_clocks.socClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dscclk_mhz > (max_clocks.dscClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.dscClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dscclk_mhz = (max_clocks.dscClockInKhz / 1000);\n\t}\n\n\t// Second pass - remove all duplicate clock states\n\tfor (i = bb->num_states - 1; i > 1; i--) {\n\t\tbool duplicate = true;\n\n\t\tif (bb->clock_limits[i-1].dcfclk_mhz != bb->clock_limits[i].dcfclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dispclk_mhz != bb->clock_limits[i].dispclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dppclk_mhz != bb->clock_limits[i].dppclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dram_speed_mts != bb->clock_limits[i].dram_speed_mts)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dscclk_mhz != bb->clock_limits[i].dscclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].fabricclk_mhz != bb->clock_limits[i].fabricclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].phyclk_mhz != bb->clock_limits[i].phyclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].socclk_mhz != bb->clock_limits[i].socclk_mhz)\n\t\t\tduplicate = false;\n\n\t\tif (duplicate)\n\t\t\tbb->num_states--;\n\t}\n}\n\nstatic void update_bounding_box(struct dc *dc, struct _vcs_dpi_soc_bounding_box_st *bb,\n\t\tstruct pp_smu_nv_clock_table *max_clocks, unsigned int *uclk_states, unsigned int num_states)\n{\n\tstruct _vcs_dpi_voltage_scaling_st calculated_states[MAX_CLOCK_LIMIT_STATES] = {0};\n\tint i;\n\tint num_calculated_states = 0;\n\tint min_dcfclk = 0;\n\n\tif (num_states == 0)\n\t\treturn;\n\n\tif (dc->bb_overrides.min_dcfclk_mhz > 0)\n\t\tmin_dcfclk = dc->bb_overrides.min_dcfclk_mhz;\n\telse\n\t\t// Accounting for SOC/DCF relationship, we can go as high as\n\t\t// 506Mhz in Vmin.  We need to code 507 since SMU will round down to 506.\n\t\tmin_dcfclk = 507;\n\n\tfor (i = 0; i < num_states; i++) {\n\t\tint min_fclk_required_by_uclk;\n\t\tcalculated_states[i].state = i;\n\t\tcalculated_states[i].dram_speed_mts = uclk_states[i] * 16 / 1000;\n\n\t\t// FCLK:UCLK ratio is 1.08\n\t\tmin_fclk_required_by_uclk = mul_u64_u32_shr(BIT_ULL(32) * 1080 / 1000000, uclk_states[i], 32);\n\n\t\tcalculated_states[i].fabricclk_mhz = (min_fclk_required_by_uclk < min_dcfclk) ?\n\t\t\t\tmin_dcfclk : min_fclk_required_by_uclk;\n\n\t\tcalculated_states[i].socclk_mhz = (calculated_states[i].fabricclk_mhz > max_clocks->socClockInKhz / 1000) ?\n\t\t\t\tmax_clocks->socClockInKhz / 1000 : calculated_states[i].fabricclk_mhz;\n\n\t\tcalculated_states[i].dcfclk_mhz = (calculated_states[i].fabricclk_mhz > max_clocks->dcfClockInKhz / 1000) ?\n\t\t\t\tmax_clocks->dcfClockInKhz / 1000 : calculated_states[i].fabricclk_mhz;\n\n\t\tcalculated_states[i].dispclk_mhz = max_clocks->displayClockInKhz / 1000;\n\t\tcalculated_states[i].dppclk_mhz = max_clocks->displayClockInKhz / 1000;\n\t\tcalculated_states[i].dscclk_mhz = max_clocks->displayClockInKhz / (1000 * 3);\n\n\t\tcalculated_states[i].phyclk_mhz = max_clocks->phyClockInKhz / 1000;\n\n\t\tnum_calculated_states++;\n\t}\n\n\tcalculated_states[num_calculated_states - 1].socclk_mhz = max_clocks->socClockInKhz / 1000;\n\tcalculated_states[num_calculated_states - 1].fabricclk_mhz = max_clocks->socClockInKhz / 1000;\n\tcalculated_states[num_calculated_states - 1].dcfclk_mhz = max_clocks->dcfClockInKhz / 1000;\n\n\tmemcpy(bb->clock_limits, calculated_states, sizeof(bb->clock_limits));\n\tbb->num_states = num_calculated_states;\n\n\t// Duplicate the last state, DML always an extra state identical to max state to work\n\tmemcpy(&bb->clock_limits[num_calculated_states], &bb->clock_limits[num_calculated_states - 1], sizeof(struct _vcs_dpi_voltage_scaling_st));\n\tbb->clock_limits[num_calculated_states].state = bb->num_states;\n}\n\nstatic void patch_bounding_box(struct dc *dc, struct _vcs_dpi_soc_bounding_box_st *bb)\n{\n\tkernel_fpu_begin();\n\tif ((int)(bb->sr_exit_time_us * 1000) != dc->bb_overrides.sr_exit_time_ns\n\t\t\t&& dc->bb_overrides.sr_exit_time_ns) {\n\t\tbb->sr_exit_time_us = dc->bb_overrides.sr_exit_time_ns / 1000.0;\n\t}\n\n\tif ((int)(bb->sr_enter_plus_exit_time_us * 1000)\n\t\t\t\t!= dc->bb_overrides.sr_enter_plus_exit_time_ns\n\t\t\t&& dc->bb_overrides.sr_enter_plus_exit_time_ns) {\n\t\tbb->sr_enter_plus_exit_time_us =\n\t\t\t\tdc->bb_overrides.sr_enter_plus_exit_time_ns / 1000.0;\n\t}\n\n\tif ((int)(bb->urgent_latency_us * 1000) != dc->bb_overrides.urgent_latency_ns\n\t\t\t&& dc->bb_overrides.urgent_latency_ns) {\n\t\tbb->urgent_latency_us = dc->bb_overrides.urgent_latency_ns / 1000.0;\n\t}\n\n\tif ((int)(bb->dram_clock_change_latency_us * 1000)\n\t\t\t\t!= dc->bb_overrides.dram_clock_change_latency_ns\n\t\t\t&& dc->bb_overrides.dram_clock_change_latency_ns) {\n\t\tbb->dram_clock_change_latency_us =\n\t\t\t\tdc->bb_overrides.dram_clock_change_latency_ns / 1000.0;\n\t}\n\tkernel_fpu_end();\n}\n\nstatic struct _vcs_dpi_soc_bounding_box_st *get_asic_rev_soc_bb(\n\tuint32_t hw_internal_rev)\n{\n\tif (ASICREV_IS_NAVI12_P(hw_internal_rev))\n\t\treturn &dcn2_0_nv12_soc;\n\n\treturn &dcn2_0_soc;\n}\n\nstatic struct _vcs_dpi_ip_params_st *get_asic_rev_ip_params(\n\tuint32_t hw_internal_rev)\n{\n\t/* NV12 and NV10 */\n\treturn &dcn2_0_ip;\n}\n\nstatic enum dml_project get_dml_project_version(uint32_t hw_internal_rev)\n{\n\treturn DML_PROJECT_NAVI10v2;\n}\n\n#define fixed16_to_double(x) (((double) x) / ((double) (1 << 16)))\n#define fixed16_to_double_to_cpu(x) fixed16_to_double(le32_to_cpu(x))\n\nstatic bool init_soc_bounding_box(struct dc *dc,\n\t\t\t\t  struct dcn20_resource_pool *pool)\n{\n\tconst struct gpu_info_soc_bounding_box_v1_0 *bb = dc->soc_bounding_box;\n\tstruct _vcs_dpi_soc_bounding_box_st *loaded_bb =\n\t\t\tget_asic_rev_soc_bb(dc->ctx->asic_id.hw_internal_rev);\n\tstruct _vcs_dpi_ip_params_st *loaded_ip =\n\t\t\tget_asic_rev_ip_params(dc->ctx->asic_id.hw_internal_rev);\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (!bb && !SOC_BOUNDING_BOX_VALID) {\n\t\tDC_LOG_ERROR(\"%s: not valid soc bounding box/n\", __func__);\n\t\treturn false;\n\t}\n\n\tif (bb && !SOC_BOUNDING_BOX_VALID) {\n\t\tint i;\n\n\t\tdcn2_0_nv12_soc.sr_exit_time_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->sr_exit_time_us);\n\t\tdcn2_0_nv12_soc.sr_enter_plus_exit_time_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->sr_enter_plus_exit_time_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_pixel_data_only_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_pixel_data_only_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_pixel_mixed_with_vm_data_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_pixel_mixed_with_vm_data_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_vm_data_only_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_vm_data_only_us);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_pixel_only_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_pixel_only_bytes);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_pixel_and_vm_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_pixel_and_vm_bytes);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_vm_only_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_vm_only_bytes);\n\t\tdcn2_0_nv12_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_only =\n\t\t\t\tfixed16_to_double_to_cpu(bb->pct_ideal_dram_sdp_bw_after_urgent_pixel_only);\n\t\tdcn2_0_nv12_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm =\n\t\t\t\tfixed16_to_double_to_cpu(bb->pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm);\n\t\tdcn2_0_nv12_soc.pct_ideal_dram_sdp_bw_after_urgent_vm_only =\n\t\t\t\tfixed16_to_double_to_cpu(bb->pct_ideal_dram_sdp_bw_after_urgent_vm_only);\n\t\tdcn2_0_nv12_soc.max_avg_sdp_bw_use_normal_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->max_avg_sdp_bw_use_normal_percent);\n\t\tdcn2_0_nv12_soc.max_avg_dram_bw_use_normal_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->max_avg_dram_bw_use_normal_percent);\n\t\tdcn2_0_nv12_soc.writeback_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->writeback_latency_us);\n\t\tdcn2_0_nv12_soc.ideal_dram_bw_after_urgent_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->ideal_dram_bw_after_urgent_percent);\n\t\tdcn2_0_nv12_soc.max_request_size_bytes =\n\t\t\t\tle32_to_cpu(bb->max_request_size_bytes);\n\t\tdcn2_0_nv12_soc.dram_channel_width_bytes =\n\t\t\t\tle32_to_cpu(bb->dram_channel_width_bytes);\n\t\tdcn2_0_nv12_soc.fabric_datapath_to_dcn_data_return_bytes =\n\t\t\t\tle32_to_cpu(bb->fabric_datapath_to_dcn_data_return_bytes);\n\t\tdcn2_0_nv12_soc.dcn_downspread_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dcn_downspread_percent);\n\t\tdcn2_0_nv12_soc.downspread_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->downspread_percent);\n\t\tdcn2_0_nv12_soc.dram_page_open_time_ns =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dram_page_open_time_ns);\n\t\tdcn2_0_nv12_soc.dram_rw_turnaround_time_ns =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dram_rw_turnaround_time_ns);\n\t\tdcn2_0_nv12_soc.dram_return_buffer_per_channel_bytes =\n\t\t\t\tle32_to_cpu(bb->dram_return_buffer_per_channel_bytes);\n\t\tdcn2_0_nv12_soc.round_trip_ping_latency_dcfclk_cycles =\n\t\t\t\tle32_to_cpu(bb->round_trip_ping_latency_dcfclk_cycles);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_bytes);\n\t\tdcn2_0_nv12_soc.channel_interleave_bytes =\n\t\t\t\tle32_to_cpu(bb->channel_interleave_bytes);\n\t\tdcn2_0_nv12_soc.num_banks =\n\t\t\t\tle32_to_cpu(bb->num_banks);\n\t\tdcn2_0_nv12_soc.num_chans =\n\t\t\t\tle32_to_cpu(bb->num_chans);\n\t\tdcn2_0_nv12_soc.vmm_page_size_bytes =\n\t\t\t\tle32_to_cpu(bb->vmm_page_size_bytes);\n\t\tdcn2_0_nv12_soc.dram_clock_change_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dram_clock_change_latency_us);\n\t\t// HACK!! Lower uclock latency switch time so we don't switch\n\t\tdcn2_0_nv12_soc.dram_clock_change_latency_us = 10;\n\t\tdcn2_0_nv12_soc.writeback_dram_clock_change_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->writeback_dram_clock_change_latency_us);\n\t\tdcn2_0_nv12_soc.return_bus_width_bytes =\n\t\t\t\tle32_to_cpu(bb->return_bus_width_bytes);\n\t\tdcn2_0_nv12_soc.dispclk_dppclk_vco_speed_mhz =\n\t\t\t\tle32_to_cpu(bb->dispclk_dppclk_vco_speed_mhz);\n\t\tdcn2_0_nv12_soc.xfc_bus_transport_time_us =\n\t\t\t\tle32_to_cpu(bb->xfc_bus_transport_time_us);\n\t\tdcn2_0_nv12_soc.xfc_xbuf_latency_tolerance_us =\n\t\t\t\tle32_to_cpu(bb->xfc_xbuf_latency_tolerance_us);\n\t\tdcn2_0_nv12_soc.use_urgent_burst_bw =\n\t\t\t\tle32_to_cpu(bb->use_urgent_burst_bw);\n\t\tdcn2_0_nv12_soc.num_states =\n\t\t\t\tle32_to_cpu(bb->num_states);\n\n\t\tfor (i = 0; i < dcn2_0_nv12_soc.num_states; i++) {\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].state =\n\t\t\t\t\tle32_to_cpu(bb->clock_limits[i].state);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dcfclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dcfclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].fabricclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].fabricclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dispclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dispclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dppclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dppclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].phyclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].phyclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].socclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].socclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dscclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dscclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dram_speed_mts =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dram_speed_mts);\n\t\t}\n\t}\n\n\tif (pool->base.pp_smu) {\n\t\tstruct pp_smu_nv_clock_table max_clocks = {0};\n\t\tunsigned int uclk_states[8] = {0};\n\t\tunsigned int num_states = 0;\n\t\tenum pp_smu_status status;\n\t\tbool clock_limits_available = false;\n\t\tbool uclk_states_available = false;\n\n\t\tif (pool->base.pp_smu->nv_funcs.get_uclk_dpm_states) {\n\t\t\tstatus = (pool->base.pp_smu->nv_funcs.get_uclk_dpm_states)\n\t\t\t\t(&pool->base.pp_smu->nv_funcs.pp_smu, uclk_states, &num_states);\n\n\t\t\tuclk_states_available = (status == PP_SMU_RESULT_OK);\n\t\t}\n\n\t\tif (pool->base.pp_smu->nv_funcs.get_maximum_sustainable_clocks) {\n\t\t\tstatus = (*pool->base.pp_smu->nv_funcs.get_maximum_sustainable_clocks)\n\t\t\t\t\t(&pool->base.pp_smu->nv_funcs.pp_smu, &max_clocks);\n\t\t\t/* SMU cannot set DCF clock to anything equal to or higher than SOC clock\n\t\t\t */\n\t\t\tif (max_clocks.dcfClockInKhz >= max_clocks.socClockInKhz)\n\t\t\t\tmax_clocks.dcfClockInKhz = max_clocks.socClockInKhz - 1000;\n\t\t\tclock_limits_available = (status == PP_SMU_RESULT_OK);\n\t\t}\n\n\t\tif (clock_limits_available && uclk_states_available && num_states)\n\t\t\tupdate_bounding_box(dc, loaded_bb, &max_clocks, uclk_states, num_states);\n\t\telse if (clock_limits_available)\n\t\t\tcap_soc_clocks(loaded_bb, max_clocks);\n\t}\n\n\tloaded_ip->max_num_otg = pool->base.res_cap->num_timing_generator;\n\tloaded_ip->max_num_dpp = pool->base.pipe_count;\n\tpatch_bounding_box(dc, loaded_bb);\n\n\treturn true;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dcn20_resource_pool *pool)\n{\n\tint i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct irq_service_init_data init_data;\n\tstruct _vcs_dpi_soc_bounding_box_st *loaded_bb =\n\t\t\tget_asic_rev_soc_bb(ctx->asic_id.hw_internal_rev);\n\tstruct _vcs_dpi_ip_params_st *loaded_ip =\n\t\t\tget_asic_rev_ip_params(ctx->asic_id.hw_internal_rev);\n\tenum dml_project dml_project_version =\n\t\t\tget_dml_project_version(ctx->asic_id.hw_internal_rev);\n\n\tctx->dc_bios->regs = &bios_regs;\n\tpool->base.funcs = &dcn20_res_pool_funcs;\n\n\tif (ASICREV_IS_NAVI14_M(ctx->asic_id.hw_internal_rev)) {\n\t\tpool->base.res_cap = &res_cap_nv14;\n\t\tpool->base.pipe_count = 5;\n\t\tpool->base.mpcc_count = 5;\n\t} else {\n\t\tpool->base.res_cap = &res_cap_nv10;\n\t\tpool->base.pipe_count = 6;\n\t\tpool->base.mpcc_count = 6;\n\t}\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 256;\n\tdc->caps.dmdata_alloc_size = 2048;\n\n\tdc->caps.max_slave_planes = 1;\n\tdc->caps.post_blend_color_processing = true;\n\tdc->caps.force_dp_tps4_for_cp2520 = true;\n\tdc->caps.hw_3d_lut = true;\n\n\tif (dc->ctx->dce_environment == DCE_ENV_PRODUCTION_DRV) {\n\t\tdc->debug = debug_defaults_drv;\n\t} else if (dc->ctx->dce_environment == DCE_ENV_FPGA_MAXIMUS) {\n\t\tpool->base.pipe_count = 4;\n\t\tpool->base.mpcc_count = pool->base.pipe_count;\n\t\tdc->debug = debug_defaults_diags;\n\t} else {\n\t\tdc->debug = debug_defaults_diags;\n\t}\n\t//dcn2.0x\n\tdc->work_arounds.dedcn20_305_wa = true;\n\n\t// Init the vm_helper\n\tif (dc->vm_helper)\n\t\tvm_helper_init(dc->vm_helper, 16);\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL0] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL1] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL2] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL3] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL4] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL5] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCN20_CLK_SRC_TOTAL;\n\t/* todo: not reuse phy_pll registers */\n\tpool->base.dp_clock_source =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_ID_DP_DTO,\n\t\t\t\t&clk_src_regs[0], true);\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tpool->base.dccg = dccg2_create(ctx, &dccg_regs, &dccg_shift, &dccg_mask);\n\tif (pool->base.dccg == NULL) {\n\t\tdm_error(\"DC: failed to create dccg!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.dmcu = dcn20_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.pp_smu = dcn20_pp_smu_create(ctx);\n\n\n\tif (!init_soc_bounding_box(dc, pool)) {\n\t\tdm_error(\"DC: failed to initialize soc bounding box!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tdml_init_instance(&dc->dml, loaded_bb, loaded_ip, dml_project_version);\n\n\tif (!dc->debug.disable_pplib_wm_range) {\n\t\tstruct pp_smu_wm_range_sets ranges = {0};\n\t\tint i = 0;\n\n\t\tranges.num_reader_wm_sets = 0;\n\n\t\tif (loaded_bb->num_states == 1) {\n\t\t\tranges.reader_wm_sets[0].wm_inst = i;\n\t\t\tranges.reader_wm_sets[0].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges.reader_wm_sets[0].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t\tranges.reader_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges.reader_wm_sets[0].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n\t\t\tranges.num_reader_wm_sets = 1;\n\t\t} else if (loaded_bb->num_states > 1) {\n\t\t\tfor (i = 0; i < 4 && i < loaded_bb->num_states; i++) {\n\t\t\t\tranges.reader_wm_sets[i].wm_inst = i;\n\t\t\t\tranges.reader_wm_sets[i].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\t\tranges.reader_wm_sets[i].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t\t\tranges.reader_wm_sets[i].min_fill_clk_mhz = (i > 0) ? (loaded_bb->clock_limits[i - 1].dram_speed_mts / 16) + 1 : 0;\n\t\t\t\tranges.reader_wm_sets[i].max_fill_clk_mhz = loaded_bb->clock_limits[i].dram_speed_mts / 16;\n\n\t\t\t\tranges.num_reader_wm_sets = i + 1;\n\t\t\t}\n\n\t\t\tranges.reader_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges.reader_wm_sets[ranges.num_reader_wm_sets - 1].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t}\n\n\t\tranges.num_writer_wm_sets = 1;\n\n\t\tranges.writer_wm_sets[0].wm_inst = 0;\n\t\tranges.writer_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\tranges.writer_wm_sets[0].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\tranges.writer_wm_sets[0].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\tranges.writer_wm_sets[0].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n\t\t/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */\n\t\tif (pool->base.pp_smu->nv_funcs.set_wm_ranges)\n\t\t\tpool->base.pp_smu->nv_funcs.set_wm_ranges(&pool->base.pp_smu->nv_funcs.pp_smu, &ranges);\n\t}\n\n\tinit_data.ctx = dc->ctx;\n\tpool->base.irqs = dal_irq_service_dcn20_create(&init_data);\n\tif (!pool->base.irqs)\n\t\tgoto create_fail;\n\n\t/* mem input -> ipp -> dpp -> opp -> TG */\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.hubps[i] = dcn20_hubp_create(ctx, i);\n\t\tif (pool->base.hubps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dcn20_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\n\t\tpool->base.dpps[i] = dcn20_dpp_create(ctx, i);\n\t\tif (pool->base.dpps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create dpps!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dcn20_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dcn20_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create hw i2c!!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_opp; i++) {\n\t\tpool->base.opps[i] = dcn20_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_timing_generator; i++) {\n\t\tpool->base.timing_generators[i] = dcn20_timing_generator_create(\n\t\t\t\tctx, i);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tpool->base.timing_generator_count = i;\n\n\tpool->base.mpc = dcn20_mpc_create(ctx);\n\tif (pool->base.mpc == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create mpc!\\n\");\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.hubbub = dcn20_hubbub_create(ctx);\n\tif (pool->base.hubbub == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create hubbub!\\n\");\n\t\tgoto create_fail;\n\t}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tfor (i = 0; i < pool->base.res_cap->num_dsc; i++) {\n\t\tpool->base.dscs[i] = dcn20_dsc_create(ctx, i);\n\t\tif (pool->base.dscs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create display stream compressor %d!\\n\", i);\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n#endif\n\n\tif (!dcn20_dwbc_create(ctx, &pool->base)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create dwbc!\\n\");\n\t\tgoto create_fail;\n\t}\n\tif (!dcn20_mmhubbub_create(ctx, &pool->base)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create mcif_wb!\\n\");\n\t\tgoto create_fail;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t(!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment) ?\n\t\t\t&res_create_funcs : &res_create_maximus_funcs)))\n\t\t\tgoto create_fail;\n\n\tdcn20_hw_sequencer_construct(dc);\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->cap_funcs = cap_funcs;\n\n\treturn true;\n\ncreate_fail:\n\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dcn20_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn20_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn20_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(pool);\n\treturn NULL;\n}\n"], "fixing_code": ["/*\n * Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"../virtual/virtual_stream_encoder.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce110/dce110_timing_generator.h\"\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce100/dce100_hw_sequencer.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_10_0_d.h\"\n#include \"dce/dce_10_0_sh_mask.h\"\n\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_i2c.h\"\n\n#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT\n#include \"gmc/gmc_8_2_d.h\"\n#include \"gmc/gmc_8_2_sh_mask.h\"\n#endif\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\nstatic const struct dce110_timing_generator_offsets dce100_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE100_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE100(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE100_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST_DCE_BASE(id),\\\n\t.AFMT_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5),\n\tstream_enc_regs(6)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_100_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_100(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_100(_MASK)\n};\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(id)\\\n[id] = {\\\n\tCS_COMMON_REG_LIST_DCE_100_110(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0),\n\tclk_src_regs(1),\n\tclk_src_regs(2)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define DCFE_MEM_PWR_CTRL_REG_BASE 0x1b03\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps res_cap = {\n\t.num_timing_generator = 6,\n\t.num_audio = 6,\n\t.num_stream_encoder = 6,\n\t.num_pll = 3,\n\t.num_ddc = 6,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x1918\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct timing_generator *dce100_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce100_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id], &se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE10_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE10_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE10_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce100_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce100_stream_encoder_create,\n\t.create_hwseq = dce100_hwseq_create,\n};\n\n#define mi_inst_regs(id) { \\\n\tMI_DCE8_REG_LIST(id), \\\n\t.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \\\n}\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE8_MASK_SH_LIST(__SHIFT),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE8_MASK_SH_LIST(_MASK),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK\n};\n\nstatic struct mem_input *dce100_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\tdce_mi->wa.single_head_rdreq_dmif_limit = 2;\n\treturn &dce_mi->base;\n}\n\nstatic void dce100_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce100_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\treturn &transform->base;\n}\n\nstatic struct input_pixel_processor *dce100_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 300000,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true\n};\n\nstruct link_encoder *dce100_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstruct output_pixel_processor *dce100_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce100_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstruct dce_i2c_hw *dce100_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce100_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce100_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce100_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL)\n\t\t\tdce100_clock_source_destroy(&pool->base.clock_sources[i]);\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce100_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL)\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\t\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL)\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc  *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nbool dce100_validate_bandwidth(\n\tstruct dc  *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tint i;\n\tbool at_least_one_pipe = false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].stream)\n\t\t\tat_least_one_pipe = true;\n\t}\n\n\tif (at_least_one_pipe) {\n\t\t/* TODO implement when needed but for now hardcode max value*/\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 681000;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;\n\t} else {\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 0;\n\t}\n\n\treturn true;\n}\n\nstatic bool dce100_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce100_validate_global(\n\t\tstruct dc  *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce100_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nenum dc_status dce100_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_clock_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic void dce100_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nenum dc_status dce100_validate_plane(const struct dc_plane_state *plane_state, struct dc_caps *caps)\n{\n\n\tif (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\treturn DC_OK;\n\n\treturn DC_FAIL_SURFACE_VALIDATE;\n}\n\nstruct stream_encoder *dce100_find_first_free_match_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tint j = -1;\n\tstruct dc_link *link = stream->link;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (!res_ctx->is_stream_enc_acquired[i] &&\n\t\t\t\tpool->stream_enc[i]) {\n\t\t\t/* Store first available for MST second display\n\t\t\t * in daisy chain use case\n\t\t\t */\n\t\t\tj = i;\n\t\t\tif (pool->stream_enc[i]->id ==\n\t\t\t\t\tlink->link_enc->preferred_engine)\n\t\t\t\treturn pool->stream_enc[i];\n\t\t}\n\t}\n\n\t/*\n\t * below can happen in cases when stream encoder is acquired:\n\t * 1) for second MST display in chain, so preferred engine already\n\t * acquired;\n\t * 2) for another link, which preferred engine already acquired by any\n\t * MST configuration.\n\t *\n\t * If signal is of DP type and preferred engine not found, return last available\n\t *\n\t * TODO - This is just a patch up and a generic solution is\n\t * required for non DP connectors.\n\t */\n\n\tif (j >= 0 && link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT)\n\t\treturn pool->stream_enc[j];\n\n\treturn NULL;\n}\n\nstatic const struct resource_funcs dce100_res_pool_funcs = {\n\t.destroy = dce100_destroy_resource_pool,\n\t.link_enc_create = dce100_link_encoder_create,\n\t.validate_bandwidth = dce100_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce100_add_stream_to_ctx,\n\t.validate_global = dce100_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce100_find_first_free_match_stream_enc_for_link\n};\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dce100_res_pool_funcs;\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[2] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 3;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 2;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t\t&abm_regs,\n\t\t\t\t&abm_shift,\n\t\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\t/*************************************************\n\t*  Resource + asic cap harcoding                *\n\t*************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap.num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\tdc->caps.disable_dp_clk_share = true;\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] =\n\t\t\tdce100_timing_generator_create(\n\t\t\t\tctx,\n\t\t\t\ti,\n\t\t\t\t&dce100_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce100_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce100_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce100_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce100_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce100_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce100_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce100_hw_sequencer_construct(dc);\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\n", "/*\n * Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce110/dce110_timing_generator.h\"\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce110/dce110_timing_generator_v.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce110/dce110_mem_input_v.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce110/dce110_transform_v.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce110/dce110_opp_v.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_i2c.h\"\n\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n#include \"dce110/dce110_compressor.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_11_0_d.h\"\n#include \"dce/dce_11_0_sh_mask.h\"\n\n#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT\n#include \"gmc/gmc_8_2_d.h\"\n#include \"gmc/gmc_8_2_sh_mask.h\"\n#endif\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\n#ifndef DPHY_RX_FAST_TRAINING_CAPABLE\n\t#define DPHY_RX_FAST_TRAINING_CAPABLE 0x1\n#endif\n\nstatic const struct dce110_timing_generator_offsets dce110_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE110_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_110_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_110(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_110(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n/* AG TBD Needs to be reduced back to 3 pipes once dce10 hw sequencer implemented. */\n\n\n#define clk_src_regs(id)\\\n[id] = {\\\n\tCS_COMMON_REG_LIST_DCE_100_110(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0),\n\tclk_src_regs(1),\n\tclk_src_regs(2)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps carrizo_resource_cap = {\n\t\t.num_timing_generator = 3,\n\t\t.num_video_plane = 1,\n\t\t.num_audio = 3,\n\t\t.num_stream_encoder = 3,\n\t\t.num_pll = 2,\n\t\t.num_ddc = 3,\n};\n\nstatic const struct resource_caps stoney_resource_cap = {\n\t\t.num_timing_generator = 2,\n\t\t.num_video_plane = 1,\n\t\t.num_audio = 3,\n\t\t.num_stream_encoder = 3,\n\t\t.num_pll = 2,\n\t\t.num_ddc = 3,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t\t.type = DC_PLANE_TYPE_DCE_RGB,\n\t\t.blends_with_below = true,\n\t\t.blends_with_above = true,\n\t\t.per_pixel_alpha = 1,\n\n\t\t.pixel_format_support = {\n\t\t\t\t.argb8888 = true,\n\t\t\t\t.nv12 = false,\n\t\t\t\t.fp16 = false\n\t\t},\n\n\t\t.max_upscale_factor = {\n\t\t\t\t.argb8888 = 16000,\n\t\t\t\t.nv12 = 1,\n\t\t\t\t.fp16 = 1\n\t\t},\n\n\t\t.max_downscale_factor = {\n\t\t\t\t.argb8888 = 250,\n\t\t\t\t.nv12 = 1,\n\t\t\t\t.fp16 = 1\n\t\t}\n};\n\nstatic const struct dc_plane_cap underlay_plane_cap = {\n\t\t.type = DC_PLANE_TYPE_DCE_UNDERLAY,\n\t\t.blends_with_above = true,\n\t\t.per_pixel_alpha = 1,\n\n\t\t.pixel_format_support = {\n\t\t\t\t.argb8888 = false,\n\t\t\t\t.nv12 = true,\n\t\t\t\t.fp16 = false\n\t\t},\n\n\t\t.max_upscale_factor = {\n\t\t\t\t.argb8888 = 1,\n\t\t\t\t.nv12 = 16000,\n\t\t\t\t.fp16 = 1\n\t\t},\n\n\t\t.max_downscale_factor = {\n\t\t\t\t.argb8888 = 1,\n\t\t\t\t.nv12 = 250,\n\t\t\t\t.fp16 = 1\n\t\t}\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x4819\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct timing_generator *dce110_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce110_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_stoney_reg = {\n\t\tHWSEQ_ST_REG_LIST()\n};\n\nstatic const struct dce_hwseq_registers hwseq_cz_reg = {\n\t\tHWSEQ_CZ_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE11_MASK_SH_LIST(__SHIFT),\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE11_MASK_SH_LIST(_MASK),\n};\n\nstatic struct dce_hwseq *dce110_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = ASIC_REV_IS_STONEY(ctx->asic_id.hw_internal_rev) ?\n\t\t\t\t&hwseq_stoney_reg : &hwseq_cz_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t\thws->wa.blnd_crtc_trigger = true;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce110_stream_encoder_create,\n\t.create_hwseq = dce110_hwseq_create,\n};\n\n#define mi_inst_regs(id) { \\\n\tMI_DCE11_REG_LIST(id), \\\n\t.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \\\n}\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE11_MASK_SH_LIST(__SHIFT),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE11_MASK_SH_LIST(_MASK),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK\n};\n\n\nstatic struct mem_input *dce110_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\tdce_mi->wa.single_head_rdreq_dmif_limit = 3;\n\treturn &dce_mi->base;\n}\n\nstatic void dce110_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce110_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\treturn &transform->base;\n}\n\nstatic struct input_pixel_processor *dce110_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 300000,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true\n};\n\nstatic struct link_encoder *dce110_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstatic struct output_pixel_processor *dce110_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce110_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dce110_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce100_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce110_clock_source_destroy(struct clock_source **clk_src)\n{\n\tstruct dce110_clk_src *dce110_clk_src;\n\n\tif (!clk_src)\n\t\treturn;\n\n\tdce110_clk_src = TO_DCE110_CLK_SRC(*clk_src);\n\n\tkfree(dce110_clk_src->dp_ss_params);\n\tkfree(dce110_clk_src->hdmi_ss_params);\n\tkfree(dce110_clk_src->dvi_ss_params);\n\n\tkfree(dce110_clk_src);\n\t*clk_src = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce110_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce110_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce110_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\n\nstatic void get_pixel_clock_parameters(\n\tconst struct pipe_ctx *pipe_ctx,\n\tstruct pixel_clk_params *pixel_clk_params)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\n\t/*TODO: is this halved for YCbCr 420? in that case we might want to move\n\t * the pixel clock normalization for hdmi up to here instead of doing it\n\t * in pll_adjust_pix_clk\n\t */\n\tpixel_clk_params->requested_pix_clk_100hz = stream->timing.pix_clk_100hz;\n\tpixel_clk_params->encoder_object_id = stream->link->link_enc->id;\n\tpixel_clk_params->signal_type = pipe_ctx->stream->signal;\n\tpixel_clk_params->controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\t/* TODO: un-hardcode*/\n\tpixel_clk_params->requested_sym_clk = LINK_RATE_LOW *\n\t\t\t\t\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\tpixel_clk_params->flags.ENABLE_SS = 0;\n\tpixel_clk_params->color_depth =\n\t\tstream->timing.display_color_depth;\n\tpixel_clk_params->flags.DISPLAY_BLANKED = 1;\n\tpixel_clk_params->flags.SUPPORT_YCBCR420 = (stream->timing.pixel_encoding ==\n\t\t\tPIXEL_ENCODING_YCBCR420);\n\tpixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422) {\n\t\tpixel_clk_params->color_depth = COLOR_DEPTH_888;\n\t}\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420) {\n\t\tpixel_clk_params->requested_pix_clk_100hz  = pixel_clk_params->requested_pix_clk_100hz / 2;\n\t}\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tpixel_clk_params->requested_pix_clk_100hz *= 2;\n\n}\n\nvoid dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx)\n{\n\tget_pixel_clock_parameters(pipe_ctx, &pipe_ctx->stream_res.pix_clk_params);\n\tpipe_ctx->clock_source->funcs->get_pix_clk_dividers(\n\t\tpipe_ctx->clock_source,\n\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t&pipe_ctx->pll_settings);\n\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t&pipe_ctx->stream->bit_depth_params);\n\tpipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;\n}\n\nstatic bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigned int underlay_idx)\n{\n\tif (pipe_ctx->pipe_idx != underlay_idx)\n\t\treturn true;\n\tif (!pipe_ctx->plane_state)\n\t\treturn false;\n\tif (pipe_ctx->plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\treturn false;\n\treturn true;\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (!is_surface_pixel_format_supported(pipe_ctx,\n\t\t\tdc->res_pool->underlay_pipe_index))\n\t\treturn DC_SURFACE_PIXEL_FORMAT_UNSUPPORTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\t/* TODO: validate audio ASIC caps, encoder */\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nstatic bool dce110_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tbool result = false;\n\n\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\"%s: start\",\n\t\t__func__);\n\n\tif (bw_calcs(\n\t\t\tdc->ctx,\n\t\t\tdc->bw_dceip,\n\t\t\tdc->bw_vbios,\n\t\t\tcontext->res_ctx.pipe_ctx,\n\t\t\tdc->res_pool->pipe_count,\n\t\t\t&context->bw_ctx.bw.dce))\n\t\tresult =  true;\n\n\tif (!result)\n\t\tDC_LOG_BANDWIDTH_VALIDATION(\"%s: %dx%d@%d Bandwidth validation failed!\\n\",\n\t\t\t__func__,\n\t\t\tcontext->streams[0]->timing.h_addressable,\n\t\t\tcontext->streams[0]->timing.v_addressable,\n\t\t\tcontext->streams[0]->timing.pix_clk_100hz / 10);\n\n\tif (memcmp(&dc->current_state->bw_ctx.bw.dce,\n\t\t\t&context->bw_ctx.bw.dce, sizeof(context->bw_ctx.bw.dce))) {\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\t\"%s: finish,\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d stutter_mode_enable: %d\\n\"\n\t\t\t\"cstate: %d pstate: %d nbpstate: %d sync: %d dispclk: %d\\n\"\n\t\t\t\"sclk: %d sclk_sleep: %d yclk: %d blackout_recovery_time_us: %d\\n\"\n\t\t\t,\n\t\t\t__func__,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_mode_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync,\n\t\t\tcontext->bw_ctx.bw.dce.dispclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_deep_sleep_khz,\n\t\t\tcontext->bw_ctx.bw.dce.yclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us);\n\t}\n\treturn result;\n}\n\nenum dc_status dce110_validate_plane(const struct dc_plane_state *plane_state,\n\t\t\t\t     struct dc_caps *caps)\n{\n\tif (((plane_state->dst_rect.width * 2) < plane_state->src_rect.width) ||\n\t    ((plane_state->dst_rect.height * 2) < plane_state->src_rect.height))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic bool dce110_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i, j;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 2)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < context->stream_status[i].plane_count; j++) {\n\t\t\tstruct dc_plane_state *plane =\n\t\t\t\tcontext->stream_status[i].plane_states[j];\n\n\t\t\t/* underlay validation */\n\t\t\tif (plane->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\n\t\t\t\tif ((plane->src_rect.width > 1920 ||\n\t\t\t\t\tplane->src_rect.height > 1080))\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* we don't have the logic to support underlay\n\t\t\t\t * only yet so block the use case where we get\n\t\t\t\t * NV12 plane as top layer\n\t\t\t\t */\n\t\t\t\tif (j == 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* irrespective of plane format,\n\t\t\t\t * stream should be RGB encoded\n\t\t\t\t */\n\t\t\t\tif (context->streams[i]->timing.pixel_encoding\n\t\t\t\t\t\t!= PIXEL_ENCODING_RGB)\n\t\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce110_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce110_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status dce110_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic struct pipe_ctx *dce110_acquire_underlay(\n\t\tstruct dc_state *context,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct dc *dc = stream->ctx->dc;\n\tstruct resource_context *res_ctx = &context->res_ctx;\n\tunsigned int underlay_idx = pool->underlay_pipe_index;\n\tstruct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];\n\n\tif (res_ctx->pipe_ctx[underlay_idx].stream)\n\t\treturn NULL;\n\n\tpipe_ctx->stream_res.tg = pool->timing_generators[underlay_idx];\n\tpipe_ctx->plane_res.mi = pool->mis[underlay_idx];\n\t/*pipe_ctx->plane_res.ipp = res_ctx->pool->ipps[underlay_idx];*/\n\tpipe_ctx->plane_res.xfm = pool->transforms[underlay_idx];\n\tpipe_ctx->stream_res.opp = pool->opps[underlay_idx];\n\tpipe_ctx->pipe_idx = underlay_idx;\n\n\tpipe_ctx->stream = stream;\n\n\tif (!dc->current_state->res_ctx.pipe_ctx[underlay_idx].stream) {\n\t\tstruct tg_color black_color = {0};\n\t\tstruct dc_bios *dcb = dc->ctx->dc_bios;\n\n\t\tdc->hwss.enable_display_power_gating(\n\t\t\t\tdc,\n\t\t\t\tpipe_ctx->stream_res.tg->inst,\n\t\t\t\tdcb, PIPE_GATING_CONTROL_DISABLE);\n\n\t\t/*\n\t\t * This is for powering on underlay, so crtc does not\n\t\t * need to be enabled\n\t\t */\n\n\t\tpipe_ctx->stream_res.tg->funcs->program_timing(pipe_ctx->stream_res.tg,\n\t\t\t\t&stream->timing,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tpipe_ctx->stream->signal,\n\t\t\t\tfalse);\n\n\t\tpipe_ctx->stream_res.tg->funcs->enable_advanced_request(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\ttrue,\n\t\t\t\t&stream->timing);\n\n\t\tpipe_ctx->plane_res.mi->funcs->allocate_mem_input(pipe_ctx->plane_res.mi,\n\t\t\t\tstream->timing.h_total,\n\t\t\t\tstream->timing.v_total,\n\t\t\t\tstream->timing.pix_clk_100hz / 10,\n\t\t\t\tcontext->stream_count);\n\n\t\tcolor_space_to_black_color(dc,\n\t\t\t\tCOLOR_SPACE_YCBCR601, &black_color);\n\t\tpipe_ctx->stream_res.tg->funcs->set_blank_color(\n\t\t\t\tpipe_ctx->stream_res.tg,\n\t\t\t\t&black_color);\n\t}\n\n\treturn pipe_ctx;\n}\n\nstatic void dce110_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstruct stream_encoder *dce110_find_first_free_match_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tint j = -1;\n\tstruct dc_link *link = stream->link;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (!res_ctx->is_stream_enc_acquired[i] &&\n\t\t\t\tpool->stream_enc[i]) {\n\t\t\t/* Store first available for MST second display\n\t\t\t * in daisy chain use case\n\t\t\t */\n\t\t\tj = i;\n\t\t\tif (pool->stream_enc[i]->id ==\n\t\t\t\t\tlink->link_enc->preferred_engine)\n\t\t\t\treturn pool->stream_enc[i];\n\t\t}\n\t}\n\n\t/*\n\t * For CZ and later, we can allow DIG FE and BE to differ for all display types\n\t */\n\n\tif (j >= 0)\n\t\treturn pool->stream_enc[j];\n\n\treturn NULL;\n}\n\n\nstatic const struct resource_funcs dce110_res_pool_funcs = {\n\t.destroy = dce110_destroy_resource_pool,\n\t.link_enc_create = dce110_link_encoder_create,\n\t.validate_bandwidth = dce110_validate_bandwidth,\n\t.validate_plane = dce110_validate_plane,\n\t.acquire_idle_pipe_for_layer = dce110_acquire_underlay,\n\t.add_stream_to_ctx = dce110_add_stream_to_ctx,\n\t.validate_global = dce110_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic bool underlay_create(struct dc_context *ctx, struct resource_pool *pool)\n{\n\tstruct dce110_timing_generator *dce110_tgv = kzalloc(sizeof(*dce110_tgv),\n\t\t\t\t\t\t\t     GFP_KERNEL);\n\tstruct dce_transform *dce110_xfmv = kzalloc(sizeof(*dce110_xfmv),\n\t\t\t\t\t\t    GFP_KERNEL);\n\tstruct dce_mem_input *dce110_miv = kzalloc(sizeof(*dce110_miv),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tstruct dce110_opp *dce110_oppv = kzalloc(sizeof(*dce110_oppv),\n\t\t\t\t\t\t GFP_KERNEL);\n\n\tif (!dce110_tgv || !dce110_xfmv || !dce110_miv || !dce110_oppv) {\n\t\tkfree(dce110_tgv);\n\t\tkfree(dce110_xfmv);\n\t\tkfree(dce110_miv);\n\t\tkfree(dce110_oppv);\n\t\treturn false;\n\t}\n\n\tdce110_opp_v_construct(dce110_oppv, ctx);\n\n\tdce110_timing_generator_v_construct(dce110_tgv, ctx);\n\tdce110_mem_input_v_construct(dce110_miv, ctx);\n\tdce110_transform_v_construct(dce110_xfmv, ctx);\n\n\tpool->opps[pool->pipe_count] = &dce110_oppv->base;\n\tpool->timing_generators[pool->pipe_count] = &dce110_tgv->base;\n\tpool->mis[pool->pipe_count] = &dce110_miv->base;\n\tpool->transforms[pool->pipe_count] = &dce110_xfmv->base;\n\tpool->pipe_count++;\n\n\t/* update the public caps to indicate an underlay is available */\n\tctx->dc->caps.max_slave_planes = 1;\n\tctx->dc->caps.max_slave_planes = 1;\n\n\treturn true;\n}\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels clks = {0};\n\n\t/*do system clock*/\n\tdm_pp_get_clock_levels_by_type(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t&clks);\n\t/* convert all the clock fro kHz to fix point mHz */\n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels/8], 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*2/8], 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*3/8], 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*4/8], 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*5/8], 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels*6/8], 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0], 1000);\n\tdc->sclk_lvls = clks;\n\n\t/*do display clock*/\n\tdm_pp_get_clock_levels_by_type(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_DISPLAY_CLK,\n\t\t\t&clks);\n\tdc->bw_vbios->high_voltage_max_dispclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\tdc->bw_vbios->mid_voltage_max_dispclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels>>1], 1000);\n\tdc->bw_vbios->low_voltage_max_dispclk  = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0], 1000);\n\n\t/*do memory clock*/\n\tdm_pp_get_clock_levels_by_type(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&clks);\n\n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tclks.clocks_in_khz[0] * MEMORY_TYPE_MULTIPLIER_CZ, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tclks.clocks_in_khz[clks.num_levels>>1] * MEMORY_TYPE_MULTIPLIER_CZ,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tclks.clocks_in_khz[clks.num_levels-1] * MEMORY_TYPE_MULTIPLIER_CZ,\n\t\t1000);\n}\n\nconst struct resource_caps *dce110_resource_cap(\n\tstruct hw_asic_id *asic_id)\n{\n\tif (ASIC_REV_IS_STONEY(asic_id->hw_internal_rev))\n\t\treturn &stoney_resource_cap;\n\telse\n\t\treturn &carrizo_resource_cap;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool,\n\tstruct hw_asic_id asic_id)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = dce110_resource_cap(&ctx->asic_id);\n\tpool->base.funcs = &dce110_res_pool_funcs;\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.underlay_pipe_index = pool->base.pipe_count;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 150;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.is_apu = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0,\n\t\t\t\t\t\t&clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1,\n\t\t\t\t\t\t&clk_src_regs[1], false);\n\n\t\tpool->base.clk_src_count = 2;\n\n\t\t/* TODO: find out if CZ support 3 PLLs */\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce110_timing_generator_create(\n\t\t\t\tctx, i, &dce110_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce110_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce110_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce110_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce110_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce110_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce110_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tif (dc->config.fbc_support)\n\t\tdc->fbc_compressor = dce110_compressor_create(ctx);\n\n\tif (!underlay_create(ctx, &pool->base))\n\t\tgoto res_create_fail;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce110_hw_sequencer_construct(dc);\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < pool->base.underlay_pipe_index; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.planes[pool->base.underlay_pipe_index] = underlay_plane_cap;\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce110/dce110_timing_generator.h\"\n\n#include \"irq/dce110/irq_service_dce110.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_clock_source.h\"\n\n#include \"dce/dce_hwseq.h\"\n#include \"dce112/dce112_hw_sequencer.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_11_2_d.h\"\n#include \"dce/dce_11_2_sh_mask.h\"\n\n#include \"dce100/dce100_resource.h\"\n#define DC_LOGGER \\\n\t\tdc->ctx->logger\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n\t#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL 0x4ba7\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL 0x4ca7\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL 0x4da7\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL 0x4ea7\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL 0x4fa7\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL 0x54a7\n\t#define mmDP7_DP_DPHY_INTERNAL_CTRL 0x56a7\n\t#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7\n#endif\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL\n\t#define mmDP_DPHY_BS_SR_SWAP_CNTL                       0x4ADC\n\t#define mmDP0_DP_DPHY_BS_SR_SWAP_CNTL                   0x4ADC\n\t#define mmDP1_DP_DPHY_BS_SR_SWAP_CNTL                   0x4BDC\n\t#define mmDP2_DP_DPHY_BS_SR_SWAP_CNTL                   0x4CDC\n\t#define mmDP3_DP_DPHY_BS_SR_SWAP_CNTL                   0x4DDC\n\t#define mmDP4_DP_DPHY_BS_SR_SWAP_CNTL                   0x4EDC\n\t#define mmDP5_DP_DPHY_BS_SR_SWAP_CNTL                   0x4FDC\n\t#define mmDP6_DP_DPHY_BS_SR_SWAP_CNTL                   0x54DC\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x4ABC\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x4ABC\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x4BBC\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x4CBC\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x4DBC\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x4EBC\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4FBC\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x54BC\n#endif\n\nenum dce112_clk_src_array_id {\n\tDCE112_CLK_SRC_PLL0,\n\tDCE112_CLK_SRC_PLL1,\n\tDCE112_CLK_SRC_PLL2,\n\tDCE112_CLK_SRC_PLL3,\n\tDCE112_CLK_SRC_PLL4,\n\tDCE112_CLK_SRC_PLL5,\n\n\tDCE112_CLK_SRC_TOTAL\n};\n\nstatic const struct dce110_timing_generator_offsets dce112_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp =  (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE100_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE110_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE112(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE112(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_112_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5)\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(index, id)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCE_112(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps polaris_10_resource_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 8, /* why 8? 6 combo PHY PLL + 2 regular PLLs? */\n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps polaris_11_resource_cap = {\n\t\t.num_timing_generator = 5,\n\t\t.num_audio = 5,\n\t\t.num_stream_encoder = 5,\n\t\t.num_pll = 8, /* why 8? 6 combo PHY PLL + 2 regular PLLs? */\n\t\t.num_ddc = 5,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x4819\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\n\nstatic struct timing_generator *dce112_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce110_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct stream_encoder *dce112_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE112_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE112_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE112_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce112_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce112_stream_encoder_create,\n\t.create_hwseq = dce112_hwseq_create,\n};\n\n#define mi_inst_regs(id) { MI_DCE11_2_REG_LIST(id) }\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE11_2_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE11_2_MASK_SH_LIST(_MASK)\n};\n\nstatic struct mem_input *dce112_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce112_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\treturn &dce_mi->base;\n}\n\nstatic void dce112_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce112_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->lb_memory_size = 0x1404; /*5124*/\n\treturn &transform->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstruct link_encoder *dce112_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstatic struct input_pixel_processor *dce112_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstruct output_pixel_processor *dce112_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce112_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dce112_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce112_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce112_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce112_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL) {\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce112_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce112_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\nstatic struct clock_source *find_matching_pll(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tconst struct dc_stream_state *const stream)\n{\n\tswitch (stream->link->link_enc->transmitter) {\n\tcase TRANSMITTER_UNIPHY_A:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL0];\n\tcase TRANSMITTER_UNIPHY_B:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL1];\n\tcase TRANSMITTER_UNIPHY_C:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL2];\n\tcase TRANSMITTER_UNIPHY_D:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL3];\n\tcase TRANSMITTER_UNIPHY_E:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL4];\n\tcase TRANSMITTER_UNIPHY_F:\n\t\treturn pool->clock_sources[DCE112_CLK_SRC_PLL5];\n\tdefault:\n\t\treturn NULL;\n\t};\n\n\treturn 0;\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tdce110_resource_build_pipe_hw_param(pipe_ctx);\n\n\tresource_build_info_frame(pipe_ctx);\n\n\treturn DC_OK;\n}\n\nbool dce112_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tbool result = false;\n\n\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\"%s: start\",\n\t\t__func__);\n\n\tif (bw_calcs(\n\t\t\tdc->ctx,\n\t\t\tdc->bw_dceip,\n\t\t\tdc->bw_vbios,\n\t\t\tcontext->res_ctx.pipe_ctx,\n\t\t\tdc->res_pool->pipe_count,\n\t\t\t&context->bw_ctx.bw.dce))\n\t\tresult = true;\n\n\tif (!result)\n\t\tDC_LOG_BANDWIDTH_VALIDATION(\n\t\t\t\"%s: Bandwidth validation failed!\",\n\t\t\t__func__);\n\n\tif (memcmp(&dc->current_state->bw_ctx.bw.dce,\n\t\t\t&context->bw_ctx.bw.dce, sizeof(context->bw_ctx.bw.dce))) {\n\n\t\tDC_LOG_BANDWIDTH_CALCS(\n\t\t\t\"%s: finish,\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d\\n\"\n\t\t\t\"nbpMark_b: %d nbpMark_a: %d urgentMark_b: %d urgentMark_a: %d\\n\"\n\t\t\t\"stutMark_b: %d stutMark_a: %d stutter_mode_enable: %d\\n\"\n\t\t\t\"cstate: %d pstate: %d nbpstate: %d sync: %d dispclk: %d\\n\"\n\t\t\t\"sclk: %d sclk_sleep: %d yclk: %d blackout_recovery_time_us: %d\\n\"\n\t\t\t,\n\t\t\t__func__,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[0].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[1].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.urgent_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].b_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_exit_wm_ns[2].a_mark,\n\t\t\tcontext->bw_ctx.bw.dce.stutter_mode_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpuc_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.cpup_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.nbp_state_change_enable,\n\t\t\tcontext->bw_ctx.bw.dce.all_displays_in_sync,\n\t\t\tcontext->bw_ctx.bw.dce.dispclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.sclk_deep_sleep_khz,\n\t\t\tcontext->bw_ctx.bw.dce.yclk_khz,\n\t\t\tcontext->bw_ctx.bw.dce.blackout_recovery_time_us);\n\t}\n\treturn result;\n}\n\nenum dc_status resource_map_phy_clock_resources(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\n\t/* acquire new resources */\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(\n\t\t\t&context->res_ctx, stream);\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tif (dc_is_dp_signal(pipe_ctx->stream->signal)\n\t\t|| dc_is_virtual_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->clock_source =\n\t\t\t\tdc->res_pool->dp_clock_source;\n\telse\n\t\tpipe_ctx->clock_source = find_matching_pll(\n\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\tstream);\n\n\tif (pipe_ctx->clock_source == NULL)\n\t\treturn DC_NO_CLOCK_SOURCE_RESOURCE;\n\n\tresource_reference_clock_source(\n\t\t&context->res_ctx,\n\t\tdc->res_pool,\n\t\tpipe_ctx->clock_source);\n\n\treturn DC_OK;\n}\n\nstatic bool dce112_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce112_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nenum dc_status dce112_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce112_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic void dce112_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce112_res_pool_funcs = {\n\t.destroy = dce112_destroy_resource_pool,\n\t.link_enc_create = dce112_link_encoder_create,\n\t.validate_bandwidth = dce112_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce112_add_stream_to_ctx,\n\t.validate_global = dce112_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels_with_latency eng_clks = {0};\n\tstruct dm_pp_clock_levels_with_latency mem_clks = {0};\n\tstruct dm_pp_wm_sets_with_clock_ranges clk_ranges = {0};\n\tstruct dm_pp_clock_levels clks = {0};\n\tint memory_type_multiplier = MEMORY_TYPE_MULTIPLIER_CZ;\n\n\tif (dc->bw_vbios && dc->bw_vbios->memory_type == bw_def_hbm)\n\t\tmemory_type_multiplier = MEMORY_TYPE_HBM;\n\n\t/*do system clock  TODO PPLIB: after PPLIB implement,\n\t * then remove old way\n\t */\n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t&eng_clks)) {\n\n\t\t/* This is only for temporary */\n\t\tdm_pp_get_clock_levels_by_type(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t\t&clks);\n\t\t/* convert all the clock fro kHz to fix point mHz */\n\t\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels-1], 1000);\n\t\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels/8], 1000);\n\t\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*2/8], 1000);\n\t\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*3/8], 1000);\n\t\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*4/8], 1000);\n\t\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*5/8], 1000);\n\t\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[clks.num_levels*6/8], 1000);\n\t\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\t\tclks.clocks_in_khz[0], 1000);\n\n\t\t/*do memory clock*/\n\t\tdm_pp_get_clock_levels_by_type(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t\t&clks);\n\n\t\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[0] * memory_type_multiplier, 1000);\n\t\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels>>1] * memory_type_multiplier,\n\t\t\t1000);\n\t\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\t\tclks.clocks_in_khz[clks.num_levels-1] * memory_type_multiplier,\n\t\t\t1000);\n\n\t\treturn;\n\t}\n\n\t/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */\n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\teng_clks.data[0].clocks_in_khz, 1000);\n\n\t/*do memory clock*/\n\tdm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&mem_clks);\n\n\t/* we don't need to call PPLIB for validation clock since they\n\t * also give us the highest sclk and highest mclk (UMA clock).\n\t * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):\n\t * YCLK = UMACLK*m_memoryTypeMultiplier\n\t */\n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[0].clocks_in_khz * memory_type_multiplier, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels-1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\n\t/* Now notify PPLib/SMU about which Watermarks sets they should select\n\t * depending on DPM state they are in. And update BW MGR GFX Engine and\n\t * Memory clock member variables for Watermarks calculations for each\n\t * Watermark Set\n\t */\n\tclk_ranges.num_wm_sets = 4;\n\tclk_ranges.wm_clk_ranges[0].wm_set_id = WM_SET_A;\n\tclk_ranges.wm_clk_ranges[0].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[0].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[1].wm_set_id = WM_SET_B;\n\tclk_ranges.wm_clk_ranges[1].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[1].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[1].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[2].wm_set_id = WM_SET_C;\n\tclk_ranges.wm_clk_ranges[2].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[2].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[2].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;\n\n\tclk_ranges.wm_clk_ranges[3].wm_set_id = WM_SET_D;\n\tclk_ranges.wm_clk_ranges[3].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[3].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;\n\n\t/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */\n\tdm_pp_notify_wm_clock_changes(dc->ctx, &clk_ranges);\n}\n\nconst struct resource_caps *dce112_resource_cap(\n\tstruct hw_asic_id *asic_id)\n{\n\tif (ASIC_REV_IS_POLARIS11_M(asic_id->hw_internal_rev) ||\n\t    ASIC_REV_IS_POLARIS12_V(asic_id->hw_internal_rev))\n\t\treturn &polaris_11_resource_cap;\n\telse\n\t\treturn &polaris_10_resource_cap;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = dce112_resource_cap(&ctx->asic_id);\n\tpool->base.funcs = &dce112_res_pool_funcs;\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL0] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL1] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL2] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL3] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL4] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCE112_CLK_SRC_PLL5] =\n\t\t\tdce112_clock_source_create(\n\t\t\t\tctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =  dce112_clock_source_create(\n\t\tctx, ctx->dc_bios,\n\t\tCLOCK_SOURCE_ID_DP_DTO, &clk_src_regs[0], true);\n\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce110_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] =\n\t\t\t\tdce112_timing_generator_create(\n\t\t\t\t\tctx,\n\t\t\t\t\ti,\n\t\t\t\t\t&dce112_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce112_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce112_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce112_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce112_opp_create(\n\t\t\tctx,\n\t\t\ti);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce112_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce112_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t  &res_create_funcs))\n\t\tgoto res_create_fail;\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\t/* Create hardware sequencer */\n\tdce112_hw_sequencer_construct(dc);\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2012-15 Advanced Micro Devices, Inc.cls\n*\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n\n\n#include \"stream_encoder.h\"\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dce120_resource.h\"\n\n#include \"dce112/dce112_resource.h\"\n\n#include \"dce110/dce110_resource.h\"\n#include \"../virtual/virtual_stream_encoder.h\"\n#include \"dce120_timing_generator.h\"\n#include \"irq/dce120/irq_service_dce120.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_mem_input.h\"\n\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dce120/dce120_hw_sequencer.h\"\n#include \"dce/dce_transform.h\"\n#include \"clk_mgr.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n\n#include \"dce/dce_12_0_offset.h\"\n#include \"dce/dce_12_0_sh_mask.h\"\n#include \"soc15_hw_ip.h\"\n#include \"vega10_ip_offset.h\"\n#include \"nbio/nbio_6_1_offset.h\"\n#include \"mmhub/mmhub_9_4_0_offset.h\"\n#include \"mmhub/mmhub_9_4_0_sh_mask.h\"\n#include \"reg_helper.h\"\n\n#include \"dce100/dce100_resource.h\"\n\n#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL\t\t0x210f\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL\t\t0x220f\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL\t\t0x230f\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL\t\t0x240f\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL\t\t0x250f\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL\t\t0x260f\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL\t\t0x270f\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n#endif\n\nenum dce120_clk_src_array_id {\n\tDCE120_CLK_SRC_PLL0,\n\tDCE120_CLK_SRC_PLL1,\n\tDCE120_CLK_SRC_PLL2,\n\tDCE120_CLK_SRC_PLL3,\n\tDCE120_CLK_SRC_PLL4,\n\tDCE120_CLK_SRC_PLL5,\n\n\tDCE120_CLK_SRC_TOTAL\n};\n\nstatic const struct dce110_timing_generator_offsets dce120_tg_offsets[] = {\n\t{\n\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t},\n\t{\n\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC0_CRTC_CONTROL),\n\t}\n};\n\n/* begin *********************\n * macros to expend register list macro defined in HW object header file */\n\n#define BASE_INNER(seg) \\\n\tDCE_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE_INNER(seg) \\\n\tNBIF_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE(seg) \\\n\tNBIO_BASE_INNER(seg)\n\n/* compile time expand base address. */\n#define BASE(seg) \\\n\tBASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define SRI(reg_name, block, id)\\\n\t.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n/* MMHUB */\n#define MMHUB_BASE_INNER(seg) \\\n\tMMHUB_BASE__INST0_SEG ## seg\n\n#define MMHUB_BASE(seg) \\\n\tMMHUB_BASE_INNER(seg)\n\n#define MMHUB_SR(reg_name)\\\n\t\t.reg_name = MMHUB_BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n/* macros to expend register list macro defined in HW object header file\n * end *********************/\n\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_DCE110_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_DCE120_MASK_SH_LIST_SOC_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_DCE120_MASK_SH_LIST_SOC_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE110(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_SOC_BASE(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_SOC_BASE(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE120_REG_LIST(id), \\\n\tSRI(DP_DPHY_INTERNAL_CTRL, DP, id) \\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST(id),\\\n\t.TMDS_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE120(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE120(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_120_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_120(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_120(_MASK)\n};\n #define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5)\n};\n\n#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\\\n\t\tAUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(index, id)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCE_112(id),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_112(_MASK)\n};\n\nstruct output_pixel_processor *dce120_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\nstruct dce_aux *dce120_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dce120_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce112_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3 + NBIO_BASE(mmBIOS_SCRATCH_3_BASE_IDX),\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6 + NBIO_BASE(mmBIOS_SCRATCH_6_BASE_IDX)\n};\n\nstatic const struct resource_caps res_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 7,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 6,\n\t\t.num_ddc = 6,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\nstatic const struct dc_debug_options debug_defaults = {\n\t\t.disable_clock_gate = true,\n};\n\nstatic struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void dce120_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\n\nstatic bool dce120_hw_sequencer_create(struct dc *dc)\n{\n\t/* All registers used by dce11.2 match those in dce11 in offset and\n\t * structure\n\t */\n\tdce120_hw_sequencer_construct(dc);\n\n\t/*TODO\tMove to separate file and Override what is needed */\n\n\treturn true;\n}\n\nstatic struct timing_generator *dce120_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce120_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic void dce120_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce120_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.irqs != NULL) {\n\t\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL) {\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.audio_count; i++) {\n\t\tif (pool->base.audios[i])\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL)\n\t\t\tdce120_clock_source_destroy(\n\t\t\t\t&pool->base.clock_sources[i]);\n\t}\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce120_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tuint32_t reg_val = dm_read_reg_soc15(ctx, mmCC_DC_MISC_STRAPS, 0);\n\n\tstraps->audio_stream_number = get_reg_field_value(reg_val,\n\t\t\t\t\t\t\t  CC_DC_MISC_STRAPS,\n\t\t\t\t\t\t\t  AUDIO_STREAM_NUMBER);\n\tstraps->hdmi_disable = get_reg_field_value(reg_val,\n\t\t\t\t\t\t   CC_DC_MISC_STRAPS,\n\t\t\t\t\t\t   HDMI_DISABLE);\n\n\treg_val = dm_read_reg_soc15(ctx, mmDC_PINSTRAPS, 0);\n\tstraps->dc_pinstraps_audio = get_reg_field_value(reg_val,\n\t\t\t\t\t\t\t DC_PINSTRAPS,\n\t\t\t\t\t\t\t DC_PINSTRAPS_AUDIO);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true,\n};\n\nstatic struct link_encoder *dce120_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\n\treturn &enc110->base;\n}\n\nstatic struct input_pixel_processor *dce120_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic struct stream_encoder *dce120_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE120_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE12_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE12_MASK_SH_LIST(_MASK)\n};\n\n/* HWSEQ regs for VG20 */\nstatic const struct dce_hwseq_registers dce121_hwseq_reg = {\n\t\tHWSEQ_VG20_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift dce121_hwseq_shift = {\n\t\tHWSEQ_VG20_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask dce121_hwseq_mask = {\n\t\tHWSEQ_VG20_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce120_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic struct dce_hwseq *dce121_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &dce121_hwseq_reg;\n\t\thws->shifts = &dce121_hwseq_shift;\n\t\thws->masks = &dce121_hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce120_stream_encoder_create,\n\t.create_hwseq = dce120_hwseq_create,\n};\n\nstatic const struct resource_create_funcs dce121_res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce120_stream_encoder_create,\n\t.create_hwseq = dce121_hwseq_create,\n};\n\n\n#define mi_inst_regs(id) { MI_DCE12_REG_LIST(id) }\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE12_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE12_MASK_SH_LIST(_MASK)\n};\n\nstatic struct mem_input *dce120_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce120_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\treturn &dce_mi->base;\n}\n\nstatic struct transform *dce120_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->lb_memory_size = 0x1404; /*5124*/\n\treturn &transform->base;\n}\n\nstatic void dce120_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce120_res_pool_funcs = {\n\t.destroy = dce120_destroy_resource_pool,\n\t.link_enc_create = dce120_link_encoder_create,\n\t.validate_bandwidth = dce112_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce112_add_stream_to_ctx,\n\t.find_first_free_match_stream_enc_for_link = dce110_find_first_free_match_stream_enc_for_link\n};\n\nstatic void bw_calcs_data_update_from_pplib(struct dc *dc)\n{\n\tstruct dm_pp_clock_levels_with_latency eng_clks = {0};\n\tstruct dm_pp_clock_levels_with_latency mem_clks = {0};\n\tstruct dm_pp_wm_sets_with_clock_ranges clk_ranges = {0};\n\tint i;\n\tunsigned int clk;\n\tunsigned int latency;\n\t/*original logic in dal3*/\n\tint memory_type_multiplier = MEMORY_TYPE_MULTIPLIER_CZ;\n\n\t/*do system clock*/\n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\t\tdc->ctx,\n\t\t\t\tDM_PP_CLOCK_TYPE_ENGINE_CLK,\n\t\t\t\t&eng_clks) || eng_clks.num_levels == 0) {\n\n\t\teng_clks.num_levels = 8;\n\t\tclk = 300000;\n\n\t\tfor (i = 0; i < eng_clks.num_levels; i++) {\n\t\t\teng_clks.data[i].clocks_in_khz = clk;\n\t\t\tclk += 100000;\n\t\t}\n\t}\n\n\t/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */\n\tdc->bw_vbios->high_sclk = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(\n\t\teng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);\n\tdc->bw_vbios->low_sclk  = bw_frc_to_fixed(\n\t\t\teng_clks.data[0].clocks_in_khz, 1000);\n\n\t/*do memory clock*/\n\tif (!dm_pp_get_clock_levels_by_type_with_latency(\n\t\t\tdc->ctx,\n\t\t\tDM_PP_CLOCK_TYPE_MEMORY_CLK,\n\t\t\t&mem_clks) || mem_clks.num_levels == 0) {\n\n\t\tmem_clks.num_levels = 3;\n\t\tclk = 250000;\n\t\tlatency = 45;\n\n\t\tfor (i = 0; i < eng_clks.num_levels; i++) {\n\t\t\tmem_clks.data[i].clocks_in_khz = clk;\n\t\t\tmem_clks.data[i].latency_in_us = latency;\n\t\t\tclk += 500000;\n\t\t\tlatency -= 5;\n\t\t}\n\n\t}\n\n\t/* we don't need to call PPLIB for validation clock since they\n\t * also give us the highest sclk and highest mclk (UMA clock).\n\t * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):\n\t * YCLK = UMACLK*m_memoryTypeMultiplier\n\t */\n\tif (dc->bw_vbios->memory_type == bw_def_hbm)\n\t\tmemory_type_multiplier = MEMORY_TYPE_HBM;\n\n\tdc->bw_vbios->low_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[0].clocks_in_khz * memory_type_multiplier, 1000);\n\tdc->bw_vbios->mid_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\tdc->bw_vbios->high_yclk = bw_frc_to_fixed(\n\t\tmem_clks.data[mem_clks.num_levels-1].clocks_in_khz * memory_type_multiplier,\n\t\t1000);\n\n\t/* Now notify PPLib/SMU about which Watermarks sets they should select\n\t * depending on DPM state they are in. And update BW MGR GFX Engine and\n\t * Memory clock member variables for Watermarks calculations for each\n\t * Watermark Set\n\t */\n\tclk_ranges.num_wm_sets = 4;\n\tclk_ranges.wm_clk_ranges[0].wm_set_id = WM_SET_A;\n\tclk_ranges.wm_clk_ranges[0].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[0].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[0].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[1].wm_set_id = WM_SET_B;\n\tclk_ranges.wm_clk_ranges[1].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[1].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[1].wm_max_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;\n\n\tclk_ranges.wm_clk_ranges[2].wm_set_id = WM_SET_C;\n\tclk_ranges.wm_clk_ranges[2].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[0].clocks_in_khz;\n\tclk_ranges.wm_clk_ranges[2].wm_max_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;\n\tclk_ranges.wm_clk_ranges[2].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;\n\n\tclk_ranges.wm_clk_ranges[3].wm_set_id = WM_SET_D;\n\tclk_ranges.wm_clk_ranges[3].wm_min_eng_clk_in_khz =\n\t\t\teng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;\n\t/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;\n\tclk_ranges.wm_clk_ranges[3].wm_min_mem_clk_in_khz =\n\t\t\tmem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;\n\t/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */\n\tclk_ranges.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;\n\n\t/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */\n\tdm_pp_notify_wm_clock_changes(dc->ctx, &clk_ranges);\n}\n\nstatic uint32_t read_pipe_fuses(struct dc_context *ctx)\n{\n\tuint32_t value = dm_read_reg_soc15(ctx, mmCC_DC_PIPE_DIS, 0);\n\t/* VG20 support max 6 pipes */\n\tvalue = value & 0x3f;\n\treturn value;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tint j;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct irq_service_init_data irq_init_data;\n\tstatic const struct resource_create_funcs *res_funcs;\n\tbool is_vg20 = ASICREV_IS_VEGA20_P(ctx->asic_id.hw_internal_rev);\n\tuint32_t pipe_fuses;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dce120_res_pool_funcs;\n\n\t/* TODO: Fill more data from GreenlandAsicCapability.cpp */\n\tpool->base.pipe_count = res_cap.num_timing_generator;\n\tpool->base.timing_generator_count = pool->base.res_cap->num_timing_generator;\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\tdc->caps.psp_setup_panel_mode = true;\n\n\tdc->debug = debug_defaults;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL0] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL1] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL2] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL3] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL4] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCE120_CLK_SRC_PLL5] =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCE120_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =\n\t\t\tdce120_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_ID_DP_DTO,\n\t\t\t\t&clk_src_regs[0], true);\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto clk_src_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\n\tirq_init_data.ctx = dc->ctx;\n\tpool->base.irqs = dal_irq_service_dce120_create(&irq_init_data);\n\tif (!pool->base.irqs)\n\t\tgoto irqs_create_fail;\n\n\t/* VG20: Pipe harvesting enabled, retrieve valid pipe fuses */\n\tif (is_vg20)\n\t\tpipe_fuses = read_pipe_fuses(ctx);\n\n\t/* index to valid pipe resource */\n\tj = 0;\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (is_vg20) {\n\t\t\tif ((pipe_fuses & (1 << i)) != 0) {\n\t\t\t\tdm_error(\"DC: skip invalid pipe %d!\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpool->base.timing_generators[j] =\n\t\t\t\tdce120_timing_generator_create(\n\t\t\t\t\tctx,\n\t\t\t\t\ti,\n\t\t\t\t\t&dce120_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto controller_create_fail;\n\t\t}\n\n\t\tpool->base.mis[j] = dce120_mem_input_create(ctx, i);\n\n\t\tif (pool->base.mis[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto controller_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[j] = dce120_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto controller_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[j] = dce120_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[j] = dce120_opp_create(\n\t\t\tctx,\n\t\t\ti);\n\t\tif (pool->base.opps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t}\n\n\t\t/* check next valid pipe */\n\t\tj++;\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce120_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce120_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\t/* valid pipe num */\n\tpool->base.pipe_count = j;\n\tpool->base.timing_generator_count = j;\n\n\tif (is_vg20)\n\t\tres_funcs = &dce121_res_create_funcs;\n\telse\n\t\tres_funcs = &res_create_funcs;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base, res_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tif (!dce120_hw_sequencer_create(dc))\n\t\tgoto controller_create_fail;\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tbw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);\n\n\tbw_calcs_data_update_from_pplib(dc);\n\n\treturn true;\n\nirqs_create_fail:\ncontroller_create_fail:\nclk_src_create_fail:\nres_create_fail:\n\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n * Copyright 2012-15 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dce/dce_8_0_d.h\"\n#include \"dce/dce_8_0_sh_mask.h\"\n\n#include \"dm_services.h\"\n\n#include \"link_encoder.h\"\n#include \"stream_encoder.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"irq/dce80/irq_service_dce80.h\"\n#include \"dce110/dce110_timing_generator.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce80/dce80_timing_generator.h\"\n#include \"dce/dce_mem_input.h\"\n#include \"dce/dce_link_encoder.h\"\n#include \"dce/dce_stream_encoder.h\"\n#include \"dce/dce_ipp.h\"\n#include \"dce/dce_transform.h\"\n#include \"dce/dce_opp.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"dce80/dce80_hw_sequencer.h\"\n#include \"dce100/dce100_resource.h\"\n\n#include \"reg_helper.h\"\n\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_i2c.h\"\n/* TODO remove this include */\n\n#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT\n#include \"gmc/gmc_7_1_d.h\"\n#include \"gmc/gmc_7_1_sh_mask.h\"\n#endif\n\n#ifndef mmDP_DPHY_INTERNAL_CTRL\n#define mmDP_DPHY_INTERNAL_CTRL                         0x1CDE\n#define mmDP0_DP_DPHY_INTERNAL_CTRL                     0x1CDE\n#define mmDP1_DP_DPHY_INTERNAL_CTRL                     0x1FDE\n#define mmDP2_DP_DPHY_INTERNAL_CTRL                     0x42DE\n#define mmDP3_DP_DPHY_INTERNAL_CTRL                     0x45DE\n#define mmDP4_DP_DPHY_INTERNAL_CTRL                     0x48DE\n#define mmDP5_DP_DPHY_INTERNAL_CTRL                     0x4BDE\n#define mmDP6_DP_DPHY_INTERNAL_CTRL                     0x4EDE\n#endif\n\n\n#ifndef mmBIOS_SCRATCH_2\n\t#define mmBIOS_SCRATCH_2 0x05CB\n\t#define mmBIOS_SCRATCH_3 0x05CC\n\t#define mmBIOS_SCRATCH_6 0x05CF\n#endif\n\n#ifndef mmDP_DPHY_FAST_TRAINING\n\t#define mmDP_DPHY_FAST_TRAINING                         0x1CCE\n\t#define mmDP0_DP_DPHY_FAST_TRAINING                     0x1CCE\n\t#define mmDP1_DP_DPHY_FAST_TRAINING                     0x1FCE\n\t#define mmDP2_DP_DPHY_FAST_TRAINING                     0x42CE\n\t#define mmDP3_DP_DPHY_FAST_TRAINING                     0x45CE\n\t#define mmDP4_DP_DPHY_FAST_TRAINING                     0x48CE\n\t#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4BCE\n\t#define mmDP6_DP_DPHY_FAST_TRAINING                     0x4ECE\n#endif\n\n\n#ifndef mmHPD_DC_HPD_CONTROL\n\t#define mmHPD_DC_HPD_CONTROL                            0x189A\n\t#define mmHPD0_DC_HPD_CONTROL                           0x189A\n\t#define mmHPD1_DC_HPD_CONTROL                           0x18A2\n\t#define mmHPD2_DC_HPD_CONTROL                           0x18AA\n\t#define mmHPD3_DC_HPD_CONTROL                           0x18B2\n\t#define mmHPD4_DC_HPD_CONTROL                           0x18BA\n\t#define mmHPD5_DC_HPD_CONTROL                           0x18C2\n#endif\n\n#define DCE11_DIG_FE_CNTL 0x4a00\n#define DCE11_DIG_BE_CNTL 0x4a47\n#define DCE11_DP_SEC 0x4ac3\n\nstatic const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {\n\t\t{\n\t\t\t.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp =  (mmGRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t},\n\t\t{\n\t\t\t.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),\n\t\t\t.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),\n\t\t\t.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL\n\t\t\t\t\t- mmDPG_WATERMARK_MASK_CONTROL),\n\t\t}\n};\n\n/* set register offset */\n#define SR(reg_name)\\\n\t.reg_name = mm ## reg_name\n\n/* set register offset with instance */\n#define SRI(reg_name, block, id)\\\n\t.reg_name = mm ## block ## id ## _ ## reg_name\n\n#define ipp_regs(id)\\\n[id] = {\\\n\t\tIPP_COMMON_REG_LIST_DCE_BASE(id)\\\n}\n\nstatic const struct dce_ipp_registers ipp_regs[] = {\n\t\tipp_regs(0),\n\t\tipp_regs(1),\n\t\tipp_regs(2),\n\t\tipp_regs(3),\n\t\tipp_regs(4),\n\t\tipp_regs(5)\n};\n\nstatic const struct dce_ipp_shift ipp_shift = {\n\t\tIPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_ipp_mask ipp_mask = {\n\t\tIPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\n#define transform_regs(id)\\\n[id] = {\\\n\t\tXFM_COMMON_REG_LIST_DCE80(id)\\\n}\n\nstatic const struct dce_transform_registers xfm_regs[] = {\n\t\ttransform_regs(0),\n\t\ttransform_regs(1),\n\t\ttransform_regs(2),\n\t\ttransform_regs(3),\n\t\ttransform_regs(4),\n\t\ttransform_regs(5)\n};\n\nstatic const struct dce_transform_shift xfm_shift = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE80(__SHIFT)\n};\n\nstatic const struct dce_transform_mask xfm_mask = {\n\t\tXFM_COMMON_MASK_SH_LIST_DCE80(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {\n\taux_regs(0),\n\taux_regs(1),\n\taux_regs(2),\n\taux_regs(3),\n\taux_regs(4),\n\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCE80_REG_LIST(id)\\\n}\n\nstatic const struct dce110_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3),\n\tlink_regs(4),\n\tlink_regs(5),\n\tlink_regs(6),\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_COMMON_REG_LIST_DCE_BASE(id),\\\n\t.AFMT_CNTL = 0,\\\n}\n\nstatic const struct dce110_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5),\n\tstream_enc_regs(6)\n};\n\nstatic const struct dce_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(__SHIFT)\n};\n\nstatic const struct dce_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_DCE_80_REG_LIST(id),\\\n}\n\nstatic const struct dce_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5)\n};\n\nstatic const struct dce_opp_shift opp_shift = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_80(__SHIFT)\n};\n\nstatic const struct dce_opp_mask opp_mask = {\n\tOPP_COMMON_MASK_SH_LIST_DCE_80(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tAUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tAUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define clk_src_regs(id)\\\n[id] = {\\\n\tCS_COMMON_REG_LIST_DCE_80(id),\\\n}\n\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0),\n\tclk_src_regs(1),\n\tclk_src_regs(2)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,\n\t.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6\n};\n\nstatic const struct resource_caps res_cap = {\n\t\t.num_timing_generator = 6,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 3,\n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps res_cap_81 = {\n\t\t.num_timing_generator = 4,\n\t\t.num_audio = 7,\n\t\t.num_stream_encoder = 7,\n\t\t.num_pll = 3,\n\t\t.num_ddc = 6,\n};\n\nstatic const struct resource_caps res_cap_83 = {\n\t\t.num_timing_generator = 2,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 2,\n\t\t.num_ddc = 2,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCE_RGB,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = false,\n\t\t\t.fp16 = false\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 1,\n\t\t\t.fp16 = 1\n\t}\n};\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCE80_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCE80(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCE80(_MASK)\n};\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCE110_COMMON_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCE110(_MASK)\n};\n\n#define CTX  ctx\n#define REG(reg) mm ## reg\n\n#ifndef mmCC_DC_HDMI_STRAPS\n#define mmCC_DC_HDMI_STRAPS 0x1918\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40\n#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700\n#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8\n#endif\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tREG_GET_2(CC_DC_HDMI_STRAPS,\n\t\t\tHDMI_DISABLE, &straps->hdmi_disable,\n\t\t\tAUDIO_STREAM_NUMBER, &straps->audio_stream_number);\n\n\tREG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct timing_generator *dce80_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance,\n\t\tconst struct dce110_timing_generator_offsets *offsets)\n{\n\tstruct dce110_timing_generator *tg110 =\n\t\tkzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);\n\n\tif (!tg110)\n\t\treturn NULL;\n\n\tdce80_timing_generator_construct(tg110, ctx, instance, offsets);\n\treturn &tg110->base;\n}\n\nstatic struct output_pixel_processor *dce80_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dce80_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)\n};\n\nstruct dce_i2c_hw *dce80_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdce_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\n\nstruct dce_i2c_sw *dce80_i2c_sw_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_i2c_sw *dce_i2c_sw =\n\t\tkzalloc(sizeof(struct dce_i2c_sw), GFP_KERNEL);\n\n\tif (!dce_i2c_sw)\n\t\treturn NULL;\n\n\tdce_i2c_sw_construct(dce_i2c_sw, ctx);\n\n\treturn dce_i2c_sw;\n}\nstatic struct stream_encoder *dce80_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dce110_stream_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc110->base;\n}\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = mm ## block ## id ## _ ## reg_name\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCE8_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCE8_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCE8_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dce80_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dce80_stream_encoder_create,\n\t.create_hwseq = dce80_hwseq_create,\n};\n\n#define mi_inst_regs(id) { \\\n\tMI_DCE8_REG_LIST(id), \\\n\t.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \\\n}\nstatic const struct dce_mem_input_registers mi_regs[] = {\n\t\tmi_inst_regs(0),\n\t\tmi_inst_regs(1),\n\t\tmi_inst_regs(2),\n\t\tmi_inst_regs(3),\n\t\tmi_inst_regs(4),\n\t\tmi_inst_regs(5),\n};\n\nstatic const struct dce_mem_input_shift mi_shifts = {\n\t\tMI_DCE8_MASK_SH_LIST(__SHIFT),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT\n};\n\nstatic const struct dce_mem_input_mask mi_masks = {\n\t\tMI_DCE8_MASK_SH_LIST(_MASK),\n\t\t.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK\n};\n\nstatic struct mem_input *dce80_mem_input_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!dce_mi) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);\n\tdce_mi->wa.single_head_rdreq_dmif_limit = 2;\n\treturn &dce_mi->base;\n}\n\nstatic void dce80_transform_destroy(struct transform **xfm)\n{\n\tkfree(TO_DCE_TRANSFORM(*xfm));\n\t*xfm = NULL;\n}\n\nstatic struct transform *dce80_transform_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_transform *transform =\n\t\tkzalloc(sizeof(struct dce_transform), GFP_KERNEL);\n\n\tif (!transform)\n\t\treturn NULL;\n\n\tdce_transform_construct(transform, ctx, inst,\n\t\t\t\t&xfm_regs[inst], &xfm_shift, &xfm_mask);\n\ttransform->prescaler_on = false;\n\treturn &transform->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 297000,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true\n};\n\nstruct link_encoder *dce80_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dce110_link_encoder *enc110 =\n\t\tkzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);\n\n\tif (!enc110)\n\t\treturn NULL;\n\n\tdce110_link_encoder_construct(enc110,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source]);\n\treturn &enc110->base;\n}\n\nstruct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nvoid dce80_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic struct input_pixel_processor *dce80_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdce_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\nstatic void destruct(struct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tdce110_opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.transforms[i] != NULL)\n\t\t\tdce80_transform_destroy(&pool->base.transforms[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tdce_ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.mis[i] != NULL) {\n\t\t\tkfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));\n\t\t\tpool->base.mis[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL)\n\t\t\tkfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdce80_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t}\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.dp_clock_source != NULL)\n\t\tdce80_clock_source_destroy(&pool->base.dp_clock_source);\n\n\tfor (i = 0; i < pool->base.audio_count; i++)\t{\n\t\tif (pool->base.audios[i] != NULL) {\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t\t}\n\t}\n\n\tif (pool->base.irqs != NULL) {\n\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t}\n}\n\nbool dce80_validate_bandwidth(\n\tstruct dc *dc,\n\tstruct dc_state *context,\n\tbool fast_validate)\n{\n\tint i;\n\tbool at_least_one_pipe = false;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (context->res_ctx.pipe_ctx[i].stream)\n\t\t\tat_least_one_pipe = true;\n\t}\n\n\tif (at_least_one_pipe) {\n\t\t/* TODO implement when needed but for now hardcode max value*/\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 681000;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;\n\t} else {\n\t\tcontext->bw_ctx.bw.dce.dispclk_khz = 0;\n\t\tcontext->bw_ctx.bw.dce.yclk_khz = 0;\n\t}\n\n\treturn true;\n}\n\nstatic bool dce80_validate_surface_sets(\n\t\tstruct dc_state *context)\n{\n\tint i;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 1)\n\t\t\treturn false;\n\n\t\tif (context->stream_status[i].plane_states[0]->format\n\t\t\t\t>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nenum dc_status dce80_validate_global(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tif (!dce80_validate_surface_sets(context))\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic void dce80_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);\n\n\tdestruct(dce110_pool);\n\tkfree(dce110_pool);\n\t*pool = NULL;\n}\n\nstatic const struct resource_funcs dce80_res_pool_funcs = {\n\t.destroy = dce80_destroy_resource_pool,\n\t.link_enc_create = dce80_link_encoder_create,\n\t.validate_bandwidth = dce80_validate_bandwidth,\n\t.validate_plane = dce100_validate_plane,\n\t.add_stream_to_ctx = dce100_add_stream_to_ctx,\n\t.validate_global = dce80_validate_global,\n\t.find_first_free_match_stream_enc_for_link = dce100_find_first_free_match_stream_enc_for_link\n};\n\nstatic bool dce80_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dce80_res_pool_funcs;\n\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap.num_timing_generator;\n\tpool->base.timing_generator_count = res_cap.num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.dual_link_dvi = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[2] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 3;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 2;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce80_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce80_timing_generator_create(\n\t\t\t\tctx, i, &dce80_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce80_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce80_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce80_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce80_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce80_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);\n\t\tif (pool->base.sw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create sw i2c!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.disable_dp_clk_share = true;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce80_hw_sequencer_construct(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce80_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce80_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic bool dce81_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap_81;\n\tpool->base.funcs = &dce80_res_pool_funcs;\n\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap_81.num_timing_generator;\n\tpool->base.timing_generator_count = res_cap_81.num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.is_apu = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[2] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 3;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);\n\t\tpool->base.clk_src_count = 2;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce80_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce80_timing_generator_create(\n\t\t\t\tctx, i, &dce80_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce80_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce80_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce80_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce80_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce80_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);\n\t\tif (pool->base.sw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create sw i2c!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.disable_dp_clk_share = true;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce80_hw_sequencer_construct(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce81_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce81_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic bool dce83_construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dce110_resource_pool *pool)\n{\n\tunsigned int i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct dc_bios *bp;\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tpool->base.res_cap = &res_cap_83;\n\tpool->base.funcs = &dce80_res_pool_funcs;\n\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\tpool->base.pipe_count = res_cap_83.num_timing_generator;\n\tpool->base.timing_generator_count = res_cap_83.num_timing_generator;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 40;\n\tdc->caps.max_cursor_size = 128;\n\tdc->caps.is_apu = true;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tbp = ctx->dc_bios;\n\n\tif (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[0], false);\n\t\tpool->base.clock_sources[1] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[1], false);\n\t\tpool->base.clk_src_count = 2;\n\n\t} else {\n\t\tpool->base.dp_clock_source =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[0], true);\n\n\t\tpool->base.clock_sources[0] =\n\t\t\t\tdce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[1], false);\n\t\tpool->base.clk_src_count = 1;\n\t}\n\n\tif (pool->base.dp_clock_source == NULL) {\n\t\tdm_error(\"DC: failed to create dp clock source!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dce_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto res_create_fail;\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dce80_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto res_create_fail;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.timing_generators[i] = dce80_timing_generator_create(\n\t\t\t\tctx, i, &dce80_tg_offsets[i]);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.mis[i] = dce80_mem_input_create(ctx, i);\n\t\tif (pool->base.mis[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create memory input!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dce80_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.transforms[i] = dce80_transform_create(ctx, i);\n\t\tif (pool->base.transforms[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create transform!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\n\t\tpool->base.opps[i] = dce80_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dce80_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create i2c engine!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);\n\t\tif (pool->base.sw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create sw i2c!!\\n\");\n\t\t\tgoto res_create_fail;\n\t\t}\n\t}\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->caps.disable_dp_clk_share = true;\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t&res_create_funcs))\n\t\tgoto res_create_fail;\n\n\t/* Create hardware sequencer */\n\tdce80_hw_sequencer_construct(dc);\n\n\treturn true;\n\nres_create_fail:\n\tdestruct(pool);\n\treturn false;\n}\n\nstruct resource_pool *dce83_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce83_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2016 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n#include \"dc.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dcn10_resource.h\"\n#include \"dcn10_ipp.h\"\n#include \"dcn10_mpc.h\"\n#include \"irq/dcn10/irq_service_dcn10.h\"\n#include \"dcn10_dpp.h\"\n#include \"dcn10_optc.h\"\n#include \"dcn10_hw_sequencer.h\"\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dcn10_opp.h\"\n#include \"dcn10_link_encoder.h\"\n#include \"dcn10_stream_encoder.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"virtual/virtual_stream_encoder.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dce112/dce112_resource.h\"\n#include \"dcn10_hubp.h\"\n#include \"dcn10_hubbub.h\"\n\n#include \"soc15_hw_ip.h\"\n#include \"vega10_ip_offset.h\"\n\n#include \"dcn/dcn_1_0_offset.h\"\n#include \"dcn/dcn_1_0_sh_mask.h\"\n\n#include \"nbio/nbio_7_0_offset.h\"\n\n#include \"mmhub/mmhub_9_1_offset.h\"\n#include \"mmhub/mmhub_9_1_sh_mask.h\"\n\n#include \"reg_helper.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n\nconst struct _vcs_dpi_ip_params_st dcn1_0_ip = {\n\t.rob_buffer_size_kbytes = 64,\n\t.det_buffer_size_kbytes = 164,\n\t.dpte_buffer_size_in_pte_reqs_luma = 42,\n\t.dpp_output_buffer_pixels = 2560,\n\t.opp_output_buffer_lines = 1,\n\t.pixel_chunk_size_kbytes = 8,\n\t.pte_enable = 1,\n\t.pte_chunk_size_kbytes = 2,\n\t.meta_chunk_size_kbytes = 2,\n\t.writeback_chunk_size_kbytes = 2,\n\t.line_buffer_size_bits = 589824,\n\t.max_line_buffer_lines = 12,\n\t.IsLineBufferBppFixed = 0,\n\t.LineBufferFixedBpp = -1,\n\t.writeback_luma_buffer_size_kbytes = 12,\n\t.writeback_chroma_buffer_size_kbytes = 8,\n\t.max_num_dpp = 4,\n\t.max_num_wb = 2,\n\t.max_dchub_pscl_bw_pix_per_clk = 4,\n\t.max_pscl_lb_bw_pix_per_clk = 2,\n\t.max_lb_vscl_bw_pix_per_clk = 4,\n\t.max_vscl_hscl_bw_pix_per_clk = 4,\n\t.max_hscl_ratio = 4,\n\t.max_vscl_ratio = 4,\n\t.hscl_mults = 4,\n\t.vscl_mults = 4,\n\t.max_hscl_taps = 8,\n\t.max_vscl_taps = 8,\n\t.dispclk_ramp_margin_percent = 1,\n\t.underscan_factor = 1.10,\n\t.min_vblank_lines = 14,\n\t.dppclk_delay_subtotal = 90,\n\t.dispclk_delay_subtotal = 42,\n\t.dcfclk_cstate_latency = 10,\n\t.max_inter_dcn_tile_repeaters = 8,\n\t.can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one = 0,\n\t.bug_forcing_LC_req_same_size_fixed = 0,\n};\n\nconst struct _vcs_dpi_soc_bounding_box_st dcn1_0_soc = {\n\t.sr_exit_time_us = 9.0,\n\t.sr_enter_plus_exit_time_us = 11.0,\n\t.urgent_latency_us = 4.0,\n\t.writeback_latency_us = 12.0,\n\t.ideal_dram_bw_after_urgent_percent = 80.0,\n\t.max_request_size_bytes = 256,\n\t.downspread_percent = 0.5,\n\t.dram_page_open_time_ns = 50.0,\n\t.dram_rw_turnaround_time_ns = 17.5,\n\t.dram_return_buffer_per_channel_bytes = 8192,\n\t.round_trip_ping_latency_dcfclk_cycles = 128,\n\t.urgent_out_of_order_return_per_channel_bytes = 256,\n\t.channel_interleave_bytes = 256,\n\t.num_banks = 8,\n\t.num_chans = 2,\n\t.vmm_page_size_bytes = 4096,\n\t.dram_clock_change_latency_us = 17.0,\n\t.writeback_dram_clock_change_latency_us = 23.0,\n\t.return_bus_width_bytes = 64,\n};\n\n#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL\t\t0x210f\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL\t\t0x220f\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL\t\t0x230f\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL\t\t0x240f\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL\t\t0x250f\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL\t\t0x260f\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL\t\t0x270f\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n#endif\n\n\nenum dcn10_clk_src_array_id {\n\tDCN10_CLK_SRC_PLL0,\n\tDCN10_CLK_SRC_PLL1,\n\tDCN10_CLK_SRC_PLL2,\n\tDCN10_CLK_SRC_PLL3,\n\tDCN10_CLK_SRC_TOTAL,\n\tDCN101_CLK_SRC_TOTAL = DCN10_CLK_SRC_PLL3\n};\n\n/* begin *********************\n * macros to expend register list macro defined in HW object header file */\n\n/* DCN */\n#define BASE_INNER(seg) \\\n\tDCE_BASE__INST0_SEG ## seg\n\n#define BASE(seg) \\\n\tBASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define SRI(reg_name, block, id)\\\n\t.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n/* NBIO */\n#define NBIO_BASE_INNER(seg) \\\n\tNBIF_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE(seg) \\\n\tNBIO_BASE_INNER(seg)\n\n#define NBIO_SR(reg_name)\\\n\t\t.reg_name = NBIO_BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n/* MMHUB */\n#define MMHUB_BASE_INNER(seg) \\\n\tMMHUB_BASE__INST0_SEG ## seg\n\n#define MMHUB_BASE(seg) \\\n\tMMHUB_BASE_INNER(seg)\n\n#define MMHUB_SR(reg_name)\\\n\t\t.reg_name = MMHUB_BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n/* macros to expend register list macro defined in HW object header file\n * end *********************/\n\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCN10_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCN10(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCN10_REG_LIST(0)\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_DCN_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n};\n\nstatic const struct dcn10_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\t\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n};\n\n#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\\\n\t\tAUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define aux_regs(id)\\\n[id] = {\\\n\tAUX_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3)\n};\n\n#define link_regs(id)\\\n[id] = {\\\n\tLE_DCN10_REG_LIST(id), \\\n\tSRI(DP_DPHY_INTERNAL_CTRL, DP, id) \\\n}\n\nstatic const struct dcn10_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0),\n\tlink_regs(1),\n\tlink_regs(2),\n\tlink_regs(3)\n};\n\nstatic const struct dcn10_link_enc_shift le_shift = {\n\t\tLINK_ENCODER_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_link_enc_mask le_mask = {\n\t\tLINK_ENCODER_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\tIPP_REG_LIST_DCN10(id),\\\n}\n\nstatic const struct dcn10_ipp_registers ipp_regs[] = {\n\tipp_regs(0),\n\tipp_regs(1),\n\tipp_regs(2),\n\tipp_regs(3),\n};\n\nstatic const struct dcn10_ipp_shift ipp_shift = {\n\t\tIPP_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_ipp_mask ipp_mask = {\n\t\tIPP_MASK_SH_LIST_DCN10(_MASK),\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_REG_LIST_DCN10(id),\\\n}\n\nstatic const struct dcn10_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n};\n\nstatic const struct dcn10_opp_shift opp_shift = {\n\t\tOPP_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn10_opp_mask opp_mask = {\n\t\tOPP_MASK_SH_LIST_DCN10(_MASK),\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST(id), \\\n\t.AUX_RESET_MASK = 0 \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define tf_regs(id)\\\n[id] = {\\\n\tTF_REG_LIST_DCN10(id),\\\n}\n\nstatic const struct dcn_dpp_registers tf_regs[] = {\n\ttf_regs(0),\n\ttf_regs(1),\n\ttf_regs(2),\n\ttf_regs(3),\n};\n\nstatic const struct dcn_dpp_shift tf_shift = {\n\tTF_REG_LIST_SH_MASK_DCN10(__SHIFT),\n\tTF_DEBUG_REG_LIST_SH_DCN10\n\n};\n\nstatic const struct dcn_dpp_mask tf_mask = {\n\tTF_REG_LIST_SH_MASK_DCN10(_MASK),\n\tTF_DEBUG_REG_LIST_MASK_DCN10\n};\n\nstatic const struct dcn_mpc_registers mpc_regs = {\n\t\tMPC_COMMON_REG_LIST_DCN1_0(0),\n\t\tMPC_COMMON_REG_LIST_DCN1_0(1),\n\t\tMPC_COMMON_REG_LIST_DCN1_0(2),\n\t\tMPC_COMMON_REG_LIST_DCN1_0(3),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(0),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(1),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(2),\n\t\tMPC_OUT_MUX_COMMON_REG_LIST_DCN1_0(3)\n};\n\nstatic const struct dcn_mpc_shift mpc_shift = {\n\tMPC_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)\n};\n\nstatic const struct dcn_mpc_mask mpc_mask = {\n\tMPC_COMMON_MASK_SH_LIST_DCN1_0(_MASK),\n};\n\n#define tg_regs(id)\\\n[id] = {TG_COMMON_REG_LIST_DCN1_0(id)}\n\nstatic const struct dcn_optc_registers tg_regs[] = {\n\ttg_regs(0),\n\ttg_regs(1),\n\ttg_regs(2),\n\ttg_regs(3),\n};\n\nstatic const struct dcn_optc_shift tg_shift = {\n\tTG_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)\n};\n\nstatic const struct dcn_optc_mask tg_mask = {\n\tTG_COMMON_MASK_SH_LIST_DCN1_0(_MASK)\n};\n\nstatic const struct bios_registers bios_regs = {\n\t\tNBIO_SR(BIOS_SCRATCH_3),\n\t\tNBIO_SR(BIOS_SCRATCH_6)\n};\n\n#define hubp_regs(id)\\\n[id] = {\\\n\tHUBP_REG_LIST_DCN10(id)\\\n}\n\nstatic const struct dcn_mi_registers hubp_regs[] = {\n\thubp_regs(0),\n\thubp_regs(1),\n\thubp_regs(2),\n\thubp_regs(3),\n};\n\nstatic const struct dcn_mi_shift hubp_shift = {\n\t\tHUBP_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn_mi_mask hubp_mask = {\n\t\tHUBP_MASK_SH_LIST_DCN10(_MASK)\n};\n\nstatic const struct dcn_hubbub_registers hubbub_reg = {\n\t\tHUBBUB_REG_LIST_DCN10(0)\n};\n\nstatic const struct dcn_hubbub_shift hubbub_shift = {\n\t\tHUBBUB_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dcn_hubbub_mask hubbub_mask = {\n\t\tHUBBUB_MASK_SH_LIST_DCN10(_MASK)\n};\n\n#define clk_src_regs(index, pllid)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCN1_0(index, pllid),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN1_0(_MASK)\n};\n\nstatic const struct resource_caps res_cap = {\n\t\t.num_timing_generator = 4,\n\t\t.num_opp = 4,\n\t\t.num_video_plane = 4,\n\t\t.num_audio = 4,\n\t\t.num_stream_encoder = 4,\n\t\t.num_pll = 4,\n\t\t.num_ddc = 4,\n};\n\nstatic const struct resource_caps rv2_res_cap = {\n\t\t.num_timing_generator = 3,\n\t\t.num_opp = 3,\n\t\t.num_video_plane = 3,\n\t\t.num_audio = 3,\n\t\t.num_stream_encoder = 3,\n\t\t.num_pll = 3,\n\t\t.num_ddc = 4,\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCN_UNIVERSAL,\n\t.blends_with_above = true,\n\t.blends_with_below = true,\n\t.per_pixel_alpha = true,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = true,\n\t\t\t.fp16 = true\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 16000,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 250,\n\t\t\t.fp16 = 1\n\t}\n};\n\nstatic const struct dc_debug_options debug_defaults_drv = {\n\t\t.sanity_checks = true,\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = false,\n\t\t.clock_trace = true,\n\n\t\t/* raven smu dones't allow 0 disp clk,\n\t\t * smu min disp clk limit is 50Mhz\n\t\t * keep min disp clk 100Mhz avoid smu hang\n\t\t */\n\t\t.min_disp_clk_khz = 100000,\n\n\t\t.disable_pplib_clock_request = false,\n\t\t.disable_pplib_wm_range = false,\n\t\t.pplib_wm_report_mode = WM_REPORT_DEFAULT,\n\t\t.pipe_split_policy = MPC_SPLIT_AVOID_MULT_DISP,\n\t\t.force_single_disp_pipe_split = true,\n\t\t.disable_dcc = DCC_ENABLE,\n\t\t.voltage_align_fclk = true,\n\t\t.disable_stereo_support = true,\n\t\t.vsr_support = true,\n\t\t.performance_trace = false,\n\t\t.az_endpoint_mute_only = true,\n\t\t.recovery_enabled = false, /*enable this by default after testing.*/\n\t\t.max_downscale_src_width = 3840,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nstatic const struct dc_debug_options debug_defaults_diags = {\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = true,\n\t\t.clock_trace = true,\n\t\t.disable_stutter = true,\n\t\t.disable_pplib_clock_request = true,\n\t\t.disable_pplib_wm_range = true,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nstatic void dcn10_dpp_destroy(struct dpp **dpp)\n{\n\tkfree(TO_DCN10_DPP(*dpp));\n\t*dpp = NULL;\n}\n\nstatic struct dpp *dcn10_dpp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn10_dpp *dpp =\n\t\tkzalloc(sizeof(struct dcn10_dpp), GFP_KERNEL);\n\n\tif (!dpp)\n\t\treturn NULL;\n\n\tdpp1_construct(dpp, ctx, inst,\n\t\t       &tf_regs[inst], &tf_shift, &tf_mask);\n\treturn &dpp->base;\n}\n\nstatic struct input_pixel_processor *dcn10_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn10_ipp *ipp =\n\t\tkzalloc(sizeof(struct dcn10_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn10_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\n\nstatic struct output_pixel_processor *dcn10_opp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn10_opp *opp =\n\t\tkzalloc(sizeof(struct dcn10_opp), GFP_KERNEL);\n\n\tif (!opp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn10_opp_construct(opp, ctx, inst,\n\t\t\t&opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dcn10_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCE110(_MASK)\n};\n\nstruct dce_i2c_hw *dcn10_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdcn1_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstatic struct mpc *dcn10_mpc_create(struct dc_context *ctx)\n{\n\tstruct dcn10_mpc *mpc10 = kzalloc(sizeof(struct dcn10_mpc),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!mpc10)\n\t\treturn NULL;\n\n\tdcn10_mpc_construct(mpc10, ctx,\n\t\t\t&mpc_regs,\n\t\t\t&mpc_shift,\n\t\t\t&mpc_mask,\n\t\t\t4);\n\n\treturn &mpc10->base;\n}\n\nstatic struct hubbub *dcn10_hubbub_create(struct dc_context *ctx)\n{\n\tstruct dcn10_hubbub *dcn10_hubbub = kzalloc(sizeof(struct dcn10_hubbub),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!dcn10_hubbub)\n\t\treturn NULL;\n\n\thubbub1_construct(&dcn10_hubbub->base, ctx,\n\t\t\t&hubbub_reg,\n\t\t\t&hubbub_shift,\n\t\t\t&hubbub_mask);\n\n\treturn &dcn10_hubbub->base;\n}\n\nstatic struct timing_generator *dcn10_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance)\n{\n\tstruct optc *tgn10 =\n\t\tkzalloc(sizeof(struct optc), GFP_KERNEL);\n\n\tif (!tgn10)\n\t\treturn NULL;\n\n\ttgn10->base.inst = instance;\n\ttgn10->base.ctx = ctx;\n\n\ttgn10->tg_regs = &tg_regs[instance];\n\ttgn10->tg_shift = &tg_shift;\n\ttgn10->tg_mask = &tg_mask;\n\n\tdcn10_timing_generator_init(tgn10);\n\n\treturn &tgn10->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = false,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstruct link_encoder *dcn10_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dcn10_link_encoder *enc10 =\n\t\tkzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);\n\n\tif (!enc10)\n\t\treturn NULL;\n\n\tdcn10_link_encoder_construct(enc10,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source],\n\t\t\t\t      &le_shift,\n\t\t\t\t      &le_mask);\n\n\treturn &enc10->base;\n}\n\nstruct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tgeneric_reg_get(ctx, mmDC_PINSTRAPS + BASE(mmDC_PINSTRAPS_BASE_IDX),\n\t\tFN(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO), &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstatic struct stream_encoder *dcn10_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn10_stream_encoder *enc1 =\n\t\tkzalloc(sizeof(struct dcn10_stream_encoder), GFP_KERNEL);\n\n\tif (!enc1)\n\t\treturn NULL;\n\n\tdcn10_stream_encoder_construct(enc1, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\treturn &enc1->base;\n}\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCN1_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCN1_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCN1_MASK_SH_LIST(_MASK)\n};\n\nstatic struct dce_hwseq *dcn10_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t\thws->wa.DEGVIDCN10_253 = true;\n\t\thws->wa.false_optc_underflow = true;\n\t\thws->wa.DEGVIDCN10_254 = true;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = create_audio,\n\t.create_stream_encoder = dcn10_stream_encoder_create,\n\t.create_hwseq = dcn10_hwseq_create,\n};\n\nstatic const struct resource_create_funcs res_create_maximus_funcs = {\n\t.read_dce_straps = NULL,\n\t.create_audio = NULL,\n\t.create_stream_encoder = NULL,\n\t.create_hwseq = dcn10_hwseq_create,\n};\n\nvoid dcn10_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\nstatic struct pp_smu_funcs *dcn10_pp_smu_create(struct dc_context *ctx)\n{\n\tstruct pp_smu_funcs *pp_smu = kzalloc(sizeof(*pp_smu), GFP_KERNEL);\n\n\tif (!pp_smu)\n\t\treturn pp_smu;\n\n\tdm_pp_get_funcs(ctx, pp_smu);\n\treturn pp_smu;\n}\n\nstatic void destruct(struct dcn10_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL) {\n\t\t\tkfree(DCN10STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t\t\tpool->base.stream_enc[i] = NULL;\n\t\t}\n\t}\n\n\tif (pool->base.mpc != NULL) {\n\t\tkfree(TO_DCN10_MPC(pool->base.mpc));\n\t\tpool->base.mpc = NULL;\n\t}\n\n\tif (pool->base.hubbub != NULL) {\n\t\tkfree(pool->base.hubbub);\n\t\tpool->base.hubbub = NULL;\n\t}\n\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tpool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);\n\n\t\tif (pool->base.dpps[i] != NULL)\n\t\t\tdcn10_dpp_destroy(&pool->base.dpps[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tpool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.hubps[i] != NULL) {\n\t\t\tkfree(TO_DCN10_HUBP(pool->base.hubps[i]));\n\t\t\tpool->base.hubps[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.irqs != NULL) {\n\t\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t\t}\n\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCN10TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.audio_count; i++) {\n\t\tif (pool->base.audios[i])\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdcn10_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t\tpool->base.clock_sources[i] = NULL;\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL) {\n\t\tdcn10_clock_source_destroy(&pool->base.dp_clock_source);\n\t\tpool->base.dp_clock_source = NULL;\n\t}\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tkfree(pool->base.pp_smu);\n}\n\nstatic struct hubp *dcn10_hubp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn10_hubp *hubp1 =\n\t\tkzalloc(sizeof(struct dcn10_hubp), GFP_KERNEL);\n\n\tif (!hubp1)\n\t\treturn NULL;\n\n\tdcn10_hubp_construct(hubp1, ctx, inst,\n\t\t\t     &hubp_regs[inst], &hubp_shift, &hubp_mask);\n\treturn &hubp1->base;\n}\n\nstatic void get_pixel_clock_parameters(\n\tconst struct pipe_ctx *pipe_ctx,\n\tstruct pixel_clk_params *pixel_clk_params)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tpixel_clk_params->requested_pix_clk_100hz = stream->timing.pix_clk_100hz;\n\tpixel_clk_params->encoder_object_id = stream->link->link_enc->id;\n\tpixel_clk_params->signal_type = pipe_ctx->stream->signal;\n\tpixel_clk_params->controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\t/* TODO: un-hardcode*/\n\tpixel_clk_params->requested_sym_clk = LINK_RATE_LOW *\n\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\tpixel_clk_params->flags.ENABLE_SS = 0;\n\tpixel_clk_params->color_depth =\n\t\tstream->timing.display_color_depth;\n\tpixel_clk_params->flags.DISPLAY_BLANKED = 1;\n\tpixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;\n\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\tpixel_clk_params->color_depth = COLOR_DEPTH_888;\n\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\tpixel_clk_params->requested_pix_clk_100hz  /= 2;\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tpixel_clk_params->requested_pix_clk_100hz *= 2;\n\n}\n\nstatic void build_clamping_params(struct dc_stream_state *stream)\n{\n\tstream->clamping.clamping_level = CLAMPING_FULL_RANGE;\n\tstream->clamping.c_depth = stream->timing.display_color_depth;\n\tstream->clamping.pixel_encoding = stream->timing.pixel_encoding;\n}\n\nstatic void build_pipe_hw_param(struct pipe_ctx *pipe_ctx)\n{\n\n\tget_pixel_clock_parameters(pipe_ctx, &pipe_ctx->stream_res.pix_clk_params);\n\n\tpipe_ctx->clock_source->funcs->get_pix_clk_dividers(\n\t\tpipe_ctx->clock_source,\n\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t&pipe_ctx->pll_settings);\n\n\tpipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;\n\n\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t\t\t&pipe_ctx->stream->bit_depth_params);\n\tbuild_clamping_params(pipe_ctx->stream);\n}\n\nstatic enum dc_status build_mapped_resource(\n\t\tconst struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\t/*TODO Seems unneeded anymore */\n\t/*\tif (old_context && resource_is_stream_unchanged(old_context, stream)) {\n\t\t\tif (stream != NULL && old_context->streams[i] != NULL) {\n\t\t\t\t todo: shouldn't have to copy missing parameter here\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tstream->clamping.pixel_encoding =\n\t\t\t\t\t\tstream->timing.pixel_encoding;\n\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tbuild_clamping_params(stream);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t*/\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tbuild_pipe_hw_param(pipe_ctx);\n\treturn DC_OK;\n}\n\nenum dc_status dcn10_add_stream_to_ctx(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n\n\tif (result == DC_OK)\n\t\tresult = build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\nstatic struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(\n\t\tstruct dc_state *context,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct resource_context *res_ctx = &context->res_ctx;\n\tstruct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);\n\tstruct pipe_ctx *idle_pipe = find_idle_secondary_pipe(res_ctx, pool, head_pipe);\n\n\tif (!head_pipe) {\n\t\tASSERT(0);\n\t\treturn NULL;\n\t}\n\n\tif (!idle_pipe)\n\t\treturn NULL;\n\n\tidle_pipe->stream = head_pipe->stream;\n\tidle_pipe->stream_res.tg = head_pipe->stream_res.tg;\n\tidle_pipe->stream_res.abm = head_pipe->stream_res.abm;\n\tidle_pipe->stream_res.opp = head_pipe->stream_res.opp;\n\n\tidle_pipe->plane_res.hubp = pool->hubps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.ipp = pool->ipps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.dpp = pool->dpps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.mpcc_inst = pool->dpps[idle_pipe->pipe_idx]->inst;\n\n\treturn idle_pipe;\n}\n\nstatic bool dcn10_get_dcc_compression_cap(const struct dc *dc,\n\t\tconst struct dc_dcc_surface_param *input,\n\t\tstruct dc_surface_dcc_cap *output)\n{\n\treturn dc->res_pool->hubbub->funcs->get_dcc_compression_cap(\n\t\t\tdc->res_pool->hubbub,\n\t\t\tinput,\n\t\t\toutput);\n}\n\nstatic void dcn10_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dcn10_resource_pool *dcn10_pool = TO_DCN10_RES_POOL(*pool);\n\n\tdestruct(dcn10_pool);\n\tkfree(dcn10_pool);\n\t*pool = NULL;\n}\n\nstatic enum dc_status dcn10_validate_plane(const struct dc_plane_state *plane_state, struct dc_caps *caps)\n{\n\tif (plane_state->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN\n\t\t\t&& caps->max_video_width != 0\n\t\t\t&& plane_state->src_rect.width > caps->max_video_width)\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status dcn10_validate_global(struct dc *dc, struct dc_state *context)\n{\n\tint i, j;\n\tbool video_down_scaled = false;\n\tbool video_large = false;\n\tbool desktop_large = false;\n\tbool dcc_disabled = false;\n\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tif (context->stream_status[i].plane_count == 0)\n\t\t\tcontinue;\n\n\t\tif (context->stream_status[i].plane_count > 2)\n\t\t\treturn DC_FAIL_UNSUPPORTED_1;\n\n\t\tfor (j = 0; j < context->stream_status[i].plane_count; j++) {\n\t\t\tstruct dc_plane_state *plane =\n\t\t\t\tcontext->stream_status[i].plane_states[j];\n\n\n\t\t\tif (plane->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\n\t\t\t\tif (plane->src_rect.width > plane->dst_rect.width ||\n\t\t\t\t\t\tplane->src_rect.height > plane->dst_rect.height)\n\t\t\t\t\tvideo_down_scaled = true;\n\n\t\t\t\tif (plane->src_rect.width >= 3840)\n\t\t\t\t\tvideo_large = true;\n\n\t\t\t} else {\n\t\t\t\tif (plane->src_rect.width >= 3840)\n\t\t\t\t\tdesktop_large = true;\n\t\t\t\tif (!plane->dcc.enable)\n\t\t\t\t\tdcc_disabled = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Workaround: On DCN10 there is UMC issue that causes underflow when\n\t * playing 4k video on 4k desktop with video downscaled and single channel\n\t * memory\n\t */\n\tif (video_large && desktop_large && video_down_scaled && dcc_disabled &&\n\t\t\tdc->dcn_soc->number_of_channels == 1)\n\t\treturn DC_FAIL_SURFACE_VALIDATE;\n\n\treturn DC_OK;\n}\n\nstatic enum dc_status dcn10_get_default_swizzle_mode(struct dc_plane_state *plane_state)\n{\n\tenum dc_status result = DC_OK;\n\n\tenum surface_pixel_format surf_pix_format = plane_state->format;\n\tunsigned int bpp = resource_pixel_format_to_bpp(surf_pix_format);\n\n\tenum swizzle_mode_values swizzle = DC_SW_LINEAR;\n\n\tif (bpp == 64)\n\t\tswizzle = DC_SW_64KB_D;\n\telse\n\t\tswizzle = DC_SW_64KB_S;\n\n\tplane_state->tiling_info.gfx9.swizzle = swizzle;\n\treturn result;\n}\n\nstruct stream_encoder *dcn10_find_first_free_match_stream_enc_for_link(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tint i;\n\tint j = -1;\n\tstruct dc_link *link = stream->link;\n\n\tfor (i = 0; i < pool->stream_enc_count; i++) {\n\t\tif (!res_ctx->is_stream_enc_acquired[i] &&\n\t\t\t\tpool->stream_enc[i]) {\n\t\t\t/* Store first available for MST second display\n\t\t\t * in daisy chain use case\n\t\t\t */\n\t\t\tj = i;\n\t\t\tif (pool->stream_enc[i]->id ==\n\t\t\t\t\tlink->link_enc->preferred_engine)\n\t\t\t\treturn pool->stream_enc[i];\n\t\t}\n\t}\n\n\t/*\n\t * For CZ and later, we can allow DIG FE and BE to differ for all display types\n\t */\n\n\tif (j >= 0)\n\t\treturn pool->stream_enc[j];\n\n\treturn NULL;\n}\n\nstatic const struct dc_cap_funcs cap_funcs = {\n\t.get_dcc_compression_cap = dcn10_get_dcc_compression_cap\n};\n\nstatic const struct resource_funcs dcn10_res_pool_funcs = {\n\t.destroy = dcn10_destroy_resource_pool,\n\t.link_enc_create = dcn10_link_encoder_create,\n\t.validate_bandwidth = dcn_validate_bandwidth,\n\t.acquire_idle_pipe_for_layer = dcn10_acquire_idle_pipe_for_layer,\n\t.validate_plane = dcn10_validate_plane,\n\t.validate_global = dcn10_validate_global,\n\t.add_stream_to_ctx = dcn10_add_stream_to_ctx,\n\t.get_default_swizzle_mode = dcn10_get_default_swizzle_mode,\n\t.find_first_free_match_stream_enc_for_link = dcn10_find_first_free_match_stream_enc_for_link\n};\n\nstatic uint32_t read_pipe_fuses(struct dc_context *ctx)\n{\n\tuint32_t value = dm_read_reg_soc15(ctx, mmCC_DC_PIPE_DIS, 0);\n\t/* RV1 support max 4 pipes */\n\tvalue = value & 0xf;\n\treturn value;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dcn10_resource_pool *pool)\n{\n\tint i;\n\tint j;\n\tstruct dc_context *ctx = dc->ctx;\n\tuint32_t pipe_fuses = read_pipe_fuses(ctx);\n\n\tctx->dc_bios->regs = &bios_regs;\n\n\tif (ctx->dce_version == DCN_VERSION_1_01)\n\t\tpool->base.res_cap = &rv2_res_cap;\n\telse\n\t\tpool->base.res_cap = &res_cap;\n\tpool->base.funcs = &dcn10_res_pool_funcs;\n\n\t/*\n\t * TODO fill in from actual raven resource when we create\n\t * more than virtual encoder\n\t */\n\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\t/* max pipe num for ASIC before check pipe fuses */\n\tpool->base.pipe_count = pool->base.res_cap->num_timing_generator;\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_01)\n\t\tpool->base.pipe_count = 3;\n\tdc->caps.max_video_width = 3840;\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 256;\n\tdc->caps.max_slave_planes = 1;\n\tdc->caps.is_apu = true;\n\tdc->caps.post_blend_color_processing = false;\n\t/* Raven DP PHY HBR2 eye diagram pattern is not stable. Use TP4 */\n\tdc->caps.force_dp_tps4_for_cp2520 = true;\n\n\tif (dc->ctx->dce_environment == DCE_ENV_PRODUCTION_DRV)\n\t\tdc->debug = debug_defaults_drv;\n\telse\n\t\tdc->debug = debug_defaults_diags;\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCN10_CLK_SRC_PLL0] =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCN10_CLK_SRC_PLL1] =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCN10_CLK_SRC_PLL2] =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_0) {\n\t\tpool->base.clock_sources[DCN10_CLK_SRC_PLL3] =\n\t\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t\t&clk_src_regs[3], false);\n\t}\n\n\tpool->base.clk_src_count = DCN10_CLK_SRC_TOTAL;\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_01)\n\t\tpool->base.clk_src_count = DCN101_CLK_SRC_TOTAL;\n\n\tpool->base.dp_clock_source =\n\t\t\tdcn10_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_ID_DP_DTO,\n\t\t\t\t/* todo: not reuse phy_pll registers */\n\t\t\t\t&clk_src_regs[0], true);\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tpool->base.dmcu = dcn10_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto fail;\n\t}\n\n\tdml_init_instance(&dc->dml, &dcn1_0_soc, &dcn1_0_ip, DML_PROJECT_RAVEN1);\n\tmemcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults));\n\tmemcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults));\n\n\tif (dc->ctx->dce_version == DCN_VERSION_1_01) {\n\t\tstruct dcn_soc_bounding_box *dcn_soc = dc->dcn_soc;\n\t\tstruct dcn_ip_params *dcn_ip = dc->dcn_ip;\n\t\tstruct display_mode_lib *dml = &dc->dml;\n\n\t\tdml->ip.max_num_dpp = 3;\n\t\t/* TODO how to handle 23.84? */\n\t\tdcn_soc->dram_clock_change_latency = 23;\n\t\tdcn_ip->max_num_dpp = 3;\n\t}\n\tif (ASICREV_IS_RV1_F0(dc->ctx->asic_id.hw_internal_rev)) {\n\t\tdc->dcn_soc->urgent_latency = 3;\n\t\tdc->debug.disable_dmcu = true;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 41.60f;\n\t}\n\n\n\tdc->dcn_soc->number_of_channels = dc->ctx->asic_id.vram_width / ddr4_dram_width;\n\tASSERT(dc->dcn_soc->number_of_channels < 3);\n\tif (dc->dcn_soc->number_of_channels == 0)/*old sbios bug*/\n\t\tdc->dcn_soc->number_of_channels = 2;\n\n\tif (dc->dcn_soc->number_of_channels == 1) {\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 19.2f;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 = 17.066f;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 = 14.933f;\n\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 = 12.8f;\n\t\tif (ASICREV_IS_RV1_F0(dc->ctx->asic_id.hw_internal_rev)) {\n\t\t\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 20.80f;\n\t\t}\n\t}\n\n\tpool->base.pp_smu = dcn10_pp_smu_create(ctx);\n\n\t/*\n\t * Right now SMU/PPLIB and DAL all have the AZ D3 force PME notification *\n\t * implemented. So AZ D3 should work.For issue 197007.                   *\n\t */\n\tif (pool->base.pp_smu != NULL\n\t\t\t&& pool->base.pp_smu->rv_funcs.set_pme_wa_enable != NULL)\n\t\tdc->debug.az_endpoint_mute_only = false;\n\n\tif (!dc->debug.disable_pplib_clock_request)\n\t\tdcn_bw_update_from_pplib(dc);\n\tdcn_bw_sync_calcs_and_dml(dc);\n\tif (!dc->debug.disable_pplib_wm_range) {\n\t\tdc->res_pool = &pool->base;\n\t\tdcn_bw_notify_pplib_of_wm_ranges(dc);\n\t}\n\n\t{\n\t\tstruct irq_service_init_data init_data;\n\t\tinit_data.ctx = dc->ctx;\n\t\tpool->base.irqs = dal_irq_service_dcn10_create(&init_data);\n\t\tif (!pool->base.irqs)\n\t\t\tgoto fail;\n\t}\n\n\t/* index to valid pipe resource  */\n\tj = 0;\n\t/* mem input -> ipp -> dpp -> opp -> TG */\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\t/* if pipe is disabled, skip instance of HW pipe,\n\t\t * i.e, skip ASIC register instance\n\t\t */\n\t\tif ((pipe_fuses & (1 << i)) != 0)\n\t\t\tcontinue;\n\n\t\tpool->base.hubps[j] = dcn10_hubp_create(ctx, i);\n\t\tif (pool->base.hubps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.ipps[j] = dcn10_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.dpps[j] = dcn10_dpp_create(ctx, i);\n\t\tif (pool->base.dpps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create dpp!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.opps[j] = dcn10_opp_create(ctx, i);\n\t\tif (pool->base.opps[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpool->base.timing_generators[j] = dcn10_timing_generator_create(\n\t\t\t\tctx, i);\n\t\tif (pool->base.timing_generators[j] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check next valid pipe */\n\t\tj++;\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dcn10_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dcn10_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create hw i2c!!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\t/* valid pipe num */\n\tpool->base.pipe_count = j;\n\tpool->base.timing_generator_count = j;\n\n\t/* within dml lib, it is hard code to 4. If ASIC pipe is fused,\n\t * the value may be changed\n\t */\n\tdc->dml.ip.max_num_dpp = pool->base.pipe_count;\n\tdc->dcn_ip->max_num_dpp = pool->base.pipe_count;\n\n\tpool->base.mpc = dcn10_mpc_create(ctx);\n\tif (pool->base.mpc == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create mpc!\\n\");\n\t\tgoto fail;\n\t}\n\n\tpool->base.hubbub = dcn10_hubbub_create(ctx);\n\tif (pool->base.hubbub == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create hubbub!\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t(!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment) ?\n\t\t\t&res_create_funcs : &res_create_maximus_funcs)))\n\t\t\tgoto fail;\n\n\tdcn10_hw_sequencer_construct(dc);\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->cap_funcs = cap_funcs;\n\n\treturn true;\n\nfail:\n\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n", "/*\n* Copyright 2016 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/slab.h>\n\n#include \"dm_services.h\"\n#include \"dc.h\"\n\n#include \"resource.h\"\n#include \"include/irq_service_interface.h\"\n#include \"dcn20/dcn20_resource.h\"\n\n#include \"dcn10/dcn10_hubp.h\"\n#include \"dcn10/dcn10_ipp.h\"\n#include \"dcn20_hubbub.h\"\n#include \"dcn20_mpc.h\"\n#include \"dcn20_hubp.h\"\n#include \"irq/dcn20/irq_service_dcn20.h\"\n#include \"dcn20_dpp.h\"\n#include \"dcn20_optc.h\"\n#include \"dcn20_hwseq.h\"\n#include \"dce110/dce110_hw_sequencer.h\"\n#include \"dcn10/dcn10_resource.h\"\n#include \"dcn20_opp.h\"\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n#include \"dcn20_dsc.h\"\n#endif\n\n#include \"dcn20_link_encoder.h\"\n#include \"dcn20_stream_encoder.h\"\n#include \"dce/dce_clock_source.h\"\n#include \"dce/dce_audio.h\"\n#include \"dce/dce_hwseq.h\"\n#include \"virtual/virtual_stream_encoder.h\"\n#include \"dce110/dce110_resource.h\"\n#include \"dml/display_mode_vba.h\"\n#include \"dcn20_dccg.h\"\n#include \"dcn20_vmid.h\"\n\n#include \"navi10_ip_offset.h\"\n\n#include \"dcn/dcn_2_0_0_offset.h\"\n#include \"dcn/dcn_2_0_0_sh_mask.h\"\n\n#include \"nbio/nbio_2_3_offset.h\"\n\n#include \"dcn20/dcn20_dwb.h\"\n#include \"dcn20/dcn20_mmhubbub.h\"\n\n#include \"mmhub/mmhub_2_0_0_offset.h\"\n#include \"mmhub/mmhub_2_0_0_sh_mask.h\"\n\n#include \"reg_helper.h\"\n#include \"dce/dce_abm.h\"\n#include \"dce/dce_dmcu.h\"\n#include \"dce/dce_aux.h\"\n#include \"dce/dce_i2c.h\"\n#include \"vm_helper.h\"\n\n#include \"amdgpu_socbb.h\"\n\n/* NV12 SOC BB is currently in FW, mark SW bounding box invalid. */\n#define SOC_BOUNDING_BOX_VALID false\n#define DC_LOGGER_INIT(logger)\n\nstruct _vcs_dpi_ip_params_st dcn2_0_ip = {\n\t.odm_capable = 1,\n\t.gpuvm_enable = 0,\n\t.hostvm_enable = 0,\n\t.gpuvm_max_page_table_levels = 4,\n\t.hostvm_max_page_table_levels = 4,\n\t.hostvm_cached_page_table_levels = 0,\n\t.pte_group_size_bytes = 2048,\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t.num_dsc = 6,\n#else\n\t.num_dsc = 0,\n#endif\n\t.rob_buffer_size_kbytes = 168,\n\t.det_buffer_size_kbytes = 164,\n\t.dpte_buffer_size_in_pte_reqs_luma = 84,\n\t.pde_proc_buffer_size_64k_reqs = 48,\n\t.dpp_output_buffer_pixels = 2560,\n\t.opp_output_buffer_lines = 1,\n\t.pixel_chunk_size_kbytes = 8,\n\t.pte_chunk_size_kbytes = 2,\n\t.meta_chunk_size_kbytes = 2,\n\t.writeback_chunk_size_kbytes = 2,\n\t.line_buffer_size_bits = 789504,\n\t.is_line_buffer_bpp_fixed = 0,\n\t.line_buffer_fixed_bpp = 0,\n\t.dcc_supported = true,\n\t.max_line_buffer_lines = 12,\n\t.writeback_luma_buffer_size_kbytes = 12,\n\t.writeback_chroma_buffer_size_kbytes = 8,\n\t.writeback_chroma_line_buffer_width_pixels = 4,\n\t.writeback_max_hscl_ratio = 1,\n\t.writeback_max_vscl_ratio = 1,\n\t.writeback_min_hscl_ratio = 1,\n\t.writeback_min_vscl_ratio = 1,\n\t.writeback_max_hscl_taps = 12,\n\t.writeback_max_vscl_taps = 12,\n\t.writeback_line_buffer_luma_buffer_size = 0,\n\t.writeback_line_buffer_chroma_buffer_size = 14643,\n\t.cursor_buffer_size = 8,\n\t.cursor_chunk_size = 2,\n\t.max_num_otg = 6,\n\t.max_num_dpp = 6,\n\t.max_num_wb = 1,\n\t.max_dchub_pscl_bw_pix_per_clk = 4,\n\t.max_pscl_lb_bw_pix_per_clk = 2,\n\t.max_lb_vscl_bw_pix_per_clk = 4,\n\t.max_vscl_hscl_bw_pix_per_clk = 4,\n\t.max_hscl_ratio = 8,\n\t.max_vscl_ratio = 8,\n\t.hscl_mults = 4,\n\t.vscl_mults = 4,\n\t.max_hscl_taps = 8,\n\t.max_vscl_taps = 8,\n\t.dispclk_ramp_margin_percent = 1,\n\t.underscan_factor = 1.10,\n\t.min_vblank_lines = 32, //\n\t.dppclk_delay_subtotal = 77, //\n\t.dppclk_delay_scl_lb_only = 16,\n\t.dppclk_delay_scl = 50,\n\t.dppclk_delay_cnvc_formatter = 8,\n\t.dppclk_delay_cnvc_cursor = 6,\n\t.dispclk_delay_subtotal = 87, //\n\t.dcfclk_cstate_latency = 10, // SRExitTime\n\t.max_inter_dcn_tile_repeaters = 8,\n\n\t.xfc_supported = true,\n\t.xfc_fill_bw_overhead_percent = 10.0,\n\t.xfc_fill_constant_bytes = 0,\n};\n\nstruct _vcs_dpi_soc_bounding_box_st dcn2_0_soc = {\n\t/* Defaults that get patched on driver load from firmware. */\n\t.clock_limits = {\n\t\t\t{\n\t\t\t\t.state = 0,\n\t\t\t\t.dcfclk_mhz = 560.0,\n\t\t\t\t.fabricclk_mhz = 560.0,\n\t\t\t\t.dispclk_mhz = 513.0,\n\t\t\t\t.dppclk_mhz = 513.0,\n\t\t\t\t.phyclk_mhz = 540.0,\n\t\t\t\t.socclk_mhz = 560.0,\n\t\t\t\t.dscclk_mhz = 171.0,\n\t\t\t\t.dram_speed_mts = 8960.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 1,\n\t\t\t\t.dcfclk_mhz = 694.0,\n\t\t\t\t.fabricclk_mhz = 694.0,\n\t\t\t\t.dispclk_mhz = 642.0,\n\t\t\t\t.dppclk_mhz = 642.0,\n\t\t\t\t.phyclk_mhz = 600.0,\n\t\t\t\t.socclk_mhz = 694.0,\n\t\t\t\t.dscclk_mhz = 214.0,\n\t\t\t\t.dram_speed_mts = 11104.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 2,\n\t\t\t\t.dcfclk_mhz = 875.0,\n\t\t\t\t.fabricclk_mhz = 875.0,\n\t\t\t\t.dispclk_mhz = 734.0,\n\t\t\t\t.dppclk_mhz = 734.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 875.0,\n\t\t\t\t.dscclk_mhz = 245.0,\n\t\t\t\t.dram_speed_mts = 14000.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 3,\n\t\t\t\t.dcfclk_mhz = 1000.0,\n\t\t\t\t.fabricclk_mhz = 1000.0,\n\t\t\t\t.dispclk_mhz = 1100.0,\n\t\t\t\t.dppclk_mhz = 1100.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 1000.0,\n\t\t\t\t.dscclk_mhz = 367.0,\n\t\t\t\t.dram_speed_mts = 16000.0,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.state = 4,\n\t\t\t\t.dcfclk_mhz = 1200.0,\n\t\t\t\t.fabricclk_mhz = 1200.0,\n\t\t\t\t.dispclk_mhz = 1284.0,\n\t\t\t\t.dppclk_mhz = 1284.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 1200.0,\n\t\t\t\t.dscclk_mhz = 428.0,\n\t\t\t\t.dram_speed_mts = 16000.0,\n\t\t\t},\n\t\t\t/*Extra state, no dispclk ramping*/\n\t\t\t{\n\t\t\t\t.state = 5,\n\t\t\t\t.dcfclk_mhz = 1200.0,\n\t\t\t\t.fabricclk_mhz = 1200.0,\n\t\t\t\t.dispclk_mhz = 1284.0,\n\t\t\t\t.dppclk_mhz = 1284.0,\n\t\t\t\t.phyclk_mhz = 810.0,\n\t\t\t\t.socclk_mhz = 1200.0,\n\t\t\t\t.dscclk_mhz = 428.0,\n\t\t\t\t.dram_speed_mts = 16000.0,\n\t\t\t},\n\t\t},\n\t.num_states = 5,\n\t.sr_exit_time_us = 8.6,\n\t.sr_enter_plus_exit_time_us = 10.9,\n\t.urgent_latency_us = 4.0,\n\t.urgent_latency_pixel_data_only_us = 4.0,\n\t.urgent_latency_pixel_mixed_with_vm_data_us = 4.0,\n\t.urgent_latency_vm_data_only_us = 4.0,\n\t.urgent_out_of_order_return_per_channel_pixel_only_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_pixel_and_vm_bytes = 4096,\n\t.urgent_out_of_order_return_per_channel_vm_only_bytes = 4096,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_only = 40.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm = 40.0,\n\t.pct_ideal_dram_sdp_bw_after_urgent_vm_only = 40.0,\n\t.max_avg_sdp_bw_use_normal_percent = 40.0,\n\t.max_avg_dram_bw_use_normal_percent = 40.0,\n\t.writeback_latency_us = 12.0,\n\t.ideal_dram_bw_after_urgent_percent = 40.0,\n\t.max_request_size_bytes = 256,\n\t.dram_channel_width_bytes = 2,\n\t.fabric_datapath_to_dcn_data_return_bytes = 64,\n\t.dcn_downspread_percent = 0.5,\n\t.downspread_percent = 0.38,\n\t.dram_page_open_time_ns = 50.0,\n\t.dram_rw_turnaround_time_ns = 17.5,\n\t.dram_return_buffer_per_channel_bytes = 8192,\n\t.round_trip_ping_latency_dcfclk_cycles = 131,\n\t.urgent_out_of_order_return_per_channel_bytes = 256,\n\t.channel_interleave_bytes = 256,\n\t.num_banks = 8,\n\t.num_chans = 16,\n\t.vmm_page_size_bytes = 4096,\n\t.dram_clock_change_latency_us = 404.0,\n\t.dummy_pstate_latency_us = 5.0,\n\t.writeback_dram_clock_change_latency_us = 23.0,\n\t.return_bus_width_bytes = 64,\n\t.dispclk_dppclk_vco_speed_mhz = 3850,\n\t.xfc_bus_transport_time_us = 20,\n\t.xfc_xbuf_latency_tolerance_us = 4,\n\t.use_urgent_burst_bw = 0\n};\n\nstruct _vcs_dpi_soc_bounding_box_st dcn2_0_nv12_soc = { 0 };\n\n#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL\t\t0x210f\n\t#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL\t\t0x220f\n\t#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL\t\t0x230f\n\t#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL\t\t0x240f\n\t#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL\t\t0x250f\n\t#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL\t\t0x260f\n\t#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL\t\t0x270f\n\t#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX\t2\n#endif\n\n\nenum dcn20_clk_src_array_id {\n\tDCN20_CLK_SRC_PLL0,\n\tDCN20_CLK_SRC_PLL1,\n\tDCN20_CLK_SRC_PLL2,\n\tDCN20_CLK_SRC_PLL3,\n\tDCN20_CLK_SRC_PLL4,\n\tDCN20_CLK_SRC_PLL5,\n\tDCN20_CLK_SRC_TOTAL\n};\n\n/* begin *********************\n * macros to expend register list macro defined in HW object header file */\n\n/* DCN */\n/* TODO awful hack. fixup dcn20_dwb.h */\n#undef BASE_INNER\n#define BASE_INNER(seg) DCN_BASE__INST0_SEG ## seg\n\n#define BASE(seg) BASE_INNER(seg)\n\n#define SR(reg_name)\\\n\t\t.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \\\n\t\t\t\t\tmm ## reg_name\n\n#define SRI(reg_name, block, id)\\\n\t.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n#define SRIR(var_name, reg_name, block, id)\\\n\t.var_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n#define SRII(reg_name, block, id)\\\n\t.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n#define DCCG_SRII(reg_name, block, id)\\\n\t.block ## _ ## reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## block ## id ## _ ## reg_name\n\n/* NBIO */\n#define NBIO_BASE_INNER(seg) \\\n\tNBIO_BASE__INST0_SEG ## seg\n\n#define NBIO_BASE(seg) \\\n\tNBIO_BASE_INNER(seg)\n\n#define NBIO_SR(reg_name)\\\n\t\t.reg_name = NBIO_BASE(mm ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmm ## reg_name\n\n/* MMHUB */\n#define MMHUB_BASE_INNER(seg) \\\n\tMMHUB_BASE__INST0_SEG ## seg\n\n#define MMHUB_BASE(seg) \\\n\tMMHUB_BASE_INNER(seg)\n\n#define MMHUB_SR(reg_name)\\\n\t\t.reg_name = MMHUB_BASE(mmMM ## reg_name ## _BASE_IDX) + \\\n\t\t\t\t\tmmMM ## reg_name\n\nstatic const struct bios_registers bios_regs = {\n\t\tNBIO_SR(BIOS_SCRATCH_3),\n\t\tNBIO_SR(BIOS_SCRATCH_6)\n};\n\n#define clk_src_regs(index, pllid)\\\n[index] = {\\\n\tCS_COMMON_REG_LIST_DCN2_0(index, pllid),\\\n}\n\nstatic const struct dce110_clk_src_regs clk_src_regs[] = {\n\tclk_src_regs(0, A),\n\tclk_src_regs(1, B),\n\tclk_src_regs(2, C),\n\tclk_src_regs(3, D),\n\tclk_src_regs(4, E),\n\tclk_src_regs(5, F)\n};\n\nstatic const struct dce110_clk_src_shift cs_shift = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dce110_clk_src_mask cs_mask = {\n\t\tCS_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\nstatic const struct dce_dmcu_registers dmcu_regs = {\n\t\tDMCU_DCN10_REG_LIST()\n};\n\nstatic const struct dce_dmcu_shift dmcu_shift = {\n\t\tDMCU_MASK_SH_LIST_DCN10(__SHIFT)\n};\n\nstatic const struct dce_dmcu_mask dmcu_mask = {\n\t\tDMCU_MASK_SH_LIST_DCN10(_MASK)\n};\n\nstatic const struct dce_abm_registers abm_regs = {\n\t\tABM_DCN20_REG_LIST()\n};\n\nstatic const struct dce_abm_shift abm_shift = {\n\t\tABM_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dce_abm_mask abm_mask = {\n\t\tABM_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define audio_regs(id)\\\n[id] = {\\\n\t\tAUD_COMMON_REG_LIST(id)\\\n}\n\nstatic const struct dce_audio_registers audio_regs[] = {\n\taudio_regs(0),\n\taudio_regs(1),\n\taudio_regs(2),\n\taudio_regs(3),\n\taudio_regs(4),\n\taudio_regs(5),\n\taudio_regs(6),\n};\n\n#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\\\n\t\tSF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\\\n\t\tAUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\n\nstatic const struct dce_audio_shift audio_shift = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_audio_mask audio_mask = {\n\t\tDCE120_AUD_COMMON_MASK_SH_LIST(_MASK)\n};\n\n#define stream_enc_regs(id)\\\n[id] = {\\\n\tSE_DCN2_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_stream_enc_registers stream_enc_regs[] = {\n\tstream_enc_regs(0),\n\tstream_enc_regs(1),\n\tstream_enc_regs(2),\n\tstream_enc_regs(3),\n\tstream_enc_regs(4),\n\tstream_enc_regs(5),\n};\n\nstatic const struct dcn10_stream_encoder_shift se_shift = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn10_stream_encoder_mask se_mask = {\n\t\tSE_COMMON_MASK_SH_LIST_DCN20(_MASK)\n};\n\n\n#define aux_regs(id)\\\n[id] = {\\\n\tDCN2_AUX_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_aux_registers link_enc_aux_regs[] = {\n\t\taux_regs(0),\n\t\taux_regs(1),\n\t\taux_regs(2),\n\t\taux_regs(3),\n\t\taux_regs(4),\n\t\taux_regs(5)\n};\n\n#define hpd_regs(id)\\\n[id] = {\\\n\tHPD_REG_LIST(id)\\\n}\n\nstatic const struct dcn10_link_enc_hpd_registers link_enc_hpd_regs[] = {\n\t\thpd_regs(0),\n\t\thpd_regs(1),\n\t\thpd_regs(2),\n\t\thpd_regs(3),\n\t\thpd_regs(4),\n\t\thpd_regs(5)\n};\n\n#define link_regs(id, phyid)\\\n[id] = {\\\n\tLE_DCN10_REG_LIST(id), \\\n\tUNIPHY_DCN2_REG_LIST(phyid), \\\n\tSRI(DP_DPHY_INTERNAL_CTRL, DP, id) \\\n}\n\nstatic const struct dcn10_link_enc_registers link_enc_regs[] = {\n\tlink_regs(0, A),\n\tlink_regs(1, B),\n\tlink_regs(2, C),\n\tlink_regs(3, D),\n\tlink_regs(4, E),\n\tlink_regs(5, F)\n};\n\nstatic const struct dcn10_link_enc_shift le_shift = {\n\tLINK_ENCODER_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn10_link_enc_mask le_mask = {\n\tLINK_ENCODER_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define ipp_regs(id)\\\n[id] = {\\\n\tIPP_REG_LIST_DCN20(id),\\\n}\n\nstatic const struct dcn10_ipp_registers ipp_regs[] = {\n\tipp_regs(0),\n\tipp_regs(1),\n\tipp_regs(2),\n\tipp_regs(3),\n\tipp_regs(4),\n\tipp_regs(5),\n};\n\nstatic const struct dcn10_ipp_shift ipp_shift = {\n\t\tIPP_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn10_ipp_mask ipp_mask = {\n\t\tIPP_MASK_SH_LIST_DCN20(_MASK),\n};\n\n#define opp_regs(id)\\\n[id] = {\\\n\tOPP_REG_LIST_DCN20(id),\\\n}\n\nstatic const struct dcn20_opp_registers opp_regs[] = {\n\topp_regs(0),\n\topp_regs(1),\n\topp_regs(2),\n\topp_regs(3),\n\topp_regs(4),\n\topp_regs(5),\n};\n\nstatic const struct dcn20_opp_shift opp_shift = {\n\t\tOPP_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn20_opp_mask opp_mask = {\n\t\tOPP_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define aux_engine_regs(id)\\\n[id] = {\\\n\tAUX_COMMON_REG_LIST0(id), \\\n\t.AUXN_IMPCAL = 0, \\\n\t.AUXP_IMPCAL = 0, \\\n\t.AUX_RESET_MASK = DP_AUX0_AUX_CONTROL__AUX_RESET_MASK, \\\n}\n\nstatic const struct dce110_aux_registers aux_engine_regs[] = {\n\t\taux_engine_regs(0),\n\t\taux_engine_regs(1),\n\t\taux_engine_regs(2),\n\t\taux_engine_regs(3),\n\t\taux_engine_regs(4),\n\t\taux_engine_regs(5)\n};\n\n#define tf_regs(id)\\\n[id] = {\\\n\tTF_REG_LIST_DCN20(id),\\\n}\n\nstatic const struct dcn2_dpp_registers tf_regs[] = {\n\ttf_regs(0),\n\ttf_regs(1),\n\ttf_regs(2),\n\ttf_regs(3),\n\ttf_regs(4),\n\ttf_regs(5),\n};\n\nstatic const struct dcn2_dpp_shift tf_shift = {\n\t\tTF_REG_LIST_SH_MASK_DCN20(__SHIFT)\n};\n\nstatic const struct dcn2_dpp_mask tf_mask = {\n\t\tTF_REG_LIST_SH_MASK_DCN20(_MASK)\n};\n\n#define dwbc_regs_dcn2(id)\\\n[id] = {\\\n\tDWBC_COMMON_REG_LIST_DCN2_0(id),\\\n\t\t}\n\nstatic const struct dcn20_dwbc_registers dwbc20_regs[] = {\n\tdwbc_regs_dcn2(0),\n};\n\nstatic const struct dcn20_dwbc_shift dwbc20_shift = {\n\tDWBC_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn20_dwbc_mask dwbc20_mask = {\n\tDWBC_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\n#define mcif_wb_regs_dcn2(id)\\\n[id] = {\\\n\tMCIF_WB_COMMON_REG_LIST_DCN2_0(id),\\\n\t\t}\n\nstatic const struct dcn20_mmhubbub_registers mcif_wb20_regs[] = {\n\tmcif_wb_regs_dcn2(0),\n};\n\nstatic const struct dcn20_mmhubbub_shift mcif_wb20_shift = {\n\tMCIF_WB_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn20_mmhubbub_mask mcif_wb20_mask = {\n\tMCIF_WB_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\nstatic const struct dcn20_mpc_registers mpc_regs = {\n\t\tMPC_REG_LIST_DCN2_0(0),\n\t\tMPC_REG_LIST_DCN2_0(1),\n\t\tMPC_REG_LIST_DCN2_0(2),\n\t\tMPC_REG_LIST_DCN2_0(3),\n\t\tMPC_REG_LIST_DCN2_0(4),\n\t\tMPC_REG_LIST_DCN2_0(5),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(0),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(1),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(2),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(3),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(4),\n\t\tMPC_OUT_MUX_REG_LIST_DCN2_0(5),\n};\n\nstatic const struct dcn20_mpc_shift mpc_shift = {\n\tMPC_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn20_mpc_mask mpc_mask = {\n\tMPC_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\n#define tg_regs(id)\\\n[id] = {TG_COMMON_REG_LIST_DCN2_0(id)}\n\n\nstatic const struct dcn_optc_registers tg_regs[] = {\n\ttg_regs(0),\n\ttg_regs(1),\n\ttg_regs(2),\n\ttg_regs(3),\n\ttg_regs(4),\n\ttg_regs(5)\n};\n\nstatic const struct dcn_optc_shift tg_shift = {\n\tTG_COMMON_MASK_SH_LIST_DCN2_0(__SHIFT)\n};\n\nstatic const struct dcn_optc_mask tg_mask = {\n\tTG_COMMON_MASK_SH_LIST_DCN2_0(_MASK)\n};\n\n#define hubp_regs(id)\\\n[id] = {\\\n\tHUBP_REG_LIST_DCN20(id)\\\n}\n\nstatic const struct dcn_hubp2_registers hubp_regs[] = {\n\t\thubp_regs(0),\n\t\thubp_regs(1),\n\t\thubp_regs(2),\n\t\thubp_regs(3),\n\t\thubp_regs(4),\n\t\thubp_regs(5)\n};\n\nstatic const struct dcn_hubp2_shift hubp_shift = {\n\t\tHUBP_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn_hubp2_mask hubp_mask = {\n\t\tHUBP_MASK_SH_LIST_DCN20(_MASK)\n};\n\nstatic const struct dcn_hubbub_registers hubbub_reg = {\n\t\tHUBBUB_REG_LIST_DCN20(0)\n};\n\nstatic const struct dcn_hubbub_shift hubbub_shift = {\n\t\tHUBBUB_MASK_SH_LIST_DCN20(__SHIFT)\n};\n\nstatic const struct dcn_hubbub_mask hubbub_mask = {\n\t\tHUBBUB_MASK_SH_LIST_DCN20(_MASK)\n};\n\n#define vmid_regs(id)\\\n[id] = {\\\n\t\tDCN20_VMID_REG_LIST(id)\\\n}\n\nstatic const struct dcn_vmid_registers vmid_regs[] = {\n\tvmid_regs(0),\n\tvmid_regs(1),\n\tvmid_regs(2),\n\tvmid_regs(3),\n\tvmid_regs(4),\n\tvmid_regs(5),\n\tvmid_regs(6),\n\tvmid_regs(7),\n\tvmid_regs(8),\n\tvmid_regs(9),\n\tvmid_regs(10),\n\tvmid_regs(11),\n\tvmid_regs(12),\n\tvmid_regs(13),\n\tvmid_regs(14),\n\tvmid_regs(15)\n};\n\nstatic const struct dcn20_vmid_shift vmid_shifts = {\n\t\tDCN20_VMID_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dcn20_vmid_mask vmid_masks = {\n\t\tDCN20_VMID_MASK_SH_LIST(_MASK)\n};\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n#define dsc_regsDCN20(id)\\\n[id] = {\\\n\tDSC_REG_LIST_DCN20(id)\\\n}\n\nstatic const struct dcn20_dsc_registers dsc_regs[] = {\n\tdsc_regsDCN20(0),\n\tdsc_regsDCN20(1),\n\tdsc_regsDCN20(2),\n\tdsc_regsDCN20(3),\n\tdsc_regsDCN20(4),\n\tdsc_regsDCN20(5)\n};\n\nstatic const struct dcn20_dsc_shift dsc_shift = {\n\tDSC_REG_LIST_SH_MASK_DCN20(__SHIFT)\n};\n\nstatic const struct dcn20_dsc_mask dsc_mask = {\n\tDSC_REG_LIST_SH_MASK_DCN20(_MASK)\n};\n#endif\n\nstatic const struct dccg_registers dccg_regs = {\n\t\tDCCG_REG_LIST_DCN2()\n};\n\nstatic const struct dccg_shift dccg_shift = {\n\t\tDCCG_MASK_SH_LIST_DCN2(__SHIFT)\n};\n\nstatic const struct dccg_mask dccg_mask = {\n\t\tDCCG_MASK_SH_LIST_DCN2(_MASK)\n};\n\nstatic const struct resource_caps res_cap_nv10 = {\n\t\t.num_timing_generator = 6,\n\t\t.num_opp = 6,\n\t\t.num_video_plane = 6,\n\t\t.num_audio = 7,\n\t\t.num_stream_encoder = 6,\n\t\t.num_pll = 6,\n\t\t.num_dwb = 1,\n\t\t.num_ddc = 6,\n\t\t.num_vmid = 16,\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t\t.num_dsc = 6,\n#endif\n};\n\nstatic const struct dc_plane_cap plane_cap = {\n\t.type = DC_PLANE_TYPE_DCN_UNIVERSAL,\n\t.blends_with_above = true,\n\t.blends_with_below = true,\n\t.per_pixel_alpha = true,\n\n\t.pixel_format_support = {\n\t\t\t.argb8888 = true,\n\t\t\t.nv12 = true,\n\t\t\t.fp16 = true\n\t},\n\n\t.max_upscale_factor = {\n\t\t\t.argb8888 = 16000,\n\t\t\t.nv12 = 16000,\n\t\t\t.fp16 = 1\n\t},\n\n\t.max_downscale_factor = {\n\t\t\t.argb8888 = 250,\n\t\t\t.nv12 = 250,\n\t\t\t.fp16 = 1\n\t}\n};\nstatic const struct resource_caps res_cap_nv14 = {\n\t\t.num_timing_generator = 5,\n\t\t.num_opp = 5,\n\t\t.num_video_plane = 5,\n\t\t.num_audio = 6,\n\t\t.num_stream_encoder = 5,\n\t\t.num_pll = 5,\n\t\t.num_dwb = 0,\n\t\t.num_ddc = 5,\n};\n\nstatic const struct dc_debug_options debug_defaults_drv = {\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = false,\n\t\t.clock_trace = true,\n\t\t.disable_pplib_clock_request = true,\n\t\t.pipe_split_policy = MPC_SPLIT_DYNAMIC,\n\t\t.force_single_disp_pipe_split = true,\n\t\t.disable_dcc = DCC_ENABLE,\n\t\t.vsr_support = true,\n\t\t.performance_trace = false,\n\t\t.max_downscale_src_width = 5120,/*upto 5K*/\n\t\t.disable_pplib_wm_range = false,\n\t\t.scl_reset_length10 = true,\n\t\t.sanity_checks = false,\n\t\t.disable_tri_buf = true,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nstatic const struct dc_debug_options debug_defaults_diags = {\n\t\t.disable_dmcu = true,\n\t\t.force_abm_enable = false,\n\t\t.timing_trace = true,\n\t\t.clock_trace = true,\n\t\t.disable_dpp_power_gate = true,\n\t\t.disable_hubp_power_gate = true,\n\t\t.disable_clock_gate = true,\n\t\t.disable_pplib_clock_request = true,\n\t\t.disable_pplib_wm_range = true,\n\t\t.disable_stutter = true,\n\t\t.scl_reset_length10 = true,\n\t\t.underflow_assert_delay_us = 0xFFFFFFFF,\n};\n\nvoid dcn20_dpp_destroy(struct dpp **dpp)\n{\n\tkfree(TO_DCN20_DPP(*dpp));\n\t*dpp = NULL;\n}\n\nstruct dpp *dcn20_dpp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn20_dpp *dpp =\n\t\tkzalloc(sizeof(struct dcn20_dpp), GFP_KERNEL);\n\n\tif (!dpp)\n\t\treturn NULL;\n\n\tif (dpp2_construct(dpp, ctx, inst,\n\t\t\t&tf_regs[inst], &tf_shift, &tf_mask))\n\t\treturn &dpp->base;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(dpp);\n\treturn NULL;\n}\n\nstruct input_pixel_processor *dcn20_ipp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn10_ipp *ipp =\n\t\tkzalloc(sizeof(struct dcn10_ipp), GFP_KERNEL);\n\n\tif (!ipp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn20_ipp_construct(ipp, ctx, inst,\n\t\t\t&ipp_regs[inst], &ipp_shift, &ipp_mask);\n\treturn &ipp->base;\n}\n\n\nstruct output_pixel_processor *dcn20_opp_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn20_opp *opp =\n\t\tkzalloc(sizeof(struct dcn20_opp), GFP_KERNEL);\n\n\tif (!opp) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdcn20_opp_construct(opp, ctx, inst,\n\t\t\t&opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}\n\nstruct dce_aux *dcn20_aux_engine_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct aux_engine_dce110 *aux_engine =\n\t\tkzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);\n\n\tif (!aux_engine)\n\t\treturn NULL;\n\n\tdce110_aux_engine_construct(aux_engine, ctx, inst,\n\t\t\t\t    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,\n\t\t\t\t    &aux_engine_regs[inst]);\n\n\treturn &aux_engine->base;\n}\n#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }\n\nstatic const struct dce_i2c_registers i2c_hw_regs[] = {\n\t\ti2c_inst_regs(1),\n\t\ti2c_inst_regs(2),\n\t\ti2c_inst_regs(3),\n\t\ti2c_inst_regs(4),\n\t\ti2c_inst_regs(5),\n\t\ti2c_inst_regs(6),\n};\n\nstatic const struct dce_i2c_shift i2c_shifts = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCN2(__SHIFT)\n};\n\nstatic const struct dce_i2c_mask i2c_masks = {\n\t\tI2C_COMMON_MASK_SH_LIST_DCN2(_MASK)\n};\n\nstruct dce_i2c_hw *dcn20_i2c_hw_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce_i2c_hw *dce_i2c_hw =\n\t\tkzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);\n\n\tif (!dce_i2c_hw)\n\t\treturn NULL;\n\n\tdcn2_i2c_hw_construct(dce_i2c_hw, ctx, inst,\n\t\t\t\t    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);\n\n\treturn dce_i2c_hw;\n}\nstruct mpc *dcn20_mpc_create(struct dc_context *ctx)\n{\n\tstruct dcn20_mpc *mpc20 = kzalloc(sizeof(struct dcn20_mpc),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!mpc20)\n\t\treturn NULL;\n\n\tdcn20_mpc_construct(mpc20, ctx,\n\t\t\t&mpc_regs,\n\t\t\t&mpc_shift,\n\t\t\t&mpc_mask,\n\t\t\t6);\n\n\treturn &mpc20->base;\n}\n\nstruct hubbub *dcn20_hubbub_create(struct dc_context *ctx)\n{\n\tint i;\n\tstruct dcn20_hubbub *hubbub = kzalloc(sizeof(struct dcn20_hubbub),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!hubbub)\n\t\treturn NULL;\n\n\thubbub2_construct(hubbub, ctx,\n\t\t\t&hubbub_reg,\n\t\t\t&hubbub_shift,\n\t\t\t&hubbub_mask);\n\n\tfor (i = 0; i < res_cap_nv10.num_vmid; i++) {\n\t\tstruct dcn20_vmid *vmid = &hubbub->vmid[i];\n\n\t\tvmid->ctx = ctx;\n\n\t\tvmid->regs = &vmid_regs[i];\n\t\tvmid->shifts = &vmid_shifts;\n\t\tvmid->masks = &vmid_masks;\n\t}\n\n\treturn &hubbub->base;\n}\n\nstruct timing_generator *dcn20_timing_generator_create(\n\t\tstruct dc_context *ctx,\n\t\tuint32_t instance)\n{\n\tstruct optc *tgn10 =\n\t\tkzalloc(sizeof(struct optc), GFP_KERNEL);\n\n\tif (!tgn10)\n\t\treturn NULL;\n\n\ttgn10->base.inst = instance;\n\ttgn10->base.ctx = ctx;\n\n\ttgn10->tg_regs = &tg_regs[instance];\n\ttgn10->tg_shift = &tg_shift;\n\ttgn10->tg_mask = &tg_mask;\n\n\tdcn20_timing_generator_init(tgn10);\n\n\treturn &tgn10->base;\n}\n\nstatic const struct encoder_feature_support link_enc_feature = {\n\t\t.max_hdmi_deep_color = COLOR_DEPTH_121212,\n\t\t.max_hdmi_pixel_clock = 600000,\n\t\t.hdmi_ycbcr420_supported = true,\n\t\t.dp_ycbcr420_supported = true,\n\t\t.flags.bits.IS_HBR2_CAPABLE = true,\n\t\t.flags.bits.IS_HBR3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS3_CAPABLE = true,\n\t\t.flags.bits.IS_TPS4_CAPABLE = true\n};\n\nstruct link_encoder *dcn20_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dcn20_link_encoder *enc20 =\n\t\tkzalloc(sizeof(struct dcn20_link_encoder), GFP_KERNEL);\n\n\tif (!enc20)\n\t\treturn NULL;\n\n\tdcn20_link_encoder_construct(enc20,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source],\n\t\t\t\t      &le_shift,\n\t\t\t\t      &le_mask);\n\n\treturn &enc20->enc10.base;\n}\n\nstruct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}\n\nstatic void read_dce_straps(\n\tstruct dc_context *ctx,\n\tstruct resource_straps *straps)\n{\n\tgeneric_reg_get(ctx, mmDC_PINSTRAPS + BASE(mmDC_PINSTRAPS_BASE_IDX),\n\t\tFN(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO), &straps->dc_pinstraps_audio);\n}\n\nstatic struct audio *dcn20_create_audio(\n\t\tstruct dc_context *ctx, unsigned int inst)\n{\n\treturn dce_audio_create(ctx, inst,\n\t\t\t&audio_regs[inst], &audio_shift, &audio_mask);\n}\n\nstruct stream_encoder *dcn20_stream_encoder_create(\n\tenum engine_id eng_id,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn10_stream_encoder *enc1 =\n\t\tkzalloc(sizeof(struct dcn10_stream_encoder), GFP_KERNEL);\n\n\tif (!enc1)\n\t\treturn NULL;\n\n\tdcn20_stream_encoder_construct(enc1, ctx, ctx->dc_bios, eng_id,\n\t\t\t\t\t&stream_enc_regs[eng_id],\n\t\t\t\t\t&se_shift, &se_mask);\n\n\treturn &enc1->base;\n}\n\nstatic const struct dce_hwseq_registers hwseq_reg = {\n\t\tHWSEQ_DCN2_REG_LIST()\n};\n\nstatic const struct dce_hwseq_shift hwseq_shift = {\n\t\tHWSEQ_DCN2_MASK_SH_LIST(__SHIFT)\n};\n\nstatic const struct dce_hwseq_mask hwseq_mask = {\n\t\tHWSEQ_DCN2_MASK_SH_LIST(_MASK)\n};\n\nstruct dce_hwseq *dcn20_hwseq_create(\n\tstruct dc_context *ctx)\n{\n\tstruct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);\n\n\tif (hws) {\n\t\thws->ctx = ctx;\n\t\thws->regs = &hwseq_reg;\n\t\thws->shifts = &hwseq_shift;\n\t\thws->masks = &hwseq_mask;\n\t}\n\treturn hws;\n}\n\nstatic const struct resource_create_funcs res_create_funcs = {\n\t.read_dce_straps = read_dce_straps,\n\t.create_audio = dcn20_create_audio,\n\t.create_stream_encoder = dcn20_stream_encoder_create,\n\t.create_hwseq = dcn20_hwseq_create,\n};\n\nstatic const struct resource_create_funcs res_create_maximus_funcs = {\n\t.read_dce_straps = NULL,\n\t.create_audio = NULL,\n\t.create_stream_encoder = NULL,\n\t.create_hwseq = dcn20_hwseq_create,\n};\n\nvoid dcn20_clock_source_destroy(struct clock_source **clk_src)\n{\n\tkfree(TO_DCE110_CLK_SRC(*clk_src));\n\t*clk_src = NULL;\n}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\nstruct display_stream_compressor *dcn20_dsc_create(\n\tstruct dc_context *ctx, uint32_t inst)\n{\n\tstruct dcn20_dsc *dsc =\n\t\tkzalloc(sizeof(struct dcn20_dsc), GFP_KERNEL);\n\n\tif (!dsc) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn NULL;\n\t}\n\n\tdsc2_construct(dsc, ctx, inst, &dsc_regs[inst], &dsc_shift, &dsc_mask);\n\treturn &dsc->base;\n}\n\nvoid dcn20_dsc_destroy(struct display_stream_compressor **dsc)\n{\n\tkfree(container_of(*dsc, struct dcn20_dsc, base));\n\t*dsc = NULL;\n}\n\n#endif\n\nstatic void destruct(struct dcn20_resource_pool *pool)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pool->base.stream_enc_count; i++) {\n\t\tif (pool->base.stream_enc[i] != NULL) {\n\t\t\tkfree(DCN10STRENC_FROM_STRENC(pool->base.stream_enc[i]));\n\t\t\tpool->base.stream_enc[i] = NULL;\n\t\t}\n\t}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tfor (i = 0; i < pool->base.res_cap->num_dsc; i++) {\n\t\tif (pool->base.dscs[i] != NULL)\n\t\t\tdcn20_dsc_destroy(&pool->base.dscs[i]);\n\t}\n#endif\n\n\tif (pool->base.mpc != NULL) {\n\t\tkfree(TO_DCN20_MPC(pool->base.mpc));\n\t\tpool->base.mpc = NULL;\n\t}\n\tif (pool->base.hubbub != NULL) {\n\t\tkfree(pool->base.hubbub);\n\t\tpool->base.hubbub = NULL;\n\t}\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tif (pool->base.dpps[i] != NULL)\n\t\t\tdcn20_dpp_destroy(&pool->base.dpps[i]);\n\n\t\tif (pool->base.ipps[i] != NULL)\n\t\t\tpool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);\n\n\t\tif (pool->base.hubps[i] != NULL) {\n\t\t\tkfree(TO_DCN20_HUBP(pool->base.hubps[i]));\n\t\t\tpool->base.hubps[i] = NULL;\n\t\t}\n\n\t\tif (pool->base.irqs != NULL) {\n\t\t\tdal_irq_service_destroy(&pool->base.irqs);\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tif (pool->base.engines[i] != NULL)\n\t\t\tdce110_engine_destroy(&pool->base.engines[i]);\n\t\tif (pool->base.hw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.hw_i2cs[i]);\n\t\t\tpool->base.hw_i2cs[i] = NULL;\n\t\t}\n\t\tif (pool->base.sw_i2cs[i] != NULL) {\n\t\t\tkfree(pool->base.sw_i2cs[i]);\n\t\t\tpool->base.sw_i2cs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_opp; i++) {\n\t\tif (pool->base.opps[i] != NULL)\n\t\t\tpool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_timing_generator; i++) {\n\t\tif (pool->base.timing_generators[i] != NULL)\t{\n\t\t\tkfree(DCN10TG_FROM_TG(pool->base.timing_generators[i]));\n\t\t\tpool->base.timing_generators[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_dwb; i++) {\n\t\tif (pool->base.dwbc[i] != NULL) {\n\t\t\tkfree(TO_DCN20_DWBC(pool->base.dwbc[i]));\n\t\t\tpool->base.dwbc[i] = NULL;\n\t\t}\n\t\tif (pool->base.mcif_wb[i] != NULL) {\n\t\t\tkfree(TO_DCN20_MMHUBBUB(pool->base.mcif_wb[i]));\n\t\t\tpool->base.mcif_wb[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.audio_count; i++) {\n\t\tif (pool->base.audios[i])\n\t\t\tdce_aud_destroy(&pool->base.audios[i]);\n\t}\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] != NULL) {\n\t\t\tdcn20_clock_source_destroy(&pool->base.clock_sources[i]);\n\t\t\tpool->base.clock_sources[i] = NULL;\n\t\t}\n\t}\n\n\tif (pool->base.dp_clock_source != NULL) {\n\t\tdcn20_clock_source_destroy(&pool->base.dp_clock_source);\n\t\tpool->base.dp_clock_source = NULL;\n\t}\n\n\n\tif (pool->base.abm != NULL)\n\t\tdce_abm_destroy(&pool->base.abm);\n\n\tif (pool->base.dmcu != NULL)\n\t\tdce_dmcu_destroy(&pool->base.dmcu);\n\n\tif (pool->base.dccg != NULL)\n\t\tdcn_dccg_destroy(&pool->base.dccg);\n\n\tif (pool->base.pp_smu != NULL)\n\t\tdcn20_pp_smu_destroy(&pool->base.pp_smu);\n\n}\n\nstruct hubp *dcn20_hubp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dcn20_hubp *hubp2 =\n\t\tkzalloc(sizeof(struct dcn20_hubp), GFP_KERNEL);\n\n\tif (!hubp2)\n\t\treturn NULL;\n\n\tif (hubp2_construct(hubp2, ctx, inst,\n\t\t\t&hubp_regs[inst], &hubp_shift, &hubp_mask))\n\t\treturn &hubp2->base;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(hubp2);\n\treturn NULL;\n}\n\nstatic void get_pixel_clock_parameters(\n\tstruct pipe_ctx *pipe_ctx,\n\tstruct pixel_clk_params *pixel_clk_params)\n{\n\tconst struct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct pipe_ctx *odm_pipe;\n\tint opp_cnt = 1;\n\n\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\topp_cnt++;\n\n\tpixel_clk_params->requested_pix_clk_100hz = stream->timing.pix_clk_100hz;\n\tpixel_clk_params->encoder_object_id = stream->link->link_enc->id;\n\tpixel_clk_params->signal_type = pipe_ctx->stream->signal;\n\tpixel_clk_params->controller_id = pipe_ctx->stream_res.tg->inst + 1;\n\t/* TODO: un-hardcode*/\n\tpixel_clk_params->requested_sym_clk = LINK_RATE_LOW *\n\t\tLINK_RATE_REF_FREQ_IN_KHZ;\n\tpixel_clk_params->flags.ENABLE_SS = 0;\n\tpixel_clk_params->color_depth =\n\t\tstream->timing.display_color_depth;\n\tpixel_clk_params->flags.DISPLAY_BLANKED = 1;\n\tpixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;\n\n\tif (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)\n\t\tpixel_clk_params->color_depth = COLOR_DEPTH_888;\n\n\tif (opp_cnt == 4)\n\t\tpixel_clk_params->requested_pix_clk_100hz /= 4;\n\telse if (optc1_is_two_pixels_per_containter(&stream->timing) || opp_cnt == 2)\n\t\tpixel_clk_params->requested_pix_clk_100hz /= 2;\n\n\tif (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\tpixel_clk_params->requested_pix_clk_100hz *= 2;\n\n}\n\nstatic void build_clamping_params(struct dc_stream_state *stream)\n{\n\tstream->clamping.clamping_level = CLAMPING_FULL_RANGE;\n\tstream->clamping.c_depth = stream->timing.display_color_depth;\n\tstream->clamping.pixel_encoding = stream->timing.pixel_encoding;\n}\n\nstatic enum dc_status build_pipe_hw_param(struct pipe_ctx *pipe_ctx)\n{\n\n\tget_pixel_clock_parameters(pipe_ctx, &pipe_ctx->stream_res.pix_clk_params);\n\n\tpipe_ctx->clock_source->funcs->get_pix_clk_dividers(\n\t\tpipe_ctx->clock_source,\n\t\t&pipe_ctx->stream_res.pix_clk_params,\n\t\t&pipe_ctx->pll_settings);\n\n\tpipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;\n\n\tresource_build_bit_depth_reduction_params(pipe_ctx->stream,\n\t\t\t\t\t&pipe_ctx->stream->bit_depth_params);\n\tbuild_clamping_params(pipe_ctx->stream);\n\n\treturn DC_OK;\n}\n\nenum dc_status dcn20_build_mapped_resource(const struct dc *dc, struct dc_state *context, struct dc_stream_state *stream)\n{\n\tenum dc_status status = DC_OK;\n\tstruct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);\n\n\t/*TODO Seems unneeded anymore */\n\t/*\tif (old_context && resource_is_stream_unchanged(old_context, stream)) {\n\t\t\tif (stream != NULL && old_context->streams[i] != NULL) {\n\t\t\t\t todo: shouldn't have to copy missing parameter here\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tstream->clamping.pixel_encoding =\n\t\t\t\t\t\tstream->timing.pixel_encoding;\n\n\t\t\t\tresource_build_bit_depth_reduction_params(stream,\n\t\t\t\t\t\t\t\t&stream->bit_depth_params);\n\t\t\t\tbuild_clamping_params(stream);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t*/\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\n\tstatus = build_pipe_hw_param(pipe_ctx);\n\n\treturn status;\n}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\nstatic void acquire_dsc(struct resource_context *res_ctx,\n\t\t\tconst struct resource_pool *pool,\n\t\t\tstruct display_stream_compressor **dsc)\n{\n\tint i;\n\n\tASSERT(*dsc == NULL);\n\t*dsc = NULL;\n\n\t/* Find first free DSC */\n\tfor (i = 0; i < pool->res_cap->num_dsc; i++)\n\t\tif (!res_ctx->is_dsc_acquired[i]) {\n\t\t\t*dsc = pool->dscs[i];\n\t\t\tres_ctx->is_dsc_acquired[i] = true;\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void release_dsc(struct resource_context *res_ctx,\n\t\t\tconst struct resource_pool *pool,\n\t\t\tstruct display_stream_compressor **dsc)\n{\n\tint i;\n\n\tfor (i = 0; i < pool->res_cap->num_dsc; i++)\n\t\tif (pool->dscs[i] == *dsc) {\n\t\t\tres_ctx->is_dsc_acquired[i] = false;\n\t\t\t*dsc = NULL;\n\t\t\tbreak;\n\t\t}\n}\n\n#endif\n\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\nstatic enum dc_status add_dsc_to_stream_resource(struct dc *dc,\n\t\tstruct dc_state *dc_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_OK;\n\tint i;\n\tconst struct resource_pool *pool = dc->res_pool;\n\n\t/* Get a DSC if required and available */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &dc_ctx->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream != dc_stream)\n\t\t\tcontinue;\n\n\t\tacquire_dsc(&dc_ctx->res_ctx, pool, &pipe_ctx->stream_res.dsc);\n\n\t\t/* The number of DSCs can be less than the number of pipes */\n\t\tif (!pipe_ctx->stream_res.dsc) {\n\t\t\tdm_output_to_console(\"No DSCs available\\n\");\n\t\t\tresult = DC_NO_DSC_RESOURCE;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n\nstatic enum dc_status remove_dsc_from_stream_resource(struct dc *dc,\n\t\tstruct dc_state *new_ctx,\n\t\tstruct dc_stream_state *dc_stream)\n{\n\tstruct pipe_ctx *pipe_ctx = NULL;\n\tint i;\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (new_ctx->res_ctx.pipe_ctx[i].stream == dc_stream && !new_ctx->res_ctx.pipe_ctx[i].top_pipe) {\n\t\t\tpipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];\n\n\t\t\tif (pipe_ctx->stream_res.dsc)\n\t\t\t\trelease_dsc(&new_ctx->res_ctx, dc->res_pool, &pipe_ctx->stream_res.dsc);\n\t\t}\n\t}\n\n\tif (!pipe_ctx)\n\t\treturn DC_ERROR_UNEXPECTED;\n\telse\n\t\treturn DC_OK;\n}\n#endif\n\n\nenum dc_status dcn20_add_stream_to_ctx(struct dc *dc, struct dc_state *new_ctx, struct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_ERROR_UNEXPECTED;\n\n\tresult = resource_map_pool_resources(dc, new_ctx, dc_stream);\n\n\tif (result == DC_OK)\n\t\tresult = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t/* Get a DSC if required and available */\n\tif (result == DC_OK && dc_stream->timing.flags.DSC)\n\t\tresult = add_dsc_to_stream_resource(dc, new_ctx, dc_stream);\n#endif\n\n\tif (result == DC_OK)\n\t\tresult = dcn20_build_mapped_resource(dc, new_ctx, dc_stream);\n\n\treturn result;\n}\n\n\nenum dc_status dcn20_remove_stream_from_ctx(struct dc *dc, struct dc_state *new_ctx, struct dc_stream_state *dc_stream)\n{\n\tenum dc_status result = DC_OK;\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tresult = remove_dsc_from_stream_resource(dc, new_ctx, dc_stream);\n#endif\n\n\treturn result;\n}\n\n\nstatic void swizzle_to_dml_params(\n\t\tenum swizzle_mode_values swizzle,\n\t\tunsigned int *sw_mode)\n{\n\tswitch (swizzle) {\n\tcase DC_SW_LINEAR:\n\t\t*sw_mode = dm_sw_linear;\n\t\tbreak;\n\tcase DC_SW_4KB_S:\n\t\t*sw_mode = dm_sw_4kb_s;\n\t\tbreak;\n\tcase DC_SW_4KB_S_X:\n\t\t*sw_mode = dm_sw_4kb_s_x;\n\t\tbreak;\n\tcase DC_SW_4KB_D:\n\t\t*sw_mode = dm_sw_4kb_d;\n\t\tbreak;\n\tcase DC_SW_4KB_D_X:\n\t\t*sw_mode = dm_sw_4kb_d_x;\n\t\tbreak;\n\tcase DC_SW_64KB_S:\n\t\t*sw_mode = dm_sw_64kb_s;\n\t\tbreak;\n\tcase DC_SW_64KB_S_X:\n\t\t*sw_mode = dm_sw_64kb_s_x;\n\t\tbreak;\n\tcase DC_SW_64KB_S_T:\n\t\t*sw_mode = dm_sw_64kb_s_t;\n\t\tbreak;\n\tcase DC_SW_64KB_D:\n\t\t*sw_mode = dm_sw_64kb_d;\n\t\tbreak;\n\tcase DC_SW_64KB_D_X:\n\t\t*sw_mode = dm_sw_64kb_d_x;\n\t\tbreak;\n\tcase DC_SW_64KB_D_T:\n\t\t*sw_mode = dm_sw_64kb_d_t;\n\t\tbreak;\n\tcase DC_SW_64KB_R_X:\n\t\t*sw_mode = dm_sw_64kb_r_x;\n\t\tbreak;\n\tcase DC_SW_VAR_S:\n\t\t*sw_mode = dm_sw_var_s;\n\t\tbreak;\n\tcase DC_SW_VAR_S_X:\n\t\t*sw_mode = dm_sw_var_s_x;\n\t\tbreak;\n\tcase DC_SW_VAR_D:\n\t\t*sw_mode = dm_sw_var_d;\n\t\tbreak;\n\tcase DC_SW_VAR_D_X:\n\t\t*sw_mode = dm_sw_var_d_x;\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0); /* Not supported */\n\t\tbreak;\n\t}\n}\n\nstatic bool dcn20_split_stream_for_odm(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct pipe_ctx *prev_odm_pipe,\n\t\tstruct pipe_ctx *next_odm_pipe)\n{\n\tint pipe_idx = next_odm_pipe->pipe_idx;\n\n\t*next_odm_pipe = *prev_odm_pipe;\n\n\tnext_odm_pipe->pipe_idx = pipe_idx;\n\tnext_odm_pipe->plane_res.mi = pool->mis[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.hubp = pool->hubps[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.ipp = pool->ipps[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.xfm = pool->transforms[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.dpp = pool->dpps[next_odm_pipe->pipe_idx];\n\tnext_odm_pipe->plane_res.mpcc_inst = pool->dpps[next_odm_pipe->pipe_idx]->inst;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tnext_odm_pipe->stream_res.dsc = NULL;\n#endif\n\tif (prev_odm_pipe->next_odm_pipe && prev_odm_pipe->next_odm_pipe != next_odm_pipe) {\n\t\tASSERT(!next_odm_pipe->next_odm_pipe);\n\t\tnext_odm_pipe->next_odm_pipe = prev_odm_pipe->next_odm_pipe;\n\t\tnext_odm_pipe->next_odm_pipe->prev_odm_pipe = next_odm_pipe;\n\t}\n\tprev_odm_pipe->next_odm_pipe = next_odm_pipe;\n\tnext_odm_pipe->prev_odm_pipe = prev_odm_pipe;\n\tASSERT(next_odm_pipe->top_pipe == NULL);\n\n\tif (prev_odm_pipe->plane_state) {\n\t\tstruct scaler_data *sd = &prev_odm_pipe->plane_res.scl_data;\n\t\tint new_width;\n\n\t\t/* HACTIVE halved for odm combine */\n\t\tsd->h_active /= 2;\n\t\t/* Calculate new vp and recout for left pipe */\n\t\t/* Need at least 16 pixels width per side */\n\t\tif (sd->recout.x + 16 >= sd->h_active)\n\t\t\treturn false;\n\t\tnew_width = sd->h_active - sd->recout.x;\n\t\tsd->viewport.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz, sd->recout.width - new_width));\n\t\tsd->viewport_c.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz_c, sd->recout.width - new_width));\n\t\tsd->recout.width = new_width;\n\n\t\t/* Calculate new vp and recout for right pipe */\n\t\tsd = &next_odm_pipe->plane_res.scl_data;\n\t\t/* HACTIVE halved for odm combine */\n\t\tsd->h_active /= 2;\n\t\t/* Need at least 16 pixels width per side */\n\t\tif (new_width <= 16)\n\t\t\treturn false;\n\t\tnew_width = sd->recout.width + sd->recout.x - sd->h_active;\n\t\tsd->viewport.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz, sd->recout.width - new_width));\n\t\tsd->viewport_c.width -= dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz_c, sd->recout.width - new_width));\n\t\tsd->recout.width = new_width;\n\t\tsd->viewport.x += dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz, sd->h_active - sd->recout.x));\n\t\tsd->viewport_c.x += dc_fixpt_floor(dc_fixpt_mul_int(\n\t\t\t\tsd->ratios.horz_c, sd->h_active - sd->recout.x));\n\t\tsd->recout.x = 0;\n\t}\n\tnext_odm_pipe->stream_res.opp = pool->opps[next_odm_pipe->pipe_idx];\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tif (next_odm_pipe->stream->timing.flags.DSC == 1) {\n\t\tacquire_dsc(res_ctx, pool, &next_odm_pipe->stream_res.dsc);\n\t\tASSERT(next_odm_pipe->stream_res.dsc);\n\t\tif (next_odm_pipe->stream_res.dsc == NULL)\n\t\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}\n\nstatic void dcn20_split_stream_for_mpc(\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tstruct pipe_ctx *primary_pipe,\n\t\tstruct pipe_ctx *secondary_pipe)\n{\n\tint pipe_idx = secondary_pipe->pipe_idx;\n\tstruct pipe_ctx *sec_bot_pipe = secondary_pipe->bottom_pipe;\n\n\t*secondary_pipe = *primary_pipe;\n\tsecondary_pipe->bottom_pipe = sec_bot_pipe;\n\n\tsecondary_pipe->pipe_idx = pipe_idx;\n\tsecondary_pipe->plane_res.mi = pool->mis[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.hubp = pool->hubps[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.ipp = pool->ipps[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.xfm = pool->transforms[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.dpp = pool->dpps[secondary_pipe->pipe_idx];\n\tsecondary_pipe->plane_res.mpcc_inst = pool->dpps[secondary_pipe->pipe_idx]->inst;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tsecondary_pipe->stream_res.dsc = NULL;\n#endif\n\tif (primary_pipe->bottom_pipe && primary_pipe->bottom_pipe != secondary_pipe) {\n\t\tASSERT(!secondary_pipe->bottom_pipe);\n\t\tsecondary_pipe->bottom_pipe = primary_pipe->bottom_pipe;\n\t\tsecondary_pipe->bottom_pipe->top_pipe = secondary_pipe;\n\t}\n\tprimary_pipe->bottom_pipe = secondary_pipe;\n\tsecondary_pipe->top_pipe = primary_pipe;\n\n\tASSERT(primary_pipe->plane_state);\n\tresource_build_scaling_params(primary_pipe);\n\tresource_build_scaling_params(secondary_pipe);\n}\n\nvoid dcn20_populate_dml_writeback_from_context(\n\t\tstruct dc *dc, struct resource_context *res_ctx, display_e2e_pipe_params_st *pipes)\n{\n\tint pipe_cnt, i;\n\n\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_writeback_info *wb_info = &res_ctx->pipe_ctx[i].stream->writeback_info[0];\n\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\t/* Set writeback information */\n\t\tpipes[pipe_cnt].dout.wb_enable = (wb_info->wb_enabled == true) ? 1 : 0;\n\t\tpipes[pipe_cnt].dout.num_active_wb++;\n\t\tpipes[pipe_cnt].dout.wb.wb_src_height = wb_info->dwb_params.cnv_params.crop_height;\n\t\tpipes[pipe_cnt].dout.wb.wb_src_width = wb_info->dwb_params.cnv_params.crop_width;\n\t\tpipes[pipe_cnt].dout.wb.wb_dst_width = wb_info->dwb_params.dest_width;\n\t\tpipes[pipe_cnt].dout.wb.wb_dst_height = wb_info->dwb_params.dest_height;\n\t\tpipes[pipe_cnt].dout.wb.wb_htaps_luma = 1;\n\t\tpipes[pipe_cnt].dout.wb.wb_vtaps_luma = 1;\n\t\tpipes[pipe_cnt].dout.wb.wb_htaps_chroma = wb_info->dwb_params.scaler_taps.h_taps_c;\n\t\tpipes[pipe_cnt].dout.wb.wb_vtaps_chroma = wb_info->dwb_params.scaler_taps.v_taps_c;\n\t\tpipes[pipe_cnt].dout.wb.wb_hratio = 1.0;\n\t\tpipes[pipe_cnt].dout.wb.wb_vratio = 1.0;\n\t\tif (wb_info->dwb_params.out_format == dwb_scaler_mode_yuv420) {\n\t\t\tif (wb_info->dwb_params.output_depth == DWB_OUTPUT_PIXEL_DEPTH_8BPC)\n\t\t\t\tpipes[pipe_cnt].dout.wb.wb_pixel_format = dm_420_8;\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].dout.wb.wb_pixel_format = dm_420_10;\n\t\t} else\n\t\t\tpipes[pipe_cnt].dout.wb.wb_pixel_format = dm_444_32;\n\n\t\tpipe_cnt++;\n\t}\n\n}\n\nint dcn20_populate_dml_pipes_from_context(\n\t\tstruct dc *dc, struct resource_context *res_ctx, display_e2e_pipe_params_st *pipes)\n{\n\tint pipe_cnt, i;\n\tbool synchronized_vblank = true;\n\n\tfor (i = 0, pipe_cnt = -1; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tif (pipe_cnt < 0) {\n\t\t\tpipe_cnt = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!resource_are_streams_timing_synchronizable(\n\t\t\t\tres_ctx->pipe_ctx[pipe_cnt].stream,\n\t\t\t\tres_ctx->pipe_ctx[i].stream)) {\n\t\t\tsynchronized_vblank = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct dc_crtc_timing *timing = &res_ctx->pipe_ctx[i].stream->timing;\n\t\tint output_bpc;\n\n\t\tif (!res_ctx->pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\t/* todo:\n\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_enable = 0;\n\t\tpipes[pipe_cnt].pipe.src.dcc = 0;\n\t\tpipes[pipe_cnt].pipe.src.vm = 0;*/\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t\tpipes[pipe_cnt].dout.dsc_enable = res_ctx->pipe_ctx[i].stream->timing.flags.DSC;\n\t\t/* todo: rotation?*/\n\t\tpipes[pipe_cnt].dout.dsc_slices = res_ctx->pipe_ctx[i].stream->timing.dsc_cfg.num_slices_h;\n#endif\n\t\tif (res_ctx->pipe_ctx[i].stream->use_dynamic_meta) {\n\t\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_enable = true;\n\t\t\t/* 1/2 vblank */\n\t\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_lines_before_active =\n\t\t\t\t(timing->v_total - timing->v_addressable\n\t\t\t\t\t- timing->v_border_top - timing->v_border_bottom) / 2;\n\t\t\t/* 36 bytes dp, 32 hdmi */\n\t\t\tpipes[pipe_cnt].pipe.src.dynamic_metadata_xmit_bytes =\n\t\t\t\tdc_is_dp_signal(res_ctx->pipe_ctx[i].stream->signal) ? 36 : 32;\n\t\t}\n\t\tpipes[pipe_cnt].pipe.src.dcc = false;\n\t\tpipes[pipe_cnt].pipe.src.dcc_rate = 1;\n\t\tpipes[pipe_cnt].pipe.dest.synchronized_vblank_all_planes = synchronized_vblank;\n\t\tpipes[pipe_cnt].pipe.dest.hblank_start = timing->h_total - timing->h_front_porch;\n\t\tpipes[pipe_cnt].pipe.dest.hblank_end = pipes[pipe_cnt].pipe.dest.hblank_start\n\t\t\t\t- timing->h_addressable\n\t\t\t\t- timing->h_border_left\n\t\t\t\t- timing->h_border_right;\n\t\tpipes[pipe_cnt].pipe.dest.vblank_start = timing->v_total - timing->v_front_porch;\n\t\tpipes[pipe_cnt].pipe.dest.vblank_end = pipes[pipe_cnt].pipe.dest.vblank_start\n\t\t\t\t- timing->v_addressable\n\t\t\t\t- timing->v_border_top\n\t\t\t\t- timing->v_border_bottom;\n\t\tpipes[pipe_cnt].pipe.dest.htotal = timing->h_total;\n\t\tpipes[pipe_cnt].pipe.dest.vtotal = timing->v_total;\n\t\tpipes[pipe_cnt].pipe.dest.hactive = timing->h_addressable;\n\t\tpipes[pipe_cnt].pipe.dest.vactive = timing->v_addressable;\n\t\tpipes[pipe_cnt].pipe.dest.interlaced = timing->flags.INTERLACE;\n\t\tpipes[pipe_cnt].pipe.dest.pixel_rate_mhz = timing->pix_clk_100hz/10000.0;\n\t\tif (timing->timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)\n\t\t\tpipes[pipe_cnt].pipe.dest.pixel_rate_mhz *= 2;\n\t\tpipes[pipe_cnt].pipe.dest.otg_inst = res_ctx->pipe_ctx[i].stream_res.tg->inst;\n\t\tpipes[pipe_cnt].dout.dp_lanes = 4;\n\t\tpipes[pipe_cnt].pipe.dest.vtotal_min = res_ctx->pipe_ctx[i].stream->adjust.v_total_min;\n\t\tpipes[pipe_cnt].pipe.dest.vtotal_max = res_ctx->pipe_ctx[i].stream->adjust.v_total_max;\n\t\tpipes[pipe_cnt].pipe.dest.odm_combine = res_ctx->pipe_ctx[i].prev_odm_pipe\n\t\t\t\t\t\t\t|| res_ctx->pipe_ctx[i].next_odm_pipe;\n\t\tpipes[pipe_cnt].pipe.src.hsplit_grp = res_ctx->pipe_ctx[i].pipe_idx;\n\t\tif (res_ctx->pipe_ctx[i].top_pipe && res_ctx->pipe_ctx[i].top_pipe->plane_state\n\t\t\t\t== res_ctx->pipe_ctx[i].plane_state)\n\t\t\tpipes[pipe_cnt].pipe.src.hsplit_grp = res_ctx->pipe_ctx[i].top_pipe->pipe_idx;\n\t\telse if (res_ctx->pipe_ctx[i].prev_odm_pipe) {\n\t\t\tstruct pipe_ctx *first_pipe = res_ctx->pipe_ctx[i].prev_odm_pipe;\n\n\t\t\twhile (first_pipe->prev_odm_pipe)\n\t\t\t\tfirst_pipe = first_pipe->prev_odm_pipe;\n\t\t\tpipes[pipe_cnt].pipe.src.hsplit_grp = first_pipe->pipe_idx;\n\t\t}\n\n\t\tswitch (res_ctx->pipe_ctx[i].stream->signal) {\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_dp;\n\t\t\tbreak;\n\t\tcase SIGNAL_TYPE_EDP:\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_edp;\n\t\t\tbreak;\n\t\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\t\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_hdmi;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* In case there is no signal, set dp with 4 lanes to allow max config */\n\t\t\tpipes[pipe_cnt].dout.output_type = dm_dp;\n\t\t\tpipes[pipe_cnt].dout.dp_lanes = 4;\n\t\t}\n\n\t\tswitch (res_ctx->pipe_ctx[i].stream->timing.display_color_depth) {\n\t\tcase COLOR_DEPTH_666:\n\t\t\toutput_bpc = 6;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_888:\n\t\t\toutput_bpc = 8;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\toutput_bpc = 10;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\toutput_bpc = 12;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_141414:\n\t\t\toutput_bpc = 14;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\toutput_bpc = 16;\n\t\t\tbreak;\n#ifdef CONFIG_DRM_AMD_DC_DCN2_0\n\t\tcase COLOR_DEPTH_999:\n\t\t\toutput_bpc = 9;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_111111:\n\t\t\toutput_bpc = 11;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\toutput_bpc = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (res_ctx->pipe_ctx[i].stream->timing.pixel_encoding) {\n\t\tcase PIXEL_ENCODING_RGB:\n\t\tcase PIXEL_ENCODING_YCBCR444:\n\t\t\tpipes[pipe_cnt].dout.output_format = dm_444;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = output_bpc * 3;\n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR420:\n\t\t\tpipes[pipe_cnt].dout.output_format = dm_420;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = (output_bpc * 3) / 2;\n\t\t\tbreak;\n\t\tcase PIXEL_ENCODING_YCBCR422:\n\t\t\tif (true) /* todo */\n\t\t\t\tpipes[pipe_cnt].dout.output_format = dm_s422;\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].dout.output_format = dm_n422;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = output_bpc * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpipes[pipe_cnt].dout.output_format = dm_444;\n\t\t\tpipes[pipe_cnt].dout.output_bpp = output_bpc * 3;\n\t\t}\n\n\t\t/* todo: default max for now, until there is logic reflecting this in dc*/\n\t\tpipes[pipe_cnt].dout.output_bpc = 12;\n\t\t/*\n\t\t * Use max cursor settings for calculations to minimize\n\t\t * bw calculations due to cursor on/off\n\t\t */\n\t\tpipes[pipe_cnt].pipe.src.num_cursors = 2;\n\t\tpipes[pipe_cnt].pipe.src.cur0_src_width = 256;\n\t\tpipes[pipe_cnt].pipe.src.cur0_bpp = dm_cur_32bit;\n\t\tpipes[pipe_cnt].pipe.src.cur1_src_width = 256;\n\t\tpipes[pipe_cnt].pipe.src.cur1_bpp = dm_cur_32bit;\n\n\t\tif (!res_ctx->pipe_ctx[i].plane_state) {\n\t\t\tpipes[pipe_cnt].pipe.src.source_scan = dm_horz;\n\t\t\tpipes[pipe_cnt].pipe.src.sw_mode = dm_sw_linear;\n\t\t\tpipes[pipe_cnt].pipe.src.macro_tile_size = dm_64k_tile;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_width = timing->h_addressable;\n\t\t\tif (pipes[pipe_cnt].pipe.src.viewport_width > 1920)\n\t\t\t\tpipes[pipe_cnt].pipe.src.viewport_width = 1920;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_height = timing->v_addressable;\n\t\t\tif (pipes[pipe_cnt].pipe.src.viewport_height > 1080)\n\t\t\t\tpipes[pipe_cnt].pipe.src.viewport_height = 1080;\n\t\t\tpipes[pipe_cnt].pipe.src.data_pitch = ((pipes[pipe_cnt].pipe.src.viewport_width + 63) / 64) * 64; /* linear sw only */\n\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_32;\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_width = pipes[pipe_cnt].pipe.src.viewport_width; /*vp_width/hratio*/\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_height = pipes[pipe_cnt].pipe.src.viewport_height; /*vp_height/vratio*/\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width = pipes[pipe_cnt].pipe.dest.recout_width;  /*when is_hsplit != 1*/\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height = pipes[pipe_cnt].pipe.dest.recout_height; /*when is_hsplit != 1*/\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.lb_depth = dm_lb_16;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.hscl_ratio = 1.0;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.vscl_ratio = 1.0;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.scl_enable = 0; /*Lb only or Full scl*/\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.htaps = 1;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.vtaps = 1;\n\t\t\tpipes[pipe_cnt].pipe.src.is_hsplit = 0;\n\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine = 0;\n\t\t\tpipes[pipe_cnt].pipe.dest.vtotal_min = timing->v_total;\n\t\t\tpipes[pipe_cnt].pipe.dest.vtotal_max = timing->v_total;\n\t\t} else {\n\t\t\tstruct dc_plane_state *pln = res_ctx->pipe_ctx[i].plane_state;\n\t\t\tstruct scaler_data *scl = &res_ctx->pipe_ctx[i].plane_res.scl_data;\n\n\t\t\tpipes[pipe_cnt].pipe.src.immediate_flip = pln->flip_immediate;\n\t\t\tpipes[pipe_cnt].pipe.src.is_hsplit = (res_ctx->pipe_ctx[i].bottom_pipe\n\t\t\t\t\t&& res_ctx->pipe_ctx[i].bottom_pipe->plane_state == pln)\n\t\t\t\t\t|| (res_ctx->pipe_ctx[i].top_pipe\n\t\t\t\t\t&& res_ctx->pipe_ctx[i].top_pipe->plane_state == pln);\n\t\t\tpipes[pipe_cnt].pipe.src.source_scan = pln->rotation == ROTATION_ANGLE_90\n\t\t\t\t\t|| pln->rotation == ROTATION_ANGLE_270 ? dm_vert : dm_horz;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_y_y = scl->viewport.y;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_y_c = scl->viewport_c.y;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_width = scl->viewport.width;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_width_c = scl->viewport_c.width;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_height = scl->viewport.height;\n\t\t\tpipes[pipe_cnt].pipe.src.viewport_height_c = scl->viewport_c.height;\n\t\t\tif (pln->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\t\t\t\tpipes[pipe_cnt].pipe.src.data_pitch = pln->plane_size.surface_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.data_pitch_c = pln->plane_size.chroma_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.meta_pitch = pln->dcc.meta_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.meta_pitch_c = pln->dcc.meta_pitch_c;\n\t\t\t} else {\n\t\t\t\tpipes[pipe_cnt].pipe.src.data_pitch = pln->plane_size.surface_pitch;\n\t\t\t\tpipes[pipe_cnt].pipe.src.meta_pitch = pln->dcc.meta_pitch;\n\t\t\t}\n\t\t\tpipes[pipe_cnt].pipe.src.dcc = pln->dcc.enable;\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_width = scl->recout.width;\n\t\t\tpipes[pipe_cnt].pipe.dest.recout_height = scl->recout.height;\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width = scl->recout.width;\n\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height = scl->recout.height;\n\t\t\tif (res_ctx->pipe_ctx[i].bottom_pipe && res_ctx->pipe_ctx[i].bottom_pipe->plane_state == pln) {\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].bottom_pipe->plane_res.scl_data.recout.width;\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].bottom_pipe->plane_res.scl_data.recout.height;\n\t\t\t} else if (res_ctx->pipe_ctx[i].top_pipe && res_ctx->pipe_ctx[i].top_pipe->plane_state == pln) {\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_width +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].top_pipe->plane_res.scl_data.recout.width;\n\t\t\t\tpipes[pipe_cnt].pipe.dest.full_recout_height +=\n\t\t\t\t\t\tres_ctx->pipe_ctx[i].top_pipe->plane_res.scl_data.recout.height;\n\t\t\t}\n\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.lb_depth = dm_lb_16;\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.hscl_ratio = (double) scl->ratios.horz.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.hscl_ratio_c = (double) scl->ratios.horz_c.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.vscl_ratio = (double) scl->ratios.vert.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.vscl_ratio_c = (double) scl->ratios.vert_c.value / (1ULL<<32);\n\t\t\tpipes[pipe_cnt].pipe.scale_ratio_depth.scl_enable =\n\t\t\t\t\tscl->ratios.vert.value != dc_fixpt_one.value\n\t\t\t\t\t|| scl->ratios.horz.value != dc_fixpt_one.value\n\t\t\t\t\t|| scl->ratios.vert_c.value != dc_fixpt_one.value\n\t\t\t\t\t|| scl->ratios.horz_c.value != dc_fixpt_one.value /*Lb only or Full scl*/\n\t\t\t\t\t|| dc->debug.always_scale; /*support always scale*/\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.htaps = scl->taps.h_taps;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.htaps_c = scl->taps.h_taps_c;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.vtaps = scl->taps.v_taps;\n\t\t\tpipes[pipe_cnt].pipe.scale_taps.vtaps_c = scl->taps.v_taps_c;\n\n\t\t\tpipes[pipe_cnt].pipe.src.macro_tile_size =\n\t\t\t\t\tswizzle_mode_to_macro_tile_size(pln->tiling_info.gfx9.swizzle);\n\t\t\tswizzle_to_dml_params(pln->tiling_info.gfx9.swizzle,\n\t\t\t\t\t&pipes[pipe_cnt].pipe.src.sw_mode);\n\n\t\t\tswitch (pln->format) {\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_420_8;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:\n\t\t\tcase SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_420_10;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_64;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_RGB565:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_16;\n\t\t\t\tbreak;\n\t\t\tcase SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpipes[pipe_cnt].pipe.src.source_format = dm_444_32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpipe_cnt++;\n\t}\n\n\t/* populate writeback information */\n\tdc->res_pool->funcs->populate_dml_writeback_from_context(dc, res_ctx, pipes);\n\n\treturn pipe_cnt;\n}\n\nunsigned int dcn20_calc_max_scaled_time(\n\t\tunsigned int time_per_pixel,\n\t\tenum mmhubbub_wbif_mode mode,\n\t\tunsigned int urgent_watermark)\n{\n\tunsigned int time_per_byte = 0;\n\tunsigned int total_y_free_entry = 0x200; /* two memory piece for luma */\n\tunsigned int total_c_free_entry = 0x140; /* two memory piece for chroma */\n\tunsigned int small_free_entry, max_free_entry;\n\tunsigned int buf_lh_capability;\n\tunsigned int max_scaled_time;\n\n\tif (mode == PACKED_444) /* packed mode */\n\t\ttime_per_byte = time_per_pixel/4;\n\telse if (mode == PLANAR_420_8BPC)\n\t\ttime_per_byte  = time_per_pixel;\n\telse if (mode == PLANAR_420_10BPC) /* p010 */\n\t\ttime_per_byte  = time_per_pixel * 819/1024;\n\n\tif (time_per_byte == 0)\n\t\ttime_per_byte = 1;\n\n\tsmall_free_entry  = (total_y_free_entry > total_c_free_entry) ? total_c_free_entry : total_y_free_entry;\n\tmax_free_entry    = (mode == PACKED_444) ? total_y_free_entry + total_c_free_entry : small_free_entry;\n\tbuf_lh_capability = max_free_entry*time_per_byte*32/16; /* there is 4bit fraction */\n\tmax_scaled_time   = buf_lh_capability - urgent_watermark;\n\treturn max_scaled_time;\n}\n\nvoid dcn20_set_mcif_arb_params(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint pipe_cnt)\n{\n\tenum mmhubbub_wbif_mode wbif_mode;\n\tstruct mcif_arb_params *wb_arb_params;\n\tint i, j, k, dwb_pipe;\n\n\t/* Writeback MCIF_WB arbitration parameters */\n\tdwb_pipe = 0;\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < MAX_DWB_PIPES; j++) {\n\t\t\tif (context->res_ctx.pipe_ctx[i].stream->writeback_info[j].wb_enabled == false)\n\t\t\t\tcontinue;\n\n\t\t\t//wb_arb_params = &context->res_ctx.pipe_ctx[i].stream->writeback_info[j].mcif_arb_params;\n\t\t\twb_arb_params = &context->bw_ctx.bw.dcn.bw_writeback.mcif_wb_arb[dwb_pipe];\n\n\t\t\tif (context->res_ctx.pipe_ctx[i].stream->writeback_info[j].dwb_params.out_format == dwb_scaler_mode_yuv420) {\n\t\t\t\tif (context->res_ctx.pipe_ctx[i].stream->writeback_info[j].dwb_params.output_depth == DWB_OUTPUT_PIXEL_DEPTH_8BPC)\n\t\t\t\t\twbif_mode = PLANAR_420_8BPC;\n\t\t\t\telse\n\t\t\t\t\twbif_mode = PLANAR_420_10BPC;\n\t\t\t} else\n\t\t\t\twbif_mode = PACKED_444;\n\n\t\t\tfor (k = 0; k < sizeof(wb_arb_params->cli_watermark)/sizeof(wb_arb_params->cli_watermark[0]); k++) {\n\t\t\t\twb_arb_params->cli_watermark[k] = get_wm_writeback_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\t\t\twb_arb_params->pstate_watermark[k] = get_wm_writeback_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\t\t\t}\n\t\t\twb_arb_params->time_per_pixel = 16.0 / context->res_ctx.pipe_ctx[i].stream->phy_pix_clk; /* 4 bit fraction, ms */\n\t\t\twb_arb_params->slice_lines = 32;\n\t\t\twb_arb_params->arbitration_slice = 2;\n\t\t\twb_arb_params->max_scaled_time = dcn20_calc_max_scaled_time(wb_arb_params->time_per_pixel,\n\t\t\t\twbif_mode,\n\t\t\t\twb_arb_params->cli_watermark[0]); /* assume 4 watermark sets have the same value */\n\n\t\t\tdwb_pipe++;\n\n\t\t\tif (dwb_pipe >= MAX_DWB_PIPES)\n\t\t\t\treturn;\n\t\t}\n\t\tif (dwb_pipe >= MAX_DWB_PIPES)\n\t\t\treturn;\n\t}\n}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\nstatic bool dcn20_validate_dsc(struct dc *dc, struct dc_state *new_ctx)\n{\n\tint i;\n\n\t/* Validate DSC config, dsc count validation is already done */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];\n\t\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\t\tstruct dsc_config dsc_cfg;\n\t\tstruct pipe_ctx *odm_pipe;\n\t\tint opp_cnt = 1;\n\n\t\tfor (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)\n\t\t\topp_cnt++;\n\n\t\t/* Only need to validate top pipe */\n\t\tif (pipe_ctx->top_pipe || pipe_ctx->prev_odm_pipe || !stream || !stream->timing.flags.DSC)\n\t\t\tcontinue;\n\n\t\tdsc_cfg.pic_width = (stream->timing.h_addressable + stream->timing.h_border_left\n\t\t\t\t+ stream->timing.h_border_right) / opp_cnt;\n\t\tdsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top\n\t\t\t\t+ stream->timing.v_border_bottom;\n\t\tdsc_cfg.pixel_encoding = stream->timing.pixel_encoding;\n\t\tdsc_cfg.color_depth = stream->timing.display_color_depth;\n\t\tdsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;\n\t\tdsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;\n\n\t\tif (!pipe_ctx->stream_res.dsc->funcs->dsc_validate_stream(pipe_ctx->stream_res.dsc, &dsc_cfg))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n#endif\n\nstatic struct pipe_ctx *dcn20_find_secondary_pipe(struct dc *dc,\n\t\tstruct resource_context *res_ctx,\n\t\tconst struct resource_pool *pool,\n\t\tconst struct pipe_ctx *primary_pipe)\n{\n\tstruct pipe_ctx *secondary_pipe = NULL;\n\n\tif (dc && primary_pipe) {\n\t\tint j;\n\t\tint preferred_pipe_idx = 0;\n\n\t\t/* first check the prev dc state:\n\t\t * if this primary pipe has a bottom pipe in prev. state\n\t\t * and if the bottom pipe is still available (which it should be),\n\t\t * pick that pipe as secondary\n\t\t * Same logic applies for ODM pipes. Since mpo is not allowed with odm\n\t\t * check in else case.\n\t\t */\n\t\tif (dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].bottom_pipe) {\n\t\t\tpreferred_pipe_idx = dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].bottom_pipe->pipe_idx;\n\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t}\n\t\t} else if (dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].next_odm_pipe) {\n\t\t\tpreferred_pipe_idx = dc->current_state->res_ctx.pipe_ctx[primary_pipe->pipe_idx].next_odm_pipe->pipe_idx;\n\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if this primary pipe does not have a bottom pipe in prev. state\n\t\t * start backward and find a pipe that did not used to be a bottom pipe in\n\t\t * prev. dc state. This way we make sure we keep the same assignment as\n\t\t * last state and will not have to reprogram every pipe\n\t\t */\n\t\tif (secondary_pipe == NULL) {\n\t\t\tfor (j = dc->res_pool->pipe_count - 1; j >= 0; j--) {\n\t\t\t\tif (dc->current_state->res_ctx.pipe_ctx[j].top_pipe == NULL) {\n\t\t\t\t\tpreferred_pipe_idx = j;\n\n\t\t\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We should never hit this assert unless assignments are shuffled around\n\t\t * if this happens we will prob. hit a vsync tdr\n\t\t */\n\t\tASSERT(secondary_pipe);\n\t\t/*\n\t\t * search backwards for the second pipe to keep pipe\n\t\t * assignment more consistent\n\t\t */\n\t\tif (secondary_pipe == NULL) {\n\t\t\tfor (j = dc->res_pool->pipe_count - 1; j >= 0; j--) {\n\t\t\t\tpreferred_pipe_idx = j;\n\n\t\t\t\tif (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {\n\t\t\t\t\tsecondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];\n\t\t\t\t\tsecondary_pipe->pipe_idx = preferred_pipe_idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn secondary_pipe;\n}\n\nbool dcn20_fast_validate_bw(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint *pipe_cnt_out,\n\t\tint *pipe_split_from,\n\t\tint *vlevel_out)\n{\n\tbool out = false;\n\n\tint pipe_cnt, i, pipe_idx, vlevel, vlevel_unsplit;\n\tbool odm_capable = context->bw_ctx.dml.ip.odm_capable;\n\tbool force_split = false;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tbool failed_non_odm_dsc = false;\n#endif\n\tint split_threshold = dc->res_pool->pipe_count / 2;\n\tbool avoid_split = dc->debug.pipe_split_policy != MPC_SPLIT_DYNAMIC;\n\n\n\tASSERT(pipes);\n\tif (!pipes)\n\t\treturn false;\n\n\t/* merge previously split odm pipes since mode support needs to make the decision */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *odm_pipe = pipe->next_odm_pipe;\n\n\t\tif (pipe->prev_odm_pipe)\n\t\t\tcontinue;\n\n\t\tpipe->next_odm_pipe = NULL;\n\t\twhile (odm_pipe) {\n\t\t\tstruct pipe_ctx *next_odm_pipe = odm_pipe->next_odm_pipe;\n\n\t\t\todm_pipe->plane_state = NULL;\n\t\t\todm_pipe->stream = NULL;\n\t\t\todm_pipe->top_pipe = NULL;\n\t\t\todm_pipe->bottom_pipe = NULL;\n\t\t\todm_pipe->prev_odm_pipe = NULL;\n\t\t\todm_pipe->next_odm_pipe = NULL;\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t\t\tif (odm_pipe->stream_res.dsc)\n\t\t\t\trelease_dsc(&context->res_ctx, dc->res_pool, &odm_pipe->stream_res.dsc);\n#endif\n\t\t\t/* Clear plane_res and stream_res */\n\t\t\tmemset(&odm_pipe->plane_res, 0, sizeof(odm_pipe->plane_res));\n\t\t\tmemset(&odm_pipe->stream_res, 0, sizeof(odm_pipe->stream_res));\n\t\t\todm_pipe = next_odm_pipe;\n\t\t}\n\t\tif (pipe->plane_state)\n\t\t\tresource_build_scaling_params(pipe);\n\t}\n\n\t/* merge previously mpc split pipes since mode support needs to make the decision */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;\n\n\t\tif (!hsplit_pipe || hsplit_pipe->plane_state != pipe->plane_state)\n\t\t\tcontinue;\n\n\t\tpipe->bottom_pipe = hsplit_pipe->bottom_pipe;\n\t\tif (hsplit_pipe->bottom_pipe)\n\t\t\thsplit_pipe->bottom_pipe->top_pipe = pipe;\n\t\thsplit_pipe->plane_state = NULL;\n\t\thsplit_pipe->stream = NULL;\n\t\thsplit_pipe->top_pipe = NULL;\n\t\thsplit_pipe->bottom_pipe = NULL;\n\n\t\t/* Clear plane_res and stream_res */\n\t\tmemset(&hsplit_pipe->plane_res, 0, sizeof(hsplit_pipe->plane_res));\n\t\tmemset(&hsplit_pipe->stream_res, 0, sizeof(hsplit_pipe->stream_res));\n\t\tif (pipe->plane_state)\n\t\t\tresource_build_scaling_params(pipe);\n\t}\n\n\tif (dc->res_pool->funcs->populate_dml_pipes)\n\t\tpipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc,\n\t\t\t&context->res_ctx, pipes);\n\telse\n\t\tpipe_cnt = dcn20_populate_dml_pipes_from_context(dc,\n\t\t\t&context->res_ctx, pipes);\n\n\t*pipe_cnt_out = pipe_cnt;\n\n\tif (!pipe_cnt) {\n\t\tout = true;\n\t\tgoto validate_out;\n\t}\n\n\tcontext->bw_ctx.dml.ip.odm_capable = 0;\n\n\tvlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\tcontext->bw_ctx.dml.ip.odm_capable = odm_capable;\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t/* 1 dsc per stream dsc validation */\n\tif (vlevel <= context->bw_ctx.dml.soc.num_states)\n\t\tif (!dcn20_validate_dsc(dc, context)) {\n\t\t\tfailed_non_odm_dsc = true;\n\t\t\tvlevel = context->bw_ctx.dml.soc.num_states + 1;\n\t\t}\n#endif\n\n\tif (vlevel > context->bw_ctx.dml.soc.num_states && odm_capable)\n\t\tvlevel = dml_get_voltage_level(&context->bw_ctx.dml, pipes, pipe_cnt);\n\n\tif (vlevel > context->bw_ctx.dml.soc.num_states)\n\t\tgoto validate_fail;\n\n\tif ((context->stream_count > split_threshold && dc->current_state->stream_count <= split_threshold)\n\t\t|| (context->stream_count <= split_threshold && dc->current_state->stream_count > split_threshold))\n\t\tcontext->commit_hints.full_update_needed = true;\n\n\t/*initialize pipe_just_split_from to invalid idx*/\n\tfor (i = 0; i < MAX_PIPES; i++)\n\t\tpipe_split_from[i] = -1;\n\n\t/* Single display only conditionals get set here */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tbool exit_loop = false;\n\n\t\tif (!pipe->stream || pipe->top_pipe)\n\t\t\tcontinue;\n\n\t\tif (dc->debug.force_single_disp_pipe_split) {\n\t\t\tif (!force_split)\n\t\t\t\tforce_split = true;\n\t\t\telse {\n\t\t\t\tforce_split = false;\n\t\t\t\texit_loop = true;\n\t\t\t}\n\t\t}\n\t\tif (dc->debug.pipe_split_policy == MPC_SPLIT_AVOID_MULT_DISP) {\n\t\t\tif (avoid_split)\n\t\t\t\tavoid_split = false;\n\t\t\telse {\n\t\t\t\tavoid_split = true;\n\t\t\t\texit_loop = true;\n\t\t\t}\n\t\t}\n\t\tif (exit_loop)\n\t\t\tbreak;\n\t}\n\n\tif (context->stream_count > split_threshold)\n\t\tavoid_split = true;\n\n\tvlevel_unsplit = vlevel;\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\tfor (; vlevel_unsplit <= context->bw_ctx.dml.soc.num_states; vlevel_unsplit++)\n\t\t\tif (context->bw_ctx.dml.vba.NoOfDPP[vlevel_unsplit][0][pipe_idx] == 1)\n\t\t\t\tbreak;\n\t\tpipe_idx++;\n\t}\n\n\tfor (i = 0, pipe_idx = -1; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\tstruct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;\n\t\tbool need_split = true;\n\t\tbool need_split3d;\n\n\t\tif (!pipe->stream || pipe_split_from[i] >= 0)\n\t\t\tcontinue;\n\n\t\tpipe_idx++;\n\n\t\tif (dc->debug.force_odm_combine & (1 << pipe->stream_res.tg->inst)) {\n\t\t\tforce_split = true;\n\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx] = true;\n\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_idx] = true;\n\t\t}\n\t\tif (force_split && context->bw_ctx.dml.vba.NoOfDPP[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] == 1)\n\t\t\tcontext->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] /= 2;\n\t\tif (!pipe->top_pipe && !pipe->plane_state && context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx]) {\n\t\t\thsplit_pipe = dcn20_find_secondary_pipe(dc, &context->res_ctx, dc->res_pool, pipe);\n\t\t\tASSERT(hsplit_pipe);\n\t\t\tif (!dcn20_split_stream_for_odm(\n\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\tpipe, hsplit_pipe))\n\t\t\t\tgoto validate_fail;\n\t\t\tpipe_split_from[hsplit_pipe->pipe_idx] = pipe_idx;\n\t\t\tdcn20_build_mapped_resource(dc, context, pipe->stream);\n\t\t}\n\n\t\tif (!pipe->plane_state)\n\t\t\tcontinue;\n\t\t/* Skip 2nd half of already split pipe */\n\t\tif (pipe->top_pipe && pipe->plane_state == pipe->top_pipe->plane_state)\n\t\t\tcontinue;\n\n\t\tneed_split3d = ((pipe->stream->view_format ==\n\t\t\t\tVIEW_3D_FORMAT_SIDE_BY_SIDE ||\n\t\t\t\tpipe->stream->view_format ==\n\t\t\t\tVIEW_3D_FORMAT_TOP_AND_BOTTOM) &&\n\t\t\t\t(pipe->stream->timing.timing_3d_format ==\n\t\t\t\tTIMING_3D_FORMAT_TOP_AND_BOTTOM ||\n\t\t\t\t pipe->stream->timing.timing_3d_format ==\n\t\t\t\tTIMING_3D_FORMAT_SIDE_BY_SIDE));\n\n\t\tif (avoid_split && vlevel_unsplit <= context->bw_ctx.dml.soc.num_states && !force_split && !need_split3d) {\n\t\t\tneed_split = false;\n\t\t\tvlevel = vlevel_unsplit;\n\t\t\tcontext->bw_ctx.dml.vba.maxMpcComb = 0;\n\t\t} else\n\t\t\tneed_split = context->bw_ctx.dml.vba.NoOfDPP[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] == 2;\n\n\t\t/* We do not support mpo + odm at the moment */\n\t\tif (hsplit_pipe && hsplit_pipe->plane_state != pipe->plane_state\n\t\t\t\t&& context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx])\n\t\t\tgoto validate_fail;\n\n\t\tif (need_split3d || need_split || force_split) {\n\t\t\tif (!hsplit_pipe || hsplit_pipe->plane_state != pipe->plane_state) {\n\t\t\t\t/* pipe not split previously needs split */\n\t\t\t\thsplit_pipe = dcn20_find_secondary_pipe(dc, &context->res_ctx, dc->res_pool, pipe);\n\t\t\t\tASSERT(hsplit_pipe || force_split);\n\t\t\t\tif (!hsplit_pipe)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_idx]) {\n\t\t\t\t\tif (!dcn20_split_stream_for_odm(\n\t\t\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\t\t\tpipe, hsplit_pipe))\n\t\t\t\t\t\tgoto validate_fail;\n\t\t\t\t} else\n\t\t\t\t\tdcn20_split_stream_for_mpc(\n\t\t\t\t\t\t&context->res_ctx, dc->res_pool,\n\t\t\t\t\t\tpipe, hsplit_pipe);\n\t\t\t\tpipe_split_from[hsplit_pipe->pipe_idx] = pipe_idx;\n\t\t\t}\n\t\t} else if (hsplit_pipe && hsplit_pipe->plane_state == pipe->plane_state) {\n\t\t\t/* merge should already have been done */\n\t\t\tASSERT(0);\n\t\t}\n\t}\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\t/* Actual dsc count per stream dsc validation*/\n\tif (failed_non_odm_dsc && !dcn20_validate_dsc(dc, context)) {\n\t\tcontext->bw_ctx.dml.vba.ValidationStatus[context->bw_ctx.dml.vba.soc.num_states] =\n\t\t\t\tDML_FAIL_DSC_VALIDATION_FAILURE;\n\t\tgoto validate_fail;\n\t}\n#endif\n\n\t*vlevel_out = vlevel;\n\n\tout = true;\n\tgoto validate_out;\n\nvalidate_fail:\n\tout = false;\n\nvalidate_out:\n\treturn out;\n}\n\nvoid dcn20_calculate_wm(\n\t\tstruct dc *dc, struct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint *out_pipe_cnt,\n\t\tint *pipe_split_from,\n\t\tint vlevel)\n{\n\tint pipe_cnt, i, pipe_idx;\n\n\tfor (i = 0, pipe_idx = 0, pipe_cnt = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tpipes[pipe_cnt].clks_cfg.refclk_mhz = dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000.0;\n\t\tpipes[pipe_cnt].clks_cfg.dispclk_mhz = context->bw_ctx.dml.vba.RequiredDISPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb];\n\n\t\tif (pipe_split_from[i] < 0) {\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz =\n\t\t\t\t\tcontext->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx];\n\t\t\tif (context->bw_ctx.dml.vba.BlendingAndTiming[pipe_idx] == pipe_idx)\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine =\n\t\t\t\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_idx];\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine = 0;\n\t\t\tpipe_idx++;\n\t\t} else {\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz =\n\t\t\t\t\tcontext->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_split_from[i]];\n\t\t\tif (context->bw_ctx.dml.vba.BlendingAndTiming[pipe_split_from[i]] == pipe_split_from[i])\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine =\n\t\t\t\t\t\tcontext->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_split_from[i]];\n\t\t\telse\n\t\t\t\tpipes[pipe_cnt].pipe.dest.odm_combine = 0;\n\t\t}\n\n\t\tif (dc->config.forced_clocks) {\n\t\t\tpipes[pipe_cnt].clks_cfg.dispclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dispclk_mhz;\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz = context->bw_ctx.dml.soc.clock_limits[0].dppclk_mhz;\n\t\t}\n\t\tif (dc->debug.min_disp_clk_khz > pipes[pipe_cnt].clks_cfg.dispclk_mhz * 1000)\n\t\t\tpipes[pipe_cnt].clks_cfg.dispclk_mhz = dc->debug.min_disp_clk_khz / 1000.0;\n\t\tif (dc->debug.min_dpp_clk_khz > pipes[pipe_cnt].clks_cfg.dppclk_mhz * 1000)\n\t\t\tpipes[pipe_cnt].clks_cfg.dppclk_mhz = dc->debug.min_dpp_clk_khz / 1000.0;\n\n\t\tpipe_cnt++;\n\t}\n\n\tif (pipe_cnt != pipe_idx) {\n\t\tif (dc->res_pool->funcs->populate_dml_pipes)\n\t\t\tpipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc,\n\t\t\t\t&context->res_ctx, pipes);\n\t\telse\n\t\t\tpipe_cnt = dcn20_populate_dml_pipes_from_context(dc,\n\t\t\t\t&context->res_ctx, pipes);\n\t}\n\n\t*out_pipe_cnt = pipe_cnt;\n\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].dcfclk_mhz;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].socclk_mhz;\n\n\t/* only pipe 0 is read for voltage and dcf/soc clocks */\n\tif (vlevel < 1) {\n\t\tpipes[0].clks_cfg.voltage = 1;\n\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[1].dcfclk_mhz;\n\t\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[1].socclk_mhz;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.b.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.b.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tif (vlevel < 2) {\n\t\tpipes[0].clks_cfg.voltage = 2;\n\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].dcfclk_mhz;\n\t\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].socclk_mhz;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.c.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.c.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tif (vlevel < 3) {\n\t\tpipes[0].clks_cfg.voltage = 3;\n\t\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].dcfclk_mhz;\n\t\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[2].socclk_mhz;\n\t}\n\tcontext->bw_ctx.bw.dcn.watermarks.d.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.d.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\n\tpipes[0].clks_cfg.voltage = vlevel;\n\tpipes[0].clks_cfg.dcfclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].dcfclk_mhz;\n\tpipes[0].clks_cfg.socclk_mhz = context->bw_ctx.dml.soc.clock_limits[vlevel].socclk_mhz;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.urgent_ns = get_wm_urgent(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns = get_wm_stutter_enter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.cstate_exit_ns = get_wm_stutter_exit(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns = get_wm_dram_clock_change(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n\tcontext->bw_ctx.bw.dcn.watermarks.a.pte_meta_urgent_ns = get_wm_memory_trip(&context->bw_ctx.dml, pipes, pipe_cnt) * 1000;\n}\n\nvoid dcn20_calculate_dlg_params(\n\t\tstruct dc *dc, struct dc_state *context,\n\t\tdisplay_e2e_pipe_params_st *pipes,\n\t\tint pipe_cnt,\n\t\tint vlevel)\n{\n\tint i, j, pipe_idx, pipe_idx_unsplit;\n\tbool visited[MAX_PIPES] = { 0 };\n\n\t/* Writeback MCIF_WB arbitration parameters */\n\tdc->res_pool->funcs->set_mcif_arb_params(dc, context, pipes, pipe_cnt);\n\n\tcontext->bw_ctx.bw.dcn.clk.dispclk_khz = context->bw_ctx.dml.vba.DISPCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.dcfclk_khz = context->bw_ctx.dml.vba.DCFCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.socclk_khz = context->bw_ctx.dml.vba.SOCCLK * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.dramclk_khz = context->bw_ctx.dml.vba.DRAMSpeed * 1000 / 16;\n\tcontext->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz = context->bw_ctx.dml.vba.DCFCLKDeepSleep * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.fclk_khz = 0;\n\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support =\n\t\tcontext->bw_ctx.dml.vba.DRAMClockChangeSupport[vlevel][context->bw_ctx.dml.vba.maxMpcComb]\n\t\t\t\t\t\t\t!= dm_dram_clock_change_unsupported;\n\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = 0;\n\n\t/*\n\t * An artifact of dml pipe split/odm is that pipes get merged back together for\n\t * calculation. Therefore we need to only extract for first pipe in ascending index order\n\t * and copy into the other split half.\n\t */\n\tfor (i = 0, pipe_idx = 0, pipe_idx_unsplit = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tif (!visited[pipe_idx]) {\n\t\t\tdisplay_pipe_source_params_st *src = &pipes[pipe_idx_unsplit].pipe.src;\n\t\t\tdisplay_pipe_dest_params_st *dst = &pipes[pipe_idx_unsplit].pipe.dest;\n\n\t\t\tdst->vstartup_start = context->bw_ctx.dml.vba.VStartup[pipe_idx_unsplit];\n\t\t\tdst->vupdate_offset = context->bw_ctx.dml.vba.VUpdateOffsetPix[pipe_idx_unsplit];\n\t\t\tdst->vupdate_width = context->bw_ctx.dml.vba.VUpdateWidthPix[pipe_idx_unsplit];\n\t\t\tdst->vready_offset = context->bw_ctx.dml.vba.VReadyOffsetPix[pipe_idx_unsplit];\n\t\t\t/*\n\t\t\t * j iterates inside pipes array, unlike i which iterates inside\n\t\t\t * pipe_ctx array\n\t\t\t */\n\t\t\tif (src->is_hsplit)\n\t\t\t\tfor (j = pipe_idx + 1; j < pipe_cnt; j++) {\n\t\t\t\t\tdisplay_pipe_source_params_st *src_j = &pipes[j].pipe.src;\n\t\t\t\t\tdisplay_pipe_dest_params_st *dst_j = &pipes[j].pipe.dest;\n\n\t\t\t\t\tif (src_j->is_hsplit && !visited[j]\n\t\t\t\t\t\t\t&& src->hsplit_grp == src_j->hsplit_grp) {\n\t\t\t\t\t\tdst_j->vstartup_start = context->bw_ctx.dml.vba.VStartup[pipe_idx_unsplit];\n\t\t\t\t\t\tdst_j->vupdate_offset = context->bw_ctx.dml.vba.VUpdateOffsetPix[pipe_idx_unsplit];\n\t\t\t\t\t\tdst_j->vupdate_width = context->bw_ctx.dml.vba.VUpdateWidthPix[pipe_idx_unsplit];\n\t\t\t\t\t\tdst_j->vready_offset = context->bw_ctx.dml.vba.VReadyOffsetPix[pipe_idx_unsplit];\n\t\t\t\t\t\tvisited[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tvisited[pipe_idx] = true;\n\t\t\tpipe_idx_unsplit++;\n\t\t}\n\t\tpipe_idx++;\n\t}\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\t\tif (context->bw_ctx.bw.dcn.clk.dppclk_khz < pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000)\n\t\t\tcontext->bw_ctx.bw.dcn.clk.dppclk_khz = pipes[pipe_idx].clks_cfg.dppclk_mhz * 1000;\n\t\tcontext->res_ctx.pipe_ctx[i].plane_res.bw.dppclk_khz =\n\t\t\t\t\t\tpipes[pipe_idx].clks_cfg.dppclk_mhz * 1000;\n\t\tASSERT(visited[pipe_idx]);\n\t\tcontext->res_ctx.pipe_ctx[i].pipe_dlg_param = pipes[pipe_idx].pipe.dest;\n\t\tpipe_idx++;\n\t}\n\t/*save a original dppclock copy*/\n\tcontext->bw_ctx.bw.dcn.clk.bw_dppclk_khz = context->bw_ctx.bw.dcn.clk.dppclk_khz;\n\tcontext->bw_ctx.bw.dcn.clk.bw_dispclk_khz = context->bw_ctx.bw.dcn.clk.dispclk_khz;\n\tcontext->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz = context->bw_ctx.dml.soc.clock_limits[vlevel].dppclk_mhz * 1000;\n\tcontext->bw_ctx.bw.dcn.clk.max_supported_dispclk_khz = context->bw_ctx.dml.soc.clock_limits[vlevel].dispclk_mhz * 1000;\n\n\tfor (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tbool cstate_en = context->bw_ctx.dml.vba.PrefetchMode[vlevel][context->bw_ctx.dml.vba.maxMpcComb] != 2;\n\n\t\tif (!context->res_ctx.pipe_ctx[i].stream)\n\t\t\tcontinue;\n\n\t\tcontext->bw_ctx.dml.funcs.rq_dlg_get_dlg_reg(&context->bw_ctx.dml,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].dlg_regs,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].ttu_regs,\n\t\t\t\tpipes,\n\t\t\t\tpipe_cnt,\n\t\t\t\tpipe_idx,\n\t\t\t\tcstate_en,\n\t\t\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support,\n\t\t\t\tfalse, false, false);\n\n\t\tcontext->bw_ctx.dml.funcs.rq_dlg_get_rq_reg(&context->bw_ctx.dml,\n\t\t\t\t&context->res_ctx.pipe_ctx[i].rq_regs,\n\t\t\t\tpipes[pipe_idx].pipe);\n\t\tpipe_idx++;\n\t}\n}\n\nstatic bool dcn20_validate_bandwidth_internal(struct dc *dc, struct dc_state *context,\n\t\tbool fast_validate)\n{\n\tbool out = false;\n\n\tBW_VAL_TRACE_SETUP();\n\n\tint vlevel = 0;\n\tint pipe_split_from[MAX_PIPES];\n\tint pipe_cnt = 0;\n\tdisplay_e2e_pipe_params_st *pipes = kzalloc(dc->res_pool->pipe_count * sizeof(display_e2e_pipe_params_st), GFP_KERNEL);\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tBW_VAL_TRACE_COUNT();\n\n\tout = dcn20_fast_validate_bw(dc, context, pipes, &pipe_cnt, pipe_split_from, &vlevel);\n\n\tif (pipe_cnt == 0)\n\t\tgoto validate_out;\n\n\tif (!out)\n\t\tgoto validate_fail;\n\n\tBW_VAL_TRACE_END_VOLTAGE_LEVEL();\n\n\tif (fast_validate) {\n\t\tBW_VAL_TRACE_SKIP(fast);\n\t\tgoto validate_out;\n\t}\n\n\tdcn20_calculate_wm(dc, context, pipes, &pipe_cnt, pipe_split_from, vlevel);\n\tdcn20_calculate_dlg_params(dc, context, pipes, pipe_cnt, vlevel);\n\n\tBW_VAL_TRACE_END_WATERMARKS();\n\n\tgoto validate_out;\n\nvalidate_fail:\n\tDC_LOG_WARNING(\"Mode Validation Warning: %s failed validation.\\n\",\n\t\tdml_get_status_message(context->bw_ctx.dml.vba.ValidationStatus[context->bw_ctx.dml.vba.soc.num_states]));\n\n\tBW_VAL_TRACE_SKIP(fail);\n\tout = false;\n\nvalidate_out:\n\tkfree(pipes);\n\n\tBW_VAL_TRACE_FINISH();\n\n\treturn out;\n}\n\n\nbool dcn20_validate_bandwidth(struct dc *dc, struct dc_state *context,\n\t\tbool fast_validate)\n{\n\tbool voltage_supported = false;\n\tbool full_pstate_supported = false;\n\tbool dummy_pstate_supported = false;\n\tdouble p_state_latency_us = context->bw_ctx.dml.soc.dram_clock_change_latency_us;\n\n\tif (fast_validate)\n\t\treturn dcn20_validate_bandwidth_internal(dc, context, true);\n\n\n\t// Best case, we support full UCLK switch latency\n\tvoltage_supported = dcn20_validate_bandwidth_internal(dc, context, false);\n\tfull_pstate_supported = context->bw_ctx.bw.dcn.clk.p_state_change_support;\n\n\tif (context->bw_ctx.dml.soc.dummy_pstate_latency_us == 0 ||\n\t\t(voltage_supported && full_pstate_supported)) {\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = true;\n\t\tgoto restore_dml_state;\n\t}\n\n\t// Fallback: Try to only support G6 temperature read latency\n\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = context->bw_ctx.dml.soc.dummy_pstate_latency_us;\n\n\tvoltage_supported = dcn20_validate_bandwidth_internal(dc, context, false);\n\tdummy_pstate_supported = context->bw_ctx.bw.dcn.clk.p_state_change_support;\n\n\tif (voltage_supported && dummy_pstate_supported) {\n\t\tcontext->bw_ctx.bw.dcn.clk.p_state_change_support = false;\n\t\tgoto restore_dml_state;\n\t}\n\n\t// ERROR: fallback is supposed to always work.\n\tASSERT(false);\n\nrestore_dml_state:\n\tmemcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));\n\tcontext->bw_ctx.dml.soc.dram_clock_change_latency_us = p_state_latency_us;\n\n\treturn voltage_supported;\n}\n\nstruct pipe_ctx *dcn20_acquire_idle_pipe_for_layer(\n\t\tstruct dc_state *state,\n\t\tconst struct resource_pool *pool,\n\t\tstruct dc_stream_state *stream)\n{\n\tstruct resource_context *res_ctx = &state->res_ctx;\n\tstruct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);\n\tstruct pipe_ctx *idle_pipe = find_idle_secondary_pipe(res_ctx, pool, head_pipe);\n\n\tif (!head_pipe)\n\t\tASSERT(0);\n\n\tif (!idle_pipe)\n\t\treturn NULL;\n\n\tidle_pipe->stream = head_pipe->stream;\n\tidle_pipe->stream_res.tg = head_pipe->stream_res.tg;\n\tidle_pipe->stream_res.opp = head_pipe->stream_res.opp;\n\n\tidle_pipe->plane_res.hubp = pool->hubps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.ipp = pool->ipps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.dpp = pool->dpps[idle_pipe->pipe_idx];\n\tidle_pipe->plane_res.mpcc_inst = pool->dpps[idle_pipe->pipe_idx]->inst;\n\n\treturn idle_pipe;\n}\n\nbool dcn20_get_dcc_compression_cap(const struct dc *dc,\n\t\tconst struct dc_dcc_surface_param *input,\n\t\tstruct dc_surface_dcc_cap *output)\n{\n\treturn dc->res_pool->hubbub->funcs->get_dcc_compression_cap(\n\t\t\tdc->res_pool->hubbub,\n\t\t\tinput,\n\t\t\toutput);\n}\n\nstatic void dcn20_destroy_resource_pool(struct resource_pool **pool)\n{\n\tstruct dcn20_resource_pool *dcn20_pool = TO_DCN20_RES_POOL(*pool);\n\n\tdestruct(dcn20_pool);\n\tkfree(dcn20_pool);\n\t*pool = NULL;\n}\n\n\nstatic struct dc_cap_funcs cap_funcs = {\n\t.get_dcc_compression_cap = dcn20_get_dcc_compression_cap\n};\n\n\nenum dc_status dcn20_get_default_swizzle_mode(struct dc_plane_state *plane_state)\n{\n\tenum dc_status result = DC_OK;\n\n\tenum surface_pixel_format surf_pix_format = plane_state->format;\n\tunsigned int bpp = resource_pixel_format_to_bpp(surf_pix_format);\n\n\tenum swizzle_mode_values swizzle = DC_SW_LINEAR;\n\n\tif (bpp == 64)\n\t\tswizzle = DC_SW_64KB_D;\n\telse\n\t\tswizzle = DC_SW_64KB_S;\n\n\tplane_state->tiling_info.gfx9.swizzle = swizzle;\n\treturn result;\n}\n\nstatic struct resource_funcs dcn20_res_pool_funcs = {\n\t.destroy = dcn20_destroy_resource_pool,\n\t.link_enc_create = dcn20_link_encoder_create,\n\t.validate_bandwidth = dcn20_validate_bandwidth,\n\t.acquire_idle_pipe_for_layer = dcn20_acquire_idle_pipe_for_layer,\n\t.add_stream_to_ctx = dcn20_add_stream_to_ctx,\n\t.remove_stream_from_ctx = dcn20_remove_stream_from_ctx,\n\t.populate_dml_writeback_from_context = dcn20_populate_dml_writeback_from_context,\n\t.get_default_swizzle_mode = dcn20_get_default_swizzle_mode,\n\t.set_mcif_arb_params = dcn20_set_mcif_arb_params,\n\t.find_first_free_match_stream_enc_for_link = dcn10_find_first_free_match_stream_enc_for_link\n};\n\nbool dcn20_dwbc_create(struct dc_context *ctx, struct resource_pool *pool)\n{\n\tint i;\n\tuint32_t pipe_count = pool->res_cap->num_dwb;\n\n\tASSERT(pipe_count > 0);\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tstruct dcn20_dwbc *dwbc20 = kzalloc(sizeof(struct dcn20_dwbc),\n\t\t\t\t\t\t    GFP_KERNEL);\n\n\t\tif (!dwbc20) {\n\t\t\tdm_error(\"DC: failed to create dwbc20!\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tdcn20_dwbc_construct(dwbc20, ctx,\n\t\t\t\t&dwbc20_regs[i],\n\t\t\t\t&dwbc20_shift,\n\t\t\t\t&dwbc20_mask,\n\t\t\t\ti);\n\t\tpool->dwbc[i] = &dwbc20->base;\n\t}\n\treturn true;\n}\n\nbool dcn20_mmhubbub_create(struct dc_context *ctx, struct resource_pool *pool)\n{\n\tint i;\n\tuint32_t pipe_count = pool->res_cap->num_dwb;\n\n\tASSERT(pipe_count > 0);\n\n\tfor (i = 0; i < pipe_count; i++) {\n\t\tstruct dcn20_mmhubbub *mcif_wb20 = kzalloc(sizeof(struct dcn20_mmhubbub),\n\t\t\t\t\t\t    GFP_KERNEL);\n\n\t\tif (!mcif_wb20) {\n\t\t\tdm_error(\"DC: failed to create mcif_wb20!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tdcn20_mmhubbub_construct(mcif_wb20, ctx,\n\t\t\t\t&mcif_wb20_regs[i],\n\t\t\t\t&mcif_wb20_shift,\n\t\t\t\t&mcif_wb20_mask,\n\t\t\t\ti);\n\n\t\tpool->mcif_wb[i] = &mcif_wb20->base;\n\t}\n\treturn true;\n}\n\nstruct pp_smu_funcs *dcn20_pp_smu_create(struct dc_context *ctx)\n{\n\tstruct pp_smu_funcs *pp_smu = kzalloc(sizeof(*pp_smu), GFP_KERNEL);\n\n\tif (!pp_smu)\n\t\treturn pp_smu;\n\n\tdm_pp_get_funcs(ctx, pp_smu);\n\n\tif (pp_smu->ctx.ver != PP_SMU_VER_NV)\n\t\tpp_smu = memset(pp_smu, 0, sizeof(struct pp_smu_funcs));\n\n\treturn pp_smu;\n}\n\nvoid dcn20_pp_smu_destroy(struct pp_smu_funcs **pp_smu)\n{\n\tif (pp_smu && *pp_smu) {\n\t\tkfree(*pp_smu);\n\t\t*pp_smu = NULL;\n\t}\n}\n\nstatic void cap_soc_clocks(\n\t\tstruct _vcs_dpi_soc_bounding_box_st *bb,\n\t\tstruct pp_smu_nv_clock_table max_clocks)\n{\n\tint i;\n\n\t// First pass - cap all clocks higher than the reported max\n\tfor (i = 0; i < bb->num_states; i++) {\n\t\tif ((bb->clock_limits[i].dcfclk_mhz > (max_clocks.dcfClockInKhz / 1000))\n\t\t\t\t&& max_clocks.dcfClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dcfclk_mhz = (max_clocks.dcfClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dram_speed_mts > (max_clocks.uClockInKhz / 1000) * 16)\n\t\t\t\t\t\t&& max_clocks.uClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dram_speed_mts = (max_clocks.uClockInKhz / 1000) * 16;\n\n\t\tif ((bb->clock_limits[i].fabricclk_mhz > (max_clocks.fabricClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.fabricClockInKhz != 0)\n\t\t\tbb->clock_limits[i].fabricclk_mhz = (max_clocks.fabricClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dispclk_mhz > (max_clocks.displayClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.displayClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dispclk_mhz = (max_clocks.displayClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dppclk_mhz > (max_clocks.dppClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.dppClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dppclk_mhz = (max_clocks.dppClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].phyclk_mhz > (max_clocks.phyClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.phyClockInKhz != 0)\n\t\t\tbb->clock_limits[i].phyclk_mhz = (max_clocks.phyClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].socclk_mhz > (max_clocks.socClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.socClockInKhz != 0)\n\t\t\tbb->clock_limits[i].socclk_mhz = (max_clocks.socClockInKhz / 1000);\n\n\t\tif ((bb->clock_limits[i].dscclk_mhz > (max_clocks.dscClockInKhz / 1000))\n\t\t\t\t\t\t&& max_clocks.dscClockInKhz != 0)\n\t\t\tbb->clock_limits[i].dscclk_mhz = (max_clocks.dscClockInKhz / 1000);\n\t}\n\n\t// Second pass - remove all duplicate clock states\n\tfor (i = bb->num_states - 1; i > 1; i--) {\n\t\tbool duplicate = true;\n\n\t\tif (bb->clock_limits[i-1].dcfclk_mhz != bb->clock_limits[i].dcfclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dispclk_mhz != bb->clock_limits[i].dispclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dppclk_mhz != bb->clock_limits[i].dppclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dram_speed_mts != bb->clock_limits[i].dram_speed_mts)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].dscclk_mhz != bb->clock_limits[i].dscclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].fabricclk_mhz != bb->clock_limits[i].fabricclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].phyclk_mhz != bb->clock_limits[i].phyclk_mhz)\n\t\t\tduplicate = false;\n\t\tif (bb->clock_limits[i-1].socclk_mhz != bb->clock_limits[i].socclk_mhz)\n\t\t\tduplicate = false;\n\n\t\tif (duplicate)\n\t\t\tbb->num_states--;\n\t}\n}\n\nstatic void update_bounding_box(struct dc *dc, struct _vcs_dpi_soc_bounding_box_st *bb,\n\t\tstruct pp_smu_nv_clock_table *max_clocks, unsigned int *uclk_states, unsigned int num_states)\n{\n\tstruct _vcs_dpi_voltage_scaling_st calculated_states[MAX_CLOCK_LIMIT_STATES] = {0};\n\tint i;\n\tint num_calculated_states = 0;\n\tint min_dcfclk = 0;\n\n\tif (num_states == 0)\n\t\treturn;\n\n\tif (dc->bb_overrides.min_dcfclk_mhz > 0)\n\t\tmin_dcfclk = dc->bb_overrides.min_dcfclk_mhz;\n\telse\n\t\t// Accounting for SOC/DCF relationship, we can go as high as\n\t\t// 506Mhz in Vmin.  We need to code 507 since SMU will round down to 506.\n\t\tmin_dcfclk = 507;\n\n\tfor (i = 0; i < num_states; i++) {\n\t\tint min_fclk_required_by_uclk;\n\t\tcalculated_states[i].state = i;\n\t\tcalculated_states[i].dram_speed_mts = uclk_states[i] * 16 / 1000;\n\n\t\t// FCLK:UCLK ratio is 1.08\n\t\tmin_fclk_required_by_uclk = mul_u64_u32_shr(BIT_ULL(32) * 1080 / 1000000, uclk_states[i], 32);\n\n\t\tcalculated_states[i].fabricclk_mhz = (min_fclk_required_by_uclk < min_dcfclk) ?\n\t\t\t\tmin_dcfclk : min_fclk_required_by_uclk;\n\n\t\tcalculated_states[i].socclk_mhz = (calculated_states[i].fabricclk_mhz > max_clocks->socClockInKhz / 1000) ?\n\t\t\t\tmax_clocks->socClockInKhz / 1000 : calculated_states[i].fabricclk_mhz;\n\n\t\tcalculated_states[i].dcfclk_mhz = (calculated_states[i].fabricclk_mhz > max_clocks->dcfClockInKhz / 1000) ?\n\t\t\t\tmax_clocks->dcfClockInKhz / 1000 : calculated_states[i].fabricclk_mhz;\n\n\t\tcalculated_states[i].dispclk_mhz = max_clocks->displayClockInKhz / 1000;\n\t\tcalculated_states[i].dppclk_mhz = max_clocks->displayClockInKhz / 1000;\n\t\tcalculated_states[i].dscclk_mhz = max_clocks->displayClockInKhz / (1000 * 3);\n\n\t\tcalculated_states[i].phyclk_mhz = max_clocks->phyClockInKhz / 1000;\n\n\t\tnum_calculated_states++;\n\t}\n\n\tcalculated_states[num_calculated_states - 1].socclk_mhz = max_clocks->socClockInKhz / 1000;\n\tcalculated_states[num_calculated_states - 1].fabricclk_mhz = max_clocks->socClockInKhz / 1000;\n\tcalculated_states[num_calculated_states - 1].dcfclk_mhz = max_clocks->dcfClockInKhz / 1000;\n\n\tmemcpy(bb->clock_limits, calculated_states, sizeof(bb->clock_limits));\n\tbb->num_states = num_calculated_states;\n\n\t// Duplicate the last state, DML always an extra state identical to max state to work\n\tmemcpy(&bb->clock_limits[num_calculated_states], &bb->clock_limits[num_calculated_states - 1], sizeof(struct _vcs_dpi_voltage_scaling_st));\n\tbb->clock_limits[num_calculated_states].state = bb->num_states;\n}\n\nstatic void patch_bounding_box(struct dc *dc, struct _vcs_dpi_soc_bounding_box_st *bb)\n{\n\tkernel_fpu_begin();\n\tif ((int)(bb->sr_exit_time_us * 1000) != dc->bb_overrides.sr_exit_time_ns\n\t\t\t&& dc->bb_overrides.sr_exit_time_ns) {\n\t\tbb->sr_exit_time_us = dc->bb_overrides.sr_exit_time_ns / 1000.0;\n\t}\n\n\tif ((int)(bb->sr_enter_plus_exit_time_us * 1000)\n\t\t\t\t!= dc->bb_overrides.sr_enter_plus_exit_time_ns\n\t\t\t&& dc->bb_overrides.sr_enter_plus_exit_time_ns) {\n\t\tbb->sr_enter_plus_exit_time_us =\n\t\t\t\tdc->bb_overrides.sr_enter_plus_exit_time_ns / 1000.0;\n\t}\n\n\tif ((int)(bb->urgent_latency_us * 1000) != dc->bb_overrides.urgent_latency_ns\n\t\t\t&& dc->bb_overrides.urgent_latency_ns) {\n\t\tbb->urgent_latency_us = dc->bb_overrides.urgent_latency_ns / 1000.0;\n\t}\n\n\tif ((int)(bb->dram_clock_change_latency_us * 1000)\n\t\t\t\t!= dc->bb_overrides.dram_clock_change_latency_ns\n\t\t\t&& dc->bb_overrides.dram_clock_change_latency_ns) {\n\t\tbb->dram_clock_change_latency_us =\n\t\t\t\tdc->bb_overrides.dram_clock_change_latency_ns / 1000.0;\n\t}\n\tkernel_fpu_end();\n}\n\nstatic struct _vcs_dpi_soc_bounding_box_st *get_asic_rev_soc_bb(\n\tuint32_t hw_internal_rev)\n{\n\tif (ASICREV_IS_NAVI12_P(hw_internal_rev))\n\t\treturn &dcn2_0_nv12_soc;\n\n\treturn &dcn2_0_soc;\n}\n\nstatic struct _vcs_dpi_ip_params_st *get_asic_rev_ip_params(\n\tuint32_t hw_internal_rev)\n{\n\t/* NV12 and NV10 */\n\treturn &dcn2_0_ip;\n}\n\nstatic enum dml_project get_dml_project_version(uint32_t hw_internal_rev)\n{\n\treturn DML_PROJECT_NAVI10v2;\n}\n\n#define fixed16_to_double(x) (((double) x) / ((double) (1 << 16)))\n#define fixed16_to_double_to_cpu(x) fixed16_to_double(le32_to_cpu(x))\n\nstatic bool init_soc_bounding_box(struct dc *dc,\n\t\t\t\t  struct dcn20_resource_pool *pool)\n{\n\tconst struct gpu_info_soc_bounding_box_v1_0 *bb = dc->soc_bounding_box;\n\tstruct _vcs_dpi_soc_bounding_box_st *loaded_bb =\n\t\t\tget_asic_rev_soc_bb(dc->ctx->asic_id.hw_internal_rev);\n\tstruct _vcs_dpi_ip_params_st *loaded_ip =\n\t\t\tget_asic_rev_ip_params(dc->ctx->asic_id.hw_internal_rev);\n\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tif (!bb && !SOC_BOUNDING_BOX_VALID) {\n\t\tDC_LOG_ERROR(\"%s: not valid soc bounding box/n\", __func__);\n\t\treturn false;\n\t}\n\n\tif (bb && !SOC_BOUNDING_BOX_VALID) {\n\t\tint i;\n\n\t\tdcn2_0_nv12_soc.sr_exit_time_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->sr_exit_time_us);\n\t\tdcn2_0_nv12_soc.sr_enter_plus_exit_time_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->sr_enter_plus_exit_time_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_pixel_data_only_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_pixel_data_only_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_pixel_mixed_with_vm_data_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_pixel_mixed_with_vm_data_us);\n\t\tdcn2_0_nv12_soc.urgent_latency_vm_data_only_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->urgent_latency_vm_data_only_us);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_pixel_only_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_pixel_only_bytes);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_pixel_and_vm_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_pixel_and_vm_bytes);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_vm_only_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_vm_only_bytes);\n\t\tdcn2_0_nv12_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_only =\n\t\t\t\tfixed16_to_double_to_cpu(bb->pct_ideal_dram_sdp_bw_after_urgent_pixel_only);\n\t\tdcn2_0_nv12_soc.pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm =\n\t\t\t\tfixed16_to_double_to_cpu(bb->pct_ideal_dram_sdp_bw_after_urgent_pixel_and_vm);\n\t\tdcn2_0_nv12_soc.pct_ideal_dram_sdp_bw_after_urgent_vm_only =\n\t\t\t\tfixed16_to_double_to_cpu(bb->pct_ideal_dram_sdp_bw_after_urgent_vm_only);\n\t\tdcn2_0_nv12_soc.max_avg_sdp_bw_use_normal_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->max_avg_sdp_bw_use_normal_percent);\n\t\tdcn2_0_nv12_soc.max_avg_dram_bw_use_normal_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->max_avg_dram_bw_use_normal_percent);\n\t\tdcn2_0_nv12_soc.writeback_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->writeback_latency_us);\n\t\tdcn2_0_nv12_soc.ideal_dram_bw_after_urgent_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->ideal_dram_bw_after_urgent_percent);\n\t\tdcn2_0_nv12_soc.max_request_size_bytes =\n\t\t\t\tle32_to_cpu(bb->max_request_size_bytes);\n\t\tdcn2_0_nv12_soc.dram_channel_width_bytes =\n\t\t\t\tle32_to_cpu(bb->dram_channel_width_bytes);\n\t\tdcn2_0_nv12_soc.fabric_datapath_to_dcn_data_return_bytes =\n\t\t\t\tle32_to_cpu(bb->fabric_datapath_to_dcn_data_return_bytes);\n\t\tdcn2_0_nv12_soc.dcn_downspread_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dcn_downspread_percent);\n\t\tdcn2_0_nv12_soc.downspread_percent =\n\t\t\t\tfixed16_to_double_to_cpu(bb->downspread_percent);\n\t\tdcn2_0_nv12_soc.dram_page_open_time_ns =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dram_page_open_time_ns);\n\t\tdcn2_0_nv12_soc.dram_rw_turnaround_time_ns =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dram_rw_turnaround_time_ns);\n\t\tdcn2_0_nv12_soc.dram_return_buffer_per_channel_bytes =\n\t\t\t\tle32_to_cpu(bb->dram_return_buffer_per_channel_bytes);\n\t\tdcn2_0_nv12_soc.round_trip_ping_latency_dcfclk_cycles =\n\t\t\t\tle32_to_cpu(bb->round_trip_ping_latency_dcfclk_cycles);\n\t\tdcn2_0_nv12_soc.urgent_out_of_order_return_per_channel_bytes =\n\t\t\t\tle32_to_cpu(bb->urgent_out_of_order_return_per_channel_bytes);\n\t\tdcn2_0_nv12_soc.channel_interleave_bytes =\n\t\t\t\tle32_to_cpu(bb->channel_interleave_bytes);\n\t\tdcn2_0_nv12_soc.num_banks =\n\t\t\t\tle32_to_cpu(bb->num_banks);\n\t\tdcn2_0_nv12_soc.num_chans =\n\t\t\t\tle32_to_cpu(bb->num_chans);\n\t\tdcn2_0_nv12_soc.vmm_page_size_bytes =\n\t\t\t\tle32_to_cpu(bb->vmm_page_size_bytes);\n\t\tdcn2_0_nv12_soc.dram_clock_change_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->dram_clock_change_latency_us);\n\t\t// HACK!! Lower uclock latency switch time so we don't switch\n\t\tdcn2_0_nv12_soc.dram_clock_change_latency_us = 10;\n\t\tdcn2_0_nv12_soc.writeback_dram_clock_change_latency_us =\n\t\t\t\tfixed16_to_double_to_cpu(bb->writeback_dram_clock_change_latency_us);\n\t\tdcn2_0_nv12_soc.return_bus_width_bytes =\n\t\t\t\tle32_to_cpu(bb->return_bus_width_bytes);\n\t\tdcn2_0_nv12_soc.dispclk_dppclk_vco_speed_mhz =\n\t\t\t\tle32_to_cpu(bb->dispclk_dppclk_vco_speed_mhz);\n\t\tdcn2_0_nv12_soc.xfc_bus_transport_time_us =\n\t\t\t\tle32_to_cpu(bb->xfc_bus_transport_time_us);\n\t\tdcn2_0_nv12_soc.xfc_xbuf_latency_tolerance_us =\n\t\t\t\tle32_to_cpu(bb->xfc_xbuf_latency_tolerance_us);\n\t\tdcn2_0_nv12_soc.use_urgent_burst_bw =\n\t\t\t\tle32_to_cpu(bb->use_urgent_burst_bw);\n\t\tdcn2_0_nv12_soc.num_states =\n\t\t\t\tle32_to_cpu(bb->num_states);\n\n\t\tfor (i = 0; i < dcn2_0_nv12_soc.num_states; i++) {\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].state =\n\t\t\t\t\tle32_to_cpu(bb->clock_limits[i].state);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dcfclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dcfclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].fabricclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].fabricclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dispclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dispclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dppclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dppclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].phyclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].phyclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].socclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].socclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dscclk_mhz =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dscclk_mhz);\n\t\t\tdcn2_0_nv12_soc.clock_limits[i].dram_speed_mts =\n\t\t\t\t\tfixed16_to_double_to_cpu(bb->clock_limits[i].dram_speed_mts);\n\t\t}\n\t}\n\n\tif (pool->base.pp_smu) {\n\t\tstruct pp_smu_nv_clock_table max_clocks = {0};\n\t\tunsigned int uclk_states[8] = {0};\n\t\tunsigned int num_states = 0;\n\t\tenum pp_smu_status status;\n\t\tbool clock_limits_available = false;\n\t\tbool uclk_states_available = false;\n\n\t\tif (pool->base.pp_smu->nv_funcs.get_uclk_dpm_states) {\n\t\t\tstatus = (pool->base.pp_smu->nv_funcs.get_uclk_dpm_states)\n\t\t\t\t(&pool->base.pp_smu->nv_funcs.pp_smu, uclk_states, &num_states);\n\n\t\t\tuclk_states_available = (status == PP_SMU_RESULT_OK);\n\t\t}\n\n\t\tif (pool->base.pp_smu->nv_funcs.get_maximum_sustainable_clocks) {\n\t\t\tstatus = (*pool->base.pp_smu->nv_funcs.get_maximum_sustainable_clocks)\n\t\t\t\t\t(&pool->base.pp_smu->nv_funcs.pp_smu, &max_clocks);\n\t\t\t/* SMU cannot set DCF clock to anything equal to or higher than SOC clock\n\t\t\t */\n\t\t\tif (max_clocks.dcfClockInKhz >= max_clocks.socClockInKhz)\n\t\t\t\tmax_clocks.dcfClockInKhz = max_clocks.socClockInKhz - 1000;\n\t\t\tclock_limits_available = (status == PP_SMU_RESULT_OK);\n\t\t}\n\n\t\tif (clock_limits_available && uclk_states_available && num_states)\n\t\t\tupdate_bounding_box(dc, loaded_bb, &max_clocks, uclk_states, num_states);\n\t\telse if (clock_limits_available)\n\t\t\tcap_soc_clocks(loaded_bb, max_clocks);\n\t}\n\n\tloaded_ip->max_num_otg = pool->base.res_cap->num_timing_generator;\n\tloaded_ip->max_num_dpp = pool->base.pipe_count;\n\tpatch_bounding_box(dc, loaded_bb);\n\n\treturn true;\n}\n\nstatic bool construct(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct dcn20_resource_pool *pool)\n{\n\tint i;\n\tstruct dc_context *ctx = dc->ctx;\n\tstruct irq_service_init_data init_data;\n\tstruct _vcs_dpi_soc_bounding_box_st *loaded_bb =\n\t\t\tget_asic_rev_soc_bb(ctx->asic_id.hw_internal_rev);\n\tstruct _vcs_dpi_ip_params_st *loaded_ip =\n\t\t\tget_asic_rev_ip_params(ctx->asic_id.hw_internal_rev);\n\tenum dml_project dml_project_version =\n\t\t\tget_dml_project_version(ctx->asic_id.hw_internal_rev);\n\n\tctx->dc_bios->regs = &bios_regs;\n\tpool->base.funcs = &dcn20_res_pool_funcs;\n\n\tif (ASICREV_IS_NAVI14_M(ctx->asic_id.hw_internal_rev)) {\n\t\tpool->base.res_cap = &res_cap_nv14;\n\t\tpool->base.pipe_count = 5;\n\t\tpool->base.mpcc_count = 5;\n\t} else {\n\t\tpool->base.res_cap = &res_cap_nv10;\n\t\tpool->base.pipe_count = 6;\n\t\tpool->base.mpcc_count = 6;\n\t}\n\t/*************************************************\n\t *  Resource + asic cap harcoding                *\n\t *************************************************/\n\tpool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;\n\n\tdc->caps.max_downscale_ratio = 200;\n\tdc->caps.i2c_speed_in_khz = 100;\n\tdc->caps.max_cursor_size = 256;\n\tdc->caps.dmdata_alloc_size = 2048;\n\n\tdc->caps.max_slave_planes = 1;\n\tdc->caps.post_blend_color_processing = true;\n\tdc->caps.force_dp_tps4_for_cp2520 = true;\n\tdc->caps.hw_3d_lut = true;\n\n\tif (dc->ctx->dce_environment == DCE_ENV_PRODUCTION_DRV) {\n\t\tdc->debug = debug_defaults_drv;\n\t} else if (dc->ctx->dce_environment == DCE_ENV_FPGA_MAXIMUS) {\n\t\tpool->base.pipe_count = 4;\n\t\tpool->base.mpcc_count = pool->base.pipe_count;\n\t\tdc->debug = debug_defaults_diags;\n\t} else {\n\t\tdc->debug = debug_defaults_diags;\n\t}\n\t//dcn2.0x\n\tdc->work_arounds.dedcn20_305_wa = true;\n\n\t// Init the vm_helper\n\tif (dc->vm_helper)\n\t\tvm_helper_init(dc->vm_helper, 16);\n\n\t/*************************************************\n\t *  Create resources                             *\n\t *************************************************/\n\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL0] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL0,\n\t\t\t\t&clk_src_regs[0], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL1] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL1,\n\t\t\t\t&clk_src_regs[1], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL2] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL2,\n\t\t\t\t&clk_src_regs[2], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL3] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL3,\n\t\t\t\t&clk_src_regs[3], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL4] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL4,\n\t\t\t\t&clk_src_regs[4], false);\n\tpool->base.clock_sources[DCN20_CLK_SRC_PLL5] =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_COMBO_PHY_PLL5,\n\t\t\t\t&clk_src_regs[5], false);\n\tpool->base.clk_src_count = DCN20_CLK_SRC_TOTAL;\n\t/* todo: not reuse phy_pll registers */\n\tpool->base.dp_clock_source =\n\t\t\tdcn20_clock_source_create(ctx, ctx->dc_bios,\n\t\t\t\tCLOCK_SOURCE_ID_DP_DTO,\n\t\t\t\t&clk_src_regs[0], true);\n\n\tfor (i = 0; i < pool->base.clk_src_count; i++) {\n\t\tif (pool->base.clock_sources[i] == NULL) {\n\t\t\tdm_error(\"DC: failed to create clock sources!\\n\");\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tpool->base.dccg = dccg2_create(ctx, &dccg_regs, &dccg_shift, &dccg_mask);\n\tif (pool->base.dccg == NULL) {\n\t\tdm_error(\"DC: failed to create dccg!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.dmcu = dcn20_dmcu_create(ctx,\n\t\t\t&dmcu_regs,\n\t\t\t&dmcu_shift,\n\t\t\t&dmcu_mask);\n\tif (pool->base.dmcu == NULL) {\n\t\tdm_error(\"DC: failed to create dmcu!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.abm = dce_abm_create(ctx,\n\t\t\t&abm_regs,\n\t\t\t&abm_shift,\n\t\t\t&abm_mask);\n\tif (pool->base.abm == NULL) {\n\t\tdm_error(\"DC: failed to create abm!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.pp_smu = dcn20_pp_smu_create(ctx);\n\n\n\tif (!init_soc_bounding_box(dc, pool)) {\n\t\tdm_error(\"DC: failed to initialize soc bounding box!\\n\");\n\t\tBREAK_TO_DEBUGGER();\n\t\tgoto create_fail;\n\t}\n\n\tdml_init_instance(&dc->dml, loaded_bb, loaded_ip, dml_project_version);\n\n\tif (!dc->debug.disable_pplib_wm_range) {\n\t\tstruct pp_smu_wm_range_sets ranges = {0};\n\t\tint i = 0;\n\n\t\tranges.num_reader_wm_sets = 0;\n\n\t\tif (loaded_bb->num_states == 1) {\n\t\t\tranges.reader_wm_sets[0].wm_inst = i;\n\t\t\tranges.reader_wm_sets[0].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges.reader_wm_sets[0].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t\tranges.reader_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges.reader_wm_sets[0].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n\t\t\tranges.num_reader_wm_sets = 1;\n\t\t} else if (loaded_bb->num_states > 1) {\n\t\t\tfor (i = 0; i < 4 && i < loaded_bb->num_states; i++) {\n\t\t\t\tranges.reader_wm_sets[i].wm_inst = i;\n\t\t\t\tranges.reader_wm_sets[i].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\t\tranges.reader_wm_sets[i].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t\t\tranges.reader_wm_sets[i].min_fill_clk_mhz = (i > 0) ? (loaded_bb->clock_limits[i - 1].dram_speed_mts / 16) + 1 : 0;\n\t\t\t\tranges.reader_wm_sets[i].max_fill_clk_mhz = loaded_bb->clock_limits[i].dram_speed_mts / 16;\n\n\t\t\t\tranges.num_reader_wm_sets = i + 1;\n\t\t\t}\n\n\t\t\tranges.reader_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\t\tranges.reader_wm_sets[ranges.num_reader_wm_sets - 1].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\t}\n\n\t\tranges.num_writer_wm_sets = 1;\n\n\t\tranges.writer_wm_sets[0].wm_inst = 0;\n\t\tranges.writer_wm_sets[0].min_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\tranges.writer_wm_sets[0].max_fill_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\t\tranges.writer_wm_sets[0].min_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MIN;\n\t\tranges.writer_wm_sets[0].max_drain_clk_mhz = PP_SMU_WM_SET_RANGE_CLK_UNCONSTRAINED_MAX;\n\n\t\t/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */\n\t\tif (pool->base.pp_smu->nv_funcs.set_wm_ranges)\n\t\t\tpool->base.pp_smu->nv_funcs.set_wm_ranges(&pool->base.pp_smu->nv_funcs.pp_smu, &ranges);\n\t}\n\n\tinit_data.ctx = dc->ctx;\n\tpool->base.irqs = dal_irq_service_dcn20_create(&init_data);\n\tif (!pool->base.irqs)\n\t\tgoto create_fail;\n\n\t/* mem input -> ipp -> dpp -> opp -> TG */\n\tfor (i = 0; i < pool->base.pipe_count; i++) {\n\t\tpool->base.hubps[i] = dcn20_hubp_create(ctx, i);\n\t\tif (pool->base.hubps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create memory input!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\n\t\tpool->base.ipps[i] = dcn20_ipp_create(ctx, i);\n\t\tif (pool->base.ipps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create input pixel processor!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\n\t\tpool->base.dpps[i] = dcn20_dpp_create(ctx, i);\n\t\tif (pool->base.dpps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create dpps!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\tfor (i = 0; i < pool->base.res_cap->num_ddc; i++) {\n\t\tpool->base.engines[i] = dcn20_aux_engine_create(ctx, i);\n\t\tif (pool->base.engines[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create aux engine!!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t\tpool->base.hw_i2cs[i] = dcn20_i2c_hw_create(ctx, i);\n\t\tif (pool->base.hw_i2cs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC:failed to create hw i2c!!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t\tpool->base.sw_i2cs[i] = NULL;\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_opp; i++) {\n\t\tpool->base.opps[i] = dcn20_opp_create(ctx, i);\n\t\tif (pool->base.opps[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\n\t\t\t\t\"DC: failed to create output pixel processor!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pool->base.res_cap->num_timing_generator; i++) {\n\t\tpool->base.timing_generators[i] = dcn20_timing_generator_create(\n\t\t\t\tctx, i);\n\t\tif (pool->base.timing_generators[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create tg!\\n\");\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tpool->base.timing_generator_count = i;\n\n\tpool->base.mpc = dcn20_mpc_create(ctx);\n\tif (pool->base.mpc == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create mpc!\\n\");\n\t\tgoto create_fail;\n\t}\n\n\tpool->base.hubbub = dcn20_hubbub_create(ctx);\n\tif (pool->base.hubbub == NULL) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create hubbub!\\n\");\n\t\tgoto create_fail;\n\t}\n\n#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT\n\tfor (i = 0; i < pool->base.res_cap->num_dsc; i++) {\n\t\tpool->base.dscs[i] = dcn20_dsc_create(ctx, i);\n\t\tif (pool->base.dscs[i] == NULL) {\n\t\t\tBREAK_TO_DEBUGGER();\n\t\t\tdm_error(\"DC: failed to create display stream compressor %d!\\n\", i);\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n#endif\n\n\tif (!dcn20_dwbc_create(ctx, &pool->base)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create dwbc!\\n\");\n\t\tgoto create_fail;\n\t}\n\tif (!dcn20_mmhubbub_create(ctx, &pool->base)) {\n\t\tBREAK_TO_DEBUGGER();\n\t\tdm_error(\"DC: failed to create mcif_wb!\\n\");\n\t\tgoto create_fail;\n\t}\n\n\tif (!resource_construct(num_virtual_links, dc, &pool->base,\n\t\t\t(!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment) ?\n\t\t\t&res_create_funcs : &res_create_maximus_funcs)))\n\t\t\tgoto create_fail;\n\n\tdcn20_hw_sequencer_construct(dc);\n\n\tdc->caps.max_planes =  pool->base.pipe_count;\n\n\tfor (i = 0; i < dc->caps.max_planes; ++i)\n\t\tdc->caps.planes[i] = plane_cap;\n\n\tdc->cap_funcs = cap_funcs;\n\n\treturn true;\n\ncreate_fail:\n\n\tdestruct(pool);\n\n\treturn false;\n}\n\nstruct resource_pool *dcn20_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn20_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn20_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\tkfree(pool);\n\treturn NULL;\n}\n"], "filenames": ["drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c", "drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c", "drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c", "drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c", "drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c", "drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c", "drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c"], "buggy_code_start_loc": [670, 716, 689, 502, 703, 788, 1079], "buggy_code_end_loc": [670, 716, 689, 502, 703, 788, 1079], "fixing_code_start_loc": [671, 717, 690, 503, 704, 789, 1080], "fixing_code_end_loc": [672, 718, 691, 504, 705, 790, 1081], "type": "CWE-401", "message": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "other": {"cve": {"id": "CVE-2019-19083", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.890", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en las funciones *clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc en el kernel de Linux versiones anteriores a la versi\u00f3n  5.3.8, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria). Esto afecta la funci\u00f3n dce112_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, la funci\u00f3n dce100_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, la funci\u00f3n  dcn10_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, la funci\u00f3n dcn20_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, la funci\u00f3n dce120_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, la funci\u00f3n dce110_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, y la funci\u00f3n dce80_clock_source_create() en el archivo drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, tambi\u00e9n se conoce como CID-055e547478a1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.8", "matchCriteriaId": "AEC4B6C4-7934-4B29-A754-F6B88C80CF6E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4208-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12"}}