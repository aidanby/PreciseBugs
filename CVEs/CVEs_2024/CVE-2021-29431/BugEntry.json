{"buggy_code": ["# -*- coding: utf-8 -*-\n\n# Copyright 2018 New Vector Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nimport logging\nimport time\n\nfrom twisted.internet import defer\nfrom unpaddedbase64 import decode_base64\nimport signedjson.sign\nimport signedjson.key\nfrom signedjson.sign import SignatureVerifyException\n\nfrom sydent.http.httpclient import FederationHttpClient\nfrom sydent.util.stringutils import is_valid_hostname\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass NoAuthenticationError(Exception):\n    \"\"\"\n    Raised when no signature is provided that could be authenticated\n    \"\"\"\n    pass\n\n\nclass InvalidServerName(Exception):\n    \"\"\"\n    Raised when the provided origin parameter is not a valid hostname (plus optional port).\n    \"\"\"\n    pass\n\n\nclass Verifier(object):\n    \"\"\"\n    Verifies signed json blobs from Matrix Homeservers by finding the\n    homeserver's address, contacting it, requesting its keys and\n    verifying that the signature on the json blob matches.\n    \"\"\"\n    def __init__(self, sydent):\n        self.sydent = sydent\n        # Cache of server keys. These are cached until the 'valid_until_ts' time\n        # in the result.\n        self.cache = {\n            # server_name: <result from keys query>,\n        }\n\n    @defer.inlineCallbacks\n    def _getKeysForServer(self, server_name):\n        \"\"\"Get the signing key data from a homeserver.\n\n        :param server_name: The name of the server to request the keys from.\n        :type server_name: unicode\n\n        :return: The verification keys returned by the server.\n        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]\n        \"\"\"\n\n        if server_name in self.cache:\n            cached = self.cache[server_name]\n            now = int(time.time() * 1000)\n            if cached['valid_until_ts'] > now:\n                defer.returnValue(self.cache[server_name]['verify_keys'])\n\n        client = FederationHttpClient(self.sydent)\n        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)\n        if 'verify_keys' not in result:\n            raise SignatureVerifyException(\"No key found in response\")\n\n        if 'valid_until_ts' in result:\n            # Don't cache anything without a valid_until_ts or we wouldn't\n            # know when to expire it.\n            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])\n            self.cache[server_name] = result\n\n        defer.returnValue(result['verify_keys'])\n\n    @defer.inlineCallbacks\n    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):\n        \"\"\"Given a signed json object, try to verify any one\n        of the signatures on it\n\n        XXX: This contains a fairly noddy version of the home server\n        SRV lookup and signature verification. It does no caching (just\n        fetches the signature each time and does not contact any other\n        servers to do perspective checks).\n\n        :param acceptable_server_names: If provided and not None,\n        only signatures from servers in this list will be accepted.\n        :type acceptable_server_names: list[unicode] or None\n\n        :return a tuple of the server name and key name that was\n        successfully verified.\n        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]\n\n        :raise SignatureVerifyException: The json cannot be verified.\n        \"\"\"\n        if 'signatures' not in signed_json:\n            raise SignatureVerifyException(\"Signature missing\")\n        for server_name, sigs in signed_json['signatures'].items():\n            if acceptable_server_names is not None:\n                if server_name not in acceptable_server_names:\n                    continue\n\n            server_keys = yield self._getKeysForServer(server_name)\n            for key_name, sig in sigs.items():\n                if key_name in server_keys:\n                    if 'key' not in server_keys[key_name]:\n                        logger.warn(\"Ignoring key %s with no 'key'\")\n                        continue\n                    key_bytes = decode_base64(server_keys[key_name]['key'])\n                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)\n                    logger.info(\"verifying sig from key %r\", key_name)\n                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)\n                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)\n                    defer.returnValue((server_name, key_name))\n            logger.warn(\n                \"No matching key found for signature block %r in server keys %r\",\n                signed_json['signatures'], server_keys,\n            )\n        logger.warn(\n            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",\n            signed_json['signatures'], acceptable_server_names,\n        )\n        raise SignatureVerifyException(\"No matching signature found\")\n\n    @defer.inlineCallbacks\n    def authenticate_request(self, request, content):\n        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header\n        XXX: Copied largely from synapse\n\n        :param request: The request object to authenticate\n        :type request: twisted.web.server.Request\n        :param content: The content of the request, if any\n        :type content: bytes or None\n\n        :return: The origin of the server whose signature was validated\n        :rtype: twisted.internet.defer.Deferred[unicode]\n        \"\"\"\n        json_request = {\n            \"method\": request.method,\n            \"uri\": request.uri,\n            \"destination_is\": self.sydent.server_name,\n            \"signatures\": {},\n        }\n\n        if content is not None:\n            json_request[\"content\"] = content\n\n        origin = None\n\n        def parse_auth_header(header_str):\n            \"\"\"\n            Extracts a server name, signing key and payload signature from an\n            authentication header.\n\n            :param header_str: The content of the header\n            :type header_str: unicode\n\n            :return: The server name, the signing key, and the payload signature.\n            :rtype: tuple[unicode]\n            \"\"\"\n            try:\n                params = header_str.split(u\" \")[1].split(u\",\")\n                param_dict = dict(kv.split(u\"=\") for kv in params)\n\n                def strip_quotes(value):\n                    if value.startswith(u\"\\\"\"):\n                        return value[1:-1]\n                    else:\n                        return value\n\n                origin = strip_quotes(param_dict[\"origin\"])\n                key = strip_quotes(param_dict[\"key\"])\n                sig = strip_quotes(param_dict[\"sig\"])\n                return origin, key, sig\n            except Exception:\n                raise SignatureVerifyException(\"Malformed Authorization header\")\n\n        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")\n\n        if not auth_headers:\n            raise NoAuthenticationError(\"Missing Authorization headers\")\n\n        for auth in auth_headers:\n            if auth.startswith(u\"X-Matrix\"):\n                (origin, key, sig) = parse_auth_header(auth)\n                json_request[\"origin\"] = origin\n                json_request[\"signatures\"].setdefault(origin, {})[key] = sig\n\n        if not json_request[\"signatures\"]:\n            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")\n\n        if not is_valid_hostname(json_request[\"origin\"]):\n            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid hostname\")\n\n        yield self.verifyServerSignedJson(json_request, [origin])\n\n        logger.info(\"Verified request from HS %s\", origin)\n\n        defer.returnValue(origin)\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2019 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nfrom twisted.web.resource import Resource\nfrom twisted.internet import defer\n\nimport logging\nimport json\nfrom six.moves import urllib\n\nfrom sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors\nfrom sydent.http.httpclient import FederationHttpClient\nfrom sydent.users.tokens import issueToken\nfrom sydent.util.stringutils import is_valid_hostname\n\nlogger = logging.getLogger(__name__)\n\n\nclass RegisterServlet(Resource):\n    isLeaf = True\n\n    def __init__(self, syd):\n        self.sydent = syd\n        self.client = FederationHttpClient(self.sydent)\n\n    @deferjsonwrap\n    @defer.inlineCallbacks\n    def render_POST(self, request):\n        \"\"\"\n        Register with the Identity Server\n        \"\"\"\n        send_cors(request)\n\n        args = get_args(request, ('matrix_server_name', 'access_token'))\n\n        matrix_server = args['matrix_server_name'].lower()\n\n        if not is_valid_hostname(matrix_server):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'matrix_server_name must be a valid hostname'\n            }\n\n        result = yield self.client.get_json(\n            \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\"\n            % (\n                matrix_server,\n                urllib.parse.quote(args['access_token']),\n            ),\n            1024 * 5,\n        )\n\n        if 'sub' not in result:\n            raise Exception(\"Invalid response from homeserver\")\n\n        user_id = result['sub']\n\n        if not isinstance(user_id, str):\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned a malformed reply'\n            }\n\n        user_id_components = user_id.split(':', 1)\n\n        # Ensure there's a localpart and domain in the returned user ID.\n        if len(user_id_components) != 2:\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned an invalid MXID'\n            }\n\n        user_id_server = user_id_components[1]\n\n        if not is_valid_hostname(user_id_server):\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned an invalid MXID'\n            }\n\n        if user_id_server != matrix_server:\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned a MXID belonging to another homeserver'\n            }\n\n        tok = yield issueToken(self.sydent, user_id)\n\n        # XXX: `token` is correct for the spec, but we released with `access_token`\n        # for a substantial amount of time. Serve both to make spec-compliant clients\n        # happy.\n        defer.returnValue({\n            \"access_token\": tok,\n            \"token\": tok,\n        })\n\n    def render_OPTIONS(self, request):\n        send_cors(request)\n        return b''\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2014 OpenMarket Ltd\n# Copyright 2018 New Vector Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nimport collections\nimport logging\nimport math\nimport signedjson.sign\nfrom sydent.db.invite_tokens import JoinTokenStore\n\nfrom sydent.db.threepid_associations import LocalAssociationStore\n\nfrom sydent.util import time_msec\nfrom sydent.util.hash import sha256_and_url_safe_base64\nfrom sydent.db.hashing_metadata import HashingMetadataStore\nfrom sydent.threepid.signer import Signer\nfrom sydent.http.httpclient import FederationHttpClient\n\nfrom sydent.threepid import ThreepidAssociation\n\nfrom sydent.util.stringutils import is_valid_hostname\n\nfrom twisted.internet import defer\n\nlogger = logging.getLogger(__name__)\n\n\nclass ThreepidBinder:\n    # the lifetime of a 3pid association\n    THREEPID_ASSOCIATION_LIFETIME_MS = 100 * 365 * 24 * 60 * 60 * 1000\n\n    def __init__(self, sydent):\n        self.sydent = sydent\n        self.hashing_store = HashingMetadataStore(sydent)\n\n    def addBinding(self, medium, address, mxid):\n        \"\"\"\n        Binds the given 3pid to the given mxid.\n\n        It's assumed that we have somehow validated that the given user owns\n        the given 3pid\n\n        :param medium: The medium of the 3PID to bind.\n        :type medium: unicode\n        :param address: The address of the 3PID to bind.\n        :type address: unicode\n        :param mxid: The MXID to bind the 3PID to.\n        :type mxid: unicode\n\n        :return: The signed association.\n        :rtype: dict[str, any]\n        \"\"\"\n        localAssocStore = LocalAssociationStore(self.sydent)\n\n        # Fill out the association details\n        createdAt = time_msec()\n        expires = createdAt + ThreepidBinder.THREEPID_ASSOCIATION_LIFETIME_MS\n\n        # Hash the medium + address and store that hash for the purposes of\n        # later lookups\n        str_to_hash = u' '.join(\n            [address, medium, self.hashing_store.get_lookup_pepper()],\n        )\n        lookup_hash = sha256_and_url_safe_base64(str_to_hash)\n\n        assoc = ThreepidAssociation(\n            medium, address, lookup_hash, mxid, createdAt, createdAt, expires,\n        )\n\n        localAssocStore.addOrUpdateAssociation(assoc)\n\n        self.sydent.pusher.doLocalPush()\n\n        joinTokenStore = JoinTokenStore(self.sydent)\n        pendingJoinTokens = joinTokenStore.getTokens(medium, address)\n        invites = []\n        for token in pendingJoinTokens:\n            token[\"mxid\"] = mxid\n            token[\"signed\"] = {\n                \"mxid\": mxid,\n                \"token\": token[\"token\"],\n            }\n            token[\"signed\"] = signedjson.sign.sign_json(token[\"signed\"], self.sydent.server_name, self.sydent.keyring.ed25519)\n            invites.append(token)\n        if invites:\n            assoc.extra_fields[\"invites\"] = invites\n            joinTokenStore.markTokensAsSent(medium, address)\n\n        signer = Signer(self.sydent)\n        sgassoc = signer.signedThreePidAssociation(assoc)\n\n        self._notify(sgassoc, 0)\n\n        return sgassoc\n\n    def removeBinding(self, threepid, mxid):\n        \"\"\"\n        Removes the binding between a given 3PID and a given MXID.\n\n        :param threepid: The 3PID of the binding to remove.\n        :type threepid: dict[unicode, unicode]\n        :param mxid: The MXID of the binding to remove.\n        :type mxid: unicode\n        \"\"\"\n        localAssocStore = LocalAssociationStore(self.sydent)\n        localAssocStore.removeAssociation(threepid, mxid)\n        self.sydent.pusher.doLocalPush()\n\n    @defer.inlineCallbacks\n    def _notify(self, assoc, attempt):\n        \"\"\"\n        Sends data about a new association (and, if necessary, the associated invites)\n        to the associated MXID's homeserver.\n\n        :param assoc: The association to send down to the homeserver.\n        :type assoc: dict[str, any]\n        :param attempt: The number of previous attempts to send this association.\n        :type attempt: int\n        \"\"\"\n        mxid = assoc[\"mxid\"]\n        mxid_parts = mxid.split(\":\", 1)\n\n        if len(mxid_parts) != 2:\n            logger.error(\n                \"Can't notify on bind for unparseable mxid %s. Not retrying.\",\n                assoc[\"mxid\"],\n            )\n            return\n\n        matrix_server = mxid_parts[1]\n\n        if not is_valid_hostname(matrix_server):\n            logger.error(\n                \"MXID server part '%s' not a valid hostname. Not retrying.\",\n                matrix_server,\n            )\n            return\n\n        post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % (\n            matrix_server,\n        )\n\n        logger.info(\"Making bind callback to: %s\", post_url)\n\n        # Make a POST to the chosen Synapse server\n        http_client = FederationHttpClient(self.sydent)\n        try:\n            response = yield http_client.post_json_get_nothing(post_url, assoc, {})\n        except Exception as e:\n            self._notifyErrback(assoc, attempt, e)\n            return\n\n        # If the request failed, try again with exponential backoff\n        if response.code != 200:\n            self._notifyErrback(\n                assoc, attempt, \"Non-OK error code received (%d)\" % response.code\n            )\n        else:\n            logger.info(\"Successfully notified on bind for %s\" % (mxid,))\n\n            # Skip the deletion step if instructed so by the config.\n            if not self.sydent.delete_tokens_on_bind:\n                return\n\n            # Only remove sent tokens when they've been successfully sent.\n            try:\n                joinTokenStore = JoinTokenStore(self.sydent)\n                joinTokenStore.deleteTokens(assoc[\"medium\"], assoc[\"address\"])\n                logger.info(\n                    \"Successfully deleted invite for %s from the store\",\n                    assoc[\"address\"],\n                )\n            except Exception as e:\n                logger.exception(\n                    \"Couldn't remove invite for %s from the store\",\n                    assoc[\"address\"],\n                )\n\n    def _notifyErrback(self, assoc, attempt, error):\n        \"\"\"\n        Handles errors when trying to send an association down to a homeserver by\n        logging the error and scheduling a new attempt.\n\n        :param assoc: The association to send down to the homeserver.\n        :type assoc: dict[str, any]\n        :param attempt: The number of previous attempts to send this association.\n        :type attempt: int\n        :param error: The error that was raised when trying to send the association.\n        :type error: Exception\n        \"\"\"\n        logger.warning(\n            \"Error notifying on bind for %s: %s - rescheduling\", assoc[\"mxid\"], error\n        )\n        self.sydent.reactor.callLater(\n            math.pow(2, attempt), self._notify, assoc, attempt + 1\n        )\n\n    # The below is lovingly ripped off of synapse/http/endpoint.py\n\n    _Server = collections.namedtuple(\"_Server\", \"priority weight host port\")\n", "# -*- coding: utf-8 -*-\n# Copyright 2020 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport re\n\n# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken\nclient_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")\n\n# hostname/domain name + optional port\n# https://regex101.com/r/OyN1lg/2\nhostname_regex = re.compile(\n    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",\n    flags=re.IGNORECASE)\n\n\ndef is_valid_client_secret(client_secret):\n    \"\"\"Validate that a given string matches the client_secret regex defined by the spec\n\n    :param client_secret: The client_secret to validate\n    :type client_secret: str\n\n    :return: Whether the client_secret is valid\n    :rtype: bool\n    \"\"\"\n    return client_secret_regex.match(client_secret) is not None\n\n\ndef is_valid_hostname(string: str) -> bool:\n    \"\"\"Validate that a given string is a valid hostname or domain name, with an\n    optional port number.\n\n    For domain names, this only validates that the form is right (for\n    instance, it doesn't check that the TLD is valid). If a port is\n    specified, it has to be a valid port number.\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid hostname\n    :rtype: bool\n    \"\"\"\n\n    host_parts = string.split(\":\", 1)\n\n    if len(host_parts) == 1:\n        return hostname_regex.match(string) is not None\n    else:\n        host, port = host_parts\n        valid_hostname = hostname_regex.match(host) is not None\n\n        try:\n            port_num = int(port)\n            valid_port = (\n                port == str(port_num)  # exclude things like '08090' or ' 8090'\n                and 1 <= port_num < 65536)\n        except ValueError:\n            valid_port = False\n\n        return valid_hostname and valid_port\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2021 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom twisted.trial import unittest\n\nfrom tests.utils import make_request, make_sydent\n\n\nclass RegisterTestCase(unittest.TestCase):\n    \"\"\"Tests Sydent's register servlet\"\"\"\n    def setUp(self):\n        # Create a new sydent\n        self.sydent = make_sydent()\n\n    def test_sydent_rejects_invalid_hostname(self):\n        \"\"\"Tests that the /register endpoint rejects an invalid hostname passed as matrix_server_name\"\"\"\n        self.sydent.run()\n\n        bad_hostname = \"example.com#\"\n\n        request, channel = make_request(\n            self.sydent.reactor,\n            \"POST\",\n            \"/_matrix/identity/v2/account/register\",\n            content={\n                \"matrix_server_name\": bad_hostname,\n                \"access_token\": \"foo\"\n            })\n\n        request.render(self.sydent.servlets.registerServlet)\n\n        self.assertEqual(channel.code, 400)\n", "from twisted.trial import unittest\nfrom sydent.util.stringutils import is_valid_hostname\n\n\nclass UtilTests(unittest.TestCase):\n    \"\"\"Tests Sydent utility functions.\"\"\"\n    def test_is_valid_hostname(self):\n        \"\"\"Tests that the is_valid_hostname function accepts only valid\n        hostnames (or domain names), with optional port number.\n        \"\"\"\n\n        self.assertTrue(is_valid_hostname(\"example.com\"))\n        self.assertTrue(is_valid_hostname(\"EXAMPLE.COM\"))\n        self.assertTrue(is_valid_hostname(\"ExAmPlE.CoM\"))\n        self.assertTrue(is_valid_hostname(\"example.com:4242\"))\n        self.assertTrue(is_valid_hostname(\"localhost\"))\n        self.assertTrue(is_valid_hostname(\"localhost:9000\"))\n        self.assertTrue(is_valid_hostname(\"a.b:1234\"))\n\n        self.assertFalse(is_valid_hostname(\"example.com:65536\"))\n        self.assertFalse(is_valid_hostname(\"example.com:0\"))\n        self.assertFalse(is_valid_hostname(\"example.com:a\"))\n        self.assertFalse(is_valid_hostname(\"example.com:04242\"))\n        self.assertFalse(is_valid_hostname(\"example.com: 4242\"))\n        self.assertFalse(is_valid_hostname(\"example.com/example.com\"))\n        self.assertFalse(is_valid_hostname(\"example.com#example.com\"))\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n# Copyright 2018 New Vector Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nimport logging\nimport time\n\nfrom twisted.internet import defer\nfrom unpaddedbase64 import decode_base64\nimport signedjson.sign\nimport signedjson.key\nfrom signedjson.sign import SignatureVerifyException\n\nfrom sydent.http.httpclient import FederationHttpClient\nfrom sydent.util.stringutils import is_valid_matrix_server_name\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass NoAuthenticationError(Exception):\n    \"\"\"\n    Raised when no signature is provided that could be authenticated\n    \"\"\"\n    pass\n\n\nclass InvalidServerName(Exception):\n    \"\"\"\n    Raised when the provided origin parameter is not a valid hostname (plus optional port).\n    \"\"\"\n    pass\n\n\nclass Verifier(object):\n    \"\"\"\n    Verifies signed json blobs from Matrix Homeservers by finding the\n    homeserver's address, contacting it, requesting its keys and\n    verifying that the signature on the json blob matches.\n    \"\"\"\n    def __init__(self, sydent):\n        self.sydent = sydent\n        # Cache of server keys. These are cached until the 'valid_until_ts' time\n        # in the result.\n        self.cache = {\n            # server_name: <result from keys query>,\n        }\n\n    @defer.inlineCallbacks\n    def _getKeysForServer(self, server_name):\n        \"\"\"Get the signing key data from a homeserver.\n\n        :param server_name: The name of the server to request the keys from.\n        :type server_name: unicode\n\n        :return: The verification keys returned by the server.\n        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]\n        \"\"\"\n\n        if server_name in self.cache:\n            cached = self.cache[server_name]\n            now = int(time.time() * 1000)\n            if cached['valid_until_ts'] > now:\n                defer.returnValue(self.cache[server_name]['verify_keys'])\n\n        client = FederationHttpClient(self.sydent)\n        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)\n        if 'verify_keys' not in result:\n            raise SignatureVerifyException(\"No key found in response\")\n\n        if 'valid_until_ts' in result:\n            # Don't cache anything without a valid_until_ts or we wouldn't\n            # know when to expire it.\n            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])\n            self.cache[server_name] = result\n\n        defer.returnValue(result['verify_keys'])\n\n    @defer.inlineCallbacks\n    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):\n        \"\"\"Given a signed json object, try to verify any one\n        of the signatures on it\n\n        XXX: This contains a fairly noddy version of the home server\n        SRV lookup and signature verification. It does no caching (just\n        fetches the signature each time and does not contact any other\n        servers to do perspective checks).\n\n        :param acceptable_server_names: If provided and not None,\n        only signatures from servers in this list will be accepted.\n        :type acceptable_server_names: list[unicode] or None\n\n        :return a tuple of the server name and key name that was\n        successfully verified.\n        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]\n\n        :raise SignatureVerifyException: The json cannot be verified.\n        \"\"\"\n        if 'signatures' not in signed_json:\n            raise SignatureVerifyException(\"Signature missing\")\n        for server_name, sigs in signed_json['signatures'].items():\n            if acceptable_server_names is not None:\n                if server_name not in acceptable_server_names:\n                    continue\n\n            server_keys = yield self._getKeysForServer(server_name)\n            for key_name, sig in sigs.items():\n                if key_name in server_keys:\n                    if 'key' not in server_keys[key_name]:\n                        logger.warn(\"Ignoring key %s with no 'key'\")\n                        continue\n                    key_bytes = decode_base64(server_keys[key_name]['key'])\n                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)\n                    logger.info(\"verifying sig from key %r\", key_name)\n                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)\n                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)\n                    defer.returnValue((server_name, key_name))\n            logger.warn(\n                \"No matching key found for signature block %r in server keys %r\",\n                signed_json['signatures'], server_keys,\n            )\n        logger.warn(\n            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",\n            signed_json['signatures'], acceptable_server_names,\n        )\n        raise SignatureVerifyException(\"No matching signature found\")\n\n    @defer.inlineCallbacks\n    def authenticate_request(self, request, content):\n        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header\n        XXX: Copied largely from synapse\n\n        :param request: The request object to authenticate\n        :type request: twisted.web.server.Request\n        :param content: The content of the request, if any\n        :type content: bytes or None\n\n        :return: The origin of the server whose signature was validated\n        :rtype: twisted.internet.defer.Deferred[unicode]\n        \"\"\"\n        json_request = {\n            \"method\": request.method,\n            \"uri\": request.uri,\n            \"destination_is\": self.sydent.server_name,\n            \"signatures\": {},\n        }\n\n        if content is not None:\n            json_request[\"content\"] = content\n\n        origin = None\n\n        def parse_auth_header(header_str):\n            \"\"\"\n            Extracts a server name, signing key and payload signature from an\n            authentication header.\n\n            :param header_str: The content of the header\n            :type header_str: unicode\n\n            :return: The server name, the signing key, and the payload signature.\n            :rtype: tuple[unicode]\n            \"\"\"\n            try:\n                params = header_str.split(u\" \")[1].split(u\",\")\n                param_dict = dict(kv.split(u\"=\") for kv in params)\n\n                def strip_quotes(value):\n                    if value.startswith(u\"\\\"\"):\n                        return value[1:-1]\n                    else:\n                        return value\n\n                origin = strip_quotes(param_dict[\"origin\"])\n                key = strip_quotes(param_dict[\"key\"])\n                sig = strip_quotes(param_dict[\"sig\"])\n                return origin, key, sig\n            except Exception:\n                raise SignatureVerifyException(\"Malformed Authorization header\")\n\n        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")\n\n        if not auth_headers:\n            raise NoAuthenticationError(\"Missing Authorization headers\")\n\n        for auth in auth_headers:\n            if auth.startswith(u\"X-Matrix\"):\n                (origin, key, sig) = parse_auth_header(auth)\n                json_request[\"origin\"] = origin\n                json_request[\"signatures\"].setdefault(origin, {})[key] = sig\n\n        if not json_request[\"signatures\"]:\n            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")\n\n        if not is_valid_matrix_server_name(json_request[\"origin\"]):\n            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid Matrix server name\")\n\n        yield self.verifyServerSignedJson(json_request, [origin])\n\n        logger.info(\"Verified request from HS %s\", origin)\n\n        defer.returnValue(origin)\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2019 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nfrom twisted.web.resource import Resource\nfrom twisted.internet import defer\n\nimport logging\nimport json\nfrom six.moves import urllib\n\nfrom sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors\nfrom sydent.http.httpclient import FederationHttpClient\nfrom sydent.users.tokens import issueToken\nfrom sydent.util.stringutils import is_valid_matrix_server_name\n\nlogger = logging.getLogger(__name__)\n\n\nclass RegisterServlet(Resource):\n    isLeaf = True\n\n    def __init__(self, syd):\n        self.sydent = syd\n        self.client = FederationHttpClient(self.sydent)\n\n    @deferjsonwrap\n    @defer.inlineCallbacks\n    def render_POST(self, request):\n        \"\"\"\n        Register with the Identity Server\n        \"\"\"\n        send_cors(request)\n\n        args = get_args(request, ('matrix_server_name', 'access_token'))\n\n        matrix_server = args['matrix_server_name'].lower()\n\n        if not is_valid_matrix_server_name(matrix_server):\n            request.setResponseCode(400)\n            return {\n                'errcode': 'M_INVALID_PARAM',\n                'error': 'matrix_server_name must be a valid Matrix server name (IP address or hostname)'\n            }\n\n        result = yield self.client.get_json(\n            \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\"\n            % (\n                matrix_server,\n                urllib.parse.quote(args['access_token']),\n            ),\n            1024 * 5,\n        )\n\n        if 'sub' not in result:\n            raise Exception(\"Invalid response from homeserver\")\n\n        user_id = result['sub']\n\n        if not isinstance(user_id, str):\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned a malformed reply'\n            }\n\n        user_id_components = user_id.split(':', 1)\n\n        # Ensure there's a localpart and domain in the returned user ID.\n        if len(user_id_components) != 2:\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned an invalid MXID'\n            }\n\n        user_id_server = user_id_components[1]\n\n        if not is_valid_matrix_server_name(user_id_server):\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned an invalid MXID'\n            }\n\n        if user_id_server != matrix_server:\n            request.setResponseCode(500)\n            return {\n                'errcode': 'M_UNKNOWN',\n                'error': 'The Matrix homeserver returned a MXID belonging to another homeserver'\n            }\n\n        tok = yield issueToken(self.sydent, user_id)\n\n        # XXX: `token` is correct for the spec, but we released with `access_token`\n        # for a substantial amount of time. Serve both to make spec-compliant clients\n        # happy.\n        defer.returnValue({\n            \"access_token\": tok,\n            \"token\": tok,\n        })\n\n    def render_OPTIONS(self, request):\n        send_cors(request)\n        return b''\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2014 OpenMarket Ltd\n# Copyright 2018 New Vector Ltd\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom __future__ import absolute_import\n\nimport collections\nimport logging\nimport math\nimport signedjson.sign\nfrom sydent.db.invite_tokens import JoinTokenStore\n\nfrom sydent.db.threepid_associations import LocalAssociationStore\n\nfrom sydent.util import time_msec\nfrom sydent.util.hash import sha256_and_url_safe_base64\nfrom sydent.db.hashing_metadata import HashingMetadataStore\nfrom sydent.threepid.signer import Signer\nfrom sydent.http.httpclient import FederationHttpClient\n\nfrom sydent.threepid import ThreepidAssociation\n\nfrom sydent.util.stringutils import is_valid_matrix_server_name\n\nfrom twisted.internet import defer\n\nlogger = logging.getLogger(__name__)\n\n\nclass ThreepidBinder:\n    # the lifetime of a 3pid association\n    THREEPID_ASSOCIATION_LIFETIME_MS = 100 * 365 * 24 * 60 * 60 * 1000\n\n    def __init__(self, sydent):\n        self.sydent = sydent\n        self.hashing_store = HashingMetadataStore(sydent)\n\n    def addBinding(self, medium, address, mxid):\n        \"\"\"\n        Binds the given 3pid to the given mxid.\n\n        It's assumed that we have somehow validated that the given user owns\n        the given 3pid\n\n        :param medium: The medium of the 3PID to bind.\n        :type medium: unicode\n        :param address: The address of the 3PID to bind.\n        :type address: unicode\n        :param mxid: The MXID to bind the 3PID to.\n        :type mxid: unicode\n\n        :return: The signed association.\n        :rtype: dict[str, any]\n        \"\"\"\n        localAssocStore = LocalAssociationStore(self.sydent)\n\n        # Fill out the association details\n        createdAt = time_msec()\n        expires = createdAt + ThreepidBinder.THREEPID_ASSOCIATION_LIFETIME_MS\n\n        # Hash the medium + address and store that hash for the purposes of\n        # later lookups\n        str_to_hash = u' '.join(\n            [address, medium, self.hashing_store.get_lookup_pepper()],\n        )\n        lookup_hash = sha256_and_url_safe_base64(str_to_hash)\n\n        assoc = ThreepidAssociation(\n            medium, address, lookup_hash, mxid, createdAt, createdAt, expires,\n        )\n\n        localAssocStore.addOrUpdateAssociation(assoc)\n\n        self.sydent.pusher.doLocalPush()\n\n        joinTokenStore = JoinTokenStore(self.sydent)\n        pendingJoinTokens = joinTokenStore.getTokens(medium, address)\n        invites = []\n        for token in pendingJoinTokens:\n            token[\"mxid\"] = mxid\n            token[\"signed\"] = {\n                \"mxid\": mxid,\n                \"token\": token[\"token\"],\n            }\n            token[\"signed\"] = signedjson.sign.sign_json(token[\"signed\"], self.sydent.server_name, self.sydent.keyring.ed25519)\n            invites.append(token)\n        if invites:\n            assoc.extra_fields[\"invites\"] = invites\n            joinTokenStore.markTokensAsSent(medium, address)\n\n        signer = Signer(self.sydent)\n        sgassoc = signer.signedThreePidAssociation(assoc)\n\n        self._notify(sgassoc, 0)\n\n        return sgassoc\n\n    def removeBinding(self, threepid, mxid):\n        \"\"\"\n        Removes the binding between a given 3PID and a given MXID.\n\n        :param threepid: The 3PID of the binding to remove.\n        :type threepid: dict[unicode, unicode]\n        :param mxid: The MXID of the binding to remove.\n        :type mxid: unicode\n        \"\"\"\n        localAssocStore = LocalAssociationStore(self.sydent)\n        localAssocStore.removeAssociation(threepid, mxid)\n        self.sydent.pusher.doLocalPush()\n\n    @defer.inlineCallbacks\n    def _notify(self, assoc, attempt):\n        \"\"\"\n        Sends data about a new association (and, if necessary, the associated invites)\n        to the associated MXID's homeserver.\n\n        :param assoc: The association to send down to the homeserver.\n        :type assoc: dict[str, any]\n        :param attempt: The number of previous attempts to send this association.\n        :type attempt: int\n        \"\"\"\n        mxid = assoc[\"mxid\"]\n        mxid_parts = mxid.split(\":\", 1)\n\n        if len(mxid_parts) != 2:\n            logger.error(\n                \"Can't notify on bind for unparseable mxid %s. Not retrying.\",\n                assoc[\"mxid\"],\n            )\n            return\n\n        matrix_server = mxid_parts[1]\n\n        if not is_valid_matrix_server_name(matrix_server):\n            logger.error(\n                \"MXID server part '%s' not a valid Matrix server name. Not retrying.\",\n                matrix_server,\n            )\n            return\n\n        post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % (\n            matrix_server,\n        )\n\n        logger.info(\"Making bind callback to: %s\", post_url)\n\n        # Make a POST to the chosen Synapse server\n        http_client = FederationHttpClient(self.sydent)\n        try:\n            response = yield http_client.post_json_get_nothing(post_url, assoc, {})\n        except Exception as e:\n            self._notifyErrback(assoc, attempt, e)\n            return\n\n        # If the request failed, try again with exponential backoff\n        if response.code != 200:\n            self._notifyErrback(\n                assoc, attempt, \"Non-OK error code received (%d)\" % response.code\n            )\n        else:\n            logger.info(\"Successfully notified on bind for %s\" % (mxid,))\n\n            # Skip the deletion step if instructed so by the config.\n            if not self.sydent.delete_tokens_on_bind:\n                return\n\n            # Only remove sent tokens when they've been successfully sent.\n            try:\n                joinTokenStore = JoinTokenStore(self.sydent)\n                joinTokenStore.deleteTokens(assoc[\"medium\"], assoc[\"address\"])\n                logger.info(\n                    \"Successfully deleted invite for %s from the store\",\n                    assoc[\"address\"],\n                )\n            except Exception:\n                logger.exception(\n                    \"Couldn't remove invite for %s from the store\",\n                    assoc[\"address\"],\n                )\n\n    def _notifyErrback(self, assoc, attempt, error):\n        \"\"\"\n        Handles errors when trying to send an association down to a homeserver by\n        logging the error and scheduling a new attempt.\n\n        :param assoc: The association to send down to the homeserver.\n        :type assoc: dict[str, any]\n        :param attempt: The number of previous attempts to send this association.\n        :type attempt: int\n        :param error: The error that was raised when trying to send the association.\n        :type error: Exception\n        \"\"\"\n        logger.warning(\n            \"Error notifying on bind for %s: %s - rescheduling\", assoc[\"mxid\"], error\n        )\n        self.sydent.reactor.callLater(\n            math.pow(2, attempt), self._notify, assoc, attempt + 1\n        )\n\n    # The below is lovingly ripped off of synapse/http/endpoint.py\n\n    _Server = collections.namedtuple(\"_Server\", \"priority weight host port\")\n", "# -*- coding: utf-8 -*-\n# Copyright 2020 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport re\nfrom typing import Optional, Tuple\n\nfrom twisted.internet.abstract import isIPAddress, isIPv6Address\n\n# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken\nclient_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")\n\n# hostname/domain name\n# https://regex101.com/r/OyN1lg/2\nhostname_regex = re.compile(\n    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",\n    flags=re.IGNORECASE)\n\n\ndef is_valid_client_secret(client_secret):\n    \"\"\"Validate that a given string matches the client_secret regex defined by the spec\n\n    :param client_secret: The client_secret to validate\n    :type client_secret: str\n\n    :return: Whether the client_secret is valid\n    :rtype: bool\n    \"\"\"\n    return client_secret_regex.match(client_secret) is not None\n\n\ndef is_valid_hostname(string: str) -> bool:\n    \"\"\"Validate that a given string is a valid hostname or domain name.\n\n    For domain names, this only validates that the form is right (for\n    instance, it doesn't check that the TLD is valid).\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid hostname\n    :rtype: bool\n    \"\"\"\n\n    return hostname_regex.match(string) is not None\n\n\ndef parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:\n    \"\"\"Split a server name into host/port parts.\n\n    No validation is done on the host part. The port part is validated to be\n    a valid port number.\n\n    Args:\n        server_name: server name to parse\n\n    Returns:\n        host/port parts.\n\n    Raises:\n        ValueError if the server name could not be parsed.\n    \"\"\"\n    try:\n        if server_name[-1] == \"]\":\n            # ipv6 literal, hopefully\n            return server_name, None\n\n        host_port = server_name.rsplit(\":\", 1)\n        host = host_port[0]\n        port = host_port[1] if host_port[1:] else None\n\n        if port:\n            port_num = int(port)\n\n            # exclude things like '08090' or ' 8090'\n            if port != str(port_num) or not (1 <= port_num < 65536):\n                raise ValueError(\"Invalid port\")\n\n        return host, port\n    except Exception:\n        raise ValueError(\"Invalid server name '%s'\" % server_name)\n\n\ndef is_valid_matrix_server_name(string: str) -> bool:\n    \"\"\"Validate that the given string is a valid Matrix server name.\n\n    A string is a valid Matrix server name if it is one of the following, plus\n    an optional port:\n\n    a. IPv4 address\n    b. IPv6 literal (`[IPV6_ADDRESS]`)\n    c. A valid hostname\n\n    :param string: The string to validate\n    :type string: str\n\n    :return: Whether the input is a valid Matrix server name\n    :rtype: bool\n    \"\"\"\n\n    try:\n        host, port = parse_server_name(string)\n    except ValueError:\n        return False\n\n    valid_ipv4_addr = isIPAddress(host)\n    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])\n\n    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)\n", "# -*- coding: utf-8 -*-\n\n# Copyright 2021 The Matrix.org Foundation C.I.C.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom twisted.trial import unittest\n\nfrom tests.utils import make_request, make_sydent\n\n\nclass RegisterTestCase(unittest.TestCase):\n    \"\"\"Tests Sydent's register servlet\"\"\"\n\n    def setUp(self):\n        # Create a new sydent\n        self.sydent = make_sydent()\n\n    def test_sydent_rejects_invalid_hostname(self):\n        \"\"\"Tests that the /register endpoint rejects an invalid hostname passed as matrix_server_name\"\"\"\n        self.sydent.run()\n\n        bad_hostname = \"example.com#\"\n\n        request, channel = make_request(\n            self.sydent.reactor,\n            \"POST\",\n            \"/_matrix/identity/v2/account/register\",\n            content={\n                \"matrix_server_name\": bad_hostname,\n                \"access_token\": \"foo\"\n            })\n\n        request.render(self.sydent.servlets.registerServlet)\n\n        self.assertEqual(channel.code, 400)\n", "from twisted.trial import unittest\nfrom sydent.util.stringutils import is_valid_matrix_server_name\n\n\nclass UtilTests(unittest.TestCase):\n    \"\"\"Tests Sydent utility functions.\"\"\"\n\n    def test_is_valid_matrix_server_name(self):\n        \"\"\"Tests that the is_valid_matrix_server_name function accepts only\n        valid hostnames (or domain names), with optional port number.\n        \"\"\"\n        self.assertTrue(is_valid_matrix_server_name(\"9.9.9.9\"))\n        self.assertTrue(is_valid_matrix_server_name(\"9.9.9.9:4242\"))\n        self.assertTrue(is_valid_matrix_server_name(\"[::]\"))\n        self.assertTrue(is_valid_matrix_server_name(\"[::]:4242\"))\n        self.assertTrue(is_valid_matrix_server_name(\"[a:b:c::]:4242\"))\n\n        self.assertTrue(is_valid_matrix_server_name(\"example.com\"))\n        self.assertTrue(is_valid_matrix_server_name(\"EXAMPLE.COM\"))\n        self.assertTrue(is_valid_matrix_server_name(\"ExAmPlE.CoM\"))\n        self.assertTrue(is_valid_matrix_server_name(\"example.com:4242\"))\n        self.assertTrue(is_valid_matrix_server_name(\"localhost\"))\n        self.assertTrue(is_valid_matrix_server_name(\"localhost:9000\"))\n        self.assertTrue(is_valid_matrix_server_name(\"a.b.c.d:1234\"))\n\n        self.assertFalse(is_valid_matrix_server_name(\"[:::]\"))\n        self.assertFalse(is_valid_matrix_server_name(\"a:b:c::\"))\n\n        self.assertFalse(is_valid_matrix_server_name(\"example.com:65536\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com:0\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com:-1\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com:a\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com: \"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com:04242\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com: 4242\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com/example.com\"))\n        self.assertFalse(is_valid_matrix_server_name(\"example.com#example.com\"))\n"], "filenames": ["sydent/hs_federation/verifier.py", "sydent/http/servlets/registerservlet.py", "sydent/threepid/bind.py", "sydent/util/stringutils.py", "tests/test_register.py", "tests/test_util.py"], "buggy_code_start_loc": [28, 28, 35, 15, 23, 2], "buggy_code_end_loc": [210, 93, 188, 71, 23, 27], "fixing_code_start_loc": [28, 28, 35, 16, 24, 2], "fixing_code_end_loc": [210, 93, 188, 120, 25, 38], "type": "CWE-20", "message": "Sydent is a reference Matrix identity server. Sydent can be induced to send HTTP GET requests to internal systems, due to lack of parameter validation or IP address blacklisting. It is not possible to exfiltrate data or control request headers, but it might be possible to use the attack to perform an internal port enumeration. This issue has been addressed in in 9e57334, 8936925, 3d531ed, 0f00412. A potential workaround would be to use a firewall to ensure that Sydent cannot reach internal HTTP resources.", "other": {"cve": {"id": "CVE-2021-29431", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-15T21:15:17.520", "lastModified": "2021-04-22T15:27:01.050", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sydent is a reference Matrix identity server. Sydent can be induced to send HTTP GET requests to internal systems, due to lack of parameter validation or IP address blacklisting. It is not possible to exfiltrate data or control request headers, but it might be possible to use the attack to perform an internal port enumeration. This issue has been addressed in in 9e57334, 8936925, 3d531ed, 0f00412. A potential workaround would be to use a firewall to ensure that Sydent cannot reach internal HTTP resources."}, {"lang": "es", "value": "Sydent es un servidor de identidad Matrix de referencia. Sydent puede ser inducido a enviar peticiones HTTP GET hacia sistemas internos, debido a una falta de comprobaci\u00f3n de par\u00e1metros o la lista negra de direcciones IP.&#xa0;No es posible exfiltrar datos o controlar los encabezados de peticiones, pero podr\u00eda ser posible utilizar el ataque para llevar a cabo una enumeraci\u00f3n de puertos internos.&#xa0;Este problema ha sido abordado en 9e57334, 8936925, 3d531ed, 0f00412.&#xa0;Una posible soluci\u00f3n alternativa ser\u00eda utilizar un firewall para garantizar que Sydent no pueda acceder a los recursos HTTP internos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:sydent:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "C77C5A80-7302-49F8-8DAA-37B269691C9C"}]}]}], "references": [{"url": "https://github.com/matrix-org/sydent/commit/0f00412017f25619bc36c264b29ea96808bf310a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/sydent/commit/3d531ed50d2fd41ac387f36d44d3fb2c62dd22d3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/sydent/commit/8936925f561b0c352c2fa922d5097d7245aad00a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/sydent/commit/9e573348d81df8191bbe8c266c01999c9d57cd5f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/sydent/releases/tag/v2.3.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/sydent/security/advisories/GHSA-9jhm-8m8c-c3f4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pypi.org/project/matrix-sydent/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/sydent/commit/0f00412017f25619bc36c264b29ea96808bf310a"}}