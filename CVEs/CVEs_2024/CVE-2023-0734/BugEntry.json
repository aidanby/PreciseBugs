{"buggy_code": ["<?php\n\nnamespace Wallabag\\CoreBundle\\Controller;\n\nuse Doctrine\\ORM\\QueryBuilder;\nuse Pagerfanta\\Adapter\\ArrayAdapter;\nuse Pagerfanta\\Exception\\OutOfRangeCurrentPageException;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\ParamConverter;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Wallabag\\CoreBundle\\Entity\\Entry;\nuse Wallabag\\CoreBundle\\Entity\\Tag;\nuse Wallabag\\CoreBundle\\Form\\Type\\NewTagType;\nuse Wallabag\\CoreBundle\\Form\\Type\\RenameTagType;\n\nclass TagController extends Controller\n{\n    /**\n     * @Route(\"/new-tag/{entry}\", requirements={\"entry\" = \"\\d+\"}, name=\"new_tag\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function addTagFormAction(Request $request, Entry $entry)\n    {\n        $form = $this->createForm(NewTagType::class, new Tag());\n        $form->handleRequest($request);\n\n        if ($form->isSubmitted() && $form->isValid()) {\n            $this->get('wallabag_core.tags_assigner')->assignTagsToEntry(\n                $entry,\n                $form->get('label')->getData()\n            );\n\n            $em = $this->getDoctrine()->getManager();\n            $em->persist($entry);\n            $em->flush();\n\n            $this->get('session')->getFlashBag()->add(\n                'notice',\n                'flashes.tag.notice.tag_added'\n            );\n\n            return $this->redirect($this->generateUrl('view', ['id' => $entry->getId()]));\n        }\n\n        return $this->render('WallabagCoreBundle:Tag:new_form.html.twig', [\n            'form' => $form->createView(),\n            'entry' => $entry,\n        ]);\n    }\n\n    /**\n     * Removes tag from entry.\n     *\n     * @Route(\"/remove-tag/{entry}/{tag}\", requirements={\"entry\" = \"\\d+\", \"tag\" = \"\\d+\"}, name=\"remove_tag\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function removeTagFromEntry(Request $request, Entry $entry, Tag $tag)\n    {\n        $entry->removeTag($tag);\n        $em = $this->getDoctrine()->getManager();\n        $em->flush();\n\n        // remove orphan tag in case no entries are associated to it\n        if (0 === \\count($tag->getEntries())) {\n            $em->remove($tag);\n            $em->flush();\n        }\n\n        $redirectUrl = $this->get('wallabag_core.helper.redirect')->to($request->headers->get('referer'), '', true);\n\n        return $this->redirect($redirectUrl);\n    }\n\n    /**\n     * Shows tags for current user.\n     *\n     * @Route(\"/tag/list\", name=\"tag\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function showTagAction()\n    {\n        $tags = $this->get('wallabag_core.tag_repository')\n            ->findAllFlatTagsWithNbEntries($this->getUser()->getId());\n        $nbEntriesUntagged = $this->get('wallabag_core.entry_repository')\n            ->countUntaggedEntriesByUser($this->getUser()->getId());\n\n        $renameForms = [];\n        foreach ($tags as $tag) {\n            $renameForms[$tag['id']] = $this->createForm(RenameTagType::class, new Tag())->createView();\n        }\n\n        return $this->render('WallabagCoreBundle:Tag:tags.html.twig', [\n            'tags' => $tags,\n            'renameForms' => $renameForms,\n            'nbEntriesUntagged' => $nbEntriesUntagged,\n        ]);\n    }\n\n    /**\n     * @param int $page\n     *\n     * @Route(\"/tag/list/{slug}/{page}\", name=\"tag_entries\", defaults={\"page\" = \"1\"})\n     * @ParamConverter(\"tag\", options={\"mapping\": {\"slug\": \"slug\"}})\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function showEntriesForTagAction(Tag $tag, $page, Request $request)\n    {\n        $entriesByTag = $this->get('wallabag_core.entry_repository')->findAllByTagId(\n            $this->getUser()->getId(),\n            $tag->getId()\n        );\n\n        $pagerAdapter = new ArrayAdapter($entriesByTag);\n\n        $entries = $this->get('wallabag_core.helper.prepare_pager_for_entries')->prepare($pagerAdapter);\n\n        try {\n            $entries->setCurrentPage($page);\n        } catch (OutOfRangeCurrentPageException $e) {\n            if ($page > 1) {\n                return $this->redirect($this->generateUrl($request->get('_route'), [\n                    'slug' => $tag->getSlug(),\n                    'page' => $entries->getNbPages(),\n                ]), 302);\n            }\n        }\n\n        return $this->render('WallabagCoreBundle:Entry:entries.html.twig', [\n            'form' => null,\n            'entries' => $entries,\n            'currentPage' => $page,\n            'tag' => $tag,\n        ]);\n    }\n\n    /**\n     * Rename a given tag with a new label\n     * Create a new tag with the new name and drop the old one.\n     *\n     * @Route(\"/tag/rename/{slug}\", name=\"tag_rename\")\n     * @ParamConverter(\"tag\", options={\"mapping\": {\"slug\": \"slug\"}})\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function renameTagAction(Tag $tag, Request $request)\n    {\n        $form = $this->createForm(RenameTagType::class, new Tag());\n        $form->handleRequest($request);\n\n        $redirectUrl = $this->get('wallabag_core.helper.redirect')->to($request->headers->get('referer'), '', true);\n\n        if ($form->isSubmitted() && $form->isValid()) {\n            $newTag = new Tag();\n            $newTag->setLabel($form->get('label')->getData());\n\n            if ($newTag->getLabel() === $tag->getLabel()) {\n                return $this->redirect($redirectUrl);\n            }\n\n            $tagFromRepo = $this->get('wallabag_core.tag_repository')->findOneByLabel($newTag->getLabel());\n\n            if (null !== $tagFromRepo) {\n                $newTag = $tagFromRepo;\n            }\n\n            $entries = $this->get('wallabag_core.entry_repository')->findAllByTagId(\n                $this->getUser()->getId(),\n                $tag->getId()\n            );\n            foreach ($entries as $entry) {\n                $this->get('wallabag_core.tags_assigner')->assignTagsToEntry(\n                    $entry,\n                    $newTag->getLabel(),\n                    [$newTag]\n                );\n                $entry->removeTag($tag);\n            }\n\n            $this->getDoctrine()->getManager()->flush();\n\n            $this->get('session')->getFlashBag()->add(\n                'notice',\n                'flashes.tag.notice.tag_renamed'\n            );\n        }\n\n        return $this->redirect($redirectUrl);\n    }\n\n    /**\n     * Tag search results with the current search term.\n     *\n     * @Route(\"/tag/search/{filter}\", name=\"tag_this_search\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function tagThisSearchAction($filter, Request $request)\n    {\n        $currentRoute = $request->query->has('currentRoute') ? $request->query->get('currentRoute') : '';\n\n        /** @var QueryBuilder $qb */\n        $qb = $this->get('wallabag_core.entry_repository')->getBuilderForSearchByUser($this->getUser()->getId(), $filter, $currentRoute);\n        $em = $this->getDoctrine()->getManager();\n\n        $entries = $qb->getQuery()->getResult();\n\n        foreach ($entries as $entry) {\n            $this->get('wallabag_core.tags_assigner')->assignTagsToEntry(\n                $entry,\n                $filter\n            );\n\n            $em->persist($entry);\n        }\n\n        $em->flush();\n\n        return $this->redirect($this->get('wallabag_core.helper.redirect')->to($request->headers->get('referer'), '', true));\n    }\n}\n", "<?php\n\nnamespace Wallabag\\CoreBundle\\Form\\Type;\n\nuse Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass NewTagType extends AbstractType\n{\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            ->add('label', TextType::class, [\n                'required' => true,\n                'attr' => [\n                    'placeholder' => 'tag.new.placeholder',\n                ],\n            ])\n            ->add('add', SubmitType::class, [\n                'label' => 'tag.new.add',\n            ])\n        ;\n    }\n\n    public function configureOptions(OptionsResolver $resolver)\n    {\n        $resolver->setDefaults([\n            'data_class' => 'Wallabag\\CoreBundle\\Entity\\Tag',\n        ]);\n    }\n\n    public function getBlockPrefix()\n    {\n        return 'tag';\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Wallabag\\CoreBundle\\Controller;\n\nuse Doctrine\\ORM\\QueryBuilder;\nuse Pagerfanta\\Adapter\\ArrayAdapter;\nuse Pagerfanta\\Exception\\OutOfRangeCurrentPageException;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\ParamConverter;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Wallabag\\CoreBundle\\Entity\\Entry;\nuse Wallabag\\CoreBundle\\Entity\\Tag;\nuse Wallabag\\CoreBundle\\Form\\Type\\NewTagType;\nuse Wallabag\\CoreBundle\\Form\\Type\\RenameTagType;\n\nclass TagController extends Controller\n{\n    /**\n     * @Route(\"/new-tag/{entry}\", requirements={\"entry\" = \"\\d+\"}, name=\"new_tag\", methods={\"POST\"})\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function addTagFormAction(Request $request, Entry $entry)\n    {\n        $form = $this->createForm(NewTagType::class, new Tag());\n        $form->handleRequest($request);\n\n        $tags = $form->get('label')->getData();\n        $tagsExploded = explode(',', $tags);\n\n        // avoid too much tag to be added\n        if (\\count($tagsExploded) >= 5 || \\strlen($tags) >= NewTagType::MAX_LENGTH) {\n            return $this->redirect($this->generateUrl('view', ['id' => $entry->getId()]));\n        }\n\n        if ($form->isSubmitted() && $form->isValid()) {\n            $this->checkUserAction($entry);\n\n            $this->get('wallabag_core.tags_assigner')->assignTagsToEntry(\n                $entry,\n                $form->get('label')->getData()\n            );\n\n            $em = $this->getDoctrine()->getManager();\n            $em->persist($entry);\n            $em->flush();\n\n            $this->get('session')->getFlashBag()->add(\n                'notice',\n                'flashes.tag.notice.tag_added'\n            );\n\n            return $this->redirect($this->generateUrl('view', ['id' => $entry->getId()]));\n        }\n\n        return $this->render('WallabagCoreBundle:Tag:new_form.html.twig', [\n            'form' => $form->createView(),\n            'entry' => $entry,\n        ]);\n    }\n\n    /**\n     * Removes tag from entry.\n     *\n     * @Route(\"/remove-tag/{entry}/{tag}\", requirements={\"entry\" = \"\\d+\", \"tag\" = \"\\d+\"}, name=\"remove_tag\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function removeTagFromEntry(Request $request, Entry $entry, Tag $tag)\n    {\n        $this->checkUserAction($entry);\n\n        $entry->removeTag($tag);\n        $em = $this->getDoctrine()->getManager();\n        $em->flush();\n\n        // remove orphan tag in case no entries are associated to it\n        if (0 === \\count($tag->getEntries())) {\n            $em->remove($tag);\n            $em->flush();\n        }\n\n        $redirectUrl = $this->get('wallabag_core.helper.redirect')->to($request->headers->get('referer'), '', true);\n\n        return $this->redirect($redirectUrl);\n    }\n\n    /**\n     * Shows tags for current user.\n     *\n     * @Route(\"/tag/list\", name=\"tag\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function showTagAction()\n    {\n        $tags = $this->get('wallabag_core.tag_repository')\n            ->findAllFlatTagsWithNbEntries($this->getUser()->getId());\n        $nbEntriesUntagged = $this->get('wallabag_core.entry_repository')\n            ->countUntaggedEntriesByUser($this->getUser()->getId());\n\n        $renameForms = [];\n        foreach ($tags as $tag) {\n            $renameForms[$tag['id']] = $this->createForm(RenameTagType::class, new Tag())->createView();\n        }\n\n        return $this->render('WallabagCoreBundle:Tag:tags.html.twig', [\n            'tags' => $tags,\n            'renameForms' => $renameForms,\n            'nbEntriesUntagged' => $nbEntriesUntagged,\n        ]);\n    }\n\n    /**\n     * @param int $page\n     *\n     * @Route(\"/tag/list/{slug}/{page}\", name=\"tag_entries\", defaults={\"page\" = \"1\"})\n     * @ParamConverter(\"tag\", options={\"mapping\": {\"slug\": \"slug\"}})\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function showEntriesForTagAction(Tag $tag, $page, Request $request)\n    {\n        $entriesByTag = $this->get('wallabag_core.entry_repository')->findAllByTagId(\n            $this->getUser()->getId(),\n            $tag->getId()\n        );\n\n        $pagerAdapter = new ArrayAdapter($entriesByTag);\n\n        $entries = $this->get('wallabag_core.helper.prepare_pager_for_entries')->prepare($pagerAdapter);\n\n        try {\n            $entries->setCurrentPage($page);\n        } catch (OutOfRangeCurrentPageException $e) {\n            if ($page > 1) {\n                return $this->redirect($this->generateUrl($request->get('_route'), [\n                    'slug' => $tag->getSlug(),\n                    'page' => $entries->getNbPages(),\n                ]), 302);\n            }\n        }\n\n        return $this->render('WallabagCoreBundle:Entry:entries.html.twig', [\n            'form' => null,\n            'entries' => $entries,\n            'currentPage' => $page,\n            'tag' => $tag,\n        ]);\n    }\n\n    /**\n     * Rename a given tag with a new label\n     * Create a new tag with the new name and drop the old one.\n     *\n     * @Route(\"/tag/rename/{slug}\", name=\"tag_rename\")\n     * @ParamConverter(\"tag\", options={\"mapping\": {\"slug\": \"slug\"}})\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function renameTagAction(Tag $tag, Request $request)\n    {\n        $form = $this->createForm(RenameTagType::class, new Tag());\n        $form->handleRequest($request);\n\n        $redirectUrl = $this->get('wallabag_core.helper.redirect')->to($request->headers->get('referer'), '', true);\n\n        if ($form->isSubmitted() && $form->isValid()) {\n            $newTag = new Tag();\n            $newTag->setLabel($form->get('label')->getData());\n\n            if ($newTag->getLabel() === $tag->getLabel()) {\n                return $this->redirect($redirectUrl);\n            }\n\n            $tagFromRepo = $this->get('wallabag_core.tag_repository')->findOneByLabel($newTag->getLabel());\n\n            if (null !== $tagFromRepo) {\n                $newTag = $tagFromRepo;\n            }\n\n            $entries = $this->get('wallabag_core.entry_repository')->findAllByTagId(\n                $this->getUser()->getId(),\n                $tag->getId()\n            );\n            foreach ($entries as $entry) {\n                $this->get('wallabag_core.tags_assigner')->assignTagsToEntry(\n                    $entry,\n                    $newTag->getLabel(),\n                    [$newTag]\n                );\n                $entry->removeTag($tag);\n            }\n\n            $this->getDoctrine()->getManager()->flush();\n\n            $this->get('session')->getFlashBag()->add(\n                'notice',\n                'flashes.tag.notice.tag_renamed'\n            );\n        }\n\n        return $this->redirect($redirectUrl);\n    }\n\n    /**\n     * Tag search results with the current search term.\n     *\n     * @Route(\"/tag/search/{filter}\", name=\"tag_this_search\")\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     */\n    public function tagThisSearchAction($filter, Request $request)\n    {\n        $currentRoute = $request->query->has('currentRoute') ? $request->query->get('currentRoute') : '';\n\n        /** @var QueryBuilder $qb */\n        $qb = $this->get('wallabag_core.entry_repository')->getBuilderForSearchByUser($this->getUser()->getId(), $filter, $currentRoute);\n        $em = $this->getDoctrine()->getManager();\n\n        $entries = $qb->getQuery()->getResult();\n\n        foreach ($entries as $entry) {\n            $this->get('wallabag_core.tags_assigner')->assignTagsToEntry(\n                $entry,\n                $filter\n            );\n\n            $em->persist($entry);\n        }\n\n        $em->flush();\n\n        return $this->redirect($this->get('wallabag_core.helper.redirect')->to($request->headers->get('referer'), '', true));\n    }\n\n    /**\n     * Check if the logged user can manage the given entry.\n     */\n    private function checkUserAction(Entry $entry)\n    {\n        if (null === $this->getUser() || $this->getUser()->getId() !== $entry->getUser()->getId()) {\n            throw $this->createAccessDeniedException('You can not access this entry.');\n        }\n    }\n}\n", "<?php\n\nnamespace Wallabag\\CoreBundle\\Form\\Type;\n\nuse Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\SubmitType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass NewTagType extends AbstractType\n{\n    public const MAX_LENGTH = 40;\n\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            ->add('label', TextType::class, [\n                'required' => true,\n                'attr' => [\n                    'placeholder' => 'tag.new.placeholder',\n                    'max_length' => self::MAX_LENGTH,\n                ],\n            ])\n            ->add('add', SubmitType::class, [\n                'label' => 'tag.new.add',\n            ])\n        ;\n    }\n\n    public function configureOptions(OptionsResolver $resolver)\n    {\n        $resolver->setDefaults([\n            'data_class' => 'Wallabag\\CoreBundle\\Entity\\Tag',\n        ]);\n    }\n\n    public function getBlockPrefix()\n    {\n        return 'tag';\n    }\n}\n"], "filenames": ["src/Wallabag/CoreBundle/Controller/TagController.php", "src/Wallabag/CoreBundle/Form/Type/NewTagType.php"], "buggy_code_start_loc": [20, 12], "buggy_code_end_loc": [224, 19], "fixing_code_start_loc": [20, 13], "fixing_code_end_loc": [247, 23], "type": "CWE-285", "message": "Improper Authorization in GitHub repository wallabag/wallabag prior to 2.5.4.", "other": {"cve": {"id": "CVE-2023-0734", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-05T21:15:10.027", "lastModified": "2023-03-09T20:55:01.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository wallabag/wallabag prior to 2.5.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wallabag:wallabag:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.4", "matchCriteriaId": "D5F56D3B-7045-4633-9208-6605904F3584"}]}]}], "references": [{"url": "https://github.com/wallabag/wallabag/commit/acd285dcbb71b595e6320bb1d0d3a44cdf646ac0", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/a296324c-6925-4f5f-a729-39b0d73d5b8b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wallabag/wallabag/commit/acd285dcbb71b595e6320bb1d0d3a44cdf646ac0"}}