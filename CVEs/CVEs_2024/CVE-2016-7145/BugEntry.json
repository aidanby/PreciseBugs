{"buggy_code": ["/*\n * IRC - Internet Relay Chat, ircd/m_authenticate.c\n * Copyright (C) 2013 Matthew Beeching (Jobe)\n * Copyright (C) 1990 Jarkko Oikarinen and\n *                    University of Oulu, Computing Center\n *\n * See file AUTHORS in IRC package for additional names of\n * the programmers.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 1, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n * $Id:$\n */\n\n/*\n * m_functions execute protocol messages on this server:\n *\n *    cptr    is always NON-NULL, pointing to a *LOCAL* client\n *            structure (with an open socket connected!). This\n *            identifies the physical socket where the message\n *            originated (or which caused the m_function to be\n *            executed--some m_functions may call others...).\n *\n *    sptr    is the source of the message, defined by the\n *            prefix part of the message if present. If not\n *            or prefix not found, then sptr==cptr.\n *\n *            (!IsServer(cptr)) => (cptr == sptr), because\n *            prefixes are taken *only* from servers...\n *\n *            (IsServer(cptr))\n *                    (sptr == cptr) => the message didn't\n *                    have the prefix.\n *\n *                    (sptr != cptr && IsServer(sptr) means\n *                    the prefix specified servername. (?)\n *\n *                    (sptr != cptr && !IsServer(sptr) means\n *                    that message originated from a remote\n *                    user (not local).\n *\n *            combining\n *\n *            (!IsServer(sptr)) means that, sptr can safely\n *            taken as defining the target structure of the\n *            message in this server.\n *\n *    *Always* true (if 'parse' and others are working correct):\n *\n *    1)      sptr->from == cptr  (note: cptr->from == cptr)\n *\n *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr\n *            *cannot* be a local connection, unless it's\n *            actually cptr!). [MyConnect(x) should probably\n *            be defined as (x == x->from) --msa ]\n *\n *    parc    number of variable parameter strings (if zero,\n *            parv is allowed to be NULL)\n *\n *    parv    a NULL terminated list of parameter pointers,\n *\n *                    parv[0], sender (prefix string), if not present\n *                            this points to an empty string.\n *                    parv[1]...parv[parc-1]\n *                            pointers to additional parameters\n *                    parv[parc] == NULL, *always*\n *\n *            note:   it is guaranteed that parv[0]..parv[parc-1] are all\n *                    non-NULL pointers.\n */\n#include \"config.h\"\n\n#include \"client.h\"\n#include \"ircd.h\"\n#include \"ircd_features.h\"\n#include \"ircd_log.h\"\n#include \"ircd_reply.h\"\n#include \"ircd_string.h\"\n#include \"ircd_snprintf.h\"\n#include \"msg.h\"\n#include \"numeric.h\"\n#include \"numnicks.h\"\n#include \"random.h\"\n#include \"send.h\"\n#include \"s_misc.h\"\n#include \"s_user.h\"\n\n/* #include <assert.h> -- Now using assert in ircd_log.h */\n\nstatic void sasl_timeout_callback(struct Event* ev);\n\nint m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc < 2) /* have enough parameters? */\n    return need_more_params(cptr, \"AUTHENTICATE\");\n\n  if (strlen(parv[1]) > 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n    return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\n\n  /* If it's to us, do nothing; otherwise, forward the query */\n  if (acptr && IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, ':') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n\n  if (acptr) {\n    if (first) {\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  } else {\n    if (first) {\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&cli_sasltimeout(cptr)))\n    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}\n\n/** Timeout a given SASL auth request.\n * @param[in] ev A timer event whose associated data is the expired\n *   struct AuthRequest.\n */\nstatic void sasl_timeout_callback(struct Event* ev)\n{\n  struct Client *cptr;\n\n  assert(0 != ev_timer(ev));\n  assert(0 != t_data(ev_timer(ev)));\n\n  if (ev_type(ev) == ET_EXPIRE) {\n    cptr = (struct Client*) t_data(ev_timer(ev));\n\n   abort_sasl(cptr, 1);\n  }\n}\n\n"], "fixing_code": ["/*\n * IRC - Internet Relay Chat, ircd/m_authenticate.c\n * Copyright (C) 2013 Matthew Beeching (Jobe)\n * Copyright (C) 1990 Jarkko Oikarinen and\n *                    University of Oulu, Computing Center\n *\n * See file AUTHORS in IRC package for additional names of\n * the programmers.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 1, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n * $Id:$\n */\n\n/*\n * m_functions execute protocol messages on this server:\n *\n *    cptr    is always NON-NULL, pointing to a *LOCAL* client\n *            structure (with an open socket connected!). This\n *            identifies the physical socket where the message\n *            originated (or which caused the m_function to be\n *            executed--some m_functions may call others...).\n *\n *    sptr    is the source of the message, defined by the\n *            prefix part of the message if present. If not\n *            or prefix not found, then sptr==cptr.\n *\n *            (!IsServer(cptr)) => (cptr == sptr), because\n *            prefixes are taken *only* from servers...\n *\n *            (IsServer(cptr))\n *                    (sptr == cptr) => the message didn't\n *                    have the prefix.\n *\n *                    (sptr != cptr && IsServer(sptr) means\n *                    the prefix specified servername. (?)\n *\n *                    (sptr != cptr && !IsServer(sptr) means\n *                    that message originated from a remote\n *                    user (not local).\n *\n *            combining\n *\n *            (!IsServer(sptr)) means that, sptr can safely\n *            taken as defining the target structure of the\n *            message in this server.\n *\n *    *Always* true (if 'parse' and others are working correct):\n *\n *    1)      sptr->from == cptr  (note: cptr->from == cptr)\n *\n *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr\n *            *cannot* be a local connection, unless it's\n *            actually cptr!). [MyConnect(x) should probably\n *            be defined as (x == x->from) --msa ]\n *\n *    parc    number of variable parameter strings (if zero,\n *            parv is allowed to be NULL)\n *\n *    parv    a NULL terminated list of parameter pointers,\n *\n *                    parv[0], sender (prefix string), if not present\n *                            this points to an empty string.\n *                    parv[1]...parv[parc-1]\n *                            pointers to additional parameters\n *                    parv[parc] == NULL, *always*\n *\n *            note:   it is guaranteed that parv[0]..parv[parc-1] are all\n *                    non-NULL pointers.\n */\n#include \"config.h\"\n\n#include \"client.h\"\n#include \"ircd.h\"\n#include \"ircd_features.h\"\n#include \"ircd_log.h\"\n#include \"ircd_reply.h\"\n#include \"ircd_string.h\"\n#include \"ircd_snprintf.h\"\n#include \"msg.h\"\n#include \"numeric.h\"\n#include \"numnicks.h\"\n#include \"random.h\"\n#include \"send.h\"\n#include \"s_misc.h\"\n#include \"s_user.h\"\n\n/* #include <assert.h> -- Now using assert in ircd_log.h */\n\nstatic void sasl_timeout_callback(struct Event* ev);\n\nint m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc < 2) /* have enough parameters? */\n    return need_more_params(cptr, \"AUTHENTICATE\");\n\n  if (strlen(parv[1]) > 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n    return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\n\n  /* If it's to us, do nothing; otherwise, forward the query */\n  if (acptr && IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, ':') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n\n  if (acptr) {\n    if (first) {\n      if (*parv[1] == ':' || strchr(parv[1], ' '))\n\t\treturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  } else {\n    if (first) {\n      if (*parv[1] == ':' || strchr(parv[1], ' '))\n        return exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&cli_sasltimeout(cptr)))\n    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}\n\n/** Timeout a given SASL auth request.\n * @param[in] ev A timer event whose associated data is the expired\n *   struct AuthRequest.\n */\nstatic void sasl_timeout_callback(struct Event* ev)\n{\n  struct Client *cptr;\n\n  assert(0 != ev_timer(ev));\n  assert(0 != t_data(ev_timer(ev)));\n\n  if (ev_type(ev) == ET_EXPIRE) {\n    cptr = (struct Client*) t_data(ev_timer(ev));\n\n   abort_sasl(cptr, 1);\n  }\n}\n\n"], "filenames": ["ircd/m_authenticate.c"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [169], "fixing_code_start_loc": [153], "fixing_code_end_loc": [174], "type": "CWE-287", "message": "The m_authenticate function in ircd/m_authenticate.c in nefarious2 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.", "other": {"cve": {"id": "CVE-2016-7145", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-07T15:59:00.360", "lastModified": "2017-03-08T17:06:21.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The m_authenticate function in ircd/m_authenticate.c in nefarious2 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter."}, {"lang": "es", "value": "Una vulnerabilidad de elevaci\u00f3n de privilegios en el verificador de recuperaci\u00f3n podr\u00eda permitir a una aplicaci\u00f3n local maliciosa ejecutar c\u00f3digo arbitrario en el contexto del kernel. Este problema est\u00e1 calificado como Critical debido a la posibilidad de que el dispositivo sea comprometido localmente de forma permanente, que puede requerir reflashing del sistema operativo para reparar el dispositivo. Producto: Android. Versiones: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. ID de Android: A-31914369."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nefarious2_project:nefarious2:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8D8E8B5E-4947-4317-82C4-D1098F127C8C"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/05/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5"}}