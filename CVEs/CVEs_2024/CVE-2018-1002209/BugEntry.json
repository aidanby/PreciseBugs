{"buggy_code": ["QuaZIP changes\n\n* 0.7.5\n        * Fixed target_link_libraries call in CMakeLists\n        * Worked around a Qt 4.6 bug (QTBUG-15421) screwing up hidden\n          files handling in JlCompress::compressDir()\n        * Removed Q_FOREACH uses to avoid conflicts (SF patch #32)\n\n* 2017-02-05 0.7.4\n        * Static analysis patch from Intel Deutschland GmbH\n        * Replaced UNUSED with QUAZIP_UNUSED to avoid name clashes\n        * Minor bug fixes\n\n* 2017-02-05 0.7.3\n        * Symlink handling\n        * Static linking exception for LGPL\n        * Minor bug fixes\n\n* 2016-03-29 0.7.2\n        * New JlCompress methods (QIODevice*-based API by Lukasz Kwiecinski)\n        * Implemented QuaZioDevice::atEnd() and bytesAvailable()--these might\n          break ABI, but pretty unlikely.\n\n* 2015-01-07 0.7.1\n        * Fixed licensing issues (bug #45).\n        * Added the convenience method QuaZipFileInfo::isEncrypted().\n\n* 2014-07-24 0.7\n        * It is now possible to write ZIP files to sequential devices\n          like sockets (only in mdCreate mode, so no self-extract, sorry).\n        * A few zip64 fixes.\n        * Several bug fixes and portability improvements.\n\n* 2014-02-09 0.6.2\n        * QuaZipNewInfo / QuaZipFileInfo64 now provide API to access/set\n          NTFS time stamps - useful even on non-NTFS systems if you \n          need more precise dates and times than default ones.\n        * QuaZipNewInfo may now be initialized from QuaZipFileInfo64.\n        * No more crashes when using QSaveFile as QIODevice for ZIP.\n        * The new QuaZip::setAutoClose() method allows to leave the\n          QIODevice open when you close the QuaZip instance.\n        * qztest now depends on quazip, no longer breaking the build.\n\n* 2014-01-26 0.6.1\n        * Improved zip64 support.\n        * A LOT more tests thanks to g++ --coverage / lcov.\n        * JlCompress extraction methods now create files with default\n          permissions if they are zero in the original archive.\n        * Some QuaZipDir fixes (thanks to the new tests).\n\n* 2014-01-22 0.6\n        * Minizip updated to 1.1 (with all the necessary modifications\n          re-done), and that means that...\n        * the long-awaited zip64 support is now available!\n        * A few rather minor fixes.\n\n* 2014-01-19 0.5.2\n        * Some minor bug fixes.\n        * API to access file permissions subfield of the external\n          attributes.\n        * MS VS 2012 Express support.\n        * API to set the default codec used to encode/decode file names\n          (mainly for use by various wrappers such as JlCompress, when\n          you don't have direct access to the underlying QuaZip instance).\n\n* 2013-03-02 0.5.1\n        * Lots of QuaZipDir fixes, thanks to all bug reporters.\n        * Full Qt Creator support.\n        * MS VS 2010 Express support.\n        * Qt5 support (didn't need any source code changes anyway).\n        * Lots of minor bug fixes.\n\n* 2012-09-07 0.5\n        * Added run_moc.bat files for building under Windows in case Qt\n          integration is not available (e. g. VS 2008 Express).\n        * Added the QuaZipDir class to simplify ZIP navigation in terms\n          of directories.\n        * Added the QuaGzipFile class for working with GZIP archives. It\n          was added as a bonus since it has nothing to do with the main\n          purpose of the library. It probably won't get any major\n          improvements, although minor bug fixes are possible.\n        * Added the QuaZIODevice class for working with zlib\n          compression. It has nothing to do with the ZIP format, and\n          therefore the same notice as for the QuaGzipFile applies.\n        * The global comment is no longer erased when adding files to\n          an archive.\n        * Many bug fixes.\n\n* 2012-01-14 0.4.4\n        * Fixed isSequential() test that was causing open() failures on\n          Unix.\n        * Fixed sub-directory compressing in JlCompress.\n        * Added MS VS 2008 solution, compatible with the binary Qt\n          distribution (tested on MS VS 2008 Express, had to run MOC\n          manually due to the lack of plugin in Express).\n        * Fixed extracting directories in JlCompress.\n        * Fixed JlCompress.h includes in the test suite, which used\n          lowercase names thus breaking on case-sensitive systems.\n        * Implemented missing QuaZipFile::getZip() that was only\n          declared.\n        * Fixed reopening closed files.\n        * Fixed possible memory leak in case of open error.\n\n* 2011-09-09 0.4.3\n        * New test suite using QTestLib.\n        * Fixed bytesAvailable(), pos() and atEnd().\n        * Added ZIP v1.0 support and disabling data descriptor for\n          compatibility with some older software.\n        * Fixed DLL export/import issues for some symbols.\n        * Added QUAZIP_STATIC macro for compiling as a static library or\n          directly including the source.\n        * Added getFileNameList() and getFileInfoList() convenience\n          functions.\n        * Added some buffering to JlCompress to improve performance.\n\n* 2011-08-10 0.4.2\n        * Cmake patch (thanks to Bernhard Rosenkraenzer).\n        * Symbian patch (thanks to Hamish Willee).\n        * Documented the multiple files limitation of QuaZipFile.\n        * Fixed relative paths handling in JlCompress.\n        * Fixed linking to MinGW zlib.\n\n* 2011-05-26 0.4.1\n        * License statement updated to avoid confusion. GPL license\n        removed for the very same reason.\n        * Parts of original package are now clearly marked as modified,\n        just as their license requires.\n\n* 2011-05-23 0.4\n        * QuaZip and QuaZipFile classes now use the Pimpl idiom. This\n        means that future releases will probably be binary compatible\n        with this one, but it also means that this one is binary\n        incompatible with the old ones.\n        * IO API has been rewritten using QIODevice instead of standard\n        C library. Among other things it means that QuaZip now supports\n        files up to 4 GB in size instead of 2 GB.\n        * Added QuaZip methods allowing access to ZIP files represented\n        by any seekable QIODevice implementation (QBuffer is a good\n        example).\n\n* 2010-07-23 0.3\n        * Fixed getComment() for global comments.\n        * Added some useful classes for calculating checksums (thanks to\n        Adam Walczak).\n        * Added some utility classes for working with whole directories\n        (thanks to Roberto Pompermaier). It would be nice if someone\n        documents these in English, though.\n        * Probably fixed some problems with passwords (thanks to Vasiliy\n        Sorokin). I didn't test it, though.\n\n* 2008-09-17 0.2.3\n        * Fixed license notices in sources.\n\n* SVN\n        * Fixed a small bug in QuaZipFile::atEnd().\n\n* 2007-01-16 0.2.2\n        * Added LGPL as alternative license.\n        * Added FAQ documentation page.\n\n* 2006-03-21 0.2.1\n        * Fixed setCommentCodec() bug.\n        * Fixed bug that set month 1-12 instead of 0-11, as specified in\n          zip.h.\n        * Added workaround for Qt's bug that caused wrong timestamps.\n        * Few documentation fixes and cosmetic changes.\n\n* 2005-07-08 0.2\n        * Write support.\n        * Extended QuaZipFile API, including size(), *pos() functions.\n        * Support for comments encoding/decoding.\n\n* 2005-07-01 0.1\n        * Initial version.\n", "/*\nCopyright (C) 2010 Roberto Pompermaier\nCopyright (C) 2005-2014 Sergey A. Tachenov\n\nThis file is part of QuaZIP.\n\nQuaZIP is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 2.1 of the License, or\n(at your option) any later version.\n\nQuaZIP is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with QuaZIP.  If not, see <http://www.gnu.org/licenses/>.\n\nSee COPYING file for the full LGPL text.\n\nOriginal ZIP package is copyrighted by Gilles Vollant and contributors,\nsee quazip/(un)zip.h files for details. Basically it's the zlib license.\n*/\n\n#include \"JlCompress.h\"\n#include <QDebug>\n\nstatic bool copyData(QIODevice &inFile, QIODevice &outFile)\n{\n    while (!inFile.atEnd()) {\n        char buf[4096];\n        qint64 readLen = inFile.read(buf, 4096);\n        if (readLen <= 0)\n            return false;\n        if (outFile.write(buf, readLen) != readLen)\n            return false;\n    }\n    return true;\n}\n\nbool JlCompress::compressFile(QuaZip* zip, QString fileName, QString fileDest) {\n    // zip: oggetto dove aggiungere il file\n    // fileName: nome del file reale\n    // fileDest: nome del file all'interno del file compresso\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip->getMode()!=QuaZip::mdCreate &&\n        zip->getMode()!=QuaZip::mdAppend &&\n        zip->getMode()!=QuaZip::mdAdd) return false;\n\n    // Apro il file originale\n    QFile inFile;\n    inFile.setFileName(fileName);\n    if(!inFile.open(QIODevice::ReadOnly)) return false;\n\n    // Apro il file risulato\n    QuaZipFile outFile(zip);\n    if(!outFile.open(QIODevice::WriteOnly, QuaZipNewInfo(fileDest, inFile.fileName()))) return false;\n\n    // Copio i dati\n    if (!copyData(inFile, outFile) || outFile.getZipError()!=UNZ_OK) {\n        return false;\n    }\n\n    // Chiudo i file\n    outFile.close();\n    if (outFile.getZipError()!=UNZ_OK) return false;\n    inFile.close();\n\n    return true;\n}\n\nbool JlCompress::compressSubDir(QuaZip* zip, QString dir, QString origDir, bool recursive, QDir::Filters filters) {\n    // zip: oggetto dove aggiungere il file\n    // dir: cartella reale corrente\n    // origDir: cartella reale originale\n    // (path(dir)-path(origDir)) = path interno all'oggetto zip\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip->getMode()!=QuaZip::mdCreate &&\n        zip->getMode()!=QuaZip::mdAppend &&\n        zip->getMode()!=QuaZip::mdAdd) return false;\n\n    // Controllo la cartella\n    QDir directory(dir);\n    if (!directory.exists()) return false;\n\n    QDir origDirectory(origDir);\n\tif (dir != origDir) {\n\t\tQuaZipFile dirZipFile(zip);\n\t\tif (!dirZipFile.open(QIODevice::WriteOnly,\n\t\t\tQuaZipNewInfo(origDirectory.relativeFilePath(dir) + \"/\", dir), 0, 0, 0)) {\n\t\t\t\treturn false;\n\t\t}\n\t\tdirZipFile.close();\n\t}\n\n\n    // Se comprimo anche le sotto cartelle\n    if (recursive) {\n        // Per ogni sotto cartella\n        QFileInfoList files = directory.entryInfoList(QDir::AllDirs|QDir::NoDotAndDotDot|filters);\n        for (int index = 0; index < files.size(); ++index ) {\n            const QFileInfo & file( files.at( index ) );\n#if QT_VERSION < QT_VERSION_CHECK(4, 7, 4)\n            if (!file.isDir())\n                continue;\n#endif\n            // Comprimo la sotto cartella\n            if(!compressSubDir(zip,file.absoluteFilePath(),origDir,recursive,filters)) return false;\n        }\n    }\n\n    // Per ogni file nella cartella\n    QFileInfoList files = directory.entryInfoList(QDir::Files|filters);\n    for (int index = 0; index < files.size(); ++index ) {\n        const QFileInfo & file( files.at( index ) );\n        // Se non e un file o e il file compresso che sto creando\n        if(!file.isFile()||file.absoluteFilePath()==zip->getZipName()) continue;\n\n        // Creo il nome relativo da usare all'interno del file compresso\n        QString filename = origDirectory.relativeFilePath(file.absoluteFilePath());\n\n        // Comprimo il file\n        if (!compressFile(zip,file.absoluteFilePath(),filename)) return false;\n    }\n\n    return true;\n}\n\nbool JlCompress::extractFile(QuaZip* zip, QString fileName, QString fileDest) {\n    // zip: oggetto dove aggiungere il file\n    // filename: nome del file reale\n    // fileincompress: nome del file all'interno del file compresso\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip->getMode()!=QuaZip::mdUnzip) return false;\n\n    // Apro il file compresso\n    if (!fileName.isEmpty())\n        zip->setCurrentFile(fileName);\n    QuaZipFile inFile(zip);\n    if(!inFile.open(QIODevice::ReadOnly) || inFile.getZipError()!=UNZ_OK) return false;\n\n    // Controllo esistenza cartella file risultato\n    QDir curDir;\n    if (fileDest.endsWith('/')) {\n        if (!curDir.mkpath(fileDest)) {\n            return false;\n        }\n    } else {\n        if (!curDir.mkpath(QFileInfo(fileDest).absolutePath())) {\n            return false;\n        }\n    }\n\n    QuaZipFileInfo64 info;\n    if (!zip->getCurrentFileInfo(&info))\n        return false;\n\n    QFile::Permissions srcPerm = info.getPermissions();\n    if (fileDest.endsWith('/') && QFileInfo(fileDest).isDir()) {\n        if (srcPerm != 0) {\n            QFile(fileDest).setPermissions(srcPerm);\n        }\n        return true;\n    }\n\n    // Apro il file risultato\n    QFile outFile;\n    outFile.setFileName(fileDest);\n    if(!outFile.open(QIODevice::WriteOnly)) return false;\n\n    // Copio i dati\n    if (!copyData(inFile, outFile) || inFile.getZipError()!=UNZ_OK) {\n        outFile.close();\n        removeFile(QStringList(fileDest));\n        return false;\n    }\n    outFile.close();\n\n    // Chiudo i file\n    inFile.close();\n    if (inFile.getZipError()!=UNZ_OK) {\n        removeFile(QStringList(fileDest));\n        return false;\n    }\n\n    if (srcPerm != 0) {\n        outFile.setPermissions(srcPerm);\n    }\n    return true;\n}\n\nbool JlCompress::removeFile(QStringList listFile) {\n    bool ret = true;\n    // Per ogni file\n    for (int i=0; i<listFile.count(); i++) {\n        // Lo elimino\n        ret = ret && QFile::remove(listFile.at(i));\n    }\n    return ret;\n}\n\nbool JlCompress::compressFile(QString fileCompressed, QString file) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Aggiungo il file\n    if (!compressFile(&zip,file,QFileInfo(file).fileName())) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\nbool JlCompress::compressFiles(QString fileCompressed, QStringList files) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Comprimo i file\n    QFileInfo info;\n    for (int index = 0; index < files.size(); ++index ) {\n        const QString & file( files.at( index ) );\n        info.setFile(file);\n        if (!info.exists() || !compressFile(&zip,file,info.fileName())) {\n            QFile::remove(fileCompressed);\n            return false;\n        }\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\nbool JlCompress::compressDir(QString fileCompressed, QString dir, bool recursive) {\n    return compressDir(fileCompressed, dir, recursive, 0);\n}\n\nbool JlCompress::compressDir(QString fileCompressed, QString dir,\n                             bool recursive, QDir::Filters filters)\n{\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Aggiungo i file e le sotto cartelle\n    if (!compressSubDir(&zip,dir,dir,recursive, filters)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\nQString JlCompress::extractFile(QString fileCompressed, QString fileName, QString fileDest) {\n    // Apro lo zip\n    QuaZip zip(fileCompressed);\n    return extractFile(zip, fileName, fileDest);\n}\n\nQString JlCompress::extractFile(QuaZip &zip, QString fileName, QString fileDest)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QString();\n    }\n\n    // Estraggo il file\n    if (fileDest.isEmpty())\n        fileDest = fileName;\n    if (!extractFile(&zip,fileName,fileDest)) {\n        return QString();\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(QStringList(fileDest));\n        return QString();\n    }\n    return QFileInfo(fileDest).absoluteFilePath();\n}\n\nQStringList JlCompress::extractFiles(QString fileCompressed, QStringList files, QString dir) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    return extractFiles(zip, files, dir);\n}\n\nQStringList JlCompress::extractFiles(QuaZip &zip, const QStringList &files, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n\n    // Estraggo i file\n    QStringList extracted;\n    for (int i=0; i<files.count(); i++) {\n        QString absPath = QDir(dir).absoluteFilePath(files.at(i));\n        if (!extractFile(&zip, files.at(i), absPath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absPath);\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}\n\nQStringList JlCompress::extractDir(QString fileCompressed, QString dir) {\n    // Apro lo zip\n    QuaZip zip(fileCompressed);\n    return extractDir(zip, dir);\n}\n\nQStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}\n\nQStringList JlCompress::getFileList(QString fileCompressed) {\n    // Apro lo zip\n    QuaZip* zip = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());\n    return getFileList(zip);\n}\n\nQStringList JlCompress::getFileList(QuaZip *zip)\n{\n    if(!zip->open(QuaZip::mdUnzip)) {\n        delete zip;\n        return QStringList();\n    }\n\n    // Estraggo i nomi dei file\n    QStringList lst;\n    QuaZipFileInfo64 info;\n    for(bool more=zip->goToFirstFile(); more; more=zip->goToNextFile()) {\n      if(!zip->getCurrentFileInfo(&info)) {\n          delete zip;\n          return QStringList();\n      }\n      lst << info.name;\n      //info.name.toLocal8Bit().constData()\n    }\n\n    // Chiudo il file zip\n    zip->close();\n    if(zip->getZipError()!=0) {\n        delete zip;\n        return QStringList();\n    }\n    delete zip;\n    return lst;\n}\n\nQStringList JlCompress::extractDir(QIODevice *ioDevice, QString dir)\n{\n    QuaZip zip(ioDevice);\n    return extractDir(zip, dir);\n}\n\nQStringList JlCompress::getFileList(QIODevice *ioDevice)\n{\n    QuaZip *zip = new QuaZip(ioDevice);\n    return getFileList(zip);\n}\n\nQString JlCompress::extractFile(QIODevice *ioDevice, QString fileName, QString fileDest)\n{\n    QuaZip zip(ioDevice);\n    return extractFile(zip, fileName, fileDest);\n}\n\nQStringList JlCompress::extractFiles(QIODevice *ioDevice, QStringList files, QString dir)\n{\n    QuaZip zip(ioDevice);\n    return extractFiles(zip, files, dir);\n} \n", "/*\nCopyright (C) 2005-2014 Sergey A. Tachenov\n\nThis file is part of QuaZIP test suite.\n\nQuaZIP is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 2.1 of the License, or\n(at your option) any later version.\n\nQuaZIP is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with QuaZIP.  If not, see <http://www.gnu.org/licenses/>.\n\nSee COPYING file for the full LGPL text.\n\nOriginal ZIP package is copyrighted by Gilles Vollant and contributors,\nsee quazip/(un)zip.h files for details. Basically it's the zlib license.\n*/\n\n#include \"testjlcompress.h\"\n\n#include \"qztest.h\"\n\n#include <QDir>\n#include <QFileInfo>\n\n#include <QtTest/QtTest>\n\n#include <quazip/JlCompress.h>\n\n#ifdef Q_OS_WIN\n#include <windows.h>\n#endif\n\nvoid TestJlCompress::compressFile_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QString>(\"fileName\");\n    QTest::newRow(\"simple\") << \"jlsimplefile.zip\" << \"test0.txt\";\n}\n\nvoid TestJlCompress::compressFile()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QString, fileName);\n    QDir curDir;\n    if (curDir.exists(zipName)) {\n        if (!curDir.remove(zipName))\n            QFAIL(\"Can't remove zip file\");\n    }\n    if (!createTestFiles(QStringList() << fileName)) {\n        QFAIL(\"Can't create test file\");\n    }\n    QVERIFY(JlCompress::compressFile(zipName, \"tmp/\" + fileName));\n    // get the file list and check it\n    QStringList fileList = JlCompress::getFileList(zipName);\n    QCOMPARE(fileList.count(), 1);\n    QVERIFY(fileList[0] == fileName);\n    // now test the QIODevice* overload of getFileList()\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    fileList = JlCompress::getFileList(zipName);\n    QCOMPARE(fileList.count(), 1);\n    QVERIFY(fileList[0] == fileName);\n    zipFile.close();\n    removeTestFiles(QStringList() << fileName);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::compressFiles_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlsimplefiles.zip\" <<\n        (QStringList() << \"test0.txt\" << \"test00.txt\");\n    QTest::newRow(\"different subdirs\") << \"jlsubdirfiles.zip\" <<\n        (QStringList() << \"subdir1/test1.txt\" << \"subdir2/test2.txt\");\n}\n\nvoid TestJlCompress::compressFiles()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (curDir.exists(zipName)) {\n        if (!curDir.remove(zipName))\n            QFAIL(\"Can't remove zip file\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Can't create test files\");\n    }\n    QStringList realNamesList, shortNamesList;\n    foreach (QString fileName, fileNames) {\n        QString realName = \"tmp/\" + fileName;\n        realNamesList += realName;\n        shortNamesList += QFileInfo(realName).fileName();\n    }\n    QVERIFY(JlCompress::compressFiles(zipName, realNamesList));\n    // get the file list and check it\n    QStringList fileList = JlCompress::getFileList(zipName);\n    QCOMPARE(fileList, shortNamesList);\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::compressDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expected\");\n    QTest::newRow(\"simple\") << \"jldir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n\t\t<< (QStringList() << \"test0.txt\"\n\t\t\t<< \"testdir1/\" << \"testdir1/test1.txt\"\n            << \"testdir2/\" << \"testdir2/test2.txt\"\n\t\t\t<< \"testdir2/subdir/\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"empty dirs\") << \"jldir_empty.zip\"\n\t\t<< (QStringList() << \"testdir1/\" << \"testdir2/testdir3/\")\n        << (QStringList() << \"testdir1/\" << \"testdir2/\"\n            << \"testdir2/testdir3/\");\n    QTest::newRow(\"hidden files\") << \"jldir_hidden.zip\"\n        << (QStringList() << \".test0.txt\" << \"test1.txt\")\n        << (QStringList() << \".test0.txt\" << \"test1.txt\");\n}\n\nvoid TestJlCompress::compressDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QStringList, expected);\n    QDir curDir;\n    if (curDir.exists(zipName)) {\n        if (!curDir.remove(zipName))\n            QFAIL(\"Can't remove zip file\");\n    }\n    if (!createTestFiles(fileNames, -1, \"compressDir_tmp\")) {\n        QFAIL(\"Can't create test files\");\n    }\n#ifdef Q_OS_WIN\n    for (int i = 0; i < fileNames.size(); ++i) {\n        if (fileNames.at(i).startsWith(\".\")) {\n            QString fn = \"compressDir_tmp\\\\\" + fileNames.at(i);\n            SetFileAttributesW(reinterpret_cast<LPCWSTR>(fn.utf16()),\n                              FILE_ATTRIBUTE_HIDDEN);\n        }\n    }\n#endif\n    QVERIFY(JlCompress::compressDir(zipName, \"compressDir_tmp\", true, QDir::Hidden));\n    // get the file list and check it\n    QStringList fileList = JlCompress::getFileList(zipName);\n    qSort(fileList);\n    qSort(expected);\n    QCOMPARE(fileList, expected);\n    removeTestFiles(fileNames, \"compressDir_tmp\");\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::extractFile_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QString>(\"fileToExtract\");\n    QTest::addColumn<QString>(\"destName\");\n    QTest::addColumn<QByteArray>(\"encoding\");\n    QTest::newRow(\"simple\") << \"jlextfile.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << \"testdir2/test2.txt\" << \"test2.txt\" << QByteArray();\n    QTest::newRow(\"russian\") << \"jlextfilerus.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << QString::fromUtf8(\"testdir2/\u0442\u0435\u0441\u04422.txt\")\n            << \"testdir2/subdir/test2sub.txt\")\n        << QString::fromUtf8(\"testdir2/\u0442\u0435\u0441\u04422.txt\")\n        << QString::fromUtf8(\"\u0442\u0435\u0441\u04422.txt\") << QByteArray(\"IBM866\");\n    QTest::newRow(\"extract dir\") << \"jlextdir.zip\" << (\n            QStringList() << \"testdir1/\")\n        << \"testdir1/\" << \"testdir1/\" << QByteArray();\n}\n\nvoid TestJlCompress::extractFile()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QString, fileToExtract);\n    QFETCH(QString, destName);\n    QFETCH(QByteArray, encoding);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jlfile\")) {\n        QFAIL(\"Couldn't mkpath jlext/jlfile\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    QFile srcFile(\"tmp/\" + fileToExtract);\n    QFile::Permissions srcPerm = srcFile.permissions();\n    // Invert the \"write other\" flag so permissions\n    // are NOT default any more. Otherwise it's impossible\n    // to figure out whether the permissions were set correctly\n    // or JlCompress failed to set them completely,\n    // thus leaving them at the default setting.\n    srcPerm ^= QFile::WriteOther;\n    QVERIFY(srcFile.setPermissions(srcPerm));\n    if (!createTestArchive(zipName, fileNames,\n                           QTextCodec::codecForName(encoding))) {\n        QFAIL(\"Can't create test archive\");\n    }\n    QuaZip::setDefaultFileNameCodec(encoding);\n    QVERIFY(!JlCompress::extractFile(zipName, fileToExtract,\n                \"jlext/jlfile/\" + destName).isEmpty());\n    QFileInfo destInfo(\"jlext/jlfile/\" + destName), srcInfo(\"tmp/\" +\n            fileToExtract);\n    QCOMPARE(destInfo.size(), srcInfo.size());\n    QCOMPARE(destInfo.permissions(), srcInfo.permissions());\n    curDir.remove(\"jlext/jlfile/\" + destName);\n    // now test the QIODevice* overload\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QVERIFY(!JlCompress::extractFile(&zipFile, fileToExtract,\n                \"jlext/jlfile/\" + destName).isEmpty());\n    destInfo = QFileInfo(\"jlext/jlfile/\" + destName);\n    QCOMPARE(destInfo.size(), srcInfo.size());\n    QCOMPARE(destInfo.permissions(), srcInfo.permissions());\n    curDir.remove(\"jlext/jlfile/\" + destName);\n    if (!fileToExtract.endsWith(\"/\")) {\n        // If we aren't extracting a directory, we need to check\n        // that extractFile() fails if there is a directory\n        // with the same name as the file being extracted.\n        curDir.mkdir(\"jlext/jlfile/\" + destName);\n        QVERIFY(JlCompress::extractFile(zipName, fileToExtract,\n                    \"jlext/jlfile/\" + destName).isEmpty());\n    }\n    zipFile.close();\n    // Here we either delete the target dir or the dir created in the\n    // test above.\n    curDir.rmpath(\"jlext/jlfile/\" + destName);\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::extractFiles_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"filesToExtract\");\n    QTest::newRow(\"simple\") << \"jlextfiles.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << (QStringList() << \"testdir2/test2.txt\" << \"testdir1/test1.txt\");\n}\n\nvoid TestJlCompress::extractFiles()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QStringList, filesToExtract);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jlfiles\")) {\n        QFAIL(\"Couldn't mkpath jlext/jlfiles\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!JlCompress::compressDir(zipName, \"tmp\")) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QVERIFY(!JlCompress::extractFiles(zipName, filesToExtract,\n                \"jlext/jlfiles\").isEmpty());\n    foreach (QString fileName, filesToExtract) {\n        QFileInfo fileInfo(\"jlext/jlfiles/\" + fileName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(\"jlext/jlfiles/\" + fileName);\n        curDir.rmpath(fileInfo.dir().path());\n    }\n    // now test the QIODevice* overload\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QVERIFY(!JlCompress::extractFiles(&zipFile, filesToExtract,\n                \"jlext/jlfiles\").isEmpty());\n    foreach (QString fileName, filesToExtract) {\n        QFileInfo fileInfo(\"jlext/jlfiles/\" + fileName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(\"jlext/jlfiles/\" + fileName);\n        curDir.rmpath(fileInfo.dir().path());\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jlfiles\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}\n\nvoid TestJlCompress::extractDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jldir\")) {\n        QFAIL(\"Couldn't mkpath jlext/jldir\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!createTestArchive(zipName, fileNames)) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QStringList extracted;\n    QCOMPARE((extracted = JlCompress::extractDir(zipName, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n\t    absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    // now test the QIODevice* overload\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QCOMPARE((extracted = JlCompress::extractDir(&zipFile, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n        absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jldir\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::zeroPermissions()\n{\n    QuaZip zipCreator(\"zero.zip\");\n    QVERIFY(zipCreator.open(QuaZip::mdCreate));\n    QuaZipFile zeroFile(&zipCreator);\n    QuaZipNewInfo newInfo(\"zero.txt\");\n    newInfo.externalAttr = 0; // should be zero anyway, but just in case\n    QVERIFY(zeroFile.open(QIODevice::WriteOnly, newInfo));\n    zeroFile.close();\n    zipCreator.close();\n    QVERIFY(!JlCompress::extractFile(\"zero.zip\", \"zero.txt\").isEmpty());\n    QVERIFY(QFile(\"zero.txt\").permissions() != 0);\n    QDir curDir;\n    curDir.remove(\"zero.zip\");\n    curDir.remove(\"zero.txt\");\n}\n"], "fixing_code": ["QuaZIP changes\n\n* Current\n        * Fixed the Zip Slip vulnerability in JlCompress\n\n* 0.7.5\n        * Fixed target_link_libraries call in CMakeLists\n        * Worked around a Qt 4.6 bug (QTBUG-15421) screwing up hidden\n          files handling in JlCompress::compressDir()\n        * Removed Q_FOREACH uses to avoid conflicts (SF patch #32)\n\n* 2017-02-05 0.7.4\n        * Static analysis patch from Intel Deutschland GmbH\n        * Replaced UNUSED with QUAZIP_UNUSED to avoid name clashes\n        * Minor bug fixes\n\n* 2017-02-05 0.7.3\n        * Symlink handling\n        * Static linking exception for LGPL\n        * Minor bug fixes\n\n* 2016-03-29 0.7.2\n        * New JlCompress methods (QIODevice*-based API by Lukasz Kwiecinski)\n        * Implemented QuaZioDevice::atEnd() and bytesAvailable()--these might\n          break ABI, but pretty unlikely.\n\n* 2015-01-07 0.7.1\n        * Fixed licensing issues (bug #45).\n        * Added the convenience method QuaZipFileInfo::isEncrypted().\n\n* 2014-07-24 0.7\n        * It is now possible to write ZIP files to sequential devices\n          like sockets (only in mdCreate mode, so no self-extract, sorry).\n        * A few zip64 fixes.\n        * Several bug fixes and portability improvements.\n\n* 2014-02-09 0.6.2\n        * QuaZipNewInfo / QuaZipFileInfo64 now provide API to access/set\n          NTFS time stamps - useful even on non-NTFS systems if you \n          need more precise dates and times than default ones.\n        * QuaZipNewInfo may now be initialized from QuaZipFileInfo64.\n        * No more crashes when using QSaveFile as QIODevice for ZIP.\n        * The new QuaZip::setAutoClose() method allows to leave the\n          QIODevice open when you close the QuaZip instance.\n        * qztest now depends on quazip, no longer breaking the build.\n\n* 2014-01-26 0.6.1\n        * Improved zip64 support.\n        * A LOT more tests thanks to g++ --coverage / lcov.\n        * JlCompress extraction methods now create files with default\n          permissions if they are zero in the original archive.\n        * Some QuaZipDir fixes (thanks to the new tests).\n\n* 2014-01-22 0.6\n        * Minizip updated to 1.1 (with all the necessary modifications\n          re-done), and that means that...\n        * the long-awaited zip64 support is now available!\n        * A few rather minor fixes.\n\n* 2014-01-19 0.5.2\n        * Some minor bug fixes.\n        * API to access file permissions subfield of the external\n          attributes.\n        * MS VS 2012 Express support.\n        * API to set the default codec used to encode/decode file names\n          (mainly for use by various wrappers such as JlCompress, when\n          you don't have direct access to the underlying QuaZip instance).\n\n* 2013-03-02 0.5.1\n        * Lots of QuaZipDir fixes, thanks to all bug reporters.\n        * Full Qt Creator support.\n        * MS VS 2010 Express support.\n        * Qt5 support (didn't need any source code changes anyway).\n        * Lots of minor bug fixes.\n\n* 2012-09-07 0.5\n        * Added run_moc.bat files for building under Windows in case Qt\n          integration is not available (e. g. VS 2008 Express).\n        * Added the QuaZipDir class to simplify ZIP navigation in terms\n          of directories.\n        * Added the QuaGzipFile class for working with GZIP archives. It\n          was added as a bonus since it has nothing to do with the main\n          purpose of the library. It probably won't get any major\n          improvements, although minor bug fixes are possible.\n        * Added the QuaZIODevice class for working with zlib\n          compression. It has nothing to do with the ZIP format, and\n          therefore the same notice as for the QuaGzipFile applies.\n        * The global comment is no longer erased when adding files to\n          an archive.\n        * Many bug fixes.\n\n* 2012-01-14 0.4.4\n        * Fixed isSequential() test that was causing open() failures on\n          Unix.\n        * Fixed sub-directory compressing in JlCompress.\n        * Added MS VS 2008 solution, compatible with the binary Qt\n          distribution (tested on MS VS 2008 Express, had to run MOC\n          manually due to the lack of plugin in Express).\n        * Fixed extracting directories in JlCompress.\n        * Fixed JlCompress.h includes in the test suite, which used\n          lowercase names thus breaking on case-sensitive systems.\n        * Implemented missing QuaZipFile::getZip() that was only\n          declared.\n        * Fixed reopening closed files.\n        * Fixed possible memory leak in case of open error.\n\n* 2011-09-09 0.4.3\n        * New test suite using QTestLib.\n        * Fixed bytesAvailable(), pos() and atEnd().\n        * Added ZIP v1.0 support and disabling data descriptor for\n          compatibility with some older software.\n        * Fixed DLL export/import issues for some symbols.\n        * Added QUAZIP_STATIC macro for compiling as a static library or\n          directly including the source.\n        * Added getFileNameList() and getFileInfoList() convenience\n          functions.\n        * Added some buffering to JlCompress to improve performance.\n\n* 2011-08-10 0.4.2\n        * Cmake patch (thanks to Bernhard Rosenkraenzer).\n        * Symbian patch (thanks to Hamish Willee).\n        * Documented the multiple files limitation of QuaZipFile.\n        * Fixed relative paths handling in JlCompress.\n        * Fixed linking to MinGW zlib.\n\n* 2011-05-26 0.4.1\n        * License statement updated to avoid confusion. GPL license\n        removed for the very same reason.\n        * Parts of original package are now clearly marked as modified,\n        just as their license requires.\n\n* 2011-05-23 0.4\n        * QuaZip and QuaZipFile classes now use the Pimpl idiom. This\n        means that future releases will probably be binary compatible\n        with this one, but it also means that this one is binary\n        incompatible with the old ones.\n        * IO API has been rewritten using QIODevice instead of standard\n        C library. Among other things it means that QuaZip now supports\n        files up to 4 GB in size instead of 2 GB.\n        * Added QuaZip methods allowing access to ZIP files represented\n        by any seekable QIODevice implementation (QBuffer is a good\n        example).\n\n* 2010-07-23 0.3\n        * Fixed getComment() for global comments.\n        * Added some useful classes for calculating checksums (thanks to\n        Adam Walczak).\n        * Added some utility classes for working with whole directories\n        (thanks to Roberto Pompermaier). It would be nice if someone\n        documents these in English, though.\n        * Probably fixed some problems with passwords (thanks to Vasiliy\n        Sorokin). I didn't test it, though.\n\n* 2008-09-17 0.2.3\n        * Fixed license notices in sources.\n\n* SVN\n        * Fixed a small bug in QuaZipFile::atEnd().\n\n* 2007-01-16 0.2.2\n        * Added LGPL as alternative license.\n        * Added FAQ documentation page.\n\n* 2006-03-21 0.2.1\n        * Fixed setCommentCodec() bug.\n        * Fixed bug that set month 1-12 instead of 0-11, as specified in\n          zip.h.\n        * Added workaround for Qt's bug that caused wrong timestamps.\n        * Few documentation fixes and cosmetic changes.\n\n* 2005-07-08 0.2\n        * Write support.\n        * Extended QuaZipFile API, including size(), *pos() functions.\n        * Support for comments encoding/decoding.\n\n* 2005-07-01 0.1\n        * Initial version.\n", "/*\nCopyright (C) 2010 Roberto Pompermaier\nCopyright (C) 2005-2014 Sergey A. Tachenov\n\nThis file is part of QuaZIP.\n\nQuaZIP is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 2.1 of the License, or\n(at your option) any later version.\n\nQuaZIP is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with QuaZIP.  If not, see <http://www.gnu.org/licenses/>.\n\nSee COPYING file for the full LGPL text.\n\nOriginal ZIP package is copyrighted by Gilles Vollant and contributors,\nsee quazip/(un)zip.h files for details. Basically it's the zlib license.\n*/\n\n#include \"JlCompress.h\"\n#include <QDebug>\n\nstatic bool copyData(QIODevice &inFile, QIODevice &outFile)\n{\n    while (!inFile.atEnd()) {\n        char buf[4096];\n        qint64 readLen = inFile.read(buf, 4096);\n        if (readLen <= 0)\n            return false;\n        if (outFile.write(buf, readLen) != readLen)\n            return false;\n    }\n    return true;\n}\n\nbool JlCompress::compressFile(QuaZip* zip, QString fileName, QString fileDest) {\n    // zip: oggetto dove aggiungere il file\n    // fileName: nome del file reale\n    // fileDest: nome del file all'interno del file compresso\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip->getMode()!=QuaZip::mdCreate &&\n        zip->getMode()!=QuaZip::mdAppend &&\n        zip->getMode()!=QuaZip::mdAdd) return false;\n\n    // Apro il file originale\n    QFile inFile;\n    inFile.setFileName(fileName);\n    if(!inFile.open(QIODevice::ReadOnly)) return false;\n\n    // Apro il file risulato\n    QuaZipFile outFile(zip);\n    if(!outFile.open(QIODevice::WriteOnly, QuaZipNewInfo(fileDest, inFile.fileName()))) return false;\n\n    // Copio i dati\n    if (!copyData(inFile, outFile) || outFile.getZipError()!=UNZ_OK) {\n        return false;\n    }\n\n    // Chiudo i file\n    outFile.close();\n    if (outFile.getZipError()!=UNZ_OK) return false;\n    inFile.close();\n\n    return true;\n}\n\nbool JlCompress::compressSubDir(QuaZip* zip, QString dir, QString origDir, bool recursive, QDir::Filters filters) {\n    // zip: oggetto dove aggiungere il file\n    // dir: cartella reale corrente\n    // origDir: cartella reale originale\n    // (path(dir)-path(origDir)) = path interno all'oggetto zip\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip->getMode()!=QuaZip::mdCreate &&\n        zip->getMode()!=QuaZip::mdAppend &&\n        zip->getMode()!=QuaZip::mdAdd) return false;\n\n    // Controllo la cartella\n    QDir directory(dir);\n    if (!directory.exists()) return false;\n\n    QDir origDirectory(origDir);\n\tif (dir != origDir) {\n\t\tQuaZipFile dirZipFile(zip);\n\t\tif (!dirZipFile.open(QIODevice::WriteOnly,\n\t\t\tQuaZipNewInfo(origDirectory.relativeFilePath(dir) + \"/\", dir), 0, 0, 0)) {\n\t\t\t\treturn false;\n\t\t}\n\t\tdirZipFile.close();\n\t}\n\n\n    // Se comprimo anche le sotto cartelle\n    if (recursive) {\n        // Per ogni sotto cartella\n        QFileInfoList files = directory.entryInfoList(QDir::AllDirs|QDir::NoDotAndDotDot|filters);\n        for (int index = 0; index < files.size(); ++index ) {\n            const QFileInfo & file( files.at( index ) );\n#if QT_VERSION < QT_VERSION_CHECK(4, 7, 4)\n            if (!file.isDir())\n                continue;\n#endif\n            // Comprimo la sotto cartella\n            if(!compressSubDir(zip,file.absoluteFilePath(),origDir,recursive,filters)) return false;\n        }\n    }\n\n    // Per ogni file nella cartella\n    QFileInfoList files = directory.entryInfoList(QDir::Files|filters);\n    for (int index = 0; index < files.size(); ++index ) {\n        const QFileInfo & file( files.at( index ) );\n        // Se non e un file o e il file compresso che sto creando\n        if(!file.isFile()||file.absoluteFilePath()==zip->getZipName()) continue;\n\n        // Creo il nome relativo da usare all'interno del file compresso\n        QString filename = origDirectory.relativeFilePath(file.absoluteFilePath());\n\n        // Comprimo il file\n        if (!compressFile(zip,file.absoluteFilePath(),filename)) return false;\n    }\n\n    return true;\n}\n\nbool JlCompress::extractFile(QuaZip* zip, QString fileName, QString fileDest) {\n    // zip: oggetto dove aggiungere il file\n    // filename: nome del file reale\n    // fileincompress: nome del file all'interno del file compresso\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip->getMode()!=QuaZip::mdUnzip) return false;\n\n    // Apro il file compresso\n    if (!fileName.isEmpty())\n        zip->setCurrentFile(fileName);\n    QuaZipFile inFile(zip);\n    if(!inFile.open(QIODevice::ReadOnly) || inFile.getZipError()!=UNZ_OK) return false;\n\n    // Controllo esistenza cartella file risultato\n    QDir curDir;\n    if (fileDest.endsWith('/')) {\n        if (!curDir.mkpath(fileDest)) {\n            return false;\n        }\n    } else {\n        if (!curDir.mkpath(QFileInfo(fileDest).absolutePath())) {\n            return false;\n        }\n    }\n\n    QuaZipFileInfo64 info;\n    if (!zip->getCurrentFileInfo(&info))\n        return false;\n\n    QFile::Permissions srcPerm = info.getPermissions();\n    if (fileDest.endsWith('/') && QFileInfo(fileDest).isDir()) {\n        if (srcPerm != 0) {\n            QFile(fileDest).setPermissions(srcPerm);\n        }\n        return true;\n    }\n\n    // Apro il file risultato\n    QFile outFile;\n    outFile.setFileName(fileDest);\n    if(!outFile.open(QIODevice::WriteOnly)) return false;\n\n    // Copio i dati\n    if (!copyData(inFile, outFile) || inFile.getZipError()!=UNZ_OK) {\n        outFile.close();\n        removeFile(QStringList(fileDest));\n        return false;\n    }\n    outFile.close();\n\n    // Chiudo i file\n    inFile.close();\n    if (inFile.getZipError()!=UNZ_OK) {\n        removeFile(QStringList(fileDest));\n        return false;\n    }\n\n    if (srcPerm != 0) {\n        outFile.setPermissions(srcPerm);\n    }\n    return true;\n}\n\nbool JlCompress::removeFile(QStringList listFile) {\n    bool ret = true;\n    // Per ogni file\n    for (int i=0; i<listFile.count(); i++) {\n        // Lo elimino\n        ret = ret && QFile::remove(listFile.at(i));\n    }\n    return ret;\n}\n\nbool JlCompress::compressFile(QString fileCompressed, QString file) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Aggiungo il file\n    if (!compressFile(&zip,file,QFileInfo(file).fileName())) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\nbool JlCompress::compressFiles(QString fileCompressed, QStringList files) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Comprimo i file\n    QFileInfo info;\n    for (int index = 0; index < files.size(); ++index ) {\n        const QString & file( files.at( index ) );\n        info.setFile(file);\n        if (!info.exists() || !compressFile(&zip,file,info.fileName())) {\n            QFile::remove(fileCompressed);\n            return false;\n        }\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\nbool JlCompress::compressDir(QString fileCompressed, QString dir, bool recursive) {\n    return compressDir(fileCompressed, dir, recursive, 0);\n}\n\nbool JlCompress::compressDir(QString fileCompressed, QString dir,\n                             bool recursive, QDir::Filters filters)\n{\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Aggiungo i file e le sotto cartelle\n    if (!compressSubDir(&zip,dir,dir,recursive, filters)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\nQString JlCompress::extractFile(QString fileCompressed, QString fileName, QString fileDest) {\n    // Apro lo zip\n    QuaZip zip(fileCompressed);\n    return extractFile(zip, fileName, fileDest);\n}\n\nQString JlCompress::extractFile(QuaZip &zip, QString fileName, QString fileDest)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QString();\n    }\n\n    // Estraggo il file\n    if (fileDest.isEmpty())\n        fileDest = fileName;\n    if (!extractFile(&zip,fileName,fileDest)) {\n        return QString();\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(QStringList(fileDest));\n        return QString();\n    }\n    return QFileInfo(fileDest).absoluteFilePath();\n}\n\nQStringList JlCompress::extractFiles(QString fileCompressed, QStringList files, QString dir) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    return extractFiles(zip, files, dir);\n}\n\nQStringList JlCompress::extractFiles(QuaZip &zip, const QStringList &files, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n\n    // Estraggo i file\n    QStringList extracted;\n    for (int i=0; i<files.count(); i++) {\n        QString absPath = QDir(dir).absoluteFilePath(files.at(i));\n        if (!extractFile(&zip, files.at(i), absPath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absPath);\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}\n\nQStringList JlCompress::extractDir(QString fileCompressed, QString dir) {\n    // Apro lo zip\n    QuaZip zip(fileCompressed);\n    return extractDir(zip, dir);\n}\n\nQStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QString cleanDir = QDir::cleanPath(dir);\n    QDir directory(cleanDir);\n    QString absCleanDir = directory.absolutePath();\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        QString absCleanPath = QDir::cleanPath(absFilePath);\n        if (!absCleanPath.startsWith(absCleanDir + \"/\"))\n            continue;\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}\n\nQStringList JlCompress::getFileList(QString fileCompressed) {\n    // Apro lo zip\n    QuaZip* zip = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());\n    return getFileList(zip);\n}\n\nQStringList JlCompress::getFileList(QuaZip *zip)\n{\n    if(!zip->open(QuaZip::mdUnzip)) {\n        delete zip;\n        return QStringList();\n    }\n\n    // Estraggo i nomi dei file\n    QStringList lst;\n    QuaZipFileInfo64 info;\n    for(bool more=zip->goToFirstFile(); more; more=zip->goToNextFile()) {\n      if(!zip->getCurrentFileInfo(&info)) {\n          delete zip;\n          return QStringList();\n      }\n      lst << info.name;\n      //info.name.toLocal8Bit().constData()\n    }\n\n    // Chiudo il file zip\n    zip->close();\n    if(zip->getZipError()!=0) {\n        delete zip;\n        return QStringList();\n    }\n    delete zip;\n    return lst;\n}\n\nQStringList JlCompress::extractDir(QIODevice *ioDevice, QString dir)\n{\n    QuaZip zip(ioDevice);\n    return extractDir(zip, dir);\n}\n\nQStringList JlCompress::getFileList(QIODevice *ioDevice)\n{\n    QuaZip *zip = new QuaZip(ioDevice);\n    return getFileList(zip);\n}\n\nQString JlCompress::extractFile(QIODevice *ioDevice, QString fileName, QString fileDest)\n{\n    QuaZip zip(ioDevice);\n    return extractFile(zip, fileName, fileDest);\n}\n\nQStringList JlCompress::extractFiles(QIODevice *ioDevice, QStringList files, QString dir)\n{\n    QuaZip zip(ioDevice);\n    return extractFiles(zip, files, dir);\n} \n", "/*\nCopyright (C) 2005-2014 Sergey A. Tachenov\n\nThis file is part of QuaZIP test suite.\n\nQuaZIP is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 2.1 of the License, or\n(at your option) any later version.\n\nQuaZIP is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with QuaZIP.  If not, see <http://www.gnu.org/licenses/>.\n\nSee COPYING file for the full LGPL text.\n\nOriginal ZIP package is copyrighted by Gilles Vollant and contributors,\nsee quazip/(un)zip.h files for details. Basically it's the zlib license.\n*/\n\n#include \"testjlcompress.h\"\n\n#include \"qztest.h\"\n\n#include <QDir>\n#include <QFileInfo>\n\n#include <QtTest/QtTest>\n\n#include <quazip/JlCompress.h>\n\n#ifdef Q_OS_WIN\n#include <windows.h>\n#endif\n\nvoid TestJlCompress::compressFile_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QString>(\"fileName\");\n    QTest::newRow(\"simple\") << \"jlsimplefile.zip\" << \"test0.txt\";\n}\n\nvoid TestJlCompress::compressFile()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QString, fileName);\n    QDir curDir;\n    if (curDir.exists(zipName)) {\n        if (!curDir.remove(zipName))\n            QFAIL(\"Can't remove zip file\");\n    }\n    if (!createTestFiles(QStringList() << fileName)) {\n        QFAIL(\"Can't create test file\");\n    }\n    QVERIFY(JlCompress::compressFile(zipName, \"tmp/\" + fileName));\n    // get the file list and check it\n    QStringList fileList = JlCompress::getFileList(zipName);\n    QCOMPARE(fileList.count(), 1);\n    QVERIFY(fileList[0] == fileName);\n    // now test the QIODevice* overload of getFileList()\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    fileList = JlCompress::getFileList(zipName);\n    QCOMPARE(fileList.count(), 1);\n    QVERIFY(fileList[0] == fileName);\n    zipFile.close();\n    removeTestFiles(QStringList() << fileName);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::compressFiles_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlsimplefiles.zip\" <<\n        (QStringList() << \"test0.txt\" << \"test00.txt\");\n    QTest::newRow(\"different subdirs\") << \"jlsubdirfiles.zip\" <<\n        (QStringList() << \"subdir1/test1.txt\" << \"subdir2/test2.txt\");\n}\n\nvoid TestJlCompress::compressFiles()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (curDir.exists(zipName)) {\n        if (!curDir.remove(zipName))\n            QFAIL(\"Can't remove zip file\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Can't create test files\");\n    }\n    QStringList realNamesList, shortNamesList;\n    foreach (QString fileName, fileNames) {\n        QString realName = \"tmp/\" + fileName;\n        realNamesList += realName;\n        shortNamesList += QFileInfo(realName).fileName();\n    }\n    QVERIFY(JlCompress::compressFiles(zipName, realNamesList));\n    // get the file list and check it\n    QStringList fileList = JlCompress::getFileList(zipName);\n    QCOMPARE(fileList, shortNamesList);\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::compressDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expected\");\n    QTest::newRow(\"simple\") << \"jldir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n\t\t<< (QStringList() << \"test0.txt\"\n\t\t\t<< \"testdir1/\" << \"testdir1/test1.txt\"\n            << \"testdir2/\" << \"testdir2/test2.txt\"\n\t\t\t<< \"testdir2/subdir/\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"empty dirs\") << \"jldir_empty.zip\"\n\t\t<< (QStringList() << \"testdir1/\" << \"testdir2/testdir3/\")\n        << (QStringList() << \"testdir1/\" << \"testdir2/\"\n            << \"testdir2/testdir3/\");\n    QTest::newRow(\"hidden files\") << \"jldir_hidden.zip\"\n        << (QStringList() << \".test0.txt\" << \"test1.txt\")\n        << (QStringList() << \".test0.txt\" << \"test1.txt\");\n}\n\nvoid TestJlCompress::compressDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QStringList, expected);\n    QDir curDir;\n    if (curDir.exists(zipName)) {\n        if (!curDir.remove(zipName))\n            QFAIL(\"Can't remove zip file\");\n    }\n    if (!createTestFiles(fileNames, -1, \"compressDir_tmp\")) {\n        QFAIL(\"Can't create test files\");\n    }\n#ifdef Q_OS_WIN\n    for (int i = 0; i < fileNames.size(); ++i) {\n        if (fileNames.at(i).startsWith(\".\")) {\n            QString fn = \"compressDir_tmp\\\\\" + fileNames.at(i);\n            SetFileAttributesW(reinterpret_cast<LPCWSTR>(fn.utf16()),\n                              FILE_ATTRIBUTE_HIDDEN);\n        }\n    }\n#endif\n    QVERIFY(JlCompress::compressDir(zipName, \"compressDir_tmp\", true, QDir::Hidden));\n    // get the file list and check it\n    QStringList fileList = JlCompress::getFileList(zipName);\n    qSort(fileList);\n    qSort(expected);\n    QCOMPARE(fileList, expected);\n    removeTestFiles(fileNames, \"compressDir_tmp\");\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::extractFile_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QString>(\"fileToExtract\");\n    QTest::addColumn<QString>(\"destName\");\n    QTest::addColumn<QByteArray>(\"encoding\");\n    QTest::newRow(\"simple\") << \"jlextfile.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << \"testdir2/test2.txt\" << \"test2.txt\" << QByteArray();\n    QTest::newRow(\"russian\") << \"jlextfilerus.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << QString::fromUtf8(\"testdir2/\u0442\u0435\u0441\u04422.txt\")\n            << \"testdir2/subdir/test2sub.txt\")\n        << QString::fromUtf8(\"testdir2/\u0442\u0435\u0441\u04422.txt\")\n        << QString::fromUtf8(\"\u0442\u0435\u0441\u04422.txt\") << QByteArray(\"IBM866\");\n    QTest::newRow(\"extract dir\") << \"jlextdir.zip\" << (\n            QStringList() << \"testdir1/\")\n        << \"testdir1/\" << \"testdir1/\" << QByteArray();\n}\n\nvoid TestJlCompress::extractFile()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QString, fileToExtract);\n    QFETCH(QString, destName);\n    QFETCH(QByteArray, encoding);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jlfile\")) {\n        QFAIL(\"Couldn't mkpath jlext/jlfile\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    QFile srcFile(\"tmp/\" + fileToExtract);\n    QFile::Permissions srcPerm = srcFile.permissions();\n    // Invert the \"write other\" flag so permissions\n    // are NOT default any more. Otherwise it's impossible\n    // to figure out whether the permissions were set correctly\n    // or JlCompress failed to set them completely,\n    // thus leaving them at the default setting.\n    srcPerm ^= QFile::WriteOther;\n    QVERIFY(srcFile.setPermissions(srcPerm));\n    if (!createTestArchive(zipName, fileNames,\n                           QTextCodec::codecForName(encoding))) {\n        QFAIL(\"Can't create test archive\");\n    }\n    QuaZip::setDefaultFileNameCodec(encoding);\n    QVERIFY(!JlCompress::extractFile(zipName, fileToExtract,\n                \"jlext/jlfile/\" + destName).isEmpty());\n    QFileInfo destInfo(\"jlext/jlfile/\" + destName), srcInfo(\"tmp/\" +\n            fileToExtract);\n    QCOMPARE(destInfo.size(), srcInfo.size());\n    QCOMPARE(destInfo.permissions(), srcInfo.permissions());\n    curDir.remove(\"jlext/jlfile/\" + destName);\n    // now test the QIODevice* overload\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QVERIFY(!JlCompress::extractFile(&zipFile, fileToExtract,\n                \"jlext/jlfile/\" + destName).isEmpty());\n    destInfo = QFileInfo(\"jlext/jlfile/\" + destName);\n    QCOMPARE(destInfo.size(), srcInfo.size());\n    QCOMPARE(destInfo.permissions(), srcInfo.permissions());\n    curDir.remove(\"jlext/jlfile/\" + destName);\n    if (!fileToExtract.endsWith(\"/\")) {\n        // If we aren't extracting a directory, we need to check\n        // that extractFile() fails if there is a directory\n        // with the same name as the file being extracted.\n        curDir.mkdir(\"jlext/jlfile/\" + destName);\n        QVERIFY(JlCompress::extractFile(zipName, fileToExtract,\n                    \"jlext/jlfile/\" + destName).isEmpty());\n    }\n    zipFile.close();\n    // Here we either delete the target dir or the dir created in the\n    // test above.\n    curDir.rmpath(\"jlext/jlfile/\" + destName);\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::extractFiles_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"filesToExtract\");\n    QTest::newRow(\"simple\") << \"jlextfiles.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << (QStringList() << \"testdir2/test2.txt\" << \"testdir1/test1.txt\");\n}\n\nvoid TestJlCompress::extractFiles()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QStringList, filesToExtract);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jlfiles\")) {\n        QFAIL(\"Couldn't mkpath jlext/jlfiles\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!JlCompress::compressDir(zipName, \"tmp\")) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QVERIFY(!JlCompress::extractFiles(zipName, filesToExtract,\n                \"jlext/jlfiles\").isEmpty());\n    foreach (QString fileName, filesToExtract) {\n        QFileInfo fileInfo(\"jlext/jlfiles/\" + fileName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(\"jlext/jlfiles/\" + fileName);\n        curDir.rmpath(fileInfo.dir().path());\n    }\n    // now test the QIODevice* overload\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QVERIFY(!JlCompress::extractFiles(&zipFile, filesToExtract,\n                \"jlext/jlfiles\").isEmpty());\n    foreach (QString fileName, filesToExtract) {\n        QFileInfo fileInfo(\"jlext/jlfiles/\" + fileName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(\"jlext/jlfiles/\" + fileName);\n        curDir.rmpath(fileInfo.dir().path());\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jlfiles\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expectedExtracted\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\"\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\")\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n    QTest::newRow(\"Zip Slip\") << \"zipslip.zip\"\n        << (QStringList() << \"test0.txt\" << \"../zipslip.txt\")\n        << (QStringList() << \"test0.txt\");\n}\n\nvoid TestJlCompress::extractDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QFETCH(QStringList, expectedExtracted);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jldir\")) {\n        QFAIL(\"Couldn't mkpath jlext/jldir\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!createTestArchive(zipName, fileNames)) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QStringList extracted;\n    QCOMPARE((extracted = JlCompress::extractDir(zipName, \"jlext/jldir\"))\n        .count(), expectedExtracted.count());\n    const QString dir = \"jlext/jldir/\";\n    foreach (QString fileName, expectedExtracted) {\n        QString fullName = dir + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = QDir(dir).absoluteFilePath(fileName);\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n\t    absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    // now test the QIODevice* overload\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QCOMPARE((extracted = JlCompress::extractDir(&zipFile, \"jlext/jldir\"))\n        .count(), expectedExtracted.count());\n    foreach (QString fileName, expectedExtracted) {\n        QString fullName = dir + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = QDir(dir).absoluteFilePath(fileName);\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n        absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jldir\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}\n\nvoid TestJlCompress::zeroPermissions()\n{\n    QuaZip zipCreator(\"zero.zip\");\n    QVERIFY(zipCreator.open(QuaZip::mdCreate));\n    QuaZipFile zeroFile(&zipCreator);\n    QuaZipNewInfo newInfo(\"zero.txt\");\n    newInfo.externalAttr = 0; // should be zero anyway, but just in case\n    QVERIFY(zeroFile.open(QIODevice::WriteOnly, newInfo));\n    zeroFile.close();\n    zipCreator.close();\n    QVERIFY(!JlCompress::extractFile(\"zero.zip\", \"zero.txt\").isEmpty());\n    QVERIFY(QFile(\"zero.txt\").permissions() != 0);\n    QDir curDir;\n    curDir.remove(\"zero.zip\");\n    curDir.remove(\"zero.txt\");\n}\n"], "filenames": ["NEWS.txt", "quazip/JlCompress.cpp", "qztest/testjlcompress.cpp"], "buggy_code_start_loc": [1, 367, 305], "buggy_code_end_loc": [1, 375, 358], "fixing_code_start_loc": [2, 367, 305], "fixing_code_end_loc": [5, 380, 367], "type": "CWE-22", "message": "QuaZIP before 0.7.6 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.", "other": {"cve": {"id": "CVE-2018-1002209", "sourceIdentifier": "report@snyk.io", "published": "2018-07-25T17:29:02.283", "lastModified": "2019-10-09T23:32:35.807", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "QuaZIP before 0.7.6 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'."}, {"lang": "es", "value": "QuaZIP en versiones anteriores a la 0.7.6 es vulnerable a un salto de directorio, lo que permite que los atacantes escriban en archivos arbitrarios mediante un ../ (punto punto barra) en una entrada de archivo Zip que se gestiona de manera incorrecta durante la extracci\u00f3n. Esta vulnerabilidad tambi\u00e9n se conoce como \"Zip-Slip\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quazip_project:quazip:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7.6", "matchCriteriaId": "82738A49-9F47-4CB1-84DB-FAD9BE63B597"}]}]}], "references": [{"url": "https://github.com/snyk/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/stachenov/quazip/blob/0.7.6/NEWS.txt", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://github.com/stachenov/quazip/commit/5d2fc16a1976e5bf78d2927b012f67a2ae047a98", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://snyk.io/research/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stachenov/quazip/commit/5d2fc16a1976e5bf78d2927b012f67a2ae047a98"}}