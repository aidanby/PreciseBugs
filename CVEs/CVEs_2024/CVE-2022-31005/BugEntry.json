{"buggy_code": ["import NIO\n\nextension Request {\n    public var fileio: FileIO {\n        return .init(\n            io: self.application.fileio,\n            allocator: self.application.allocator,\n            request: self\n        )\n    }\n}\n\n// MARK: FileIO\n\n/// `FileIO` is a convenience wrapper around SwiftNIO's `NonBlockingFileIO`.\n///\n/// It can read files, both in their entirety and chunked.\n///\n///     let fileio = try c.make(FileIO.self)\n///\n///     fileio.readFile(at: \"/path/to/file.txt\") { chunk in\n///         print(chunk) // part of file\n///     }\n///\n///     fileio.collectFile(at: \"/path/to/file.txt\").map { file in\n///         print(file) // entire file\n///     }\n///\n/// It can also create streaming HTTP responses.\n///\n///     let fileio = try c.make(FileIO.self)\n///     router.get(\"file-stream\") { req -> Response in\n///         return fileio.streamFile(at: \"/path/to/file.txt\", for: req)\n///     }\n///\n/// Streaming file responses respect `E-Tag` headers present in the request.\npublic struct FileIO {\n    /// Wrapped non-blocking file io from SwiftNIO\n    private let io: NonBlockingFileIO\n\n    /// ByteBufferAllocator to use for generating buffers.\n    private let allocator: ByteBufferAllocator\n    \n    /// HTTP request context.\n    let request: Request\n\n    /// Creates a new `FileIO`.\n    ///\n    /// See `Request.fileio()` to create one.\n    internal init(io: NonBlockingFileIO, allocator: ByteBufferAllocator, request: Request) {\n        self.io = io\n        self.allocator = allocator\n        self.request = request\n    }\n\n    /// Reads the contents of a file at the supplied path.\n    ///\n    ///     let data = try req.fileio().read(file: \"/path/to/file.txt\").wait()\n    ///     print(data) // file data\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    /// - returns: `Future` containing the file data.\n    public func collectFile(at path: String) -> EventLoopFuture<ByteBuffer> {\n        var data = self.allocator.buffer(capacity: 0)\n        return self.readFile(at: path) { new in\n            var new = new\n            data.writeBuffer(&new)\n            return self.request.eventLoop.makeSucceededFuture(())\n        }.map { data }\n    }\n\n    /// Reads the contents of a file at the supplied path in chunks.\n    ///\n    ///     try req.fileio().readChunked(file: \"/path/to/file.txt\") { chunk in\n    ///         print(\"chunk: \\(data)\")\n    ///     }.wait()\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    ///     - chunkSize: Maximum size for the file data chunks.\n    ///     - onRead: Closure to be called sequentially for each file data chunk.\n    /// - returns: `Future` that will complete when the file read is finished.\n    public func readFile(\n        at path: String,\n        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,\n        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>\n    ) -> EventLoopFuture<Void> {\n        guard\n            let attributes = try? FileManager.default.attributesOfItem(atPath: path),\n            let fileSize = attributes[.size] as? NSNumber\n        else {\n            return self.request.eventLoop.makeFailedFuture(Abort(.internalServerError))\n        }\n        return self.read(\n            path: path,\n            fromOffset: 0,\n            byteCount:\n            fileSize.intValue,\n            chunkSize: chunkSize,\n            onRead: onRead\n        )\n    }\n\n    /// Generates a chunked `HTTPResponse` for the specified file. This method respects values in\n    /// the `\"ETag\"` header and is capable of responding `304 Not Modified` if the file in question\n    /// has not been modified since last served. This method will also set the `\"Content-Type\"` header\n    /// automatically if an appropriate `MediaType` can be found for the file's suffix.\n    ///\n    ///     router.get(\"file-stream\") { req -> HTTPResponse in\n    ///         return try req.fileio().chunkedResponse(file: \"/path/to/file.txt\")\n    ///     }\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    ///     - req: `HTTPRequest` to parse `\"If-None-Match\"` header from.\n    ///     - chunkSize: Maximum size for the file data chunks.\n    /// - returns: A `200 OK` response containing the file stream and appropriate headers.\n    public func streamFile(\n        at path: String,\n        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,\n        mediaType: HTTPMediaType? = nil,\n        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }\n    ) -> Response {\n        // Get file attributes for this file.\n        guard\n            let attributes = try? FileManager.default.attributesOfItem(atPath: path),\n            let modifiedAt = attributes[.modificationDate] as? Date,\n            let fileSize = (attributes[.size] as? NSNumber)?.intValue\n        else {\n            return Response(status: .internalServerError)\n        }\n\n        let contentRange: HTTPHeaders.Range?\n        if let rangeFromHeaders = request.headers.range {\n            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {\n                contentRange = rangeFromHeaders\n            } else {\n                contentRange = nil\n            }\n        } else {\n            contentRange = nil\n        }\n        // Create empty headers array.\n        var headers: HTTPHeaders = [:]\n\n        // Generate ETag value, \"HEX value of last modified date\" + \"-\" + \"file size\"\n        let fileETag = \"\\(modifiedAt.timeIntervalSince1970)-\\(fileSize)\"\n        headers.replaceOrAdd(name: .eTag, value: fileETag)\n\n        // Check if file has been cached already and return NotModified response if the etags match\n        if fileETag == request.headers.first(name: .ifNoneMatch) {\n            return Response(status: .notModified)\n        }\n\n        // Create the HTTP response.\n        let response = Response(status: .ok, headers: headers)\n        let offset: Int64\n        let byteCount: Int\n        if let contentRange = contentRange {\n            response.status = .partialContent\n            response.headers.add(name: .accept, value: contentRange.unit.serialize())\n            if let firstRange = contentRange.ranges.first {\n                let range = firstRange.asResponseContentRange(limit: fileSize)\n                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)\n                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)\n            } else {\n                offset = 0\n                byteCount = fileSize\n            }\n        } else {\n            offset = 0\n            byteCount = fileSize\n        }\n        // Set Content-Type header based on the media type\n        // Only set Content-Type if file not modified and returned above.\n        if\n            let fileExtension = path.components(separatedBy: \".\").last,\n            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)\n        {\n            response.headers.contentType = type\n        }\n        response.body = .init(stream: { stream in\n            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in\n                return stream.write(.buffer(chunk))\n            }.whenComplete { result in\n                switch result {\n                case .failure(let error):\n                    stream.write(.error(error), promise: nil)\n                case .success:\n                    stream.write(.end, promise: nil)\n                }\n                onCompleted(result)\n            }\n        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)\n        \n        return response\n    }\n\n    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.\n    /// There may be use in publicizing this in the future for reads that must be async.\n    private func read(\n        path: String,\n        fromOffset offset: Int64,\n        byteCount: Int,\n        chunkSize: Int,\n        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>\n    ) -> EventLoopFuture<Void> {\n        do {\n            let fd = try NIOFileHandle(path: path)\n            let done = self.io.readChunked(\n                fileHandle: fd,\n                fromOffset: offset,\n                byteCount: byteCount,\n                chunkSize: chunkSize,\n                allocator: allocator,\n                eventLoop: self.request.eventLoop\n            ) { chunk in\n                return onRead(chunk)\n            }\n            done.whenComplete { _ in\n                try? fd.close()\n            }\n            return done\n        } catch {\n            return self.request.eventLoop.makeFailedFuture(error)\n        }\n    }\n    \n    /// Write the contents of buffer to a file at the supplied path.\n    ///\n    ///     let data = ByteBuffer(string: \"ByteBuffer\")\n    ///     try req.fileio.writeFile(data, at: \"/path/to/file.txt\").wait()\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    ///     - buffer: The `ByteBuffer` to write.\n    /// - returns: `Future` that will complete when the file write is finished.\n    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {\n        do {\n            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())\n            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)\n            done.whenComplete { _ in\n                try? fd.close()\n            }\n            return done\n        } catch {\n            return self.request.eventLoop.makeFailedFuture(error)\n        }\n    }\n}\n\nextension HTTPHeaders.Range.Value {\n    \n    fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {\n        switch self {\n            case .start(let value):\n                return (offset: numericCast(value), byteCount: size - value)\n            case .tail(let value):\n                return (offset: numericCast(size - value), byteCount: value)\n            case .within(let start, let end):\n                return (offset: numericCast(start), byteCount: end - start + 1)\n        }\n    }\n}\n", "import XCTVapor\n\nfinal class FileTests: XCTestCase {\n    func testStreamFile() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file) { result in\n                do {\n                    try result.get()\n                } catch { \n                    XCTFail(\"File Stream should have succeeded\")\n                }\n            }\n        }\n\n        try app.testable(method: .running).test(.GET, \"/file-stream\") { res in\n            let test = \"the quick brown fox\"\n            XCTAssertNotNil(res.headers.first(name: .eTag))\n            XCTAssertContains(res.body.string, test)\n        }\n    }\n\n    func testStreamFileConnectionClose() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file)\n        }\n\n        var headers = HTTPHeaders()\n        headers.replaceOrAdd(name: .connection, value: \"close\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            let test = \"the quick brown fox\"\n            XCTAssertNotNil(res.headers.first(name: .eTag))\n            XCTAssertContains(res.body.string, test)\n        }\n    }\n\n    func testStreamFileNull() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req -> Response in\n            var tmpPath: String\n            repeat {\n                tmpPath = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString).path\n            } while (FileManager.default.fileExists(atPath: tmpPath))\n\n            return req.fileio.streamFile(at: tmpPath) { result in\n                do {\n                    try result.get()\n                    XCTFail(\"File Stream should have failed\")\n                } catch { \n                }\n            }\n        }\n\n        try app.testable(method: .running).test(.GET, \"/file-stream\") { res in\n            XCTAssertTrue(res.body.string.isEmpty)\n        }\n    }\n    \n//    func testStreamFileContentHeaderTail() throws {\n//        let app = Application(.testing)\n//        defer { app.shutdown() }\n//\n//        app.get(\"file-stream\") { req in\n//            return req.fileio.streamFile(at: #file) { result in\n//                do {\n//                    try result.get()\n//                } catch {\n//                    XCTFail(\"File Stream should have succeeded\")\n//                }\n//            }\n//        }\n//        \n//        var headerRequest = HTTPHeaders()\n//        headerRequest.range = .init(unit: .bytes, ranges: [.tail(value: 20)])\n//        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headerRequest) { res in\n//            \n//            let contentRange = res.headers.first(name: \"content-range\")\n//            let contentLength = res.headers.first(name: \"content-length\")\n//            \n//            let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!\n//            let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!\n//            \n//            let range = upperRange - lowerRange + 1\n//            let length = Int(contentLength!)!\n//            print(\"\\(range) : \\(length)\")\n//\n//            XCTAssertTrue(range == length)\n//        }\n//    }\n    \n    func testStreamFileContentHeaderStart() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file) { result in\n                do {\n                    try result.get()\n                } catch {\n                    XCTFail(\"File Stream should have succeeded\")\n                }\n            }\n        }\n        \n        var headerRequest = HTTPHeaders()\n        headerRequest.range = .init(unit: .bytes, ranges: [.start(value: 20)])\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headerRequest) { res in\n            \n            let contentRange = res.headers.first(name: \"content-range\")\n            let contentLength = res.headers.first(name: \"content-length\")\n            \n            let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!\n            let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!\n            \n            let range = upperRange - lowerRange + 1\n            let length = Int(contentLength!)!\n            print(\"\\(range) : \\(length)\")\n\n            XCTAssertTrue(range == length)\n        }\n    }\n    \n    func testStreamFileContentHeadersWithin() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file) { result in\n                do {\n                    try result.get()\n                } catch {\n                    XCTFail(\"File Stream should have succeeded\")\n                }\n            }\n        }\n        \n        var headerRequest = HTTPHeaders()\n        headerRequest.range = .init(unit: .bytes, ranges: [.within(start: 20, end: 25)])\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headerRequest) { res in\n            \n            let contentRange = res.headers.first(name: \"content-range\")\n            let contentLength = res.headers.first(name: \"content-length\")\n            \n            let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!\n            let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!\n            \n            let range = upperRange - lowerRange + 1\n            let length = Int(contentLength!)!\n            print(\"\\(range) : \\(length)\")\n\n            XCTAssertTrue(range == length)\n        }\n    }\n    \n    func testFileWrite() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n        \n        let request = Request(application: app, on: app.eventLoopGroup.next())\n        \n        let data = \"Hello\"\n        let path = \"/tmp/fileio_write.txt\"\n        \n        try request.fileio.writeFile(ByteBuffer(string: data), at: path).wait()\n        defer { try? FileManager.default.removeItem(atPath: path) }\n        \n        let result = try String(contentsOfFile: path)\n        XCTAssertEqual(result, data)\n    }\n\n    func testPercentDecodedFilePath() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))\n\n        try app.test(.GET, \"/Utilities/foo%20bar.html\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Hello</h1>\\n\")\n        }\n    }\n\n    func testPercentDecodedRelativePath() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))\n\n        try app.test(.GET, \"%2e%2e/VaporTests/Utilities/foo.txt\") { res in\n            XCTAssertEqual(res.status, .forbidden)\n        }.test(.GET, \"Utilities/foo.txt\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"bar\\n\")\n        }\n    }\n    \n    func testDefaultFileRelative() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path, defaultFile: \"index.html\"))\n\n        try app.test(.GET, \"Utilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")\n        }.test(.GET, \"Utilities/SubUtilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Subdirectory Default</h1>\\n\")\n        }\n    }\n    \n    func testDefaultFileAbsolute() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path, defaultFile: \"/Utilities/index.html\"))\n\n        try app.test(.GET, \"Utilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")\n        }.test(.GET, \"Utilities/SubUtilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")\n        }\n    }\n    \n    func testNoDefaultFile() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))\n\n        try app.test(.GET, \"Utilities/\") { res in\n            XCTAssertEqual(res.status, .notFound)\n        }\n    }\n}\n"], "fixing_code": ["import NIO\nimport Logging\n\nextension Request {\n    public var fileio: FileIO {\n        return .init(\n            io: self.application.fileio,\n            allocator: self.application.allocator,\n            request: self\n        )\n    }\n}\n\n// MARK: FileIO\n\n/// `FileIO` is a convenience wrapper around SwiftNIO's `NonBlockingFileIO`.\n///\n/// It can read files, both in their entirety and chunked.\n///\n///     let fileio = try c.make(FileIO.self)\n///\n///     fileio.readFile(at: \"/path/to/file.txt\") { chunk in\n///         print(chunk) // part of file\n///     }\n///\n///     fileio.collectFile(at: \"/path/to/file.txt\").map { file in\n///         print(file) // entire file\n///     }\n///\n/// It can also create streaming HTTP responses.\n///\n///     let fileio = try c.make(FileIO.self)\n///     router.get(\"file-stream\") { req -> Response in\n///         return fileio.streamFile(at: \"/path/to/file.txt\", for: req)\n///     }\n///\n/// Streaming file responses respect `E-Tag` headers present in the request.\npublic struct FileIO {\n    /// Wrapped non-blocking file io from SwiftNIO\n    private let io: NonBlockingFileIO\n\n    /// ByteBufferAllocator to use for generating buffers.\n    private let allocator: ByteBufferAllocator\n    \n    /// HTTP request context.\n    let request: Request\n\n    /// Creates a new `FileIO`.\n    ///\n    /// See `Request.fileio()` to create one.\n    internal init(io: NonBlockingFileIO, allocator: ByteBufferAllocator, request: Request) {\n        self.io = io\n        self.allocator = allocator\n        self.request = request\n    }\n\n    /// Reads the contents of a file at the supplied path.\n    ///\n    ///     let data = try req.fileio().read(file: \"/path/to/file.txt\").wait()\n    ///     print(data) // file data\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    /// - returns: `Future` containing the file data.\n    public func collectFile(at path: String) -> EventLoopFuture<ByteBuffer> {\n        var data = self.allocator.buffer(capacity: 0)\n        return self.readFile(at: path) { new in\n            var new = new\n            data.writeBuffer(&new)\n            return self.request.eventLoop.makeSucceededFuture(())\n        }.map { data }\n    }\n\n    /// Reads the contents of a file at the supplied path in chunks.\n    ///\n    ///     try req.fileio().readChunked(file: \"/path/to/file.txt\") { chunk in\n    ///         print(\"chunk: \\(data)\")\n    ///     }.wait()\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    ///     - chunkSize: Maximum size for the file data chunks.\n    ///     - onRead: Closure to be called sequentially for each file data chunk.\n    /// - returns: `Future` that will complete when the file read is finished.\n    public func readFile(\n        at path: String,\n        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,\n        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>\n    ) -> EventLoopFuture<Void> {\n        guard\n            let attributes = try? FileManager.default.attributesOfItem(atPath: path),\n            let fileSize = attributes[.size] as? NSNumber\n        else {\n            return self.request.eventLoop.makeFailedFuture(Abort(.internalServerError))\n        }\n        return self.read(\n            path: path,\n            fromOffset: 0,\n            byteCount:\n            fileSize.intValue,\n            chunkSize: chunkSize,\n            onRead: onRead\n        )\n    }\n\n    /// Generates a chunked `HTTPResponse` for the specified file. This method respects values in\n    /// the `\"ETag\"` header and is capable of responding `304 Not Modified` if the file in question\n    /// has not been modified since last served. This method will also set the `\"Content-Type\"` header\n    /// automatically if an appropriate `MediaType` can be found for the file's suffix.\n    ///\n    ///     router.get(\"file-stream\") { req -> HTTPResponse in\n    ///         return try req.fileio().chunkedResponse(file: \"/path/to/file.txt\")\n    ///     }\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    ///     - req: `HTTPRequest` to parse `\"If-None-Match\"` header from.\n    ///     - chunkSize: Maximum size for the file data chunks.\n    /// - returns: A `200 OK` response containing the file stream and appropriate headers.\n    public func streamFile(\n        at path: String,\n        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,\n        mediaType: HTTPMediaType? = nil,\n        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }\n    ) -> Response {\n        // Get file attributes for this file.\n        guard\n            let attributes = try? FileManager.default.attributesOfItem(atPath: path),\n            let modifiedAt = attributes[.modificationDate] as? Date,\n            let fileSize = (attributes[.size] as? NSNumber)?.intValue\n        else {\n            return Response(status: .internalServerError)\n        }\n\n        let contentRange: HTTPHeaders.Range?\n        if let rangeFromHeaders = request.headers.range {\n            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {\n                contentRange = rangeFromHeaders\n            } else {\n                contentRange = nil\n            }\n        } else if request.headers.contains(name: .range) {\n            // Range header was supplied but could not be parsed i.e. it was invalid\n            request.logger.debug(\"Range header was provided in request but was invalid\")\n            let response = Response(status: .badRequest)\n            return response\n        } else {\n            contentRange = nil\n        }\n        // Create empty headers array.\n        var headers: HTTPHeaders = [:]\n\n        // Generate ETag value, \"HEX value of last modified date\" + \"-\" + \"file size\"\n        let fileETag = \"\\(modifiedAt.timeIntervalSince1970)-\\(fileSize)\"\n        headers.replaceOrAdd(name: .eTag, value: fileETag)\n\n        // Check if file has been cached already and return NotModified response if the etags match\n        if fileETag == request.headers.first(name: .ifNoneMatch) {\n            return Response(status: .notModified)\n        }\n\n        // Create the HTTP response.\n        let response = Response(status: .ok, headers: headers)\n        let offset: Int64\n        let byteCount: Int\n        if let contentRange = contentRange {\n            response.status = .partialContent\n            response.headers.add(name: .accept, value: contentRange.unit.serialize())\n            if let firstRange = contentRange.ranges.first {\n                let range = firstRange.asResponseContentRange(limit: fileSize)\n                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)\n                do {\n                    (offset, byteCount) = try firstRange.asByteBufferBounds(withMaxSize: fileSize, logger: request.logger)\n                } catch {\n                    let response = Response(status: .badRequest)\n                    return response\n                }\n            } else {\n                offset = 0\n                byteCount = fileSize\n            }\n        } else {\n            offset = 0\n            byteCount = fileSize\n        }\n        // Set Content-Type header based on the media type\n        // Only set Content-Type if file not modified and returned above.\n        if\n            let fileExtension = path.components(separatedBy: \".\").last,\n            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)\n        {\n            response.headers.contentType = type\n        }\n        response.body = .init(stream: { stream in\n            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in\n                return stream.write(.buffer(chunk))\n            }.whenComplete { result in\n                switch result {\n                case .failure(let error):\n                    stream.write(.error(error), promise: nil)\n                case .success:\n                    stream.write(.end, promise: nil)\n                }\n                onCompleted(result)\n            }\n        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)\n        \n        return response\n    }\n\n    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.\n    /// There may be use in publicizing this in the future for reads that must be async.\n    private func read(\n        path: String,\n        fromOffset offset: Int64,\n        byteCount: Int,\n        chunkSize: Int,\n        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>\n    ) -> EventLoopFuture<Void> {\n        do {\n            let fd = try NIOFileHandle(path: path)\n            let done = self.io.readChunked(\n                fileHandle: fd,\n                fromOffset: offset,\n                byteCount: byteCount,\n                chunkSize: chunkSize,\n                allocator: allocator,\n                eventLoop: self.request.eventLoop\n            ) { chunk in\n                return onRead(chunk)\n            }\n            done.whenComplete { _ in\n                try? fd.close()\n            }\n            return done\n        } catch {\n            return self.request.eventLoop.makeFailedFuture(error)\n        }\n    }\n    \n    /// Write the contents of buffer to a file at the supplied path.\n    ///\n    ///     let data = ByteBuffer(string: \"ByteBuffer\")\n    ///     try req.fileio.writeFile(data, at: \"/path/to/file.txt\").wait()\n    ///\n    /// - parameters:\n    ///     - path: Path to file on the disk.\n    ///     - buffer: The `ByteBuffer` to write.\n    /// - returns: `Future` that will complete when the file write is finished.\n    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {\n        do {\n            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())\n            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)\n            done.whenComplete { _ in\n                try? fd.close()\n            }\n            return done\n        } catch {\n            return self.request.eventLoop.makeFailedFuture(error)\n        }\n    }\n}\n\nextension HTTPHeaders.Range.Value {\n    \n    fileprivate func asByteBufferBounds(withMaxSize size: Int, logger: Logger) throws -> (offset: Int64, byteCount: Int) {\n        switch self {\n            case .start(let value):\n                guard value <= size, value >= 0 else {\n                    logger.debug(\"Requested range start was invalid: \\(value)\")\n                    throw Abort(.badRequest)\n                }\n                return (offset: numericCast(value), byteCount: size - value)\n            case .tail(let value):\n                guard value <= size, value >= 0 else {\n                    logger.debug(\"Requested range end was invalid: \\(value)\")\n                    throw Abort(.badRequest)\n                }\n                return (offset: numericCast(size - value), byteCount: value)\n            case .within(let start, let end):\n                guard start >= 0, end >= 0, start < end else {\n                    logger.debug(\"Requested range was invalid: \\(start)-\\(end)\")\n                    throw Abort(.badRequest)\n                }\n                let (byteCount, overflow) =  (end - start).addingReportingOverflow(1)\n                guard !overflow else {\n                    logger.debug(\"Requested range was invalid: \\(start)-\\(end)\")\n                    throw Abort(.badRequest)\n                }\n                return (offset: numericCast(start), byteCount: byteCount)\n        }\n    }\n}\n", "import XCTVapor\n\nfinal class FileTests: XCTestCase {\n    func testStreamFile() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file) { result in\n                do {\n                    try result.get()\n                } catch { \n                    XCTFail(\"File Stream should have succeeded\")\n                }\n            }\n        }\n\n        try app.testable(method: .running).test(.GET, \"/file-stream\") { res in\n            let test = \"the quick brown fox\"\n            XCTAssertNotNil(res.headers.first(name: .eTag))\n            XCTAssertContains(res.body.string, test)\n        }\n    }\n\n    func testStreamFileConnectionClose() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file)\n        }\n\n        var headers = HTTPHeaders()\n        headers.replaceOrAdd(name: .connection, value: \"close\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            let test = \"the quick brown fox\"\n            XCTAssertNotNil(res.headers.first(name: .eTag))\n            XCTAssertContains(res.body.string, test)\n        }\n    }\n\n    func testStreamFileNull() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req -> Response in\n            var tmpPath: String\n            repeat {\n                tmpPath = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString).path\n            } while (FileManager.default.fileExists(atPath: tmpPath))\n\n            return req.fileio.streamFile(at: tmpPath) { result in\n                do {\n                    try result.get()\n                    XCTFail(\"File Stream should have failed\")\n                } catch { \n                }\n            }\n        }\n\n        try app.testable(method: .running).test(.GET, \"/file-stream\") { res in\n            XCTAssertTrue(res.body.string.isEmpty)\n        }\n    }\n    \n//    func testStreamFileContentHeaderTail() throws {\n//        let app = Application(.testing)\n//        defer { app.shutdown() }\n//\n//        app.get(\"file-stream\") { req in\n//            return req.fileio.streamFile(at: #file) { result in\n//                do {\n//                    try result.get()\n//                } catch {\n//                    XCTFail(\"File Stream should have succeeded\")\n//                }\n//            }\n//        }\n//        \n//        var headerRequest = HTTPHeaders()\n//        headerRequest.range = .init(unit: .bytes, ranges: [.tail(value: 20)])\n//        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headerRequest) { res in\n//            \n//            let contentRange = res.headers.first(name: \"content-range\")\n//            let contentLength = res.headers.first(name: \"content-length\")\n//            \n//            let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!\n//            let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!\n//            \n//            let range = upperRange - lowerRange + 1\n//            let length = Int(contentLength!)!\n//            print(\"\\(range) : \\(length)\")\n//\n//            XCTAssertTrue(range == length)\n//        }\n//    }\n    \n    func testStreamFileContentHeaderStart() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file) { result in\n                do {\n                    try result.get()\n                } catch {\n                    XCTFail(\"File Stream should have succeeded\")\n                }\n            }\n        }\n        \n        var headerRequest = HTTPHeaders()\n        headerRequest.range = .init(unit: .bytes, ranges: [.start(value: 20)])\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headerRequest) { res in\n            \n            let contentRange = res.headers.first(name: \"content-range\")\n            let contentLength = res.headers.first(name: \"content-length\")\n            \n            let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!\n            let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!\n            \n            let range = upperRange - lowerRange + 1\n            let length = Int(contentLength!)!\n            print(\"\\(range) : \\(length)\")\n\n            XCTAssertTrue(range == length)\n        }\n    }\n    \n    func testStreamFileContentHeadersWithin() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file) { result in\n                do {\n                    try result.get()\n                } catch {\n                    XCTFail(\"File Stream should have succeeded\")\n                }\n            }\n        }\n        \n        var headerRequest = HTTPHeaders()\n        headerRequest.range = .init(unit: .bytes, ranges: [.within(start: 20, end: 25)])\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headerRequest) { res in\n            \n            let contentRange = res.headers.first(name: \"content-range\")\n            let contentLength = res.headers.first(name: \"content-length\")\n            \n            let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!\n            let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!\n            \n            let range = upperRange - lowerRange + 1\n            let length = Int(contentLength!)!\n            print(\"\\(range) : \\(length)\")\n\n            XCTAssertTrue(range == length)\n        }\n    }\n    \n    func testFileWrite() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n        \n        let request = Request(application: app, on: app.eventLoopGroup.next())\n        \n        let data = \"Hello\"\n        let path = \"/tmp/fileio_write.txt\"\n        \n        try request.fileio.writeFile(ByteBuffer(string: data), at: path).wait()\n        defer { try? FileManager.default.removeItem(atPath: path) }\n        \n        let result = try String(contentsOfFile: path)\n        XCTAssertEqual(result, data)\n    }\n\n    func testPercentDecodedFilePath() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))\n\n        try app.test(.GET, \"/Utilities/foo%20bar.html\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Hello</h1>\\n\")\n        }\n    }\n\n    func testPercentDecodedRelativePath() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))\n\n        try app.test(.GET, \"%2e%2e/VaporTests/Utilities/foo.txt\") { res in\n            XCTAssertEqual(res.status, .forbidden)\n        }.test(.GET, \"Utilities/foo.txt\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"bar\\n\")\n        }\n    }\n    \n    func testDefaultFileRelative() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path, defaultFile: \"index.html\"))\n\n        try app.test(.GET, \"Utilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")\n        }.test(.GET, \"Utilities/SubUtilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Subdirectory Default</h1>\\n\")\n        }\n    }\n    \n    func testDefaultFileAbsolute() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path, defaultFile: \"/Utilities/index.html\"))\n\n        try app.test(.GET, \"Utilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")\n        }.test(.GET, \"Utilities/SubUtilities/\") { res in\n            XCTAssertEqual(res.status, .ok)\n            XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")\n        }\n    }\n    \n    func testNoDefaultFile() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let path = #file.split(separator: \"/\").dropLast().joined(separator: \"/\")\n        app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))\n\n        try app.test(.GET, \"Utilities/\") { res in\n            XCTAssertEqual(res.status, .notFound)\n        }\n    }\n    \n    // https://github.com/vapor/vapor/security/advisories/GHSA-vj2m-9f5j-mpr5\n    func testInvalidRangeHeaderDoesNotCrash() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.get(\"file-stream\") { req in\n            return req.fileio.streamFile(at: #file)\n        }\n\n        var headers = HTTPHeaders()\n        headers.replaceOrAdd(name: .range, value: \"bytes=0-9223372036854775807\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=-1-10\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=100-10\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=10--100\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=9223372036854775808-\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=922337203-\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=-922337203\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n        \n        headers.replaceOrAdd(name: .range, value: \"bytes=-9223372036854775808\")\n        try app.testable(method: .running).test(.GET, \"/file-stream\", headers: headers) { res in\n            XCTAssertEqual(res.status, .badRequest)\n        }\n    }\n}\n"], "filenames": ["Sources/Vapor/Utilities/FileIO.swift", "Tests/VaporTests/FileTests.swift"], "buggy_code_start_loc": [1, 248], "buggy_code_end_loc": [263, 248], "fixing_code_start_loc": [2, 249], "fixing_code_end_loc": [291, 300], "type": "CWE-190", "message": "Vapor is an HTTP web framework for Swift. Users of Vapor prior to version 4.60.3 with FileMiddleware enabled are vulnerable to an integer overflow vulnerability that can crash the application. Version 4.60.3 contains a patch for this issue. As a workaround, disable FileMiddleware and serve via a Content Delivery Network.", "other": {"cve": {"id": "CVE-2022-31005", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-31T20:15:07.973", "lastModified": "2022-06-10T14:22:48.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vapor is an HTTP web framework for Swift. Users of Vapor prior to version 4.60.3 with FileMiddleware enabled are vulnerable to an integer overflow vulnerability that can crash the application. Version 4.60.3 contains a patch for this issue. As a workaround, disable FileMiddleware and serve via a Content Delivery Network."}, {"lang": "es", "value": "Vapor es un framework web HTTP para Swift. Los usuarios de Vapor anteriores a la versi\u00f3n 4.60.3 con FileMiddleware activado son vulnerables a una vulnerabilidad de desbordamiento de enteros que puede bloquear la aplicaci\u00f3n. La versi\u00f3n 4.60.3 contiene un parche para este problema. Como soluci\u00f3n, desactive FileMiddleware y sirva a trav\u00e9s de una red de distribuci\u00f3n de contenidos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vapor:vapor:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.60.3", "matchCriteriaId": "B8DF55F4-EF6D-4E8B-90F0-23D721D0CB08"}]}]}], "references": [{"url": "https://github.com/vapor/vapor/commit/953a349b539b3e0d3653585c8ffb50c427986df1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vapor/vapor/releases/tag/4.60.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vapor/vapor/security/advisories/GHSA-vj2m-9f5j-mpr5", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vapor/vapor/commit/953a349b539b3e0d3653585c8ffb50c427986df1"}}