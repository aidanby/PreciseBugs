{"buggy_code": ["/*\n * Driver for Cadence QSPI Controller\n *\n * Copyright Altera Corporation (C) 2012-2014. All rights reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/spi/spi.h>\n#include <linux/timer.h>\n\n#define CQSPI_NAME\t\t\t\"cadence-qspi\"\n#define CQSPI_MAX_CHIPSELECT\t\t16\n\nstruct cqspi_st;\n\nstruct cqspi_flash_pdata {\n\tstruct spi_nor\tnor;\n\tstruct cqspi_st\t*cqspi;\n\tu32\t\tclk_rate;\n\tu32\t\tread_delay;\n\tu32\t\ttshsl_ns;\n\tu32\t\ttsd2d_ns;\n\tu32\t\ttchsh_ns;\n\tu32\t\ttslch_ns;\n\tu8\t\tinst_width;\n\tu8\t\taddr_width;\n\tu8\t\tdata_width;\n\tu8\t\tcs;\n\tbool\t\tregistered;\n};\n\nstruct cqspi_st {\n\tstruct platform_device\t*pdev;\n\n\tstruct clk\t\t*clk;\n\tunsigned int\t\tsclk;\n\n\tvoid __iomem\t\t*iobase;\n\tvoid __iomem\t\t*ahb_base;\n\tstruct completion\ttransfer_complete;\n\tstruct mutex\t\tbus_mutex;\n\n\tint\t\t\tcurrent_cs;\n\tint\t\t\tcurrent_page_size;\n\tint\t\t\tcurrent_erase_size;\n\tint\t\t\tcurrent_addr_width;\n\tunsigned long\t\tmaster_ref_clk_hz;\n\tbool\t\t\tis_decoded_cs;\n\tu32\t\t\tfifo_depth;\n\tu32\t\t\tfifo_width;\n\tu32\t\t\ttrigger_address;\n\tstruct cqspi_flash_pdata f_pdata[CQSPI_MAX_CHIPSELECT];\n};\n\n/* Operation timeout value */\n#define CQSPI_TIMEOUT_MS\t\t\t500\n#define CQSPI_READ_TIMEOUT_MS\t\t\t10\n\n/* Instruction type */\n#define CQSPI_INST_TYPE_SINGLE\t\t\t0\n#define CQSPI_INST_TYPE_DUAL\t\t\t1\n#define CQSPI_INST_TYPE_QUAD\t\t\t2\n\n#define CQSPI_DUMMY_CLKS_PER_BYTE\t\t8\n#define CQSPI_DUMMY_BYTES_MAX\t\t\t4\n#define CQSPI_DUMMY_CLKS_MAX\t\t\t31\n\n#define CQSPI_STIG_DATA_LEN_MAX\t\t\t8\n\n/* Register map */\n#define CQSPI_REG_CONFIG\t\t\t0x00\n#define CQSPI_REG_CONFIG_ENABLE_MASK\t\tBIT(0)\n#define CQSPI_REG_CONFIG_DECODE_MASK\t\tBIT(9)\n#define CQSPI_REG_CONFIG_CHIPSELECT_LSB\t\t10\n#define CQSPI_REG_CONFIG_DMA_MASK\t\tBIT(15)\n#define CQSPI_REG_CONFIG_BAUD_LSB\t\t19\n#define CQSPI_REG_CONFIG_IDLE_LSB\t\t31\n#define CQSPI_REG_CONFIG_CHIPSELECT_MASK\t0xF\n#define CQSPI_REG_CONFIG_BAUD_MASK\t\t0xF\n\n#define CQSPI_REG_RD_INSTR\t\t\t0x04\n#define CQSPI_REG_RD_INSTR_OPCODE_LSB\t\t0\n#define CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB\t8\n#define CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB\t12\n#define CQSPI_REG_RD_INSTR_TYPE_DATA_LSB\t16\n#define CQSPI_REG_RD_INSTR_MODE_EN_LSB\t\t20\n#define CQSPI_REG_RD_INSTR_DUMMY_LSB\t\t24\n#define CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_TYPE_DATA_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_DUMMY_MASK\t\t0x1F\n\n#define CQSPI_REG_WR_INSTR\t\t\t0x08\n#define CQSPI_REG_WR_INSTR_OPCODE_LSB\t\t0\n#define CQSPI_REG_WR_INSTR_TYPE_ADDR_LSB\t12\n#define CQSPI_REG_WR_INSTR_TYPE_DATA_LSB\t16\n\n#define CQSPI_REG_DELAY\t\t\t\t0x0C\n#define CQSPI_REG_DELAY_TSLCH_LSB\t\t0\n#define CQSPI_REG_DELAY_TCHSH_LSB\t\t8\n#define CQSPI_REG_DELAY_TSD2D_LSB\t\t16\n#define CQSPI_REG_DELAY_TSHSL_LSB\t\t24\n#define CQSPI_REG_DELAY_TSLCH_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TCHSH_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TSD2D_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TSHSL_MASK\t\t0xFF\n\n#define CQSPI_REG_READCAPTURE\t\t\t0x10\n#define CQSPI_REG_READCAPTURE_BYPASS_LSB\t0\n#define CQSPI_REG_READCAPTURE_DELAY_LSB\t\t1\n#define CQSPI_REG_READCAPTURE_DELAY_MASK\t0xF\n\n#define CQSPI_REG_SIZE\t\t\t\t0x14\n#define CQSPI_REG_SIZE_ADDRESS_LSB\t\t0\n#define CQSPI_REG_SIZE_PAGE_LSB\t\t\t4\n#define CQSPI_REG_SIZE_BLOCK_LSB\t\t16\n#define CQSPI_REG_SIZE_ADDRESS_MASK\t\t0xF\n#define CQSPI_REG_SIZE_PAGE_MASK\t\t0xFFF\n#define CQSPI_REG_SIZE_BLOCK_MASK\t\t0x3F\n\n#define CQSPI_REG_SRAMPARTITION\t\t\t0x18\n#define CQSPI_REG_INDIRECTTRIGGER\t\t0x1C\n\n#define CQSPI_REG_DMA\t\t\t\t0x20\n#define CQSPI_REG_DMA_SINGLE_LSB\t\t0\n#define CQSPI_REG_DMA_BURST_LSB\t\t\t8\n#define CQSPI_REG_DMA_SINGLE_MASK\t\t0xFF\n#define CQSPI_REG_DMA_BURST_MASK\t\t0xFF\n\n#define CQSPI_REG_REMAP\t\t\t\t0x24\n#define CQSPI_REG_MODE_BIT\t\t\t0x28\n\n#define CQSPI_REG_SDRAMLEVEL\t\t\t0x2C\n#define CQSPI_REG_SDRAMLEVEL_RD_LSB\t\t0\n#define CQSPI_REG_SDRAMLEVEL_WR_LSB\t\t16\n#define CQSPI_REG_SDRAMLEVEL_RD_MASK\t\t0xFFFF\n#define CQSPI_REG_SDRAMLEVEL_WR_MASK\t\t0xFFFF\n\n#define CQSPI_REG_IRQSTATUS\t\t\t0x40\n#define CQSPI_REG_IRQMASK\t\t\t0x44\n\n#define CQSPI_REG_INDIRECTRD\t\t\t0x60\n#define CQSPI_REG_INDIRECTRD_START_MASK\t\tBIT(0)\n#define CQSPI_REG_INDIRECTRD_CANCEL_MASK\tBIT(1)\n#define CQSPI_REG_INDIRECTRD_DONE_MASK\t\tBIT(5)\n\n#define CQSPI_REG_INDIRECTRDWATERMARK\t\t0x64\n#define CQSPI_REG_INDIRECTRDSTARTADDR\t\t0x68\n#define CQSPI_REG_INDIRECTRDBYTES\t\t0x6C\n\n#define CQSPI_REG_CMDCTRL\t\t\t0x90\n#define CQSPI_REG_CMDCTRL_EXECUTE_MASK\t\tBIT(0)\n#define CQSPI_REG_CMDCTRL_INPROGRESS_MASK\tBIT(1)\n#define CQSPI_REG_CMDCTRL_WR_BYTES_LSB\t\t12\n#define CQSPI_REG_CMDCTRL_WR_EN_LSB\t\t15\n#define CQSPI_REG_CMDCTRL_ADD_BYTES_LSB\t\t16\n#define CQSPI_REG_CMDCTRL_ADDR_EN_LSB\t\t19\n#define CQSPI_REG_CMDCTRL_RD_BYTES_LSB\t\t20\n#define CQSPI_REG_CMDCTRL_RD_EN_LSB\t\t23\n#define CQSPI_REG_CMDCTRL_OPCODE_LSB\t\t24\n#define CQSPI_REG_CMDCTRL_WR_BYTES_MASK\t\t0x7\n#define CQSPI_REG_CMDCTRL_ADD_BYTES_MASK\t0x3\n#define CQSPI_REG_CMDCTRL_RD_BYTES_MASK\t\t0x7\n\n#define CQSPI_REG_INDIRECTWR\t\t\t0x70\n#define CQSPI_REG_INDIRECTWR_START_MASK\t\tBIT(0)\n#define CQSPI_REG_INDIRECTWR_CANCEL_MASK\tBIT(1)\n#define CQSPI_REG_INDIRECTWR_DONE_MASK\t\tBIT(5)\n\n#define CQSPI_REG_INDIRECTWRWATERMARK\t\t0x74\n#define CQSPI_REG_INDIRECTWRSTARTADDR\t\t0x78\n#define CQSPI_REG_INDIRECTWRBYTES\t\t0x7C\n\n#define CQSPI_REG_CMDADDRESS\t\t\t0x94\n#define CQSPI_REG_CMDREADDATALOWER\t\t0xA0\n#define CQSPI_REG_CMDREADDATAUPPER\t\t0xA4\n#define CQSPI_REG_CMDWRITEDATALOWER\t\t0xA8\n#define CQSPI_REG_CMDWRITEDATAUPPER\t\t0xAC\n\n/* Interrupt status bits */\n#define CQSPI_REG_IRQ_MODE_ERR\t\t\tBIT(0)\n#define CQSPI_REG_IRQ_UNDERFLOW\t\t\tBIT(1)\n#define CQSPI_REG_IRQ_IND_COMP\t\t\tBIT(2)\n#define CQSPI_REG_IRQ_IND_RD_REJECT\t\tBIT(3)\n#define CQSPI_REG_IRQ_WR_PROTECTED_ERR\t\tBIT(4)\n#define CQSPI_REG_IRQ_ILLEGAL_AHB_ERR\t\tBIT(5)\n#define CQSPI_REG_IRQ_WATERMARK\t\t\tBIT(6)\n#define CQSPI_REG_IRQ_IND_SRAM_FULL\t\tBIT(12)\n\n#define CQSPI_IRQ_MASK_RD\t\t(CQSPI_REG_IRQ_WATERMARK\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_IND_SRAM_FULL\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_IND_COMP)\n\n#define CQSPI_IRQ_MASK_WR\t\t(CQSPI_REG_IRQ_IND_COMP\t\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_WATERMARK\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_UNDERFLOW)\n\n#define CQSPI_IRQ_STATUS_MASK\t\t0x1FFFF\n\nstatic int cqspi_wait_for_bit(void __iomem *reg, const u32 mask, bool clear)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\n\tu32 val;\n\n\twhile (1) {\n\t\tval = readl(reg);\n\t\tif (clear)\n\t\t\tval = ~val;\n\t\tval &= mask;\n\n\t\tif (val == mask)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, end))\n\t\t\treturn -ETIMEDOUT;\n\t}\n}\n\nstatic bool cqspi_is_idle(struct cqspi_st *cqspi)\n{\n\tu32 reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\n\treturn reg & (1 << CQSPI_REG_CONFIG_IDLE_LSB);\n}\n\nstatic u32 cqspi_get_rd_sram_level(struct cqspi_st *cqspi)\n{\n\tu32 reg = readl(cqspi->iobase + CQSPI_REG_SDRAMLEVEL);\n\n\treg >>= CQSPI_REG_SDRAMLEVEL_RD_LSB;\n\treturn reg & CQSPI_REG_SDRAMLEVEL_RD_MASK;\n}\n\nstatic irqreturn_t cqspi_irq_handler(int this_irq, void *dev)\n{\n\tstruct cqspi_st *cqspi = dev;\n\tunsigned int irq_status;\n\n\t/* Read interrupt status */\n\tirq_status = readl(cqspi->iobase + CQSPI_REG_IRQSTATUS);\n\n\t/* Clear interrupt */\n\twritel(irq_status, cqspi->iobase + CQSPI_REG_IRQSTATUS);\n\n\tirq_status &= CQSPI_IRQ_MASK_RD | CQSPI_IRQ_MASK_WR;\n\n\tif (irq_status)\n\t\tcomplete(&cqspi->transfer_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int cqspi_calc_rdreg(struct spi_nor *nor, const u8 opcode)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tu32 rdreg = 0;\n\n\trdreg |= f_pdata->inst_width << CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB;\n\trdreg |= f_pdata->addr_width << CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB;\n\trdreg |= f_pdata->data_width << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB;\n\n\treturn rdreg;\n}\n\nstatic int cqspi_wait_idle(struct cqspi_st *cqspi)\n{\n\tconst unsigned int poll_idle_retry = 3;\n\tunsigned int count = 0;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\n\twhile (1) {\n\t\t/*\n\t\t * Read few times in succession to ensure the controller\n\t\t * is indeed idle, that is, the bit does not transition\n\t\t * low again.\n\t\t */\n\t\tif (cqspi_is_idle(cqspi))\n\t\t\tcount++;\n\t\telse\n\t\t\tcount = 0;\n\n\t\tif (count >= poll_idle_retry)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t/* Timeout, in busy mode. */\n\t\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\t\"QSPI is still busy after %dms timeout.\\n\",\n\t\t\t\tCQSPI_TIMEOUT_MS);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n}\n\nstatic int cqspi_exec_flash_cmd(struct cqspi_st *cqspi, unsigned int reg)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tint ret;\n\n\t/* Write the CMDCTRL without start execution. */\n\twritel(reg, reg_base + CQSPI_REG_CMDCTRL);\n\t/* Start execute */\n\treg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;\n\twritel(reg, reg_base + CQSPI_REG_CMDCTRL);\n\n\t/* Polling for completion. */\n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_CMDCTRL,\n\t\t\t\t CQSPI_REG_CMDCTRL_INPROGRESS_MASK, 1);\n\tif (ret) {\n\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\"Flash command execution timed out.\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Polling QSPI idle status. */\n\treturn cqspi_wait_idle(cqspi);\n}\n\nstatic int cqspi_command_read(struct spi_nor *nor,\n\t\t\t      const u8 *txbuf, const unsigned n_tx,\n\t\t\t      u8 *rxbuf, const unsigned n_rx)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int rdreg;\n\tunsigned int reg;\n\tunsigned int read_len;\n\tint status;\n\n\tif (!n_rx || n_rx > CQSPI_STIG_DATA_LEN_MAX || !rxbuf) {\n\t\tdev_err(nor->dev, \"Invalid input argument, len %d rxbuf 0x%p\\n\",\n\t\t\tn_rx, rxbuf);\n\t\treturn -EINVAL;\n\t}\n\n\treg = txbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\n\trdreg = cqspi_calc_rdreg(nor, txbuf[0]);\n\twritel(rdreg, reg_base + CQSPI_REG_RD_INSTR);\n\n\treg |= (0x1 << CQSPI_REG_CMDCTRL_RD_EN_LSB);\n\n\t/* 0 means 1 byte. */\n\treg |= (((n_rx - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)\n\t\t<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB);\n\tstatus = cqspi_exec_flash_cmd(cqspi, reg);\n\tif (status)\n\t\treturn status;\n\n\treg = readl(reg_base + CQSPI_REG_CMDREADDATALOWER);\n\n\t/* Put the read value into rx_buf */\n\tread_len = (n_rx > 4) ? 4 : n_rx;\n\tmemcpy(rxbuf, &reg, read_len);\n\trxbuf += read_len;\n\n\tif (n_rx > 4) {\n\t\treg = readl(reg_base + CQSPI_REG_CMDREADDATAUPPER);\n\n\t\tread_len = n_rx - read_len;\n\t\tmemcpy(rxbuf, &reg, read_len);\n\t}\n\n\treturn 0;\n}\n\nstatic int cqspi_command_write(struct spi_nor *nor, const u8 opcode,\n\t\t\t       const u8 *txbuf, const unsigned n_tx)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\tunsigned int data;\n\tint ret;\n\n\tif (n_tx > 4 || (n_tx && !txbuf)) {\n\t\tdev_err(nor->dev,\n\t\t\t\"Invalid input argument, cmdlen %d txbuf 0x%p\\n\",\n\t\t\tn_tx, txbuf);\n\t\treturn -EINVAL;\n\t}\n\n\treg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\tif (n_tx) {\n\t\treg |= (0x1 << CQSPI_REG_CMDCTRL_WR_EN_LSB);\n\t\treg |= ((n_tx - 1) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)\n\t\t\t<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;\n\t\tdata = 0;\n\t\tmemcpy(&data, txbuf, n_tx);\n\t\twritel(data, reg_base + CQSPI_REG_CMDWRITEDATALOWER);\n\t}\n\n\tret = cqspi_exec_flash_cmd(cqspi, reg);\n\treturn ret;\n}\n\nstatic int cqspi_command_write_addr(struct spi_nor *nor,\n\t\t\t\t    const u8 opcode, const unsigned int addr)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\treg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);\n\treg |= ((nor->addr_width - 1) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)\n\t\t<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;\n\n\twritel(addr, reg_base + CQSPI_REG_CMDADDRESS);\n\n\treturn cqspi_exec_flash_cmd(cqspi, reg);\n}\n\nstatic int cqspi_indirect_read_setup(struct spi_nor *nor,\n\t\t\t\t     const unsigned int from_addr)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int dummy_clk = 0;\n\tunsigned int reg;\n\n\twritel(from_addr, reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);\n\n\treg = nor->read_opcode << CQSPI_REG_RD_INSTR_OPCODE_LSB;\n\treg |= cqspi_calc_rdreg(nor, nor->read_opcode);\n\n\t/* Setup dummy clock cycles */\n\tdummy_clk = nor->read_dummy;\n\tif (dummy_clk > CQSPI_DUMMY_CLKS_MAX)\n\t\tdummy_clk = CQSPI_DUMMY_CLKS_MAX;\n\n\tif (dummy_clk / 8) {\n\t\treg |= (1 << CQSPI_REG_RD_INSTR_MODE_EN_LSB);\n\t\t/* Set mode bits high to ensure chip doesn't enter XIP */\n\t\twritel(0xFF, reg_base + CQSPI_REG_MODE_BIT);\n\n\t\t/* Need to subtract the mode byte (8 clocks). */\n\t\tif (f_pdata->inst_width != CQSPI_INST_TYPE_QUAD)\n\t\t\tdummy_clk -= 8;\n\n\t\tif (dummy_clk)\n\t\t\treg |= (dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK)\n\t\t\t       << CQSPI_REG_RD_INSTR_DUMMY_LSB;\n\t}\n\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\t/* Set address width */\n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->addr_width - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n\nstatic int cqspi_indirect_read_execute(struct spi_nor *nor,\n\t\t\t\t       u8 *rxbuf, const unsigned n_rx)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tvoid __iomem *ahb_base = cqspi->ahb_base;\n\tunsigned int remaining = n_rx;\n\tunsigned int bytes_to_read = 0;\n\tint ret = 0;\n\n\twritel(remaining, reg_base + CQSPI_REG_INDIRECTRDBYTES);\n\n\t/* Clear all interrupts. */\n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\twritel(CQSPI_IRQ_MASK_RD, reg_base + CQSPI_REG_IRQMASK);\n\n\treinit_completion(&cqspi->transfer_complete);\n\twritel(CQSPI_REG_INDIRECTRD_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\n\twhile (remaining > 0) {\n\t\tret = wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t\t  msecs_to_jiffies\n\t\t\t\t\t\t  (CQSPI_READ_TIMEOUT_MS));\n\n\t\tbytes_to_read = cqspi_get_rd_sram_level(cqspi);\n\n\t\tif (!ret && bytes_to_read == 0) {\n\t\t\tdev_err(nor->dev, \"Indirect read timeout, no bytes\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto failrd;\n\t\t}\n\n\t\twhile (bytes_to_read != 0) {\n\t\t\tbytes_to_read *= cqspi->fifo_width;\n\t\t\tbytes_to_read = bytes_to_read > remaining ?\n\t\t\t\t\tremaining : bytes_to_read;\n\t\t\treadsl(ahb_base, rxbuf, DIV_ROUND_UP(bytes_to_read, 4));\n\t\t\trxbuf += bytes_to_read;\n\t\t\tremaining -= bytes_to_read;\n\t\t\tbytes_to_read = cqspi_get_rd_sram_level(cqspi);\n\t\t}\n\n\t\tif (remaining > 0)\n\t\t\treinit_completion(&cqspi->transfer_complete);\n\t}\n\n\t/* Check indirect done status */\n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTRD,\n\t\t\t\t CQSPI_REG_INDIRECTRD_DONE_MASK, 0);\n\tif (ret) {\n\t\tdev_err(nor->dev,\n\t\t\t\"Indirect read completion error (%i)\\n\", ret);\n\t\tgoto failrd;\n\t}\n\n\t/* Disable interrupt */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Clear indirect completion status */\n\twritel(CQSPI_REG_INDIRECTRD_DONE_MASK, reg_base + CQSPI_REG_INDIRECTRD);\n\n\treturn 0;\n\nfailrd:\n\t/* Disable interrupt */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Cancel the indirect read */\n\twritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\treturn ret;\n}\n\nstatic int cqspi_indirect_write_setup(struct spi_nor *nor,\n\t\t\t\t      const unsigned int to_addr)\n{\n\tunsigned int reg;\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\n\t/* Set opcode. */\n\treg = nor->program_opcode << CQSPI_REG_WR_INSTR_OPCODE_LSB;\n\twritel(reg, reg_base + CQSPI_REG_WR_INSTR);\n\treg = cqspi_calc_rdreg(nor, nor->program_opcode);\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\twritel(to_addr, reg_base + CQSPI_REG_INDIRECTWRSTARTADDR);\n\n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->addr_width - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n\nstatic int cqspi_indirect_write_execute(struct spi_nor *nor,\n\t\t\t\t\tconst u8 *txbuf, const unsigned n_tx)\n{\n\tconst unsigned int page_size = nor->page_size;\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int remaining = n_tx;\n\tunsigned int write_bytes;\n\tint ret;\n\n\twritel(remaining, reg_base + CQSPI_REG_INDIRECTWRBYTES);\n\n\t/* Clear all interrupts. */\n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\twritel(CQSPI_IRQ_MASK_WR, reg_base + CQSPI_REG_IRQMASK);\n\n\treinit_completion(&cqspi->transfer_complete);\n\twritel(CQSPI_REG_INDIRECTWR_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTWR);\n\n\twhile (remaining > 0) {\n\t\twrite_bytes = remaining > page_size ? page_size : remaining;\n\t\twritesl(cqspi->ahb_base, txbuf, DIV_ROUND_UP(write_bytes, 4));\n\n\t\tret = wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t\t  msecs_to_jiffies\n\t\t\t\t\t\t  (CQSPI_TIMEOUT_MS));\n\t\tif (!ret) {\n\t\t\tdev_err(nor->dev, \"Indirect write timeout\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto failwr;\n\t\t}\n\n\t\ttxbuf += write_bytes;\n\t\tremaining -= write_bytes;\n\n\t\tif (remaining > 0)\n\t\t\treinit_completion(&cqspi->transfer_complete);\n\t}\n\n\t/* Check indirect done status */\n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTWR,\n\t\t\t\t CQSPI_REG_INDIRECTWR_DONE_MASK, 0);\n\tif (ret) {\n\t\tdev_err(nor->dev,\n\t\t\t\"Indirect write completion error (%i)\\n\", ret);\n\t\tgoto failwr;\n\t}\n\n\t/* Disable interrupt. */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Clear indirect completion status */\n\twritel(CQSPI_REG_INDIRECTWR_DONE_MASK, reg_base + CQSPI_REG_INDIRECTWR);\n\n\tcqspi_wait_idle(cqspi);\n\n\treturn 0;\n\nfailwr:\n\t/* Disable interrupt. */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Cancel the indirect write */\n\twritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTWR);\n\treturn ret;\n}\n\nstatic void cqspi_chipselect(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int chip_select = f_pdata->cs;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\tif (cqspi->is_decoded_cs) {\n\t\treg |= CQSPI_REG_CONFIG_DECODE_MASK;\n\t} else {\n\t\treg &= ~CQSPI_REG_CONFIG_DECODE_MASK;\n\n\t\t/* Convert CS if without decoder.\n\t\t * CS0 to 4b'1110\n\t\t * CS1 to 4b'1101\n\t\t * CS2 to 4b'1011\n\t\t * CS3 to 4b'0111\n\t\t */\n\t\tchip_select = 0xF & ~(1 << chip_select);\n\t}\n\n\treg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK\n\t\t << CQSPI_REG_CONFIG_CHIPSELECT_LSB);\n\treg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)\n\t    << CQSPI_REG_CONFIG_CHIPSELECT_LSB;\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_configure_cs_and_sizes(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *iobase = cqspi->iobase;\n\tunsigned int reg;\n\n\t/* configure page size and block size. */\n\treg = readl(iobase + CQSPI_REG_SIZE);\n\treg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);\n\treg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->page_size << CQSPI_REG_SIZE_PAGE_LSB);\n\treg |= (ilog2(nor->mtd.erasesize) << CQSPI_REG_SIZE_BLOCK_LSB);\n\treg |= (nor->addr_width - 1);\n\twritel(reg, iobase + CQSPI_REG_SIZE);\n\n\t/* configure the chip select */\n\tcqspi_chipselect(nor);\n\n\t/* Store the new configuration of the controller */\n\tcqspi->current_page_size = nor->page_size;\n\tcqspi->current_erase_size = nor->mtd.erasesize;\n\tcqspi->current_addr_width = nor->addr_width;\n}\n\nstatic unsigned int calculate_ticks_for_ns(const unsigned int ref_clk_hz,\n\t\t\t\t\t   const unsigned int ns_val)\n{\n\tunsigned int ticks;\n\n\tticks = ref_clk_hz / 1000;\t/* kHz */\n\tticks = DIV_ROUND_UP(ticks * ns_val, 1000000);\n\n\treturn ticks;\n}\n\nstatic void cqspi_delay(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *iobase = cqspi->iobase;\n\tconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\n\tunsigned int tshsl, tchsh, tslch, tsd2d;\n\tunsigned int reg;\n\tunsigned int tsclk;\n\n\t/* calculate the number of ref ticks for one sclk tick */\n\ttsclk = DIV_ROUND_UP(ref_clk_hz, cqspi->sclk);\n\n\ttshsl = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tshsl_ns);\n\t/* this particular value must be at least one sclk */\n\tif (tshsl < tsclk)\n\t\ttshsl = tsclk;\n\n\ttchsh = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tchsh_ns);\n\ttslch = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tslch_ns);\n\ttsd2d = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tsd2d_ns);\n\n\treg = (tshsl & CQSPI_REG_DELAY_TSHSL_MASK)\n\t       << CQSPI_REG_DELAY_TSHSL_LSB;\n\treg |= (tchsh & CQSPI_REG_DELAY_TCHSH_MASK)\n\t\t<< CQSPI_REG_DELAY_TCHSH_LSB;\n\treg |= (tslch & CQSPI_REG_DELAY_TSLCH_MASK)\n\t\t<< CQSPI_REG_DELAY_TSLCH_LSB;\n\treg |= (tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)\n\t\t<< CQSPI_REG_DELAY_TSD2D_LSB;\n\twritel(reg, iobase + CQSPI_REG_DELAY);\n}\n\nstatic void cqspi_config_baudrate_div(struct cqspi_st *cqspi)\n{\n\tconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu32 reg, div;\n\n\t/* Recalculate the baudrate divisor based on QSPI specification. */\n\tdiv = DIV_ROUND_UP(ref_clk_hz, 2 * cqspi->sclk) - 1;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\treg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);\n\treg |= (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_readdata_capture(struct cqspi_st *cqspi,\n\t\t\t\t   const unsigned int bypass,\n\t\t\t\t   const unsigned int delay)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_READCAPTURE);\n\n\tif (bypass)\n\t\treg |= (1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\n\telse\n\t\treg &= ~(1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\n\n\treg &= ~(CQSPI_REG_READCAPTURE_DELAY_MASK\n\t\t << CQSPI_REG_READCAPTURE_DELAY_LSB);\n\n\treg |= (delay & CQSPI_REG_READCAPTURE_DELAY_MASK)\n\t\t<< CQSPI_REG_READCAPTURE_DELAY_LSB;\n\n\twritel(reg, reg_base + CQSPI_REG_READCAPTURE);\n}\n\nstatic void cqspi_controller_enable(struct cqspi_st *cqspi, bool enable)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\n\tif (enable)\n\t\treg |= CQSPI_REG_CONFIG_ENABLE_MASK;\n\telse\n\t\treg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;\n\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_configure(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tconst unsigned int sclk = f_pdata->clk_rate;\n\tint switch_cs = (cqspi->current_cs != f_pdata->cs);\n\tint switch_ck = (cqspi->sclk != sclk);\n\n\tif ((cqspi->current_page_size != nor->page_size) ||\n\t    (cqspi->current_erase_size != nor->mtd.erasesize) ||\n\t    (cqspi->current_addr_width != nor->addr_width))\n\t\tswitch_cs = 1;\n\n\tif (switch_cs || switch_ck)\n\t\tcqspi_controller_enable(cqspi, 0);\n\n\t/* Switch chip select. */\n\tif (switch_cs) {\n\t\tcqspi->current_cs = f_pdata->cs;\n\t\tcqspi_configure_cs_and_sizes(nor);\n\t}\n\n\t/* Setup baudrate divisor and delays */\n\tif (switch_ck) {\n\t\tcqspi->sclk = sclk;\n\t\tcqspi_config_baudrate_div(cqspi);\n\t\tcqspi_delay(nor);\n\t\tcqspi_readdata_capture(cqspi, 1, f_pdata->read_delay);\n\t}\n\n\tif (switch_cs || switch_ck)\n\t\tcqspi_controller_enable(cqspi, 1);\n}\n\nstatic int cqspi_set_protocol(struct spi_nor *nor, const int read)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\n\tf_pdata->inst_width = CQSPI_INST_TYPE_SINGLE;\n\tf_pdata->addr_width = CQSPI_INST_TYPE_SINGLE;\n\tf_pdata->data_width = CQSPI_INST_TYPE_SINGLE;\n\n\tif (read) {\n\t\tswitch (nor->flash_read) {\n\t\tcase SPI_NOR_NORMAL:\n\t\tcase SPI_NOR_FAST:\n\t\t\tf_pdata->data_width = CQSPI_INST_TYPE_SINGLE;\n\t\t\tbreak;\n\t\tcase SPI_NOR_DUAL:\n\t\t\tf_pdata->data_width = CQSPI_INST_TYPE_DUAL;\n\t\t\tbreak;\n\t\tcase SPI_NOR_QUAD:\n\t\t\tf_pdata->data_width = CQSPI_INST_TYPE_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcqspi_configure(nor);\n\n\treturn 0;\n}\n\nstatic ssize_t cqspi_write(struct spi_nor *nor, loff_t to,\n\t\t\t   size_t len, const u_char *buf)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_write_setup(nor, to);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_write_execute(nor, buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (ret < 0) ? ret : len;\n}\n\nstatic ssize_t cqspi_read(struct spi_nor *nor, loff_t from,\n\t\t\t  size_t len, u_char *buf)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_read_setup(nor, from);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_read_execute(nor, buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (ret < 0) ? ret : len;\n}\n\nstatic int cqspi_erase(struct spi_nor *nor, loff_t offs)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Send write enable, then erase commands. */\n\tret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Set up command buffer. */\n\tret = cqspi_command_write_addr(nor, nor->erase_opcode, offs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cqspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\n\tmutex_lock(&cqspi->bus_mutex);\n\n\treturn 0;\n}\n\nstatic void cqspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\n\tmutex_unlock(&cqspi->bus_mutex);\n}\n\nstatic int cqspi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (!ret)\n\t\tret = cqspi_command_read(nor, &opcode, 1, buf, len);\n\n\treturn ret;\n}\n\nstatic int cqspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (!ret)\n\t\tret = cqspi_command_write(nor, opcode, buf, len);\n\n\treturn ret;\n}\n\nstatic int cqspi_of_get_flash_pdata(struct platform_device *pdev,\n\t\t\t\t    struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t    struct device_node *np)\n{\n\tif (of_property_read_u32(np, \"cdns,read-delay\", &f_pdata->read_delay)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine read-delay\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tshsl-ns\", &f_pdata->tshsl_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tshsl-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tsd2d-ns\", &f_pdata->tsd2d_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tsd2d-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tchsh-ns\", &f_pdata->tchsh_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tchsh-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tslch-ns\", &f_pdata->tslch_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tslch-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"spi-max-frequency\", &f_pdata->clk_rate)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine spi-max-frequency\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cqspi_of_get_pdata(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\n\n\tcqspi->is_decoded_cs = of_property_read_bool(np, \"cdns,is-decoded-cs\");\n\n\tif (of_property_read_u32(np, \"cdns,fifo-depth\", &cqspi->fifo_depth)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine fifo-depth\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,fifo-width\", &cqspi->fifo_width)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine fifo-width\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,trigger-address\",\n\t\t\t\t &cqspi->trigger_address)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine trigger-address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void cqspi_controller_init(struct cqspi_st *cqspi)\n{\n\tcqspi_controller_enable(cqspi, 0);\n\n\t/* Configure the remap address register, no remap */\n\twritel(0, cqspi->iobase + CQSPI_REG_REMAP);\n\n\t/* Disable all interrupts. */\n\twritel(0, cqspi->iobase + CQSPI_REG_IRQMASK);\n\n\t/* Configure the SRAM split to 1:1 . */\n\twritel(cqspi->fifo_depth / 2, cqspi->iobase + CQSPI_REG_SRAMPARTITION);\n\n\t/* Load indirect trigger address. */\n\twritel(cqspi->trigger_address,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTTRIGGER);\n\n\t/* Program read watermark -- 1/2 of the FIFO. */\n\twritel(cqspi->fifo_depth * cqspi->fifo_width / 2,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTRDWATERMARK);\n\t/* Program write watermark -- 1/8 of the FIFO. */\n\twritel(cqspi->fifo_depth * cqspi->fifo_width / 8,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTWRWATERMARK);\n\n\tcqspi_controller_enable(cqspi, 1);\n}\n\nstatic int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\n\t/* Get flash device data */\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\n\t\tmtd->priv = nor;\n\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tf_pdata->registered = true;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}\n\nstatic int cqspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_st *cqspi;\n\tstruct resource *res;\n\tstruct resource *res_ahb;\n\tint ret;\n\tint irq;\n\n\tcqspi = devm_kzalloc(dev, sizeof(*cqspi), GFP_KERNEL);\n\tif (!cqspi)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&cqspi->bus_mutex);\n\tcqspi->pdev = pdev;\n\tplatform_set_drvdata(pdev, cqspi);\n\n\t/* Obtain configuration from OF. */\n\tret = cqspi_of_get_pdata(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot get mandatory OF data.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Obtain QSPI clock. */\n\tcqspi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cqspi->clk)) {\n\t\tdev_err(dev, \"Cannot claim QSPI clock.\\n\");\n\t\treturn PTR_ERR(cqspi->clk);\n\t}\n\n\t/* Obtain and remap controller address. */\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tcqspi->iobase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(cqspi->iobase)) {\n\t\tdev_err(dev, \"Cannot remap controller address.\\n\");\n\t\treturn PTR_ERR(cqspi->iobase);\n\t}\n\n\t/* Obtain and remap AHB address. */\n\tres_ahb = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tcqspi->ahb_base = devm_ioremap_resource(dev, res_ahb);\n\tif (IS_ERR(cqspi->ahb_base)) {\n\t\tdev_err(dev, \"Cannot remap AHB address.\\n\");\n\t\treturn PTR_ERR(cqspi->ahb_base);\n\t}\n\n\tinit_completion(&cqspi->transfer_complete);\n\n\t/* Obtain IRQ line. */\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(dev, \"Cannot obtain IRQ.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = clk_prepare_enable(cqspi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable QSPI clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tcqspi->master_ref_clk_hz = clk_get_rate(cqspi->clk);\n\n\tret = devm_request_irq(dev, irq, cqspi_irq_handler, 0,\n\t\t\t       pdev->name, cqspi);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot request IRQ.\\n\");\n\t\tgoto probe_irq_failed;\n\t}\n\n\tcqspi_wait_idle(cqspi);\n\tcqspi_controller_init(cqspi);\n\tcqspi->current_cs = -1;\n\tcqspi->sclk = 0;\n\n\tret = cqspi_setup_flash(cqspi, np);\n\tif (ret) {\n\t\tdev_err(dev, \"Cadence QSPI NOR probe failed %d\\n\", ret);\n\t\tgoto probe_setup_failed;\n\t}\n\n\treturn ret;\nprobe_irq_failed:\n\tcqspi_controller_enable(cqspi, 0);\nprobe_setup_failed:\n\tclk_disable_unprepare(cqspi->clk);\n\treturn ret;\n}\n\nstatic int cqspi_remove(struct platform_device *pdev)\n{\n\tstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\n\tcqspi_controller_enable(cqspi, 0);\n\n\tclk_disable_unprepare(cqspi->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cqspi_suspend(struct device *dev)\n{\n\tstruct cqspi_st *cqspi = dev_get_drvdata(dev);\n\n\tcqspi_controller_enable(cqspi, 0);\n\treturn 0;\n}\n\nstatic int cqspi_resume(struct device *dev)\n{\n\tstruct cqspi_st *cqspi = dev_get_drvdata(dev);\n\n\tcqspi_controller_enable(cqspi, 1);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cqspi__dev_pm_ops = {\n\t.suspend = cqspi_suspend,\n\t.resume = cqspi_resume,\n};\n\n#define CQSPI_DEV_PM_OPS\t(&cqspi__dev_pm_ops)\n#else\n#define CQSPI_DEV_PM_OPS\tNULL\n#endif\n\nstatic struct of_device_id const cqspi_dt_ids[] = {\n\t{.compatible = \"cdns,qspi-nor\",},\n\t{ /* end of table */ }\n};\n\nMODULE_DEVICE_TABLE(of, cqspi_dt_ids);\n\nstatic struct platform_driver cqspi_platform_driver = {\n\t.probe = cqspi_probe,\n\t.remove = cqspi_remove,\n\t.driver = {\n\t\t.name = CQSPI_NAME,\n\t\t.pm = CQSPI_DEV_PM_OPS,\n\t\t.of_match_table = cqspi_dt_ids,\n\t},\n};\n\nmodule_platform_driver(cqspi_platform_driver);\n\nMODULE_DESCRIPTION(\"Cadence QSPI Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" CQSPI_NAME);\nMODULE_AUTHOR(\"Ley Foon Tan <lftan@altera.com>\");\nMODULE_AUTHOR(\"Graham Moore <grmoore@opensource.altera.com>\");\n"], "fixing_code": ["/*\n * Driver for Cadence QSPI Controller\n *\n * Copyright Altera Corporation (C) 2012-2014. All rights reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/spi/spi.h>\n#include <linux/timer.h>\n\n#define CQSPI_NAME\t\t\t\"cadence-qspi\"\n#define CQSPI_MAX_CHIPSELECT\t\t16\n\nstruct cqspi_st;\n\nstruct cqspi_flash_pdata {\n\tstruct spi_nor\tnor;\n\tstruct cqspi_st\t*cqspi;\n\tu32\t\tclk_rate;\n\tu32\t\tread_delay;\n\tu32\t\ttshsl_ns;\n\tu32\t\ttsd2d_ns;\n\tu32\t\ttchsh_ns;\n\tu32\t\ttslch_ns;\n\tu8\t\tinst_width;\n\tu8\t\taddr_width;\n\tu8\t\tdata_width;\n\tu8\t\tcs;\n\tbool\t\tregistered;\n};\n\nstruct cqspi_st {\n\tstruct platform_device\t*pdev;\n\n\tstruct clk\t\t*clk;\n\tunsigned int\t\tsclk;\n\n\tvoid __iomem\t\t*iobase;\n\tvoid __iomem\t\t*ahb_base;\n\tstruct completion\ttransfer_complete;\n\tstruct mutex\t\tbus_mutex;\n\n\tint\t\t\tcurrent_cs;\n\tint\t\t\tcurrent_page_size;\n\tint\t\t\tcurrent_erase_size;\n\tint\t\t\tcurrent_addr_width;\n\tunsigned long\t\tmaster_ref_clk_hz;\n\tbool\t\t\tis_decoded_cs;\n\tu32\t\t\tfifo_depth;\n\tu32\t\t\tfifo_width;\n\tu32\t\t\ttrigger_address;\n\tstruct cqspi_flash_pdata f_pdata[CQSPI_MAX_CHIPSELECT];\n};\n\n/* Operation timeout value */\n#define CQSPI_TIMEOUT_MS\t\t\t500\n#define CQSPI_READ_TIMEOUT_MS\t\t\t10\n\n/* Instruction type */\n#define CQSPI_INST_TYPE_SINGLE\t\t\t0\n#define CQSPI_INST_TYPE_DUAL\t\t\t1\n#define CQSPI_INST_TYPE_QUAD\t\t\t2\n\n#define CQSPI_DUMMY_CLKS_PER_BYTE\t\t8\n#define CQSPI_DUMMY_BYTES_MAX\t\t\t4\n#define CQSPI_DUMMY_CLKS_MAX\t\t\t31\n\n#define CQSPI_STIG_DATA_LEN_MAX\t\t\t8\n\n/* Register map */\n#define CQSPI_REG_CONFIG\t\t\t0x00\n#define CQSPI_REG_CONFIG_ENABLE_MASK\t\tBIT(0)\n#define CQSPI_REG_CONFIG_DECODE_MASK\t\tBIT(9)\n#define CQSPI_REG_CONFIG_CHIPSELECT_LSB\t\t10\n#define CQSPI_REG_CONFIG_DMA_MASK\t\tBIT(15)\n#define CQSPI_REG_CONFIG_BAUD_LSB\t\t19\n#define CQSPI_REG_CONFIG_IDLE_LSB\t\t31\n#define CQSPI_REG_CONFIG_CHIPSELECT_MASK\t0xF\n#define CQSPI_REG_CONFIG_BAUD_MASK\t\t0xF\n\n#define CQSPI_REG_RD_INSTR\t\t\t0x04\n#define CQSPI_REG_RD_INSTR_OPCODE_LSB\t\t0\n#define CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB\t8\n#define CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB\t12\n#define CQSPI_REG_RD_INSTR_TYPE_DATA_LSB\t16\n#define CQSPI_REG_RD_INSTR_MODE_EN_LSB\t\t20\n#define CQSPI_REG_RD_INSTR_DUMMY_LSB\t\t24\n#define CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_TYPE_DATA_MASK\t0x3\n#define CQSPI_REG_RD_INSTR_DUMMY_MASK\t\t0x1F\n\n#define CQSPI_REG_WR_INSTR\t\t\t0x08\n#define CQSPI_REG_WR_INSTR_OPCODE_LSB\t\t0\n#define CQSPI_REG_WR_INSTR_TYPE_ADDR_LSB\t12\n#define CQSPI_REG_WR_INSTR_TYPE_DATA_LSB\t16\n\n#define CQSPI_REG_DELAY\t\t\t\t0x0C\n#define CQSPI_REG_DELAY_TSLCH_LSB\t\t0\n#define CQSPI_REG_DELAY_TCHSH_LSB\t\t8\n#define CQSPI_REG_DELAY_TSD2D_LSB\t\t16\n#define CQSPI_REG_DELAY_TSHSL_LSB\t\t24\n#define CQSPI_REG_DELAY_TSLCH_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TCHSH_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TSD2D_MASK\t\t0xFF\n#define CQSPI_REG_DELAY_TSHSL_MASK\t\t0xFF\n\n#define CQSPI_REG_READCAPTURE\t\t\t0x10\n#define CQSPI_REG_READCAPTURE_BYPASS_LSB\t0\n#define CQSPI_REG_READCAPTURE_DELAY_LSB\t\t1\n#define CQSPI_REG_READCAPTURE_DELAY_MASK\t0xF\n\n#define CQSPI_REG_SIZE\t\t\t\t0x14\n#define CQSPI_REG_SIZE_ADDRESS_LSB\t\t0\n#define CQSPI_REG_SIZE_PAGE_LSB\t\t\t4\n#define CQSPI_REG_SIZE_BLOCK_LSB\t\t16\n#define CQSPI_REG_SIZE_ADDRESS_MASK\t\t0xF\n#define CQSPI_REG_SIZE_PAGE_MASK\t\t0xFFF\n#define CQSPI_REG_SIZE_BLOCK_MASK\t\t0x3F\n\n#define CQSPI_REG_SRAMPARTITION\t\t\t0x18\n#define CQSPI_REG_INDIRECTTRIGGER\t\t0x1C\n\n#define CQSPI_REG_DMA\t\t\t\t0x20\n#define CQSPI_REG_DMA_SINGLE_LSB\t\t0\n#define CQSPI_REG_DMA_BURST_LSB\t\t\t8\n#define CQSPI_REG_DMA_SINGLE_MASK\t\t0xFF\n#define CQSPI_REG_DMA_BURST_MASK\t\t0xFF\n\n#define CQSPI_REG_REMAP\t\t\t\t0x24\n#define CQSPI_REG_MODE_BIT\t\t\t0x28\n\n#define CQSPI_REG_SDRAMLEVEL\t\t\t0x2C\n#define CQSPI_REG_SDRAMLEVEL_RD_LSB\t\t0\n#define CQSPI_REG_SDRAMLEVEL_WR_LSB\t\t16\n#define CQSPI_REG_SDRAMLEVEL_RD_MASK\t\t0xFFFF\n#define CQSPI_REG_SDRAMLEVEL_WR_MASK\t\t0xFFFF\n\n#define CQSPI_REG_IRQSTATUS\t\t\t0x40\n#define CQSPI_REG_IRQMASK\t\t\t0x44\n\n#define CQSPI_REG_INDIRECTRD\t\t\t0x60\n#define CQSPI_REG_INDIRECTRD_START_MASK\t\tBIT(0)\n#define CQSPI_REG_INDIRECTRD_CANCEL_MASK\tBIT(1)\n#define CQSPI_REG_INDIRECTRD_DONE_MASK\t\tBIT(5)\n\n#define CQSPI_REG_INDIRECTRDWATERMARK\t\t0x64\n#define CQSPI_REG_INDIRECTRDSTARTADDR\t\t0x68\n#define CQSPI_REG_INDIRECTRDBYTES\t\t0x6C\n\n#define CQSPI_REG_CMDCTRL\t\t\t0x90\n#define CQSPI_REG_CMDCTRL_EXECUTE_MASK\t\tBIT(0)\n#define CQSPI_REG_CMDCTRL_INPROGRESS_MASK\tBIT(1)\n#define CQSPI_REG_CMDCTRL_WR_BYTES_LSB\t\t12\n#define CQSPI_REG_CMDCTRL_WR_EN_LSB\t\t15\n#define CQSPI_REG_CMDCTRL_ADD_BYTES_LSB\t\t16\n#define CQSPI_REG_CMDCTRL_ADDR_EN_LSB\t\t19\n#define CQSPI_REG_CMDCTRL_RD_BYTES_LSB\t\t20\n#define CQSPI_REG_CMDCTRL_RD_EN_LSB\t\t23\n#define CQSPI_REG_CMDCTRL_OPCODE_LSB\t\t24\n#define CQSPI_REG_CMDCTRL_WR_BYTES_MASK\t\t0x7\n#define CQSPI_REG_CMDCTRL_ADD_BYTES_MASK\t0x3\n#define CQSPI_REG_CMDCTRL_RD_BYTES_MASK\t\t0x7\n\n#define CQSPI_REG_INDIRECTWR\t\t\t0x70\n#define CQSPI_REG_INDIRECTWR_START_MASK\t\tBIT(0)\n#define CQSPI_REG_INDIRECTWR_CANCEL_MASK\tBIT(1)\n#define CQSPI_REG_INDIRECTWR_DONE_MASK\t\tBIT(5)\n\n#define CQSPI_REG_INDIRECTWRWATERMARK\t\t0x74\n#define CQSPI_REG_INDIRECTWRSTARTADDR\t\t0x78\n#define CQSPI_REG_INDIRECTWRBYTES\t\t0x7C\n\n#define CQSPI_REG_CMDADDRESS\t\t\t0x94\n#define CQSPI_REG_CMDREADDATALOWER\t\t0xA0\n#define CQSPI_REG_CMDREADDATAUPPER\t\t0xA4\n#define CQSPI_REG_CMDWRITEDATALOWER\t\t0xA8\n#define CQSPI_REG_CMDWRITEDATAUPPER\t\t0xAC\n\n/* Interrupt status bits */\n#define CQSPI_REG_IRQ_MODE_ERR\t\t\tBIT(0)\n#define CQSPI_REG_IRQ_UNDERFLOW\t\t\tBIT(1)\n#define CQSPI_REG_IRQ_IND_COMP\t\t\tBIT(2)\n#define CQSPI_REG_IRQ_IND_RD_REJECT\t\tBIT(3)\n#define CQSPI_REG_IRQ_WR_PROTECTED_ERR\t\tBIT(4)\n#define CQSPI_REG_IRQ_ILLEGAL_AHB_ERR\t\tBIT(5)\n#define CQSPI_REG_IRQ_WATERMARK\t\t\tBIT(6)\n#define CQSPI_REG_IRQ_IND_SRAM_FULL\t\tBIT(12)\n\n#define CQSPI_IRQ_MASK_RD\t\t(CQSPI_REG_IRQ_WATERMARK\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_IND_SRAM_FULL\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_IND_COMP)\n\n#define CQSPI_IRQ_MASK_WR\t\t(CQSPI_REG_IRQ_IND_COMP\t\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_WATERMARK\t| \\\n\t\t\t\t\t CQSPI_REG_IRQ_UNDERFLOW)\n\n#define CQSPI_IRQ_STATUS_MASK\t\t0x1FFFF\n\nstatic int cqspi_wait_for_bit(void __iomem *reg, const u32 mask, bool clear)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\n\tu32 val;\n\n\twhile (1) {\n\t\tval = readl(reg);\n\t\tif (clear)\n\t\t\tval = ~val;\n\t\tval &= mask;\n\n\t\tif (val == mask)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, end))\n\t\t\treturn -ETIMEDOUT;\n\t}\n}\n\nstatic bool cqspi_is_idle(struct cqspi_st *cqspi)\n{\n\tu32 reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\n\n\treturn reg & (1 << CQSPI_REG_CONFIG_IDLE_LSB);\n}\n\nstatic u32 cqspi_get_rd_sram_level(struct cqspi_st *cqspi)\n{\n\tu32 reg = readl(cqspi->iobase + CQSPI_REG_SDRAMLEVEL);\n\n\treg >>= CQSPI_REG_SDRAMLEVEL_RD_LSB;\n\treturn reg & CQSPI_REG_SDRAMLEVEL_RD_MASK;\n}\n\nstatic irqreturn_t cqspi_irq_handler(int this_irq, void *dev)\n{\n\tstruct cqspi_st *cqspi = dev;\n\tunsigned int irq_status;\n\n\t/* Read interrupt status */\n\tirq_status = readl(cqspi->iobase + CQSPI_REG_IRQSTATUS);\n\n\t/* Clear interrupt */\n\twritel(irq_status, cqspi->iobase + CQSPI_REG_IRQSTATUS);\n\n\tirq_status &= CQSPI_IRQ_MASK_RD | CQSPI_IRQ_MASK_WR;\n\n\tif (irq_status)\n\t\tcomplete(&cqspi->transfer_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int cqspi_calc_rdreg(struct spi_nor *nor, const u8 opcode)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tu32 rdreg = 0;\n\n\trdreg |= f_pdata->inst_width << CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB;\n\trdreg |= f_pdata->addr_width << CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB;\n\trdreg |= f_pdata->data_width << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB;\n\n\treturn rdreg;\n}\n\nstatic int cqspi_wait_idle(struct cqspi_st *cqspi)\n{\n\tconst unsigned int poll_idle_retry = 3;\n\tunsigned int count = 0;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\n\twhile (1) {\n\t\t/*\n\t\t * Read few times in succession to ensure the controller\n\t\t * is indeed idle, that is, the bit does not transition\n\t\t * low again.\n\t\t */\n\t\tif (cqspi_is_idle(cqspi))\n\t\t\tcount++;\n\t\telse\n\t\t\tcount = 0;\n\n\t\tif (count >= poll_idle_retry)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t/* Timeout, in busy mode. */\n\t\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\t\"QSPI is still busy after %dms timeout.\\n\",\n\t\t\t\tCQSPI_TIMEOUT_MS);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n}\n\nstatic int cqspi_exec_flash_cmd(struct cqspi_st *cqspi, unsigned int reg)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tint ret;\n\n\t/* Write the CMDCTRL without start execution. */\n\twritel(reg, reg_base + CQSPI_REG_CMDCTRL);\n\t/* Start execute */\n\treg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;\n\twritel(reg, reg_base + CQSPI_REG_CMDCTRL);\n\n\t/* Polling for completion. */\n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_CMDCTRL,\n\t\t\t\t CQSPI_REG_CMDCTRL_INPROGRESS_MASK, 1);\n\tif (ret) {\n\t\tdev_err(&cqspi->pdev->dev,\n\t\t\t\"Flash command execution timed out.\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Polling QSPI idle status. */\n\treturn cqspi_wait_idle(cqspi);\n}\n\nstatic int cqspi_command_read(struct spi_nor *nor,\n\t\t\t      const u8 *txbuf, const unsigned n_tx,\n\t\t\t      u8 *rxbuf, const unsigned n_rx)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int rdreg;\n\tunsigned int reg;\n\tunsigned int read_len;\n\tint status;\n\n\tif (!n_rx || n_rx > CQSPI_STIG_DATA_LEN_MAX || !rxbuf) {\n\t\tdev_err(nor->dev, \"Invalid input argument, len %d rxbuf 0x%p\\n\",\n\t\t\tn_rx, rxbuf);\n\t\treturn -EINVAL;\n\t}\n\n\treg = txbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\n\trdreg = cqspi_calc_rdreg(nor, txbuf[0]);\n\twritel(rdreg, reg_base + CQSPI_REG_RD_INSTR);\n\n\treg |= (0x1 << CQSPI_REG_CMDCTRL_RD_EN_LSB);\n\n\t/* 0 means 1 byte. */\n\treg |= (((n_rx - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)\n\t\t<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB);\n\tstatus = cqspi_exec_flash_cmd(cqspi, reg);\n\tif (status)\n\t\treturn status;\n\n\treg = readl(reg_base + CQSPI_REG_CMDREADDATALOWER);\n\n\t/* Put the read value into rx_buf */\n\tread_len = (n_rx > 4) ? 4 : n_rx;\n\tmemcpy(rxbuf, &reg, read_len);\n\trxbuf += read_len;\n\n\tif (n_rx > 4) {\n\t\treg = readl(reg_base + CQSPI_REG_CMDREADDATAUPPER);\n\n\t\tread_len = n_rx - read_len;\n\t\tmemcpy(rxbuf, &reg, read_len);\n\t}\n\n\treturn 0;\n}\n\nstatic int cqspi_command_write(struct spi_nor *nor, const u8 opcode,\n\t\t\t       const u8 *txbuf, const unsigned n_tx)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\tunsigned int data;\n\tint ret;\n\n\tif (n_tx > 4 || (n_tx && !txbuf)) {\n\t\tdev_err(nor->dev,\n\t\t\t\"Invalid input argument, cmdlen %d txbuf 0x%p\\n\",\n\t\t\tn_tx, txbuf);\n\t\treturn -EINVAL;\n\t}\n\n\treg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\tif (n_tx) {\n\t\treg |= (0x1 << CQSPI_REG_CMDCTRL_WR_EN_LSB);\n\t\treg |= ((n_tx - 1) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)\n\t\t\t<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;\n\t\tdata = 0;\n\t\tmemcpy(&data, txbuf, n_tx);\n\t\twritel(data, reg_base + CQSPI_REG_CMDWRITEDATALOWER);\n\t}\n\n\tret = cqspi_exec_flash_cmd(cqspi, reg);\n\treturn ret;\n}\n\nstatic int cqspi_command_write_addr(struct spi_nor *nor,\n\t\t\t\t    const u8 opcode, const unsigned int addr)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\n\treg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);\n\treg |= ((nor->addr_width - 1) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)\n\t\t<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;\n\n\twritel(addr, reg_base + CQSPI_REG_CMDADDRESS);\n\n\treturn cqspi_exec_flash_cmd(cqspi, reg);\n}\n\nstatic int cqspi_indirect_read_setup(struct spi_nor *nor,\n\t\t\t\t     const unsigned int from_addr)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int dummy_clk = 0;\n\tunsigned int reg;\n\n\twritel(from_addr, reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);\n\n\treg = nor->read_opcode << CQSPI_REG_RD_INSTR_OPCODE_LSB;\n\treg |= cqspi_calc_rdreg(nor, nor->read_opcode);\n\n\t/* Setup dummy clock cycles */\n\tdummy_clk = nor->read_dummy;\n\tif (dummy_clk > CQSPI_DUMMY_CLKS_MAX)\n\t\tdummy_clk = CQSPI_DUMMY_CLKS_MAX;\n\n\tif (dummy_clk / 8) {\n\t\treg |= (1 << CQSPI_REG_RD_INSTR_MODE_EN_LSB);\n\t\t/* Set mode bits high to ensure chip doesn't enter XIP */\n\t\twritel(0xFF, reg_base + CQSPI_REG_MODE_BIT);\n\n\t\t/* Need to subtract the mode byte (8 clocks). */\n\t\tif (f_pdata->inst_width != CQSPI_INST_TYPE_QUAD)\n\t\t\tdummy_clk -= 8;\n\n\t\tif (dummy_clk)\n\t\t\treg |= (dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK)\n\t\t\t       << CQSPI_REG_RD_INSTR_DUMMY_LSB;\n\t}\n\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\t/* Set address width */\n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->addr_width - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n\nstatic int cqspi_indirect_read_execute(struct spi_nor *nor,\n\t\t\t\t       u8 *rxbuf, const unsigned n_rx)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tvoid __iomem *ahb_base = cqspi->ahb_base;\n\tunsigned int remaining = n_rx;\n\tunsigned int bytes_to_read = 0;\n\tint ret = 0;\n\n\twritel(remaining, reg_base + CQSPI_REG_INDIRECTRDBYTES);\n\n\t/* Clear all interrupts. */\n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\twritel(CQSPI_IRQ_MASK_RD, reg_base + CQSPI_REG_IRQMASK);\n\n\treinit_completion(&cqspi->transfer_complete);\n\twritel(CQSPI_REG_INDIRECTRD_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\n\twhile (remaining > 0) {\n\t\tret = wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t\t  msecs_to_jiffies\n\t\t\t\t\t\t  (CQSPI_READ_TIMEOUT_MS));\n\n\t\tbytes_to_read = cqspi_get_rd_sram_level(cqspi);\n\n\t\tif (!ret && bytes_to_read == 0) {\n\t\t\tdev_err(nor->dev, \"Indirect read timeout, no bytes\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto failrd;\n\t\t}\n\n\t\twhile (bytes_to_read != 0) {\n\t\t\tbytes_to_read *= cqspi->fifo_width;\n\t\t\tbytes_to_read = bytes_to_read > remaining ?\n\t\t\t\t\tremaining : bytes_to_read;\n\t\t\treadsl(ahb_base, rxbuf, DIV_ROUND_UP(bytes_to_read, 4));\n\t\t\trxbuf += bytes_to_read;\n\t\t\tremaining -= bytes_to_read;\n\t\t\tbytes_to_read = cqspi_get_rd_sram_level(cqspi);\n\t\t}\n\n\t\tif (remaining > 0)\n\t\t\treinit_completion(&cqspi->transfer_complete);\n\t}\n\n\t/* Check indirect done status */\n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTRD,\n\t\t\t\t CQSPI_REG_INDIRECTRD_DONE_MASK, 0);\n\tif (ret) {\n\t\tdev_err(nor->dev,\n\t\t\t\"Indirect read completion error (%i)\\n\", ret);\n\t\tgoto failrd;\n\t}\n\n\t/* Disable interrupt */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Clear indirect completion status */\n\twritel(CQSPI_REG_INDIRECTRD_DONE_MASK, reg_base + CQSPI_REG_INDIRECTRD);\n\n\treturn 0;\n\nfailrd:\n\t/* Disable interrupt */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Cancel the indirect read */\n\twritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTRD);\n\treturn ret;\n}\n\nstatic int cqspi_indirect_write_setup(struct spi_nor *nor,\n\t\t\t\t      const unsigned int to_addr)\n{\n\tunsigned int reg;\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\n\t/* Set opcode. */\n\treg = nor->program_opcode << CQSPI_REG_WR_INSTR_OPCODE_LSB;\n\twritel(reg, reg_base + CQSPI_REG_WR_INSTR);\n\treg = cqspi_calc_rdreg(nor, nor->program_opcode);\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\twritel(to_addr, reg_base + CQSPI_REG_INDIRECTWRSTARTADDR);\n\n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->addr_width - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n\nstatic int cqspi_indirect_write_execute(struct spi_nor *nor,\n\t\t\t\t\tconst u8 *txbuf, const unsigned n_tx)\n{\n\tconst unsigned int page_size = nor->page_size;\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int remaining = n_tx;\n\tunsigned int write_bytes;\n\tint ret;\n\n\twritel(remaining, reg_base + CQSPI_REG_INDIRECTWRBYTES);\n\n\t/* Clear all interrupts. */\n\twritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\n\n\twritel(CQSPI_IRQ_MASK_WR, reg_base + CQSPI_REG_IRQMASK);\n\n\treinit_completion(&cqspi->transfer_complete);\n\twritel(CQSPI_REG_INDIRECTWR_START_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTWR);\n\n\twhile (remaining > 0) {\n\t\twrite_bytes = remaining > page_size ? page_size : remaining;\n\t\twritesl(cqspi->ahb_base, txbuf, DIV_ROUND_UP(write_bytes, 4));\n\n\t\tret = wait_for_completion_timeout(&cqspi->transfer_complete,\n\t\t\t\t\t\t  msecs_to_jiffies\n\t\t\t\t\t\t  (CQSPI_TIMEOUT_MS));\n\t\tif (!ret) {\n\t\t\tdev_err(nor->dev, \"Indirect write timeout\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto failwr;\n\t\t}\n\n\t\ttxbuf += write_bytes;\n\t\tremaining -= write_bytes;\n\n\t\tif (remaining > 0)\n\t\t\treinit_completion(&cqspi->transfer_complete);\n\t}\n\n\t/* Check indirect done status */\n\tret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTWR,\n\t\t\t\t CQSPI_REG_INDIRECTWR_DONE_MASK, 0);\n\tif (ret) {\n\t\tdev_err(nor->dev,\n\t\t\t\"Indirect write completion error (%i)\\n\", ret);\n\t\tgoto failwr;\n\t}\n\n\t/* Disable interrupt. */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Clear indirect completion status */\n\twritel(CQSPI_REG_INDIRECTWR_DONE_MASK, reg_base + CQSPI_REG_INDIRECTWR);\n\n\tcqspi_wait_idle(cqspi);\n\n\treturn 0;\n\nfailwr:\n\t/* Disable interrupt. */\n\twritel(0, reg_base + CQSPI_REG_IRQMASK);\n\n\t/* Cancel the indirect write */\n\twritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\n\t       reg_base + CQSPI_REG_INDIRECTWR);\n\treturn ret;\n}\n\nstatic void cqspi_chipselect(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int chip_select = f_pdata->cs;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\tif (cqspi->is_decoded_cs) {\n\t\treg |= CQSPI_REG_CONFIG_DECODE_MASK;\n\t} else {\n\t\treg &= ~CQSPI_REG_CONFIG_DECODE_MASK;\n\n\t\t/* Convert CS if without decoder.\n\t\t * CS0 to 4b'1110\n\t\t * CS1 to 4b'1101\n\t\t * CS2 to 4b'1011\n\t\t * CS3 to 4b'0111\n\t\t */\n\t\tchip_select = 0xF & ~(1 << chip_select);\n\t}\n\n\treg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK\n\t\t << CQSPI_REG_CONFIG_CHIPSELECT_LSB);\n\treg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)\n\t    << CQSPI_REG_CONFIG_CHIPSELECT_LSB;\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_configure_cs_and_sizes(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *iobase = cqspi->iobase;\n\tunsigned int reg;\n\n\t/* configure page size and block size. */\n\treg = readl(iobase + CQSPI_REG_SIZE);\n\treg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);\n\treg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->page_size << CQSPI_REG_SIZE_PAGE_LSB);\n\treg |= (ilog2(nor->mtd.erasesize) << CQSPI_REG_SIZE_BLOCK_LSB);\n\treg |= (nor->addr_width - 1);\n\twritel(reg, iobase + CQSPI_REG_SIZE);\n\n\t/* configure the chip select */\n\tcqspi_chipselect(nor);\n\n\t/* Store the new configuration of the controller */\n\tcqspi->current_page_size = nor->page_size;\n\tcqspi->current_erase_size = nor->mtd.erasesize;\n\tcqspi->current_addr_width = nor->addr_width;\n}\n\nstatic unsigned int calculate_ticks_for_ns(const unsigned int ref_clk_hz,\n\t\t\t\t\t   const unsigned int ns_val)\n{\n\tunsigned int ticks;\n\n\tticks = ref_clk_hz / 1000;\t/* kHz */\n\tticks = DIV_ROUND_UP(ticks * ns_val, 1000000);\n\n\treturn ticks;\n}\n\nstatic void cqspi_delay(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *iobase = cqspi->iobase;\n\tconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\n\tunsigned int tshsl, tchsh, tslch, tsd2d;\n\tunsigned int reg;\n\tunsigned int tsclk;\n\n\t/* calculate the number of ref ticks for one sclk tick */\n\ttsclk = DIV_ROUND_UP(ref_clk_hz, cqspi->sclk);\n\n\ttshsl = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tshsl_ns);\n\t/* this particular value must be at least one sclk */\n\tif (tshsl < tsclk)\n\t\ttshsl = tsclk;\n\n\ttchsh = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tchsh_ns);\n\ttslch = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tslch_ns);\n\ttsd2d = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tsd2d_ns);\n\n\treg = (tshsl & CQSPI_REG_DELAY_TSHSL_MASK)\n\t       << CQSPI_REG_DELAY_TSHSL_LSB;\n\treg |= (tchsh & CQSPI_REG_DELAY_TCHSH_MASK)\n\t\t<< CQSPI_REG_DELAY_TCHSH_LSB;\n\treg |= (tslch & CQSPI_REG_DELAY_TSLCH_MASK)\n\t\t<< CQSPI_REG_DELAY_TSLCH_LSB;\n\treg |= (tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)\n\t\t<< CQSPI_REG_DELAY_TSD2D_LSB;\n\twritel(reg, iobase + CQSPI_REG_DELAY);\n}\n\nstatic void cqspi_config_baudrate_div(struct cqspi_st *cqspi)\n{\n\tconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tu32 reg, div;\n\n\t/* Recalculate the baudrate divisor based on QSPI specification. */\n\tdiv = DIV_ROUND_UP(ref_clk_hz, 2 * cqspi->sclk) - 1;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\treg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);\n\treg |= (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_readdata_capture(struct cqspi_st *cqspi,\n\t\t\t\t   const unsigned int bypass,\n\t\t\t\t   const unsigned int delay)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_READCAPTURE);\n\n\tif (bypass)\n\t\treg |= (1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\n\telse\n\t\treg &= ~(1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\n\n\treg &= ~(CQSPI_REG_READCAPTURE_DELAY_MASK\n\t\t << CQSPI_REG_READCAPTURE_DELAY_LSB);\n\n\treg |= (delay & CQSPI_REG_READCAPTURE_DELAY_MASK)\n\t\t<< CQSPI_REG_READCAPTURE_DELAY_LSB;\n\n\twritel(reg, reg_base + CQSPI_REG_READCAPTURE);\n}\n\nstatic void cqspi_controller_enable(struct cqspi_st *cqspi, bool enable)\n{\n\tvoid __iomem *reg_base = cqspi->iobase;\n\tunsigned int reg;\n\n\treg = readl(reg_base + CQSPI_REG_CONFIG);\n\n\tif (enable)\n\t\treg |= CQSPI_REG_CONFIG_ENABLE_MASK;\n\telse\n\t\treg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;\n\n\twritel(reg, reg_base + CQSPI_REG_CONFIG);\n}\n\nstatic void cqspi_configure(struct spi_nor *nor)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tconst unsigned int sclk = f_pdata->clk_rate;\n\tint switch_cs = (cqspi->current_cs != f_pdata->cs);\n\tint switch_ck = (cqspi->sclk != sclk);\n\n\tif ((cqspi->current_page_size != nor->page_size) ||\n\t    (cqspi->current_erase_size != nor->mtd.erasesize) ||\n\t    (cqspi->current_addr_width != nor->addr_width))\n\t\tswitch_cs = 1;\n\n\tif (switch_cs || switch_ck)\n\t\tcqspi_controller_enable(cqspi, 0);\n\n\t/* Switch chip select. */\n\tif (switch_cs) {\n\t\tcqspi->current_cs = f_pdata->cs;\n\t\tcqspi_configure_cs_and_sizes(nor);\n\t}\n\n\t/* Setup baudrate divisor and delays */\n\tif (switch_ck) {\n\t\tcqspi->sclk = sclk;\n\t\tcqspi_config_baudrate_div(cqspi);\n\t\tcqspi_delay(nor);\n\t\tcqspi_readdata_capture(cqspi, 1, f_pdata->read_delay);\n\t}\n\n\tif (switch_cs || switch_ck)\n\t\tcqspi_controller_enable(cqspi, 1);\n}\n\nstatic int cqspi_set_protocol(struct spi_nor *nor, const int read)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\n\tf_pdata->inst_width = CQSPI_INST_TYPE_SINGLE;\n\tf_pdata->addr_width = CQSPI_INST_TYPE_SINGLE;\n\tf_pdata->data_width = CQSPI_INST_TYPE_SINGLE;\n\n\tif (read) {\n\t\tswitch (nor->flash_read) {\n\t\tcase SPI_NOR_NORMAL:\n\t\tcase SPI_NOR_FAST:\n\t\t\tf_pdata->data_width = CQSPI_INST_TYPE_SINGLE;\n\t\t\tbreak;\n\t\tcase SPI_NOR_DUAL:\n\t\t\tf_pdata->data_width = CQSPI_INST_TYPE_DUAL;\n\t\t\tbreak;\n\t\tcase SPI_NOR_QUAD:\n\t\t\tf_pdata->data_width = CQSPI_INST_TYPE_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcqspi_configure(nor);\n\n\treturn 0;\n}\n\nstatic ssize_t cqspi_write(struct spi_nor *nor, loff_t to,\n\t\t\t   size_t len, const u_char *buf)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_write_setup(nor, to);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_write_execute(nor, buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (ret < 0) ? ret : len;\n}\n\nstatic ssize_t cqspi_read(struct spi_nor *nor, loff_t from,\n\t\t\t  size_t len, u_char *buf)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_read_setup(nor, from);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqspi_indirect_read_execute(nor, buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (ret < 0) ? ret : len;\n}\n\nstatic int cqspi_erase(struct spi_nor *nor, loff_t offs)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Send write enable, then erase commands. */\n\tret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Set up command buffer. */\n\tret = cqspi_command_write_addr(nor, nor->erase_opcode, offs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cqspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\n\tmutex_lock(&cqspi->bus_mutex);\n\n\treturn 0;\n}\n\nstatic void cqspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\n\tmutex_unlock(&cqspi->bus_mutex);\n}\n\nstatic int cqspi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (!ret)\n\t\tret = cqspi_command_read(nor, &opcode, 1, buf, len);\n\n\treturn ret;\n}\n\nstatic int cqspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (!ret)\n\t\tret = cqspi_command_write(nor, opcode, buf, len);\n\n\treturn ret;\n}\n\nstatic int cqspi_of_get_flash_pdata(struct platform_device *pdev,\n\t\t\t\t    struct cqspi_flash_pdata *f_pdata,\n\t\t\t\t    struct device_node *np)\n{\n\tif (of_property_read_u32(np, \"cdns,read-delay\", &f_pdata->read_delay)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine read-delay\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tshsl-ns\", &f_pdata->tshsl_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tshsl-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tsd2d-ns\", &f_pdata->tsd2d_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tsd2d-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tchsh-ns\", &f_pdata->tchsh_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tchsh-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,tslch-ns\", &f_pdata->tslch_ns)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine tslch-ns\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"spi-max-frequency\", &f_pdata->clk_rate)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine spi-max-frequency\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cqspi_of_get_pdata(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\n\n\tcqspi->is_decoded_cs = of_property_read_bool(np, \"cdns,is-decoded-cs\");\n\n\tif (of_property_read_u32(np, \"cdns,fifo-depth\", &cqspi->fifo_depth)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine fifo-depth\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,fifo-width\", &cqspi->fifo_width)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine fifo-width\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (of_property_read_u32(np, \"cdns,trigger-address\",\n\t\t\t\t &cqspi->trigger_address)) {\n\t\tdev_err(&pdev->dev, \"couldn't determine trigger-address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void cqspi_controller_init(struct cqspi_st *cqspi)\n{\n\tcqspi_controller_enable(cqspi, 0);\n\n\t/* Configure the remap address register, no remap */\n\twritel(0, cqspi->iobase + CQSPI_REG_REMAP);\n\n\t/* Disable all interrupts. */\n\twritel(0, cqspi->iobase + CQSPI_REG_IRQMASK);\n\n\t/* Configure the SRAM split to 1:1 . */\n\twritel(cqspi->fifo_depth / 2, cqspi->iobase + CQSPI_REG_SRAMPARTITION);\n\n\t/* Load indirect trigger address. */\n\twritel(cqspi->trigger_address,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTTRIGGER);\n\n\t/* Program read watermark -- 1/2 of the FIFO. */\n\twritel(cqspi->fifo_depth * cqspi->fifo_width / 2,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTRDWATERMARK);\n\t/* Program write watermark -- 1/8 of the FIFO. */\n\twritel(cqspi->fifo_depth * cqspi->fifo_width / 8,\n\t       cqspi->iobase + CQSPI_REG_INDIRECTWRWATERMARK);\n\n\tcqspi_controller_enable(cqspi, 1);\n}\n\nstatic int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\n\t/* Get flash device data */\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cs >= CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\n\t\tmtd->priv = nor;\n\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tf_pdata->registered = true;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}\n\nstatic int cqspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_st *cqspi;\n\tstruct resource *res;\n\tstruct resource *res_ahb;\n\tint ret;\n\tint irq;\n\n\tcqspi = devm_kzalloc(dev, sizeof(*cqspi), GFP_KERNEL);\n\tif (!cqspi)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&cqspi->bus_mutex);\n\tcqspi->pdev = pdev;\n\tplatform_set_drvdata(pdev, cqspi);\n\n\t/* Obtain configuration from OF. */\n\tret = cqspi_of_get_pdata(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot get mandatory OF data.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Obtain QSPI clock. */\n\tcqspi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cqspi->clk)) {\n\t\tdev_err(dev, \"Cannot claim QSPI clock.\\n\");\n\t\treturn PTR_ERR(cqspi->clk);\n\t}\n\n\t/* Obtain and remap controller address. */\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tcqspi->iobase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(cqspi->iobase)) {\n\t\tdev_err(dev, \"Cannot remap controller address.\\n\");\n\t\treturn PTR_ERR(cqspi->iobase);\n\t}\n\n\t/* Obtain and remap AHB address. */\n\tres_ahb = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tcqspi->ahb_base = devm_ioremap_resource(dev, res_ahb);\n\tif (IS_ERR(cqspi->ahb_base)) {\n\t\tdev_err(dev, \"Cannot remap AHB address.\\n\");\n\t\treturn PTR_ERR(cqspi->ahb_base);\n\t}\n\n\tinit_completion(&cqspi->transfer_complete);\n\n\t/* Obtain IRQ line. */\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(dev, \"Cannot obtain IRQ.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = clk_prepare_enable(cqspi->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable QSPI clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tcqspi->master_ref_clk_hz = clk_get_rate(cqspi->clk);\n\n\tret = devm_request_irq(dev, irq, cqspi_irq_handler, 0,\n\t\t\t       pdev->name, cqspi);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot request IRQ.\\n\");\n\t\tgoto probe_irq_failed;\n\t}\n\n\tcqspi_wait_idle(cqspi);\n\tcqspi_controller_init(cqspi);\n\tcqspi->current_cs = -1;\n\tcqspi->sclk = 0;\n\n\tret = cqspi_setup_flash(cqspi, np);\n\tif (ret) {\n\t\tdev_err(dev, \"Cadence QSPI NOR probe failed %d\\n\", ret);\n\t\tgoto probe_setup_failed;\n\t}\n\n\treturn ret;\nprobe_irq_failed:\n\tcqspi_controller_enable(cqspi, 0);\nprobe_setup_failed:\n\tclk_disable_unprepare(cqspi->clk);\n\treturn ret;\n}\n\nstatic int cqspi_remove(struct platform_device *pdev)\n{\n\tstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\n\tcqspi_controller_enable(cqspi, 0);\n\n\tclk_disable_unprepare(cqspi->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cqspi_suspend(struct device *dev)\n{\n\tstruct cqspi_st *cqspi = dev_get_drvdata(dev);\n\n\tcqspi_controller_enable(cqspi, 0);\n\treturn 0;\n}\n\nstatic int cqspi_resume(struct device *dev)\n{\n\tstruct cqspi_st *cqspi = dev_get_drvdata(dev);\n\n\tcqspi_controller_enable(cqspi, 1);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cqspi__dev_pm_ops = {\n\t.suspend = cqspi_suspend,\n\t.resume = cqspi_resume,\n};\n\n#define CQSPI_DEV_PM_OPS\t(&cqspi__dev_pm_ops)\n#else\n#define CQSPI_DEV_PM_OPS\tNULL\n#endif\n\nstatic struct of_device_id const cqspi_dt_ids[] = {\n\t{.compatible = \"cdns,qspi-nor\",},\n\t{ /* end of table */ }\n};\n\nMODULE_DEVICE_TABLE(of, cqspi_dt_ids);\n\nstatic struct platform_driver cqspi_platform_driver = {\n\t.probe = cqspi_probe,\n\t.remove = cqspi_remove,\n\t.driver = {\n\t\t.name = CQSPI_NAME,\n\t\t.pm = CQSPI_DEV_PM_OPS,\n\t\t.of_match_table = cqspi_dt_ids,\n\t},\n};\n\nmodule_platform_driver(cqspi_platform_driver);\n\nMODULE_DESCRIPTION(\"Cadence QSPI Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" CQSPI_NAME);\nMODULE_AUTHOR(\"Ley Foon Tan <lftan@altera.com>\");\nMODULE_AUTHOR(\"Graham Moore <grmoore@opensource.altera.com>\");\n"], "filenames": ["drivers/mtd/spi-nor/cadence-quadspi.c"], "buggy_code_start_loc": [1085], "buggy_code_end_loc": [1086], "fixing_code_start_loc": [1085], "fixing_code_end_loc": [1086], "type": "CWE-119", "message": "In the Linux kernel before 4.9.6, there is an off by one in the drivers/mtd/spi-nor/cadence-quadspi.c cqspi_setup_flash() function. There are CQSPI_MAX_CHIPSELECT elements in the ->f_pdata array so the \">\" should be \">=\" instead.", "other": {"cve": {"id": "CVE-2016-10764", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T22:15:11.480", "lastModified": "2023-01-19T16:08:03.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.9.6, there is an off by one in the drivers/mtd/spi-nor/cadence-quadspi.c cqspi_setup_flash() function. There are CQSPI_MAX_CHIPSELECT elements in the ->f_pdata array so the \">\" should be \">=\" instead."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 4.9.6, se presenta una desactivaci\u00f3n de una en la funci\u00f3n en el archivo drivers/mtd/spi-nor/cadence-quadspi.c en la funci\u00f3n cqspi_setup_flash(). Existen elementos CQSPI_MAX_CHIPSELECT en la matriz -)f_pdata por lo que mayor que \")\" deber\u00eda ser mayor o igual que \")=\" en su lugar."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.8", "versionEndExcluding": "4.9.6", "matchCriteriaId": "A731E711-265F-4522-A17C-84C40D5F04D8"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=193e87143c290ec16838f5368adc0e0bc94eb931", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/193e87143c290ec16838f5368adc0e0bc94eb931", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K24444495", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K24444495?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/193e87143c290ec16838f5368adc0e0bc94eb931"}}