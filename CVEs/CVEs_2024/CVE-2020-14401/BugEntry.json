{"buggy_code": ["/*\n * scale.c - deal with server-side scaling.\n */\n\n/*\n *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin\n *  Copyright (C) 2002 RealVNC Ltd.\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#endif\n#include <string.h>\n#include <rfb/rfb.h>\n#include <rfb/rfbregion.h>\n#include \"private.h\"\n\n#ifdef LIBVNCSERVER_HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n\n#ifdef DEBUGPROTO\n#undef DEBUGPROTO\n#define DEBUGPROTO(x) x\n#else\n#define DEBUGPROTO(x)\n#endif\n\n/****************************/\n#define CEIL(x)  ( (double) ((int) (x)) == (x) ? \\\n        (double) ((int) (x)) : (double) ((int) (x) + 1) )\n#define FLOOR(x) ( (double) ((int) (x)) )\n\n#ifdef WIN32\n#define InlineX __inline\n#else\n# ifndef __STRICT_ANSI__\n#  define InlineX inline\n# else\n#  define InlineX\n# endif\n#endif\n\n\nstatic InlineX int pad4(int value)\n{\n    int remainder = value & 3;\n    if (!remainder) return value;\n    return value + 4 - remainder;\n}\n\nint ScaleX(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int x)\n{\n    if ((from==to) || (from==NULL) || (to==NULL)) return x;\n    return ((int)(((double) x / (double)from->width) * (double)to->width ));\n}\n\nint ScaleY(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int y)\n{\n    if ((from==to) || (from==NULL) || (to==NULL)) return y;\n    return ((int)(((double) y / (double)from->height) * (double)to->height ));\n}\n\n/* So, all of the encodings point to the ->screen->frameBuffer,\n * We need to change this!\n */\nvoid rfbScaledCorrection(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int *x, int *y, int *w, int *h, const char *function)\n{\n    double x1,y1,w1,h1, x2, y2, w2, h2;\n    double scaleW = ((double) to->width) / ((double) from->width);\n    double scaleH = ((double) to->height) / ((double) from->height);\n\n\n    /*\n     * rfbLog(\"rfbScaledCorrection(%p -> %p, %dx%d->%dx%d (%dXx%dY-%dWx%dH)\\n\",\n     * from, to, from->width, from->height, to->width, to->height, *x, *y, *w, *h);\n     */\n\n    /* If it's the original framebuffer... */\n    if (from==to) return;\n\n    x1 = ((double) *x) * scaleW;\n    y1 = ((double) *y) * scaleH;\n    w1 = ((double) *w) * scaleW;\n    h1 = ((double) *h) * scaleH;\n\n\n    /*cast from double to int is same as \"*x = floor(x1);\" */\n    x2 = FLOOR(x1);\n    y2 = FLOOR(y1);\n\n    /* include into W and H the jitter of scaling X and Y */\n    w2 = CEIL(w1 + ( x1 - x2 ));\n    h2 = CEIL(h1 + ( y1 - y2 ));\n\n    /*\n     * rfbLog(\"%s (%dXx%dY-%dWx%dH  ->  %fXx%fY-%fWx%fH) {%dWx%dH -> %dWx%dH}\\n\",\n     *    function, *x, *y, *w, *h, x2, y2, w2, h2,\n     *    from->width, from->height, to->width, to->height);\n     */\n\n    /* simulate ceil() without math library */\n    *x = (int)x2;\n    *y = (int)y2;\n    *w = (int)w2;\n    *h = (int)h2;\n\n    /* Small changes for a thumbnail may be scaled to zero */\n    if (*w==0) (*w)++;\n    if (*h==0) (*h)++;\n    /* scaling from small to big may overstep the size a bit */\n    if (*x+*w > to->width)  *w=to->width - *x;\n    if (*y+*h > to->height) *h=to->height - *y;\n}\n\nvoid rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}\n\nvoid rfbScaledScreenUpdate(rfbScreenInfoPtr screen, int x1, int y1, int x2, int y2)\n{\n    /* ok, now the task is to update each and every scaled version of the framebuffer\n     * and we only have to do this for this specific changed rectangle!\n     */\n    rfbScreenInfoPtr ptr;\n    int count=0;\n\n    /* We don't point to cl->screen as it is the original */\n    for (ptr=screen->scaledScreenNext;ptr!=NULL;ptr=ptr->scaledScreenNext)\n    {\n        /* Only update if it has active clients... */\n        if (ptr->scaledScreenRefCount>0)\n        {\n          rfbScaledScreenUpdateRect(screen, ptr, x1, y1, x2-x1, y2-y1);\n          count++;\n        }\n    }\n}\n\n/* Create a new scaled version of the framebuffer */\nrfbScreenInfoPtr rfbScaledScreenAllocate(rfbClientPtr cl, int width, int height)\n{\n    rfbScreenInfoPtr ptr;\n    ptr = malloc(sizeof(rfbScreenInfo));\n    if (ptr!=NULL)\n    {\n        int allocSize;\n\n        /* copy *everything* (we don't use most of it, but just in case) */\n        memcpy(ptr, cl->screen, sizeof(rfbScreenInfo));\n\n        /* SECURITY: make sure that no integer overflow will occur afterwards.\n         * Note: this is defensive coding, as the check should have already been\n         * performed during initial, non-scaled screen setup.\n         */\n        allocSize = pad4(width * (ptr->bitsPerPixel/8)); /* per protocol, width<2**16 and bpp<256 */\n        if (height == 0 || allocSize >= SIZE_MAX / height)\n        {\n          free(ptr);\n          return NULL; /* malloc() will allocate an incorrect buffer size - early abort */\n        }\n\n        /* Resume copy everything */\n        ptr->width = width;\n        ptr->height = height;\n        ptr->paddedWidthInBytes = (ptr->bitsPerPixel/8)*ptr->width;\n\n        /* Need to by multiples of 4 for Sparc systems */\n        ptr->paddedWidthInBytes = pad4(ptr->paddedWidthInBytes);\n\n        /* Reset the reference count to 0! */\n        ptr->scaledScreenRefCount = 0;\n\n        ptr->sizeInBytes = ptr->paddedWidthInBytes * ptr->height;\n        ptr->serverFormat = cl->screen->serverFormat;\n\n        ptr->frameBuffer = malloc(ptr->sizeInBytes);\n        if (ptr->frameBuffer!=NULL)\n        {\n            /* Reset to a known condition: scale the entire framebuffer */\n            rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);\n            /* Now, insert into the chain */\n            LOCK(cl->updateMutex);\n            ptr->scaledScreenNext = cl->screen->scaledScreenNext;\n            cl->screen->scaledScreenNext = ptr;\n            UNLOCK(cl->updateMutex);\n        }\n        else\n        {\n            /* Failed to malloc the new frameBuffer, cleanup */\n            free(ptr);\n            ptr=NULL;\n        }\n    }\n    return ptr;\n}\n\n/* Find an active scaled version of the framebuffer\n * TODO: implement a refcount per scaled screen to prevent\n * unreferenced scaled screens from hanging around\n */\nrfbScreenInfoPtr rfbScalingFind(rfbClientPtr cl, int width, int height)\n{\n    rfbScreenInfoPtr ptr;\n    /* include the original in the search (ie: fine 1:1 scaled version of the frameBuffer) */\n    for (ptr=cl->screen; ptr!=NULL; ptr=ptr->scaledScreenNext)\n    {\n        if ((ptr->width==width) && (ptr->height==height))\n            return ptr;\n    }\n    return NULL;\n}\n\n/* Future needs \"scale to 320x240, as that's the client's screen size */\nvoid rfbScalingSetup(rfbClientPtr cl, int width, int height)\n{\n    rfbScreenInfoPtr ptr;\n\n    ptr = rfbScalingFind(cl,width,height);\n    if (ptr==NULL)\n        ptr = rfbScaledScreenAllocate(cl,width,height);\n    /* Now, there is a new screen available (if ptr is not NULL) */\n    if (ptr!=NULL)\n    {\n        /* Update it! */\n        if (ptr->scaledScreenRefCount<1)\n            rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);\n        /*\n         * rfbLog(\"Taking one from %dx%d-%d and adding it to %dx%d-%d\\n\",\n         *    cl->scaledScreen->width, cl->scaledScreen->height,\n         *    cl->scaledScreen->scaledScreenRefCount,\n         *    ptr->width, ptr->height, ptr->scaledScreenRefCount);\n         */\n\n        LOCK(cl->updateMutex);\n        cl->scaledScreen->scaledScreenRefCount--;\n        ptr->scaledScreenRefCount++;\n        cl->scaledScreen=ptr;\n        cl->newFBSizePending = TRUE;\n        UNLOCK(cl->updateMutex);\n\n        rfbLog(\"Scaling to %dx%d (refcount=%d)\\n\",width,height,ptr->scaledScreenRefCount);\n    }\n    else\n        rfbLog(\"Scaling to %dx%d failed, leaving things alone\\n\",width,height);\n}\n\nint rfbSendNewScaleSize(rfbClientPtr cl)\n{\n    /* if the client supports newFBsize Encoding, use it */\n    if (cl->useNewFBSize && cl->newFBSizePending)\n\treturn FALSE;\n\n    LOCK(cl->updateMutex);\n    cl->newFBSizePending = FALSE;\n    UNLOCK(cl->updateMutex);\n\n    if (cl->PalmVNC==TRUE)\n    {\n        rfbPalmVNCReSizeFrameBufferMsg pmsg;\n        pmsg.type = rfbPalmVNCReSizeFrameBuffer;\n        pmsg.pad1 = 0;\n        pmsg.desktop_w = Swap16IfLE(cl->screen->width);\n        pmsg.desktop_h = Swap16IfLE(cl->screen->height);\n        pmsg.buffer_w  = Swap16IfLE(cl->scaledScreen->width);\n        pmsg.buffer_h  = Swap16IfLE(cl->scaledScreen->height);\n        pmsg.pad2 = 0;\n\n        rfbLog(\"Sending a response to a PalmVNC style frameuffer resize event (%dx%d)\\n\", cl->scaledScreen->width, cl->scaledScreen->height);\n        if (rfbWriteExact(cl, (char *)&pmsg, sz_rfbPalmVNCReSizeFrameBufferMsg) < 0) {\n            rfbLogPerror(\"rfbNewClient: write\");\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n    else\n    {\n        rfbResizeFrameBufferMsg        rmsg;\n        rmsg.type = rfbResizeFrameBuffer;\n        rmsg.pad1=0;\n        rmsg.framebufferWidth  = Swap16IfLE(cl->scaledScreen->width);\n        rmsg.framebufferHeigth = Swap16IfLE(cl->scaledScreen->height);\n        rfbLog(\"Sending a response to a UltraVNC style frameuffer resize event (%dx%d)\\n\", cl->scaledScreen->width, cl->scaledScreen->height);\n        if (rfbWriteExact(cl, (char *)&rmsg, sz_rfbResizeFrameBufferMsg) < 0) {\n            rfbLogPerror(\"rfbNewClient: write\");\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}\n/****************************/\n"], "fixing_code": ["/*\n * scale.c - deal with server-side scaling.\n */\n\n/*\n *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin\n *  Copyright (C) 2002 RealVNC Ltd.\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#endif\n#include <string.h>\n#include <rfb/rfb.h>\n#include <rfb/rfbregion.h>\n#include \"private.h\"\n\n#ifdef LIBVNCSERVER_HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n\n#ifdef DEBUGPROTO\n#undef DEBUGPROTO\n#define DEBUGPROTO(x) x\n#else\n#define DEBUGPROTO(x)\n#endif\n\n/****************************/\n#define CEIL(x)  ( (double) ((int) (x)) == (x) ? \\\n        (double) ((int) (x)) : (double) ((int) (x) + 1) )\n#define FLOOR(x) ( (double) ((int) (x)) )\n\n#ifdef WIN32\n#define InlineX __inline\n#else\n# ifndef __STRICT_ANSI__\n#  define InlineX inline\n# else\n#  define InlineX\n# endif\n#endif\n\n\nstatic InlineX int pad4(int value)\n{\n    int remainder = value & 3;\n    if (!remainder) return value;\n    return value + 4 - remainder;\n}\n\nint ScaleX(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int x)\n{\n    if ((from==to) || (from==NULL) || (to==NULL)) return x;\n    return ((int)(((double) x / (double)from->width) * (double)to->width ));\n}\n\nint ScaleY(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int y)\n{\n    if ((from==to) || (from==NULL) || (to==NULL)) return y;\n    return ((int)(((double) y / (double)from->height) * (double)to->height ));\n}\n\n/* So, all of the encodings point to the ->screen->frameBuffer,\n * We need to change this!\n */\nvoid rfbScaledCorrection(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int *x, int *y, int *w, int *h, const char *function)\n{\n    double x1,y1,w1,h1, x2, y2, w2, h2;\n    double scaleW = ((double) to->width) / ((double) from->width);\n    double scaleH = ((double) to->height) / ((double) from->height);\n\n\n    /*\n     * rfbLog(\"rfbScaledCorrection(%p -> %p, %dx%d->%dx%d (%dXx%dY-%dWx%dH)\\n\",\n     * from, to, from->width, from->height, to->width, to->height, *x, *y, *w, *h);\n     */\n\n    /* If it's the original framebuffer... */\n    if (from==to) return;\n\n    x1 = ((double) *x) * scaleW;\n    y1 = ((double) *y) * scaleH;\n    w1 = ((double) *w) * scaleW;\n    h1 = ((double) *h) * scaleH;\n\n\n    /*cast from double to int is same as \"*x = floor(x1);\" */\n    x2 = FLOOR(x1);\n    y2 = FLOOR(y1);\n\n    /* include into W and H the jitter of scaling X and Y */\n    w2 = CEIL(w1 + ( x1 - x2 ));\n    h2 = CEIL(h1 + ( y1 - y2 ));\n\n    /*\n     * rfbLog(\"%s (%dXx%dY-%dWx%dH  ->  %fXx%fY-%fWx%fH) {%dWx%dH -> %dWx%dH}\\n\",\n     *    function, *x, *y, *w, *h, x2, y2, w2, h2,\n     *    from->width, from->height, to->width, to->height);\n     */\n\n    /* simulate ceil() without math library */\n    *x = (int)x2;\n    *y = (int)y2;\n    *w = (int)w2;\n    *h = (int)h2;\n\n    /* Small changes for a thumbnail may be scaled to zero */\n    if (*w==0) (*w)++;\n    if (*h==0) (*h)++;\n    /* scaling from small to big may overstep the size a bit */\n    if (*x+*w > to->width)  *w=to->width - *x;\n    if (*y+*h > to->height) *h=to->height - *y;\n}\n\nvoid rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}\n\nvoid rfbScaledScreenUpdate(rfbScreenInfoPtr screen, int x1, int y1, int x2, int y2)\n{\n    /* ok, now the task is to update each and every scaled version of the framebuffer\n     * and we only have to do this for this specific changed rectangle!\n     */\n    rfbScreenInfoPtr ptr;\n    int count=0;\n\n    /* We don't point to cl->screen as it is the original */\n    for (ptr=screen->scaledScreenNext;ptr!=NULL;ptr=ptr->scaledScreenNext)\n    {\n        /* Only update if it has active clients... */\n        if (ptr->scaledScreenRefCount>0)\n        {\n          rfbScaledScreenUpdateRect(screen, ptr, x1, y1, x2-x1, y2-y1);\n          count++;\n        }\n    }\n}\n\n/* Create a new scaled version of the framebuffer */\nrfbScreenInfoPtr rfbScaledScreenAllocate(rfbClientPtr cl, int width, int height)\n{\n    rfbScreenInfoPtr ptr;\n    ptr = malloc(sizeof(rfbScreenInfo));\n    if (ptr!=NULL)\n    {\n        int allocSize;\n\n        /* copy *everything* (we don't use most of it, but just in case) */\n        memcpy(ptr, cl->screen, sizeof(rfbScreenInfo));\n\n        /* SECURITY: make sure that no integer overflow will occur afterwards.\n         * Note: this is defensive coding, as the check should have already been\n         * performed during initial, non-scaled screen setup.\n         */\n        allocSize = pad4(width * (ptr->bitsPerPixel/8)); /* per protocol, width<2**16 and bpp<256 */\n        if (height == 0 || allocSize >= SIZE_MAX / height)\n        {\n          free(ptr);\n          return NULL; /* malloc() will allocate an incorrect buffer size - early abort */\n        }\n\n        /* Resume copy everything */\n        ptr->width = width;\n        ptr->height = height;\n        ptr->paddedWidthInBytes = (ptr->bitsPerPixel/8)*ptr->width;\n\n        /* Need to by multiples of 4 for Sparc systems */\n        ptr->paddedWidthInBytes = pad4(ptr->paddedWidthInBytes);\n\n        /* Reset the reference count to 0! */\n        ptr->scaledScreenRefCount = 0;\n\n        ptr->sizeInBytes = ptr->paddedWidthInBytes * ptr->height;\n        ptr->serverFormat = cl->screen->serverFormat;\n\n        ptr->frameBuffer = malloc(ptr->sizeInBytes);\n        if (ptr->frameBuffer!=NULL)\n        {\n            /* Reset to a known condition: scale the entire framebuffer */\n            rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);\n            /* Now, insert into the chain */\n            LOCK(cl->updateMutex);\n            ptr->scaledScreenNext = cl->screen->scaledScreenNext;\n            cl->screen->scaledScreenNext = ptr;\n            UNLOCK(cl->updateMutex);\n        }\n        else\n        {\n            /* Failed to malloc the new frameBuffer, cleanup */\n            free(ptr);\n            ptr=NULL;\n        }\n    }\n    return ptr;\n}\n\n/* Find an active scaled version of the framebuffer\n * TODO: implement a refcount per scaled screen to prevent\n * unreferenced scaled screens from hanging around\n */\nrfbScreenInfoPtr rfbScalingFind(rfbClientPtr cl, int width, int height)\n{\n    rfbScreenInfoPtr ptr;\n    /* include the original in the search (ie: fine 1:1 scaled version of the frameBuffer) */\n    for (ptr=cl->screen; ptr!=NULL; ptr=ptr->scaledScreenNext)\n    {\n        if ((ptr->width==width) && (ptr->height==height))\n            return ptr;\n    }\n    return NULL;\n}\n\n/* Future needs \"scale to 320x240, as that's the client's screen size */\nvoid rfbScalingSetup(rfbClientPtr cl, int width, int height)\n{\n    rfbScreenInfoPtr ptr;\n\n    ptr = rfbScalingFind(cl,width,height);\n    if (ptr==NULL)\n        ptr = rfbScaledScreenAllocate(cl,width,height);\n    /* Now, there is a new screen available (if ptr is not NULL) */\n    if (ptr!=NULL)\n    {\n        /* Update it! */\n        if (ptr->scaledScreenRefCount<1)\n            rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);\n        /*\n         * rfbLog(\"Taking one from %dx%d-%d and adding it to %dx%d-%d\\n\",\n         *    cl->scaledScreen->width, cl->scaledScreen->height,\n         *    cl->scaledScreen->scaledScreenRefCount,\n         *    ptr->width, ptr->height, ptr->scaledScreenRefCount);\n         */\n\n        LOCK(cl->updateMutex);\n        cl->scaledScreen->scaledScreenRefCount--;\n        ptr->scaledScreenRefCount++;\n        cl->scaledScreen=ptr;\n        cl->newFBSizePending = TRUE;\n        UNLOCK(cl->updateMutex);\n\n        rfbLog(\"Scaling to %dx%d (refcount=%d)\\n\",width,height,ptr->scaledScreenRefCount);\n    }\n    else\n        rfbLog(\"Scaling to %dx%d failed, leaving things alone\\n\",width,height);\n}\n\nint rfbSendNewScaleSize(rfbClientPtr cl)\n{\n    /* if the client supports newFBsize Encoding, use it */\n    if (cl->useNewFBSize && cl->newFBSizePending)\n\treturn FALSE;\n\n    LOCK(cl->updateMutex);\n    cl->newFBSizePending = FALSE;\n    UNLOCK(cl->updateMutex);\n\n    if (cl->PalmVNC==TRUE)\n    {\n        rfbPalmVNCReSizeFrameBufferMsg pmsg;\n        pmsg.type = rfbPalmVNCReSizeFrameBuffer;\n        pmsg.pad1 = 0;\n        pmsg.desktop_w = Swap16IfLE(cl->screen->width);\n        pmsg.desktop_h = Swap16IfLE(cl->screen->height);\n        pmsg.buffer_w  = Swap16IfLE(cl->scaledScreen->width);\n        pmsg.buffer_h  = Swap16IfLE(cl->scaledScreen->height);\n        pmsg.pad2 = 0;\n\n        rfbLog(\"Sending a response to a PalmVNC style frameuffer resize event (%dx%d)\\n\", cl->scaledScreen->width, cl->scaledScreen->height);\n        if (rfbWriteExact(cl, (char *)&pmsg, sz_rfbPalmVNCReSizeFrameBufferMsg) < 0) {\n            rfbLogPerror(\"rfbNewClient: write\");\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n    else\n    {\n        rfbResizeFrameBufferMsg        rmsg;\n        rmsg.type = rfbResizeFrameBuffer;\n        rmsg.pad1=0;\n        rmsg.framebufferWidth  = Swap16IfLE(cl->scaledScreen->width);\n        rmsg.framebufferHeigth = Swap16IfLE(cl->scaledScreen->height);\n        rfbLog(\"Sending a response to a UltraVNC style frameuffer resize event (%dx%d)\\n\", cl->scaledScreen->width, cl->scaledScreen->height);\n        if (rfbWriteExact(cl, (char *)&rmsg, sz_rfbResizeFrameBufferMsg) < 0) {\n            rfbLogPerror(\"rfbNewClient: write\");\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}\n/****************************/\n"], "filenames": ["libvncserver/scale.c"], "buggy_code_start_loc": [213], "buggy_code_end_loc": [214], "fixing_code_start_loc": [213], "fixing_code_end_loc": [214], "type": "CWE-190", "message": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/scale.c has a pixel_value integer overflow.", "other": {"cve": {"id": "CVE-2020-14401", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:12.087", "lastModified": "2022-03-09T22:56:46.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/scale.c has a pixel_value integer overflow."}, {"lang": "es", "value": "Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. La biblioteca libvncserver/scale.c presenta un desbordamiento de enteros en la funci\u00f3n pixel_value"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvncserver_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.13", "matchCriteriaId": "4F3C4EF0-4663-4832-8662-D1AB70E562E7"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af"}}