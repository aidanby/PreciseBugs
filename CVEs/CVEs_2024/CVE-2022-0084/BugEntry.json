{"buggy_code": ["/*\n * JBoss, Home of Professional Open Source\n *\n * Copyright 2013 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.xnio;\n\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.xnio.channels.CloseListenerSettable;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.ConduitStreamSourceChannel;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.StreamSourceConduit;\n\nimport static org.xnio._private.Messages.msg;\n\n/**\n * A connection between peers.\n *\n * @author <a href=\"mailto:david.lloyd@redhat.com\">David M. Lloyd</a>\n * @author Flavia Rainone\n */\npublic abstract class StreamConnection extends Connection implements CloseListenerSettable<StreamConnection> {\n\n    /**\n     * An empty listener used as a flag, to indicate that close listener has been invoked.\n     */\n    private static final ChannelListener<? super StreamConnection> INVOKED_CLOSE_LISTENER_FLAG = (StreamConnection connection)->{};\n\n    private ConduitStreamSourceChannel sourceChannel;\n    private ConduitStreamSinkChannel sinkChannel;\n    private AtomicReference<ChannelListener<? super StreamConnection>> closeListener;\n\n    /**\n     * Construct a new instance.\n     *\n     * @param thread the I/O thread\n     */\n    protected StreamConnection(final XnioIoThread thread) {\n        super(thread);\n        closeListener = new AtomicReference<>();\n    }\n\n    public void setCloseListener(final ChannelListener<? super StreamConnection> listener) {\n        ChannelListener<? super StreamConnection> currentListener;\n        ChannelListener<? super StreamConnection> newListener;\n        do {\n            newListener = listener;\n            currentListener = closeListener.get();\n            if (currentListener != null) {\n                // channel is closed, just invoke the new listener and do not update closeListener\n                if (currentListener == INVOKED_CLOSE_LISTENER_FLAG) {\n                    ChannelListeners.invokeChannelListener(this, listener);\n                    return;\n                } else {\n                    newListener = mergeListeners(currentListener, listener);\n                }\n            }\n        } while (!closeListener.compareAndSet(currentListener, newListener));\n    }\n\n    private final ChannelListener<? super StreamConnection> mergeListeners(final ChannelListener<? super StreamConnection> listener1, final ChannelListener<? super StreamConnection> listener2) {\n        return (StreamConnection channel) -> {\n            listener1.handleEvent(channel);\n            listener2.handleEvent(channel);\n        };\n    }\n\n    @Override protected void notifyReadClosed() {\n\n        try {\n            this.getSourceChannel().shutdownReads();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override protected void notifyWriteClosed() {\n        try {\n            this.getSinkChannel().shutdownWrites();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ChannelListener<? super StreamConnection> getCloseListener() {\n        return closeListener.get();\n    }\n\n    public ChannelListener.Setter<? extends StreamConnection> getCloseSetter() {\n        return new Setter<>(this);\n    }\n\n    /**\n     * Set the source conduit for this channel.  The source channel will automatically be updated.\n     *\n     * @param conduit the source conduit for this channel\n     */\n    protected void setSourceConduit(StreamSourceConduit conduit) {\n        this.sourceChannel = conduit == null ? null : new ConduitStreamSourceChannel(this, conduit);\n    }\n\n    /**\n     * Set the sink conduit for this channel.  The sink channel will automatically be updated.\n     *\n     * @param conduit the sink conduit for this channel\n     */\n    protected void setSinkConduit(StreamSinkConduit conduit) {\n        this.sinkChannel = conduit == null ? null : new ConduitStreamSinkChannel(this, conduit);\n    }\n\n    void invokeCloseListener() {\n        // use a flag to indicate that closeListener has been invoked\n        final ChannelListener<? super StreamConnection> listener = closeListener.getAndSet(INVOKED_CLOSE_LISTENER_FLAG);\n        ChannelListeners.invokeChannelListener(this, listener);\n    }\n\n    private static <T> T notNull(T orig) throws IllegalStateException {\n        if (orig == null) {\n            throw msg.channelNotAvailable();\n        }\n        return orig;\n    }\n\n    /**\n     * Get the source channel.\n     *\n     * @return the source channel\n     */\n    public ConduitStreamSourceChannel getSourceChannel() {\n        return notNull(sourceChannel);\n    }\n\n    /**\n     * Get the sink channel.\n     *\n     * @return the sink channel\n     */\n    public ConduitStreamSinkChannel getSinkChannel() {\n        return notNull(sinkChannel);\n    }\n}\n"], "fixing_code": ["/*\n * JBoss, Home of Professional Open Source\n *\n * Copyright 2013 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.xnio;\n\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.jboss.logging.Logger;\nimport org.xnio.channels.CloseListenerSettable;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.ConduitStreamSourceChannel;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.StreamSourceConduit;\n\nimport static org.xnio._private.Messages.msg;\n\n/**\n * A connection between peers.\n *\n * @author <a href=\"mailto:david.lloyd@redhat.com\">David M. Lloyd</a>\n * @author Flavia Rainone\n */\npublic abstract class StreamConnection extends Connection implements CloseListenerSettable<StreamConnection> {\n\n    /**\n     * An empty listener used as a flag, to indicate that close listener has been invoked.\n     */\n    private static final ChannelListener<? super StreamConnection> INVOKED_CLOSE_LISTENER_FLAG = (StreamConnection connection)->{};\n    private static final Logger log = Logger.getLogger(\"org.xnio.StreamConnection\");\n\n    private ConduitStreamSourceChannel sourceChannel;\n    private ConduitStreamSinkChannel sinkChannel;\n    private AtomicReference<ChannelListener<? super StreamConnection>> closeListener;\n\n    /**\n     * Construct a new instance.\n     *\n     * @param thread the I/O thread\n     */\n    protected StreamConnection(final XnioIoThread thread) {\n        super(thread);\n        closeListener = new AtomicReference<>();\n    }\n\n    public void setCloseListener(final ChannelListener<? super StreamConnection> listener) {\n        ChannelListener<? super StreamConnection> currentListener;\n        ChannelListener<? super StreamConnection> newListener;\n        do {\n            newListener = listener;\n            currentListener = closeListener.get();\n            if (currentListener != null) {\n                // channel is closed, just invoke the new listener and do not update closeListener\n                if (currentListener == INVOKED_CLOSE_LISTENER_FLAG) {\n                    ChannelListeners.invokeChannelListener(this, listener);\n                    return;\n                } else {\n                    newListener = mergeListeners(currentListener, listener);\n                }\n            }\n        } while (!closeListener.compareAndSet(currentListener, newListener));\n    }\n\n    private final ChannelListener<? super StreamConnection> mergeListeners(final ChannelListener<? super StreamConnection> listener1, final ChannelListener<? super StreamConnection> listener2) {\n        return (StreamConnection channel) -> {\n            listener1.handleEvent(channel);\n            listener2.handleEvent(channel);\n        };\n    }\n\n    @Override protected void notifyReadClosed() {\n\n        try {\n            this.getSourceChannel().shutdownReads();\n        } catch (IOException e) {\n            log.error(\"Error in read close\", e);\n        }\n    }\n\n    @Override protected void notifyWriteClosed() {\n        try {\n            this.getSinkChannel().shutdownWrites();\n        } catch (IOException e) {\n            log.error(\"Error in write close\", e);\n        }\n    }\n\n    public ChannelListener<? super StreamConnection> getCloseListener() {\n        return closeListener.get();\n    }\n\n    public ChannelListener.Setter<? extends StreamConnection> getCloseSetter() {\n        return new Setter<>(this);\n    }\n\n    /**\n     * Set the source conduit for this channel.  The source channel will automatically be updated.\n     *\n     * @param conduit the source conduit for this channel\n     */\n    protected void setSourceConduit(StreamSourceConduit conduit) {\n        this.sourceChannel = conduit == null ? null : new ConduitStreamSourceChannel(this, conduit);\n    }\n\n    /**\n     * Set the sink conduit for this channel.  The sink channel will automatically be updated.\n     *\n     * @param conduit the sink conduit for this channel\n     */\n    protected void setSinkConduit(StreamSinkConduit conduit) {\n        this.sinkChannel = conduit == null ? null : new ConduitStreamSinkChannel(this, conduit);\n    }\n\n    void invokeCloseListener() {\n        // use a flag to indicate that closeListener has been invoked\n        final ChannelListener<? super StreamConnection> listener = closeListener.getAndSet(INVOKED_CLOSE_LISTENER_FLAG);\n        ChannelListeners.invokeChannelListener(this, listener);\n    }\n\n    private static <T> T notNull(T orig) throws IllegalStateException {\n        if (orig == null) {\n            throw msg.channelNotAvailable();\n        }\n        return orig;\n    }\n\n    /**\n     * Get the source channel.\n     *\n     * @return the source channel\n     */\n    public ConduitStreamSourceChannel getSourceChannel() {\n        return notNull(sourceChannel);\n    }\n\n    /**\n     * Get the sink channel.\n     *\n     * @return the sink channel\n     */\n    public ConduitStreamSinkChannel getSinkChannel() {\n        return notNull(sinkChannel);\n    }\n}\n"], "filenames": ["api/src/main/java/org/xnio/StreamConnection.java"], "buggy_code_start_loc": [23], "buggy_code_end_loc": [98], "fixing_code_start_loc": [24], "fixing_code_end_loc": [100], "type": "CWE-770", "message": "A flaw was found in XNIO, specifically in the notifyReadClosed method. The issue revealed this method was logging a message to another expected end. This flaw allows an attacker to send flawed requests to a server, possibly causing log contention-related performance concerns or an unwanted disk fill-up.", "other": {"cve": {"id": "CVE-2022-0084", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-26T18:15:08.487", "lastModified": "2022-09-01T15:34:55.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in XNIO, specifically in the notifyReadClosed method. The issue revealed this method was logging a message to another expected end. This flaw allows an attacker to send flawed requests to a server, possibly causing log contention-related performance concerns or an unwanted disk fill-up."}, {"lang": "es", "value": "Se ha encontrado un fallo en XNIO, concretamente en el m\u00e9todo notifyReadClosed. El problema revel\u00f3 que este m\u00e9todo estaba registrando un mensaje a otro extremo esperado. Este fallo permite a un atacante enviar peticiones defectuosas a un servidor, causando posiblemente problemas de rendimiento relacionados con la contenci\u00f3n de registros o un llenado de disco no deseado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:integration_camel_k:-:*:*:*:*:*:*:*", "matchCriteriaId": "B87C8AD3-8878-4546-86C2-BF411876648C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:integration_camel_quarkus:-:*:*:*:*:*:*:*", "matchCriteriaId": "F039C746-2001-4EE5-835F-49607A94F12B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "9EFEC7CA-8DDA-48A6-A7B6-1F1D14792890"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:xnio:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.8.7", "matchCriteriaId": "0BE22D4E-4636-47CF-87B1-D97AB30A885B"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-0084", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2064226", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/xnio/xnio/commit/fdefb3b8b715d33387cadc4d48991fb1989b0c12", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xnio/xnio/pull/291", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xnio/xnio/commit/fdefb3b8b715d33387cadc4d48991fb1989b0c12"}}