{"buggy_code": ["\"\"\" Track relationships between compiled extension functions & code fragments\n\n    catalog keeps track of which compiled(or even standard) functions are\n    related to which code fragments.  It also stores these relationships\n    to disk so they are remembered between Python sessions.  When\n\n        a = 1\n        compiler.inline('printf(\"printed from C: %d\",a);',['a'] )\n\n    is called, inline() first looks to see if it has seen the code\n    'printf(\"printed from C\");' before.  If not, it calls\n\n        catalog.get_functions('printf(\"printed from C: %d\", a);')\n\n    which returns a list of all the function objects that have been compiled\n    for the code fragment.  Multiple functions can occur because the code\n    could be compiled for different types for 'a' (although not likely in\n    this case). The catalog first looks in its cache and quickly returns\n    a list of the functions if possible.  If the cache lookup fails, it then\n    looks through possibly multiple catalog files on disk and fills its\n    cache with all the functions that match the code fragment.\n\n    In case where the code fragment hasn't been compiled, inline() compiles\n    the code and then adds it to the catalog:\n\n        function = <code to compile function>\n        catalog.add_function('printf(\"printed from C: %d\", a);',function)\n\n    add_function() adds function to the front of the cache.  function,\n    along with the path information to its module, are also stored in a\n    persistent catalog for future use by python sessions.\n\"\"\"\nfrom __future__ import absolute_import, print_function\n\nimport os\nimport sys\nimport pickle\nimport socket\nimport tempfile\n\ntry:\n    import dbhash\n    import shelve\n    dumb = 0\nexcept ImportError:\n    from . import _dumb_shelve as shelve\n    dumb = 1\n\n#For testing...\n#import scipy.io.dumb_shelve as shelve\n#dumb = 1\n\n#import shelve\n#dumb = 0\n\ndef getmodule(object):\n    \"\"\" Discover the name of the module where object was defined.\n\n        This is an augmented version of inspect.getmodule that can discover\n        the parent module for extension functions.\n    \"\"\"\n    import inspect\n    value = inspect.getmodule(object)\n    if value is None:\n        #walk trough all modules looking for function\n        for name,mod in sys.modules.items():\n            # try except used because of some comparison failures\n            # in wxPoint code.  Need to review this\n            try:\n                if mod and object in mod.__dict__.values():\n                    value = mod\n                    # if it is a built-in module, keep looking to see\n                    # if a non-builtin also has it.  Otherwise quit and\n                    # consider the module found. (ain't perfect, but will\n                    # have to do for now).\n                    if str(mod) not in '(built-in)':\n                        break\n\n            except (TypeError, KeyError, ImportError):\n                pass\n    return value\n\ndef expr_to_filename(expr):\n    \"\"\" Convert an arbitrary expr string to a valid file name.\n\n        The name is based on the md5 check sum for the string and\n        Something that was a little more human readable would be\n        nice, but the computer doesn't seem to care.\n    \"\"\"\n    import scipy.weave.md5_load as md5\n    base = 'sc_'\n    return base + md5.new(expr).hexdigest()\n\ndef unique_file(d,expr):\n    \"\"\" Generate a unqiue file name based on expr in directory d\n\n        This is meant for use with building extension modules, so\n        a file name is considered unique if none of the following\n        extension '.cpp','.o','.so','module.so','.py', or '.pyd'\n        exists in directory d.  The fully qualified path to the\n        new name is returned.  You'll need to append your own\n        extension to it before creating files.\n    \"\"\"\n    files = os.listdir(d)\n    #base = 'scipy_compile'\n    base = expr_to_filename(expr)\n    for i in xrange(1000000):\n        fname = base + repr(i)\n        if not (fname+'.cpp' in files or\n                fname+'.o' in files or\n                fname+'.so' in files or\n                fname+'module.so' in files or\n                fname+'.py' in files or\n                fname+'.pyd' in files):\n            break\n    return os.path.join(d,fname)\n\ndef is_writable(dir):\n    \"\"\"Determine whether a given directory is writable in a portable manner.\n\n    Parameters\n    ----------\n    dir : str\n        A string represeting a path to a directory on the filesystem.\n\n    Returns\n    -------\n    res : bool\n        True or False.\n    \"\"\"\n    if not os.path.isdir(dir):\n        return False\n\n    # Do NOT use a hardcoded name here due to the danger from race conditions\n    # on NFS when multiple processes are accessing the same base directory in\n    # parallel.  We use both hostname and pocess id for the prefix in an\n    # attempt to ensure that there can really be no name collisions (tempfile\n    # appends 6 random chars to this prefix).\n    prefix = 'dummy_%s_%s_' % (socket.gethostname(),os.getpid())\n    try:\n        tmp = tempfile.TemporaryFile(prefix=prefix,dir=dir)\n    except OSError:\n        return False\n    # The underlying file is destroyed upon closing the file object (under\n    # *nix, it was unlinked at creation time)\n    tmp.close()\n    return True\n\ndef whoami():\n    \"\"\"return a string identifying the user.\"\"\"\n    return os.environ.get(\"USER\") or os.environ.get(\"USERNAME\") or \"unknown\"\n\ndef default_dir():\n    \"\"\" Return a default location to store compiled files and catalogs.\n\n        XX is the Python version number in all paths listed below\n        On windows, the default location is the temporary directory\n        returned by gettempdir()/pythonXX.\n\n        On Unix, ~/.pythonXX_compiled is the default location.  If it doesn't\n        exist, it is created.  The directory is marked rwx------.\n\n        If for some reason it isn't possible to build a default directory\n        in the user's home, /tmp/<uid>_pythonXX_compiled is used.  If it\n        doesn't exist, it is created.  The directory is marked rwx------\n        to try and keep people from being able to sneak a bad module\n        in on you.\n\n    \"\"\"\n\n    # Use a cached value for fast return if possible\n    if hasattr(default_dir,\"cached_path\") and \\\n       os.path.exists(default_dir.cached_path) and \\\n       os.access(default_dir.cached_path, os.W_OK):\n        return default_dir.cached_path\n\n    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])\n    path_candidates = []\n    if sys.platform != 'win32':\n        try:\n            path_candidates.append(os.path.join(os.environ['HOME'],\n                                                '.' + python_name))\n        except KeyError:\n            pass\n\n        temp_dir = repr(os.getuid()) + '_' + python_name\n        path_candidates.append(os.path.join(tempfile.gettempdir(), temp_dir))\n    else:\n        path_candidates.append(os.path.join(tempfile.gettempdir(),\n                                           \"%s\" % whoami(), python_name))\n\n    writable = False\n    for path in path_candidates:\n        if not os.path.exists(path):\n            try:\n                os.makedirs(path, mode=0o700)\n            except OSError:\n                continue\n        if is_writable(path):\n            writable = True\n            break\n\n    if not writable:\n        print('warning: default directory is not write accessible.')\n        print('default:', path)\n\n    # Cache the default dir path so that this function returns quickly after\n    # being called once (nothing in it should change after the first call)\n    default_dir.cached_path = path\n\n    return path\n\ndef intermediate_dir():\n    \"\"\" Location in temp dir for storing .cpp and .o  files during\n        builds.\n    \"\"\"\n    python_name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])\n    path = os.path.join(tempfile.gettempdir(),\"%s\"%whoami(),python_name)\n    if not os.path.exists(path):\n        os.makedirs(path, mode=0o700)\n    return path\n\ndef default_temp_dir():\n    path = os.path.join(default_dir(),'temp')\n    if not os.path.exists(path):\n        os.makedirs(path, mode=0o700)\n    if not is_writable(path):\n        print('warning: default directory is not write accessible.')\n        print('default:', path)\n    return path\n\n\ndef os_dependent_catalog_name():\n    \"\"\" Generate catalog name dependent on OS and Python version being used.\n\n        This allows multiple platforms to have catalog files in the\n        same directory without stepping on each other.  For now, it\n        bases the name of the value returned by sys.platform and the\n        version of python being run.  If this isn't enough to descriminate\n        on some platforms, we can try to add other info.  It has\n        occurred to me that if we get fancy enough to optimize for different\n        architectures, then chip type might be added to the catalog name also.\n    \"\"\"\n    version = '%d%d' % sys.version_info[:2]\n    return sys.platform+version+'compiled_catalog'\n\ndef catalog_path(module_path):\n    \"\"\" Return the full path name for the catalog file in the given directory.\n\n        module_path can either be a file name or a path name.  If it is a\n        file name, the catalog file name in its parent directory is returned.\n        If it is a directory, the catalog file in that directory is returned.\n\n        If module_path doesn't exist, None is returned.  Note though, that the\n        catalog file does *not* have to exist, only its parent.  '~', shell\n        variables, and relative ('.' and '..') paths are all acceptable.\n\n        catalog file names are os dependent (based on sys.platform), so this\n        should support multiple platforms sharing the same disk space\n        (NFS mounts). See os_dependent_catalog_name() for more info.\n    \"\"\"\n    module_path = os.path.expanduser(module_path)\n    module_path = os.path.expandvars(module_path)\n    module_path = os.path.abspath(module_path)\n    if not os.path.exists(module_path):\n        catalog_file = None\n    elif not os.path.isdir(module_path):\n        module_path,dummy = os.path.split(module_path)\n        catalog_file = os.path.join(module_path,os_dependent_catalog_name())\n    else:\n        catalog_file = os.path.join(module_path,os_dependent_catalog_name())\n    return catalog_file\n\ndef get_catalog(module_path,mode='r'):\n    \"\"\" Return a function catalog (shelve object) from the path module_path\n\n        If module_path is a directory, the function catalog returned is\n        from that directory.  If module_path is an actual module_name,\n        then the function catalog returned is from its parent directory.\n        mode uses the standard 'c' = create, 'n' = new, 'r' = read,\n        'w' = write file open modes available for anydbm databases.\n\n        Well... it should be.  Stuck with dumbdbm for now and the modes\n        almost don't matter.  We do some checking for 'r' mode, but that\n        is about it.\n\n        See catalog_path() for more information on module_path.\n    \"\"\"\n    if mode not in ['c','r','w','n']:\n        msg = \" mode must be 'c', 'n', 'r', or 'w'.  See anydbm for more info\"\n        raise ValueError(msg)\n    catalog_file = catalog_path(module_path)\n    if (catalog_file is not None) \\\n           and ((dumb and os.path.exists(catalog_file+'.dat')) \\\n                or os.path.exists(catalog_file)):\n        sh = shelve.open(catalog_file,mode)\n    else:\n        if mode=='r':\n            sh = None\n        else:\n            sh = shelve.open(catalog_file,mode)\n    return sh\n\nclass catalog(object):\n    \"\"\" Stores information about compiled functions both in cache and on disk.\n\n        catalog stores (code, list_of_function) pairs so that all the functions\n        that have been compiled for code are available for calling (usually in\n        inline or blitz).\n\n        catalog keeps a dictionary of previously accessed code values cached\n        for quick access.  It also handles the looking up of functions compiled\n        in previously called Python sessions on disk in function catalogs.\n        catalog searches the directories in the PYTHONCOMPILED environment\n        variable in order loading functions that correspond to the given code\n        fragment.  A default directory is also searched for catalog functions.\n        On unix, the default directory is usually '~/.pythonxx_compiled' where\n        xx is the version of Python used. On windows, it is the directory\n        returned by temfile.gettempdir().  Functions closer to the front are of\n        the variable list are guaranteed to be closer to the front of the\n        function list so that they will be called first.  See\n        get_cataloged_functions() for more info on how the search order is\n        traversed.\n\n        Catalog also handles storing information about compiled functions to\n        a catalog.  When writing this information, the first writable catalog\n        file in PYTHONCOMPILED path is used.  If a writable catalog is not\n        found, it is written to the catalog in the default directory.  This\n        directory should always be writable.\n    \"\"\"\n    def __init__(self,user_path_list=None):\n        \"\"\" Create a catalog for storing/searching for compiled functions.\n\n            user_path_list contains directories that should be searched\n            first for function catalogs.  They will come before the path\n            entries in the PYTHONCOMPILED environment varilable.\n        \"\"\"\n        if isinstance(user_path_list, str):\n            self.user_path_list = [user_path_list]\n        elif user_path_list:\n            self.user_path_list = user_path_list\n        else:\n            self.user_path_list = []\n        self.cache = {}\n        self.module_dir = None\n        self.paths_added = 0\n        # unconditionally append the default dir for auto-generated compiled\n        # extension modules, so that pickle.load()s don't fail.\n        sys.path.append(default_dir())\n\n    def set_module_directory(self,module_dir):\n        \"\"\" Set the path that will replace 'MODULE' in catalog searches.\n\n            You should call clear_module_directory() when your finished\n            working with it.\n        \"\"\"\n        self.module_dir = module_dir\n    def get_module_directory(self):\n        \"\"\" Return the path used to replace the 'MODULE' in searches.\n        \"\"\"\n        return self.module_dir\n    def clear_module_directory(self):\n        \"\"\" Reset 'MODULE' path to None so that it is ignored in searches.\n        \"\"\"\n        self.module_dir = None\n\n    def get_environ_path(self):\n        \"\"\" Return list of paths from 'PYTHONCOMPILED' environment variable.\n\n            On Unix the path in PYTHONCOMPILED is a ':' separated list of\n            directories.  On Windows, a ';' separated list is used.\n        \"\"\"\n        paths = []\n        if 'PYTHONCOMPILED' in os.environ:\n            path_string = os.environ['PYTHONCOMPILED']\n            paths = path_string.split(os.path.pathsep)\n        return paths\n\n    def build_search_order(self):\n        \"\"\" Returns a list of paths that are searched for catalogs.\n\n            Values specified in the catalog constructor are searched first,\n            then values found in the PYTHONCOMPILED environment variable.\n            The directory returned by default_dir() is always returned at\n            the end of the list.\n\n            There is a 'magic' path name called 'MODULE' that is replaced\n            by the directory defined by set_module_directory().  If the\n            module directory hasn't been set, 'MODULE' is ignored.\n        \"\"\"\n\n        paths = self.user_path_list + self.get_environ_path()\n        search_order = []\n        for path in paths:\n            if path == 'MODULE':\n                if self.module_dir:\n                    search_order.append(self.module_dir)\n            else:\n                search_order.append(path)\n        search_order.append(default_dir())\n        return search_order\n\n    def get_catalog_files(self):\n        \"\"\" Returns catalog file list in correct search order.\n\n            Some of the catalog files may not currently exists.\n            However, all will be valid locations for a catalog\n            to be created (if you have write permission).\n        \"\"\"\n        files = map(catalog_path,self.build_search_order())\n        files = filter(lambda x: x is not None,files)\n        return files\n\n    def get_existing_files(self):\n        \"\"\" Returns all existing catalog file list in correct search order.\n        \"\"\"\n        files = self.get_catalog_files()\n        # open every stinking file to check if it exists.\n        # This is because anydbm doesn't provide a consistent naming\n        # convention across platforms for its files\n        existing_files = []\n        for file in files:\n            cat = get_catalog(os.path.dirname(file),'r')\n            if cat is not None:\n                existing_files.append(file)\n                cat.close()\n        # This is the non-portable (and much faster) old code\n        #existing_files = filter(os.path.exists,files)\n        return existing_files\n\n    def get_writable_file(self,existing_only=0):\n        \"\"\" Return the name of the first writable catalog file.\n\n            Its parent directory must also be writable.  This is so that\n            compiled modules can be written to the same directory.\n        \"\"\"\n        # note: both file and its parent directory must be writeable\n        if existing_only:\n            files = self.get_existing_files()\n        else:\n            files = self.get_catalog_files()\n        # filter for (file exists and is writable) OR directory is writable\n        def file_test(x):\n            from os import access, F_OK, W_OK\n            return (access(x,F_OK) and access(x,W_OK) or\n                    access(os.path.dirname(x),W_OK))\n        writable = filter(file_test,files)\n        if writable:\n            file = writable[0]\n        else:\n            file = None\n        return file\n\n    def get_writable_dir(self):\n        \"\"\" Return the parent directory of first writable catalog file.\n\n            The returned directory has write access.\n        \"\"\"\n        return os.path.dirname(self.get_writable_file())\n\n    def unique_module_name(self,code,module_dir=None):\n        \"\"\" Return full path to unique file name that in writable location.\n\n            The directory for the file is the first writable directory in\n            the catalog search path.  The unique file name is derived from\n            the code fragment.  If, module_dir is specified, it is used\n            to replace 'MODULE' in the search path.\n        \"\"\"\n        if module_dir is not None:\n            self.set_module_directory(module_dir)\n        try:\n            d = self.get_writable_dir()\n        finally:\n            if module_dir is not None:\n                self.clear_module_directory()\n        return unique_file(d, code)\n\n    def path_key(self,code):\n        \"\"\" Return key for path information for functions associated with code.\n        \"\"\"\n        return '__path__' + code\n\n    def configure_path(self,cat,code):\n        \"\"\" Add the python path for the given code to the sys.path\n\n            unconfigure_path() should be called as soon as possible after\n            imports associated with code are finished so that sys.path\n            is restored to normal.\n        \"\"\"\n        try:\n            paths = cat[self.path_key(code)]\n            self.paths_added = len(paths)\n            sys.path = paths + sys.path\n        except:\n            self.paths_added = 0\n\n    def unconfigure_path(self):\n        \"\"\" Restores sys.path to normal after calls to configure_path()\n\n            Remove the previously added paths from sys.path\n        \"\"\"\n        sys.path = sys.path[self.paths_added:]\n        self.paths_added = 0\n\n    def get_cataloged_functions(self,code):\n        \"\"\" Load all functions associated with code from catalog search path.\n\n            Sometimes there can be trouble loading a function listed in a\n            catalog file because the actual module that holds the function\n            has been moved or deleted.  When this happens, that catalog file\n            is \"repaired\", meaning the entire entry for this function is\n            removed from the file.  This only affects the catalog file that\n            has problems -- not the others in the search path.\n\n            The \"repair\" behavior may not be needed, but I'll keep it for now.\n        \"\"\"\n        mode = 'r'\n        cat = None\n        function_list = []\n        for path in self.build_search_order():\n            cat = get_catalog(path,mode)\n            if cat is not None and code in cat:\n                # set up the python path so that modules for this\n                # function can be loaded.\n                self.configure_path(cat,code)\n                try:\n                    function_list += cat[code]\n                except: #SystemError and ImportError so far seen\n                    # problems loading a function from the catalog.  Try to\n                    # repair the cause.\n                    cat.close()\n                    self.repair_catalog(path,code)\n                self.unconfigure_path()\n            if cat is not None:\n                # ensure that the catalog is properly closed\n                cat.close()\n        return function_list\n\n\n    def repair_catalog(self,catalog_path,code):\n        \"\"\" Remove entry for code from catalog_path\n\n            Occasionally catalog entries could get corrupted. An example\n            would be when a module that had functions in the catalog was\n            deleted or moved on the disk.  The best current repair method is\n            just to trash the entire catalog entry for this piece of code.\n            This may loose function entries that are valid, but thats life.\n\n            catalog_path must be writable for repair.  If it isn't, the\n            function exists with a warning.\n        \"\"\"\n        writable_cat = None\n        if (catalog_path is not None) and (not os.path.exists(catalog_path)):\n            return\n        try:\n            writable_cat = get_catalog(catalog_path,'w')\n        except:\n            print('warning: unable to repair catalog entry\\n %s\\n in\\n %s' % \\\n                  (code,catalog_path))\n            # shelve doesn't guarantee flushing, so it's safest to explicitly\n            # close the catalog\n            writable_cat.close()\n            return\n        if code in writable_cat:\n            print('repairing catalog by removing key')\n            del writable_cat[code]\n\n        # it is possible that the path key doesn't exist (if the function\n        # registered was a built-in function), so we have to check if the path\n        # exists before arbitrarily deleting it.\n        path_key = self.path_key(code)\n        if path_key in writable_cat:\n            del writable_cat[path_key]\n        writable_cat.close()\n\n    def get_functions_fast(self,code):\n        \"\"\" Return list of functions for code from the cache.\n\n            Return an empty list if the code entry is not found.\n        \"\"\"\n        return self.cache.get(code,[])\n\n    def get_functions(self,code,module_dir=None):\n        \"\"\" Return the list of functions associated with this code fragment.\n\n            The cache is first searched for the function.  If an entry\n            in the cache is not found, then catalog files on disk are\n            searched for the entry.  This is slooooow, but only happens\n            once per code object.  All the functions found in catalog files\n            on a cache miss are loaded into the cache to speed up future calls.\n            The search order is as follows:\n\n                1. user specified path (from catalog initialization)\n                2. directories from the PYTHONCOMPILED environment variable\n                3. The temporary directory on your platform.\n\n            The path specified by module_dir will replace the 'MODULE'\n            place holder in the catalog search path. See build_search_order()\n            for more info on the search path.\n        \"\"\"\n        # Fast!! try cache first.\n        if code in self.cache:\n            return self.cache[code]\n\n        # 2. Slow!! read previously compiled functions from disk.\n        try:\n            self.set_module_directory(module_dir)\n            function_list = self.get_cataloged_functions(code)\n            # put function_list in cache to save future lookups.\n            if function_list:\n                self.cache[code] = function_list\n            # return function_list, empty or otherwise.\n        finally:\n            self.clear_module_directory()\n        return function_list\n\n    def add_function(self,code,function,module_dir=None):\n        \"\"\" Adds a function to the catalog.\n\n            The function is added to the cache as well as the first\n            writable file catalog found in the search path.  If no\n            code entry exists in the cache, the on disk catalogs\n            are loaded into the cache and function is added to the\n            beginning of the function list.\n\n            The path specified by module_dir will replace the 'MODULE'\n            place holder in the catalog search path. See build_search_order()\n            for more info on the search path.\n        \"\"\"\n\n        # 1. put it in the cache.\n        if code in self.cache:\n            if function not in self.cache[code]:\n                self.cache[code].insert(0,function)\n            else:\n                # if it is in the cache, then it is also\n                # been persisted\n                return\n        else:\n            # Load functions and put this one up front\n            self.cache[code] = self.get_functions(code)\n            self.fast_cache(code,function)\n        # 2. Store the function entry to disk.\n        try:\n            self.set_module_directory(module_dir)\n            self.add_function_persistent(code,function)\n        finally:\n            self.clear_module_directory()\n\n    def add_function_persistent(self,code,function):\n        \"\"\" Store the code->function relationship to disk.\n\n            Two pieces of information are needed for loading functions\n            from disk -- the function pickle (which conveniently stores\n            the module name, etc.) and the path to its module's directory.\n            The latter is needed so that the function can be loaded no\n            matter what the user's Python path is.\n        \"\"\"\n        # add function to data in first writable catalog\n        mode = 'c' # create if doesn't exist, otherwise, use existing\n        cat_dir = self.get_writable_dir()\n        cat = get_catalog(cat_dir,mode)\n        if cat is None:\n            cat_dir = default_dir()\n            cat = get_catalog(cat_dir,mode)\n        if cat is None:\n            cat_dir = default_dir()\n            cat_file = catalog_path(cat_dir)\n            print('problems with default catalog -- removing')\n            import glob\n            files = glob.glob(cat_file+'*')\n            for f in files:\n                os.remove(f)\n            cat = get_catalog(cat_dir,mode)\n        if cat is None:\n            raise ValueError('Failed to access a catalog for storing functions')\n        # Prabhu was getting some corrupt catalog errors.  I'll put a try/except\n        # to protect against this, but should really try and track down the issue.\n        function_list = [function]\n        try:\n            function_list = function_list + cat.get(code,[])\n        except pickle.UnpicklingError:\n            pass\n        cat[code] = function_list\n        # now add needed path information for loading function\n        module = getmodule(function)\n        try:\n            # built in modules don't have the __file__ extension, so this\n            # will fail.  Just pass in this case since path additions aren't\n            # needed for built-in modules.\n            mod_path,f=os.path.split(os.path.abspath(module.__file__))\n            pkey = self.path_key(code)\n            cat[pkey] = [mod_path] + cat.get(pkey,[])\n        except:\n            pass\n        cat.close()\n\n    def fast_cache(self,code,function):\n        \"\"\" Move function to the front of the cache entry for code\n\n            If future calls to the function have the same type signature,\n            this will speed up access significantly because the first\n            function call is correct.\n\n            Note:  The cache added to the inline_tools module is significantly\n                   faster than always calling get_functions, so this isn't\n                   as necessary as it used to be.  Still, it's probably worth\n                   doing.\n        \"\"\"\n        try:\n            if self.cache[code][0] == function:\n                return\n        except: # KeyError, IndexError\n            pass\n        try:\n            self.cache[code].remove(function)\n        except ValueError:\n            pass\n        # put new function at the beginning of the list to search.\n        self.cache[code].insert(0,function)\n", "from __future__ import absolute_import, print_function\n\nimport sys\nimport os\n\nfrom numpy.testing import TestCase, assert_\n\nfrom scipy.weave import catalog\nfrom weave_test_utils import clear_temp_catalog, restore_temp_catalog, \\\n        empty_temp_dir, cleanup_temp_dir\n\n\nclass TestDefaultDir(TestCase):\n    def test_is_writable(self):\n        path = catalog.default_dir()\n        name = os.path.join(path,'dummy_catalog')\n        test_file = open(name,'w')\n        try:\n            test_file.write('making sure default location is writable\\n')\n        finally:\n            test_file.close()\n            os.remove(name)\n\n\nclass TestOsDependentCatalogName(TestCase):\n    pass\n\n\nclass TestCatalogPath(TestCase):\n\n    def test_default(self):\n        in_path = catalog.default_dir()\n        path = catalog.catalog_path(in_path)\n        d,f = os.path.split(path)\n        assert_(d == in_path)\n        assert_(f == catalog.os_dependent_catalog_name())\n\n    def test_current(self):\n        in_path = '.'\n        path = catalog.catalog_path(in_path)\n        d,f = os.path.split(path)\n        assert_(d == os.path.abspath(in_path))\n        assert_(f == catalog.os_dependent_catalog_name())\n\n    def test_user(path):\n        if sys.platform != 'win32':\n            in_path = '~'\n            path = catalog.catalog_path(in_path)\n            d,f = os.path.split(path)\n            assert_(d == os.path.expanduser(in_path))\n            assert_(f == catalog.os_dependent_catalog_name())\n\n    def test_module(self):\n        # hand it a module and see if it uses the parent directory\n        # of the module.\n        path = catalog.catalog_path(os.__file__)\n        d,f = os.path.split(os.__file__)\n        d2,f = os.path.split(path)\n        assert_(d2 == d)\n\n    def test_path(self):\n        # use os.__file__ to get a usable directory.\n        in_path,f = os.path.split(os.__file__)\n        path = catalog.catalog_path(in_path)\n        d,f = os.path.split(path)\n        assert_(d == in_path)\n\n    def test_bad_path(self):\n        # stupid_path_name\n        in_path = 'stupid_path_name'\n        path = catalog.catalog_path(in_path)\n        assert_(path is None)\n\n\nclass TestGetCatalog(TestCase):\n    \"\"\" This only tests whether new catalogs are created correctly.\n        And whether non-existent return None correctly with read mode.\n        Putting catalogs in the right place is all tested with\n        catalog_dir tests.\n    \"\"\"\n\n    def get_test_dir(self,erase = 0):\n        # make sure tempdir catalog doesn't exist\n        import tempfile, glob\n        #temp = tempfile.gettempdir()\n        pardir = tempfile.mktemp(suffix='cat_test')\n        if not os.path.exists(pardir):\n            os.mkdir(pardir)\n        cat_glob = os.path.join(pardir,catalog.os_dependent_catalog_name()+'.*')\n        cat_files = glob.glob(cat_glob)\n        if erase:\n            for cat_file in cat_files:\n                os.remove(cat_file)\n        return pardir\n\n    def remove_dir(self,d):\n        import distutils.dir_util\n        distutils.dir_util.remove_tree(d)\n\n    def test_nonexistent_catalog_is_none(self):\n        pardir = self.get_test_dir(erase=1)\n        cat = catalog.get_catalog(pardir,'r')\n        self.remove_dir(pardir)\n        assert_(cat is None)\n\n    def test_create_catalog(self):\n        pardir = self.get_test_dir(erase=1)\n        cat = catalog.get_catalog(pardir,'c')\n        assert_(cat is not None)\n        cat.close()\n        self.remove_dir(pardir)\n\n\nclass TestCatalog(TestCase):\n\n    def clear_environ(self):\n        if 'PYTHONCOMPILED' in os.environ:\n            self.old_PYTHONCOMPILED = os.environ['PYTHONCOMPILED']\n            del os.environ['PYTHONCOMPILED']\n        else:\n            self.old_PYTHONCOMPILED = None\n\n    def reset_environ(self):\n        if self.old_PYTHONCOMPILED:\n            os.environ['PYTHONCOMPILED'] = self.old_PYTHONCOMPILED\n            self.old_PYTHONCOMPILED = None\n\n    def setUp(self):\n        self.clear_environ()\n\n    def tearDown(self):\n        self.reset_environ()\n\n    def test_set_module_directory(self):\n        q = catalog.catalog()\n        q.set_module_directory('bob')\n        r = q.get_module_directory()\n        assert_(r == 'bob')\n\n    def test_clear_module_directory(self):\n        q = catalog.catalog()\n        r = q.get_module_directory()\n        assert_(r is None)\n        q.set_module_directory('bob')\n        r = q.clear_module_directory()\n        assert_(r is None)\n\n    def test_get_environ_path(self):\n        if sys.platform == 'win32': sep = ';'\n        else: sep = ':'\n        os.environ['PYTHONCOMPILED'] = sep.join(('path1','path2','path3'))\n        q = catalog.catalog()\n        path = q.get_environ_path()\n        assert_(path == ['path1','path2','path3'])\n\n    def test_build_search_order1(self):\n        \"\"\" MODULE in search path should be replaced by module_dir.\n        \"\"\"\n        q = catalog.catalog(['first','MODULE','third'])\n        q.set_module_directory('second')\n        order = q.build_search_order()\n        assert_(order == ['first','second','third',catalog.default_dir()])\n\n    def test_build_search_order2(self):\n        \"\"\" MODULE in search path should be removed if module_dir==None.\n        \"\"\"\n        q = catalog.catalog(['first','MODULE','third'])\n        order = q.build_search_order()\n        assert_(order == ['first','third',catalog.default_dir()])\n\n    def test_build_search_order3(self):\n        \"\"\" If MODULE is absent, module_dir shouldn't be in search path.\n        \"\"\"\n        q = catalog.catalog(['first','second'])\n        q.set_module_directory('third')\n        order = q.build_search_order()\n        assert_(order == ['first','second',catalog.default_dir()])\n\n    def test_build_search_order4(self):\n        \"\"\" Make sure environment variable is getting used.\n        \"\"\"\n        q = catalog.catalog(['first','second'])\n        if sys.platform == 'win32':\n            sep = ';'\n        else:\n            sep = ':'\n        os.environ['PYTHONCOMPILED'] = sep.join(('MODULE','fourth','fifth'))\n        q.set_module_directory('third')\n        order = q.build_search_order()\n        assert_(order == ['first','second','third','fourth','fifth',catalog.default_dir()])\n\n    def test_catalog_files1(self):\n        \"\"\" Be sure we get at least one file even without specifying the path.\n        \"\"\"\n        q = catalog.catalog()\n        files = q.get_catalog_files()\n        assert_(len(files) == 1)\n\n    def test_catalog_files2(self):\n        \"\"\" Ignore bad paths in the path.\n        \"\"\"\n        q = catalog.catalog()\n        os.environ['PYTHONCOMPILED'] = '_some_bad_path_'\n        files = q.get_catalog_files()\n        assert_(len(files) == 1)\n\n    def test_get_existing_files1(self):\n        \"\"\" Shouldn't get any files when temp doesn't exist and no path set.\n        \"\"\"\n        clear_temp_catalog()\n        q = catalog.catalog()\n        files = q.get_existing_files()\n        restore_temp_catalog()\n        assert_(len(files) == 0)\n\n    def test_get_existing_files2(self):\n        \"\"\" Shouldn't get a single file from the temp dir.\n        \"\"\"\n        clear_temp_catalog()\n        q = catalog.catalog()\n        # create a dummy file\n        import os\n        q.add_function('code', os.getpid)\n        del q\n        q = catalog.catalog()\n        files = q.get_existing_files()\n        restore_temp_catalog()\n        assert_(len(files) == 1)\n\n    def test_access_writable_file(self):\n        \"\"\" There should always be a writable file -- even if it is in temp\n        \"\"\"\n        q = catalog.catalog()\n        file = q.get_writable_file()\n        try:\n            f = open(file,'w')\n            f.write('bob')\n        finally:\n            f.close()\n            os.remove(file)\n\n    def test_writable_with_bad_path(self):\n        \"\"\" There should always be a writable file -- even if search paths contain\n            bad values.\n        \"\"\"\n        if sys.platform == 'win32':\n            sep = ';'\n        else:\n            sep = ':'\n        os.environ['PYTHONCOMPILED'] = sep.join(('_bad_path_name_'))\n        q = catalog.catalog()\n        file = q.get_writable_file()\n        try:\n            f = open(file,'w')\n            f.write('bob')\n        finally:\n            f.close()\n        os.remove(file)\n\n    def test_writable_dir(self):\n        \"\"\" Check that we can create a file in the writable directory\n        \"\"\"\n        q = catalog.catalog()\n        d = q.get_writable_dir()\n        file = os.path.join(d,'some_silly_file')\n        try:\n            f = open(file,'w')\n            f.write('bob')\n        finally:\n            f.close()\n            os.remove(file)\n\n    def test_unique_module_name(self):\n        \"\"\" Check that we can create a file in the writable directory\n        \"\"\"\n        q = catalog.catalog()\n        file = q.unique_module_name('bob')\n        cfile1 = file+'.cpp'\n        assert_(not os.path.exists(cfile1))\n        # Make sure it is writable\n        try:\n            f = open(cfile1,'w')\n            f.write('bob')\n        finally:\n            f.close()\n        # try again with same code fragment -- should get unique name\n        file = q.unique_module_name('bob')\n        cfile2 = file+'.cpp'\n        assert_(not os.path.exists(cfile2+'.cpp'))\n        os.remove(cfile1)\n\n    def test_add_function_persistent1(self):\n        \"\"\" Test persisting a function in the default catalog\n        \"\"\"\n        clear_temp_catalog()\n        q = catalog.catalog()\n        # just use some already available functions\n        import string\n        funcs = [string.upper, string.lower, string.find,string.replace]\n        for i in funcs:\n            q.add_function_persistent('code',i)\n        pfuncs = q.get_cataloged_functions('code')\n        # any way to clean modules???\n        restore_temp_catalog()\n        for i in funcs:\n            assert_(i in pfuncs)\n\n    def test_add_function_ordered(self):\n        clear_temp_catalog()\n        q = catalog.catalog()\n        import string\n\n        q.add_function('f',string.upper)\n        q.add_function('f',string.lower)\n        q.add_function('ff',string.find)\n        q.add_function('ff',string.replace)\n        q.add_function('fff',string.atof)\n        q.add_function('fff',string.atoi)\n        del q\n\n        # now we're gonna make a new catalog with same code\n        # but different functions in a specified module directory\n        env_dir = empty_temp_dir()\n        r = catalog.catalog(env_dir)\n        r.add_function('ff',os.abort)\n        r.add_function('ff',os.chdir)\n        r.add_function('fff',os.access)\n        r.add_function('fff',os.open)\n        del r\n        # now we're gonna make a new catalog with same code\n        # but different functions in a user specified directory\n        user_dir = empty_temp_dir()\n        s = catalog.catalog(user_dir)\n        import re\n        s.add_function('fff',re.match)\n        s.add_function('fff',re.purge)\n        del s\n\n        # open new catalog and make sure it retreives the functions\n        # from d catalog instead of the temp catalog (made by q)\n        os.environ['PYTHONCOMPILED'] = env_dir\n        t = catalog.catalog(user_dir)\n        funcs1 = t.get_functions('f')\n        funcs2 = t.get_functions('ff')\n        funcs3 = t.get_functions('fff')\n        restore_temp_catalog()\n        # make sure everything is read back in the correct order\n        # a little cheating... I'm ignoring any functions that might have\n        # been read in from a prior catalog file (such as the defualt one).\n        # the test should really be made so that these aren't read in, but\n        # until I get this figured out...\n        #assert_(funcs1 == [string.lower,string.upper])\n        #assert_(funcs2 == [os.chdir,os.abort,string.replace,string.find])\n        #assert_(funcs3 == [re.purge,re.match,os.open,\n        #                  os.access,string.atoi,string.atof])\n        assert_(funcs1[:2] == [string.lower,string.upper]),repr(funcs1)\n        assert_(funcs2[:4] == [os.chdir,os.abort,string.replace,string.find])\n        assert_(funcs3[:6] == [re.purge,re.match,os.open,\n                          os.access,string.atoi,string.atof])\n        cleanup_temp_dir(user_dir)\n        cleanup_temp_dir(env_dir)\n\n\nif __name__ == '__main__':\n    import nose\n    nose.run(argv=['', __file__])\n"], "fixing_code": ["\"\"\" Track relationships between compiled extension functions & code fragments\n\n    catalog keeps track of which compiled(or even standard) functions are\n    related to which code fragments.  It also stores these relationships\n    to disk so they are remembered between Python sessions.  When\n\n        a = 1\n        compiler.inline('printf(\"printed from C: %d\",a);',['a'] )\n\n    is called, inline() first looks to see if it has seen the code\n    'printf(\"printed from C\");' before.  If not, it calls\n\n        catalog.get_functions('printf(\"printed from C: %d\", a);')\n\n    which returns a list of all the function objects that have been compiled\n    for the code fragment.  Multiple functions can occur because the code\n    could be compiled for different types for 'a' (although not likely in\n    this case). The catalog first looks in its cache and quickly returns\n    a list of the functions if possible.  If the cache lookup fails, it then\n    looks through possibly multiple catalog files on disk and fills its\n    cache with all the functions that match the code fragment.\n\n    In case where the code fragment hasn't been compiled, inline() compiles\n    the code and then adds it to the catalog:\n\n        function = <code to compile function>\n        catalog.add_function('printf(\"printed from C: %d\", a);',function)\n\n    add_function() adds function to the front of the cache.  function,\n    along with the path information to its module, are also stored in a\n    persistent catalog for future use by python sessions.\n\"\"\"\nfrom __future__ import absolute_import, print_function\n\nimport os\nimport sys\nimport stat\nimport pickle\nimport socket\nimport tempfile\n\ntry:\n    import dbhash\n    import shelve\n    dumb = 0\nexcept ImportError:\n    from . import _dumb_shelve as shelve\n    dumb = 1\n\n#For testing...\n#import scipy.io.dumb_shelve as shelve\n#dumb = 1\n\n#import shelve\n#dumb = 0\n\ndef getmodule(object):\n    \"\"\" Discover the name of the module where object was defined.\n\n        This is an augmented version of inspect.getmodule that can discover\n        the parent module for extension functions.\n    \"\"\"\n    import inspect\n    value = inspect.getmodule(object)\n    if value is None:\n        #walk trough all modules looking for function\n        for name,mod in sys.modules.items():\n            # try except used because of some comparison failures\n            # in wxPoint code.  Need to review this\n            try:\n                if mod and object in mod.__dict__.values():\n                    value = mod\n                    # if it is a built-in module, keep looking to see\n                    # if a non-builtin also has it.  Otherwise quit and\n                    # consider the module found. (ain't perfect, but will\n                    # have to do for now).\n                    if str(mod) not in '(built-in)':\n                        break\n\n            except (TypeError, KeyError, ImportError):\n                pass\n    return value\n\ndef expr_to_filename(expr):\n    \"\"\" Convert an arbitrary expr string to a valid file name.\n\n        The name is based on the md5 check sum for the string and\n        Something that was a little more human readable would be\n        nice, but the computer doesn't seem to care.\n    \"\"\"\n    import scipy.weave.md5_load as md5\n    base = 'sc_'\n    return base + md5.new(expr).hexdigest()\n\ndef unique_file(d,expr):\n    \"\"\" Generate a unqiue file name based on expr in directory d\n\n        This is meant for use with building extension modules, so\n        a file name is considered unique if none of the following\n        extension '.cpp','.o','.so','module.so','.py', or '.pyd'\n        exists in directory d.  The fully qualified path to the\n        new name is returned.  You'll need to append your own\n        extension to it before creating files.\n    \"\"\"\n    files = os.listdir(d)\n    #base = 'scipy_compile'\n    base = expr_to_filename(expr)\n    for i in xrange(1000000):\n        fname = base + repr(i)\n        if not (fname+'.cpp' in files or\n                fname+'.o' in files or\n                fname+'.so' in files or\n                fname+'module.so' in files or\n                fname+'.py' in files or\n                fname+'.pyd' in files):\n            break\n    return os.path.join(d,fname)\n\ndef is_writable(dir):\n    \"\"\"Determine whether a given directory is writable in a portable manner.\n\n    Parameters\n    ----------\n    dir : str\n        A string represeting a path to a directory on the filesystem.\n\n    Returns\n    -------\n    res : bool\n        True or False.\n    \"\"\"\n    if not os.path.isdir(dir):\n        return False\n\n    # Do NOT use a hardcoded name here due to the danger from race conditions\n    # on NFS when multiple processes are accessing the same base directory in\n    # parallel.  We use both hostname and process id for the prefix in an\n    # attempt to ensure that there can really be no name collisions (tempfile\n    # appends 6 random chars to this prefix).\n    prefix = 'dummy_%s_%s_' % (socket.gethostname(),os.getpid())\n    try:\n        tmp = tempfile.TemporaryFile(prefix=prefix,dir=dir)\n    except OSError:\n        return False\n    # The underlying file is destroyed upon closing the file object (under\n    # *nix, it was unlinked at creation time)\n    tmp.close()\n    return True\n\ndef whoami():\n    \"\"\"return a string identifying the user.\"\"\"\n    return os.environ.get(\"USER\") or os.environ.get(\"USERNAME\") or \"unknown\"\n\n\ndef _create_dirs(path):\n    \"\"\" create provided path, ignore errors \"\"\"\n    try:\n        os.makedirs(path, mode=0o700)\n    except OSError:\n        pass\n\n\ndef default_dir_posix(tmp_dir=None):\n    \"\"\"\n    Create or find default catalog store for posix systems\n\n    purpose of 'tmp_dir' is to enable way how to test this function easily\n    \"\"\"\n    path_candidates = []\n    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])\n\n    if tmp_dir:\n        home_dir = tmp_dir\n    else:\n        home_dir = os.path.expanduser('~')\n    tmp_dir = tmp_dir or tempfile.gettempdir()\n\n    home_temp_dir_name = '.' + python_name\n    home_temp_dir = os.path.join(home_dir, home_temp_dir_name)\n    path_candidates.append(home_temp_dir)\n\n    temp_dir_name = repr(os.getuid()) + '_' + python_name\n    temp_dir_path = os.path.join(tmp_dir, temp_dir_name)\n    path_candidates.append(temp_dir_path)\n\n    for path in path_candidates:\n        _create_dirs(path)\n        if check_dir(path):\n            return path\n\n    # since we got here, both dirs are not useful\n    tmp_dir_path = find_valid_temp_dir(temp_dir_name, tmp_dir)\n    if not tmp_dir_path:\n        tmp_dir_path = create_temp_dir(temp_dir_name, tmp_dir=tmp_dir)\n    return tmp_dir_path\n\n\ndef default_dir_win(tmp_dir=None):\n    \"\"\"\n    Create or find default catalog store for Windows systems\n\n    purpose of 'tmp_dir' is to enable way how to test this function easily\n    \"\"\"\n    def create_win_temp_dir(prefix, inner_dir=None, tmp_dir=None):\n        \"\"\"\n        create temp dir starting with 'prefix' in 'tmp_dir' or\n        'tempfile.gettempdir'; if 'inner_dir' is specified, it should be\n        created inside\n        \"\"\"\n        tmp_dir_path = find_valid_temp_dir(prefix, tmp_dir)\n        if tmp_dir_path:\n            if inner_dir:\n                tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)\n                if not os.path.isdir(tmp_dir_path):\n                    os.mkdir(tmp_dir_path, 0o700)\n        else:\n            tmp_dir_path = create_temp_dir(prefix, inner_dir, tmp_dir)\n        return tmp_dir_path\n\n    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])\n    tmp_dir = tmp_dir or tempfile.gettempdir()\n\n    temp_dir_name = \"%s\" % whoami()\n    temp_root_dir = os.path.join(tmp_dir, temp_dir_name)\n    temp_dir_path = os.path.join(temp_root_dir, python_name)\n    _create_dirs(temp_dir_path)\n    if check_dir(temp_dir_path) and check_dir(temp_root_dir):\n        return temp_dir_path\n    else:\n        if check_dir(temp_root_dir):\n            return create_win_temp_dir(python_name, tmp_dir=temp_root_dir)\n        else:\n            return create_win_temp_dir(temp_dir_name, python_name, tmp_dir)\n\n\ndef default_dir():\n    \"\"\" Return a default location to store compiled files and catalogs.\n\n        XX is the Python version number in all paths listed below\n        On windows, the default location is the temporary directory\n        returned by gettempdir()/pythonXX.\n\n        On Unix, ~/.pythonXX_compiled is the default location.  If it doesn't\n        exist, it is created.  The directory is marked rwx------.\n\n        If for some reason it isn't possible to build a default directory\n        in the user's home, /tmp/<uid>_pythonXX_compiled is used.  If it\n        doesn't exist, it is created.  The directory is marked rwx------\n        to try and keep people from being able to sneak a bad module\n        in on you. If the directory already exists in /tmp/ and is not\n        secure, new one is created.\n    \"\"\"\n    # Use a cached value for fast return if possible\n    if hasattr(default_dir, \"cached_path\") and \\\n       check_dir(default_dir.cached_path):\n        return default_dir.cached_path\n\n    if sys.platform == 'win32':\n        path = default_dir_win()\n    else:\n        path = default_dir_posix()\n\n    # Cache the default dir path so that this function returns quickly after\n    # being called once (nothing in it should change after the first call)\n    default_dir.cached_path = path\n\n    return path\n\n\ndef check_dir(im_dir):\n    \"\"\"\n    Check if dir is safe; if it is, return True.\n    These checks make sense only on posix:\n     * directory has correct owner\n     * directory has correct permissions (0700)\n     * directory is not a symlink\n    \"\"\"\n    def check_is_dir():\n        return os.path.isdir(im_dir)\n\n    def check_permissions():\n        \"\"\" If on posix, permissions should be 0700. \"\"\"\n        writable = is_writable(im_dir)\n        if sys.platform != 'win32':\n            try:\n                im_dir_stat = os.stat(im_dir)\n            except OSError:\n                return False\n            writable &= stat.S_IMODE(im_dir_stat.st_mode) == 0o0700\n        return writable\n\n    def check_ownership():\n        \"\"\" Intermediate dir owner should be same as owner of process. \"\"\"\n        if sys.platform != 'win32':\n            try:\n                im_dir_stat = os.stat(im_dir)\n            except OSError:\n                return False\n            proc_uid = os.getuid()\n            return proc_uid == im_dir_stat.st_uid\n        return True\n\n    def check_is_symlink():\n        \"\"\" Check if intermediate dir is symlink. \"\"\"\n        try:\n            return not os.path.islink(im_dir)\n        except OSError:\n            return False\n\n    checks = [check_is_dir, check_permissions,\n              check_ownership, check_is_symlink]\n\n    for check in checks:\n        if not check():\n            return False\n\n    return True\n\n\ndef create_temp_dir(prefix, inner_dir=None, tmp_dir=None):\n    \"\"\"\n    Create intermediate dirs <tmp>/<prefix+random suffix>/<inner_dir>/\n\n    argument 'tmp_dir' is used in unit tests\n    \"\"\"\n    if not tmp_dir:\n        tmp_dir_path = tempfile.mkdtemp(prefix=prefix)\n    else:\n        tmp_dir_path = tempfile.mkdtemp(prefix=prefix, dir=tmp_dir)\n    if inner_dir:\n        tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)\n        os.mkdir(tmp_dir_path, 0o700)\n    return tmp_dir_path\n\n\ndef intermediate_dir_prefix():\n    \"\"\" Prefix of root intermediate dir (<tmp>/<root_im_dir>). \"\"\"\n    return \"%s-%s-\" % (\"scipy\", whoami())\n\n\ndef find_temp_dir(prefix, tmp_dir=None):\n    \"\"\" Find temp dirs in 'tmp_dir' starting with 'prefix'\"\"\"\n    matches = []\n    tmp_dir = tmp_dir or tempfile.gettempdir()\n    for tmp_file in os.listdir(tmp_dir):\n        if tmp_file.startswith(prefix):\n            matches.append(os.path.join(tmp_dir, tmp_file))\n    return matches\n\n\ndef find_valid_temp_dir(prefix, tmp_dir=None):\n    \"\"\"\n    Try to look for existing temp dirs.\n    If there is one suitable found, return it, otherwise return None.\n    \"\"\"\n    matches = find_temp_dir(prefix, tmp_dir)\n    for match in matches:\n        if check_dir(match):\n            # as soon as we find correct dir, we can stop searching\n            return match\n\n\ndef py_intermediate_dir():\n    \"\"\"\n    Name of intermediate dir for current python interpreter:\n    <temp dir>/<name>/pythonXY_intermediate/\n    \"\"\"\n    name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])\n    return name\n\n\ndef create_intermediate_dir(tmp_dir=None):\n    py_im_dir = py_intermediate_dir()\n    return create_temp_dir(intermediate_dir_prefix(), py_im_dir, tmp_dir)\n\n\ndef intermediate_dir(tmp_dir=None):\n    \"\"\"\n    Temporary directory for storing .cpp and .o files during builds.\n\n    First, try to find the dir and if it exists, verify it is safe.\n    Otherwise, create it.\n    \"\"\"\n    im_dir = find_valid_temp_dir(intermediate_dir_prefix(), tmp_dir)\n    py_im_dir = py_intermediate_dir()\n    if im_dir is None:\n        py_im_dir = py_intermediate_dir()\n        im_dir = create_intermediate_dir(tmp_dir)\n    else:\n        im_dir = os.path.join(im_dir, py_im_dir)\n        if not os.path.isdir(im_dir):\n            os.mkdir(im_dir, 0o700)\n    return im_dir\n\n\ndef default_temp_dir():\n    path = os.path.join(default_dir(),'temp')\n    if not os.path.exists(path):\n        os.makedirs(path, mode=0o700)\n    if not is_writable(path):\n        print('warning: default directory is not write accessible.')\n        print('default:', path)\n    return path\n\n\ndef os_dependent_catalog_name():\n    \"\"\" Generate catalog name dependent on OS and Python version being used.\n\n        This allows multiple platforms to have catalog files in the\n        same directory without stepping on each other.  For now, it\n        bases the name of the value returned by sys.platform and the\n        version of python being run.  If this isn't enough to descriminate\n        on some platforms, we can try to add other info.  It has\n        occurred to me that if we get fancy enough to optimize for different\n        architectures, then chip type might be added to the catalog name also.\n    \"\"\"\n    version = '%d%d' % sys.version_info[:2]\n    return sys.platform+version+'compiled_catalog'\n\ndef catalog_path(module_path):\n    \"\"\" Return the full path name for the catalog file in the given directory.\n\n        module_path can either be a file name or a path name.  If it is a\n        file name, the catalog file name in its parent directory is returned.\n        If it is a directory, the catalog file in that directory is returned.\n\n        If module_path doesn't exist, None is returned.  Note though, that the\n        catalog file does *not* have to exist, only its parent.  '~', shell\n        variables, and relative ('.' and '..') paths are all acceptable.\n\n        catalog file names are os dependent (based on sys.platform), so this\n        should support multiple platforms sharing the same disk space\n        (NFS mounts). See os_dependent_catalog_name() for more info.\n    \"\"\"\n    module_path = os.path.expanduser(module_path)\n    module_path = os.path.expandvars(module_path)\n    module_path = os.path.abspath(module_path)\n    if not os.path.exists(module_path):\n        catalog_file = None\n    elif not os.path.isdir(module_path):\n        module_path,dummy = os.path.split(module_path)\n        catalog_file = os.path.join(module_path,os_dependent_catalog_name())\n    else:\n        catalog_file = os.path.join(module_path,os_dependent_catalog_name())\n    return catalog_file\n\ndef get_catalog(module_path,mode='r'):\n    \"\"\" Return a function catalog (shelve object) from the path module_path\n\n        If module_path is a directory, the function catalog returned is\n        from that directory.  If module_path is an actual module_name,\n        then the function catalog returned is from its parent directory.\n        mode uses the standard 'c' = create, 'n' = new, 'r' = read,\n        'w' = write file open modes available for anydbm databases.\n\n        Well... it should be.  Stuck with dumbdbm for now and the modes\n        almost don't matter.  We do some checking for 'r' mode, but that\n        is about it.\n\n        See catalog_path() for more information on module_path.\n    \"\"\"\n    if mode not in ['c','r','w','n']:\n        msg = \" mode must be 'c', 'n', 'r', or 'w'.  See anydbm for more info\"\n        raise ValueError(msg)\n    catalog_file = catalog_path(module_path)\n    if (catalog_file is not None) \\\n           and ((dumb and os.path.exists(catalog_file+'.dat')) \\\n                or os.path.exists(catalog_file)):\n        sh = shelve.open(catalog_file,mode)\n    else:\n        if mode=='r':\n            sh = None\n        else:\n            sh = shelve.open(catalog_file,mode)\n    return sh\n\nclass catalog(object):\n    \"\"\" Stores information about compiled functions both in cache and on disk.\n\n        catalog stores (code, list_of_function) pairs so that all the functions\n        that have been compiled for code are available for calling (usually in\n        inline or blitz).\n\n        catalog keeps a dictionary of previously accessed code values cached\n        for quick access.  It also handles the looking up of functions compiled\n        in previously called Python sessions on disk in function catalogs.\n        catalog searches the directories in the PYTHONCOMPILED environment\n        variable in order loading functions that correspond to the given code\n        fragment.  A default directory is also searched for catalog functions.\n        On unix, the default directory is usually '~/.pythonxx_compiled' where\n        xx is the version of Python used. On windows, it is the directory\n        returned by temfile.gettempdir().  Functions closer to the front are of\n        the variable list are guaranteed to be closer to the front of the\n        function list so that they will be called first.  See\n        get_cataloged_functions() for more info on how the search order is\n        traversed.\n\n        Catalog also handles storing information about compiled functions to\n        a catalog.  When writing this information, the first writable catalog\n        file in PYTHONCOMPILED path is used.  If a writable catalog is not\n        found, it is written to the catalog in the default directory.  This\n        directory should always be writable.\n    \"\"\"\n    def __init__(self,user_path_list=None):\n        \"\"\" Create a catalog for storing/searching for compiled functions.\n\n            user_path_list contains directories that should be searched\n            first for function catalogs.  They will come before the path\n            entries in the PYTHONCOMPILED environment varilable.\n        \"\"\"\n        if isinstance(user_path_list, str):\n            self.user_path_list = [user_path_list]\n        elif user_path_list:\n            self.user_path_list = user_path_list\n        else:\n            self.user_path_list = []\n        self.cache = {}\n        self.module_dir = None\n        self.paths_added = 0\n        # unconditionally append the default dir for auto-generated compiled\n        # extension modules, so that pickle.load()s don't fail.\n        sys.path.append(default_dir())\n\n    def set_module_directory(self,module_dir):\n        \"\"\" Set the path that will replace 'MODULE' in catalog searches.\n\n            You should call clear_module_directory() when your finished\n            working with it.\n        \"\"\"\n        self.module_dir = module_dir\n    def get_module_directory(self):\n        \"\"\" Return the path used to replace the 'MODULE' in searches.\n        \"\"\"\n        return self.module_dir\n    def clear_module_directory(self):\n        \"\"\" Reset 'MODULE' path to None so that it is ignored in searches.\n        \"\"\"\n        self.module_dir = None\n\n    def get_environ_path(self):\n        \"\"\" Return list of paths from 'PYTHONCOMPILED' environment variable.\n\n            On Unix the path in PYTHONCOMPILED is a ':' separated list of\n            directories.  On Windows, a ';' separated list is used.\n        \"\"\"\n        paths = []\n        if 'PYTHONCOMPILED' in os.environ:\n            path_string = os.environ['PYTHONCOMPILED']\n            paths = path_string.split(os.path.pathsep)\n        return paths\n\n    def build_search_order(self):\n        \"\"\" Returns a list of paths that are searched for catalogs.\n\n            Values specified in the catalog constructor are searched first,\n            then values found in the PYTHONCOMPILED environment variable.\n            The directory returned by default_dir() is always returned at\n            the end of the list.\n\n            There is a 'magic' path name called 'MODULE' that is replaced\n            by the directory defined by set_module_directory().  If the\n            module directory hasn't been set, 'MODULE' is ignored.\n        \"\"\"\n\n        paths = self.user_path_list + self.get_environ_path()\n        search_order = []\n        for path in paths:\n            if path == 'MODULE':\n                if self.module_dir:\n                    search_order.append(self.module_dir)\n            else:\n                search_order.append(path)\n        search_order.append(default_dir())\n        return search_order\n\n    def get_catalog_files(self):\n        \"\"\" Returns catalog file list in correct search order.\n\n            Some of the catalog files may not currently exists.\n            However, all will be valid locations for a catalog\n            to be created (if you have write permission).\n        \"\"\"\n        files = map(catalog_path,self.build_search_order())\n        files = filter(lambda x: x is not None,files)\n        return files\n\n    def get_existing_files(self):\n        \"\"\" Returns all existing catalog file list in correct search order.\n        \"\"\"\n        files = self.get_catalog_files()\n        # open every stinking file to check if it exists.\n        # This is because anydbm doesn't provide a consistent naming\n        # convention across platforms for its files\n        existing_files = []\n        for file in files:\n            cat = get_catalog(os.path.dirname(file),'r')\n            if cat is not None:\n                existing_files.append(file)\n                cat.close()\n        # This is the non-portable (and much faster) old code\n        #existing_files = filter(os.path.exists,files)\n        return existing_files\n\n    def get_writable_file(self,existing_only=0):\n        \"\"\" Return the name of the first writable catalog file.\n\n            Its parent directory must also be writable.  This is so that\n            compiled modules can be written to the same directory.\n        \"\"\"\n        # note: both file and its parent directory must be writeable\n        if existing_only:\n            files = self.get_existing_files()\n        else:\n            files = self.get_catalog_files()\n        # filter for (file exists and is writable) OR directory is writable\n        def file_test(x):\n            from os import access, F_OK, W_OK\n            return (access(x,F_OK) and access(x,W_OK) or\n                    access(os.path.dirname(x),W_OK))\n        writable = filter(file_test,files)\n        if writable:\n            file = writable[0]\n        else:\n            file = None\n        return file\n\n    def get_writable_dir(self):\n        \"\"\" Return the parent directory of first writable catalog file.\n\n            The returned directory has write access.\n        \"\"\"\n        return os.path.dirname(self.get_writable_file())\n\n    def unique_module_name(self,code,module_dir=None):\n        \"\"\" Return full path to unique file name that in writable location.\n\n            The directory for the file is the first writable directory in\n            the catalog search path.  The unique file name is derived from\n            the code fragment.  If, module_dir is specified, it is used\n            to replace 'MODULE' in the search path.\n        \"\"\"\n        if module_dir is not None:\n            self.set_module_directory(module_dir)\n        try:\n            d = self.get_writable_dir()\n        finally:\n            if module_dir is not None:\n                self.clear_module_directory()\n        return unique_file(d, code)\n\n    def path_key(self,code):\n        \"\"\" Return key for path information for functions associated with code.\n        \"\"\"\n        return '__path__' + code\n\n    def configure_path(self,cat,code):\n        \"\"\" Add the python path for the given code to the sys.path\n\n            unconfigure_path() should be called as soon as possible after\n            imports associated with code are finished so that sys.path\n            is restored to normal.\n        \"\"\"\n        try:\n            paths = cat[self.path_key(code)]\n            self.paths_added = len(paths)\n            sys.path = paths + sys.path\n        except:\n            self.paths_added = 0\n\n    def unconfigure_path(self):\n        \"\"\" Restores sys.path to normal after calls to configure_path()\n\n            Remove the previously added paths from sys.path\n        \"\"\"\n        sys.path = sys.path[self.paths_added:]\n        self.paths_added = 0\n\n    def get_cataloged_functions(self,code):\n        \"\"\" Load all functions associated with code from catalog search path.\n\n            Sometimes there can be trouble loading a function listed in a\n            catalog file because the actual module that holds the function\n            has been moved or deleted.  When this happens, that catalog file\n            is \"repaired\", meaning the entire entry for this function is\n            removed from the file.  This only affects the catalog file that\n            has problems -- not the others in the search path.\n\n            The \"repair\" behavior may not be needed, but I'll keep it for now.\n        \"\"\"\n        mode = 'r'\n        cat = None\n        function_list = []\n        for path in self.build_search_order():\n            cat = get_catalog(path,mode)\n            if cat is not None and code in cat:\n                # set up the python path so that modules for this\n                # function can be loaded.\n                self.configure_path(cat,code)\n                try:\n                    function_list += cat[code]\n                except: #SystemError and ImportError so far seen\n                    # problems loading a function from the catalog.  Try to\n                    # repair the cause.\n                    cat.close()\n                    self.repair_catalog(path,code)\n                self.unconfigure_path()\n            if cat is not None:\n                # ensure that the catalog is properly closed\n                cat.close()\n        return function_list\n\n\n    def repair_catalog(self,catalog_path,code):\n        \"\"\" Remove entry for code from catalog_path\n\n            Occasionally catalog entries could get corrupted. An example\n            would be when a module that had functions in the catalog was\n            deleted or moved on the disk.  The best current repair method is\n            just to trash the entire catalog entry for this piece of code.\n            This may loose function entries that are valid, but thats life.\n\n            catalog_path must be writable for repair.  If it isn't, the\n            function exists with a warning.\n        \"\"\"\n        writable_cat = None\n        if (catalog_path is not None) and (not os.path.exists(catalog_path)):\n            return\n        try:\n            writable_cat = get_catalog(catalog_path,'w')\n        except:\n            print('warning: unable to repair catalog entry\\n %s\\n in\\n %s' % \\\n                  (code,catalog_path))\n            # shelve doesn't guarantee flushing, so it's safest to explicitly\n            # close the catalog\n            writable_cat.close()\n            return\n        if code in writable_cat:\n            print('repairing catalog by removing key')\n            del writable_cat[code]\n\n        # it is possible that the path key doesn't exist (if the function\n        # registered was a built-in function), so we have to check if the path\n        # exists before arbitrarily deleting it.\n        path_key = self.path_key(code)\n        if path_key in writable_cat:\n            del writable_cat[path_key]\n        writable_cat.close()\n\n    def get_functions_fast(self,code):\n        \"\"\" Return list of functions for code from the cache.\n\n            Return an empty list if the code entry is not found.\n        \"\"\"\n        return self.cache.get(code,[])\n\n    def get_functions(self,code,module_dir=None):\n        \"\"\" Return the list of functions associated with this code fragment.\n\n            The cache is first searched for the function.  If an entry\n            in the cache is not found, then catalog files on disk are\n            searched for the entry.  This is slooooow, but only happens\n            once per code object.  All the functions found in catalog files\n            on a cache miss are loaded into the cache to speed up future calls.\n            The search order is as follows:\n\n                1. user specified path (from catalog initialization)\n                2. directories from the PYTHONCOMPILED environment variable\n                3. The temporary directory on your platform.\n\n            The path specified by module_dir will replace the 'MODULE'\n            place holder in the catalog search path. See build_search_order()\n            for more info on the search path.\n        \"\"\"\n        # Fast!! try cache first.\n        if code in self.cache:\n            return self.cache[code]\n\n        # 2. Slow!! read previously compiled functions from disk.\n        try:\n            self.set_module_directory(module_dir)\n            function_list = self.get_cataloged_functions(code)\n            # put function_list in cache to save future lookups.\n            if function_list:\n                self.cache[code] = function_list\n            # return function_list, empty or otherwise.\n        finally:\n            self.clear_module_directory()\n        return function_list\n\n    def add_function(self,code,function,module_dir=None):\n        \"\"\" Adds a function to the catalog.\n\n            The function is added to the cache as well as the first\n            writable file catalog found in the search path.  If no\n            code entry exists in the cache, the on disk catalogs\n            are loaded into the cache and function is added to the\n            beginning of the function list.\n\n            The path specified by module_dir will replace the 'MODULE'\n            place holder in the catalog search path. See build_search_order()\n            for more info on the search path.\n        \"\"\"\n\n        # 1. put it in the cache.\n        if code in self.cache:\n            if function not in self.cache[code]:\n                self.cache[code].insert(0,function)\n            else:\n                # if it is in the cache, then it is also\n                # been persisted\n                return\n        else:\n            # Load functions and put this one up front\n            self.cache[code] = self.get_functions(code)\n            self.fast_cache(code,function)\n        # 2. Store the function entry to disk.\n        try:\n            self.set_module_directory(module_dir)\n            self.add_function_persistent(code,function)\n        finally:\n            self.clear_module_directory()\n\n    def add_function_persistent(self,code,function):\n        \"\"\" Store the code->function relationship to disk.\n\n            Two pieces of information are needed for loading functions\n            from disk -- the function pickle (which conveniently stores\n            the module name, etc.) and the path to its module's directory.\n            The latter is needed so that the function can be loaded no\n            matter what the user's Python path is.\n        \"\"\"\n        # add function to data in first writable catalog\n        mode = 'c' # create if doesn't exist, otherwise, use existing\n        cat_dir = self.get_writable_dir()\n        cat = get_catalog(cat_dir,mode)\n        if cat is None:\n            cat_dir = default_dir()\n            cat = get_catalog(cat_dir,mode)\n        if cat is None:\n            cat_dir = default_dir()\n            cat_file = catalog_path(cat_dir)\n            print('problems with default catalog -- removing')\n            import glob\n            files = glob.glob(cat_file+'*')\n            for f in files:\n                os.remove(f)\n            cat = get_catalog(cat_dir,mode)\n        if cat is None:\n            raise ValueError('Failed to access a catalog for storing functions')\n        # Prabhu was getting some corrupt catalog errors.  I'll put a try/except\n        # to protect against this, but should really try and track down the issue.\n        function_list = [function]\n        try:\n            function_list = function_list + cat.get(code,[])\n        except pickle.UnpicklingError:\n            pass\n        cat[code] = function_list\n        # now add needed path information for loading function\n        module = getmodule(function)\n        try:\n            # built in modules don't have the __file__ extension, so this\n            # will fail.  Just pass in this case since path additions aren't\n            # needed for built-in modules.\n            mod_path,f=os.path.split(os.path.abspath(module.__file__))\n            pkey = self.path_key(code)\n            cat[pkey] = [mod_path] + cat.get(pkey,[])\n        except:\n            pass\n        cat.close()\n\n    def fast_cache(self,code,function):\n        \"\"\" Move function to the front of the cache entry for code\n\n            If future calls to the function have the same type signature,\n            this will speed up access significantly because the first\n            function call is correct.\n\n            Note:  The cache added to the inline_tools module is significantly\n                   faster than always calling get_functions, so this isn't\n                   as necessary as it used to be.  Still, it's probably worth\n                   doing.\n        \"\"\"\n        try:\n            if self.cache[code][0] == function:\n                return\n        except: # KeyError, IndexError\n            pass\n        try:\n            self.cache[code].remove(function)\n        except ValueError:\n            pass\n        # put new function at the beginning of the list to search.\n        self.cache[code].insert(0,function)\n", "from __future__ import absolute_import, print_function\n\nimport sys\nimport os\nimport stat\nimport tempfile\n\nfrom distutils.dir_util import remove_tree\n\nfrom numpy.testing import TestCase, assert_\nfrom numpy.testing.noseclasses import KnownFailureTest\n\nfrom scipy.weave import catalog\nfrom weave_test_utils import clear_temp_catalog, restore_temp_catalog, \\\n        empty_temp_dir, cleanup_temp_dir\n\n\nclass TestIntermediateDir(TestCase):\n    \"\"\"\n    Tests for intermediate dir (store of .cpp and .o during builds).\n    These tests test whether intermediate dir is safe. If it's not,\n    new one should be created.\n    \"\"\"\n    def dirs_are_valid(self, wrong_dir, tmpdir):\n        \"\"\" test if new dir is created and is consistent \"\"\"\n        new_im_dir = catalog.intermediate_dir(tmpdir)\n        assert_(not os.path.samefile(new_im_dir, wrong_dir))\n        new_im_dir2 = catalog.intermediate_dir(tmpdir)\n        assert_(os.path.samefile(new_im_dir, new_im_dir2))\n\n    def test_ownership(self):\n        \"\"\" test if intermediate dir is owned by correct user \"\"\"\n        if sys.platform != 'win32':\n            im_dir = catalog.intermediate_dir()\n            im_dir_stat = os.stat(im_dir)\n            proc_uid = os.getuid()\n            assert_(proc_uid == im_dir_stat.st_uid)\n            r_im_dir_stat = os.stat(os.path.dirname(im_dir))\n            assert_(proc_uid == r_im_dir_stat.st_uid)\n\n    def test_incorrect_ownership(self):\n        \"\"\"\n        test if new intermediate dir is created when there is only one\n        im dir owned by improper user\n        \"\"\"\n        if sys.platform != 'win32':\n            import pwd\n            tmpdir = tempfile.mkdtemp()\n            try:\n                im_dir = catalog.create_intermediate_dir(tmpdir)\n                root_im_dir = os.path.dirname(im_dir)\n                nobody = pwd.getpwnam('nobody')[2]\n                nobody_g = pwd.getpwnam('nobody')[3]\n                try:\n                    os.chown(root_im_dir, nobody, nobody_g)\n                except OSError:\n                    raise KnownFailureTest(\"Can't change owner.\")\n                else:\n                    self.dirs_are_valid(im_dir, tmpdir)\n            finally:\n                remove_tree(tmpdir)\n\n    def test_permissions(self):\n        \"\"\" im dir should have permissions 0700 \"\"\"\n        if sys.platform != 'win32':\n            im_dir = catalog.intermediate_dir()\n            im_dir_stat = os.stat(im_dir)\n            assert_(stat.S_IMODE(im_dir_stat.st_mode) == 0o0700)\n            r_im_dir_stat = os.stat(os.path.dirname(im_dir))\n            assert_(stat.S_IMODE(r_im_dir_stat.st_mode) == 0o0700)\n\n    def test_incorrect_permissions(self):\n        \"\"\"\n        if permissions on existing im dir are not correct,\n        new one should be created\n        \"\"\"\n        if sys.platform != 'win32':\n            tmpdir = tempfile.mkdtemp()\n            try:\n                im_dir = catalog.create_intermediate_dir(tmpdir)\n                root_im_dir = os.path.dirname(im_dir)\n                try:\n                    os.chmod(root_im_dir, 0o777)\n                except OSError:\n                    raise KnownFailureTest(\"Can't set file permissions.\")\n                else:\n                    self.dirs_are_valid(im_dir, tmpdir)\n            finally:\n                remove_tree(tmpdir)\n\n    def test_symlink(self):\n        \"\"\" im dir shouldn't be a symlink \"\"\"\n        if sys.platform != 'win32':\n            r_im_dir = os.path.dirname(catalog.intermediate_dir())\n            assert_(os.path.islink(r_im_dir) is False)\n\n    def test_symlink_raise(self):\n        \"\"\" if existing im dir is a symlink, new one should be created \"\"\"\n        if sys.platform != 'win32':\n            tmpdir = tempfile.mkdtemp()\n            try:\n                im_dir = catalog.create_intermediate_dir(tmpdir)\n                root_im_dir = os.path.dirname(im_dir)\n\n                tempdir = tempfile.mkdtemp(prefix='scipy-test', dir=tmpdir)\n                try:\n                    os.rename(root_im_dir, tempdir)\n                except OSError:\n                    raise KnownFailureTest(\"Can't move intermediate dir.\")\n\n                try:\n                    os.symlink(tempdir, root_im_dir)\n                except OSError:\n                    raise KnownFailureTest(\n                        \"Can't create symlink to intermediate dir.\")\n                else:\n                    self.dirs_are_valid(im_dir, tmpdir)\n            finally:\n                remove_tree(tmpdir)\n\n\nclass TestDefaultDir(TestCase):\n    \"\"\"\n    Tests for 'catalog.default_dir()'.\n    These should verified posix and win default_dir function.\n    \"\"\"\n    def test_win(self):\n        \"\"\"\n        test if default_dir for Windows platform is accessible\n\n        since default_dir_win() does not have any Windows specific code,\n        let's test it everywhere\n        \"\"\"\n        d = catalog.default_dir_win()\n        assert_(catalog.is_writable(d))\n\n    def test_win_inaccessible_root(self):\n        \"\"\"\n        there should be a new root dir created if existing one is not accessible\n        \"\"\"\n        tmpdir = tempfile.mkdtemp()\n        try:\n            d_dir = catalog.default_dir_win(tmpdir)\n            root_ddir = os.path.dirname(d_dir)\n\n            try:\n                os.chmod(root_ddir, stat.S_IREAD | stat.S_IEXEC)\n            except OSError:\n                raise KnownFailureTest(\"Can't change permissions of root default_dir.\")\n\n            new_ddir = catalog.default_dir_win(tmpdir)\n            assert_(not os.path.samefile(new_ddir, d_dir))\n            new_ddir2 = catalog.default_dir_win(tmpdir)\n            assert_(os.path.samefile(new_ddir, new_ddir2))\n        finally:\n            os.chmod(root_ddir, 0o700)\n            remove_tree(tmpdir)\n\n    def test_win_inaccessible_ddir(self):\n        \"\"\"\n        create new defualt_dir if current one is not accessible\n        \"\"\"\n        tmpdir = tempfile.mkdtemp()\n        try:\n            d_dir = catalog.default_dir_win(tmpdir)\n\n            try:\n                os.chmod(d_dir, stat.S_IREAD | stat.S_IEXEC)\n            except OSError:\n                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n\n            new_ddir = catalog.default_dir_win(tmpdir)\n            assert_(not os.path.samefile(new_ddir, d_dir))\n            new_ddir2 = catalog.default_dir_win(tmpdir)\n            assert_(os.path.samefile(new_ddir, new_ddir2))\n        finally:\n            os.chmod(d_dir, 0o700)\n            remove_tree(tmpdir)\n\n    def test_posix(self):\n        \"\"\" test if posix default_dir is writable \"\"\"\n        d = catalog.default_dir_posix()\n        assert_(catalog.is_writable(d))\n\n    def test_posix_home_inaccessible(self):\n        \"\"\" what happens when home catalog dir is innaccessible \"\"\"\n        tmpdir = tempfile.mkdtemp()\n        try:\n            d_dir = catalog.default_dir_posix(tmpdir)\n\n            try:\n                os.chmod(d_dir, 0o000)\n            except OSError:\n                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n\n            new_ddir = catalog.default_dir_posix(tmpdir)\n            assert_(not os.path.samefile(new_ddir, d_dir))\n            new_ddir2 = catalog.default_dir_posix(tmpdir)\n            assert_(os.path.samefile(new_ddir, new_ddir2))\n        finally:\n            os.chmod(d_dir, 0o700)\n            remove_tree(tmpdir)\n\n    def test_posix_dirs_inaccessible(self):\n        \"\"\" test if new dir is created if both implicit dirs are not valid\"\"\"\n        tmpdir = tempfile.mkdtemp()\n        try:\n            d_dir = catalog.default_dir_posix(tmpdir)\n\n            try:\n                os.chmod(d_dir, 0o000)\n            except OSError:\n                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n\n            d_dir2 = catalog.default_dir_posix(tmpdir)\n\n            try:\n                os.chmod(d_dir2, 0o000)\n            except OSError:\n                raise KnownFailureTest(\"Can't change permissions of default_dir.\")\n\n            new_ddir = catalog.default_dir_posix(tmpdir)\n            assert_(not (os.path.samefile(new_ddir, d_dir) or os.path.samefile(new_ddir, d_dir2)))\n            new_ddir2 = catalog.default_dir_posix(tmpdir)\n            assert_(os.path.samefile(new_ddir, new_ddir2))\n        finally:\n            os.chmod(d_dir, 0o700)\n            os.chmod(d_dir2, 0o700)\n            remove_tree(tmpdir)\n\n    def test_is_writable(self):\n        \"\"\" default_dir has to be writable \"\"\"\n        path = catalog.default_dir()\n        name = os.path.join(path,'dummy_catalog')\n        test_file = open(name,'w')\n        try:\n            test_file.write('making sure default location is writable\\n')\n        finally:\n            test_file.close()\n            os.remove(name)\n\n\nclass TestOsDependentCatalogName(TestCase):\n    pass\n\n\nclass TestCatalogPath(TestCase):\n\n    def test_default(self):\n        in_path = catalog.default_dir()\n        path = catalog.catalog_path(in_path)\n        d,f = os.path.split(path)\n        assert_(d == in_path)\n        assert_(f == catalog.os_dependent_catalog_name())\n\n    def test_current(self):\n        in_path = '.'\n        path = catalog.catalog_path(in_path)\n        d,f = os.path.split(path)\n        assert_(d == os.path.abspath(in_path))\n        assert_(f == catalog.os_dependent_catalog_name())\n\n    def test_user(path):\n        if sys.platform != 'win32':\n            in_path = '~'\n            path = catalog.catalog_path(in_path)\n            d,f = os.path.split(path)\n            assert_(d == os.path.expanduser(in_path))\n            assert_(f == catalog.os_dependent_catalog_name())\n\n    def test_module(self):\n        # hand it a module and see if it uses the parent directory\n        # of the module.\n        path = catalog.catalog_path(os.__file__)\n        d,f = os.path.split(os.__file__)\n        d2,f = os.path.split(path)\n        assert_(d2 == d)\n\n    def test_path(self):\n        # use os.__file__ to get a usable directory.\n        in_path,f = os.path.split(os.__file__)\n        path = catalog.catalog_path(in_path)\n        d,f = os.path.split(path)\n        assert_(d == in_path)\n\n    def test_bad_path(self):\n        # stupid_path_name\n        in_path = 'stupid_path_name'\n        path = catalog.catalog_path(in_path)\n        assert_(path is None)\n\n\nclass TestGetCatalog(TestCase):\n    \"\"\" This only tests whether new catalogs are created correctly.\n        And whether non-existent return None correctly with read mode.\n        Putting catalogs in the right place is all tested with\n        catalog_dir tests.\n    \"\"\"\n\n    def get_test_dir(self,erase = 0):\n        # make sure tempdir catalog doesn't exist\n        import tempfile, glob\n        #temp = tempfile.gettempdir()\n        pardir = tempfile.mktemp(suffix='cat_test')\n        if not os.path.exists(pardir):\n            os.mkdir(pardir)\n        cat_glob = os.path.join(pardir,catalog.os_dependent_catalog_name()+'.*')\n        cat_files = glob.glob(cat_glob)\n        if erase:\n            for cat_file in cat_files:\n                os.remove(cat_file)\n        return pardir\n\n    def test_nonexistent_catalog_is_none(self):\n        pardir = self.get_test_dir(erase=1)\n        cat = catalog.get_catalog(pardir,'r')\n        remove_tree(pardir)\n        assert_(cat is None)\n\n    def test_create_catalog(self):\n        pardir = self.get_test_dir(erase=1)\n        cat = catalog.get_catalog(pardir,'c')\n        assert_(cat is not None)\n        cat.close()\n        remove_tree(pardir)\n\n\nclass TestCatalog(TestCase):\n\n    def clear_environ(self):\n        if 'PYTHONCOMPILED' in os.environ:\n            self.old_PYTHONCOMPILED = os.environ['PYTHONCOMPILED']\n            del os.environ['PYTHONCOMPILED']\n        else:\n            self.old_PYTHONCOMPILED = None\n\n    def reset_environ(self):\n        if self.old_PYTHONCOMPILED:\n            os.environ['PYTHONCOMPILED'] = self.old_PYTHONCOMPILED\n            self.old_PYTHONCOMPILED = None\n\n    def setUp(self):\n        self.clear_environ()\n\n    def tearDown(self):\n        self.reset_environ()\n\n    def test_set_module_directory(self):\n        q = catalog.catalog()\n        q.set_module_directory('bob')\n        r = q.get_module_directory()\n        assert_(r == 'bob')\n\n    def test_clear_module_directory(self):\n        q = catalog.catalog()\n        r = q.get_module_directory()\n        assert_(r is None)\n        q.set_module_directory('bob')\n        r = q.clear_module_directory()\n        assert_(r is None)\n\n    def test_get_environ_path(self):\n        if sys.platform == 'win32': sep = ';'\n        else: sep = ':'\n        os.environ['PYTHONCOMPILED'] = sep.join(('path1','path2','path3'))\n        q = catalog.catalog()\n        path = q.get_environ_path()\n        assert_(path == ['path1','path2','path3'])\n\n    def test_build_search_order1(self):\n        \"\"\" MODULE in search path should be replaced by module_dir.\n        \"\"\"\n        q = catalog.catalog(['first','MODULE','third'])\n        q.set_module_directory('second')\n        order = q.build_search_order()\n        assert_(order == ['first','second','third',catalog.default_dir()])\n\n    def test_build_search_order2(self):\n        \"\"\" MODULE in search path should be removed if module_dir==None.\n        \"\"\"\n        q = catalog.catalog(['first','MODULE','third'])\n        order = q.build_search_order()\n        assert_(order == ['first','third',catalog.default_dir()])\n\n    def test_build_search_order3(self):\n        \"\"\" If MODULE is absent, module_dir shouldn't be in search path.\n        \"\"\"\n        q = catalog.catalog(['first','second'])\n        q.set_module_directory('third')\n        order = q.build_search_order()\n        assert_(order == ['first','second',catalog.default_dir()])\n\n    def test_build_search_order4(self):\n        \"\"\" Make sure environment variable is getting used.\n        \"\"\"\n        q = catalog.catalog(['first','second'])\n        if sys.platform == 'win32':\n            sep = ';'\n        else:\n            sep = ':'\n        os.environ['PYTHONCOMPILED'] = sep.join(('MODULE','fourth','fifth'))\n        q.set_module_directory('third')\n        order = q.build_search_order()\n        assert_(order == ['first','second','third','fourth','fifth',catalog.default_dir()])\n\n    def test_catalog_files1(self):\n        \"\"\" Be sure we get at least one file even without specifying the path.\n        \"\"\"\n        q = catalog.catalog()\n        files = q.get_catalog_files()\n        assert_(len(files) == 1)\n\n    def test_catalog_files2(self):\n        \"\"\" Ignore bad paths in the path.\n        \"\"\"\n        q = catalog.catalog()\n        os.environ['PYTHONCOMPILED'] = '_some_bad_path_'\n        files = q.get_catalog_files()\n        assert_(len(files) == 1)\n\n    def test_get_existing_files1(self):\n        \"\"\" Shouldn't get any files when temp doesn't exist and no path set.\n        \"\"\"\n        clear_temp_catalog()\n        q = catalog.catalog()\n        files = q.get_existing_files()\n        restore_temp_catalog()\n        assert_(len(files) == 0)\n\n    def test_get_existing_files2(self):\n        \"\"\" Shouldn't get a single file from the temp dir.\n        \"\"\"\n        clear_temp_catalog()\n        q = catalog.catalog()\n        # create a dummy file\n        import os\n        q.add_function('code', os.getpid)\n        del q\n        q = catalog.catalog()\n        files = q.get_existing_files()\n        restore_temp_catalog()\n        assert_(len(files) == 1)\n\n    def test_access_writable_file(self):\n        \"\"\" There should always be a writable file -- even if it is in temp\n        \"\"\"\n        q = catalog.catalog()\n        file = q.get_writable_file()\n        try:\n            f = open(file,'w')\n            f.write('bob')\n        finally:\n            f.close()\n            os.remove(file)\n\n    def test_writable_with_bad_path(self):\n        \"\"\" There should always be a writable file -- even if search paths contain\n            bad values.\n        \"\"\"\n        if sys.platform == 'win32':\n            sep = ';'\n        else:\n            sep = ':'\n        os.environ['PYTHONCOMPILED'] = sep.join(('_bad_path_name_'))\n        q = catalog.catalog()\n        file = q.get_writable_file()\n        try:\n            f = open(file,'w')\n            f.write('bob')\n        finally:\n            f.close()\n        os.remove(file)\n\n    def test_writable_dir(self):\n        \"\"\" Check that we can create a file in the writable directory\n        \"\"\"\n        q = catalog.catalog()\n        d = q.get_writable_dir()\n        file = os.path.join(d,'some_silly_file')\n        try:\n            f = open(file,'w')\n            f.write('bob')\n        finally:\n            f.close()\n            os.remove(file)\n\n    def test_unique_module_name(self):\n        \"\"\" Check that we can create a file in the writable directory\n        \"\"\"\n        q = catalog.catalog()\n        file = q.unique_module_name('bob')\n        cfile1 = file+'.cpp'\n        assert_(not os.path.exists(cfile1))\n        # Make sure it is writable\n        try:\n            f = open(cfile1,'w')\n            f.write('bob')\n        finally:\n            f.close()\n        # try again with same code fragment -- should get unique name\n        file = q.unique_module_name('bob')\n        cfile2 = file+'.cpp'\n        assert_(not os.path.exists(cfile2+'.cpp'))\n        os.remove(cfile1)\n\n    def test_add_function_persistent1(self):\n        \"\"\" Test persisting a function in the default catalog\n        \"\"\"\n        clear_temp_catalog()\n        q = catalog.catalog()\n        # just use some already available functions\n        import string\n        funcs = [string.upper, string.lower, string.find,string.replace]\n        for i in funcs:\n            q.add_function_persistent('code',i)\n        pfuncs = q.get_cataloged_functions('code')\n        # any way to clean modules???\n        restore_temp_catalog()\n        for i in funcs:\n            assert_(i in pfuncs)\n\n    def test_add_function_ordered(self):\n        clear_temp_catalog()\n        q = catalog.catalog()\n        import string\n\n        q.add_function('f',string.upper)\n        q.add_function('f',string.lower)\n        q.add_function('ff',string.find)\n        q.add_function('ff',string.replace)\n        q.add_function('fff',string.atof)\n        q.add_function('fff',string.atoi)\n        del q\n\n        # now we're gonna make a new catalog with same code\n        # but different functions in a specified module directory\n        env_dir = empty_temp_dir()\n        r = catalog.catalog(env_dir)\n        r.add_function('ff',os.abort)\n        r.add_function('ff',os.chdir)\n        r.add_function('fff',os.access)\n        r.add_function('fff',os.open)\n        del r\n        # now we're gonna make a new catalog with same code\n        # but different functions in a user specified directory\n        user_dir = empty_temp_dir()\n        s = catalog.catalog(user_dir)\n        import re\n        s.add_function('fff',re.match)\n        s.add_function('fff',re.purge)\n        del s\n\n        # open new catalog and make sure it retreives the functions\n        # from d catalog instead of the temp catalog (made by q)\n        os.environ['PYTHONCOMPILED'] = env_dir\n        t = catalog.catalog(user_dir)\n        funcs1 = t.get_functions('f')\n        funcs2 = t.get_functions('ff')\n        funcs3 = t.get_functions('fff')\n        restore_temp_catalog()\n        # make sure everything is read back in the correct order\n        # a little cheating... I'm ignoring any functions that might have\n        # been read in from a prior catalog file (such as the defualt one).\n        # the test should really be made so that these aren't read in, but\n        # until I get this figured out...\n        #assert_(funcs1 == [string.lower,string.upper])\n        #assert_(funcs2 == [os.chdir,os.abort,string.replace,string.find])\n        #assert_(funcs3 == [re.purge,re.match,os.open,\n        #                  os.access,string.atoi,string.atof])\n        assert_(funcs1[:2] == [string.lower,string.upper]),repr(funcs1)\n        assert_(funcs2[:4] == [os.chdir,os.abort,string.replace,string.find])\n        assert_(funcs3[:6] == [re.purge,re.match,os.open,\n                          os.access,string.atoi,string.atof])\n        cleanup_temp_dir(user_dir)\n        cleanup_temp_dir(env_dir)\n\n\nif __name__ == '__main__':\n    import nose\n    nose.run(argv=['', __file__])\n"], "filenames": ["scipy/weave/catalog.py", "scipy/weave/tests/test_catalog.py"], "buggy_code_start_loc": [36, 4], "buggy_code_end_loc": [222, 112], "fixing_code_start_loc": [37, 5], "fixing_code_end_loc": [395, 326], "type": "CWE-269", "message": "The scipy.weave component in SciPy before 0.12.1 creates insecure temporary directories.", "other": {"cve": {"id": "CVE-2013-4251", "sourceIdentifier": "secalert@redhat.com", "published": "2019-11-04T20:15:09.887", "lastModified": "2019-11-08T18:51:23.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The scipy.weave component in SciPy before 0.12.1 creates insecure temporary directories."}, {"lang": "es", "value": "El componente scipy.weave en SciPy versiones anteriores a 0.12.1, crea directorios temporales no seguros."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scipy:scipy:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.1", "matchCriteriaId": "7C603C56-98E4-4794-A6E7-1193C21A3B88"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-November/120696.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-October/119759.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-October/119771.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/63008", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/security/cve/cve-2013-4251", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-4251", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=CVE-2013-4251", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/88052", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/scipy/scipy/commit/bd296e0336420b840fcd2faabb97084fd252a973", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2013-4251", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/scipy/scipy/commit/bd296e0336420b840fcd2faabb97084fd252a973"}}