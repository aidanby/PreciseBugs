{"buggy_code": ["<?php namespace October\\Rain\\Exception;\n\n/**\n * This class represents a critical system exception.\n * System exceptions are logged in the error log.\n *\n * @package october\\exception\n * @author Alexey Bobkov, Samuel Georges\n */\nclass SystemException extends ExceptionBase\n{\n}\n", "<?php namespace October\\Rain\\Filesystem;\n\nuse Config;\nuse Exception;\n\n/**\n * File definitions helper.\n * Contains file extensions for common use cases.\n *\n * @package october\\filesystem\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Definitions\n{\n\n    /**\n     * Entry point to request a definition set.\n     * @param $type string\n     * @return array\n     */\n    public static function get($type)\n    {\n        return (new self)->getDefinitions($type);\n    }\n\n    /**\n     * Returns a definition set from config or from the default sets.\n     * @param $type string\n     * @return array\n     */\n    public function getDefinitions($type)\n    {\n        if (!method_exists($this, $type)) {\n            throw new Exception(sprintf('No such definition set exists for \"%s\"', $type));\n        }\n\n        return (array) Config::get('cms.fileDefinitions.'.$type, $this->$type());\n    }\n\n    /**\n     * Determines if a path should be ignored, sourced from the ignoreFiles\n     * and ignorePatterns definitions.\n     * @todo Efficiency of this method can be improved.\n     * @param string $path Specifies a path to check.\n     * @return boolean Returns TRUE if the path is visible.\n     */\n    public static function isPathIgnored($path)\n    {\n        $ignoreNames = self::get('ignoreFiles');\n        $ignorePatterns = self::get('ignorePatterns');\n\n        if (in_array($path, $ignoreNames)) {\n            return true;\n        }\n\n        foreach ($ignorePatterns as $pattern) {\n            if (preg_match('/'.$pattern.'/', $path)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Files that can be safely ignored.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.ignoreFiles\n     */\n    protected function ignoreFiles()\n    {\n        return [\n            '.svn',\n            '.git',\n            '.DS_Store',\n            '.AppleDouble'\n        ];\n    }\n\n    /**\n     * File patterns that can be safely ignored.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.ignorePatterns\n     */\n    protected function ignorePatterns()\n    {\n        return [\n            '^\\..*'\n        ];\n    }\n\n    /**\n     * Extensions that are particularly benign.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.defaultExtensions\n     */\n    protected function defaultExtensions()\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'svg',\n            'js',\n            'map',\n            'ico',\n            'css',\n            'less',\n            'scss',\n            'ics',\n            'odt',\n            'doc',\n            'docx',\n            'ppt',\n            'pptx',\n            'pdf',\n            'swf',\n            'txt',\n            'xml',\n            'ods',\n            'xls',\n            'xlsx',\n            'eot',\n            'woff',\n            'woff2',\n            'ttf',\n            'flv',\n            'wmv',\n            'mp3',\n            'ogg',\n            'wav',\n            'avi',\n            'mov',\n            'mp4',\n            'mpeg',\n            'webm',\n            'mkv',\n            'rar',\n            'xml',\n            'zip'\n        ];\n    }\n\n    /**\n     * Extensions seen as public assets.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.assetExtensions\n     */\n    protected function assetExtensions()\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'ico',\n            'css',\n            'js',\n            'woff',\n            'woff2',\n            'svg',\n            'ttf',\n            'eot',\n            'json',\n            'md',\n            'less',\n            'sass',\n            'scss',\n            'xml'\n        ];\n    }\n\n    /**\n     * Extensions typically used as images.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.imageExtensions\n     */\n    protected function imageExtensions()\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif'\n        ];\n    }\n\n    /**\n     * Extensions typically used as video files.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.videoExtensions\n     */\n    protected function videoExtensions()\n    {\n        return [\n            'mp4',\n            'avi',\n            'mov',\n            'mpg',\n            'mpeg',\n            'mkv',\n            'webm'\n        ];\n    }\n\n    /**\n     * Extensions typically used as audio files.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.audioExtensions\n     */\n    protected function audioExtensions()\n    {\n        return [\n            'mp3',\n            'wav',\n            'wma',\n            'm4a',\n            'ogg'\n        ];\n    }\n}\n", "<?php namespace October\\Rain\\Halcyon;\n\nuse October\\Rain\\Halcyon\\Datasource\\DatasourceInterface;\nuse October\\Rain\\Halcyon\\Processors\\Processor;\nuse October\\Rain\\Halcyon\\Exception\\MissingFileNameException;\nuse October\\Rain\\Halcyon\\Exception\\InvalidFileNameException;\nuse October\\Rain\\Halcyon\\Exception\\InvalidExtensionException;\nuse BadMethodCallException;\nuse ApplicationException;\n\n/**\n * Query builder\n *\n * @package october\\halcyon\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Builder\n{\n    /**\n     * The datasource instance.\n     *\n     * @var \\October\\Rain\\Halcyon\\Datasource\\DatasourceInterface\n     */\n    protected $datasource;\n\n    /**\n     * The model being queried.\n     *\n     * @var \\October\\Rain\\Halcyon\\Model\n     */\n    protected $model;\n\n    /**\n     * The datasource query post processor instance.\n     *\n     * @var \\October\\Rain\\Halcyon\\Processors\\Processor\n     */\n    protected $processor;\n\n    /**\n     * The columns that should be returned.\n     *\n     * @var array\n     */\n    public $columns;\n\n    /**\n     * Filter the query by these file extensions.\n     *\n     * @var array\n     */\n    public $extensions;\n\n    /**\n     * The directory name which the query is targeting.\n     *\n     * @var string\n     */\n    public $from;\n\n    /**\n     * Query should pluck a single record.\n     *\n     * @var bool\n     */\n    public $selectSingle;\n\n    /**\n     * Match files using the specified pattern.\n     *\n     * @var string\n     */\n    public $fileMatch;\n\n    /**\n     * The orderings for the query.\n     *\n     * @var array\n     */\n    public $orders;\n\n    /**\n     * The maximum number of records to return.\n     *\n     * @var int\n     */\n    public $limit;\n\n    /**\n     * The number of records to skip.\n     *\n     * @var int\n     */\n    public $offset;\n\n    /**\n     * The key that should be used when caching the query.\n     *\n     * @var string\n     */\n    protected $cacheKey;\n\n    /**\n     * The number of minutes to cache the query.\n     *\n     * @var int\n     */\n    protected $cacheMinutes;\n\n    /**\n     * The tags for the query cache.\n     *\n     * @var array\n     */\n    protected $cacheTags;\n\n    /**\n     * The cache driver to be used.\n     *\n     * @var string\n     */\n    protected $cacheDriver;\n\n    /**\n     * Internal variable to specify if the record was loaded from cache.\n     *\n     * @var bool\n     */\n    protected $loadedFromCache = false;\n\n    /**\n     * Create a new query builder instance.\n     *\n     * @param  \\October\\Rain\\Halcyon\\Datasource\\DatasourceInterface  $datasource\n     * @param  \\October\\Rain\\Halcyon\\Processors\\Processor  $processor\n     * @return void\n     */\n    public function __construct(DatasourceInterface $datasource, Processor $processor)\n    {\n        $this->datasource = $datasource;\n        $this->processor = $processor;\n    }\n\n    /**\n     * Switches mode to select a single template by its name.\n     *\n     * @param  string  $fileName\n     * @return $this\n     */\n    public function whereFileName($fileName)\n    {\n        $this->selectSingle = $this->model->getFileNameParts($fileName);\n\n        return $this;\n    }\n\n    /**\n     * Set the directory name which the query is targeting.\n     *\n     * @param  string  $dirName\n     * @return $this\n     */\n    public function from($dirName)\n    {\n        $this->from = $dirName;\n\n        return $this;\n    }\n\n    /**\n     * Set the \"offset\" value of the query.\n     *\n     * @param  int  $value\n     * @return $this\n     */\n    public function offset($value)\n    {\n        $this->offset = max(0, $value);\n\n        return $this;\n    }\n\n    /**\n     * Alias to set the \"offset\" value of the query.\n     *\n     * @param  int  $value\n     * @return \\October\\Rain\\Halcyon\\Builder|static\n     */\n    public function skip($value)\n    {\n        return $this->offset($value);\n    }\n\n    /**\n     * Set the \"limit\" value of the query.\n     *\n     * @param  int  $value\n     * @return $this\n     */\n    public function limit($value)\n    {\n        if ($value >= 0) {\n            $this->limit = $value;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Alias to set the \"limit\" value of the query.\n     *\n     * @param  int  $value\n     * @return \\October\\Rain\\Halcyon\\Builder|static\n     */\n    public function take($value)\n    {\n        return $this->limit($value);\n    }\n\n    /**\n     * Find a single template by its file name.\n     *\n     * @param  string $fileName\n     * @return mixed|static\n     */\n    public function find($fileName)\n    {\n        return $this->whereFileName($fileName)->first();\n    }\n\n    /**\n     * Execute the query and get the first result.\n     *\n     * @return mixed|static\n     */\n    public function first()\n    {\n        return $this->limit(1)->get()->first();\n    }\n\n    /**\n     * Execute the query as a \"select\" statement.\n     *\n     * @param  array  $columns\n     * @return \\October\\Rain\\Halcyon\\Collection|static[]\n     */\n    public function get($columns = ['*'])\n    {\n        if (!is_null($this->cacheMinutes)) {\n            $results = $this->getCached($columns);\n        }\n        else {\n            $results = $this->getFresh($columns);\n        }\n\n        $models = $this->getModels($results ?: []);\n\n        return $this->model->newCollection($models);\n    }\n\n    /**\n     * Get an array with the values of a given column.\n     *\n     * @param  string  $column\n     * @param  string  $key\n     * @return array\n     */\n    public function lists($column, $key = null)\n    {\n        $select = is_null($key) ? [$column] : [$column, $key];\n\n        if (!is_null($this->cacheMinutes)) {\n            $results = $this->getCached($select);\n        }\n        else {\n            $results = $this->getFresh($select);\n        }\n\n        $collection = new Collection($results);\n\n        return $collection->lists($column, $key);\n    }\n\n    /**\n     * Execute the query as a fresh \"select\" statement.\n     *\n     * @param  array  $columns\n     * @return \\October\\Rain\\Halcyon\\Collection|static[]\n     */\n    public function getFresh($columns = ['*'])\n    {\n        if (is_null($this->columns)) {\n            $this->columns = $columns;\n        }\n\n        $processCmd = $this->selectSingle ? 'processSelectOne' : 'processSelect';\n\n        return $this->processor->{$processCmd}($this, $this->runSelect());\n    }\n\n    /**\n     * Run the query as a \"select\" statement against the datasource.\n     *\n     * @return array\n     */\n    protected function runSelect()\n    {\n        if (!is_string($this->from)) {\n            throw new ApplicationException(sprintf(\"The from property is invalid, make sure that %s has a string value for its \\$dirName property (use '' if not using directories)\", get_class($this->model)));\n        }\n\n        if ($this->selectSingle) {\n            list($name, $extension) = $this->selectSingle;\n            return $this->datasource->selectOne($this->from, $name, $extension);\n        }\n\n        return $this->datasource->select($this->from, [\n            'columns' => $this->columns,\n            'extensions' => $this->extensions\n        ]);\n    }\n\n    /**\n     * Set a model instance for the model being queried.\n     *\n     * @param  \\October\\Rain\\Halcyon\\Model  $model\n     * @return $this\n     */\n    public function setModel(Model $model)\n    {\n        $this->model = $model;\n\n        $this->extensions = $this->model->getAllowedExtensions();\n\n        $this->from($this->model->getObjectTypeDirName());\n\n        return $this;\n    }\n\n    /**\n     * Get the compiled file content representation of the query.\n     *\n     * @return string\n     */\n    public function toCompiled()\n    {\n        return $this->processor->processUpdate($this, []);\n    }\n\n    /**\n     * Insert a new record into the datasource.\n     *\n     * @param  array  $values\n     * @return bool\n     */\n    public function insert(array $values)\n    {\n        if (empty($values)) {\n            return true;\n        }\n\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        $result = $this->processor->processInsert($this, $values);\n\n        return $this->datasource->insert(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension,\n            $result\n        );\n    }\n\n    /**\n     * Update a record in the datasource.\n     *\n     * @param  array  $values\n     * @return int\n     */\n    public function update(array $values)\n    {\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        $result = $this->processor->processUpdate($this, $values);\n\n        $oldName = $oldExtension = null;\n\n        if ($this->model->isDirty('fileName')) {\n            list($oldName, $oldExtension) = $this->model->getFileNameParts(\n                $this->model->getOriginal('fileName')\n            );\n        }\n\n        return $this->datasource->update(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension,\n            $result,\n            $oldName,\n            $oldExtension\n        );\n    }\n\n    /**\n     * Delete a record from the database.\n     *\n     * @param  string  $fileName\n     * @return int\n     */\n    public function delete($fileName = null)\n    {\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        return $this->datasource->delete(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension\n        );\n    }\n\n    /**\n     * Returns the last modified time of the object.\n     *\n     * @return int\n     */\n    public function lastModified()\n    {\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        return $this->datasource->lastModified(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension\n        );\n    }\n\n    /**\n     * Get the hydrated models.\n     *\n     * @param  array  $results\n     * @return \\October\\Rain\\Halcyon\\Model[]\n     */\n    public function getModels(array $results)\n    {\n        $datasource = $this->model->getDatasourceName();\n\n        $models = $this->model->hydrate($results, $datasource);\n\n        /*\n         * Flag the models as loaded from cache, then reset the internal property.\n         */\n        if ($this->loadedFromCache) {\n            $models->each(function ($model) {\n                $model->setLoadedFromCache($this->loadedFromCache);\n            });\n\n            $this->loadedFromCache = false;\n        }\n\n        return $models->all();\n    }\n\n    /**\n     * Get the model instance being queried.\n     *\n     * @return \\October\\Rain\\Halcyon\\Model\n     */\n    public function getModel()\n    {\n        return $this->model;\n    }\n\n    //\n    // Validation (Hard)\n    //\n\n    /**\n     * Validate the supplied filename, extension and path.\n     * @param string $fileName\n     */\n    protected function validateFileName($fileName = null)\n    {\n        if ($fileName === null) {\n            $fileName = $this->model->fileName;\n        }\n\n        if (!strlen($fileName)) {\n            throw (new MissingFileNameException)->setModel($this->model);\n        }\n\n        if (!$this->validateFileNamePath($fileName, $this->model->getMaxNesting())) {\n            throw (new InvalidFileNameException)->setInvalidFileName($fileName);\n        }\n\n        $this->validateFileNameExtension($fileName, $this->model->getAllowedExtensions());\n\n        return true;\n    }\n\n    /**\n     * Validates whether a file has an allowed extension.\n     * @param string $fileName Specifies a path to validate\n     * @param array $allowedExtensions A list of allowed file extensions\n     * @return void\n     */\n    protected function validateFileNameExtension($fileName, $allowedExtensions)\n    {\n        $extension = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));\n\n        if (strlen($extension) && !in_array($extension, $allowedExtensions)) {\n            throw (new InvalidExtensionException)\n                ->setInvalidExtension($extension)\n                ->setAllowedExtensions($allowedExtensions)\n            ;\n        }\n    }\n\n    /**\n     * Validates a template path.\n     * Template directory and file names can contain only alphanumeric symbols, dashes and dots.\n     * @param string $filePath Specifies a path to validate\n     * @param integer $maxNesting Specifies the maximum allowed nesting level\n     * @return void\n     */\n    protected function validateFileNamePath($filePath, $maxNesting = 2)\n    {\n        if (strpos($filePath, '..') !== false) {\n            return false;\n        }\n\n        if (strpos($filePath, './') !== false || strpos($filePath, '//') !== false) {\n            return false;\n        }\n\n        $segments = explode('/', $filePath);\n        if ($maxNesting !== null && count($segments) > $maxNesting) {\n            return false;\n        }\n\n        foreach ($segments as $segment) {\n            if (!$this->validateFileNamePattern($segment)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Validates a template file or directory name.\n     * template file names can contain only alphanumeric symbols, dashes, underscores and dots.\n     * @param string $fileName Specifies a path to validate\n     * @return boolean Returns true if the file name is valid. Otherwise returns false.\n     */\n    protected function validateFileNamePattern($fileName)\n    {\n        return preg_match('/^[a-z0-9\\_\\-\\.\\/]+$/i', $fileName) ? true : false;\n    }\n\n    //\n    // Caching\n    //\n\n    /**\n     * Indicate that the query results should be cached.\n     *\n     * @param  \\DateTime|int  $minutes\n     * @param  string  $key\n     * @return $this\n     */\n    public function remember($minutes, $key = null)\n    {\n        list($this->cacheMinutes, $this->cacheKey) = [$minutes, $key];\n\n        return $this;\n    }\n\n    /**\n     * Indicate that the query results should be cached forever.\n     *\n     * @param  string  $key\n     * @return $this\n     */\n    public function rememberForever($key = null)\n    {\n        return $this->remember(-1, $key);\n    }\n\n    /**\n     * Indicate that the results, if cached, should use the given cache tags.\n     *\n     * @param  array|mixed  $cacheTags\n     * @return $this\n     */\n    public function cacheTags($cacheTags)\n    {\n        $this->cacheTags = $cacheTags;\n        return $this;\n    }\n\n    /**\n     * Indicate that the results, if cached, should use the given cache driver.\n     *\n     * @param  string  $cacheDriver\n     * @return $this\n     */\n    public function cacheDriver($cacheDriver)\n    {\n        $this->cacheDriver = $cacheDriver;\n        return $this;\n    }\n\n    /**\n     * Execute the query as a cached \"select\" statement.\n     *\n     * @param  array  $columns\n     * @return array\n     */\n    public function getCached($columns = ['*'])\n    {\n        if (is_null($this->columns)) {\n            $this->columns = $columns;\n        }\n\n        $key = $this->getCacheKey();\n\n        $minutes = $this->cacheMinutes;\n        $cache = $this->getCache();\n        $callback = $this->getCacheCallback($columns);\n        $isNewCache = !$cache->has($key);\n\n        // If the \"minutes\" value is less than zero, we will use that as the indicator\n        // that the value should be remembered values should be stored indefinitely\n        // and if we have minutes we will use the typical remember function here.\n        if ($minutes < 0) {\n            $result = $cache->rememberForever($key, $callback);\n        }\n        else {\n            $result = $cache->remember($key, $minutes, $callback);\n        }\n\n        // If this is an old cache record, we can check if the cache has been busted\n        // by comparing the modification times. If this is the case, forget the\n        // cache and then prompt a recycle of the results.\n        if (!$isNewCache && $this->isCacheBusted($result)) {\n            $cache->forget($key);\n            $isNewCache = true;\n\n            if ($minutes < 0) {\n                $result = $cache->rememberForever($key, $callback);\n            }\n            else {\n                $result = $cache->remember($key, $minutes, $callback);\n            }\n        }\n\n        $this->loadedFromCache = !$isNewCache;\n\n        return $result;\n    }\n\n    /**\n     * Returns true if the cache for the file is busted. This only applies\n     * to single record selection.\n     * @param  array  $result\n     * @return bool\n     */\n    protected function isCacheBusted($result)\n    {\n        if (!$this->selectSingle) {\n            return false;\n        }\n\n        $mtime = $result ? array_get(reset($result), 'mtime') : null;\n\n        list($name, $extension) = $this->selectSingle;\n\n        $currentMtime = $this->datasource->lastModified(\n            $this->from,\n            $name,\n            $extension\n        );\n\n        return $currentMtime != $mtime;\n    }\n\n    /**\n     * Get the cache object with tags assigned, if applicable.\n     *\n     * @return \\Illuminate\\Cache\\CacheManager\n     */\n    protected function getCache()\n    {\n        $cache = $this->model->getCacheManager()->driver($this->cacheDriver);\n\n        return $this->cacheTags ? $cache->tags($this->cacheTags) : $cache;\n    }\n\n    /**\n     * Get a unique cache key for the complete query.\n     *\n     * @return string\n     */\n    public function getCacheKey()\n    {\n        return $this->cacheKey ?: $this->generateCacheKey();\n    }\n\n    /**\n     * Generate the unique cache key for the query.\n     *\n     * @return string\n     */\n    public function generateCacheKey()\n    {\n        $payload = [];\n        $payload[] = $this->selectSingle ? serialize($this->selectSingle) : '*';\n        $payload[] = $this->orders ? serialize($this->orders) : '*';\n        $payload[] = $this->columns ? serialize($this->columns) : '*';\n        $payload[] = $this->fileMatch;\n        $payload[] = $this->limit;\n        $payload[] = $this->offset;\n\n        return $this->from . $this->datasource->makeCacheKey(implode('-', $payload));\n    }\n\n    /**\n     * Get the Closure callback used when caching queries.\n     *\n     * @param  string  $fileName\n     * @return \\Closure\n     */\n    protected function getCacheCallback($columns)\n    {\n        return function () use ($columns) {\n            return $this->processInitCacheData($this->getFresh($columns));\n        };\n    }\n\n    /**\n     * Initialize the cache data of each record.\n     * @param  array  $data\n     * @return array\n     */\n    protected function processInitCacheData($data)\n    {\n        if ($data) {\n            $model = get_class($this->model);\n\n            foreach ($data as &$record) {\n                $model::initCacheItem($record);\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Clears the internal request-level object cache.\n     */\n    public static function clearInternalCache()\n    {\n        if (MemoryCacheManager::isEnabled()) {\n            Model::getCacheManager()->driver()->flushInternalCache();\n        }\n    }\n\n    /**\n     * Handle dynamic method calls into the method.\n     *\n     * @param  string  $method\n     * @param  array   $parameters\n     * @return mixed\n     *\n     * @throws \\BadMethodCallException\n     */\n    public function __call($method, $parameters)\n    {\n        $className = get_class($this);\n\n        throw new BadMethodCallException(\"Call to undefined method {$className}::{$method}()\");\n    }\n}\n"], "fixing_code": ["<?php namespace October\\Rain\\Exception;\n\nuse Exception;\nuse October\\Rain\\Html\\HtmlBuilder;\n\n/**\n * This class represents a critical system exception.\n * System exceptions are logged in the error log.\n *\n * @package october\\exception\n * @author Alexey Bobkov, Samuel Georges, Luke Towers\n */\nclass SystemException extends ExceptionBase\n{\n    /**\n     * Override the constructor to escape all messages to protect against potential XSS\n     * from user provided inputs being included in the exception message\n     *\n     * @param string $message Error message.\n     * @param int $code Error code.\n     * @param Exception $previous Previous exception.\n     */\n    public function __construct($message = \"\", $code = 0, Exception $previous = null)\n    {\n        $message = HtmlBuilder::clean($message);\n\n        parent::__construct($message, $code, $previous);\n    }\n}\n", "<?php namespace October\\Rain\\Filesystem;\n\nuse Config;\nuse Exception;\n\n/**\n * File definitions helper.\n * Contains file extensions for common use cases.\n *\n * @package october\\filesystem\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Definitions\n{\n\n    /**\n     * Entry point to request a definition set.\n     * @param $type string\n     * @return array\n     */\n    public static function get($type)\n    {\n        return (new self)->getDefinitions($type);\n    }\n\n    /**\n     * Returns a definition set from config or from the default sets.\n     * @param $type string\n     * @return array\n     */\n    public function getDefinitions($type)\n    {\n        if (!method_exists($this, $type)) {\n            throw new Exception(sprintf('No such definition set exists for \"%s\"', $type));\n        }\n\n        return (array) Config::get('cms.fileDefinitions.'.$type, $this->$type());\n    }\n\n    /**\n     * Determines if a path should be ignored, sourced from the ignoreFiles\n     * and ignorePatterns definitions.\n     * @todo Efficiency of this method can be improved.\n     * @param string $path Specifies a path to check.\n     * @return boolean Returns TRUE if the path is visible.\n     */\n    public static function isPathIgnored($path)\n    {\n        $ignoreNames = self::get('ignoreFiles');\n        $ignorePatterns = self::get('ignorePatterns');\n\n        if (in_array($path, $ignoreNames)) {\n            return true;\n        }\n\n        foreach ($ignorePatterns as $pattern) {\n            if (preg_match('/'.$pattern.'/', $path)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Files that can be safely ignored.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.ignoreFiles\n     */\n    protected function ignoreFiles()\n    {\n        return [\n            '.svn',\n            '.git',\n            '.DS_Store',\n            '.AppleDouble'\n        ];\n    }\n\n    /**\n     * File patterns that can be safely ignored.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.ignorePatterns\n     */\n    protected function ignorePatterns()\n    {\n        return [\n            '^\\..*'\n        ];\n    }\n\n    /**\n     * Extensions that are particularly benign.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.defaultExtensions\n     */\n    protected function defaultExtensions()\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'js',\n            'map',\n            'ico',\n            'css',\n            'less',\n            'scss',\n            'ics',\n            'odt',\n            'doc',\n            'docx',\n            'ppt',\n            'pptx',\n            'pdf',\n            'swf',\n            'txt',\n            'xml',\n            'ods',\n            'xls',\n            'xlsx',\n            'eot',\n            'woff',\n            'woff2',\n            'ttf',\n            'flv',\n            'wmv',\n            'mp3',\n            'ogg',\n            'wav',\n            'avi',\n            'mov',\n            'mp4',\n            'mpeg',\n            'webm',\n            'mkv',\n            'rar',\n            'xml',\n            'zip'\n        ];\n    }\n\n    /**\n     * Extensions seen as public assets.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.assetExtensions\n     */\n    protected function assetExtensions()\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'ico',\n            'css',\n            'js',\n            'woff',\n            'woff2',\n            'ttf',\n            'eot',\n            'json',\n            'md',\n            'less',\n            'sass',\n            'scss',\n            'xml'\n        ];\n    }\n\n    /**\n     * Extensions typically used as images.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.imageExtensions\n     */\n    protected function imageExtensions()\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif'\n        ];\n    }\n\n    /**\n     * Extensions typically used as video files.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.videoExtensions\n     */\n    protected function videoExtensions()\n    {\n        return [\n            'mp4',\n            'avi',\n            'mov',\n            'mpg',\n            'mpeg',\n            'mkv',\n            'webm'\n        ];\n    }\n\n    /**\n     * Extensions typically used as audio files.\n     * This list can be customized with config:\n     * - cms.fileDefinitions.audioExtensions\n     */\n    protected function audioExtensions()\n    {\n        return [\n            'mp3',\n            'wav',\n            'wma',\n            'm4a',\n            'ogg'\n        ];\n    }\n}\n", "<?php namespace October\\Rain\\Halcyon;\n\nuse October\\Rain\\Halcyon\\Datasource\\DatasourceInterface;\nuse October\\Rain\\Halcyon\\Processors\\Processor;\nuse October\\Rain\\Halcyon\\Exception\\MissingFileNameException;\nuse October\\Rain\\Halcyon\\Exception\\InvalidFileNameException;\nuse October\\Rain\\Halcyon\\Exception\\InvalidExtensionException;\nuse BadMethodCallException;\nuse ApplicationException;\n\n/**\n * Query builder\n *\n * @package october\\halcyon\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Builder\n{\n    /**\n     * The datasource instance.\n     *\n     * @var \\October\\Rain\\Halcyon\\Datasource\\DatasourceInterface\n     */\n    protected $datasource;\n\n    /**\n     * The model being queried.\n     *\n     * @var \\October\\Rain\\Halcyon\\Model\n     */\n    protected $model;\n\n    /**\n     * The datasource query post processor instance.\n     *\n     * @var \\October\\Rain\\Halcyon\\Processors\\Processor\n     */\n    protected $processor;\n\n    /**\n     * The columns that should be returned.\n     *\n     * @var array\n     */\n    public $columns;\n\n    /**\n     * Filter the query by these file extensions.\n     *\n     * @var array\n     */\n    public $extensions;\n\n    /**\n     * The directory name which the query is targeting.\n     *\n     * @var string\n     */\n    public $from;\n\n    /**\n     * Query should pluck a single record.\n     *\n     * @var bool\n     */\n    public $selectSingle;\n\n    /**\n     * Match files using the specified pattern.\n     *\n     * @var string\n     */\n    public $fileMatch;\n\n    /**\n     * The orderings for the query.\n     *\n     * @var array\n     */\n    public $orders;\n\n    /**\n     * The maximum number of records to return.\n     *\n     * @var int\n     */\n    public $limit;\n\n    /**\n     * The number of records to skip.\n     *\n     * @var int\n     */\n    public $offset;\n\n    /**\n     * The key that should be used when caching the query.\n     *\n     * @var string\n     */\n    protected $cacheKey;\n\n    /**\n     * The number of minutes to cache the query.\n     *\n     * @var int\n     */\n    protected $cacheMinutes;\n\n    /**\n     * The tags for the query cache.\n     *\n     * @var array\n     */\n    protected $cacheTags;\n\n    /**\n     * The cache driver to be used.\n     *\n     * @var string\n     */\n    protected $cacheDriver;\n\n    /**\n     * Internal variable to specify if the record was loaded from cache.\n     *\n     * @var bool\n     */\n    protected $loadedFromCache = false;\n\n    /**\n     * Create a new query builder instance.\n     *\n     * @param  \\October\\Rain\\Halcyon\\Datasource\\DatasourceInterface  $datasource\n     * @param  \\October\\Rain\\Halcyon\\Processors\\Processor  $processor\n     * @return void\n     */\n    public function __construct(DatasourceInterface $datasource, Processor $processor)\n    {\n        $this->datasource = $datasource;\n        $this->processor = $processor;\n    }\n\n    /**\n     * Get the compiled file content representation of the query.\n     *\n     * @return string\n     */\n    public function toCompiled()\n    {\n        return $this->processor->processUpdate($this, []);\n    }\n\n    /**\n     * Get an array with the values of a given column.\n     *\n     * @param  string  $column\n     * @param  string  $key\n     * @return array\n     */\n    public function lists($column, $key = null)\n    {\n        $select = is_null($key) ? [$column] : [$column, $key];\n\n        if (!is_null($this->cacheMinutes)) {\n            $results = $this->getCached($select);\n        }\n        else {\n            $results = $this->getFresh($select);\n        }\n\n        $collection = new Collection($results);\n\n        return $collection->lists($column, $key);\n    }\n\n    /**\n     * Set the \"limit\" value of the query.\n     *\n     * @param  int  $value\n     * @return $this\n     */\n    public function limit($value)\n    {\n        if ($value >= 0) {\n            $this->limit = $value;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Alias to set the \"limit\" value of the query.\n     *\n     * @param  int  $value\n     * @return \\October\\Rain\\Halcyon\\Builder|static\n     */\n    public function take($value)\n    {\n        return $this->limit($value);\n    }\n\n    /**\n     * Set the \"offset\" value of the query.\n     *\n     * @param  int  $value\n     * @return $this\n     */\n    public function offset($value)\n    {\n        $this->offset = max(0, $value);\n\n        return $this;\n    }\n\n    /**\n     * Alias to set the \"offset\" value of the query.\n     *\n     * @param  int  $value\n     * @return \\October\\Rain\\Halcyon\\Builder|static\n     */\n    public function skip($value)\n    {\n        return $this->offset($value);\n    }\n\n    /**\n     * Set the directory name which the query is targeting.\n     *\n     * @param  string  $dirName\n     * @return $this\n     */\n    public function from($dirName)\n    {\n        $this->from = $dirName;\n\n        return $this;\n    }\n\n    /**\n     * Find a single template by its file name.\n     *\n     * @param  string $fileName\n     * @return mixed|static\n     */\n    public function find($fileName)\n    {\n        return $this->whereFileName($fileName)->first();\n    }\n\n    /**\n     * Execute the query and get the first result.\n     *\n     * @return mixed|static\n     */\n    public function first()\n    {\n        return $this->limit(1)->get()->first();\n    }\n\n    /**\n     * Switches mode to select a single template by its name.\n     *\n     * @param  string  $fileName\n     * @return $this\n     */\n    public function whereFileName($fileName)\n    {\n        $this->validateFileName($fileName);\n\n        $this->selectSingle = $this->model->getFileNameParts($fileName);\n\n        return $this;\n    }\n\n    /**\n     * Execute the query as a fresh \"select\" statement.\n     *\n     * @param  array  $columns\n     * @return \\October\\Rain\\Halcyon\\Collection|static[]\n     */\n    public function getFresh($columns = ['*'])\n    {\n        if (is_null($this->columns)) {\n            $this->columns = $columns;\n        }\n\n        $processCmd = $this->selectSingle ? 'processSelectOne' : 'processSelect';\n\n        return $this->processor->{$processCmd}($this, $this->runSelect());\n    }\n\n    /**\n     * Run the query as a \"select\" statement against the datasource.\n     *\n     * @return array\n     */\n    protected function runSelect()\n    {\n        if (!is_string($this->from)) {\n            throw new ApplicationException(sprintf(\"The from property is invalid, make sure that %s has a string value for its \\$dirName property (use '' if not using directories)\", get_class($this->model)));\n        }\n\n        if ($this->selectSingle) {\n            list($name, $extension) = $this->selectSingle;\n            return $this->datasource->selectOne($this->from, $name, $extension);\n        }\n\n        return $this->datasource->select($this->from, [\n            'columns' => $this->columns,\n            'extensions' => $this->extensions\n        ]);\n    }\n\n    /**\n     * Execute the query as a \"select\" statement.\n     *\n     * @param  array  $columns\n     * @return \\October\\Rain\\Halcyon\\Collection|static[]\n     */\n    public function get($columns = ['*'])\n    {\n        if (!is_null($this->cacheMinutes)) {\n            $results = $this->getCached($columns);\n        }\n        else {\n            $results = $this->getFresh($columns);\n        }\n\n        $models = $this->getModels($results ?: []);\n\n        return $this->model->newCollection($models);\n    }\n\n    /**\n     * Insert a new record into the datasource.\n     *\n     * @param  array  $values\n     * @return bool\n     */\n    public function insert(array $values)\n    {\n        if (empty($values)) {\n            return true;\n        }\n\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        $result = $this->processor->processInsert($this, $values);\n\n        return $this->datasource->insert(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension,\n            $result\n        );\n    }\n\n    /**\n     * Update a record in the datasource.\n     *\n     * @param  array  $values\n     * @return int\n     */\n    public function update(array $values)\n    {\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        $result = $this->processor->processUpdate($this, $values);\n\n        $oldName = $oldExtension = null;\n\n        if ($this->model->isDirty('fileName')) {\n            list($oldName, $oldExtension) = $this->model->getFileNameParts(\n                $this->model->getOriginal('fileName')\n            );\n        }\n\n        return $this->datasource->update(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension,\n            $result,\n            $oldName,\n            $oldExtension\n        );\n    }\n\n    /**\n     * Delete a record from the database.\n     *\n     * @return int\n     */\n    public function delete()\n    {\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        return $this->datasource->delete(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension\n        );\n    }\n\n    /**\n     * Returns the last modified time of the object.\n     *\n     * @return int\n     */\n    public function lastModified()\n    {\n        $this->validateFileName();\n\n        list($name, $extension) = $this->model->getFileNameParts();\n\n        return $this->datasource->lastModified(\n            $this->model->getObjectTypeDirName(),\n            $name,\n            $extension\n        );\n    }\n\n    /**\n     * Set a model instance for the model being queried.\n     *\n     * @param  \\October\\Rain\\Halcyon\\Model  $model\n     * @return $this\n     */\n    public function setModel(Model $model)\n    {\n        $this->model = $model;\n\n        $this->extensions = $this->model->getAllowedExtensions();\n\n        $this->from($this->model->getObjectTypeDirName());\n\n        return $this;\n    }\n\n    /**\n     * Get the model instance being queried.\n     *\n     * @return \\October\\Rain\\Halcyon\\Model\n     */\n    public function getModel()\n    {\n        return $this->model;\n    }\n\n    /**\n     * Get the hydrated models.\n     *\n     * @param  array  $results\n     * @return \\October\\Rain\\Halcyon\\Model[]\n     */\n    public function getModels(array $results)\n    {\n        $datasource = $this->model->getDatasourceName();\n\n        $models = $this->model->hydrate($results, $datasource);\n\n        /*\n         * Flag the models as loaded from cache, then reset the internal property.\n         */\n        if ($this->loadedFromCache) {\n            $models->each(function ($model) {\n                $model->setLoadedFromCache($this->loadedFromCache);\n            });\n\n            $this->loadedFromCache = false;\n        }\n\n        return $models->all();\n    }\n\n    //\n    // Validation (Hard)\n    //\n\n    /**\n     * Validate the supplied filename, extension and path.\n     * @param string $fileName\n     */\n    protected function validateFileName($fileName = null)\n    {\n        if ($fileName === null) {\n            $fileName = $this->model->fileName;\n        }\n\n        if (!strlen($fileName)) {\n            throw (new MissingFileNameException)->setModel($this->model);\n        }\n\n        if (!$this->validateFileNamePath($fileName, $this->model->getMaxNesting())) {\n            throw (new InvalidFileNameException)->setInvalidFileName($fileName);\n        }\n\n        $this->validateFileNameExtension($fileName, $this->model->getAllowedExtensions());\n\n        return true;\n    }\n\n    /**\n     * Validates whether a file has an allowed extension.\n     * @param string $fileName Specifies a path to validate\n     * @param array $allowedExtensions A list of allowed file extensions\n     * @return void\n     */\n    protected function validateFileNameExtension($fileName, $allowedExtensions)\n    {\n        $extension = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));\n\n        if (strlen($extension) && !in_array($extension, $allowedExtensions)) {\n            throw (new InvalidExtensionException)\n                ->setInvalidExtension($extension)\n                ->setAllowedExtensions($allowedExtensions)\n            ;\n        }\n    }\n\n    /**\n     * Validates a template path.\n     * Template directory and file names can contain only alphanumeric symbols, dashes and dots.\n     * @param string $filePath Specifies a path to validate\n     * @param integer $maxNesting Specifies the maximum allowed nesting level\n     * @return void\n     */\n    protected function validateFileNamePath($filePath, $maxNesting = 2)\n    {\n        if (strpos($filePath, '..') !== false) {\n            return false;\n        }\n\n        if (strpos($filePath, './') !== false || strpos($filePath, '//') !== false) {\n            return false;\n        }\n\n        $segments = explode('/', $filePath);\n        if ($maxNesting !== null && count($segments) > $maxNesting) {\n            return false;\n        }\n\n        foreach ($segments as $segment) {\n            if (!$this->validateFileNamePattern($segment)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Validates a template file or directory name.\n     * template file names can contain only alphanumeric symbols, dashes, underscores and dots.\n     * @param string $fileName Specifies a path to validate\n     * @return boolean Returns true if the file name is valid. Otherwise returns false.\n     */\n    protected function validateFileNamePattern($fileName)\n    {\n        return preg_match('/^[a-z0-9\\_\\-\\.\\/]+$/i', $fileName) ? true : false;\n    }\n\n    //\n    // Caching\n    //\n\n    /**\n     * Indicate that the query results should be cached.\n     *\n     * @param  \\DateTime|int  $minutes\n     * @param  string  $key\n     * @return $this\n     */\n    public function remember($minutes, $key = null)\n    {\n        list($this->cacheMinutes, $this->cacheKey) = [$minutes, $key];\n\n        return $this;\n    }\n\n    /**\n     * Indicate that the query results should be cached forever.\n     *\n     * @param  string  $key\n     * @return $this\n     */\n    public function rememberForever($key = null)\n    {\n        return $this->remember(-1, $key);\n    }\n\n    /**\n     * Indicate that the results, if cached, should use the given cache tags.\n     *\n     * @param  array|mixed  $cacheTags\n     * @return $this\n     */\n    public function cacheTags($cacheTags)\n    {\n        $this->cacheTags = $cacheTags;\n        return $this;\n    }\n\n    /**\n     * Indicate that the results, if cached, should use the given cache driver.\n     *\n     * @param  string  $cacheDriver\n     * @return $this\n     */\n    public function cacheDriver($cacheDriver)\n    {\n        $this->cacheDriver = $cacheDriver;\n        return $this;\n    }\n\n    /**\n     * Execute the query as a cached \"select\" statement.\n     *\n     * @param  array  $columns\n     * @return array\n     */\n    public function getCached($columns = ['*'])\n    {\n        if (is_null($this->columns)) {\n            $this->columns = $columns;\n        }\n\n        $key = $this->getCacheKey();\n\n        $minutes = $this->cacheMinutes;\n        $cache = $this->getCache();\n        $callback = $this->getCacheCallback($columns);\n        $isNewCache = !$cache->has($key);\n\n        // If the \"minutes\" value is less than zero, we will use that as the indicator\n        // that the value should be remembered values should be stored indefinitely\n        // and if we have minutes we will use the typical remember function here.\n        if ($minutes < 0) {\n            $result = $cache->rememberForever($key, $callback);\n        }\n        else {\n            $result = $cache->remember($key, $minutes, $callback);\n        }\n\n        // If this is an old cache record, we can check if the cache has been busted\n        // by comparing the modification times. If this is the case, forget the\n        // cache and then prompt a recycle of the results.\n        if (!$isNewCache && $this->isCacheBusted($result)) {\n            $cache->forget($key);\n            $isNewCache = true;\n\n            if ($minutes < 0) {\n                $result = $cache->rememberForever($key, $callback);\n            }\n            else {\n                $result = $cache->remember($key, $minutes, $callback);\n            }\n        }\n\n        $this->loadedFromCache = !$isNewCache;\n\n        return $result;\n    }\n\n    /**\n     * Returns true if the cache for the file is busted. This only applies\n     * to single record selection.\n     * @param  array  $result\n     * @return bool\n     */\n    protected function isCacheBusted($result)\n    {\n        if (!$this->selectSingle) {\n            return false;\n        }\n\n        $mtime = $result ? array_get(reset($result), 'mtime') : null;\n\n        list($name, $extension) = $this->selectSingle;\n\n        $currentMtime = $this->datasource->lastModified(\n            $this->from,\n            $name,\n            $extension\n        );\n\n        return $currentMtime != $mtime;\n    }\n\n    /**\n     * Get the cache object with tags assigned, if applicable.\n     *\n     * @return \\Illuminate\\Cache\\CacheManager\n     */\n    protected function getCache()\n    {\n        $cache = $this->model->getCacheManager()->driver($this->cacheDriver);\n\n        return $this->cacheTags ? $cache->tags($this->cacheTags) : $cache;\n    }\n\n    /**\n     * Get a unique cache key for the complete query.\n     *\n     * @return string\n     */\n    public function getCacheKey()\n    {\n        return $this->cacheKey ?: $this->generateCacheKey();\n    }\n\n    /**\n     * Generate the unique cache key for the query.\n     *\n     * @return string\n     */\n    public function generateCacheKey()\n    {\n        $payload = [];\n        $payload[] = $this->selectSingle ? serialize($this->selectSingle) : '*';\n        $payload[] = $this->orders ? serialize($this->orders) : '*';\n        $payload[] = $this->columns ? serialize($this->columns) : '*';\n        $payload[] = $this->fileMatch;\n        $payload[] = $this->limit;\n        $payload[] = $this->offset;\n\n        return $this->from . $this->datasource->makeCacheKey(implode('-', $payload));\n    }\n\n    /**\n     * Get the Closure callback used when caching queries.\n     *\n     * @param  string  $fileName\n     * @return \\Closure\n     */\n    protected function getCacheCallback($columns)\n    {\n        return function () use ($columns) {\n            return $this->processInitCacheData($this->getFresh($columns));\n        };\n    }\n\n    /**\n     * Initialize the cache data of each record.\n     * @param  array  $data\n     * @return array\n     */\n    protected function processInitCacheData($data)\n    {\n        if ($data) {\n            $model = get_class($this->model);\n\n            foreach ($data as &$record) {\n                $model::initCacheItem($record);\n            }\n        }\n\n        return $data;\n    }\n\n    /**\n     * Clears the internal request-level object cache.\n     */\n    public static function clearInternalCache()\n    {\n        if (MemoryCacheManager::isEnabled()) {\n            Model::getCacheManager()->driver()->flushInternalCache();\n        }\n    }\n\n    /**\n     * Handle dynamic method calls into the method.\n     *\n     * @param  string  $method\n     * @param  array   $parameters\n     * @throws \\BadMethodCallException\n     * @return void\n     */\n    public function __call($method, $parameters)\n    {\n        $className = get_class($this);\n\n        throw new BadMethodCallException(\"Call to undefined method {$className}::{$method}()\");\n    }\n}\n"], "filenames": ["src/Exception/SystemException.php", "src/Filesystem/Definitions.php", "src/Halcyon/Builder.php"], "buggy_code_start_loc": [1, 106, 145], "buggy_code_end_loc": [11, 167, 783], "fixing_code_start_loc": [2, 105, 145], "fixing_code_end_loc": [29, 164, 784], "type": "CWE-79", "message": "October is a free, open-source, self-hosted CMS platform based on the Laravel PHP Framework. In October CMS from version 1.0.319 and before version 1.0.469, backend users with access to upload files were permitted to upload SVG files without any sanitization applied to the uploaded files. Since SVG files support being parsed as HTML by browsers, this means that they could theoretically upload Javascript that would be executed on a path under the website's domain (i.e. /storage/app/media/evil.svg), but they would have to convince their target to visit that location directly in the target's browser as the backend does not display SVGs inline anywhere, SVGs are only displayed as image resources in the backend and are thus unable to be executed. Issue has been patched in Build 469 (v1.0.469) & v1.1.0.", "other": {"cve": {"id": "CVE-2020-15249", "sourceIdentifier": "security-advisories@github.com", "published": "2020-11-23T20:15:12.557", "lastModified": "2020-11-30T16:06:50.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "October is a free, open-source, self-hosted CMS platform based on the Laravel PHP Framework. In October CMS from version 1.0.319 and before version 1.0.469, backend users with access to upload files were permitted to upload SVG files without any sanitization applied to the uploaded files. Since SVG files support being parsed as HTML by browsers, this means that they could theoretically upload Javascript that would be executed on a path under the website's domain (i.e. /storage/app/media/evil.svg), but they would have to convince their target to visit that location directly in the target's browser as the backend does not display SVGs inline anywhere, SVGs are only displayed as image resources in the backend and are thus unable to be executed. Issue has been patched in Build 469 (v1.0.469) & v1.1.0."}, {"lang": "es", "value": "October es una plataforma CMS gratuita, de c\u00f3digo abierto y autohosteada basada en Laravel PHP Framework.&#xa0;En October CMS desde la versi\u00f3n 1.0.319 y anterior a versi\u00f3n 1.0.469, a los usuarios de backend con acceso para cargar archivos se les permiti\u00f3 cargar archivos SVG sin ning\u00fan saneamiento aplicado a los archivos cargados.&#xa0;Dado que los archivos SVG admiten ser analizados como HTML por los navegadores, esto significa que te\u00f3ricamente podr\u00edan cargar Javascript que se ejecutar\u00eda en una ruta bajo el dominio del sitio web (es decir, /storage/app/media/evil.svg), pero tendr\u00edan que convencer su objetivo para que visite esa ubicaci\u00f3n directamente en el navegador del objetivo, ya que el backend no muestra SVG en l\u00ednea en ning\u00fan lugar, los SVG solo se muestran como recursos de imagen en el backend y, por lo tanto, no se pueden ejecutar.&#xa0;El problema se ha corregido en Build 469 (versi\u00f3n v1.0.469) y versi\u00f3n v1.1.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.319", "versionEndExcluding": "1.0.469", "matchCriteriaId": "ABEFA590-9054-45DD-A177-D5EBEA49C5B7"}]}]}], "references": [{"url": "https://github.com/octobercms/library/commit/80aab47f044a2660aa352450f55137598f362aa4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/october/security/advisories/GHSA-fx3v-553x-3c4q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octobercms/library/commit/80aab47f044a2660aa352450f55137598f362aa4"}}