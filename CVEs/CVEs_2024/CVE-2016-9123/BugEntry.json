{"buggy_code": ["/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"bytes\"\n\t\"crypto/cipher\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"crypto/subtle\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"hash\"\n)\n\nconst (\n\tnonceBytes = 16\n)\n\n// NewCBCHMAC instantiates a new AEAD based on CBC+HMAC.\nfunc NewCBCHMAC(key []byte, newBlockCipher func([]byte) (cipher.Block, error)) (cipher.AEAD, error) {\n\tkeySize := len(key) / 2\n\tintegrityKey := key[:keySize]\n\tencryptionKey := key[keySize:]\n\n\tblockCipher, err := newBlockCipher(encryptionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar hash func() hash.Hash\n\tswitch keySize {\n\tcase 16:\n\t\thash = sha256.New\n\tcase 24:\n\t\thash = sha512.New384\n\tcase 32:\n\t\thash = sha512.New\n\t}\n\n\treturn &cbcAEAD{\n\t\thash:         hash,\n\t\tblockCipher:  blockCipher,\n\t\tauthtagBytes: keySize,\n\t\tintegrityKey: integrityKey,\n\t}, nil\n}\n\n// An AEAD based on CBC+HMAC\ntype cbcAEAD struct {\n\thash         func() hash.Hash\n\tauthtagBytes int\n\tintegrityKey []byte\n\tblockCipher  cipher.Block\n}\n\nfunc (ctx *cbcAEAD) NonceSize() int {\n\treturn nonceBytes\n}\n\nfunc (ctx *cbcAEAD) Overhead() int {\n\t// Maximum overhead is block size (for padding) plus auth tag length, where\n\t// the length of the auth tag is equivalent to the key size.\n\treturn ctx.blockCipher.BlockSize() + ctx.authtagBytes\n}\n\n// Seal encrypts and authenticates the plaintext.\nfunc (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {\n\t// Output buffer -- must take care not to mangle plaintext input.\n\tciphertext := make([]byte, len(plaintext)+ctx.Overhead())[:len(plaintext)]\n\tcopy(ciphertext, plaintext)\n\tciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())\n\n\tcbc := cipher.NewCBCEncrypter(ctx.blockCipher, nonce)\n\n\tcbc.CryptBlocks(ciphertext, ciphertext)\n\tauthtag := ctx.computeAuthTag(data, nonce, ciphertext)\n\n\tret, out := resize(dst, len(dst)+len(ciphertext)+len(authtag))\n\tcopy(out, ciphertext)\n\tcopy(out[len(ciphertext):], authtag)\n\n\treturn ret\n}\n\n// Open decrypts and authenticates the ciphertext.\nfunc (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n\tif len(ciphertext) < ctx.authtagBytes {\n\t\treturn nil, errors.New(\"square/go-jose: invalid ciphertext (too short)\")\n\t}\n\n\toffset := len(ciphertext) - ctx.authtagBytes\n\texpectedTag := ctx.computeAuthTag(data, nonce, ciphertext[:offset])\n\tmatch := subtle.ConstantTimeCompare(expectedTag, ciphertext[offset:])\n\tif match != 1 {\n\t\treturn nil, errors.New(\"square/go-jose: invalid ciphertext (auth tag mismatch)\")\n\t}\n\n\tcbc := cipher.NewCBCDecrypter(ctx.blockCipher, nonce)\n\n\t// Make copy of ciphertext buffer, don't want to modify in place\n\tbuffer := append([]byte{}, []byte(ciphertext[:offset])...)\n\n\tif len(buffer)%ctx.blockCipher.BlockSize() > 0 {\n\t\treturn nil, errors.New(\"square/go-jose: invalid ciphertext (invalid length)\")\n\t}\n\n\tcbc.CryptBlocks(buffer, buffer)\n\n\t// Remove padding\n\tplaintext, err := unpadBuffer(buffer, ctx.blockCipher.BlockSize())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret, out := resize(dst, len(dst)+len(plaintext))\n\tcopy(out, plaintext)\n\n\treturn ret, nil\n}\n\n// Compute an authentication tag\nfunc (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {\n\tbuffer := make([]byte, len(aad)+len(nonce)+len(ciphertext)+8)\n\tn := 0\n\tn += copy(buffer, aad)\n\tn += copy(buffer[n:], nonce)\n\tn += copy(buffer[n:], ciphertext)\n\tbinary.BigEndian.PutUint64(buffer[n:], uint64(len(aad)*8))\n\n\t// According to documentation, Write() on hash.Hash never fails.\n\thmac := hmac.New(ctx.hash, ctx.integrityKey)\n\t_, _ = hmac.Write(buffer)\n\n\treturn hmac.Sum(nil)[:ctx.authtagBytes]\n}\n\n// resize ensures the the given slice has a capacity of at least n bytes.\n// If the capacity of the slice is less than n, a new slice is allocated\n// and the existing data will be copied.\nfunc resize(in []byte, n int) (head, tail []byte) {\n\tif cap(in) >= n {\n\t\thead = in[:n]\n\t} else {\n\t\thead = make([]byte, n)\n\t\tcopy(head, in)\n\t}\n\n\ttail = head[len(in):]\n\treturn\n}\n\n// Apply padding\nfunc padBuffer(buffer []byte, blockSize int) []byte {\n\tmissing := blockSize - (len(buffer) % blockSize)\n\tret, out := resize(buffer, len(buffer)+missing)\n\tpadding := bytes.Repeat([]byte{byte(missing)}, missing)\n\tcopy(out, padding)\n\treturn ret\n}\n\n// Remove padding\nfunc unpadBuffer(buffer []byte, blockSize int) ([]byte, error) {\n\tif len(buffer)%blockSize != 0 {\n\t\treturn nil, errors.New(\"square/go-jose: invalid padding\")\n\t}\n\n\tlast := buffer[len(buffer)-1]\n\tcount := int(last)\n\n\tif count == 0 || count > blockSize || count > len(buffer) {\n\t\treturn nil, errors.New(\"square/go-jose: invalid padding\")\n\t}\n\n\tpadding := bytes.Repeat([]byte{last}, count)\n\tif !bytes.HasSuffix(buffer, padding) {\n\t\treturn nil, errors.New(\"square/go-jose: invalid padding\")\n\t}\n\n\treturn buffer[:len(buffer)-count], nil\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"bytes\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestInvalidInputs(t *testing.T) {\n\tkey := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t}\n\n\tnonce := []byte{\n\t\t92, 80, 104, 49, 133, 25, 161, 215, 173, 101, 219, 211, 136, 91, 210, 145}\n\n\taead, _ := NewCBCHMAC(key, aes.NewCipher)\n\tciphertext := aead.Seal(nil, nonce, []byte(\"plaintext\"), []byte(\"aad\"))\n\n\t// Changed AAD, must fail\n\t_, err := aead.Open(nil, nonce, ciphertext, []byte(\"INVALID\"))\n\tif err == nil {\n\t\tt.Error(\"must detect invalid aad\")\n\t}\n\n\t// Empty ciphertext, must fail\n\t_, err = aead.Open(nil, nonce, []byte{}, []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect invalid/empty ciphertext\")\n\t}\n\n\t// Corrupt ciphertext, must fail\n\tcorrupt := make([]byte, len(ciphertext))\n\tcopy(corrupt, ciphertext)\n\tcorrupt[0] ^= 0xFF\n\n\t_, err = aead.Open(nil, nonce, corrupt, []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect corrupt ciphertext\")\n\t}\n\n\t// Corrupt authtag, must fail\n\tcopy(corrupt, ciphertext)\n\tcorrupt[len(ciphertext)-1] ^= 0xFF\n\n\t_, err = aead.Open(nil, nonce, corrupt, []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect corrupt authtag\")\n\t}\n\n\t// Truncated data, must fail\n\t_, err = aead.Open(nil, nonce, ciphertext[:10], []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect corrupt authtag\")\n\t}\n}\n\nfunc TestVectorsAESCBC128(t *testing.T) {\n\t// Source: http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-29#appendix-A.2\n\tplaintext := []byte{\n\t\t76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n\t\t112, 114, 111, 115, 112, 101, 114, 46}\n\n\taad := []byte{\n\t\t101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69,\n\t\t120, 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105,\n\t\t74, 66, 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85,\n\t\t50, 73, 110, 48}\n\n\texpectedCiphertext := []byte{\n\t\t40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,\n\t\t75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,\n\t\t112, 56, 102}\n\n\texpectedAuthtag := []byte{\n\t\t246, 17, 244, 190, 4, 95, 98, 3, 231, 0, 115, 157, 242, 203, 100,\n\t\t191}\n\n\tkey := []byte{\n\t\t4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,\n\t\t107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207}\n\n\tnonce := []byte{\n\t\t3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101}\n\n\tenc, err := NewCBCHMAC(key, aes.NewCipher)\n\tout := enc.Seal(nil, nonce, plaintext, aad)\n\tif err != nil {\n\t\tt.Error(\"Unable to encrypt:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(out[:len(out)-16], expectedCiphertext) != 0 {\n\t\tt.Error(\"Ciphertext did not match\")\n\t}\n\tif bytes.Compare(out[len(out)-16:], expectedAuthtag) != 0 {\n\t\tt.Error(\"Auth tag did not match\")\n\t}\n}\n\nfunc TestVectorsAESCBC256(t *testing.T) {\n\t// Source: https://tools.ietf.org/html/draft-mcgrew-aead-aes-cbc-hmac-sha2-05#section-5.4\n\tplaintext := []byte{\n\t\t0x41, 0x20, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20,\n\t\t0x6d, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75,\n\t\t0x69, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x63, 0x72, 0x65,\n\t\t0x74, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62,\n\t\t0x65, 0x20, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6c, 0x6c, 0x20, 0x69,\n\t\t0x6e, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x20, 0x6f, 0x66,\n\t\t0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x65, 0x6d, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f,\n\t\t0x75, 0x74, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x6e, 0x69, 0x65, 0x6e, 0x63, 0x65}\n\n\taad := []byte{\n\t\t0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63,\n\t\t0x69, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x41, 0x75, 0x67, 0x75, 0x73, 0x74, 0x65, 0x20,\n\t\t0x4b, 0x65, 0x72, 0x63, 0x6b, 0x68, 0x6f, 0x66, 0x66, 0x73}\n\n\texpectedCiphertext := []byte{\n\t\t0x4a, 0xff, 0xaa, 0xad, 0xb7, 0x8c, 0x31, 0xc5, 0xda, 0x4b, 0x1b, 0x59, 0x0d, 0x10, 0xff, 0xbd,\n\t\t0x3d, 0xd8, 0xd5, 0xd3, 0x02, 0x42, 0x35, 0x26, 0x91, 0x2d, 0xa0, 0x37, 0xec, 0xbc, 0xc7, 0xbd,\n\t\t0x82, 0x2c, 0x30, 0x1d, 0xd6, 0x7c, 0x37, 0x3b, 0xcc, 0xb5, 0x84, 0xad, 0x3e, 0x92, 0x79, 0xc2,\n\t\t0xe6, 0xd1, 0x2a, 0x13, 0x74, 0xb7, 0x7f, 0x07, 0x75, 0x53, 0xdf, 0x82, 0x94, 0x10, 0x44, 0x6b,\n\t\t0x36, 0xeb, 0xd9, 0x70, 0x66, 0x29, 0x6a, 0xe6, 0x42, 0x7e, 0xa7, 0x5c, 0x2e, 0x08, 0x46, 0xa1,\n\t\t0x1a, 0x09, 0xcc, 0xf5, 0x37, 0x0d, 0xc8, 0x0b, 0xfe, 0xcb, 0xad, 0x28, 0xc7, 0x3f, 0x09, 0xb3,\n\t\t0xa3, 0xb7, 0x5e, 0x66, 0x2a, 0x25, 0x94, 0x41, 0x0a, 0xe4, 0x96, 0xb2, 0xe2, 0xe6, 0x60, 0x9e,\n\t\t0x31, 0xe6, 0xe0, 0x2c, 0xc8, 0x37, 0xf0, 0x53, 0xd2, 0x1f, 0x37, 0xff, 0x4f, 0x51, 0x95, 0x0b,\n\t\t0xbe, 0x26, 0x38, 0xd0, 0x9d, 0xd7, 0xa4, 0x93, 0x09, 0x30, 0x80, 0x6d, 0x07, 0x03, 0xb1, 0xf6}\n\n\texpectedAuthtag := []byte{\n\t\t0x4d, 0xd3, 0xb4, 0xc0, 0x88, 0xa7, 0xf4, 0x5c, 0x21, 0x68, 0x39, 0x64, 0x5b, 0x20, 0x12, 0xbf,\n\t\t0x2e, 0x62, 0x69, 0xa8, 0xc5, 0x6a, 0x81, 0x6d, 0xbc, 0x1b, 0x26, 0x77, 0x61, 0x95, 0x5b, 0xc5}\n\n\tkey := []byte{\n\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f}\n\n\tnonce := []byte{\n\t\t0x1a, 0xf3, 0x8c, 0x2d, 0xc2, 0xb9, 0x6f, 0xfd, 0xd8, 0x66, 0x94, 0x09, 0x23, 0x41, 0xbc, 0x04}\n\n\tenc, err := NewCBCHMAC(key, aes.NewCipher)\n\tout := enc.Seal(nil, nonce, plaintext, aad)\n\tif err != nil {\n\t\tt.Error(\"Unable to encrypt:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(out[:len(out)-32], expectedCiphertext) != 0 {\n\t\tt.Error(\"Ciphertext did not match, got\", out[:len(out)-32], \"wanted\", expectedCiphertext)\n\t}\n\tif bytes.Compare(out[len(out)-32:], expectedAuthtag) != 0 {\n\t\tt.Error(\"Auth tag did not match, got\", out[len(out)-32:], \"wanted\", expectedAuthtag)\n\t}\n}\n\nfunc TestAESCBCRoundtrip(t *testing.T) {\n\tkey128 := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\n\tkey192 := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7}\n\n\tkey256 := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\n\tnonce := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\n\tRunRoundtrip(t, key128, nonce)\n\tRunRoundtrip(t, key192, nonce)\n\tRunRoundtrip(t, key256, nonce)\n}\n\nfunc RunRoundtrip(t *testing.T, key, nonce []byte) {\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif aead.NonceSize() != len(nonce) {\n\t\tpanic(\"invalid nonce\")\n\t}\n\n\t// Test pre-existing data in dst buffer\n\tdst := []byte{15, 15, 15, 15}\n\tplaintext := []byte{0, 0, 0, 0}\n\taad := []byte{4, 3, 2, 1}\n\n\tresult := aead.Seal(dst, nonce, plaintext, aad)\n\tif bytes.Compare(dst, result[:4]) != 0 {\n\t\tt.Error(\"Existing data in dst not preserved\")\n\t}\n\n\t// Test pre-existing (empty) dst buffer with sufficient capacity\n\tdst = make([]byte, 256)[:0]\n\tresult, err = aead.Open(dst, nonce, result[4:], aad)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif bytes.Compare(result, plaintext) != 0 {\n\t\tt.Error(\"Plaintext does not match output\")\n\t}\n}\n\nfunc TestAESCBCOverhead(t *testing.T) {\n\taead, err := NewCBCHMAC(make([]byte, 32), aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif aead.Overhead() != 32 {\n\t\tt.Error(\"CBC-HMAC reports incorrect overhead value\")\n\t}\n}\n\nfunc TestPadding(t *testing.T) {\n\tfor i := 0; i < 256; i++ {\n\t\tslice := make([]byte, i)\n\t\tpadded := padBuffer(slice, 16)\n\t\tif len(padded)%16 != 0 {\n\t\t\tt.Error(\"failed to pad slice properly\", i)\n\t\t\treturn\n\t\t}\n\t\tunpadded, err := unpadBuffer(padded, 16)\n\t\tif err != nil || len(unpadded) != i {\n\t\t\tt.Error(\"failed to unpad slice properly\", i)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestInvalidKey(t *testing.T) {\n\tkey := make([]byte, 30)\n\t_, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err == nil {\n\t\tt.Error(\"should not be able to instantiate CBC-HMAC with invalid key\")\n\t}\n}\n\nfunc TestTruncatedCiphertext(t *testing.T) {\n\tkey := make([]byte, 32)\n\tnonce := make([]byte, 16)\n\tdata := make([]byte, 32)\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tctx := aead.(*cbcAEAD)\n\tct := aead.Seal(nil, nonce, data, nil)\n\n\t// Truncated ciphertext, but with correct auth tag\n\ttruncated, tail := resize(ct[:len(ct)-ctx.authtagBytes-2], len(ct)-2)\n\tcopy(tail, ctx.computeAuthTag(nil, nonce, truncated[:len(truncated)-ctx.authtagBytes]))\n\n\t// Open should fail\n\t_, err = aead.Open(nil, nonce, truncated, nil)\n\tif err == nil {\n\t\tt.Error(\"open on truncated ciphertext should fail\")\n\t}\n}\n\nfunc TestInvalidPaddingOpen(t *testing.T) {\n\tkey := make([]byte, 32)\n\tnonce := make([]byte, 16)\n\n\t// Plaintext with invalid padding\n\tplaintext := padBuffer(make([]byte, 28), aes.BlockSize)\n\tplaintext[len(plaintext)-1] = 0xFF\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\tblock, _ := aes.NewCipher(key)\n\tcbc := cipher.NewCBCEncrypter(block, nonce)\n\tbuffer := append([]byte{}, plaintext...)\n\tcbc.CryptBlocks(buffer, buffer)\n\n\taead, _ := NewCBCHMAC(key, aes.NewCipher)\n\tctx := aead.(*cbcAEAD)\n\n\t// Mutated ciphertext, but with correct auth tag\n\tsize := len(buffer)\n\tciphertext, tail := resize(buffer, size+(len(key)/2))\n\tcopy(tail, ctx.computeAuthTag(nil, nonce, ciphertext[:size]))\n\n\t// Open should fail (b/c of invalid padding, even though tag matches)\n\t_, err := aead.Open(nil, nonce, ciphertext, nil)\n\tif err == nil || !strings.Contains(err.Error(), \"invalid padding\") {\n\t\tt.Error(\"no or unexpected error on open with invalid padding:\", err)\n\t}\n}\n\nfunc TestInvalidPadding(t *testing.T) {\n\tfor i := 0; i < 256; i++ {\n\t\tslice := make([]byte, i)\n\t\tpadded := padBuffer(slice, 16)\n\t\tif len(padded)%16 != 0 {\n\t\t\tt.Error(\"failed to pad slice properly\", i)\n\t\t\treturn\n\t\t}\n\n\t\tpaddingBytes := 16 - (i % 16)\n\n\t\t// Mutate padding for testing\n\t\tfor j := 1; j <= paddingBytes; j++ {\n\t\t\tmutated := make([]byte, len(padded))\n\t\t\tcopy(mutated, padded)\n\t\t\tmutated[len(mutated)-j] ^= 0xFF\n\n\t\t\t_, err := unpadBuffer(mutated, 16)\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"unpad on invalid padding should fail\", i)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Test truncated padding\n\t\t_, err := unpadBuffer(padded[:len(padded)-1], 16)\n\t\tif err == nil {\n\t\t\tt.Error(\"unpad on truncated padding should fail\", i)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestZeroLengthPadding(t *testing.T) {\n\tdata := make([]byte, 16)\n\tdata, err := unpadBuffer(data, 16)\n\tif err == nil {\n\t\tt.Error(\"padding with 0x00 should never be valid\")\n\t}\n}\n\nfunc benchEncryptCBCHMAC(b *testing.B, keySize, chunkSize int) {\n\tkey := make([]byte, keySize*2)\n\tnonce := make([]byte, 16)\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\tchunk := make([]byte, chunkSize)\n\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tb.SetBytes(int64(chunkSize))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\taead.Seal(nil, nonce, chunk, nil)\n\t}\n}\n\nfunc benchDecryptCBCHMAC(b *testing.B, keySize, chunkSize int) {\n\tkey := make([]byte, keySize*2)\n\tnonce := make([]byte, 16)\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\tchunk := make([]byte, chunkSize)\n\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tout := aead.Seal(nil, nonce, chunk, nil)\n\n\tb.SetBytes(int64(chunkSize))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\taead.Open(nil, nonce, out, nil)\n\t}\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_1k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 1024)\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_64k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 65536)\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_1MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 1048576)\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_64MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 67108864)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_1k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 1024)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_64k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 65536)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_1MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 1048576)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_64MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 67108864)\n}\n\nfunc BenchmarkEncryptAES192_CBCHMAC_64k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 24, 65536)\n}\n\nfunc BenchmarkEncryptAES192_CBCHMAC_1MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 24, 1048576)\n}\n\nfunc BenchmarkEncryptAES192_CBCHMAC_64MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 24, 67108864)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_1k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 1024)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_64k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 65536)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_1MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 1048576)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_64MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 67108864)\n}\n\nfunc BenchmarkEncryptAES256_CBCHMAC_64k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 32, 65536)\n}\n\nfunc BenchmarkEncryptAES256_CBCHMAC_1MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 32, 1048576)\n}\n\nfunc BenchmarkEncryptAES256_CBCHMAC_64MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 32, 67108864)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_1k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 1032)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_64k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 65536)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_1MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 1048576)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_64MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 67108864)\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"crypto\"\n\t\"encoding/binary\"\n\t\"hash\"\n\t\"io\"\n)\n\ntype concatKDF struct {\n\tz, info []byte\n\ti       uint32\n\tcache   []byte\n\thasher  hash.Hash\n}\n\n// NewConcatKDF builds a KDF reader based on the given inputs.\nfunc NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {\n\tbuffer := make([]byte, len(algID)+len(ptyUInfo)+len(ptyVInfo)+len(supPubInfo)+len(supPrivInfo))\n\tn := 0\n\tn += copy(buffer, algID)\n\tn += copy(buffer[n:], ptyUInfo)\n\tn += copy(buffer[n:], ptyVInfo)\n\tn += copy(buffer[n:], supPubInfo)\n\tcopy(buffer[n:], supPrivInfo)\n\n\thasher := hash.New()\n\n\treturn &concatKDF{\n\t\tz:      z,\n\t\tinfo:   buffer,\n\t\thasher: hasher,\n\t\tcache:  []byte{},\n\t\ti:      1,\n\t}\n}\n\nfunc (ctx *concatKDF) Read(out []byte) (int, error) {\n\tcopied := copy(out, ctx.cache)\n\tctx.cache = ctx.cache[copied:]\n\n\tfor copied < len(out) {\n\t\tctx.hasher.Reset()\n\n\t\t// Write on a hash.Hash never fails\n\t\t_ = binary.Write(ctx.hasher, binary.BigEndian, ctx.i)\n\t\t_, _ = ctx.hasher.Write(ctx.z)\n\t\t_, _ = ctx.hasher.Write(ctx.info)\n\n\t\thash := ctx.hasher.Sum(nil)\n\t\tchunkCopied := copy(out[copied:], hash)\n\t\tcopied += chunkCopied\n\t\tctx.cache = hash[chunkCopied:]\n\n\t\tctx.i++\n\t}\n\n\treturn copied, nil\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"encoding/binary\"\n)\n\n// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.\n// It is an error to call this function with a private/public key that are not on the same\n// curve. Callers must ensure that the keys are valid before calling this function.\nfunc DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {\n\t// algId, partyUInfo, partyVInfo inputs must be prefixed with the length\n\talgID := lengthPrefixed([]byte(alg))\n\tptyUInfo := lengthPrefixed(apuData)\n\tptyVInfo := lengthPrefixed(apvData)\n\n\t// suppPubInfo is the encoded length of the output size in bits\n\tsupPubInfo := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)\n\n\tif !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {\n\t\tpanic(\"public key not on same curve as private key\")\n\t}\n\n\tz, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())\n\treader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})\n\n\tkey := make([]byte, size)\n\n\t// Read on the KDF will never fail\n\t_, _ = reader.Read(key)\n\treturn key\n}\n\nfunc lengthPrefixed(data []byte) []byte {\n\tout := make([]byte, len(data)+4)\n\tbinary.BigEndian.PutUint32(out, uint32(len(data)))\n\tcopy(out[4:], data)\n\treturn out\n}\n"], "fixing_code": ["/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"bytes\"\n\t\"crypto/cipher\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"crypto/subtle\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"hash\"\n)\n\nconst (\n\tnonceBytes = 16\n)\n\n// NewCBCHMAC instantiates a new AEAD based on CBC+HMAC.\nfunc NewCBCHMAC(key []byte, newBlockCipher func([]byte) (cipher.Block, error)) (cipher.AEAD, error) {\n\tkeySize := len(key) / 2\n\tintegrityKey := key[:keySize]\n\tencryptionKey := key[keySize:]\n\n\tblockCipher, err := newBlockCipher(encryptionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar hash func() hash.Hash\n\tswitch keySize {\n\tcase 16:\n\t\thash = sha256.New\n\tcase 24:\n\t\thash = sha512.New384\n\tcase 32:\n\t\thash = sha512.New\n\t}\n\n\treturn &cbcAEAD{\n\t\thash:         hash,\n\t\tblockCipher:  blockCipher,\n\t\tauthtagBytes: keySize,\n\t\tintegrityKey: integrityKey,\n\t}, nil\n}\n\n// An AEAD based on CBC+HMAC\ntype cbcAEAD struct {\n\thash         func() hash.Hash\n\tauthtagBytes int\n\tintegrityKey []byte\n\tblockCipher  cipher.Block\n}\n\nfunc (ctx *cbcAEAD) NonceSize() int {\n\treturn nonceBytes\n}\n\nfunc (ctx *cbcAEAD) Overhead() int {\n\t// Maximum overhead is block size (for padding) plus auth tag length, where\n\t// the length of the auth tag is equivalent to the key size.\n\treturn ctx.blockCipher.BlockSize() + ctx.authtagBytes\n}\n\n// Seal encrypts and authenticates the plaintext.\nfunc (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {\n\t// Output buffer -- must take care not to mangle plaintext input.\n\tciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]\n\tcopy(ciphertext, plaintext)\n\tciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())\n\n\tcbc := cipher.NewCBCEncrypter(ctx.blockCipher, nonce)\n\n\tcbc.CryptBlocks(ciphertext, ciphertext)\n\tauthtag := ctx.computeAuthTag(data, nonce, ciphertext)\n\n\tret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))\n\tcopy(out, ciphertext)\n\tcopy(out[len(ciphertext):], authtag)\n\n\treturn ret\n}\n\n// Open decrypts and authenticates the ciphertext.\nfunc (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n\tif len(ciphertext) < ctx.authtagBytes {\n\t\treturn nil, errors.New(\"square/go-jose: invalid ciphertext (too short)\")\n\t}\n\n\toffset := len(ciphertext) - ctx.authtagBytes\n\texpectedTag := ctx.computeAuthTag(data, nonce, ciphertext[:offset])\n\tmatch := subtle.ConstantTimeCompare(expectedTag, ciphertext[offset:])\n\tif match != 1 {\n\t\treturn nil, errors.New(\"square/go-jose: invalid ciphertext (auth tag mismatch)\")\n\t}\n\n\tcbc := cipher.NewCBCDecrypter(ctx.blockCipher, nonce)\n\n\t// Make copy of ciphertext buffer, don't want to modify in place\n\tbuffer := append([]byte{}, []byte(ciphertext[:offset])...)\n\n\tif len(buffer)%ctx.blockCipher.BlockSize() > 0 {\n\t\treturn nil, errors.New(\"square/go-jose: invalid ciphertext (invalid length)\")\n\t}\n\n\tcbc.CryptBlocks(buffer, buffer)\n\n\t// Remove padding\n\tplaintext, err := unpadBuffer(buffer, ctx.blockCipher.BlockSize())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))\n\tcopy(out, plaintext)\n\n\treturn ret, nil\n}\n\n// Compute an authentication tag\nfunc (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {\n\tbuffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)\n\tn := 0\n\tn += copy(buffer, aad)\n\tn += copy(buffer[n:], nonce)\n\tn += copy(buffer[n:], ciphertext)\n\tbinary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)\n\n\t// According to documentation, Write() on hash.Hash never fails.\n\thmac := hmac.New(ctx.hash, ctx.integrityKey)\n\t_, _ = hmac.Write(buffer)\n\n\treturn hmac.Sum(nil)[:ctx.authtagBytes]\n}\n\n// resize ensures the the given slice has a capacity of at least n bytes.\n// If the capacity of the slice is less than n, a new slice is allocated\n// and the existing data will be copied.\nfunc resize(in []byte, n uint64) (head, tail []byte) {\n\tif uint64(cap(in)) >= n {\n\t\thead = in[:n]\n\t} else {\n\t\thead = make([]byte, n)\n\t\tcopy(head, in)\n\t}\n\n\ttail = head[len(in):]\n\treturn\n}\n\n// Apply padding\nfunc padBuffer(buffer []byte, blockSize int) []byte {\n\tmissing := blockSize - (len(buffer) % blockSize)\n\tret, out := resize(buffer, uint64(len(buffer))+uint64(missing))\n\tpadding := bytes.Repeat([]byte{byte(missing)}, missing)\n\tcopy(out, padding)\n\treturn ret\n}\n\n// Remove padding\nfunc unpadBuffer(buffer []byte, blockSize int) ([]byte, error) {\n\tif len(buffer)%blockSize != 0 {\n\t\treturn nil, errors.New(\"square/go-jose: invalid padding\")\n\t}\n\n\tlast := buffer[len(buffer)-1]\n\tcount := int(last)\n\n\tif count == 0 || count > blockSize || count > len(buffer) {\n\t\treturn nil, errors.New(\"square/go-jose: invalid padding\")\n\t}\n\n\tpadding := bytes.Repeat([]byte{last}, count)\n\tif !bytes.HasSuffix(buffer, padding) {\n\t\treturn nil, errors.New(\"square/go-jose: invalid padding\")\n\t}\n\n\treturn buffer[:len(buffer)-count], nil\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"bytes\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestInvalidInputs(t *testing.T) {\n\tkey := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t}\n\n\tnonce := []byte{\n\t\t92, 80, 104, 49, 133, 25, 161, 215, 173, 101, 219, 211, 136, 91, 210, 145}\n\n\taead, _ := NewCBCHMAC(key, aes.NewCipher)\n\tciphertext := aead.Seal(nil, nonce, []byte(\"plaintext\"), []byte(\"aad\"))\n\n\t// Changed AAD, must fail\n\t_, err := aead.Open(nil, nonce, ciphertext, []byte(\"INVALID\"))\n\tif err == nil {\n\t\tt.Error(\"must detect invalid aad\")\n\t}\n\n\t// Empty ciphertext, must fail\n\t_, err = aead.Open(nil, nonce, []byte{}, []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect invalid/empty ciphertext\")\n\t}\n\n\t// Corrupt ciphertext, must fail\n\tcorrupt := make([]byte, len(ciphertext))\n\tcopy(corrupt, ciphertext)\n\tcorrupt[0] ^= 0xFF\n\n\t_, err = aead.Open(nil, nonce, corrupt, []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect corrupt ciphertext\")\n\t}\n\n\t// Corrupt authtag, must fail\n\tcopy(corrupt, ciphertext)\n\tcorrupt[len(ciphertext)-1] ^= 0xFF\n\n\t_, err = aead.Open(nil, nonce, corrupt, []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect corrupt authtag\")\n\t}\n\n\t// Truncated data, must fail\n\t_, err = aead.Open(nil, nonce, ciphertext[:10], []byte(\"aad\"))\n\tif err == nil {\n\t\tt.Error(\"must detect corrupt authtag\")\n\t}\n}\n\nfunc TestVectorsAESCBC128(t *testing.T) {\n\t// Source: http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-29#appendix-A.2\n\tplaintext := []byte{\n\t\t76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n\t\t112, 114, 111, 115, 112, 101, 114, 46}\n\n\taad := []byte{\n\t\t101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69,\n\t\t120, 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105,\n\t\t74, 66, 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85,\n\t\t50, 73, 110, 48}\n\n\texpectedCiphertext := []byte{\n\t\t40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,\n\t\t75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,\n\t\t112, 56, 102}\n\n\texpectedAuthtag := []byte{\n\t\t246, 17, 244, 190, 4, 95, 98, 3, 231, 0, 115, 157, 242, 203, 100,\n\t\t191}\n\n\tkey := []byte{\n\t\t4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,\n\t\t107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207}\n\n\tnonce := []byte{\n\t\t3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101}\n\n\tenc, err := NewCBCHMAC(key, aes.NewCipher)\n\tout := enc.Seal(nil, nonce, plaintext, aad)\n\tif err != nil {\n\t\tt.Error(\"Unable to encrypt:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(out[:len(out)-16], expectedCiphertext) != 0 {\n\t\tt.Error(\"Ciphertext did not match\")\n\t}\n\tif bytes.Compare(out[len(out)-16:], expectedAuthtag) != 0 {\n\t\tt.Error(\"Auth tag did not match\")\n\t}\n}\n\nfunc TestVectorsAESCBC256(t *testing.T) {\n\t// Source: https://tools.ietf.org/html/draft-mcgrew-aead-aes-cbc-hmac-sha2-05#section-5.4\n\tplaintext := []byte{\n\t\t0x41, 0x20, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20,\n\t\t0x6d, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75,\n\t\t0x69, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x63, 0x72, 0x65,\n\t\t0x74, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62,\n\t\t0x65, 0x20, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6c, 0x6c, 0x20, 0x69,\n\t\t0x6e, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x20, 0x6f, 0x66,\n\t\t0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x65, 0x6d, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f,\n\t\t0x75, 0x74, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x6e, 0x69, 0x65, 0x6e, 0x63, 0x65}\n\n\taad := []byte{\n\t\t0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63,\n\t\t0x69, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x41, 0x75, 0x67, 0x75, 0x73, 0x74, 0x65, 0x20,\n\t\t0x4b, 0x65, 0x72, 0x63, 0x6b, 0x68, 0x6f, 0x66, 0x66, 0x73}\n\n\texpectedCiphertext := []byte{\n\t\t0x4a, 0xff, 0xaa, 0xad, 0xb7, 0x8c, 0x31, 0xc5, 0xda, 0x4b, 0x1b, 0x59, 0x0d, 0x10, 0xff, 0xbd,\n\t\t0x3d, 0xd8, 0xd5, 0xd3, 0x02, 0x42, 0x35, 0x26, 0x91, 0x2d, 0xa0, 0x37, 0xec, 0xbc, 0xc7, 0xbd,\n\t\t0x82, 0x2c, 0x30, 0x1d, 0xd6, 0x7c, 0x37, 0x3b, 0xcc, 0xb5, 0x84, 0xad, 0x3e, 0x92, 0x79, 0xc2,\n\t\t0xe6, 0xd1, 0x2a, 0x13, 0x74, 0xb7, 0x7f, 0x07, 0x75, 0x53, 0xdf, 0x82, 0x94, 0x10, 0x44, 0x6b,\n\t\t0x36, 0xeb, 0xd9, 0x70, 0x66, 0x29, 0x6a, 0xe6, 0x42, 0x7e, 0xa7, 0x5c, 0x2e, 0x08, 0x46, 0xa1,\n\t\t0x1a, 0x09, 0xcc, 0xf5, 0x37, 0x0d, 0xc8, 0x0b, 0xfe, 0xcb, 0xad, 0x28, 0xc7, 0x3f, 0x09, 0xb3,\n\t\t0xa3, 0xb7, 0x5e, 0x66, 0x2a, 0x25, 0x94, 0x41, 0x0a, 0xe4, 0x96, 0xb2, 0xe2, 0xe6, 0x60, 0x9e,\n\t\t0x31, 0xe6, 0xe0, 0x2c, 0xc8, 0x37, 0xf0, 0x53, 0xd2, 0x1f, 0x37, 0xff, 0x4f, 0x51, 0x95, 0x0b,\n\t\t0xbe, 0x26, 0x38, 0xd0, 0x9d, 0xd7, 0xa4, 0x93, 0x09, 0x30, 0x80, 0x6d, 0x07, 0x03, 0xb1, 0xf6}\n\n\texpectedAuthtag := []byte{\n\t\t0x4d, 0xd3, 0xb4, 0xc0, 0x88, 0xa7, 0xf4, 0x5c, 0x21, 0x68, 0x39, 0x64, 0x5b, 0x20, 0x12, 0xbf,\n\t\t0x2e, 0x62, 0x69, 0xa8, 0xc5, 0x6a, 0x81, 0x6d, 0xbc, 0x1b, 0x26, 0x77, 0x61, 0x95, 0x5b, 0xc5}\n\n\tkey := []byte{\n\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f}\n\n\tnonce := []byte{\n\t\t0x1a, 0xf3, 0x8c, 0x2d, 0xc2, 0xb9, 0x6f, 0xfd, 0xd8, 0x66, 0x94, 0x09, 0x23, 0x41, 0xbc, 0x04}\n\n\tenc, err := NewCBCHMAC(key, aes.NewCipher)\n\tout := enc.Seal(nil, nonce, plaintext, aad)\n\tif err != nil {\n\t\tt.Error(\"Unable to encrypt:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(out[:len(out)-32], expectedCiphertext) != 0 {\n\t\tt.Error(\"Ciphertext did not match, got\", out[:len(out)-32], \"wanted\", expectedCiphertext)\n\t}\n\tif bytes.Compare(out[len(out)-32:], expectedAuthtag) != 0 {\n\t\tt.Error(\"Auth tag did not match, got\", out[len(out)-32:], \"wanted\", expectedAuthtag)\n\t}\n}\n\nfunc TestAESCBCRoundtrip(t *testing.T) {\n\tkey128 := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\n\tkey192 := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7}\n\n\tkey256 := []byte{\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\n\tnonce := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\n\tRunRoundtrip(t, key128, nonce)\n\tRunRoundtrip(t, key192, nonce)\n\tRunRoundtrip(t, key256, nonce)\n}\n\nfunc RunRoundtrip(t *testing.T, key, nonce []byte) {\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif aead.NonceSize() != len(nonce) {\n\t\tpanic(\"invalid nonce\")\n\t}\n\n\t// Test pre-existing data in dst buffer\n\tdst := []byte{15, 15, 15, 15}\n\tplaintext := []byte{0, 0, 0, 0}\n\taad := []byte{4, 3, 2, 1}\n\n\tresult := aead.Seal(dst, nonce, plaintext, aad)\n\tif bytes.Compare(dst, result[:4]) != 0 {\n\t\tt.Error(\"Existing data in dst not preserved\")\n\t}\n\n\t// Test pre-existing (empty) dst buffer with sufficient capacity\n\tdst = make([]byte, 256)[:0]\n\tresult, err = aead.Open(dst, nonce, result[4:], aad)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif bytes.Compare(result, plaintext) != 0 {\n\t\tt.Error(\"Plaintext does not match output\")\n\t}\n}\n\nfunc TestAESCBCOverhead(t *testing.T) {\n\taead, err := NewCBCHMAC(make([]byte, 32), aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif aead.Overhead() != 32 {\n\t\tt.Error(\"CBC-HMAC reports incorrect overhead value\")\n\t}\n}\n\nfunc TestPadding(t *testing.T) {\n\tfor i := 0; i < 256; i++ {\n\t\tslice := make([]byte, i)\n\t\tpadded := padBuffer(slice, 16)\n\t\tif len(padded)%16 != 0 {\n\t\t\tt.Error(\"failed to pad slice properly\", i)\n\t\t\treturn\n\t\t}\n\t\tunpadded, err := unpadBuffer(padded, 16)\n\t\tif err != nil || len(unpadded) != i {\n\t\t\tt.Error(\"failed to unpad slice properly\", i)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestInvalidKey(t *testing.T) {\n\tkey := make([]byte, 30)\n\t_, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err == nil {\n\t\tt.Error(\"should not be able to instantiate CBC-HMAC with invalid key\")\n\t}\n}\n\nfunc TestTruncatedCiphertext(t *testing.T) {\n\tkey := make([]byte, 32)\n\tnonce := make([]byte, 16)\n\tdata := make([]byte, 32)\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tctx := aead.(*cbcAEAD)\n\tct := aead.Seal(nil, nonce, data, nil)\n\n\t// Truncated ciphertext, but with correct auth tag\n\ttruncated, tail := resize(ct[:len(ct)-ctx.authtagBytes-2], uint64(len(ct))-2)\n\tcopy(tail, ctx.computeAuthTag(nil, nonce, truncated[:len(truncated)-ctx.authtagBytes]))\n\n\t// Open should fail\n\t_, err = aead.Open(nil, nonce, truncated, nil)\n\tif err == nil {\n\t\tt.Error(\"open on truncated ciphertext should fail\")\n\t}\n}\n\nfunc TestInvalidPaddingOpen(t *testing.T) {\n\tkey := make([]byte, 32)\n\tnonce := make([]byte, 16)\n\n\t// Plaintext with invalid padding\n\tplaintext := padBuffer(make([]byte, 28), aes.BlockSize)\n\tplaintext[len(plaintext)-1] = 0xFF\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\tblock, _ := aes.NewCipher(key)\n\tcbc := cipher.NewCBCEncrypter(block, nonce)\n\tbuffer := append([]byte{}, plaintext...)\n\tcbc.CryptBlocks(buffer, buffer)\n\n\taead, _ := NewCBCHMAC(key, aes.NewCipher)\n\tctx := aead.(*cbcAEAD)\n\n\t// Mutated ciphertext, but with correct auth tag\n\tsize := uint64(len(buffer))\n\tciphertext, tail := resize(buffer, size+(uint64(len(key))/2))\n\tcopy(tail, ctx.computeAuthTag(nil, nonce, ciphertext[:size]))\n\n\t// Open should fail (b/c of invalid padding, even though tag matches)\n\t_, err := aead.Open(nil, nonce, ciphertext, nil)\n\tif err == nil || !strings.Contains(err.Error(), \"invalid padding\") {\n\t\tt.Error(\"no or unexpected error on open with invalid padding:\", err)\n\t}\n}\n\nfunc TestInvalidPadding(t *testing.T) {\n\tfor i := 0; i < 256; i++ {\n\t\tslice := make([]byte, i)\n\t\tpadded := padBuffer(slice, 16)\n\t\tif len(padded)%16 != 0 {\n\t\t\tt.Error(\"failed to pad slice properly\", i)\n\t\t\treturn\n\t\t}\n\n\t\tpaddingBytes := 16 - (i % 16)\n\n\t\t// Mutate padding for testing\n\t\tfor j := 1; j <= paddingBytes; j++ {\n\t\t\tmutated := make([]byte, len(padded))\n\t\t\tcopy(mutated, padded)\n\t\t\tmutated[len(mutated)-j] ^= 0xFF\n\n\t\t\t_, err := unpadBuffer(mutated, 16)\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"unpad on invalid padding should fail\", i)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Test truncated padding\n\t\t_, err := unpadBuffer(padded[:len(padded)-1], 16)\n\t\tif err == nil {\n\t\t\tt.Error(\"unpad on truncated padding should fail\", i)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestZeroLengthPadding(t *testing.T) {\n\tdata := make([]byte, 16)\n\tdata, err := unpadBuffer(data, 16)\n\tif err == nil {\n\t\tt.Error(\"padding with 0x00 should never be valid\")\n\t}\n}\n\nfunc benchEncryptCBCHMAC(b *testing.B, keySize, chunkSize int) {\n\tkey := make([]byte, keySize*2)\n\tnonce := make([]byte, 16)\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\tchunk := make([]byte, chunkSize)\n\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tb.SetBytes(int64(chunkSize))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\taead.Seal(nil, nonce, chunk, nil)\n\t}\n}\n\nfunc benchDecryptCBCHMAC(b *testing.B, keySize, chunkSize int) {\n\tkey := make([]byte, keySize*2)\n\tnonce := make([]byte, 16)\n\n\tio.ReadFull(rand.Reader, key)\n\tio.ReadFull(rand.Reader, nonce)\n\n\tchunk := make([]byte, chunkSize)\n\n\taead, err := NewCBCHMAC(key, aes.NewCipher)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tout := aead.Seal(nil, nonce, chunk, nil)\n\n\tb.SetBytes(int64(chunkSize))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\taead.Open(nil, nonce, out, nil)\n\t}\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_1k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 1024)\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_64k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 65536)\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_1MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 1048576)\n}\n\nfunc BenchmarkEncryptAES128_CBCHMAC_64MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 16, 67108864)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_1k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 1024)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_64k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 65536)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_1MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 1048576)\n}\n\nfunc BenchmarkDecryptAES128_CBCHMAC_64MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 16, 67108864)\n}\n\nfunc BenchmarkEncryptAES192_CBCHMAC_64k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 24, 65536)\n}\n\nfunc BenchmarkEncryptAES192_CBCHMAC_1MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 24, 1048576)\n}\n\nfunc BenchmarkEncryptAES192_CBCHMAC_64MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 24, 67108864)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_1k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 1024)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_64k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 65536)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_1MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 1048576)\n}\n\nfunc BenchmarkDecryptAES192_CBCHMAC_64MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 24, 67108864)\n}\n\nfunc BenchmarkEncryptAES256_CBCHMAC_64k(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 32, 65536)\n}\n\nfunc BenchmarkEncryptAES256_CBCHMAC_1MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 32, 1048576)\n}\n\nfunc BenchmarkEncryptAES256_CBCHMAC_64MB(b *testing.B) {\n\tbenchEncryptCBCHMAC(b, 32, 67108864)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_1k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 1032)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_64k(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 65536)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_1MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 1048576)\n}\n\nfunc BenchmarkDecryptAES256_CBCHMAC_64MB(b *testing.B) {\n\tbenchDecryptCBCHMAC(b, 32, 67108864)\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"crypto\"\n\t\"encoding/binary\"\n\t\"hash\"\n\t\"io\"\n)\n\ntype concatKDF struct {\n\tz, info []byte\n\ti       uint32\n\tcache   []byte\n\thasher  hash.Hash\n}\n\n// NewConcatKDF builds a KDF reader based on the given inputs.\nfunc NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {\n\tbuffer := make([]byte, uint64(len(algID))+uint64(len(ptyUInfo))+uint64(len(ptyVInfo))+uint64(len(supPubInfo))+uint64(len(supPrivInfo)))\n\tn := 0\n\tn += copy(buffer, algID)\n\tn += copy(buffer[n:], ptyUInfo)\n\tn += copy(buffer[n:], ptyVInfo)\n\tn += copy(buffer[n:], supPubInfo)\n\tcopy(buffer[n:], supPrivInfo)\n\n\thasher := hash.New()\n\n\treturn &concatKDF{\n\t\tz:      z,\n\t\tinfo:   buffer,\n\t\thasher: hasher,\n\t\tcache:  []byte{},\n\t\ti:      1,\n\t}\n}\n\nfunc (ctx *concatKDF) Read(out []byte) (int, error) {\n\tcopied := copy(out, ctx.cache)\n\tctx.cache = ctx.cache[copied:]\n\n\tfor copied < len(out) {\n\t\tctx.hasher.Reset()\n\n\t\t// Write on a hash.Hash never fails\n\t\t_ = binary.Write(ctx.hasher, binary.BigEndian, ctx.i)\n\t\t_, _ = ctx.hasher.Write(ctx.z)\n\t\t_, _ = ctx.hasher.Write(ctx.info)\n\n\t\thash := ctx.hasher.Sum(nil)\n\t\tchunkCopied := copy(out[copied:], hash)\n\t\tcopied += chunkCopied\n\t\tctx.cache = hash[chunkCopied:]\n\n\t\tctx.i++\n\t}\n\n\treturn copied, nil\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"encoding/binary\"\n)\n\n// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.\n// It is an error to call this function with a private/public key that are not on the same\n// curve. Callers must ensure that the keys are valid before calling this function. Output\n// size may be at most 1<<16 bytes (64 KiB).\nfunc DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {\n\tif size > 1<<16 {\n\t\tpanic(\"ECDH-ES output size too large, must be less than 1<<16\")\n\t}\n\n\t// algId, partyUInfo, partyVInfo inputs must be prefixed with the length\n\talgID := lengthPrefixed([]byte(alg))\n\tptyUInfo := lengthPrefixed(apuData)\n\tptyVInfo := lengthPrefixed(apvData)\n\n\t// suppPubInfo is the encoded length of the output size in bits\n\tsupPubInfo := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)\n\n\tif !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {\n\t\tpanic(\"public key not on same curve as private key\")\n\t}\n\n\tz, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())\n\treader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})\n\n\tkey := make([]byte, size)\n\n\t// Read on the KDF will never fail\n\t_, _ = reader.Read(key)\n\treturn key\n}\n\nfunc lengthPrefixed(data []byte) []byte {\n\tout := make([]byte, len(data)+4)\n\tbinary.BigEndian.PutUint32(out, uint32(len(data)))\n\tcopy(out[4:], data)\n\treturn out\n}\n"], "filenames": ["cipher/cbc_hmac.go", "cipher/cbc_hmac_test.go", "cipher/concat_kdf.go", "cipher/ecdh_es.go"], "buggy_code_start_loc": [85, 286, 35, 27], "buggy_code_end_loc": [172, 318, 36, 28], "fixing_code_start_loc": [85, 286, 35, 27], "fixing_code_end_loc": [172, 318, 36, 34], "type": "CWE-190", "message": "go-jose before 1.0.5 suffers from a CBC-HMAC integer overflow on 32-bit architectures. An integer overflow could lead to authentication bypass for CBC-HMAC encrypted ciphertexts on 32-bit architectures.", "other": {"cve": {"id": "CVE-2016-9123", "sourceIdentifier": "support@hackerone.com", "published": "2017-03-28T02:59:00.293", "lastModified": "2017-03-29T17:05:40.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "go-jose before 1.0.5 suffers from a CBC-HMAC integer overflow on 32-bit architectures. An integer overflow could lead to authentication bypass for CBC-HMAC encrypted ciphertexts on 32-bit architectures."}, {"lang": "es", "value": "go-jose en versiones anteriores a 1.0.5 sufre un desbordamiento de enteros CBC-HMAC en arquitecturas de 32 bits. Un desbordamiento de entero podr\u00eda dar lugar a la derivaci\u00f3n de autenticaci\u00f3n para cifrado ciphertexts CBC-HMAC en las arquitecturas de 32 bits."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-jose_project:go-jose:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.4", "matchCriteriaId": "FFFD54A7-086B-46F8-B276-D62B7333D870"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/03/1", "source": "support@hackerone.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/square/go-jose/commit/789a4c4bd4c118f7564954f441b29c153ccd6a96", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/165170", "source": "support@hackerone.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/square/go-jose/commit/789a4c4bd4c118f7564954f441b29c153ccd6a96"}}