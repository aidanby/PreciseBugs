{"buggy_code": ["# 1.7.1\n\n## Security\n\n- CVE-2023-50246: ....\n- CVE-2023-50268: ....\n\n## CLI changes\n\n- Make the default background color more suitable for bright backgrounds. @mjarosie @taoky @nicowilliams @itchyny #2904\n- Allow passing the inline jq script after `--`. @emanuele6 #2919\n- Restrict systems operations on OpenBSD and remove unused `mkstemp`. @klemensn #2934\n- Fix possible uninitialised value dereference if `jq_init()` fails. @emanuele6 @nicowilliams #2935\n\n## Language changes\n\n- Simplify `paths/0` and `paths/1`. @asheiduk @emanuele6 #2946\n- Reject `U+001F` in string literals. @torsten-schenk @itchyny @wader #2911\n- Remove unused nref accumulator in `block_bind_library`. @emanuele6 #2914\n- Remove a bunch of unused variables, and useless assignments. @emanuele6 #2914\n- main.c: Remove unused EXIT\\_STATUS\\_EXACT option. @emanuele6 #2915\n- Actually use the number correctly casted from double to int as index. @emanuele6 #2916\n- src/builtin.c: remove unnecessary jv\\_copy-s in type\\_error/type\\_error2. @emanuele6 #2937\n- Remove undefined behavior caught by LLVM 10 UBSAN. @Gaelan @emanuele6 #2926\n- Convert decnum to binary64 (double) instead of decimal64. This makes jq behave like the JSON specification suggests and more similar to other languages. @wader @leonid-s-usov #2949\n- Fix memory leaks on invalid input for `ltrimstr/1` and `rtrimstr/1`. @emanuele6 #2977\n- Fix memory leak on failed get for `setpath/2`. @emanuele6 #2970\n- Fix nan from json parsing also for nans with payload that start with 'n'. @emanuele6 #2985\n- Allow carriage return characters in comments. @emanuele6 #2942 #2984\n\n## Documentation changes\n\n- Generate links in the man page. @emanuele6 #2931\n- Standardize arch types to AMD64 & ARM64 from index page download dropdown. @owenthereal #2884\n\n## libjq\n\n- Add extern C for C++. @rockwotj #2953\n\n## Build and test changes\n\n- Fix incorrect syntax for checksum file. @kamontat @wader #2899\n- Remove `-dirty` version suffix for windows release build. @itchyny #2888\n- Make use of `od` in tests more compatible. @nabijaczleweli @emanuele6 @nicowilliams #2922\n- Add dependabot. @yeikel #2889\n- Extend fuzzing setup to fuzz parser and and JSON serializer. @DavidKorczynski @emanuele6 #2952\n- Keep releasing executables with legacy names. @itchyny #2951\n\n# 1.7\n\nAfter a five year hiatus we're back with a GitHub organization, with new admins and new maintainers who have brought a great deal of energy to make a long-awaited and long-needed new release.  We're very grateful for all the new owners, admins, and maintainers.  Special thanks go to Owen Ou (@owenthereal) for pushing to set up a new GitHub organization for jq, Stephen Dolan (@stedolan) for transferring the jq repository to the new organization, @itchyny for doing a great deal of work to get the release done, Mattias Wadman (@wader) and Emanuele Torre (@emanuele6) for many PRs and code reviews.  Many others also contributed PRs, issues, and code reviews as well, and you can find their contributions in the Git log and on the [closed issues and PRs page](https://github.com/jqlang/jq/issues?q=is%3Aclosed+sort%3Aupdated-desc).\n\nSince the last stable release many things have happened:\n\n- jq now lives at <https://github.com/jqlang>\n- New maintainers, admins, and owners have been recruited.\n  - A list of [current maintainers](https://github.com/jqlang/jq/blob/jq-1.7/AUTHORS#L4-L14)\n- NEWS file is replaced by NEWS.md with Markdown format. @wader #2599\n- CI, scan builds, release, website builds etc now use GitHub actions. @owenthereal @wader @itchyny #2596 #2603 #2620 #2723\n- Lots of documentation improvements and fixes.\n- Website updated with new section search box, better section ids for linking, dark mode, etc. @itchyny #2628\n- Release builds for:\n  - Linux `amd64`, `arm64`, `armel`, `armhf`, `i386`, `mips`, `mips64`, `mips64el`, `mips64r6`, `mips64r6el`, `mipsel`, `mipsr6`, `mipsr6el`, `powerpc`, `ppc64el`, `riscv64` and `s390x`\n  - macOS `amd64` and `arm64`\n  - Windows `i386` and `amd64`\n  - Docker `linux/386`, `linux/amd64`, `linux/arm64`, `linux/mips64le`, `linux/ppc64le`, `linux/riscv64` and `linux/s390x`\n  - More details see @owenthereal #2665\n- Docker images are now available from `ghcr.io/jqlang/jq` instead of Docker Hub. @itchyny #2652 #2686\n- OSS-fuzz. @DavidKorczynski #2760 #2762\n\nFull commit log can be found at <https://github.com/jqlang/jq/compare/jq-1.6...jq-1.7> but here are some highlights:\n\n## CLI changes\n\n- Make object key color configurable using `JQ_COLORS` environment variable. @itchyny @haguenau @ericpruitt #2703\n\n  ```sh\n  # this would make \"field\" bold yellow (`1;33`, the last value)\n  $ JQ_COLORS=\"0;90:0;37:0;37:0;37:0;32:1;37:1;37:1;33\" ./jq -n '{field: 123}'\n  {\n    \"field\": 123\n  }\n  ```\n\n- Change the default color of null to Bright Black. @itchyny #2824\n- Respect `NO_COLOR` environment variable to disable color output. See <https://no-color.org> for details. @itchyny #2728\n- Improved `--help` output. Now mentions all options and nicer order. @itchyny @wader #2747 #2766 #2799\n- Fix multiple issues of exit code using `--exit-code`/`-e` option. @ryo1kato #1697\n\n  ```sh\n  # true-ish last output value exits with zero\n  $ jq -ne true ; echo $?\n  true\n  0\n  # false-ish last output value (false and null) exits with 1\n  $ jq -ne false ; echo $?\n  false\n  1\n  # no output value exists with 4\n  $ jq -ne empty ; echo $?\n  4\n  ```\n\n- Add `--binary`/`-b` on Windows for binary output. To get `\\n` instead of `\\r\\n` line endings. @nicowilliams 0dab2b1\n- Add `--raw-output0` for NUL (zero byte) separated output. @asottile @pabs3 @itchyny #1990 #2235 #2684\n\n  ```sh\n  # will output a zero byte after each output\n  $ jq -n --raw-output0 '1,2,3' | xxd\n  00000000: 3100 3200 3300                           1.2.3.\n  # can be used with xargs -0\n  $ jq -n --raw-output0 '\"a\",\"b\",\"c\"' | xargs -0 -n1\n  a\n  b\n  c\n  $ jq -n --raw-output0 '\"a b c\", \"d\\ne\\nf\"' | xargs -0 printf '[%s]\\n'\n  [a b c]\n  [d\n  e\n  f]\n  # can be used with read -d ''\n  $ while IFS= read -r -d '' json; do\n  >   jq '.name' <<< \"$json\"\n  > done < <(jq -n --raw-output0 '{name:\"a b c\"},{name:\"d\\ne\\nf\"}')\n  \"a b c\"\n  \"d\\ne\\nf\"\n  # also it's an error to output a string containing a NUL when using NUL separator\n  $ jq -n --raw-output0 '\"\\u0000\"'\n  jq: error (at <unknown>): Cannot dump a string containing NUL with --raw-output0 option\n  ```\n\n- Fix assert crash and validate JSON for `--jsonarg`. @wader #2658\n- Remove deprecated `--argfile` option. @itchyny #2768\n- Enable stack protection. @nicowilliams #2801\n\n## Language changes\n\n- Use decimal number literals to preserve precision. Comparison operations respects precision but arithmetic operations might truncate. @leonid-s-usov #1752\n\n  ```sh\n  # precision is preserved\n  $ echo '100000000000000000' | jq .\n  100000000000000000\n  # comparison respects precision (this is false in JavaScript)\n  $ jq -n '100000000000000000 < 100000000000000001'\n  true\n  # sort/0 works\n  $ jq -n -c '[100000000000000001, 100000000000000003, 100000000000000004, 100000000000000002] | sort'\n  [100000000000000001,100000000000000002,100000000000000003,100000000000000004]\n  # arithmetic operations might truncate (same as JavaScript)\n  $ jq -n '100000000000000000 + 10'\n  100000000000000020\n  ```\n\n- Adds new builtin `pick(stream)` to emit a projection of the input object or array. @pkoppstein #2656 #2779\n\n  ```sh\n  $ jq -n '{\"a\": 1, \"b\": {\"c\": 2, \"d\": 3}, \"e\": 4} | pick(.a, .b.c, .x)'\n  {\n    \"a\": 1,\n    \"b\": {\n      \"c\": 2\n    },\n    \"x\": null\n  }\n  ```\n\n- Adds new builtin `debug(msgs)` that works like `debug` but applies a filter on the input before writing to stderr. @pkoppstein #2710\n\n  ```sh\n  $ jq -n '1 as $x | 2 | debug(\"Entering function foo with $x == \\($x)\", .) | (.+1)'\n  [\"DEBUG:\",\"Entering function foo with $x == 1\"]\n  [\"DEBUG:\",2]\n  3\n  $ jq -n '{a: 1, b: 2, c: 3} | debug({a, b, sum: (.a+.b)})'\n  [\"DEBUG:\",{\"a\":1,\"b\":2,\"sum\":3}]\n  {\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": 3\n  }\n  ```\n\n- Adds new builtin `scan($re; $flags)`. Was documented but not implemented. @itchyny #1961\n\n  ```sh\n  # look for pattern \"ab\" in \"abAB\" ignoring casing\n  $ jq -n '\"abAB\" | scan(\"ab\"; \"i\")'\n  \"ab\"\n  \"AB\"\n  ```\n\n- Adds new builtin `abs` to get absolute value. This potentially allows the literal value of numbers to be preserved as `length` and `fabs` convert to float. @pkoppstein #2767\n- Allow `if` without `else`-branch. When skipped the `else`-branch will be `.` (identity). @chancez @wader #1825 #2481\n\n  ```sh\n  # convert 1 to \"one\" otherwise keep as is\n  $ jq -n '1,2 | if . == 1 then \"one\" end'\n  \"one\"\n  2\n  # behaves the same as\n  $ jq -n '1,2 | if . == 1 then \"one\" else . end'\n  \"one\"\n  2\n  # also works with elif\n  $ jq -n '1,2,3 | if . == 1 then \"one\" elif . == 2 then \"two\" end\n  \"one\"\n  \"two\"\n  3\n  ```\n\n- Allow use of `$binding` as key in object literals. @nicowilliams 8ea4a55\n\n  ```sh\n  $ jq -n '\"a\" as $key | {$key: 123}'\n  {\n    \"a\": 123\n  }\n  # previously parentheses were needed\n  $ jq -n '\"a\" as $key | {($key): 123}'\n  {\n    \"a\": 123\n  }\n  ```\n\n- Allow dot between chained indexes when using `.[\"index\"]` @nicowilliams #1168\n\n  ```sh\n  $ jq -n '{\"a\": {\"b\": 123}} | .a[\"b\"]'\n  123\n  # now this also works\n  $ jq -n '{\"a\": {\"b\": 123}} | .a.[\"b\"]'\n  123\n  ```\n\n- Allow dot for chained value iterator `.[]`, `.[]?` @wader #2650\n\n  ```sh\n  $ jq -n '{\"a\": [123]} | .a[]'\n  123\n  # now this also works\n  $ jq -n '{\"a\": [123]} | .a.[]'\n  123\n  ```\n\n- Fix try/catch catches more than it should. @nicowilliams #2750\n- Speed up and refactor some builtins, also remove `scalars_or_empty/0`. @muhmuhten #1845\n- Now `halt` and `halt_error` exit immediately instead of continuing to the next input. @emanuele6 #2667\n- Fix issue converting string to number after previous convert error. @thalman #2400\n- Fix issue representing large numbers on some platforms causing invalid JSON output. @itchyny #2661\n- Fix deletion using assigning empty against arrays. @itchyny #2133\n\n  ```sh\n  # now this works as expected, filter out all values over 2 by assigning empty\n  $ jq -c '(.[] | select(. >= 2)) |= empty' <<< '[1,5,3,0,7]'\n  [1,0]\n  ```\n\n- Allow keywords to be used as binding name in more places. @emanuele6 #2681\n- Allow using `nan` as NaN in JSON. @emanuele6 #2712\n- Expose a module's function names in `modulemeta`. @mrwilson #2837\n- Fix `contains/1` to handle strings with NUL. @nicowilliams 61cd6db\n- Fix `stderr/0` to output raw text without any decoration. @itchyny #2751\n- Fix `nth/2` to emit empty on index out of range. @itchyny #2674\n- Fix `implode` to not assert and instead replace invalid unicode codepoints. @wader #2646\n- Fix `indices/1` and `rindex/1` in case of overlapping matches in strings. @emanuele6 #2718\n- Fix `sub/3` to resolve issues involving global search-and-replace (gsub) operations. @pkoppstein #2641\n- Fix `significand/0`, `gamma/0` and `drem/2` to be available on macOS. @itchyny #2756 #2775\n- Fix empty regular expression matches. @itchyny #2677\n- Fix overflow exception of the modulo operator. @itchyny #2629\n- Fix string multiplication by 0 (and less than 1) to emit empty string. @itchyny #2142\n- Fix segfault when using libjq and threads. @thalman #2546\n- Fix constant folding of division and reminder with zero divisor. @itchyny #2797\n- Fix `error/0`, `error/1` to throw null error. @emanuele6 #2823\n- Simpler and faster `transpose`. @pkoppstein #2758\n- Simple and efficient implementation of `walk/1`. @pkoppstein #2795\n- Remove deprecated filters `leaf_paths`, `recurse_down`. @itchyny #2666\n\n# Previous releases\n\nRelease history\n\n- jq version 1.6 was released on Fri Nov 2 2018\n- jq version 1.5 was released on Sat Aug 15 2015\n- jq version 1.4 was released on Mon Jun 9 2014\n- jq version 1.3 was released on Sun May 19 2013\n- jq version 1.2 was released on Thu Dec 20 2012\n- jq version 1.1 was released on Sun Oct 21 2012\n- jq version 1.0 was released on Sun Oct 21 2012\n\nNew features in 1.6 since 1.5:\n\n- Destructuring Alternation\n\n- New Builtins:\n  - builtins/0\n  - stderr/0\n  - halt/0, halt_error/1\n  - isempty/1\n  - walk/1\n  - utf8bytelength/1\n  - localtime/0, strflocaltime/1\n  - SQL-style builtins\n  - and more!\n\n- Add support for ASAN and UBSAN\n\n- Make it easier to use jq with shebangs (8f6f28c)\n\n- Add $ENV builtin variable to access environment\n\n- Add JQ_COLORS env var for configuring the output colors\n\nNew features in 1.5 since 1.4:\n\n- regular expressions (with Oniguruma)\n\n- a library/module system\n\n- many new builtins\n\n  - datetime builtins\n  - math builtins\n  - regexp-related builtins\n  - stream-related builtins (e.g., all/1, any/1)\n  - minimal I/O builtins (`inputs`, `debug`)\n\n- new syntactic features, including:\n\n  - destructuring (`. as [$first, $second] | ...`)\n  - try/catch, generalized `?` operator, and label/break\n  - `foreach`\n  - multiple definitions of a function with different numbers of\n      arguments\n\n- command-line arguments\n\n  - --join-lines / -j for raw output\n  - --argjson and --slurpfile\n  - --tab and --indent\n  - --stream (streaming JSON parser)\n  - --seq (RFC7464 JSON text sequence)\n  - --run-tests improvements\n\n- optimizations:\n\n  - tail-call optimization\n  - reduce and foreach no longer leak a reference to .\n\nNew features in 1.4 since 1.3:\n\n- command-line arguments\n\n  - jq --arg-file variable file\n  - jq --unbuffered\n  - jq -e / --exit-status (set exit status based on outputs)\n  - jq -S / --sort-keys (now jq no longer sorts object keys by\n      default\n\n- syntax\n\n  - .. -> like // in XPath (recursive traversal)\n  - question mark (e.g., .a?) to suppress errors\n  - .\"foo\" syntax (equivalent to .[\"foo\"])\n  - better error handling for .foo\n  - added % operator (modulo)\n  - allow negation without requiring extra parenthesis\n  - more function arguments (up to six)\n\n- filters:\n\n  - any, all\n  - iterables, arrays, objects, scalars, nulls, booleans, numbers,\n      strings, values\n\n- string built-ins:\n\n  - split\n  - join (join an array of strings with a given separator string)\n  - ltrimstr, rtrimstr\n  - startswith, endswith\n  - explode, implode\n  - fromjson, tojson\n  - index, rindex, indices\n\n- math functions\n\n  - floor, sqrt, cbrt, etcetera (depends on what's available from libm)\n\n- libjq -- a C API interface to jq's JSON representation and for\n   running jq programs from C applications\n", "/*\n * Portions Copyright (c) 2016 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n#include <stddef.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n\n#include \"jv_alloc.h\"\n#include \"jv.h\"\n#include \"jv_unicode.h\"\n#include \"util.h\"\n\n/*\n * Internal refcounting helpers\n */\n\ntypedef struct jv_refcnt {\n  int count;\n} jv_refcnt;\n\nstatic const jv_refcnt JV_REFCNT_INIT = {1};\n\nstatic void jvp_refcnt_inc(jv_refcnt* c) {\n  c->count++;\n}\n\nstatic int jvp_refcnt_dec(jv_refcnt* c) {\n  c->count--;\n  return c->count == 0;\n}\n\nstatic int jvp_refcnt_unshared(jv_refcnt* c) {\n  assert(c->count > 0);\n  return c->count == 1;\n}\n\n#define KIND_MASK   0xF\n#define PFLAGS_MASK 0xF0\n#define PTYPE_MASK  0x70\n\ntypedef enum {\n  JVP_PAYLOAD_NONE = 0,\n  JVP_PAYLOAD_ALLOCATED = 0x80,\n} payload_flags;\n\n#define JVP_MAKE_PFLAGS(ptype, allocated) ((((ptype) << 4) & PTYPE_MASK) | ((allocated) ? JVP_PAYLOAD_ALLOCATED : 0))\n#define JVP_MAKE_FLAGS(kind, pflags) ((kind & KIND_MASK) | (pflags & PFLAGS_MASK))\n\n#define JVP_FLAGS(j)  ((j).kind_flags)\n#define JVP_KIND(j)   (JVP_FLAGS(j) & KIND_MASK)\n\n#define JVP_HAS_FLAGS(j, flags) (JVP_FLAGS(j) == flags)\n#define JVP_HAS_KIND(j, kind)   (JVP_KIND(j) == kind)\n\n#define JVP_IS_ALLOCATED(j) (j.kind_flags & JVP_PAYLOAD_ALLOCATED)\n\n#define JVP_FLAGS_NULL      JVP_MAKE_FLAGS(JV_KIND_NULL, JVP_PAYLOAD_NONE)\n#define JVP_FLAGS_INVALID   JVP_MAKE_FLAGS(JV_KIND_INVALID, JVP_PAYLOAD_NONE)\n#define JVP_FLAGS_FALSE     JVP_MAKE_FLAGS(JV_KIND_FALSE, JVP_PAYLOAD_NONE)\n#define JVP_FLAGS_TRUE      JVP_MAKE_FLAGS(JV_KIND_TRUE, JVP_PAYLOAD_NONE)\n\njv_kind jv_get_kind(jv x) {\n  return JVP_KIND(x);\n}\n\nconst char* jv_kind_name(jv_kind k) {\n  switch (k) {\n  case JV_KIND_INVALID: return \"<invalid>\";\n  case JV_KIND_NULL:    return \"null\";\n  case JV_KIND_FALSE:   return \"boolean\";\n  case JV_KIND_TRUE:    return \"boolean\";\n  case JV_KIND_NUMBER:  return \"number\";\n  case JV_KIND_STRING:  return \"string\";\n  case JV_KIND_ARRAY:   return \"array\";\n  case JV_KIND_OBJECT:  return \"object\";\n  }\n  assert(0 && \"invalid kind\");\n  return \"<unknown>\";\n}\n\nconst jv JV_NULL = {JVP_FLAGS_NULL, 0, 0, 0, {0}};\nconst jv JV_INVALID = {JVP_FLAGS_INVALID, 0, 0, 0, {0}};\nconst jv JV_FALSE = {JVP_FLAGS_FALSE, 0, 0, 0, {0}};\nconst jv JV_TRUE = {JVP_FLAGS_TRUE, 0, 0, 0, {0}};\n\njv jv_true() {\n  return JV_TRUE;\n}\n\njv jv_false() {\n  return JV_FALSE;\n}\n\njv jv_null() {\n  return JV_NULL;\n}\n\njv jv_bool(int x) {\n  return x ? JV_TRUE : JV_FALSE;\n}\n\n/*\n * Invalid objects, with optional error messages\n */\n\n#define JVP_FLAGS_INVALID_MSG   JVP_MAKE_FLAGS(JV_KIND_INVALID, JVP_PAYLOAD_ALLOCATED)\n\ntypedef struct {\n  jv_refcnt refcnt;\n  jv errmsg;\n} jvp_invalid;\n\njv jv_invalid_with_msg(jv err) {\n  jvp_invalid* i = jv_mem_alloc(sizeof(jvp_invalid));\n  i->refcnt = JV_REFCNT_INIT;\n  i->errmsg = err;\n\n  jv x = {JVP_FLAGS_INVALID_MSG, 0, 0, 0, {&i->refcnt}};\n  return x;\n}\n\njv jv_invalid() {\n  return JV_INVALID;\n}\n\njv jv_invalid_get_msg(jv inv) {\n  assert(JVP_HAS_KIND(inv, JV_KIND_INVALID));\n\n  jv x;\n  if (JVP_HAS_FLAGS(inv, JVP_FLAGS_INVALID_MSG)) {\n    x = jv_copy(((jvp_invalid*)inv.u.ptr)->errmsg);\n  }\n  else {\n    x = jv_null();\n  }\n\n  jv_free(inv);\n  return x;\n}\n\nint jv_invalid_has_msg(jv inv) {\n  assert(JVP_HAS_KIND(inv, JV_KIND_INVALID));\n  int r = JVP_HAS_FLAGS(inv, JVP_FLAGS_INVALID_MSG);\n  jv_free(inv);\n  return r;\n}\n\nstatic void jvp_invalid_free(jv x) {\n  assert(JVP_HAS_KIND(x, JV_KIND_INVALID));\n  if (JVP_HAS_FLAGS(x, JVP_FLAGS_INVALID_MSG) && jvp_refcnt_dec(x.u.ptr)) {\n    jv_free(((jvp_invalid*)x.u.ptr)->errmsg);\n    jv_mem_free(x.u.ptr);\n  }\n}\n\n/*\n * Numbers\n */\n\n#ifdef USE_DECNUM\n#include \"jv_dtoa.h\"\n#include \"jv_dtoa_tsd.h\"\n\n// we will manage the space for the struct\n#define DECNUMDIGITS 1\n#include \"decNumber/decNumber.h\"\n\nenum {\n  JVP_NUMBER_NATIVE = 0,\n  JVP_NUMBER_DECIMAL = 1\n};\n\n#define JV_NUMBER_SIZE_INIT      (0)\n#define JV_NUMBER_SIZE_CONVERTED (1)\n\n#define JVP_FLAGS_NUMBER_NATIVE       JVP_MAKE_FLAGS(JV_KIND_NUMBER, JVP_MAKE_PFLAGS(JVP_NUMBER_NATIVE, 0))\n#define JVP_FLAGS_NUMBER_LITERAL      JVP_MAKE_FLAGS(JV_KIND_NUMBER, JVP_MAKE_PFLAGS(JVP_NUMBER_DECIMAL, 1))\n\n// the decimal precision of binary double\n#define DEC_NUBMER_DOUBLE_PRECISION   (17)\n#define DEC_NUMBER_STRING_GUARD       (14)\n#define DEC_NUBMER_DOUBLE_EXTRA_UNITS ((DEC_NUBMER_DOUBLE_PRECISION - DECNUMDIGITS + DECDPUN - 1)/DECDPUN)\n\n#include \"jv_thread.h\"\n#ifdef WIN32\n#ifndef __MINGW32__\n/* Copied from Heimdal: thread-specific keys; see lib/base/dll.c in Heimdal */\n\n/*\n * This is an implementation of thread-specific storage with\n * destructors.  WIN32 doesn't quite have this.  Instead it has\n * DllMain(), an entry point in every DLL that gets called to notify the\n * DLL of thread/process \"attach\"/\"detach\" events.\n *\n * We use __thread (or __declspec(thread)) for the thread-local itself\n * and DllMain() DLL_THREAD_DETACH events to drive destruction of\n * thread-local values.\n *\n * When building in maintainer mode on non-Windows pthread systems this\n * uses a single pthread key instead to implement multiple keys.  This\n * keeps the code from rotting when modified by non-Windows developers.\n */\n\n/* Logical array of keys that grows lock-lessly */\ntypedef struct tls_keys tls_keys;\nstruct tls_keys {\n    void (**keys_dtors)(void *);    /* array of destructors         */\n    size_t keys_start_idx;          /* index of first destructor    */\n    size_t keys_num;\n    tls_keys *keys_next;\n};\n\n/*\n * Well, not quite locklessly.  We need synchronization primitives to do\n * this locklessly.  An atomic CAS will do.\n */\nstatic pthread_mutex_t tls_key_defs_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic tls_keys *tls_key_defs;\n\n/* Logical array of values (per-thread; no locking needed here) */\nstruct tls_values {\n    void **values; /* realloc()ed */\n    size_t values_num;\n};\n\n#ifdef _MSC_VER\nstatic __declspec(thread) struct nomem_handler nomem_handler;\n#else\nstatic __thread struct tls_values values;\n#endif\n\n#define DEAD_KEY ((void *)8)\n\nstatic void\nw32_service_thread_detach(void *unused)\n{\n    tls_keys *key_defs;\n    void (*dtor)(void*);\n    size_t i;\n\n    pthread_mutex_lock(&tls_key_defs_lock);\n    key_defs = tls_key_defs;\n    pthread_mutex_unlock(&tls_key_defs_lock);\n\n    if (key_defs == NULL)\n        return;\n\n    for (i = 0; i < values.values_num; i++) {\n        assert(i >= key_defs->keys_start_idx);\n        if (i >= key_defs->keys_start_idx + key_defs->keys_num) {\n            pthread_mutex_lock(&tls_key_defs_lock);\n            key_defs = key_defs->keys_next;\n            pthread_mutex_unlock(&tls_key_defs_lock);\n\n            assert(key_defs != NULL);\n            assert(i >= key_defs->keys_start_idx);\n            assert(i < key_defs->keys_start_idx + key_defs->keys_num);\n        }\n        dtor = key_defs->keys_dtors[i - key_defs->keys_start_idx];\n        if (values.values[i] != NULL && dtor != NULL && dtor != DEAD_KEY)\n            dtor(values.values[i]);\n        values.values[i] = NULL;\n    }\n}\n\nextern void jv_tsd_dtoa_ctx_init();\nextern void jv_tsd_dtoa_ctx_fini();\nvoid jv_tsd_dec_ctx_fini();\nvoid jv_tsd_dec_ctx_init();\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL,\n                    DWORD fdwReason,\n                    LPVOID lpvReserved)\n{\n    switch (fdwReason) {\n    case DLL_PROCESS_ATTACH:\n\t/*create_pt_key();*/\n\tjv_tsd_dtoa_ctx_init();\n\tjv_tsd_dec_ctx_init();\n\treturn TRUE;\n    case DLL_PROCESS_DETACH:\n\tjv_tsd_dtoa_ctx_fini();\n\tjv_tsd_dec_ctx_fini();\n\treturn TRUE;\n    case DLL_THREAD_ATTACH: return 0;\n    case DLL_THREAD_DETACH:\n        w32_service_thread_detach(NULL);\n        return TRUE;\n    default: return TRUE;\n    }\n}\n\nint\npthread_key_create(pthread_key_t *key, void (*dtor)(void *))\n{\n    tls_keys *key_defs, *new_key_defs;\n    size_t i, k;\n    int ret = ENOMEM;\n\n    pthread_mutex_lock(&tls_key_defs_lock);\n    if (tls_key_defs == NULL) {\n        /* First key */\n        new_key_defs = calloc(1, sizeof(*new_key_defs));\n        if (new_key_defs == NULL) {\n            pthread_mutex_unlock(&tls_key_defs_lock);\n            return ENOMEM;\n        }\n        new_key_defs->keys_num = 8;\n        new_key_defs->keys_dtors = calloc(new_key_defs->keys_num,\n                                          sizeof(*new_key_defs->keys_dtors));\n        if (new_key_defs->keys_dtors == NULL) {\n            pthread_mutex_unlock(&tls_key_defs_lock);\n            free(new_key_defs);\n            return ENOMEM;\n        }\n        tls_key_defs = new_key_defs;\n        new_key_defs->keys_dtors[0] = dtor;\n        for (i = 1; i < new_key_defs->keys_num; i++)\n            new_key_defs->keys_dtors[i] = NULL;\n        pthread_mutex_unlock(&tls_key_defs_lock);\n        return 0;\n    }\n\n    for (key_defs = tls_key_defs;\n         key_defs != NULL;\n         key_defs = key_defs->keys_next) {\n        k = key_defs->keys_start_idx;\n        for (i = 0; i < key_defs->keys_num; i++, k++) {\n            if (key_defs->keys_dtors[i] == NULL) {\n                /* Found free slot; use it */\n                key_defs->keys_dtors[i] = dtor;\n                *key = k;\n                pthread_mutex_unlock(&tls_key_defs_lock);\n                return 0;\n            }\n        }\n        if (key_defs->keys_next != NULL)\n            continue;\n\n        /* Grow the registration array */\n        /* XXX DRY */\n        new_key_defs = calloc(1, sizeof(*new_key_defs));\n        if (new_key_defs == NULL)\n            break;\n\n        new_key_defs->keys_dtors =\n            calloc(key_defs->keys_num + key_defs->keys_num / 2,\n                   sizeof(*new_key_defs->keys_dtors));\n        if (new_key_defs->keys_dtors == NULL) {\n            free(new_key_defs);\n            break;\n        }\n        new_key_defs->keys_start_idx = key_defs->keys_start_idx +\n            key_defs->keys_num;\n        new_key_defs->keys_num = key_defs->keys_num + key_defs->keys_num / 2;\n        new_key_defs->keys_dtors[i] = dtor;\n        for (i = 1; i < new_key_defs->keys_num; i++)\n            new_key_defs->keys_dtors[i] = NULL;\n        key_defs->keys_next = new_key_defs;\n        ret = 0;\n        break;\n    }\n    pthread_mutex_unlock(&tls_key_defs_lock);\n    return ret;\n}\n\nstatic void\nkey_lookup(pthread_key_t key, tls_keys **kd,\n           size_t *dtor_idx, void (**dtor)(void *))\n{\n    tls_keys *key_defs;\n\n    if (kd != NULL)\n        *kd = NULL;\n    if (dtor_idx != NULL)\n        *dtor_idx = 0;\n    if (dtor != NULL)\n        *dtor = NULL;\n\n    pthread_mutex_lock(&tls_key_defs_lock);\n    key_defs = tls_key_defs;\n    pthread_mutex_unlock(&tls_key_defs_lock);\n\n    while (key_defs != NULL) {\n        if (key >= key_defs->keys_start_idx &&\n            key < key_defs->keys_start_idx + key_defs->keys_num) {\n            if (kd != NULL)\n                *kd = key_defs;\n            if (dtor_idx != NULL)\n                *dtor_idx = key - key_defs->keys_start_idx;\n            if (dtor != NULL)\n                *dtor = key_defs->keys_dtors[key - key_defs->keys_start_idx];\n            return;\n        }\n\n        pthread_mutex_lock(&tls_key_defs_lock);\n        key_defs = key_defs->keys_next;\n        pthread_mutex_unlock(&tls_key_defs_lock);\n        assert(key_defs != NULL);\n        assert(key >= key_defs->keys_start_idx);\n    }\n}\n\nint\npthread_setspecific(pthread_key_t key, void *value)\n{\n    void **new_values;\n    size_t new_num;\n    void (*dtor)(void *);\n    size_t i;\n\n    key_lookup(key, NULL, NULL, &dtor);\n    if (dtor == NULL)\n        return EINVAL;\n\n    if (key >= values.values_num) {\n        if (values.values_num == 0) {\n            values.values = NULL;\n            new_num = 8;\n        } else {\n            new_num = (values.values_num + values.values_num / 2);\n        }\n        new_values = realloc(values.values, sizeof(void *) * new_num);\n        if (new_values == NULL)\n            return ENOMEM;\n        for (i = values.values_num; i < new_num; i++)\n            new_values[i] = NULL;\n        values.values = new_values;\n        values.values_num = new_num;\n    }\n\n    assert(key < values.values_num);\n\n    if (values.values[key] != NULL && dtor != NULL && dtor != DEAD_KEY)\n        dtor(values.values[key]);\n\n    values.values[key] = value;\n    return 0;\n}\n\nvoid *\npthread_getspecific(pthread_key_t key)\n{\n    if (key >= values.values_num)\n        return NULL;\n    return values.values[key];\n}\n#else\n#include <pthread.h>\n#endif\n#else\n#include <pthread.h>\n#endif\n\nstatic pthread_key_t dec_ctx_key;\nstatic pthread_once_t dec_ctx_once = PTHREAD_ONCE_INIT;\n\n#define DEC_CONTEXT() tsd_dec_ctx_get(&dec_ctx_key)\n\n// atexit finalizer to clean up the tsd dec contexts if main() exits\n// without having called pthread_exit()\nvoid jv_tsd_dec_ctx_fini() {\n  jv_mem_free(pthread_getspecific(dec_ctx_key));\n  pthread_setspecific(dec_ctx_key, NULL);\n}\n\nvoid jv_tsd_dec_ctx_init() {\n  if (pthread_key_create(&dec_ctx_key, jv_mem_free) != 0) {\n    fprintf(stderr, \"error: cannot create thread specific key\");\n    abort();\n  }\n  atexit(jv_tsd_dec_ctx_fini);\n}\n\nstatic decContext* tsd_dec_ctx_get(pthread_key_t *key) {\n  pthread_once(&dec_ctx_once, jv_tsd_dec_ctx_init); // cannot fail\n  decContext *ctx = (decContext*)pthread_getspecific(*key);\n  if (ctx) {\n    return ctx;\n  }\n\n  ctx = malloc(sizeof(decContext));\n  if (ctx) {\n    if (key == &dec_ctx_key)\n    {\n      decContextDefault(ctx, DEC_INIT_BASE);\n      // make sure (Int)D2U(rhs->exponent-lhs->exponent) does not overflow\n      ctx->digits = MIN(DEC_MAX_DIGITS,\n          INT32_MAX - (DECDPUN - 1) - (ctx->emax - ctx->emin - 1));\n      ctx->traps = 0; /*no errors*/\n    }\n    if (pthread_setspecific(*key, ctx) != 0) {\n      fprintf(stderr, \"error: cannot store thread specific data\");\n      abort();\n    }\n  }\n  return ctx;\n}\n\ntypedef struct {\n  jv_refcnt refcnt;\n  double num_double;\n  char * literal_data;\n  decNumber num_decimal; // must be the last field in the structure for memory management\n} jvp_literal_number;\n\ntypedef struct {\n  decNumber number;\n  decNumberUnit units[DEC_NUBMER_DOUBLE_EXTRA_UNITS];\n} decNumberDoublePrecision;\n\n\nstatic inline int jvp_number_is_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n  return JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL);\n}\n\nstatic jvp_literal_number* jvp_literal_number_ptr(jv j) {\n  assert(JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL));\n  return (jvp_literal_number*)j.u.ptr;\n}\n\nstatic decNumber* jvp_dec_number_ptr(jv j) {\n  assert(JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL));\n  return &(((jvp_literal_number*)j.u.ptr)->num_decimal);\n}\n\nstatic jvp_literal_number* jvp_literal_number_alloc(unsigned literal_length) {\n\n  /* The number of units needed is ceil(DECNUMDIGITS/DECDPUN)         */\n  int units = ((literal_length+DECDPUN-1)/DECDPUN);\n\n  jvp_literal_number* n = jv_mem_alloc(\n    sizeof(jvp_literal_number)\n    + sizeof(decNumberUnit) * units\n  );\n\n  return n;\n}\n\nstatic jv jvp_literal_number_new(const char * literal) {\n\n  jvp_literal_number * n = jvp_literal_number_alloc(strlen(literal));\n\n  n->refcnt = JV_REFCNT_INIT;\n  n->literal_data = NULL;\n  decContext *ctx = DEC_CONTEXT();\n  decContextClearStatus(ctx, DEC_Conversion_syntax);\n  decNumberFromString(&n->num_decimal, literal, ctx);\n  n->num_double = NAN;\n\n  if (ctx->status & DEC_Conversion_syntax) {\n    jv_mem_free(n);\n    return JV_INVALID;\n  }\n\n  jv r = {JVP_FLAGS_NUMBER_LITERAL, 0, 0, JV_NUMBER_SIZE_INIT, {&n->refcnt}};\n  return r;\n}\n\nstatic double jvp_literal_number_to_double(jv j) {\n  assert(JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL));\n  decContext dblCtx;\n\n  // init as decimal64 but change digits to allow conversion to binary64 (double)\n  decContextDefault(&dblCtx, DEC_INIT_DECIMAL64);\n  dblCtx.digits = DEC_NUBMER_DOUBLE_PRECISION;\n\n  decNumber *p_dec_number = jvp_dec_number_ptr(j);\n  decNumberDoublePrecision dec_double;\n  char literal[DEC_NUBMER_DOUBLE_PRECISION + DEC_NUMBER_STRING_GUARD + 1];\n\n  // reduce the number to the shortest possible form\n  // that fits into the 64 bit floating point representation\n  decNumberReduce(&dec_double.number, p_dec_number, &dblCtx);\n\n  decNumberToString(&dec_double.number, literal);\n\n  char *end;\n  return jvp_strtod(tsd_dtoa_context_get(), literal, &end);\n}\n\nstatic const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n\nint jv_number_has_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n  return JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL);\n}\n\nconst char* jv_number_get_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n\n  if (JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL)) {\n    return jvp_literal_number_literal(n);\n  } else {\n    return NULL;\n  }\n}\n\njv jv_number_with_literal(const char * literal) {\n  return jvp_literal_number_new(literal);\n}\n#endif /* USE_DECNUM */\n\njv jv_number(double x) {\n  jv j = {\n#ifdef USE_DECNUM\n    JVP_FLAGS_NUMBER_NATIVE,\n#else\n    JV_KIND_NUMBER,\n#endif\n    0, 0, 0, {.number = x}\n  };\n  return j;\n}\n\nstatic void jvp_number_free(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL) && jvp_refcnt_dec(j.u.ptr)) {\n    jvp_literal_number* n = jvp_literal_number_ptr(j);\n    if (n->literal_data) {\n      jv_mem_free(n->literal_data);\n    }\n    jv_mem_free(n);\n  }\n#endif\n}\n\ndouble jv_number_value(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL)) {\n    jvp_literal_number* n = jvp_literal_number_ptr(j);\n\n    if (j.size != JV_NUMBER_SIZE_CONVERTED) {\n      n->num_double = jvp_literal_number_to_double(j);\n      j.size = JV_NUMBER_SIZE_CONVERTED;\n    }\n\n    return n->num_double;\n  }\n#endif\n  return j.u.number;\n}\n\nint jv_is_integer(jv j){\n  if (!JVP_HAS_KIND(j, JV_KIND_NUMBER)){\n    return 0;\n  }\n\n  double x = jv_number_value(j);\n\n  double ipart;\n  double fpart = modf(x, &ipart);\n\n  return fabs(fpart) < DBL_EPSILON;\n}\n\nint jvp_number_is_nan(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber *pdec = jvp_dec_number_ptr(n);\n    return decNumberIsNaN(pdec);\n  }\n#endif\n  return n.u.number != n.u.number;\n}\n\nint jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nstatic int jvp_number_equal(jv a, jv b) {\n  return jvp_number_cmp(a, b) == 0;\n}\n\n/*\n * Arrays (internal helpers)\n */\n\n#define ARRAY_SIZE_ROUND_UP(n) (((n)*3)/2)\n#define JVP_FLAGS_ARRAY   JVP_MAKE_FLAGS(JV_KIND_ARRAY, JVP_PAYLOAD_ALLOCATED)\n\nstatic int imax(int a, int b) {\n  if (a>b) return a;\n  else return b;\n}\n\n//FIXME signed vs unsigned\ntypedef struct {\n  jv_refcnt refcnt;\n  int length, alloc_length;\n  jv elements[];\n} jvp_array;\n\nstatic jvp_array* jvp_array_ptr(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  return (jvp_array*)a.u.ptr;\n}\n\nstatic jvp_array* jvp_array_alloc(unsigned size) {\n  jvp_array* a = jv_mem_alloc(sizeof(jvp_array) + sizeof(jv) * size);\n  a->refcnt.count = 1;\n  a->length = 0;\n  a->alloc_length = size;\n  return a;\n}\n\nstatic jv jvp_array_new(unsigned size) {\n  jv r = {JVP_FLAGS_ARRAY, 0, 0, 0, {&jvp_array_alloc(size)->refcnt}};\n  return r;\n}\n\nstatic void jvp_array_free(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  if (jvp_refcnt_dec(a.u.ptr)) {\n    jvp_array* array = jvp_array_ptr(a);\n    for (int i=0; i<array->length; i++) {\n      jv_free(array->elements[i]);\n    }\n    jv_mem_free(array);\n  }\n}\n\nstatic int jvp_array_length(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  return a.size;\n}\n\nstatic int jvp_array_offset(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  return a.offset;\n}\n\nstatic jv* jvp_array_read(jv a, int i) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  if (i >= 0 && i < jvp_array_length(a)) {\n    jvp_array* array = jvp_array_ptr(a);\n    assert(i + jvp_array_offset(a) < array->length);\n    return &array->elements[i + jvp_array_offset(a)];\n  } else {\n    return 0;\n  }\n}\n\nstatic jv* jvp_array_write(jv* a, int i) {\n  assert(i >= 0);\n  jvp_array* array = jvp_array_ptr(*a);\n\n  int pos = i + jvp_array_offset(*a);\n  if (pos < array->alloc_length && jvp_refcnt_unshared(a->u.ptr)) {\n    // use existing array space\n    for (int j = array->length; j <= pos; j++) {\n      array->elements[j] = JV_NULL;\n    }\n    array->length = imax(pos + 1, array->length);\n    a->size = imax(i + 1, a->size);\n    return &array->elements[pos];\n  } else {\n    // allocate a new array\n    int new_length = imax(i + 1, jvp_array_length(*a));\n    jvp_array* new_array = jvp_array_alloc(ARRAY_SIZE_ROUND_UP(new_length));\n    int j;\n    for (j = 0; j < jvp_array_length(*a); j++) {\n      new_array->elements[j] =\n        jv_copy(array->elements[j + jvp_array_offset(*a)]);\n    }\n    for (; j < new_length; j++) {\n      new_array->elements[j] = JV_NULL;\n    }\n    new_array->length = new_length;\n    jvp_array_free(*a);\n    jv new_jv = {JVP_FLAGS_ARRAY, 0, 0, new_length, {&new_array->refcnt}};\n    *a = new_jv;\n    return &new_array->elements[i];\n  }\n}\n\nstatic int jvp_array_equal(jv a, jv b) {\n  if (jvp_array_length(a) != jvp_array_length(b))\n    return 0;\n  if (jvp_array_ptr(a) == jvp_array_ptr(b) &&\n      jvp_array_offset(a) == jvp_array_offset(b))\n    return 1;\n  for (int i=0; i<jvp_array_length(a); i++) {\n    if (!jv_equal(jv_copy(*jvp_array_read(a, i)),\n                  jv_copy(*jvp_array_read(b, i))))\n      return 0;\n  }\n  return 1;\n}\n\nstatic void jvp_clamp_slice_params(int len, int *pstart, int *pend)\n{\n  if (*pstart < 0) *pstart = len + *pstart;\n  if (*pend < 0) *pend = len + *pend;\n\n  if (*pstart < 0) *pstart = 0;\n  if (*pstart > len) *pstart = len;\n  if (*pend > len) *pend = len;\n  if (*pend < *pstart) *pend = *pstart;\n}\n\n\nstatic int jvp_array_contains(jv a, jv b) {\n  int r = 1;\n  jv_array_foreach(b, bi, belem) {\n    int ri = 0;\n    jv_array_foreach(a, ai, aelem) {\n      if (jv_contains(aelem, jv_copy(belem))) {\n        ri = 1;\n        break;\n      }\n    }\n    jv_free(belem);\n    if (!ri) {\n      r = 0;\n      break;\n    }\n  }\n  return r;\n}\n\n\n/*\n * Public\n */\n\nstatic jv jvp_array_slice(jv a, int start, int end) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  int len = jvp_array_length(a);\n  jvp_clamp_slice_params(len, &start, &end);\n  assert(0 <= start && start <= end && end <= len);\n\n  // FIXME: maybe slice should reallocate if the slice is small enough\n  if (start == end) {\n    jv_free(a);\n    return jv_array();\n  }\n\n  if (a.offset + start >= 1 << (sizeof(a.offset) * CHAR_BIT)) {\n    jv r = jv_array_sized(end - start);\n    for (int i = start; i < end; i++)\n      r = jv_array_append(r, jv_array_get(jv_copy(a), i));\n    jv_free(a);\n    return r;\n  } else {\n    a.offset += start;\n    a.size = end - start;\n    return a;\n  }\n}\n\n/*\n * Arrays (public interface)\n */\n\njv jv_array_sized(int n) {\n  return jvp_array_new(n);\n}\n\njv jv_array() {\n  return jv_array_sized(16);\n}\n\nint jv_array_length(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n  int len = jvp_array_length(j);\n  jv_free(j);\n  return len;\n}\n\njv jv_array_get(jv j, int idx) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n  jv* slot = jvp_array_read(j, idx);\n  jv val;\n  if (slot) {\n    val = jv_copy(*slot);\n  } else {\n    val = jv_invalid();\n  }\n  jv_free(j);\n  return val;\n}\n\njv jv_array_set(jv j, int idx, jv val) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n\n  if (idx < 0)\n    idx = jvp_array_length(j) + idx;\n  if (idx < 0) {\n    jv_free(j);\n    jv_free(val);\n    return jv_invalid_with_msg(jv_string(\"Out of bounds negative array index\"));\n  }\n  // copy/free of val,j coalesced\n  jv* slot = jvp_array_write(&j, idx);\n  jv_free(*slot);\n  *slot = val;\n  return j;\n}\n\njv jv_array_append(jv j, jv val) {\n  // copy/free of val,j coalesced\n  return jv_array_set(j, jv_array_length(jv_copy(j)), val);\n}\n\njv jv_array_concat(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  assert(JVP_HAS_KIND(b, JV_KIND_ARRAY));\n\n  // FIXME: could be faster\n  jv_array_foreach(b, i, elem) {\n    a = jv_array_append(a, elem);\n  }\n  jv_free(b);\n  return a;\n}\n\njv jv_array_slice(jv a, int start, int end) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  // copy/free of a coalesced\n  return jvp_array_slice(a, start, end);\n}\n\njv jv_array_indexes(jv a, jv b) {\n  jv res = jv_array();\n  int idx = -1;\n  jv_array_foreach(a, ai, aelem) {\n    jv_free(aelem);\n    jv_array_foreach(b, bi, belem) {\n      if (!jv_equal(jv_array_get(jv_copy(a), ai + bi), jv_copy(belem)))\n        idx = -1;\n      else if (bi == 0 && idx == -1)\n        idx = ai;\n      jv_free(belem);\n    }\n    if (idx > -1)\n      res = jv_array_append(res, jv_number(idx));\n    idx = -1;\n  }\n  jv_free(a);\n  jv_free(b);\n  return res;\n}\n\n/*\n * Strings (internal helpers)\n */\n\n#define JVP_FLAGS_STRING  JVP_MAKE_FLAGS(JV_KIND_STRING, JVP_PAYLOAD_ALLOCATED)\n\ntypedef struct {\n  jv_refcnt refcnt;\n  uint32_t hash;\n  // high 31 bits are length, low bit is a flag\n  // indicating whether hash has been computed.\n  uint32_t length_hashed;\n  uint32_t alloc_length;\n  char data[];\n} jvp_string;\n\nstatic jvp_string* jvp_string_ptr(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_STRING));\n  return (jvp_string*)a.u.ptr;\n}\n\nstatic jvp_string* jvp_string_alloc(uint32_t size) {\n  jvp_string* s = jv_mem_alloc(sizeof(jvp_string) + size + 1);\n  s->refcnt.count = 1;\n  s->alloc_length = size;\n  return s;\n}\n\n/* Copy a UTF8 string, replacing all badly encoded points with U+FFFD */\nstatic jv jvp_string_copy_replace_bad(const char* data, uint32_t length) {\n  const char* end = data + length;\n  const char* i = data;\n\n  uint32_t maxlength = length * 3 + 1; // worst case: all bad bytes, each becomes a 3-byte U+FFFD\n  jvp_string* s = jvp_string_alloc(maxlength);\n  char* out = s->data;\n  int c = 0;\n\n  while ((i = jvp_utf8_next(i, end, &c))) {\n    if (c == -1) {\n      c = 0xFFFD; // U+FFFD REPLACEMENT CHARACTER\n    }\n    out += jvp_utf8_encode(c, out);\n    assert(out < s->data + maxlength);\n  }\n  length = out - s->data;\n  s->data[length] = 0;\n  s->length_hashed = length << 1;\n  jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&s->refcnt}};\n  return r;\n}\n\n/* Assumes valid UTF8 */\nstatic jv jvp_string_new(const char* data, uint32_t length) {\n  jvp_string* s = jvp_string_alloc(length);\n  s->length_hashed = length << 1;\n  if (data != NULL)\n    memcpy(s->data, data, length);\n  s->data[length] = 0;\n  jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&s->refcnt}};\n  return r;\n}\n\nstatic jv jvp_string_empty_new(uint32_t length) {\n  jvp_string* s = jvp_string_alloc(length);\n  s->length_hashed = 0;\n  memset(s->data, 0, length);\n  jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&s->refcnt}};\n  return r;\n}\n\n\nstatic void jvp_string_free(jv js) {\n  jvp_string* s = jvp_string_ptr(js);\n  if (jvp_refcnt_dec(&s->refcnt)) {\n    jv_mem_free(s);\n  }\n}\n\nstatic uint32_t jvp_string_length(jvp_string* s) {\n  return s->length_hashed >> 1;\n}\n\nstatic uint32_t jvp_string_remaining_space(jvp_string* s) {\n  assert(s->alloc_length >= jvp_string_length(s));\n  uint32_t r = s->alloc_length - jvp_string_length(s);\n  return r;\n}\n\nstatic jv jvp_string_append(jv string, const char* data, uint32_t len) {\n  jvp_string* s = jvp_string_ptr(string);\n  uint32_t currlen = jvp_string_length(s);\n\n  if (jvp_refcnt_unshared(string.u.ptr) &&\n      jvp_string_remaining_space(s) >= len) {\n    // the next string fits at the end of a\n    memcpy(s->data + currlen, data, len);\n    s->data[currlen + len] = 0;\n    s->length_hashed = (currlen + len) << 1;\n    return string;\n  } else {\n    // allocate a bigger buffer and copy\n    uint32_t allocsz = (currlen + len) * 2;\n    if (allocsz < 32) allocsz = 32;\n    jvp_string* news = jvp_string_alloc(allocsz);\n    news->length_hashed = (currlen + len) << 1;\n    memcpy(news->data, s->data, currlen);\n    memcpy(news->data + currlen, data, len);\n    news->data[currlen + len] = 0;\n    jvp_string_free(string);\n    jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&news->refcnt}};\n    return r;\n  }\n}\n\nstatic const uint32_t HASH_SEED = 0x432A9843;\n\nstatic uint32_t rotl32 (uint32_t x, int8_t r){\n  return (x << r) | (x >> (32 - r));\n}\n\nstatic uint32_t jvp_string_hash(jv jstr) {\n  jvp_string* str = jvp_string_ptr(jstr);\n  if (str->length_hashed & 1)\n    return str->hash;\n\n  /* The following is based on MurmurHash3.\n     MurmurHash3 was written by Austin Appleby, and is placed\n     in the public domain. */\n\n  const uint8_t* data = (const uint8_t*)str->data;\n  int len = (int)jvp_string_length(str);\n  const int nblocks = len / 4;\n\n  uint32_t h1 = HASH_SEED;\n\n  const uint32_t c1 = 0xcc9e2d51;\n  const uint32_t c2 = 0x1b873593;\n  const uint32_t* blocks = (const uint32_t *)(data + nblocks*4);\n\n  for(int i = -nblocks; i; i++) {\n    uint32_t k1 = blocks[i]; //FIXME: endianness/alignment\n\n    k1 *= c1;\n    k1 = rotl32(k1,15);\n    k1 *= c2;\n\n    h1 ^= k1;\n    h1 = rotl32(h1,13);\n    h1 = h1*5+0xe6546b64;\n  }\n\n  const uint8_t* tail = (const uint8_t*)(data + nblocks*4);\n\n  uint32_t k1 = 0;\n\n  switch(len & 3) {\n  case 3: k1 ^= tail[2] << 16;\n          JQ_FALLTHROUGH;\n  case 2: k1 ^= tail[1] << 8;\n          JQ_FALLTHROUGH;\n  case 1: k1 ^= tail[0];\n          k1 *= c1; k1 = rotl32(k1,15); k1 *= c2; h1 ^= k1;\n  }\n\n  h1 ^= len;\n\n  h1 ^= h1 >> 16;\n  h1 *= 0x85ebca6b;\n  h1 ^= h1 >> 13;\n  h1 *= 0xc2b2ae35;\n  h1 ^= h1 >> 16;\n\n  str->length_hashed |= 1;\n  str->hash = h1;\n\n  return h1;\n}\n\n\nstatic int jvp_string_equal(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_STRING));\n  assert(JVP_HAS_KIND(b, JV_KIND_STRING));\n  jvp_string* stra = jvp_string_ptr(a);\n  jvp_string* strb = jvp_string_ptr(b);\n  if (jvp_string_length(stra) != jvp_string_length(strb)) return 0;\n  return memcmp(stra->data, strb->data, jvp_string_length(stra)) == 0;\n}\n\n/*\n * Strings (public API)\n */\n\njv jv_string_sized(const char* str, int len) {\n  return\n    jvp_utf8_is_valid(str, str+len) ?\n    jvp_string_new(str, len) :\n    jvp_string_copy_replace_bad(str, len);\n}\n\njv jv_string_empty(int len) {\n  return jvp_string_empty_new(len);\n}\n\njv jv_string(const char* str) {\n  return jv_string_sized(str, strlen(str));\n}\n\nint jv_string_length_bytes(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  int r = jvp_string_length(jvp_string_ptr(j));\n  jv_free(j);\n  return r;\n}\n\nint jv_string_length_codepoints(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  const char* i = jv_string_value(j);\n  const char* end = i + jv_string_length_bytes(jv_copy(j));\n  int c = 0, len = 0;\n  while ((i = jvp_utf8_next(i, end, &c))) len++;\n  jv_free(j);\n  return len;\n}\n\n\njv jv_string_indexes(jv j, jv k) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  assert(JVP_HAS_KIND(k, JV_KIND_STRING));\n  const char *jstr = jv_string_value(j);\n  const char *idxstr = jv_string_value(k);\n  const char *p;\n  int jlen = jv_string_length_bytes(jv_copy(j));\n  int idxlen = jv_string_length_bytes(jv_copy(k));\n  jv a = jv_array();\n\n  if (idxlen != 0) {\n    p = jstr;\n    while ((p = _jq_memmem(p, (jstr + jlen) - p, idxstr, idxlen)) != NULL) {\n      a = jv_array_append(a, jv_number(p - jstr));\n      p++;\n    }\n  }\n  jv_free(j);\n  jv_free(k);\n  return a;\n}\n\njv jv_string_split(jv j, jv sep) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  assert(JVP_HAS_KIND(sep, JV_KIND_STRING));\n  const char *jstr = jv_string_value(j);\n  const char *jend = jstr + jv_string_length_bytes(jv_copy(j));\n  const char *sepstr = jv_string_value(sep);\n  const char *p, *s;\n  int seplen = jv_string_length_bytes(jv_copy(sep));\n  jv a = jv_array();\n\n  assert(jv_get_refcnt(a) == 1);\n\n  if (seplen == 0) {\n    int c;\n    while ((jstr = jvp_utf8_next(jstr, jend, &c)))\n      a = jv_array_append(a, jv_string_append_codepoint(jv_string(\"\"), c));\n  } else {\n    for (p = jstr; p < jend; p = s + seplen) {\n      s = _jq_memmem(p, jend - p, sepstr, seplen);\n      if (s == NULL)\n        s = jend;\n      a = jv_array_append(a, jv_string_sized(p, s - p));\n      // Add an empty string to denote that j ends on a sep\n      if (s + seplen == jend && seplen != 0)\n        a = jv_array_append(a, jv_string(\"\"));\n    }\n  }\n  jv_free(j);\n  jv_free(sep);\n  return a;\n}\n\njv jv_string_explode(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  const char* i = jv_string_value(j);\n  int len = jv_string_length_bytes(jv_copy(j));\n  const char* end = i + len;\n  jv a = jv_array_sized(len);\n  int c;\n  while ((i = jvp_utf8_next(i, end, &c)))\n    a = jv_array_append(a, jv_number(c));\n  jv_free(j);\n  return a;\n}\n\njv jv_string_implode(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n  int len = jv_array_length(jv_copy(j));\n  jv s = jv_string_empty(len);\n  int i;\n\n  assert(len >= 0);\n\n  for (i = 0; i < len; i++) {\n    jv n = jv_array_get(jv_copy(j), i);\n    assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n    int nv = jv_number_value(n);\n    jv_free(n);\n    // outside codepoint range or in utf16 surrogate pair range\n    if (nv < 0 || nv > 0x10FFFF || (nv >= 0xD800 && nv <= 0xDFFF))\n      nv = 0xFFFD; // U+FFFD REPLACEMENT CHARACTER\n    s = jv_string_append_codepoint(s, nv);\n  }\n\n  jv_free(j);\n  return s;\n}\n\nunsigned long jv_string_hash(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  uint32_t hash = jvp_string_hash(j);\n  jv_free(j);\n  return hash;\n}\n\nconst char* jv_string_value(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  return jvp_string_ptr(j)->data;\n}\n\njv jv_string_slice(jv j, int start, int end) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  const char *s = jv_string_value(j);\n  int len = jv_string_length_bytes(jv_copy(j));\n  int i;\n  const char *p, *e;\n  int c;\n  jv res;\n\n  jvp_clamp_slice_params(len, &start, &end);\n  assert(0 <= start && start <= end && end <= len);\n\n  /* Look for byte offset corresponding to start codepoints */\n  for (p = s, i = 0; i < start; i++) {\n    p = jvp_utf8_next(p, s + len, &c);\n    if (p == NULL) {\n      jv_free(j);\n      return jv_string_empty(16);\n    }\n    if (c == -1) {\n      jv_free(j);\n      return jv_invalid_with_msg(jv_string(\"Invalid UTF-8 string\"));\n    }\n  }\n  /* Look for byte offset corresponding to end codepoints */\n  for (e = p; e != NULL && i < end; i++) {\n    e = jvp_utf8_next(e, s + len, &c);\n    if (e == NULL) {\n      e = s + len;\n      break;\n    }\n    if (c == -1) {\n      jv_free(j);\n      return jv_invalid_with_msg(jv_string(\"Invalid UTF-8 string\"));\n    }\n  }\n\n  /*\n   * NOTE: Ideally we should do here what jvp_array_slice() does instead\n   * of allocating a new string as we do!  However, we assume NUL-\n   * terminated strings all over, and in the jv API, so for now we waste\n   * memory like a drunken navy programmer.  There's probably nothing we\n   * can do about it.\n   */\n  res = jv_string_sized(p, e - p);\n  jv_free(j);\n  return res;\n}\n\njv jv_string_concat(jv a, jv b) {\n  a = jvp_string_append(a, jv_string_value(b),\n                        jvp_string_length(jvp_string_ptr(b)));\n  jv_free(b);\n  return a;\n}\n\njv jv_string_append_buf(jv a, const char* buf, int len) {\n  if (jvp_utf8_is_valid(buf, buf+len)) {\n    a = jvp_string_append(a, buf, len);\n  } else {\n    jv b = jvp_string_copy_replace_bad(buf, len);\n    a = jv_string_concat(a, b);\n  }\n  return a;\n}\n\njv jv_string_append_codepoint(jv a, uint32_t c) {\n  char buf[5];\n  int len = jvp_utf8_encode(c, buf);\n  a = jvp_string_append(a, buf, len);\n  return a;\n}\n\njv jv_string_append_str(jv a, const char* str) {\n  return jv_string_append_buf(a, str, strlen(str));\n}\n\njv jv_string_vfmt(const char* fmt, va_list ap) {\n  int size = 1024;\n  while (1) {\n    char* buf = jv_mem_alloc(size);\n    va_list ap2;\n    va_copy(ap2, ap);\n    int n = vsnprintf(buf, size, fmt, ap2);\n    va_end(ap2);\n    /*\n     * NOTE: here we support old vsnprintf()s that return -1 because the\n     * buffer is too small.\n     */\n    if (n >= 0 && n < size) {\n      jv ret = jv_string_sized(buf, n);\n      jv_mem_free(buf);\n      return ret;\n    } else {\n      jv_mem_free(buf);\n      size = (n > 0) ? /* standard */ (n * 2) : /* not standard */ (size * 2);\n    }\n  }\n}\n\njv jv_string_fmt(const char* fmt, ...) {\n  va_list args;\n  va_start(args, fmt);\n  jv res = jv_string_vfmt(fmt, args);\n  va_end(args);\n  return res;\n}\n\n/*\n * Objects (internal helpers)\n */\n\n#define JVP_FLAGS_OBJECT  JVP_MAKE_FLAGS(JV_KIND_OBJECT, JVP_PAYLOAD_ALLOCATED)\n\nstruct object_slot {\n  int next; /* next slot with same hash, for collisions */\n  uint32_t hash;\n  jv string;\n  jv value;\n};\n\ntypedef struct {\n  jv_refcnt refcnt;\n  int next_free;\n  struct object_slot elements[];\n} jvp_object;\n\n\n/* warning: nontrivial justification of alignment */\nstatic jv jvp_object_new(int size) {\n  // Allocates an object of (size) slots and (size*2) hash buckets.\n\n  // size must be a power of two\n  assert(size > 0 && (size & (size - 1)) == 0);\n\n  jvp_object* obj = jv_mem_alloc(sizeof(jvp_object) +\n                                 sizeof(struct object_slot) * size +\n                                 sizeof(int) * (size * 2));\n  obj->refcnt.count = 1;\n  for (int i=0; i<size; i++) {\n    obj->elements[i].next = i - 1;\n    obj->elements[i].string = JV_NULL;\n    obj->elements[i].hash = 0;\n    obj->elements[i].value = JV_NULL;\n  }\n  obj->next_free = 0;\n  int* hashbuckets = (int*)(&obj->elements[size]);\n  for (int i=0; i<size*2; i++) {\n    hashbuckets[i] = -1;\n  }\n  jv r = {JVP_FLAGS_OBJECT, 0, 0, size, {&obj->refcnt}};\n  return r;\n}\n\nstatic jvp_object* jvp_object_ptr(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  return (jvp_object*)o.u.ptr;\n}\n\nstatic uint32_t jvp_object_mask(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  return (o.size * 2) - 1;\n}\n\nstatic int jvp_object_size(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  return o.size;\n}\n\nstatic int* jvp_object_buckets(jv o) {\n  return (int*)(&jvp_object_ptr(o)->elements[o.size]);\n}\n\nstatic int* jvp_object_find_bucket(jv object, jv key) {\n  return jvp_object_buckets(object) + (jvp_object_mask(object) & jvp_string_hash(key));\n}\n\nstatic struct object_slot* jvp_object_get_slot(jv object, int slot) {\n  assert(slot == -1 || (slot >= 0 && slot < jvp_object_size(object)));\n  if (slot == -1) return 0;\n  else return &jvp_object_ptr(object)->elements[slot];\n}\n\nstatic struct object_slot* jvp_object_next_slot(jv object, struct object_slot* slot) {\n  return jvp_object_get_slot(object, slot->next);\n}\n\nstatic struct object_slot* jvp_object_find_slot(jv object, jv keystr, int* bucket) {\n  uint32_t hash = jvp_string_hash(keystr);\n  for (struct object_slot* curr = jvp_object_get_slot(object, *bucket);\n       curr;\n       curr = jvp_object_next_slot(object, curr)) {\n    if (curr->hash == hash && jvp_string_equal(keystr, curr->string)) {\n      return curr;\n    }\n  }\n  return 0;\n}\n\nstatic struct object_slot* jvp_object_add_slot(jv object, jv key, int* bucket) {\n  jvp_object* o = jvp_object_ptr(object);\n  int newslot_idx = o->next_free;\n  if (newslot_idx == jvp_object_size(object)) return 0;\n  struct object_slot* newslot = jvp_object_get_slot(object, newslot_idx);\n  o->next_free++;\n  newslot->next = *bucket;\n  *bucket = newslot_idx;\n  newslot->hash = jvp_string_hash(key);\n  newslot->string = key;\n  return newslot;\n}\n\nstatic jv* jvp_object_read(jv object, jv key) {\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  int* bucket = jvp_object_find_bucket(object, key);\n  struct object_slot* slot = jvp_object_find_slot(object, key, bucket);\n  if (slot == 0) return 0;\n  else return &slot->value;\n}\n\nstatic void jvp_object_free(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  if (jvp_refcnt_dec(o.u.ptr)) {\n    for (int i=0; i<jvp_object_size(o); i++) {\n      struct object_slot* slot = jvp_object_get_slot(o, i);\n      if (jv_get_kind(slot->string) != JV_KIND_NULL) {\n        jvp_string_free(slot->string);\n        jv_free(slot->value);\n      }\n    }\n    jv_mem_free(jvp_object_ptr(o));\n  }\n}\n\nstatic jv jvp_object_rehash(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(jvp_refcnt_unshared(object.u.ptr));\n  int size = jvp_object_size(object);\n  jv new_object = jvp_object_new(size * 2);\n  for (int i=0; i<size; i++) {\n    struct object_slot* slot = jvp_object_get_slot(object, i);\n    if (jv_get_kind(slot->string) == JV_KIND_NULL) continue;\n    int* new_bucket = jvp_object_find_bucket(new_object, slot->string);\n    assert(!jvp_object_find_slot(new_object, slot->string, new_bucket));\n    struct object_slot* new_slot = jvp_object_add_slot(new_object, slot->string, new_bucket);\n    assert(new_slot);\n    new_slot->value = slot->value;\n  }\n  // references are transported, just drop the old table\n  jv_mem_free(jvp_object_ptr(object));\n  return new_object;\n}\n\nstatic jv jvp_object_unshare(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  if (jvp_refcnt_unshared(object.u.ptr))\n    return object;\n\n  jv new_object = jvp_object_new(jvp_object_size(object));\n  jvp_object_ptr(new_object)->next_free = jvp_object_ptr(object)->next_free;\n  for (int i=0; i<jvp_object_size(new_object); i++) {\n    struct object_slot* old_slot = jvp_object_get_slot(object, i);\n    struct object_slot* new_slot = jvp_object_get_slot(new_object, i);\n    *new_slot = *old_slot;\n    if (jv_get_kind(old_slot->string) != JV_KIND_NULL) {\n      new_slot->string = jv_copy(old_slot->string);\n      new_slot->value = jv_copy(old_slot->value);\n    }\n  }\n\n  int* old_buckets = jvp_object_buckets(object);\n  int* new_buckets = jvp_object_buckets(new_object);\n  memcpy(new_buckets, old_buckets, sizeof(int) * jvp_object_size(new_object)*2);\n\n  jvp_object_free(object);\n  assert(jvp_refcnt_unshared(new_object.u.ptr));\n  return new_object;\n}\n\nstatic jv* jvp_object_write(jv* object, jv key) {\n  *object = jvp_object_unshare(*object);\n  int* bucket = jvp_object_find_bucket(*object, key);\n  struct object_slot* slot = jvp_object_find_slot(*object, key, bucket);\n  if (slot) {\n    // already has the key\n    jvp_string_free(key);\n    return &slot->value;\n  }\n  slot = jvp_object_add_slot(*object, key, bucket);\n  if (slot) {\n    slot->value = jv_invalid();\n  } else {\n    *object = jvp_object_rehash(*object);\n    bucket = jvp_object_find_bucket(*object, key);\n    assert(!jvp_object_find_slot(*object, key, bucket));\n    slot = jvp_object_add_slot(*object, key, bucket);\n    assert(slot);\n    slot->value = jv_invalid();\n  }\n  return &slot->value;\n}\n\nstatic int jvp_object_delete(jv* object, jv key) {\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  *object = jvp_object_unshare(*object);\n  int* bucket = jvp_object_find_bucket(*object, key);\n  int* prev_ptr = bucket;\n  uint32_t hash = jvp_string_hash(key);\n  for (struct object_slot* curr = jvp_object_get_slot(*object, *bucket);\n       curr;\n       curr = jvp_object_next_slot(*object, curr)) {\n    if (hash == curr->hash && jvp_string_equal(key, curr->string)) {\n      *prev_ptr = curr->next;\n      jvp_string_free(curr->string);\n      curr->string = JV_NULL;\n      jv_free(curr->value);\n      return 1;\n    }\n    prev_ptr = &curr->next;\n  }\n  return 0;\n}\n\nstatic int jvp_object_length(jv object) {\n  int n = 0;\n  for (int i=0; i<jvp_object_size(object); i++) {\n    struct object_slot* slot = jvp_object_get_slot(object, i);\n    if (jv_get_kind(slot->string) != JV_KIND_NULL) n++;\n  }\n  return n;\n}\n\nstatic int jvp_object_equal(jv o1, jv o2) {\n  int len2 = jvp_object_length(o2);\n  int len1 = 0;\n  for (int i=0; i<jvp_object_size(o1); i++) {\n    struct object_slot* slot = jvp_object_get_slot(o1, i);\n    if (jv_get_kind(slot->string) == JV_KIND_NULL) continue;\n    jv* slot2 = jvp_object_read(o2, slot->string);\n    if (!slot2) return 0;\n    // FIXME: do less refcounting here\n    if (!jv_equal(jv_copy(slot->value), jv_copy(*slot2))) return 0;\n    len1++;\n  }\n  return len1 == len2;\n}\n\nstatic int jvp_object_contains(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(b, JV_KIND_OBJECT));\n  int r = 1;\n\n  jv_object_foreach(b, key, b_val) {\n    jv a_val = jv_object_get(jv_copy(a), key);\n\n    r = jv_contains(a_val, b_val);\n\n    if (!r) break;\n  }\n  return r;\n}\n\n/*\n * Objects (public interface)\n */\n#define DEFAULT_OBJECT_SIZE 8\njv jv_object() {\n  return jvp_object_new(8);\n}\n\njv jv_object_get(jv object, jv key) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  jv* slot = jvp_object_read(object, key);\n  jv val;\n  if (slot) {\n    val = jv_copy(*slot);\n  } else {\n    val = jv_invalid();\n  }\n  jv_free(object);\n  jv_free(key);\n  return val;\n}\n\nint jv_object_has(jv object, jv key) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  jv* slot = jvp_object_read(object, key);\n  int res = slot ? 1 : 0;\n  jv_free(object);\n  jv_free(key);\n  return res;\n}\n\njv jv_object_set(jv object, jv key, jv value) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  // copy/free of object, key, value coalesced\n  jv* slot = jvp_object_write(&object, key);\n  jv_free(*slot);\n  *slot = value;\n  return object;\n}\n\njv jv_object_delete(jv object, jv key) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  jvp_object_delete(&object, key);\n  jv_free(key);\n  return object;\n}\n\nint jv_object_length(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  int n = jvp_object_length(object);\n  jv_free(object);\n  return n;\n}\n\njv jv_object_merge(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_OBJECT));\n  jv_object_foreach(b, k, v) {\n    a = jv_object_set(a, k, v);\n  }\n  jv_free(b);\n  return a;\n}\n\njv jv_object_merge_recursive(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(b, JV_KIND_OBJECT));\n\n  jv_object_foreach(b, k, v) {\n    jv elem = jv_object_get(jv_copy(a), jv_copy(k));\n    if (jv_is_valid(elem) &&\n        JVP_HAS_KIND(elem, JV_KIND_OBJECT) &&\n        JVP_HAS_KIND(v, JV_KIND_OBJECT)) {\n      a = jv_object_set(a, k, jv_object_merge_recursive(elem, v));\n    } else {\n      jv_free(elem);\n      a = jv_object_set(a, k, v);\n    }\n  }\n  jv_free(b);\n  return a;\n}\n\n/*\n * Object iteration (internal helpers)\n */\n\nenum { ITER_FINISHED = -2 };\n\nint jv_object_iter_valid(jv object, int i) {\n  return i != ITER_FINISHED;\n}\n\nint jv_object_iter(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  return jv_object_iter_next(object, -1);\n}\n\nint jv_object_iter_next(jv object, int iter) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(iter != ITER_FINISHED);\n  struct object_slot* slot;\n  do {\n    iter++;\n    if (iter >= jvp_object_size(object))\n      return ITER_FINISHED;\n    slot = jvp_object_get_slot(object, iter);\n  } while (jv_get_kind(slot->string) == JV_KIND_NULL);\n  assert(jv_get_kind(jvp_object_get_slot(object,iter)->string)\n         == JV_KIND_STRING);\n  return iter;\n}\n\njv jv_object_iter_key(jv object, int iter) {\n  jv s = jvp_object_get_slot(object, iter)->string;\n  assert(JVP_HAS_KIND(s, JV_KIND_STRING));\n  return jv_copy(s);\n}\n\njv jv_object_iter_value(jv object, int iter) {\n  return jv_copy(jvp_object_get_slot(object, iter)->value);\n}\n\n/*\n * Memory management\n */\njv jv_copy(jv j) {\n  if (JVP_IS_ALLOCATED(j)) {\n    jvp_refcnt_inc(j.u.ptr);\n  }\n  return j;\n}\n\nvoid jv_free(jv j) {\n  switch(JVP_KIND(j)) {\n    case JV_KIND_ARRAY:\n      jvp_array_free(j);\n      break;\n    case JV_KIND_STRING:\n      jvp_string_free(j);\n      break;\n    case JV_KIND_OBJECT:\n      jvp_object_free(j);\n      break;\n    case JV_KIND_INVALID:\n      jvp_invalid_free(j);\n      break;\n    case JV_KIND_NUMBER:\n      jvp_number_free(j);\n      break;\n  }\n}\n\nint jv_get_refcnt(jv j) {\n  if (JVP_IS_ALLOCATED(j)) {\n    return j.u.ptr->count;\n  } else {\n    return 1;\n  }\n}\n\n/*\n * Higher-level operations\n */\n\nint jv_equal(jv a, jv b) {\n  int r;\n  if (jv_get_kind(a) != jv_get_kind(b)) {\n    r = 0;\n  } else if (JVP_IS_ALLOCATED(a) &&\n             JVP_IS_ALLOCATED(b) &&\n             a.kind_flags == b.kind_flags &&\n             a.size == b.size &&\n             a.u.ptr == b.u.ptr) {\n    r = 1;\n  } else {\n    switch (jv_get_kind(a)) {\n    case JV_KIND_NUMBER:\n      r = jvp_number_equal(a, b);\n      break;\n    case JV_KIND_ARRAY:\n      r = jvp_array_equal(a, b);\n      break;\n    case JV_KIND_STRING:\n      r = jvp_string_equal(a, b);\n      break;\n    case JV_KIND_OBJECT:\n      r = jvp_object_equal(a, b);\n      break;\n    default:\n      r = 1;\n      break;\n    }\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n\nint jv_identical(jv a, jv b) {\n  int r;\n  if (a.kind_flags != b.kind_flags\n      || a.offset != b.offset\n      || a.size != b.size) {\n    r = 0;\n  } else {\n    if (JVP_IS_ALLOCATED(a) /* b has the same flags */) {\n      r = a.u.ptr == b.u.ptr;\n    } else {\n      r = memcmp(&a.u.ptr, &b.u.ptr, sizeof(a.u)) == 0;\n    }\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n\nint jv_contains(jv a, jv b) {\n  int r = 1;\n  if (jv_get_kind(a) != jv_get_kind(b)) {\n    r = 0;\n  } else if (JVP_HAS_KIND(a, JV_KIND_OBJECT)) {\n    r = jvp_object_contains(a, b);\n  } else if (JVP_HAS_KIND(a, JV_KIND_ARRAY)) {\n    r = jvp_array_contains(a, b);\n  } else if (JVP_HAS_KIND(a, JV_KIND_STRING)) {\n    int b_len = jv_string_length_bytes(jv_copy(b));\n    if (b_len != 0) {\n      r = _jq_memmem(jv_string_value(a), jv_string_length_bytes(jv_copy(a)),\n                     jv_string_value(b), b_len) != 0;\n    } else {\n      r = 1;\n    }\n  } else {\n    r = jv_equal(jv_copy(a), jv_copy(b));\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n", "#!/bin/sh -x\n\n. \"${0%/*}/setup\" \"$@\"\n\nmsys=false\nmingw=false\ncase \"$(uname -s)\" in\nMSYS*)  msys=true;;\nMINGW*) mingw=true;;\nesac\n\nJQ_NO_B=$JQ\nJQ=\"$JQ -b\"\n\nPATH=$JQBASEDIR:$PATH $JQBASEDIR/tests/jq-f-test.sh > /dev/null\n\nif [ -f \"$JQBASEDIR/.libs/libinject_errors.so\" ]; then\n  # Do some simple error injection tests to check that we're handling\n  # I/O errors correctly.\n  (\n  libinject=$JQBASEDIR/.libs/libinject_errors.so\n  cd $d\n  LD_PRELOAD=$libinject $JQ . /dev/null\n  touch fail_read\n  LD_PRELOAD=$libinject $JQ . fail_read && exit 2\n  touch fail_close\n  LD_PRELOAD=$libinject $JQ . fail_close && exit 2\n  true\n  )\nfi\n\nprintf 'a\\0b\\nc\\0d\\ne' > $d/input\n$VALGRIND $Q $JQ -Rse '. == \"a\\u0000b\\nc\\u0000d\\ne\"' $d/input\n$VALGRIND $Q $JQ -Rne '[inputs] == [\"a\\u0000b\", \"c\\u0000d\", \"e\"]' $d/input\n\n## Test constant folding\n\n## XXX If we add a builtin to list the program's disassembly then we can\n## move all of these into tests/all.test\n\n# String constant folding (addition only)\nnref=$($VALGRIND $Q $JQ -n --debug-dump-disasm '\"foo\"' | wc -l)\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '\"foo\" + \"bar\"' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for strings didn't work\"\n  exit 1\nfi\n\n# Numeric constant folding (binary operators)\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '1+1' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '1-1' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '2*3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9/3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9%3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9==3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9!=3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9<3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9>3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9<=3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9>=3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\n\n## Test JSON sequence support\n\ncat > $d/expected <<EOF\njq: ignoring parse error: Truncated value at line 2, column 5\njq: ignoring parse error: Truncated value at line 2, column 25\njq: ignoring parse error: Truncated value at line 2, column 41\nEOF\nprintf '1\\0362 3\\n[0,1\\036[4,5]true\"ab\"{\"c\":4\\036{}{\"d\":5,\"e\":6\"\\036false\\n'|$VALGRIND $Q $JQ -ces --seq '. == [2,3,[4,5],true,\"ab\",{},false]' > /dev/null 2> $d/out\ncmp $d/out $d/expected\n\ncat > $d/expected <<EOF\njq: ignoring parse error: Truncated value at line 2, column 5\njq: ignoring parse error: Truncated value at line 2, column 25\njq: ignoring parse error: Truncated value at line 3, column 1\nEOF\nprintf '1\\0362 3\\n[0,1\\036[4,5]true\"ab\"{\"c\":4\\036{}{\"d\":5,\"e\":6\"false\\n\\036null'|$VALGRIND $Q $JQ -ces --seq '. == [2,3,[4,5],true,\"ab\",{},null]' > /dev/null 2> $d/out\ncmp $d/out $d/expected\n\n# Note that here jq sees no inputs at all but it still succeeds because\n# --seq ignores parse errors\ncat > $d/expected <<EOF\njq: ignoring parse error: Unfinished abandoned text at EOF at line 1, column 4\nEOF\nprintf '\"foo' | $JQ -c --seq . > $d/out 2>&1\ncmp $d/out $d/expected\n\n# with -e option should give 4 here as there's no valid output after\n# ignoring parse errors with --seq.\nprintf '\"foo' | $JQ -ce --seq . > $d/out 2>&1 || ret=$?\n[ $ret -eq 4 ]\ncmp $d/out $d/expected\n\n# Numeric values truncated by EOF are ignored\ncat > $d/expected <<EOF\njq: ignoring parse error: Unfinished abandoned text at EOF at line 1, column 1\nEOF\nprintf '1' | $JQ -c --seq . > $d/out 2>&1\ncmp $d/out $d/expected\n\ncat > $d/expected <<EOF\njq: error (at <stdin>:1): Unfinished abandoned text at EOF at line 2, column 0\nEOF\nif printf '1\\n' | $JQ -cen --seq '[inputs] == []' >/dev/null 2> $d/out; then\n  printf 'Error expected but jq exited successfully\\n' 1>&2\n  exit 2\nfi\ncmp $d/out $d/expected\n\n\n## Test --exit-status\ndata='{\"i\": 1}\\n{\"i\": 2}\\n{\"i\": 3}\\n'\nprintf \"$data\" | $JQ --exit-status 'select(.i==1)' > /dev/null 2>&1\nprintf \"$data\" | $JQ --exit-status 'select(.i==2)' > /dev/null 2>&1\nprintf \"$data\" | $JQ --exit-status 'select(.i==3)' > /dev/null 2>&1\nret=0\nprintf \"$data\" | $JQ --exit-status 'select(.i==4)' > /dev/null 2>&1 || ret=$?\n[ $ret -eq 4 ]\nret=0\nprintf \"$data\" | $JQ --exit-status 'select(.i==2) | false' > /dev/null 2>&1 || ret=$?\n[ $ret -eq 1 ]\nprintf \"$data\" | $JQ --exit-status 'select(.i==2) | true' > /dev/null 2>&1\n\n\n# Regression test for #951\nprintf '\"a\\n' > $d/input\nif $VALGRIND $Q $JQ -e . $d/input; then\n  printf 'Issue #951 is back?\\n' 1>&2\n  exit 2\nfi\n\n# Regression test for #2146\nif echo \"foobar\" | $JQ .; then\n  printf 'Issue #2146 is back?\\n' 1>&2\n  exit 1\nelif [ $? -ne 5 ]; then\n  echo \"Invalid input had wrong error code\" 1>&2\n  exit 1\nfi\n\n# Regression test for #2367; make sure to call jq twice\nif ! echo '{\"a\": 1E9999999999}' | $JQ . | $JQ -e .a; then\n  printf 'Issue #2367 is back?\\n' 1>&2\n  exit 1\nfi\n\n# Regression test for #1534\necho \"[1,2,3,4]\" > $d/expected\nprintf \"[1,2][3,4]\" | $JQ -cs add > $d/out 2>&1\ncmp $d/out $d/expected\nprintf \"[1,2][3,4]\\n\" | $JQ -cs add > $d/out 2>&1\ncmp $d/out $d/expected\n\n# Regression test for --raw-output0\nprintf \"a\\0b\\0\" > $d/expected\nprintf '[\"a\", \"b\"]' | $VALGRIND $Q $JQ --raw-output0 .[] > $d/out\ncmp $d/out $d/expected\nprintf \"a\\0\" > $d/expected\nif printf '[\"a\", \"c\\\\u0000d\", \"b\"]' | $VALGRIND $Q $JQ --raw-output0 .[] > $d/out; then\n  echo \"Should exit error on string containing NUL with --raw-output0\" 1>&2\n  exit 1\nelif [ $? -ne 5 ]; then\n  echo \"Invalid error code\" 1>&2\n  exit 1\nelse\n  cmp $d/out $d/expected\nfi\n\n## Test streaming parser\n\n## If we add an option to stream to the `import ... as $symbol;` directive\n## then we can move these tests into tests/all.test.\n$VALGRIND $Q $JQ -c '. as $d|path(..) as $p|$d|getpath($p)|select((type|. != \"array\" and . != \"object\") or length==0)|[$p,.]' < \"$JQTESTDIR/torture/input0.json\" > $d/out0\n$VALGRIND $Q $JQ --stream -c '.|select(length==2)' < \"$JQTESTDIR/torture/input0.json\" > $d/out1\ndiff $d/out0 $d/out1\n\nprintf '[\"Unfinished JSON term at EOF at line 1, column 1\",[0]]\\n' > $d/expected\nprintf '[' | $VALGRIND $Q $JQ --stream-errors -c . > $d/out 2>&1\ndiff $d/out $d/expected\n\n\n## XXX This test can be moved to tests/all.test _now_\nclean=false\nif which seq > /dev/null 2>&1; then\n    # XXX We should try every prefix of input0.json, but that makes this\n    # test very, very slow when run with valgrind, and the whole point\n    # is to run it with valgrind.\n    #\n    #len=$(wc -c < \"$JQTESTDIR/torture/input0.json\")\n    if [ -z \"$VALGRIND\" ]; then\n        start=1\n        end=$(wc -c < \"$JQTESTDIR/torture/input0.json\")\n    else\n        start=120\n        end=151\n    fi\n    for i in $(seq $start $end); do\n        dd \"if=tests/torture/input0.json\" bs=$i count=1 2>/dev/null |\n            $VALGRIND $JQ -c . > $d/out0 2>$d/err || true\n        if [ -n \"$VALGRIND\" ]; then\n            grep '^==[0-9][0-9]*== ERROR SUMMARY: 0 errors' $d/err > /dev/null\n        else\n            tail -n1 -- \"$d/err\" | grep -Ei 'assert|abort|core' && false\n        fi\n\n        dd \"if=tests/torture/input0.json\" bs=$i count=1 2>/dev/null |\n            $VALGRIND $JQ -cn --stream 'fromstream(inputs)' > $d/out1 2>$d/err || true\n        if [ -n \"$VALGRIND\" ]; then\n            grep '^==[0-9][0-9]*== ERROR SUMMARY: 0 errors' $d/err > /dev/null\n        else\n            tail -n1 -- \"$d/err\" | grep -Ei 'assert|abort|core' && false\n        fi\n\n        diff $d/out0 $d/out1\n    done\nelse\n    echo \"Not doing torture tests\"\nfi\n\n## Regression test for issue #2378 assert when stream parse broken object pair\necho '{\"a\":1,\"b\",' | $JQ --stream  > /dev/null 2> $d/err || true\ngrep 'Objects must consist of key:value pairs' $d/err > /dev/null\n\n## Regression tests for issue #2463 assert when stream parse non-scalar object key\necho '{{\"a\":\"b\"}}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after '{', not '{'\" $d/err > /dev/null\necho '{\"x\":\"y\",{\"a\":\"b\"}}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after ',' in object, not '{'\" $d/err > /dev/null\necho '{[\"a\",\"b\"]}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after '{', not '\\\\['\" $d/err > /dev/null\necho '{\"x\":\"y\",[\"a\",\"b\"]}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after ',' in object, not '\\\\['\" $d/err > /dev/null\n\n# debug, stderr\n$VALGRIND $Q $JQ -n '\"test\", {} | debug, stderr' >/dev/null\n$JQ -n -c -j '\"hello\\nworld\", null, [false, 0], {\"foo\":[\"bar\"]}, \"\\n\" | stderr' >$d/out 2>$d/err\ncat > $d/expected <<'EOF'\nhello\nworldnull[false,0]{\"foo\":[\"bar\"]}\nEOF\ncmp $d/out $d/expected\ncmp $d/err $d/expected\n\n# --arg, --argjson, $ARGS.named\n$VALGRIND $JQ -n -c --arg foo 1 --argjson bar 2 '{$foo, $bar} | ., . == $ARGS.named' > $d/out\nprintf '{\"foo\":\"1\",\"bar\":2}\\ntrue\\n' > $d/expected\ncmp $d/out $d/expected\n\n# --slurpfile, --rawfile\n$VALGRIND $JQ -n --slurpfile foo $JQBASEDIR/tests/modules/data.json \\\n  --rawfile bar $JQBASEDIR/tests/modules/data.json '{$foo, $bar}' > $d/out\ncat > $d/expected <<'EOF'\n{\n  \"foo\": [\n    {\n      \"this\": \"is a test\",\n      \"that\": \"is too\"\n    }\n  ],\n  \"bar\": \"{\\n  \\\"this\\\": \\\"is a test\\\",\\n  \\\"that\\\": \\\"is too\\\"\\n}\\n\"\n}\nEOF\ncmp $d/out $d/expected\n\n# --args, --jsonargs, $ARGS.positional\n$VALGRIND $JQ -n -c --args '$ARGS.positional' foo bar baz > $d/out\nprintf '[\"foo\",\"bar\",\"baz\"]\\n' > $d/expected\ncmp $d/out $d/expected\n$VALGRIND $JQ -n -c --jsonargs '$ARGS.positional' null true '[]' '{}' > $d/out\nprintf '[null,true,[],{}]\\n' > $d/expected\ncmp $d/out $d/expected\n$VALGRIND $JQ -n -c '$ARGS.positional' --args foo 1 --jsonargs 2 '{}' --args 3 4 > $d/out\nprintf '[\"foo\",\"1\",2,{},\"3\",\"4\"]\\n' > $d/expected\ncmp $d/out $d/expected\n$VALGRIND $JQ -n -c '$ARGS.positional' --args --jsonargs > $d/out\nprintf '[]\\n' > $d/expected\ncmp $d/out $d/expected\n\n## Regression test for issue #2572 assert when using --jsonargs and invalid JSON\n$VALGRIND $JQ -n --jsonargs null invalid && EC=$? || EC=$?\nif [ \"$EC\" -ne 2 ]; then\n    echo \"--jsonargs exited with wrong exit code, expected 2 got $EC\" 1>&2\n    exit 1\nfi\n# this tests the args_done code path \"--\"\n$VALGRIND $JQ -n --jsonargs null -- invalid && EC=$? || EC=$?\nif [ \"$EC\" -ne 2 ]; then\n    echo \"--jsonargs exited with wrong exit code, expected 2 got $EC\" 1>&2\n    exit 1\nfi\n\n## Fuzz parser\n\n## XXX With a $(urandom) builtin we could move this test into tests/all.test\nclean=false\nif dd if=/dev/urandom bs=16 count=1024 > $d/rand 2>/dev/null; then\n    # Have a /dev/urandom, good\n    $VALGRIND $Q $JQ --seq . $d/rand >/dev/null 2>&1\n    $VALGRIND $Q $JQ --seq --stream . $d/rand >/dev/null 2>&1\n    dd if=/dev/urandom bs=16 count=1024 > $d/rand 2>/dev/null\n    $VALGRIND $Q $JQ --seq . $d/rand >/dev/null 2>&1\n    $VALGRIND $Q $JQ --seq --stream . $d/rand >/dev/null 2>&1\n    dd if=/dev/urandom bs=16 count=1024 > $d/rand 2>/dev/null\n    $VALGRIND $Q $JQ --seq . $d/rand >/dev/null 2>&1\n    $VALGRIND $Q $JQ --seq --stream . $d/rand >/dev/null 2>&1\nfi\nclean=true\n\n## Test library/module system\n\n# Check handling of ~/.jq; these can't move into jq_test.c yet because\n# they depend on $HOME\nif [ \"$(HOME=\"$mods/home1\" $VALGRIND $Q $JQ -nr fg)\" != foobar ]; then\n    echo \"Bug #479 appears to be back\" 1>&2\n    exit 1\nfi\n\nif [ $(HOME=\"$mods/home1\" $VALGRIND $Q $JQ --debug-dump-disasm -n fg | grep '^[a-z]' | wc -l) -ne 3 ]; then\n    echo \"Binding too many defs into program\" 1>&2\n    exit 1\nfi\n\nif ! HOME=\"$mods/home2\" $VALGRIND $Q $JQ -n 'include \"g\"; empty'; then\n    echo \"Mishandling directory ~/.jq\" 1>&2\n    exit 1\nfi\n\ncd \"$JQBASEDIR\" # so that relative library paths are guaranteed correct\nif ! $VALGRIND $Q $JQ -L ./tests/modules -ne 'import \"test_bind_order\" as check; check::check==true'; then\n    echo \"Issue #817 regression?\" 1>&2\n    exit 1\nfi\n\ncd \"$JQBASEDIR\"\nif ! $VALGRIND $Q $JQ -L tests/modules -ne 'import \"test_bind_order\" as check; check::check==true'; then\n    echo \"Issue #817 regression?\" 1>&2\n    exit 1\nfi\n\n## Halt\n\nif ! $VALGRIND $Q $JQ -n halt; then\n    echo \"jq halt didn't work as expected\" 1>&2\n    exit 1\nfi\nif $VALGRIND $Q $VG_EXIT0 $JQ -n 'halt_error(1)'; then\n    echo \"jq halt_error(1) didn't work as expected\" 1>&2\n    exit 1\nelif [ $? -ne 1 ]; then\n    echo \"jq halt_error(1) had wrong error code\" 1>&2\n    exit 1\nfi\nif $VALGRIND $Q $VG_EXIT0 $JQ -n 'halt_error(11)'; then\n    echo \"jq halt_error(11) didn't work as expected\" 1>&2\n    exit 1\nelif [ $? -ne 11 ]; then\n    echo \"jq halt_error(11) had wrong error code\" 1>&2\n    exit 1\nfi\nif [ -n \"$($VALGRIND $Q $JQ -n 'halt_error(1)' 2>&1)\" ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\nif [ -n \"$($VALGRIND $Q $JQ -n '\"xyz\\n\" | halt_error(1)' 2>/dev/null)\" ]; then\n    echo \"jq halt_error(1) had unexpected output on stdout\" 1>&2\n    exit 1\nfi\nif [ \"$($VALGRIND $Q $JQ -n '\"xy\" | halt_error(1)' 2>&1 || echo \"z\")\" != \"xyz\" ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\nif [ \"$($VALGRIND $Q $JQ -n '\"x\\u0000y\\u0000z\" | halt_error(1)' 2>&1 | tr '\\0' '.')\" != \"x.y.z\" ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\nif [ \"$($VALGRIND $Q $JQ -n '{\"a\":\"xyz\"} | halt_error(1)' 2>&1)\" != '{\"a\":\"xyz\"}' ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\n\n# Check $JQ_COLORS\nunset JQ_COLORS\n\n## Default colors, null input\n$JQ -Ccn . > $d/color\nprintf '\\033[0;90mnull\\033[0m\\n' > $d/expect\ncmp $d/color $d/expect\n\n## Set non-default color, null input\nJQ_COLORS='4;31' $JQ -Ccn . > $d/color\nprintf '\\033[4;31mnull\\033[0m\\n' > $d/expect\ncmp $d/color $d/expect\n\n## Default colors, complex input\n$JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color\n{\n  printf '\\033[1;39m[\\033[1;39m{'\n  printf '\\033[0m\\033[1;34m\"a\"\\033['\n  printf '0m\\033[1;39m:\\033[0m\\033['\n  printf '0;39mtrue\\033[0m\\033[1'\n  printf ';39m,\\033[0m\\033[1;34m'\n  printf '\"b\"\\033[0m\\033[1;39m:\\033'\n  printf '[0m\\033[0;39mfalse\\033'\n  printf '[0m\\033[1;39m\\033[1;39'\n  printf 'm}\\033[0m\\033[1;39m,\\033['\n  printf '0;39m123\\033[0m\\033[1;'\n  printf '39m,\\033[0;90mnull\\033'\n  printf '[0m\\033[1;39m\\033[1;39'\n  printf 'm]\\033[0m\\n'\n} > $d/expect\ncmp $d/color $d/expect\n\n## Set non-default colors, complex input\nJQ_COLORS='0;30:0;31:0;32:0;33:0;34:1;35:1;36:1;37' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color\n{\n  printf '\\033[1;35m[\\033[1;36m{'\n  printf '\\033[0m\\033[1;37m\"a\"\\033['\n  printf '0m\\033[1;36m:\\033[0m\\033['\n  printf '0;32mtrue\\033[0m\\033[1'\n  printf ';36m,\\033[0m\\033[1;37m'\n  printf '\"b\"\\033[0m\\033[1;36m:\\033'\n  printf '[0m\\033[0;31mfalse\\033'\n  printf '[0m\\033[1;36m\\033[1;36'\n  printf 'm}\\033[0m\\033[1;35m,\\033['\n  printf '0;33m123\\033[0m\\033[1;'\n  printf '35m,\\033[0;30mnull\\033'\n  printf '[0m\\033[1;35m\\033[1;35'\n  printf 'm]\\033[0m\\n'\n} > $d/expect\ncmp $d/color $d/expect\n\n# Check garbage in JQ_COLORS.  We write each color sequence into a 16\n# char buffer that needs to hold ESC [ <color> m NUL, so each color\n# sequence can be no more than 12 chars (bytes).  These emit a warning\n# on stderr.\nset -vx\necho 'Failed to set $JQ_COLORS' > $d/expect_warning\n$JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/expect\nJQ_COLORS='garbage;30:*;31:,;3^:0;$%:0;34:1;35:1;36' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS='1234567890123456789;30:0;31:0;32:0;33:0;34:1;35:1;36' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS='1;31234567890123456789:0;31:0;32:0;33:0;34:1;35:1;36' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS='1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS=\"0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:\" \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\n\n# Check $NO_COLOR\ntest_no_color=true\n$msys  && test_no_color=false\n$mingw && test_no_color=false\nif $test_no_color && command -v script >/dev/null 2>&1; then\n  unset NO_COLOR\n  if script -qc echo /dev/null >/dev/null 2>&1; then\n    faketty() { script -qec \"$*\" /dev/null; }\n  else # macOS\n    faketty() { script -q /dev/null \"$@\" /dev/null |\n      sed 's/^\\x5E\\x44\\x08\\x08//'; }\n  fi\n\n  faketty $JQ_NO_B -n . > $d/color\n  printf '\\033[0;90mnull\\033[0m\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\n  NO_COLOR= faketty $JQ_NO_B -n . > $d/color\n  printf '\\033[0;90mnull\\033[0m\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\n  NO_COLOR=1 faketty $JQ_NO_B -n . > $d/color\n  printf 'null\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\n  NO_COLOR=1 faketty $JQ_NO_B -Cn . > $d/color\n  printf '\\033[0;90mnull\\033[0m\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\nfi\n\n# #2785\nif $VALGRIND $Q $JQ -n -f \"$JQTESTDIR/no-main-program.jq\" > $d/out 2>&1; then\n  echo \"jq -f $JQTESTDIR/no-main-program.jq succeeded\"\n  exit 1\nelse\n  EC=$?\n  if [ $EC -eq 1 ]; then\n    echo \"jq -f $JQTESTDIR/no-main-program.jq failed with memory errors\"\n    exit 1\n  fi\n  if [ $EC -ne 3 ]; then\n    echo \"jq -f $JQTESTDIR/no-main-program.jq failed with wrong exit code ($EC)\"\n    exit 1\n  fi\nfi\ncat > $d/expected <<EOF\njq: error: Top-level program not given (try \".\")\njq: 1 compile error\nEOF\nif ! diff $d/expected $d/out; then\n  echo \"jq -f $JQTESTDIR/no-main-program.jq failed but its error message is not the expected one\"\n  exit 1\nfi\n\nif ! $VALGRIND $Q $JQ -n -f \"$JQTESTDIR/yes-main-program.jq\" > $d/out 2>&1; then\n  echo \"jq -f $JQTESTDIR/yes-main-program.jq failed\"\n  exit 1\nfi\n\nif ! $msys && ! $mingw && locales=$(locale -a); then\n  { l=$(grep -Ev '^(C|LANG|POSIX|en)' | grep -Ei '\\.utf-?8$' | head -n1) ;} \\\n<<EOF\n$locales\nEOF\n  if [ -z \"$l\" ]; then\n    echo \"WARNING: Not testing localization\"\n  else\n    date=$(LC_ALL=$l date +'%a %d %b %Y at %H:%M:%S')\n    if ! LC_ALL=$l $JQ -nR --arg date \"$date\" '$date|strptime(\"%a %d %b %Y at %H:%M:%S\")'; then\n      echo \"jq does not honor LC_ALL environment variable\"\n      exit 1\n    fi\n  fi\nfi\n\n# Comments!\nif ! x=$($JQ -n '123 # comment') || [ \"$x\" != 123 ]; then\n  echo 'comment did not work'\n  exit 1\nfi\n\ncr=$(printf \\\\r)\nif ! x=$($JQ -n \"1 # foo$cr + 2\") || [ \"$x\" != 1 ]; then\n  echo 'regression: carriage return terminates comment'\n  exit 1\nfi\n\n# Allow passing the inline jq script before -- #2919\nif ! r=$($JQ --args -rn -- '$ARGS.positional[0]' bar) || [ \"$r\" != bar ]; then\n    echo \"passing the inline script after -- didn't work\"\n    exit 1\nfi\nif ! r=$($JQ --args -rn 1 -- '$ARGS.positional[0]' bar) || [ \"$r\" != 1 ]; then\n    echo \"passing the inline script before -- didn't work\"\n    exit 1\nfi\n\nexit 0\n"], "fixing_code": ["# 1.7.1\n\n## Security\n\n- CVE-2023-50246: ....\n- CVE-2023-50268: fix stack-buffer-overflow if comparing nan with payload\n\n## CLI changes\n\n- Make the default background color more suitable for bright backgrounds. @mjarosie @taoky @nicowilliams @itchyny #2904\n- Allow passing the inline jq script after `--`. @emanuele6 #2919\n- Restrict systems operations on OpenBSD and remove unused `mkstemp`. @klemensn #2934\n- Fix possible uninitialised value dereference if `jq_init()` fails. @emanuele6 @nicowilliams #2935\n\n## Language changes\n\n- Simplify `paths/0` and `paths/1`. @asheiduk @emanuele6 #2946\n- Reject `U+001F` in string literals. @torsten-schenk @itchyny @wader #2911\n- Remove unused nref accumulator in `block_bind_library`. @emanuele6 #2914\n- Remove a bunch of unused variables, and useless assignments. @emanuele6 #2914\n- main.c: Remove unused EXIT\\_STATUS\\_EXACT option. @emanuele6 #2915\n- Actually use the number correctly casted from double to int as index. @emanuele6 #2916\n- src/builtin.c: remove unnecessary jv\\_copy-s in type\\_error/type\\_error2. @emanuele6 #2937\n- Remove undefined behavior caught by LLVM 10 UBSAN. @Gaelan @emanuele6 #2926\n- Convert decnum to binary64 (double) instead of decimal64. This makes jq behave like the JSON specification suggests and more similar to other languages. @wader @leonid-s-usov #2949\n- Fix memory leaks on invalid input for `ltrimstr/1` and `rtrimstr/1`. @emanuele6 #2977\n- Fix memory leak on failed get for `setpath/2`. @emanuele6 #2970\n- Fix nan from json parsing also for nans with payload that start with 'n'. @emanuele6 #2985\n- Allow carriage return characters in comments. @emanuele6 #2942 #2984\n\n## Documentation changes\n\n- Generate links in the man page. @emanuele6 #2931\n- Standardize arch types to AMD64 & ARM64 from index page download dropdown. @owenthereal #2884\n\n## libjq\n\n- Add extern C for C++. @rockwotj #2953\n\n## Build and test changes\n\n- Fix incorrect syntax for checksum file. @kamontat @wader #2899\n- Remove `-dirty` version suffix for windows release build. @itchyny #2888\n- Make use of `od` in tests more compatible. @nabijaczleweli @emanuele6 @nicowilliams #2922\n- Add dependabot. @yeikel #2889\n- Extend fuzzing setup to fuzz parser and and JSON serializer. @DavidKorczynski @emanuele6 #2952\n- Keep releasing executables with legacy names. @itchyny #2951\n\n# 1.7\n\nAfter a five year hiatus we're back with a GitHub organization, with new admins and new maintainers who have brought a great deal of energy to make a long-awaited and long-needed new release.  We're very grateful for all the new owners, admins, and maintainers.  Special thanks go to Owen Ou (@owenthereal) for pushing to set up a new GitHub organization for jq, Stephen Dolan (@stedolan) for transferring the jq repository to the new organization, @itchyny for doing a great deal of work to get the release done, Mattias Wadman (@wader) and Emanuele Torre (@emanuele6) for many PRs and code reviews.  Many others also contributed PRs, issues, and code reviews as well, and you can find their contributions in the Git log and on the [closed issues and PRs page](https://github.com/jqlang/jq/issues?q=is%3Aclosed+sort%3Aupdated-desc).\n\nSince the last stable release many things have happened:\n\n- jq now lives at <https://github.com/jqlang>\n- New maintainers, admins, and owners have been recruited.\n  - A list of [current maintainers](https://github.com/jqlang/jq/blob/jq-1.7/AUTHORS#L4-L14)\n- NEWS file is replaced by NEWS.md with Markdown format. @wader #2599\n- CI, scan builds, release, website builds etc now use GitHub actions. @owenthereal @wader @itchyny #2596 #2603 #2620 #2723\n- Lots of documentation improvements and fixes.\n- Website updated with new section search box, better section ids for linking, dark mode, etc. @itchyny #2628\n- Release builds for:\n  - Linux `amd64`, `arm64`, `armel`, `armhf`, `i386`, `mips`, `mips64`, `mips64el`, `mips64r6`, `mips64r6el`, `mipsel`, `mipsr6`, `mipsr6el`, `powerpc`, `ppc64el`, `riscv64` and `s390x`\n  - macOS `amd64` and `arm64`\n  - Windows `i386` and `amd64`\n  - Docker `linux/386`, `linux/amd64`, `linux/arm64`, `linux/mips64le`, `linux/ppc64le`, `linux/riscv64` and `linux/s390x`\n  - More details see @owenthereal #2665\n- Docker images are now available from `ghcr.io/jqlang/jq` instead of Docker Hub. @itchyny #2652 #2686\n- OSS-fuzz. @DavidKorczynski #2760 #2762\n\nFull commit log can be found at <https://github.com/jqlang/jq/compare/jq-1.6...jq-1.7> but here are some highlights:\n\n## CLI changes\n\n- Make object key color configurable using `JQ_COLORS` environment variable. @itchyny @haguenau @ericpruitt #2703\n\n  ```sh\n  # this would make \"field\" bold yellow (`1;33`, the last value)\n  $ JQ_COLORS=\"0;90:0;37:0;37:0;37:0;32:1;37:1;37:1;33\" ./jq -n '{field: 123}'\n  {\n    \"field\": 123\n  }\n  ```\n\n- Change the default color of null to Bright Black. @itchyny #2824\n- Respect `NO_COLOR` environment variable to disable color output. See <https://no-color.org> for details. @itchyny #2728\n- Improved `--help` output. Now mentions all options and nicer order. @itchyny @wader #2747 #2766 #2799\n- Fix multiple issues of exit code using `--exit-code`/`-e` option. @ryo1kato #1697\n\n  ```sh\n  # true-ish last output value exits with zero\n  $ jq -ne true ; echo $?\n  true\n  0\n  # false-ish last output value (false and null) exits with 1\n  $ jq -ne false ; echo $?\n  false\n  1\n  # no output value exists with 4\n  $ jq -ne empty ; echo $?\n  4\n  ```\n\n- Add `--binary`/`-b` on Windows for binary output. To get `\\n` instead of `\\r\\n` line endings. @nicowilliams 0dab2b1\n- Add `--raw-output0` for NUL (zero byte) separated output. @asottile @pabs3 @itchyny #1990 #2235 #2684\n\n  ```sh\n  # will output a zero byte after each output\n  $ jq -n --raw-output0 '1,2,3' | xxd\n  00000000: 3100 3200 3300                           1.2.3.\n  # can be used with xargs -0\n  $ jq -n --raw-output0 '\"a\",\"b\",\"c\"' | xargs -0 -n1\n  a\n  b\n  c\n  $ jq -n --raw-output0 '\"a b c\", \"d\\ne\\nf\"' | xargs -0 printf '[%s]\\n'\n  [a b c]\n  [d\n  e\n  f]\n  # can be used with read -d ''\n  $ while IFS= read -r -d '' json; do\n  >   jq '.name' <<< \"$json\"\n  > done < <(jq -n --raw-output0 '{name:\"a b c\"},{name:\"d\\ne\\nf\"}')\n  \"a b c\"\n  \"d\\ne\\nf\"\n  # also it's an error to output a string containing a NUL when using NUL separator\n  $ jq -n --raw-output0 '\"\\u0000\"'\n  jq: error (at <unknown>): Cannot dump a string containing NUL with --raw-output0 option\n  ```\n\n- Fix assert crash and validate JSON for `--jsonarg`. @wader #2658\n- Remove deprecated `--argfile` option. @itchyny #2768\n- Enable stack protection. @nicowilliams #2801\n\n## Language changes\n\n- Use decimal number literals to preserve precision. Comparison operations respects precision but arithmetic operations might truncate. @leonid-s-usov #1752\n\n  ```sh\n  # precision is preserved\n  $ echo '100000000000000000' | jq .\n  100000000000000000\n  # comparison respects precision (this is false in JavaScript)\n  $ jq -n '100000000000000000 < 100000000000000001'\n  true\n  # sort/0 works\n  $ jq -n -c '[100000000000000001, 100000000000000003, 100000000000000004, 100000000000000002] | sort'\n  [100000000000000001,100000000000000002,100000000000000003,100000000000000004]\n  # arithmetic operations might truncate (same as JavaScript)\n  $ jq -n '100000000000000000 + 10'\n  100000000000000020\n  ```\n\n- Adds new builtin `pick(stream)` to emit a projection of the input object or array. @pkoppstein #2656 #2779\n\n  ```sh\n  $ jq -n '{\"a\": 1, \"b\": {\"c\": 2, \"d\": 3}, \"e\": 4} | pick(.a, .b.c, .x)'\n  {\n    \"a\": 1,\n    \"b\": {\n      \"c\": 2\n    },\n    \"x\": null\n  }\n  ```\n\n- Adds new builtin `debug(msgs)` that works like `debug` but applies a filter on the input before writing to stderr. @pkoppstein #2710\n\n  ```sh\n  $ jq -n '1 as $x | 2 | debug(\"Entering function foo with $x == \\($x)\", .) | (.+1)'\n  [\"DEBUG:\",\"Entering function foo with $x == 1\"]\n  [\"DEBUG:\",2]\n  3\n  $ jq -n '{a: 1, b: 2, c: 3} | debug({a, b, sum: (.a+.b)})'\n  [\"DEBUG:\",{\"a\":1,\"b\":2,\"sum\":3}]\n  {\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": 3\n  }\n  ```\n\n- Adds new builtin `scan($re; $flags)`. Was documented but not implemented. @itchyny #1961\n\n  ```sh\n  # look for pattern \"ab\" in \"abAB\" ignoring casing\n  $ jq -n '\"abAB\" | scan(\"ab\"; \"i\")'\n  \"ab\"\n  \"AB\"\n  ```\n\n- Adds new builtin `abs` to get absolute value. This potentially allows the literal value of numbers to be preserved as `length` and `fabs` convert to float. @pkoppstein #2767\n- Allow `if` without `else`-branch. When skipped the `else`-branch will be `.` (identity). @chancez @wader #1825 #2481\n\n  ```sh\n  # convert 1 to \"one\" otherwise keep as is\n  $ jq -n '1,2 | if . == 1 then \"one\" end'\n  \"one\"\n  2\n  # behaves the same as\n  $ jq -n '1,2 | if . == 1 then \"one\" else . end'\n  \"one\"\n  2\n  # also works with elif\n  $ jq -n '1,2,3 | if . == 1 then \"one\" elif . == 2 then \"two\" end\n  \"one\"\n  \"two\"\n  3\n  ```\n\n- Allow use of `$binding` as key in object literals. @nicowilliams 8ea4a55\n\n  ```sh\n  $ jq -n '\"a\" as $key | {$key: 123}'\n  {\n    \"a\": 123\n  }\n  # previously parentheses were needed\n  $ jq -n '\"a\" as $key | {($key): 123}'\n  {\n    \"a\": 123\n  }\n  ```\n\n- Allow dot between chained indexes when using `.[\"index\"]` @nicowilliams #1168\n\n  ```sh\n  $ jq -n '{\"a\": {\"b\": 123}} | .a[\"b\"]'\n  123\n  # now this also works\n  $ jq -n '{\"a\": {\"b\": 123}} | .a.[\"b\"]'\n  123\n  ```\n\n- Allow dot for chained value iterator `.[]`, `.[]?` @wader #2650\n\n  ```sh\n  $ jq -n '{\"a\": [123]} | .a[]'\n  123\n  # now this also works\n  $ jq -n '{\"a\": [123]} | .a.[]'\n  123\n  ```\n\n- Fix try/catch catches more than it should. @nicowilliams #2750\n- Speed up and refactor some builtins, also remove `scalars_or_empty/0`. @muhmuhten #1845\n- Now `halt` and `halt_error` exit immediately instead of continuing to the next input. @emanuele6 #2667\n- Fix issue converting string to number after previous convert error. @thalman #2400\n- Fix issue representing large numbers on some platforms causing invalid JSON output. @itchyny #2661\n- Fix deletion using assigning empty against arrays. @itchyny #2133\n\n  ```sh\n  # now this works as expected, filter out all values over 2 by assigning empty\n  $ jq -c '(.[] | select(. >= 2)) |= empty' <<< '[1,5,3,0,7]'\n  [1,0]\n  ```\n\n- Allow keywords to be used as binding name in more places. @emanuele6 #2681\n- Allow using `nan` as NaN in JSON. @emanuele6 #2712\n- Expose a module's function names in `modulemeta`. @mrwilson #2837\n- Fix `contains/1` to handle strings with NUL. @nicowilliams 61cd6db\n- Fix `stderr/0` to output raw text without any decoration. @itchyny #2751\n- Fix `nth/2` to emit empty on index out of range. @itchyny #2674\n- Fix `implode` to not assert and instead replace invalid unicode codepoints. @wader #2646\n- Fix `indices/1` and `rindex/1` in case of overlapping matches in strings. @emanuele6 #2718\n- Fix `sub/3` to resolve issues involving global search-and-replace (gsub) operations. @pkoppstein #2641\n- Fix `significand/0`, `gamma/0` and `drem/2` to be available on macOS. @itchyny #2756 #2775\n- Fix empty regular expression matches. @itchyny #2677\n- Fix overflow exception of the modulo operator. @itchyny #2629\n- Fix string multiplication by 0 (and less than 1) to emit empty string. @itchyny #2142\n- Fix segfault when using libjq and threads. @thalman #2546\n- Fix constant folding of division and reminder with zero divisor. @itchyny #2797\n- Fix `error/0`, `error/1` to throw null error. @emanuele6 #2823\n- Simpler and faster `transpose`. @pkoppstein #2758\n- Simple and efficient implementation of `walk/1`. @pkoppstein #2795\n- Remove deprecated filters `leaf_paths`, `recurse_down`. @itchyny #2666\n\n# Previous releases\n\nRelease history\n\n- jq version 1.6 was released on Fri Nov 2 2018\n- jq version 1.5 was released on Sat Aug 15 2015\n- jq version 1.4 was released on Mon Jun 9 2014\n- jq version 1.3 was released on Sun May 19 2013\n- jq version 1.2 was released on Thu Dec 20 2012\n- jq version 1.1 was released on Sun Oct 21 2012\n- jq version 1.0 was released on Sun Oct 21 2012\n\nNew features in 1.6 since 1.5:\n\n- Destructuring Alternation\n\n- New Builtins:\n  - builtins/0\n  - stderr/0\n  - halt/0, halt_error/1\n  - isempty/1\n  - walk/1\n  - utf8bytelength/1\n  - localtime/0, strflocaltime/1\n  - SQL-style builtins\n  - and more!\n\n- Add support for ASAN and UBSAN\n\n- Make it easier to use jq with shebangs (8f6f28c)\n\n- Add $ENV builtin variable to access environment\n\n- Add JQ_COLORS env var for configuring the output colors\n\nNew features in 1.5 since 1.4:\n\n- regular expressions (with Oniguruma)\n\n- a library/module system\n\n- many new builtins\n\n  - datetime builtins\n  - math builtins\n  - regexp-related builtins\n  - stream-related builtins (e.g., all/1, any/1)\n  - minimal I/O builtins (`inputs`, `debug`)\n\n- new syntactic features, including:\n\n  - destructuring (`. as [$first, $second] | ...`)\n  - try/catch, generalized `?` operator, and label/break\n  - `foreach`\n  - multiple definitions of a function with different numbers of\n      arguments\n\n- command-line arguments\n\n  - --join-lines / -j for raw output\n  - --argjson and --slurpfile\n  - --tab and --indent\n  - --stream (streaming JSON parser)\n  - --seq (RFC7464 JSON text sequence)\n  - --run-tests improvements\n\n- optimizations:\n\n  - tail-call optimization\n  - reduce and foreach no longer leak a reference to .\n\nNew features in 1.4 since 1.3:\n\n- command-line arguments\n\n  - jq --arg-file variable file\n  - jq --unbuffered\n  - jq -e / --exit-status (set exit status based on outputs)\n  - jq -S / --sort-keys (now jq no longer sorts object keys by\n      default\n\n- syntax\n\n  - .. -> like // in XPath (recursive traversal)\n  - question mark (e.g., .a?) to suppress errors\n  - .\"foo\" syntax (equivalent to .[\"foo\"])\n  - better error handling for .foo\n  - added % operator (modulo)\n  - allow negation without requiring extra parenthesis\n  - more function arguments (up to six)\n\n- filters:\n\n  - any, all\n  - iterables, arrays, objects, scalars, nulls, booleans, numbers,\n      strings, values\n\n- string built-ins:\n\n  - split\n  - join (join an array of strings with a given separator string)\n  - ltrimstr, rtrimstr\n  - startswith, endswith\n  - explode, implode\n  - fromjson, tojson\n  - index, rindex, indices\n\n- math functions\n\n  - floor, sqrt, cbrt, etcetera (depends on what's available from libm)\n\n- libjq -- a C API interface to jq's JSON representation and for\n   running jq programs from C applications\n", "/*\n * Portions Copyright (c) 2016 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n#include <stddef.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n\n#include \"jv_alloc.h\"\n#include \"jv.h\"\n#include \"jv_unicode.h\"\n#include \"util.h\"\n\n/*\n * Internal refcounting helpers\n */\n\ntypedef struct jv_refcnt {\n  int count;\n} jv_refcnt;\n\nstatic const jv_refcnt JV_REFCNT_INIT = {1};\n\nstatic void jvp_refcnt_inc(jv_refcnt* c) {\n  c->count++;\n}\n\nstatic int jvp_refcnt_dec(jv_refcnt* c) {\n  c->count--;\n  return c->count == 0;\n}\n\nstatic int jvp_refcnt_unshared(jv_refcnt* c) {\n  assert(c->count > 0);\n  return c->count == 1;\n}\n\n#define KIND_MASK   0xF\n#define PFLAGS_MASK 0xF0\n#define PTYPE_MASK  0x70\n\ntypedef enum {\n  JVP_PAYLOAD_NONE = 0,\n  JVP_PAYLOAD_ALLOCATED = 0x80,\n} payload_flags;\n\n#define JVP_MAKE_PFLAGS(ptype, allocated) ((((ptype) << 4) & PTYPE_MASK) | ((allocated) ? JVP_PAYLOAD_ALLOCATED : 0))\n#define JVP_MAKE_FLAGS(kind, pflags) ((kind & KIND_MASK) | (pflags & PFLAGS_MASK))\n\n#define JVP_FLAGS(j)  ((j).kind_flags)\n#define JVP_KIND(j)   (JVP_FLAGS(j) & KIND_MASK)\n\n#define JVP_HAS_FLAGS(j, flags) (JVP_FLAGS(j) == flags)\n#define JVP_HAS_KIND(j, kind)   (JVP_KIND(j) == kind)\n\n#define JVP_IS_ALLOCATED(j) (j.kind_flags & JVP_PAYLOAD_ALLOCATED)\n\n#define JVP_FLAGS_NULL      JVP_MAKE_FLAGS(JV_KIND_NULL, JVP_PAYLOAD_NONE)\n#define JVP_FLAGS_INVALID   JVP_MAKE_FLAGS(JV_KIND_INVALID, JVP_PAYLOAD_NONE)\n#define JVP_FLAGS_FALSE     JVP_MAKE_FLAGS(JV_KIND_FALSE, JVP_PAYLOAD_NONE)\n#define JVP_FLAGS_TRUE      JVP_MAKE_FLAGS(JV_KIND_TRUE, JVP_PAYLOAD_NONE)\n\njv_kind jv_get_kind(jv x) {\n  return JVP_KIND(x);\n}\n\nconst char* jv_kind_name(jv_kind k) {\n  switch (k) {\n  case JV_KIND_INVALID: return \"<invalid>\";\n  case JV_KIND_NULL:    return \"null\";\n  case JV_KIND_FALSE:   return \"boolean\";\n  case JV_KIND_TRUE:    return \"boolean\";\n  case JV_KIND_NUMBER:  return \"number\";\n  case JV_KIND_STRING:  return \"string\";\n  case JV_KIND_ARRAY:   return \"array\";\n  case JV_KIND_OBJECT:  return \"object\";\n  }\n  assert(0 && \"invalid kind\");\n  return \"<unknown>\";\n}\n\nconst jv JV_NULL = {JVP_FLAGS_NULL, 0, 0, 0, {0}};\nconst jv JV_INVALID = {JVP_FLAGS_INVALID, 0, 0, 0, {0}};\nconst jv JV_FALSE = {JVP_FLAGS_FALSE, 0, 0, 0, {0}};\nconst jv JV_TRUE = {JVP_FLAGS_TRUE, 0, 0, 0, {0}};\n\njv jv_true() {\n  return JV_TRUE;\n}\n\njv jv_false() {\n  return JV_FALSE;\n}\n\njv jv_null() {\n  return JV_NULL;\n}\n\njv jv_bool(int x) {\n  return x ? JV_TRUE : JV_FALSE;\n}\n\n/*\n * Invalid objects, with optional error messages\n */\n\n#define JVP_FLAGS_INVALID_MSG   JVP_MAKE_FLAGS(JV_KIND_INVALID, JVP_PAYLOAD_ALLOCATED)\n\ntypedef struct {\n  jv_refcnt refcnt;\n  jv errmsg;\n} jvp_invalid;\n\njv jv_invalid_with_msg(jv err) {\n  jvp_invalid* i = jv_mem_alloc(sizeof(jvp_invalid));\n  i->refcnt = JV_REFCNT_INIT;\n  i->errmsg = err;\n\n  jv x = {JVP_FLAGS_INVALID_MSG, 0, 0, 0, {&i->refcnt}};\n  return x;\n}\n\njv jv_invalid() {\n  return JV_INVALID;\n}\n\njv jv_invalid_get_msg(jv inv) {\n  assert(JVP_HAS_KIND(inv, JV_KIND_INVALID));\n\n  jv x;\n  if (JVP_HAS_FLAGS(inv, JVP_FLAGS_INVALID_MSG)) {\n    x = jv_copy(((jvp_invalid*)inv.u.ptr)->errmsg);\n  }\n  else {\n    x = jv_null();\n  }\n\n  jv_free(inv);\n  return x;\n}\n\nint jv_invalid_has_msg(jv inv) {\n  assert(JVP_HAS_KIND(inv, JV_KIND_INVALID));\n  int r = JVP_HAS_FLAGS(inv, JVP_FLAGS_INVALID_MSG);\n  jv_free(inv);\n  return r;\n}\n\nstatic void jvp_invalid_free(jv x) {\n  assert(JVP_HAS_KIND(x, JV_KIND_INVALID));\n  if (JVP_HAS_FLAGS(x, JVP_FLAGS_INVALID_MSG) && jvp_refcnt_dec(x.u.ptr)) {\n    jv_free(((jvp_invalid*)x.u.ptr)->errmsg);\n    jv_mem_free(x.u.ptr);\n  }\n}\n\n/*\n * Numbers\n */\n\n#ifdef USE_DECNUM\n#include \"jv_dtoa.h\"\n#include \"jv_dtoa_tsd.h\"\n\n// we will manage the space for the struct\n#define DECNUMDIGITS 1\n#include \"decNumber/decNumber.h\"\n\nenum {\n  JVP_NUMBER_NATIVE = 0,\n  JVP_NUMBER_DECIMAL = 1\n};\n\n#define JV_NUMBER_SIZE_INIT      (0)\n#define JV_NUMBER_SIZE_CONVERTED (1)\n\n#define JVP_FLAGS_NUMBER_NATIVE       JVP_MAKE_FLAGS(JV_KIND_NUMBER, JVP_MAKE_PFLAGS(JVP_NUMBER_NATIVE, 0))\n#define JVP_FLAGS_NUMBER_LITERAL      JVP_MAKE_FLAGS(JV_KIND_NUMBER, JVP_MAKE_PFLAGS(JVP_NUMBER_DECIMAL, 1))\n\n// the decimal precision of binary double\n#define DEC_NUBMER_DOUBLE_PRECISION   (17)\n#define DEC_NUMBER_STRING_GUARD       (14)\n#define DEC_NUBMER_DOUBLE_EXTRA_UNITS ((DEC_NUBMER_DOUBLE_PRECISION - DECNUMDIGITS + DECDPUN - 1)/DECDPUN)\n\n#include \"jv_thread.h\"\n#ifdef WIN32\n#ifndef __MINGW32__\n/* Copied from Heimdal: thread-specific keys; see lib/base/dll.c in Heimdal */\n\n/*\n * This is an implementation of thread-specific storage with\n * destructors.  WIN32 doesn't quite have this.  Instead it has\n * DllMain(), an entry point in every DLL that gets called to notify the\n * DLL of thread/process \"attach\"/\"detach\" events.\n *\n * We use __thread (or __declspec(thread)) for the thread-local itself\n * and DllMain() DLL_THREAD_DETACH events to drive destruction of\n * thread-local values.\n *\n * When building in maintainer mode on non-Windows pthread systems this\n * uses a single pthread key instead to implement multiple keys.  This\n * keeps the code from rotting when modified by non-Windows developers.\n */\n\n/* Logical array of keys that grows lock-lessly */\ntypedef struct tls_keys tls_keys;\nstruct tls_keys {\n    void (**keys_dtors)(void *);    /* array of destructors         */\n    size_t keys_start_idx;          /* index of first destructor    */\n    size_t keys_num;\n    tls_keys *keys_next;\n};\n\n/*\n * Well, not quite locklessly.  We need synchronization primitives to do\n * this locklessly.  An atomic CAS will do.\n */\nstatic pthread_mutex_t tls_key_defs_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic tls_keys *tls_key_defs;\n\n/* Logical array of values (per-thread; no locking needed here) */\nstruct tls_values {\n    void **values; /* realloc()ed */\n    size_t values_num;\n};\n\n#ifdef _MSC_VER\nstatic __declspec(thread) struct nomem_handler nomem_handler;\n#else\nstatic __thread struct tls_values values;\n#endif\n\n#define DEAD_KEY ((void *)8)\n\nstatic void\nw32_service_thread_detach(void *unused)\n{\n    tls_keys *key_defs;\n    void (*dtor)(void*);\n    size_t i;\n\n    pthread_mutex_lock(&tls_key_defs_lock);\n    key_defs = tls_key_defs;\n    pthread_mutex_unlock(&tls_key_defs_lock);\n\n    if (key_defs == NULL)\n        return;\n\n    for (i = 0; i < values.values_num; i++) {\n        assert(i >= key_defs->keys_start_idx);\n        if (i >= key_defs->keys_start_idx + key_defs->keys_num) {\n            pthread_mutex_lock(&tls_key_defs_lock);\n            key_defs = key_defs->keys_next;\n            pthread_mutex_unlock(&tls_key_defs_lock);\n\n            assert(key_defs != NULL);\n            assert(i >= key_defs->keys_start_idx);\n            assert(i < key_defs->keys_start_idx + key_defs->keys_num);\n        }\n        dtor = key_defs->keys_dtors[i - key_defs->keys_start_idx];\n        if (values.values[i] != NULL && dtor != NULL && dtor != DEAD_KEY)\n            dtor(values.values[i]);\n        values.values[i] = NULL;\n    }\n}\n\nextern void jv_tsd_dtoa_ctx_init();\nextern void jv_tsd_dtoa_ctx_fini();\nvoid jv_tsd_dec_ctx_fini();\nvoid jv_tsd_dec_ctx_init();\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL,\n                    DWORD fdwReason,\n                    LPVOID lpvReserved)\n{\n    switch (fdwReason) {\n    case DLL_PROCESS_ATTACH:\n\t/*create_pt_key();*/\n\tjv_tsd_dtoa_ctx_init();\n\tjv_tsd_dec_ctx_init();\n\treturn TRUE;\n    case DLL_PROCESS_DETACH:\n\tjv_tsd_dtoa_ctx_fini();\n\tjv_tsd_dec_ctx_fini();\n\treturn TRUE;\n    case DLL_THREAD_ATTACH: return 0;\n    case DLL_THREAD_DETACH:\n        w32_service_thread_detach(NULL);\n        return TRUE;\n    default: return TRUE;\n    }\n}\n\nint\npthread_key_create(pthread_key_t *key, void (*dtor)(void *))\n{\n    tls_keys *key_defs, *new_key_defs;\n    size_t i, k;\n    int ret = ENOMEM;\n\n    pthread_mutex_lock(&tls_key_defs_lock);\n    if (tls_key_defs == NULL) {\n        /* First key */\n        new_key_defs = calloc(1, sizeof(*new_key_defs));\n        if (new_key_defs == NULL) {\n            pthread_mutex_unlock(&tls_key_defs_lock);\n            return ENOMEM;\n        }\n        new_key_defs->keys_num = 8;\n        new_key_defs->keys_dtors = calloc(new_key_defs->keys_num,\n                                          sizeof(*new_key_defs->keys_dtors));\n        if (new_key_defs->keys_dtors == NULL) {\n            pthread_mutex_unlock(&tls_key_defs_lock);\n            free(new_key_defs);\n            return ENOMEM;\n        }\n        tls_key_defs = new_key_defs;\n        new_key_defs->keys_dtors[0] = dtor;\n        for (i = 1; i < new_key_defs->keys_num; i++)\n            new_key_defs->keys_dtors[i] = NULL;\n        pthread_mutex_unlock(&tls_key_defs_lock);\n        return 0;\n    }\n\n    for (key_defs = tls_key_defs;\n         key_defs != NULL;\n         key_defs = key_defs->keys_next) {\n        k = key_defs->keys_start_idx;\n        for (i = 0; i < key_defs->keys_num; i++, k++) {\n            if (key_defs->keys_dtors[i] == NULL) {\n                /* Found free slot; use it */\n                key_defs->keys_dtors[i] = dtor;\n                *key = k;\n                pthread_mutex_unlock(&tls_key_defs_lock);\n                return 0;\n            }\n        }\n        if (key_defs->keys_next != NULL)\n            continue;\n\n        /* Grow the registration array */\n        /* XXX DRY */\n        new_key_defs = calloc(1, sizeof(*new_key_defs));\n        if (new_key_defs == NULL)\n            break;\n\n        new_key_defs->keys_dtors =\n            calloc(key_defs->keys_num + key_defs->keys_num / 2,\n                   sizeof(*new_key_defs->keys_dtors));\n        if (new_key_defs->keys_dtors == NULL) {\n            free(new_key_defs);\n            break;\n        }\n        new_key_defs->keys_start_idx = key_defs->keys_start_idx +\n            key_defs->keys_num;\n        new_key_defs->keys_num = key_defs->keys_num + key_defs->keys_num / 2;\n        new_key_defs->keys_dtors[i] = dtor;\n        for (i = 1; i < new_key_defs->keys_num; i++)\n            new_key_defs->keys_dtors[i] = NULL;\n        key_defs->keys_next = new_key_defs;\n        ret = 0;\n        break;\n    }\n    pthread_mutex_unlock(&tls_key_defs_lock);\n    return ret;\n}\n\nstatic void\nkey_lookup(pthread_key_t key, tls_keys **kd,\n           size_t *dtor_idx, void (**dtor)(void *))\n{\n    tls_keys *key_defs;\n\n    if (kd != NULL)\n        *kd = NULL;\n    if (dtor_idx != NULL)\n        *dtor_idx = 0;\n    if (dtor != NULL)\n        *dtor = NULL;\n\n    pthread_mutex_lock(&tls_key_defs_lock);\n    key_defs = tls_key_defs;\n    pthread_mutex_unlock(&tls_key_defs_lock);\n\n    while (key_defs != NULL) {\n        if (key >= key_defs->keys_start_idx &&\n            key < key_defs->keys_start_idx + key_defs->keys_num) {\n            if (kd != NULL)\n                *kd = key_defs;\n            if (dtor_idx != NULL)\n                *dtor_idx = key - key_defs->keys_start_idx;\n            if (dtor != NULL)\n                *dtor = key_defs->keys_dtors[key - key_defs->keys_start_idx];\n            return;\n        }\n\n        pthread_mutex_lock(&tls_key_defs_lock);\n        key_defs = key_defs->keys_next;\n        pthread_mutex_unlock(&tls_key_defs_lock);\n        assert(key_defs != NULL);\n        assert(key >= key_defs->keys_start_idx);\n    }\n}\n\nint\npthread_setspecific(pthread_key_t key, void *value)\n{\n    void **new_values;\n    size_t new_num;\n    void (*dtor)(void *);\n    size_t i;\n\n    key_lookup(key, NULL, NULL, &dtor);\n    if (dtor == NULL)\n        return EINVAL;\n\n    if (key >= values.values_num) {\n        if (values.values_num == 0) {\n            values.values = NULL;\n            new_num = 8;\n        } else {\n            new_num = (values.values_num + values.values_num / 2);\n        }\n        new_values = realloc(values.values, sizeof(void *) * new_num);\n        if (new_values == NULL)\n            return ENOMEM;\n        for (i = values.values_num; i < new_num; i++)\n            new_values[i] = NULL;\n        values.values = new_values;\n        values.values_num = new_num;\n    }\n\n    assert(key < values.values_num);\n\n    if (values.values[key] != NULL && dtor != NULL && dtor != DEAD_KEY)\n        dtor(values.values[key]);\n\n    values.values[key] = value;\n    return 0;\n}\n\nvoid *\npthread_getspecific(pthread_key_t key)\n{\n    if (key >= values.values_num)\n        return NULL;\n    return values.values[key];\n}\n#else\n#include <pthread.h>\n#endif\n#else\n#include <pthread.h>\n#endif\n\nstatic pthread_key_t dec_ctx_key;\nstatic pthread_once_t dec_ctx_once = PTHREAD_ONCE_INIT;\n\n#define DEC_CONTEXT() tsd_dec_ctx_get(&dec_ctx_key)\n\n// atexit finalizer to clean up the tsd dec contexts if main() exits\n// without having called pthread_exit()\nvoid jv_tsd_dec_ctx_fini() {\n  jv_mem_free(pthread_getspecific(dec_ctx_key));\n  pthread_setspecific(dec_ctx_key, NULL);\n}\n\nvoid jv_tsd_dec_ctx_init() {\n  if (pthread_key_create(&dec_ctx_key, jv_mem_free) != 0) {\n    fprintf(stderr, \"error: cannot create thread specific key\");\n    abort();\n  }\n  atexit(jv_tsd_dec_ctx_fini);\n}\n\nstatic decContext* tsd_dec_ctx_get(pthread_key_t *key) {\n  pthread_once(&dec_ctx_once, jv_tsd_dec_ctx_init); // cannot fail\n  decContext *ctx = (decContext*)pthread_getspecific(*key);\n  if (ctx) {\n    return ctx;\n  }\n\n  ctx = malloc(sizeof(decContext));\n  if (ctx) {\n    if (key == &dec_ctx_key)\n    {\n      decContextDefault(ctx, DEC_INIT_BASE);\n      // make sure (Int)D2U(rhs->exponent-lhs->exponent) does not overflow\n      ctx->digits = MIN(DEC_MAX_DIGITS,\n          INT32_MAX - (DECDPUN - 1) - (ctx->emax - ctx->emin - 1));\n      ctx->traps = 0; /*no errors*/\n    }\n    if (pthread_setspecific(*key, ctx) != 0) {\n      fprintf(stderr, \"error: cannot store thread specific data\");\n      abort();\n    }\n  }\n  return ctx;\n}\n\ntypedef struct {\n  jv_refcnt refcnt;\n  double num_double;\n  char * literal_data;\n  decNumber num_decimal; // must be the last field in the structure for memory management\n} jvp_literal_number;\n\ntypedef struct {\n  decNumber number;\n  decNumberUnit units[DEC_NUBMER_DOUBLE_EXTRA_UNITS];\n} decNumberDoublePrecision;\n\n\nstatic inline int jvp_number_is_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n  return JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL);\n}\n\nstatic jvp_literal_number* jvp_literal_number_ptr(jv j) {\n  assert(JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL));\n  return (jvp_literal_number*)j.u.ptr;\n}\n\nstatic decNumber* jvp_dec_number_ptr(jv j) {\n  assert(JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL));\n  return &(((jvp_literal_number*)j.u.ptr)->num_decimal);\n}\n\nstatic jvp_literal_number* jvp_literal_number_alloc(unsigned literal_length) {\n\n  /* The number of units needed is ceil(DECNUMDIGITS/DECDPUN)         */\n  int units = ((literal_length+DECDPUN-1)/DECDPUN);\n\n  jvp_literal_number* n = jv_mem_alloc(\n    sizeof(jvp_literal_number)\n    + sizeof(decNumberUnit) * units\n  );\n\n  return n;\n}\n\nstatic jv jvp_literal_number_new(const char * literal) {\n\n  jvp_literal_number * n = jvp_literal_number_alloc(strlen(literal));\n\n  n->refcnt = JV_REFCNT_INIT;\n  n->literal_data = NULL;\n  decContext *ctx = DEC_CONTEXT();\n  decContextClearStatus(ctx, DEC_Conversion_syntax);\n  decNumberFromString(&n->num_decimal, literal, ctx);\n  n->num_double = NAN;\n\n  if (ctx->status & DEC_Conversion_syntax) {\n    jv_mem_free(n);\n    return JV_INVALID;\n  }\n\n  jv r = {JVP_FLAGS_NUMBER_LITERAL, 0, 0, JV_NUMBER_SIZE_INIT, {&n->refcnt}};\n  return r;\n}\n\nstatic double jvp_literal_number_to_double(jv j) {\n  assert(JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL));\n  decContext dblCtx;\n\n  // init as decimal64 but change digits to allow conversion to binary64 (double)\n  decContextDefault(&dblCtx, DEC_INIT_DECIMAL64);\n  dblCtx.digits = DEC_NUBMER_DOUBLE_PRECISION;\n\n  decNumber *p_dec_number = jvp_dec_number_ptr(j);\n  decNumberDoublePrecision dec_double;\n  char literal[DEC_NUBMER_DOUBLE_PRECISION + DEC_NUMBER_STRING_GUARD + 1];\n\n  // reduce the number to the shortest possible form\n  // that fits into the 64 bit floating point representation\n  decNumberReduce(&dec_double.number, p_dec_number, &dblCtx);\n\n  decNumberToString(&dec_double.number, literal);\n\n  char *end;\n  return jvp_strtod(tsd_dtoa_context_get(), literal, &end);\n}\n\nstatic const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n\nint jv_number_has_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n  return JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL);\n}\n\nconst char* jv_number_get_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n\n  if (JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL)) {\n    return jvp_literal_number_literal(n);\n  } else {\n    return NULL;\n  }\n}\n\njv jv_number_with_literal(const char * literal) {\n  return jvp_literal_number_new(literal);\n}\n#endif /* USE_DECNUM */\n\njv jv_number(double x) {\n  jv j = {\n#ifdef USE_DECNUM\n    JVP_FLAGS_NUMBER_NATIVE,\n#else\n    JV_KIND_NUMBER,\n#endif\n    0, 0, 0, {.number = x}\n  };\n  return j;\n}\n\nstatic void jvp_number_free(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL) && jvp_refcnt_dec(j.u.ptr)) {\n    jvp_literal_number* n = jvp_literal_number_ptr(j);\n    if (n->literal_data) {\n      jv_mem_free(n->literal_data);\n    }\n    jv_mem_free(n);\n  }\n#endif\n}\n\ndouble jv_number_value(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(j, JVP_FLAGS_NUMBER_LITERAL)) {\n    jvp_literal_number* n = jvp_literal_number_ptr(j);\n\n    if (j.size != JV_NUMBER_SIZE_CONVERTED) {\n      n->num_double = jvp_literal_number_to_double(j);\n      j.size = JV_NUMBER_SIZE_CONVERTED;\n    }\n\n    return n->num_double;\n  }\n#endif\n  return j.u.number;\n}\n\nint jv_is_integer(jv j){\n  if (!JVP_HAS_KIND(j, JV_KIND_NUMBER)){\n    return 0;\n  }\n\n  double x = jv_number_value(j);\n\n  double ipart;\n  double fpart = modf(x, &ipart);\n\n  return fabs(fpart) < DBL_EPSILON;\n}\n\nint jvp_number_is_nan(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber *pdec = jvp_dec_number_ptr(n);\n    return decNumberIsNaN(pdec);\n  }\n#endif\n  return n.u.number != n.u.number;\n}\n\nint jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    struct {\n      decNumber number;\n      decNumberUnit units[1];\n    } res;\n\n    decNumberCompare(&res.number,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res.number)) {\n      return 0;\n    } else if (decNumberIsNegative(&res.number)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nstatic int jvp_number_equal(jv a, jv b) {\n  return jvp_number_cmp(a, b) == 0;\n}\n\n/*\n * Arrays (internal helpers)\n */\n\n#define ARRAY_SIZE_ROUND_UP(n) (((n)*3)/2)\n#define JVP_FLAGS_ARRAY   JVP_MAKE_FLAGS(JV_KIND_ARRAY, JVP_PAYLOAD_ALLOCATED)\n\nstatic int imax(int a, int b) {\n  if (a>b) return a;\n  else return b;\n}\n\n//FIXME signed vs unsigned\ntypedef struct {\n  jv_refcnt refcnt;\n  int length, alloc_length;\n  jv elements[];\n} jvp_array;\n\nstatic jvp_array* jvp_array_ptr(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  return (jvp_array*)a.u.ptr;\n}\n\nstatic jvp_array* jvp_array_alloc(unsigned size) {\n  jvp_array* a = jv_mem_alloc(sizeof(jvp_array) + sizeof(jv) * size);\n  a->refcnt.count = 1;\n  a->length = 0;\n  a->alloc_length = size;\n  return a;\n}\n\nstatic jv jvp_array_new(unsigned size) {\n  jv r = {JVP_FLAGS_ARRAY, 0, 0, 0, {&jvp_array_alloc(size)->refcnt}};\n  return r;\n}\n\nstatic void jvp_array_free(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  if (jvp_refcnt_dec(a.u.ptr)) {\n    jvp_array* array = jvp_array_ptr(a);\n    for (int i=0; i<array->length; i++) {\n      jv_free(array->elements[i]);\n    }\n    jv_mem_free(array);\n  }\n}\n\nstatic int jvp_array_length(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  return a.size;\n}\n\nstatic int jvp_array_offset(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  return a.offset;\n}\n\nstatic jv* jvp_array_read(jv a, int i) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  if (i >= 0 && i < jvp_array_length(a)) {\n    jvp_array* array = jvp_array_ptr(a);\n    assert(i + jvp_array_offset(a) < array->length);\n    return &array->elements[i + jvp_array_offset(a)];\n  } else {\n    return 0;\n  }\n}\n\nstatic jv* jvp_array_write(jv* a, int i) {\n  assert(i >= 0);\n  jvp_array* array = jvp_array_ptr(*a);\n\n  int pos = i + jvp_array_offset(*a);\n  if (pos < array->alloc_length && jvp_refcnt_unshared(a->u.ptr)) {\n    // use existing array space\n    for (int j = array->length; j <= pos; j++) {\n      array->elements[j] = JV_NULL;\n    }\n    array->length = imax(pos + 1, array->length);\n    a->size = imax(i + 1, a->size);\n    return &array->elements[pos];\n  } else {\n    // allocate a new array\n    int new_length = imax(i + 1, jvp_array_length(*a));\n    jvp_array* new_array = jvp_array_alloc(ARRAY_SIZE_ROUND_UP(new_length));\n    int j;\n    for (j = 0; j < jvp_array_length(*a); j++) {\n      new_array->elements[j] =\n        jv_copy(array->elements[j + jvp_array_offset(*a)]);\n    }\n    for (; j < new_length; j++) {\n      new_array->elements[j] = JV_NULL;\n    }\n    new_array->length = new_length;\n    jvp_array_free(*a);\n    jv new_jv = {JVP_FLAGS_ARRAY, 0, 0, new_length, {&new_array->refcnt}};\n    *a = new_jv;\n    return &new_array->elements[i];\n  }\n}\n\nstatic int jvp_array_equal(jv a, jv b) {\n  if (jvp_array_length(a) != jvp_array_length(b))\n    return 0;\n  if (jvp_array_ptr(a) == jvp_array_ptr(b) &&\n      jvp_array_offset(a) == jvp_array_offset(b))\n    return 1;\n  for (int i=0; i<jvp_array_length(a); i++) {\n    if (!jv_equal(jv_copy(*jvp_array_read(a, i)),\n                  jv_copy(*jvp_array_read(b, i))))\n      return 0;\n  }\n  return 1;\n}\n\nstatic void jvp_clamp_slice_params(int len, int *pstart, int *pend)\n{\n  if (*pstart < 0) *pstart = len + *pstart;\n  if (*pend < 0) *pend = len + *pend;\n\n  if (*pstart < 0) *pstart = 0;\n  if (*pstart > len) *pstart = len;\n  if (*pend > len) *pend = len;\n  if (*pend < *pstart) *pend = *pstart;\n}\n\n\nstatic int jvp_array_contains(jv a, jv b) {\n  int r = 1;\n  jv_array_foreach(b, bi, belem) {\n    int ri = 0;\n    jv_array_foreach(a, ai, aelem) {\n      if (jv_contains(aelem, jv_copy(belem))) {\n        ri = 1;\n        break;\n      }\n    }\n    jv_free(belem);\n    if (!ri) {\n      r = 0;\n      break;\n    }\n  }\n  return r;\n}\n\n\n/*\n * Public\n */\n\nstatic jv jvp_array_slice(jv a, int start, int end) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  int len = jvp_array_length(a);\n  jvp_clamp_slice_params(len, &start, &end);\n  assert(0 <= start && start <= end && end <= len);\n\n  // FIXME: maybe slice should reallocate if the slice is small enough\n  if (start == end) {\n    jv_free(a);\n    return jv_array();\n  }\n\n  if (a.offset + start >= 1 << (sizeof(a.offset) * CHAR_BIT)) {\n    jv r = jv_array_sized(end - start);\n    for (int i = start; i < end; i++)\n      r = jv_array_append(r, jv_array_get(jv_copy(a), i));\n    jv_free(a);\n    return r;\n  } else {\n    a.offset += start;\n    a.size = end - start;\n    return a;\n  }\n}\n\n/*\n * Arrays (public interface)\n */\n\njv jv_array_sized(int n) {\n  return jvp_array_new(n);\n}\n\njv jv_array() {\n  return jv_array_sized(16);\n}\n\nint jv_array_length(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n  int len = jvp_array_length(j);\n  jv_free(j);\n  return len;\n}\n\njv jv_array_get(jv j, int idx) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n  jv* slot = jvp_array_read(j, idx);\n  jv val;\n  if (slot) {\n    val = jv_copy(*slot);\n  } else {\n    val = jv_invalid();\n  }\n  jv_free(j);\n  return val;\n}\n\njv jv_array_set(jv j, int idx, jv val) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n\n  if (idx < 0)\n    idx = jvp_array_length(j) + idx;\n  if (idx < 0) {\n    jv_free(j);\n    jv_free(val);\n    return jv_invalid_with_msg(jv_string(\"Out of bounds negative array index\"));\n  }\n  // copy/free of val,j coalesced\n  jv* slot = jvp_array_write(&j, idx);\n  jv_free(*slot);\n  *slot = val;\n  return j;\n}\n\njv jv_array_append(jv j, jv val) {\n  // copy/free of val,j coalesced\n  return jv_array_set(j, jv_array_length(jv_copy(j)), val);\n}\n\njv jv_array_concat(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  assert(JVP_HAS_KIND(b, JV_KIND_ARRAY));\n\n  // FIXME: could be faster\n  jv_array_foreach(b, i, elem) {\n    a = jv_array_append(a, elem);\n  }\n  jv_free(b);\n  return a;\n}\n\njv jv_array_slice(jv a, int start, int end) {\n  assert(JVP_HAS_KIND(a, JV_KIND_ARRAY));\n  // copy/free of a coalesced\n  return jvp_array_slice(a, start, end);\n}\n\njv jv_array_indexes(jv a, jv b) {\n  jv res = jv_array();\n  int idx = -1;\n  jv_array_foreach(a, ai, aelem) {\n    jv_free(aelem);\n    jv_array_foreach(b, bi, belem) {\n      if (!jv_equal(jv_array_get(jv_copy(a), ai + bi), jv_copy(belem)))\n        idx = -1;\n      else if (bi == 0 && idx == -1)\n        idx = ai;\n      jv_free(belem);\n    }\n    if (idx > -1)\n      res = jv_array_append(res, jv_number(idx));\n    idx = -1;\n  }\n  jv_free(a);\n  jv_free(b);\n  return res;\n}\n\n/*\n * Strings (internal helpers)\n */\n\n#define JVP_FLAGS_STRING  JVP_MAKE_FLAGS(JV_KIND_STRING, JVP_PAYLOAD_ALLOCATED)\n\ntypedef struct {\n  jv_refcnt refcnt;\n  uint32_t hash;\n  // high 31 bits are length, low bit is a flag\n  // indicating whether hash has been computed.\n  uint32_t length_hashed;\n  uint32_t alloc_length;\n  char data[];\n} jvp_string;\n\nstatic jvp_string* jvp_string_ptr(jv a) {\n  assert(JVP_HAS_KIND(a, JV_KIND_STRING));\n  return (jvp_string*)a.u.ptr;\n}\n\nstatic jvp_string* jvp_string_alloc(uint32_t size) {\n  jvp_string* s = jv_mem_alloc(sizeof(jvp_string) + size + 1);\n  s->refcnt.count = 1;\n  s->alloc_length = size;\n  return s;\n}\n\n/* Copy a UTF8 string, replacing all badly encoded points with U+FFFD */\nstatic jv jvp_string_copy_replace_bad(const char* data, uint32_t length) {\n  const char* end = data + length;\n  const char* i = data;\n\n  uint32_t maxlength = length * 3 + 1; // worst case: all bad bytes, each becomes a 3-byte U+FFFD\n  jvp_string* s = jvp_string_alloc(maxlength);\n  char* out = s->data;\n  int c = 0;\n\n  while ((i = jvp_utf8_next(i, end, &c))) {\n    if (c == -1) {\n      c = 0xFFFD; // U+FFFD REPLACEMENT CHARACTER\n    }\n    out += jvp_utf8_encode(c, out);\n    assert(out < s->data + maxlength);\n  }\n  length = out - s->data;\n  s->data[length] = 0;\n  s->length_hashed = length << 1;\n  jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&s->refcnt}};\n  return r;\n}\n\n/* Assumes valid UTF8 */\nstatic jv jvp_string_new(const char* data, uint32_t length) {\n  jvp_string* s = jvp_string_alloc(length);\n  s->length_hashed = length << 1;\n  if (data != NULL)\n    memcpy(s->data, data, length);\n  s->data[length] = 0;\n  jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&s->refcnt}};\n  return r;\n}\n\nstatic jv jvp_string_empty_new(uint32_t length) {\n  jvp_string* s = jvp_string_alloc(length);\n  s->length_hashed = 0;\n  memset(s->data, 0, length);\n  jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&s->refcnt}};\n  return r;\n}\n\n\nstatic void jvp_string_free(jv js) {\n  jvp_string* s = jvp_string_ptr(js);\n  if (jvp_refcnt_dec(&s->refcnt)) {\n    jv_mem_free(s);\n  }\n}\n\nstatic uint32_t jvp_string_length(jvp_string* s) {\n  return s->length_hashed >> 1;\n}\n\nstatic uint32_t jvp_string_remaining_space(jvp_string* s) {\n  assert(s->alloc_length >= jvp_string_length(s));\n  uint32_t r = s->alloc_length - jvp_string_length(s);\n  return r;\n}\n\nstatic jv jvp_string_append(jv string, const char* data, uint32_t len) {\n  jvp_string* s = jvp_string_ptr(string);\n  uint32_t currlen = jvp_string_length(s);\n\n  if (jvp_refcnt_unshared(string.u.ptr) &&\n      jvp_string_remaining_space(s) >= len) {\n    // the next string fits at the end of a\n    memcpy(s->data + currlen, data, len);\n    s->data[currlen + len] = 0;\n    s->length_hashed = (currlen + len) << 1;\n    return string;\n  } else {\n    // allocate a bigger buffer and copy\n    uint32_t allocsz = (currlen + len) * 2;\n    if (allocsz < 32) allocsz = 32;\n    jvp_string* news = jvp_string_alloc(allocsz);\n    news->length_hashed = (currlen + len) << 1;\n    memcpy(news->data, s->data, currlen);\n    memcpy(news->data + currlen, data, len);\n    news->data[currlen + len] = 0;\n    jvp_string_free(string);\n    jv r = {JVP_FLAGS_STRING, 0, 0, 0, {&news->refcnt}};\n    return r;\n  }\n}\n\nstatic const uint32_t HASH_SEED = 0x432A9843;\n\nstatic uint32_t rotl32 (uint32_t x, int8_t r){\n  return (x << r) | (x >> (32 - r));\n}\n\nstatic uint32_t jvp_string_hash(jv jstr) {\n  jvp_string* str = jvp_string_ptr(jstr);\n  if (str->length_hashed & 1)\n    return str->hash;\n\n  /* The following is based on MurmurHash3.\n     MurmurHash3 was written by Austin Appleby, and is placed\n     in the public domain. */\n\n  const uint8_t* data = (const uint8_t*)str->data;\n  int len = (int)jvp_string_length(str);\n  const int nblocks = len / 4;\n\n  uint32_t h1 = HASH_SEED;\n\n  const uint32_t c1 = 0xcc9e2d51;\n  const uint32_t c2 = 0x1b873593;\n  const uint32_t* blocks = (const uint32_t *)(data + nblocks*4);\n\n  for(int i = -nblocks; i; i++) {\n    uint32_t k1 = blocks[i]; //FIXME: endianness/alignment\n\n    k1 *= c1;\n    k1 = rotl32(k1,15);\n    k1 *= c2;\n\n    h1 ^= k1;\n    h1 = rotl32(h1,13);\n    h1 = h1*5+0xe6546b64;\n  }\n\n  const uint8_t* tail = (const uint8_t*)(data + nblocks*4);\n\n  uint32_t k1 = 0;\n\n  switch(len & 3) {\n  case 3: k1 ^= tail[2] << 16;\n          JQ_FALLTHROUGH;\n  case 2: k1 ^= tail[1] << 8;\n          JQ_FALLTHROUGH;\n  case 1: k1 ^= tail[0];\n          k1 *= c1; k1 = rotl32(k1,15); k1 *= c2; h1 ^= k1;\n  }\n\n  h1 ^= len;\n\n  h1 ^= h1 >> 16;\n  h1 *= 0x85ebca6b;\n  h1 ^= h1 >> 13;\n  h1 *= 0xc2b2ae35;\n  h1 ^= h1 >> 16;\n\n  str->length_hashed |= 1;\n  str->hash = h1;\n\n  return h1;\n}\n\n\nstatic int jvp_string_equal(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_STRING));\n  assert(JVP_HAS_KIND(b, JV_KIND_STRING));\n  jvp_string* stra = jvp_string_ptr(a);\n  jvp_string* strb = jvp_string_ptr(b);\n  if (jvp_string_length(stra) != jvp_string_length(strb)) return 0;\n  return memcmp(stra->data, strb->data, jvp_string_length(stra)) == 0;\n}\n\n/*\n * Strings (public API)\n */\n\njv jv_string_sized(const char* str, int len) {\n  return\n    jvp_utf8_is_valid(str, str+len) ?\n    jvp_string_new(str, len) :\n    jvp_string_copy_replace_bad(str, len);\n}\n\njv jv_string_empty(int len) {\n  return jvp_string_empty_new(len);\n}\n\njv jv_string(const char* str) {\n  return jv_string_sized(str, strlen(str));\n}\n\nint jv_string_length_bytes(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  int r = jvp_string_length(jvp_string_ptr(j));\n  jv_free(j);\n  return r;\n}\n\nint jv_string_length_codepoints(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  const char* i = jv_string_value(j);\n  const char* end = i + jv_string_length_bytes(jv_copy(j));\n  int c = 0, len = 0;\n  while ((i = jvp_utf8_next(i, end, &c))) len++;\n  jv_free(j);\n  return len;\n}\n\n\njv jv_string_indexes(jv j, jv k) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  assert(JVP_HAS_KIND(k, JV_KIND_STRING));\n  const char *jstr = jv_string_value(j);\n  const char *idxstr = jv_string_value(k);\n  const char *p;\n  int jlen = jv_string_length_bytes(jv_copy(j));\n  int idxlen = jv_string_length_bytes(jv_copy(k));\n  jv a = jv_array();\n\n  if (idxlen != 0) {\n    p = jstr;\n    while ((p = _jq_memmem(p, (jstr + jlen) - p, idxstr, idxlen)) != NULL) {\n      a = jv_array_append(a, jv_number(p - jstr));\n      p++;\n    }\n  }\n  jv_free(j);\n  jv_free(k);\n  return a;\n}\n\njv jv_string_split(jv j, jv sep) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  assert(JVP_HAS_KIND(sep, JV_KIND_STRING));\n  const char *jstr = jv_string_value(j);\n  const char *jend = jstr + jv_string_length_bytes(jv_copy(j));\n  const char *sepstr = jv_string_value(sep);\n  const char *p, *s;\n  int seplen = jv_string_length_bytes(jv_copy(sep));\n  jv a = jv_array();\n\n  assert(jv_get_refcnt(a) == 1);\n\n  if (seplen == 0) {\n    int c;\n    while ((jstr = jvp_utf8_next(jstr, jend, &c)))\n      a = jv_array_append(a, jv_string_append_codepoint(jv_string(\"\"), c));\n  } else {\n    for (p = jstr; p < jend; p = s + seplen) {\n      s = _jq_memmem(p, jend - p, sepstr, seplen);\n      if (s == NULL)\n        s = jend;\n      a = jv_array_append(a, jv_string_sized(p, s - p));\n      // Add an empty string to denote that j ends on a sep\n      if (s + seplen == jend && seplen != 0)\n        a = jv_array_append(a, jv_string(\"\"));\n    }\n  }\n  jv_free(j);\n  jv_free(sep);\n  return a;\n}\n\njv jv_string_explode(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  const char* i = jv_string_value(j);\n  int len = jv_string_length_bytes(jv_copy(j));\n  const char* end = i + len;\n  jv a = jv_array_sized(len);\n  int c;\n  while ((i = jvp_utf8_next(i, end, &c)))\n    a = jv_array_append(a, jv_number(c));\n  jv_free(j);\n  return a;\n}\n\njv jv_string_implode(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_ARRAY));\n  int len = jv_array_length(jv_copy(j));\n  jv s = jv_string_empty(len);\n  int i;\n\n  assert(len >= 0);\n\n  for (i = 0; i < len; i++) {\n    jv n = jv_array_get(jv_copy(j), i);\n    assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n    int nv = jv_number_value(n);\n    jv_free(n);\n    // outside codepoint range or in utf16 surrogate pair range\n    if (nv < 0 || nv > 0x10FFFF || (nv >= 0xD800 && nv <= 0xDFFF))\n      nv = 0xFFFD; // U+FFFD REPLACEMENT CHARACTER\n    s = jv_string_append_codepoint(s, nv);\n  }\n\n  jv_free(j);\n  return s;\n}\n\nunsigned long jv_string_hash(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  uint32_t hash = jvp_string_hash(j);\n  jv_free(j);\n  return hash;\n}\n\nconst char* jv_string_value(jv j) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  return jvp_string_ptr(j)->data;\n}\n\njv jv_string_slice(jv j, int start, int end) {\n  assert(JVP_HAS_KIND(j, JV_KIND_STRING));\n  const char *s = jv_string_value(j);\n  int len = jv_string_length_bytes(jv_copy(j));\n  int i;\n  const char *p, *e;\n  int c;\n  jv res;\n\n  jvp_clamp_slice_params(len, &start, &end);\n  assert(0 <= start && start <= end && end <= len);\n\n  /* Look for byte offset corresponding to start codepoints */\n  for (p = s, i = 0; i < start; i++) {\n    p = jvp_utf8_next(p, s + len, &c);\n    if (p == NULL) {\n      jv_free(j);\n      return jv_string_empty(16);\n    }\n    if (c == -1) {\n      jv_free(j);\n      return jv_invalid_with_msg(jv_string(\"Invalid UTF-8 string\"));\n    }\n  }\n  /* Look for byte offset corresponding to end codepoints */\n  for (e = p; e != NULL && i < end; i++) {\n    e = jvp_utf8_next(e, s + len, &c);\n    if (e == NULL) {\n      e = s + len;\n      break;\n    }\n    if (c == -1) {\n      jv_free(j);\n      return jv_invalid_with_msg(jv_string(\"Invalid UTF-8 string\"));\n    }\n  }\n\n  /*\n   * NOTE: Ideally we should do here what jvp_array_slice() does instead\n   * of allocating a new string as we do!  However, we assume NUL-\n   * terminated strings all over, and in the jv API, so for now we waste\n   * memory like a drunken navy programmer.  There's probably nothing we\n   * can do about it.\n   */\n  res = jv_string_sized(p, e - p);\n  jv_free(j);\n  return res;\n}\n\njv jv_string_concat(jv a, jv b) {\n  a = jvp_string_append(a, jv_string_value(b),\n                        jvp_string_length(jvp_string_ptr(b)));\n  jv_free(b);\n  return a;\n}\n\njv jv_string_append_buf(jv a, const char* buf, int len) {\n  if (jvp_utf8_is_valid(buf, buf+len)) {\n    a = jvp_string_append(a, buf, len);\n  } else {\n    jv b = jvp_string_copy_replace_bad(buf, len);\n    a = jv_string_concat(a, b);\n  }\n  return a;\n}\n\njv jv_string_append_codepoint(jv a, uint32_t c) {\n  char buf[5];\n  int len = jvp_utf8_encode(c, buf);\n  a = jvp_string_append(a, buf, len);\n  return a;\n}\n\njv jv_string_append_str(jv a, const char* str) {\n  return jv_string_append_buf(a, str, strlen(str));\n}\n\njv jv_string_vfmt(const char* fmt, va_list ap) {\n  int size = 1024;\n  while (1) {\n    char* buf = jv_mem_alloc(size);\n    va_list ap2;\n    va_copy(ap2, ap);\n    int n = vsnprintf(buf, size, fmt, ap2);\n    va_end(ap2);\n    /*\n     * NOTE: here we support old vsnprintf()s that return -1 because the\n     * buffer is too small.\n     */\n    if (n >= 0 && n < size) {\n      jv ret = jv_string_sized(buf, n);\n      jv_mem_free(buf);\n      return ret;\n    } else {\n      jv_mem_free(buf);\n      size = (n > 0) ? /* standard */ (n * 2) : /* not standard */ (size * 2);\n    }\n  }\n}\n\njv jv_string_fmt(const char* fmt, ...) {\n  va_list args;\n  va_start(args, fmt);\n  jv res = jv_string_vfmt(fmt, args);\n  va_end(args);\n  return res;\n}\n\n/*\n * Objects (internal helpers)\n */\n\n#define JVP_FLAGS_OBJECT  JVP_MAKE_FLAGS(JV_KIND_OBJECT, JVP_PAYLOAD_ALLOCATED)\n\nstruct object_slot {\n  int next; /* next slot with same hash, for collisions */\n  uint32_t hash;\n  jv string;\n  jv value;\n};\n\ntypedef struct {\n  jv_refcnt refcnt;\n  int next_free;\n  struct object_slot elements[];\n} jvp_object;\n\n\n/* warning: nontrivial justification of alignment */\nstatic jv jvp_object_new(int size) {\n  // Allocates an object of (size) slots and (size*2) hash buckets.\n\n  // size must be a power of two\n  assert(size > 0 && (size & (size - 1)) == 0);\n\n  jvp_object* obj = jv_mem_alloc(sizeof(jvp_object) +\n                                 sizeof(struct object_slot) * size +\n                                 sizeof(int) * (size * 2));\n  obj->refcnt.count = 1;\n  for (int i=0; i<size; i++) {\n    obj->elements[i].next = i - 1;\n    obj->elements[i].string = JV_NULL;\n    obj->elements[i].hash = 0;\n    obj->elements[i].value = JV_NULL;\n  }\n  obj->next_free = 0;\n  int* hashbuckets = (int*)(&obj->elements[size]);\n  for (int i=0; i<size*2; i++) {\n    hashbuckets[i] = -1;\n  }\n  jv r = {JVP_FLAGS_OBJECT, 0, 0, size, {&obj->refcnt}};\n  return r;\n}\n\nstatic jvp_object* jvp_object_ptr(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  return (jvp_object*)o.u.ptr;\n}\n\nstatic uint32_t jvp_object_mask(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  return (o.size * 2) - 1;\n}\n\nstatic int jvp_object_size(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  return o.size;\n}\n\nstatic int* jvp_object_buckets(jv o) {\n  return (int*)(&jvp_object_ptr(o)->elements[o.size]);\n}\n\nstatic int* jvp_object_find_bucket(jv object, jv key) {\n  return jvp_object_buckets(object) + (jvp_object_mask(object) & jvp_string_hash(key));\n}\n\nstatic struct object_slot* jvp_object_get_slot(jv object, int slot) {\n  assert(slot == -1 || (slot >= 0 && slot < jvp_object_size(object)));\n  if (slot == -1) return 0;\n  else return &jvp_object_ptr(object)->elements[slot];\n}\n\nstatic struct object_slot* jvp_object_next_slot(jv object, struct object_slot* slot) {\n  return jvp_object_get_slot(object, slot->next);\n}\n\nstatic struct object_slot* jvp_object_find_slot(jv object, jv keystr, int* bucket) {\n  uint32_t hash = jvp_string_hash(keystr);\n  for (struct object_slot* curr = jvp_object_get_slot(object, *bucket);\n       curr;\n       curr = jvp_object_next_slot(object, curr)) {\n    if (curr->hash == hash && jvp_string_equal(keystr, curr->string)) {\n      return curr;\n    }\n  }\n  return 0;\n}\n\nstatic struct object_slot* jvp_object_add_slot(jv object, jv key, int* bucket) {\n  jvp_object* o = jvp_object_ptr(object);\n  int newslot_idx = o->next_free;\n  if (newslot_idx == jvp_object_size(object)) return 0;\n  struct object_slot* newslot = jvp_object_get_slot(object, newslot_idx);\n  o->next_free++;\n  newslot->next = *bucket;\n  *bucket = newslot_idx;\n  newslot->hash = jvp_string_hash(key);\n  newslot->string = key;\n  return newslot;\n}\n\nstatic jv* jvp_object_read(jv object, jv key) {\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  int* bucket = jvp_object_find_bucket(object, key);\n  struct object_slot* slot = jvp_object_find_slot(object, key, bucket);\n  if (slot == 0) return 0;\n  else return &slot->value;\n}\n\nstatic void jvp_object_free(jv o) {\n  assert(JVP_HAS_KIND(o, JV_KIND_OBJECT));\n  if (jvp_refcnt_dec(o.u.ptr)) {\n    for (int i=0; i<jvp_object_size(o); i++) {\n      struct object_slot* slot = jvp_object_get_slot(o, i);\n      if (jv_get_kind(slot->string) != JV_KIND_NULL) {\n        jvp_string_free(slot->string);\n        jv_free(slot->value);\n      }\n    }\n    jv_mem_free(jvp_object_ptr(o));\n  }\n}\n\nstatic jv jvp_object_rehash(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(jvp_refcnt_unshared(object.u.ptr));\n  int size = jvp_object_size(object);\n  jv new_object = jvp_object_new(size * 2);\n  for (int i=0; i<size; i++) {\n    struct object_slot* slot = jvp_object_get_slot(object, i);\n    if (jv_get_kind(slot->string) == JV_KIND_NULL) continue;\n    int* new_bucket = jvp_object_find_bucket(new_object, slot->string);\n    assert(!jvp_object_find_slot(new_object, slot->string, new_bucket));\n    struct object_slot* new_slot = jvp_object_add_slot(new_object, slot->string, new_bucket);\n    assert(new_slot);\n    new_slot->value = slot->value;\n  }\n  // references are transported, just drop the old table\n  jv_mem_free(jvp_object_ptr(object));\n  return new_object;\n}\n\nstatic jv jvp_object_unshare(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  if (jvp_refcnt_unshared(object.u.ptr))\n    return object;\n\n  jv new_object = jvp_object_new(jvp_object_size(object));\n  jvp_object_ptr(new_object)->next_free = jvp_object_ptr(object)->next_free;\n  for (int i=0; i<jvp_object_size(new_object); i++) {\n    struct object_slot* old_slot = jvp_object_get_slot(object, i);\n    struct object_slot* new_slot = jvp_object_get_slot(new_object, i);\n    *new_slot = *old_slot;\n    if (jv_get_kind(old_slot->string) != JV_KIND_NULL) {\n      new_slot->string = jv_copy(old_slot->string);\n      new_slot->value = jv_copy(old_slot->value);\n    }\n  }\n\n  int* old_buckets = jvp_object_buckets(object);\n  int* new_buckets = jvp_object_buckets(new_object);\n  memcpy(new_buckets, old_buckets, sizeof(int) * jvp_object_size(new_object)*2);\n\n  jvp_object_free(object);\n  assert(jvp_refcnt_unshared(new_object.u.ptr));\n  return new_object;\n}\n\nstatic jv* jvp_object_write(jv* object, jv key) {\n  *object = jvp_object_unshare(*object);\n  int* bucket = jvp_object_find_bucket(*object, key);\n  struct object_slot* slot = jvp_object_find_slot(*object, key, bucket);\n  if (slot) {\n    // already has the key\n    jvp_string_free(key);\n    return &slot->value;\n  }\n  slot = jvp_object_add_slot(*object, key, bucket);\n  if (slot) {\n    slot->value = jv_invalid();\n  } else {\n    *object = jvp_object_rehash(*object);\n    bucket = jvp_object_find_bucket(*object, key);\n    assert(!jvp_object_find_slot(*object, key, bucket));\n    slot = jvp_object_add_slot(*object, key, bucket);\n    assert(slot);\n    slot->value = jv_invalid();\n  }\n  return &slot->value;\n}\n\nstatic int jvp_object_delete(jv* object, jv key) {\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  *object = jvp_object_unshare(*object);\n  int* bucket = jvp_object_find_bucket(*object, key);\n  int* prev_ptr = bucket;\n  uint32_t hash = jvp_string_hash(key);\n  for (struct object_slot* curr = jvp_object_get_slot(*object, *bucket);\n       curr;\n       curr = jvp_object_next_slot(*object, curr)) {\n    if (hash == curr->hash && jvp_string_equal(key, curr->string)) {\n      *prev_ptr = curr->next;\n      jvp_string_free(curr->string);\n      curr->string = JV_NULL;\n      jv_free(curr->value);\n      return 1;\n    }\n    prev_ptr = &curr->next;\n  }\n  return 0;\n}\n\nstatic int jvp_object_length(jv object) {\n  int n = 0;\n  for (int i=0; i<jvp_object_size(object); i++) {\n    struct object_slot* slot = jvp_object_get_slot(object, i);\n    if (jv_get_kind(slot->string) != JV_KIND_NULL) n++;\n  }\n  return n;\n}\n\nstatic int jvp_object_equal(jv o1, jv o2) {\n  int len2 = jvp_object_length(o2);\n  int len1 = 0;\n  for (int i=0; i<jvp_object_size(o1); i++) {\n    struct object_slot* slot = jvp_object_get_slot(o1, i);\n    if (jv_get_kind(slot->string) == JV_KIND_NULL) continue;\n    jv* slot2 = jvp_object_read(o2, slot->string);\n    if (!slot2) return 0;\n    // FIXME: do less refcounting here\n    if (!jv_equal(jv_copy(slot->value), jv_copy(*slot2))) return 0;\n    len1++;\n  }\n  return len1 == len2;\n}\n\nstatic int jvp_object_contains(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(b, JV_KIND_OBJECT));\n  int r = 1;\n\n  jv_object_foreach(b, key, b_val) {\n    jv a_val = jv_object_get(jv_copy(a), key);\n\n    r = jv_contains(a_val, b_val);\n\n    if (!r) break;\n  }\n  return r;\n}\n\n/*\n * Objects (public interface)\n */\n#define DEFAULT_OBJECT_SIZE 8\njv jv_object() {\n  return jvp_object_new(8);\n}\n\njv jv_object_get(jv object, jv key) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  jv* slot = jvp_object_read(object, key);\n  jv val;\n  if (slot) {\n    val = jv_copy(*slot);\n  } else {\n    val = jv_invalid();\n  }\n  jv_free(object);\n  jv_free(key);\n  return val;\n}\n\nint jv_object_has(jv object, jv key) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  jv* slot = jvp_object_read(object, key);\n  int res = slot ? 1 : 0;\n  jv_free(object);\n  jv_free(key);\n  return res;\n}\n\njv jv_object_set(jv object, jv key, jv value) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  // copy/free of object, key, value coalesced\n  jv* slot = jvp_object_write(&object, key);\n  jv_free(*slot);\n  *slot = value;\n  return object;\n}\n\njv jv_object_delete(jv object, jv key) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(key, JV_KIND_STRING));\n  jvp_object_delete(&object, key);\n  jv_free(key);\n  return object;\n}\n\nint jv_object_length(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  int n = jvp_object_length(object);\n  jv_free(object);\n  return n;\n}\n\njv jv_object_merge(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_OBJECT));\n  jv_object_foreach(b, k, v) {\n    a = jv_object_set(a, k, v);\n  }\n  jv_free(b);\n  return a;\n}\n\njv jv_object_merge_recursive(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_OBJECT));\n  assert(JVP_HAS_KIND(b, JV_KIND_OBJECT));\n\n  jv_object_foreach(b, k, v) {\n    jv elem = jv_object_get(jv_copy(a), jv_copy(k));\n    if (jv_is_valid(elem) &&\n        JVP_HAS_KIND(elem, JV_KIND_OBJECT) &&\n        JVP_HAS_KIND(v, JV_KIND_OBJECT)) {\n      a = jv_object_set(a, k, jv_object_merge_recursive(elem, v));\n    } else {\n      jv_free(elem);\n      a = jv_object_set(a, k, v);\n    }\n  }\n  jv_free(b);\n  return a;\n}\n\n/*\n * Object iteration (internal helpers)\n */\n\nenum { ITER_FINISHED = -2 };\n\nint jv_object_iter_valid(jv object, int i) {\n  return i != ITER_FINISHED;\n}\n\nint jv_object_iter(jv object) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  return jv_object_iter_next(object, -1);\n}\n\nint jv_object_iter_next(jv object, int iter) {\n  assert(JVP_HAS_KIND(object, JV_KIND_OBJECT));\n  assert(iter != ITER_FINISHED);\n  struct object_slot* slot;\n  do {\n    iter++;\n    if (iter >= jvp_object_size(object))\n      return ITER_FINISHED;\n    slot = jvp_object_get_slot(object, iter);\n  } while (jv_get_kind(slot->string) == JV_KIND_NULL);\n  assert(jv_get_kind(jvp_object_get_slot(object,iter)->string)\n         == JV_KIND_STRING);\n  return iter;\n}\n\njv jv_object_iter_key(jv object, int iter) {\n  jv s = jvp_object_get_slot(object, iter)->string;\n  assert(JVP_HAS_KIND(s, JV_KIND_STRING));\n  return jv_copy(s);\n}\n\njv jv_object_iter_value(jv object, int iter) {\n  return jv_copy(jvp_object_get_slot(object, iter)->value);\n}\n\n/*\n * Memory management\n */\njv jv_copy(jv j) {\n  if (JVP_IS_ALLOCATED(j)) {\n    jvp_refcnt_inc(j.u.ptr);\n  }\n  return j;\n}\n\nvoid jv_free(jv j) {\n  switch(JVP_KIND(j)) {\n    case JV_KIND_ARRAY:\n      jvp_array_free(j);\n      break;\n    case JV_KIND_STRING:\n      jvp_string_free(j);\n      break;\n    case JV_KIND_OBJECT:\n      jvp_object_free(j);\n      break;\n    case JV_KIND_INVALID:\n      jvp_invalid_free(j);\n      break;\n    case JV_KIND_NUMBER:\n      jvp_number_free(j);\n      break;\n  }\n}\n\nint jv_get_refcnt(jv j) {\n  if (JVP_IS_ALLOCATED(j)) {\n    return j.u.ptr->count;\n  } else {\n    return 1;\n  }\n}\n\n/*\n * Higher-level operations\n */\n\nint jv_equal(jv a, jv b) {\n  int r;\n  if (jv_get_kind(a) != jv_get_kind(b)) {\n    r = 0;\n  } else if (JVP_IS_ALLOCATED(a) &&\n             JVP_IS_ALLOCATED(b) &&\n             a.kind_flags == b.kind_flags &&\n             a.size == b.size &&\n             a.u.ptr == b.u.ptr) {\n    r = 1;\n  } else {\n    switch (jv_get_kind(a)) {\n    case JV_KIND_NUMBER:\n      r = jvp_number_equal(a, b);\n      break;\n    case JV_KIND_ARRAY:\n      r = jvp_array_equal(a, b);\n      break;\n    case JV_KIND_STRING:\n      r = jvp_string_equal(a, b);\n      break;\n    case JV_KIND_OBJECT:\n      r = jvp_object_equal(a, b);\n      break;\n    default:\n      r = 1;\n      break;\n    }\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n\nint jv_identical(jv a, jv b) {\n  int r;\n  if (a.kind_flags != b.kind_flags\n      || a.offset != b.offset\n      || a.size != b.size) {\n    r = 0;\n  } else {\n    if (JVP_IS_ALLOCATED(a) /* b has the same flags */) {\n      r = a.u.ptr == b.u.ptr;\n    } else {\n      r = memcmp(&a.u.ptr, &b.u.ptr, sizeof(a.u)) == 0;\n    }\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n\nint jv_contains(jv a, jv b) {\n  int r = 1;\n  if (jv_get_kind(a) != jv_get_kind(b)) {\n    r = 0;\n  } else if (JVP_HAS_KIND(a, JV_KIND_OBJECT)) {\n    r = jvp_object_contains(a, b);\n  } else if (JVP_HAS_KIND(a, JV_KIND_ARRAY)) {\n    r = jvp_array_contains(a, b);\n  } else if (JVP_HAS_KIND(a, JV_KIND_STRING)) {\n    int b_len = jv_string_length_bytes(jv_copy(b));\n    if (b_len != 0) {\n      r = _jq_memmem(jv_string_value(a), jv_string_length_bytes(jv_copy(a)),\n                     jv_string_value(b), b_len) != 0;\n    } else {\n      r = 1;\n    }\n  } else {\n    r = jv_equal(jv_copy(a), jv_copy(b));\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n", "#!/bin/sh -x\n\n. \"${0%/*}/setup\" \"$@\"\n\nmsys=false\nmingw=false\ncase \"$(uname -s)\" in\nMSYS*)  msys=true;;\nMINGW*) mingw=true;;\nesac\n\nJQ_NO_B=$JQ\nJQ=\"$JQ -b\"\n\nPATH=$JQBASEDIR:$PATH $JQBASEDIR/tests/jq-f-test.sh > /dev/null\n\nif [ -f \"$JQBASEDIR/.libs/libinject_errors.so\" ]; then\n  # Do some simple error injection tests to check that we're handling\n  # I/O errors correctly.\n  (\n  libinject=$JQBASEDIR/.libs/libinject_errors.so\n  cd $d\n  LD_PRELOAD=$libinject $JQ . /dev/null\n  touch fail_read\n  LD_PRELOAD=$libinject $JQ . fail_read && exit 2\n  touch fail_close\n  LD_PRELOAD=$libinject $JQ . fail_close && exit 2\n  true\n  )\nfi\n\nprintf 'a\\0b\\nc\\0d\\ne' > $d/input\n$VALGRIND $Q $JQ -Rse '. == \"a\\u0000b\\nc\\u0000d\\ne\"' $d/input\n$VALGRIND $Q $JQ -Rne '[inputs] == [\"a\\u0000b\", \"c\\u0000d\", \"e\"]' $d/input\n\n## Test constant folding\n\n## XXX If we add a builtin to list the program's disassembly then we can\n## move all of these into tests/all.test\n\n# String constant folding (addition only)\nnref=$($VALGRIND $Q $JQ -n --debug-dump-disasm '\"foo\"' | wc -l)\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '\"foo\" + \"bar\"' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for strings didn't work\"\n  exit 1\nfi\n\n# Numeric constant folding (binary operators)\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '1+1' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '1-1' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '2*3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9/3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9%3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9==3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9!=3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9<3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9>3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9<=3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\nn=$($VALGRIND $Q $JQ -n --debug-dump-disasm '9>=3' | wc -l)\nif [ $n -ne $nref ]; then\n  echo \"Constant expression folding for numbers didn't work\"\n  exit 1\nfi\n\n## Test JSON sequence support\n\ncat > $d/expected <<EOF\njq: ignoring parse error: Truncated value at line 2, column 5\njq: ignoring parse error: Truncated value at line 2, column 25\njq: ignoring parse error: Truncated value at line 2, column 41\nEOF\nprintf '1\\0362 3\\n[0,1\\036[4,5]true\"ab\"{\"c\":4\\036{}{\"d\":5,\"e\":6\"\\036false\\n'|$VALGRIND $Q $JQ -ces --seq '. == [2,3,[4,5],true,\"ab\",{},false]' > /dev/null 2> $d/out\ncmp $d/out $d/expected\n\ncat > $d/expected <<EOF\njq: ignoring parse error: Truncated value at line 2, column 5\njq: ignoring parse error: Truncated value at line 2, column 25\njq: ignoring parse error: Truncated value at line 3, column 1\nEOF\nprintf '1\\0362 3\\n[0,1\\036[4,5]true\"ab\"{\"c\":4\\036{}{\"d\":5,\"e\":6\"false\\n\\036null'|$VALGRIND $Q $JQ -ces --seq '. == [2,3,[4,5],true,\"ab\",{},null]' > /dev/null 2> $d/out\ncmp $d/out $d/expected\n\n# Note that here jq sees no inputs at all but it still succeeds because\n# --seq ignores parse errors\ncat > $d/expected <<EOF\njq: ignoring parse error: Unfinished abandoned text at EOF at line 1, column 4\nEOF\nprintf '\"foo' | $JQ -c --seq . > $d/out 2>&1\ncmp $d/out $d/expected\n\n# with -e option should give 4 here as there's no valid output after\n# ignoring parse errors with --seq.\nprintf '\"foo' | $JQ -ce --seq . > $d/out 2>&1 || ret=$?\n[ $ret -eq 4 ]\ncmp $d/out $d/expected\n\n# Numeric values truncated by EOF are ignored\ncat > $d/expected <<EOF\njq: ignoring parse error: Unfinished abandoned text at EOF at line 1, column 1\nEOF\nprintf '1' | $JQ -c --seq . > $d/out 2>&1\ncmp $d/out $d/expected\n\ncat > $d/expected <<EOF\njq: error (at <stdin>:1): Unfinished abandoned text at EOF at line 2, column 0\nEOF\nif printf '1\\n' | $JQ -cen --seq '[inputs] == []' >/dev/null 2> $d/out; then\n  printf 'Error expected but jq exited successfully\\n' 1>&2\n  exit 2\nfi\ncmp $d/out $d/expected\n\n\n## Test --exit-status\ndata='{\"i\": 1}\\n{\"i\": 2}\\n{\"i\": 3}\\n'\nprintf \"$data\" | $JQ --exit-status 'select(.i==1)' > /dev/null 2>&1\nprintf \"$data\" | $JQ --exit-status 'select(.i==2)' > /dev/null 2>&1\nprintf \"$data\" | $JQ --exit-status 'select(.i==3)' > /dev/null 2>&1\nret=0\nprintf \"$data\" | $JQ --exit-status 'select(.i==4)' > /dev/null 2>&1 || ret=$?\n[ $ret -eq 4 ]\nret=0\nprintf \"$data\" | $JQ --exit-status 'select(.i==2) | false' > /dev/null 2>&1 || ret=$?\n[ $ret -eq 1 ]\nprintf \"$data\" | $JQ --exit-status 'select(.i==2) | true' > /dev/null 2>&1\n\n\n# Regression test for #951\nprintf '\"a\\n' > $d/input\nif $VALGRIND $Q $JQ -e . $d/input; then\n  printf 'Issue #951 is back?\\n' 1>&2\n  exit 2\nfi\n\n# Regression test for #2146\nif echo \"foobar\" | $JQ .; then\n  printf 'Issue #2146 is back?\\n' 1>&2\n  exit 1\nelif [ $? -ne 5 ]; then\n  echo \"Invalid input had wrong error code\" 1>&2\n  exit 1\nfi\n\n# Regression test for #2367; make sure to call jq twice\nif ! echo '{\"a\": 1E9999999999}' | $JQ . | $JQ -e .a; then\n  printf 'Issue #2367 is back?\\n' 1>&2\n  exit 1\nfi\n\n# Regression test for #1534\necho \"[1,2,3,4]\" > $d/expected\nprintf \"[1,2][3,4]\" | $JQ -cs add > $d/out 2>&1\ncmp $d/out $d/expected\nprintf \"[1,2][3,4]\\n\" | $JQ -cs add > $d/out 2>&1\ncmp $d/out $d/expected\n\n# Regression test for --raw-output0\nprintf \"a\\0b\\0\" > $d/expected\nprintf '[\"a\", \"b\"]' | $VALGRIND $Q $JQ --raw-output0 .[] > $d/out\ncmp $d/out $d/expected\nprintf \"a\\0\" > $d/expected\nif printf '[\"a\", \"c\\\\u0000d\", \"b\"]' | $VALGRIND $Q $JQ --raw-output0 .[] > $d/out; then\n  echo \"Should exit error on string containing NUL with --raw-output0\" 1>&2\n  exit 1\nelif [ $? -ne 5 ]; then\n  echo \"Invalid error code\" 1>&2\n  exit 1\nelse\n  cmp $d/out $d/expected\nfi\n\n## Test streaming parser\n\n## If we add an option to stream to the `import ... as $symbol;` directive\n## then we can move these tests into tests/all.test.\n$VALGRIND $Q $JQ -c '. as $d|path(..) as $p|$d|getpath($p)|select((type|. != \"array\" and . != \"object\") or length==0)|[$p,.]' < \"$JQTESTDIR/torture/input0.json\" > $d/out0\n$VALGRIND $Q $JQ --stream -c '.|select(length==2)' < \"$JQTESTDIR/torture/input0.json\" > $d/out1\ndiff $d/out0 $d/out1\n\nprintf '[\"Unfinished JSON term at EOF at line 1, column 1\",[0]]\\n' > $d/expected\nprintf '[' | $VALGRIND $Q $JQ --stream-errors -c . > $d/out 2>&1\ndiff $d/out $d/expected\n\n\n## XXX This test can be moved to tests/all.test _now_\nclean=false\nif which seq > /dev/null 2>&1; then\n    # XXX We should try every prefix of input0.json, but that makes this\n    # test very, very slow when run with valgrind, and the whole point\n    # is to run it with valgrind.\n    #\n    #len=$(wc -c < \"$JQTESTDIR/torture/input0.json\")\n    if [ -z \"$VALGRIND\" ]; then\n        start=1\n        end=$(wc -c < \"$JQTESTDIR/torture/input0.json\")\n    else\n        start=120\n        end=151\n    fi\n    for i in $(seq $start $end); do\n        dd \"if=tests/torture/input0.json\" bs=$i count=1 2>/dev/null |\n            $VALGRIND $JQ -c . > $d/out0 2>$d/err || true\n        if [ -n \"$VALGRIND\" ]; then\n            grep '^==[0-9][0-9]*== ERROR SUMMARY: 0 errors' $d/err > /dev/null\n        else\n            tail -n1 -- \"$d/err\" | grep -Ei 'assert|abort|core' && false\n        fi\n\n        dd \"if=tests/torture/input0.json\" bs=$i count=1 2>/dev/null |\n            $VALGRIND $JQ -cn --stream 'fromstream(inputs)' > $d/out1 2>$d/err || true\n        if [ -n \"$VALGRIND\" ]; then\n            grep '^==[0-9][0-9]*== ERROR SUMMARY: 0 errors' $d/err > /dev/null\n        else\n            tail -n1 -- \"$d/err\" | grep -Ei 'assert|abort|core' && false\n        fi\n\n        diff $d/out0 $d/out1\n    done\nelse\n    echo \"Not doing torture tests\"\nfi\n\n## Regression test for issue #2378 assert when stream parse broken object pair\necho '{\"a\":1,\"b\",' | $JQ --stream  > /dev/null 2> $d/err || true\ngrep 'Objects must consist of key:value pairs' $d/err > /dev/null\n\n## Regression tests for issue #2463 assert when stream parse non-scalar object key\necho '{{\"a\":\"b\"}}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after '{', not '{'\" $d/err > /dev/null\necho '{\"x\":\"y\",{\"a\":\"b\"}}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after ',' in object, not '{'\" $d/err > /dev/null\necho '{[\"a\",\"b\"]}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after '{', not '\\\\['\" $d/err > /dev/null\necho '{\"x\":\"y\",[\"a\",\"b\"]}' | $JQ --stream > /dev/null 2> $d/err || true\ngrep \"Expected string key after ',' in object, not '\\\\['\" $d/err > /dev/null\n\n# debug, stderr\n$VALGRIND $Q $JQ -n '\"test\", {} | debug, stderr' >/dev/null\n$JQ -n -c -j '\"hello\\nworld\", null, [false, 0], {\"foo\":[\"bar\"]}, \"\\n\" | stderr' >$d/out 2>$d/err\ncat > $d/expected <<'EOF'\nhello\nworldnull[false,0]{\"foo\":[\"bar\"]}\nEOF\ncmp $d/out $d/expected\ncmp $d/err $d/expected\n\n# --arg, --argjson, $ARGS.named\n$VALGRIND $JQ -n -c --arg foo 1 --argjson bar 2 '{$foo, $bar} | ., . == $ARGS.named' > $d/out\nprintf '{\"foo\":\"1\",\"bar\":2}\\ntrue\\n' > $d/expected\ncmp $d/out $d/expected\n\n# --slurpfile, --rawfile\n$VALGRIND $JQ -n --slurpfile foo $JQBASEDIR/tests/modules/data.json \\\n  --rawfile bar $JQBASEDIR/tests/modules/data.json '{$foo, $bar}' > $d/out\ncat > $d/expected <<'EOF'\n{\n  \"foo\": [\n    {\n      \"this\": \"is a test\",\n      \"that\": \"is too\"\n    }\n  ],\n  \"bar\": \"{\\n  \\\"this\\\": \\\"is a test\\\",\\n  \\\"that\\\": \\\"is too\\\"\\n}\\n\"\n}\nEOF\ncmp $d/out $d/expected\n\n# --args, --jsonargs, $ARGS.positional\n$VALGRIND $JQ -n -c --args '$ARGS.positional' foo bar baz > $d/out\nprintf '[\"foo\",\"bar\",\"baz\"]\\n' > $d/expected\ncmp $d/out $d/expected\n$VALGRIND $JQ -n -c --jsonargs '$ARGS.positional' null true '[]' '{}' > $d/out\nprintf '[null,true,[],{}]\\n' > $d/expected\ncmp $d/out $d/expected\n$VALGRIND $JQ -n -c '$ARGS.positional' --args foo 1 --jsonargs 2 '{}' --args 3 4 > $d/out\nprintf '[\"foo\",\"1\",2,{},\"3\",\"4\"]\\n' > $d/expected\ncmp $d/out $d/expected\n$VALGRIND $JQ -n -c '$ARGS.positional' --args --jsonargs > $d/out\nprintf '[]\\n' > $d/expected\ncmp $d/out $d/expected\n\n## Regression test for issue #2572 assert when using --jsonargs and invalid JSON\n$VALGRIND $JQ -n --jsonargs null invalid && EC=$? || EC=$?\nif [ \"$EC\" -ne 2 ]; then\n    echo \"--jsonargs exited with wrong exit code, expected 2 got $EC\" 1>&2\n    exit 1\nfi\n# this tests the args_done code path \"--\"\n$VALGRIND $JQ -n --jsonargs null -- invalid && EC=$? || EC=$?\nif [ \"$EC\" -ne 2 ]; then\n    echo \"--jsonargs exited with wrong exit code, expected 2 got $EC\" 1>&2\n    exit 1\nfi\n\n## Fuzz parser\n\n## XXX With a $(urandom) builtin we could move this test into tests/all.test\nclean=false\nif dd if=/dev/urandom bs=16 count=1024 > $d/rand 2>/dev/null; then\n    # Have a /dev/urandom, good\n    $VALGRIND $Q $JQ --seq . $d/rand >/dev/null 2>&1\n    $VALGRIND $Q $JQ --seq --stream . $d/rand >/dev/null 2>&1\n    dd if=/dev/urandom bs=16 count=1024 > $d/rand 2>/dev/null\n    $VALGRIND $Q $JQ --seq . $d/rand >/dev/null 2>&1\n    $VALGRIND $Q $JQ --seq --stream . $d/rand >/dev/null 2>&1\n    dd if=/dev/urandom bs=16 count=1024 > $d/rand 2>/dev/null\n    $VALGRIND $Q $JQ --seq . $d/rand >/dev/null 2>&1\n    $VALGRIND $Q $JQ --seq --stream . $d/rand >/dev/null 2>&1\nfi\nclean=true\n\n## Test library/module system\n\n# Check handling of ~/.jq; these can't move into jq_test.c yet because\n# they depend on $HOME\nif [ \"$(HOME=\"$mods/home1\" $VALGRIND $Q $JQ -nr fg)\" != foobar ]; then\n    echo \"Bug #479 appears to be back\" 1>&2\n    exit 1\nfi\n\nif [ $(HOME=\"$mods/home1\" $VALGRIND $Q $JQ --debug-dump-disasm -n fg | grep '^[a-z]' | wc -l) -ne 3 ]; then\n    echo \"Binding too many defs into program\" 1>&2\n    exit 1\nfi\n\nif ! HOME=\"$mods/home2\" $VALGRIND $Q $JQ -n 'include \"g\"; empty'; then\n    echo \"Mishandling directory ~/.jq\" 1>&2\n    exit 1\nfi\n\ncd \"$JQBASEDIR\" # so that relative library paths are guaranteed correct\nif ! $VALGRIND $Q $JQ -L ./tests/modules -ne 'import \"test_bind_order\" as check; check::check==true'; then\n    echo \"Issue #817 regression?\" 1>&2\n    exit 1\nfi\n\ncd \"$JQBASEDIR\"\nif ! $VALGRIND $Q $JQ -L tests/modules -ne 'import \"test_bind_order\" as check; check::check==true'; then\n    echo \"Issue #817 regression?\" 1>&2\n    exit 1\nfi\n\n## Halt\n\nif ! $VALGRIND $Q $JQ -n halt; then\n    echo \"jq halt didn't work as expected\" 1>&2\n    exit 1\nfi\nif $VALGRIND $Q $VG_EXIT0 $JQ -n 'halt_error(1)'; then\n    echo \"jq halt_error(1) didn't work as expected\" 1>&2\n    exit 1\nelif [ $? -ne 1 ]; then\n    echo \"jq halt_error(1) had wrong error code\" 1>&2\n    exit 1\nfi\nif $VALGRIND $Q $VG_EXIT0 $JQ -n 'halt_error(11)'; then\n    echo \"jq halt_error(11) didn't work as expected\" 1>&2\n    exit 1\nelif [ $? -ne 11 ]; then\n    echo \"jq halt_error(11) had wrong error code\" 1>&2\n    exit 1\nfi\nif [ -n \"$($VALGRIND $Q $JQ -n 'halt_error(1)' 2>&1)\" ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\nif [ -n \"$($VALGRIND $Q $JQ -n '\"xyz\\n\" | halt_error(1)' 2>/dev/null)\" ]; then\n    echo \"jq halt_error(1) had unexpected output on stdout\" 1>&2\n    exit 1\nfi\nif [ \"$($VALGRIND $Q $JQ -n '\"xy\" | halt_error(1)' 2>&1 || echo \"z\")\" != \"xyz\" ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\nif [ \"$($VALGRIND $Q $JQ -n '\"x\\u0000y\\u0000z\" | halt_error(1)' 2>&1 | tr '\\0' '.')\" != \"x.y.z\" ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\nif [ \"$($VALGRIND $Q $JQ -n '{\"a\":\"xyz\"} | halt_error(1)' 2>&1)\" != '{\"a\":\"xyz\"}' ]; then\n    echo \"jq halt_error(1) had unexpected output\" 1>&2\n    exit 1\nfi\n\n# Check $JQ_COLORS\nunset JQ_COLORS\n\n## Default colors, null input\n$JQ -Ccn . > $d/color\nprintf '\\033[0;90mnull\\033[0m\\n' > $d/expect\ncmp $d/color $d/expect\n\n## Set non-default color, null input\nJQ_COLORS='4;31' $JQ -Ccn . > $d/color\nprintf '\\033[4;31mnull\\033[0m\\n' > $d/expect\ncmp $d/color $d/expect\n\n## Default colors, complex input\n$JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color\n{\n  printf '\\033[1;39m[\\033[1;39m{'\n  printf '\\033[0m\\033[1;34m\"a\"\\033['\n  printf '0m\\033[1;39m:\\033[0m\\033['\n  printf '0;39mtrue\\033[0m\\033[1'\n  printf ';39m,\\033[0m\\033[1;34m'\n  printf '\"b\"\\033[0m\\033[1;39m:\\033'\n  printf '[0m\\033[0;39mfalse\\033'\n  printf '[0m\\033[1;39m\\033[1;39'\n  printf 'm}\\033[0m\\033[1;39m,\\033['\n  printf '0;39m123\\033[0m\\033[1;'\n  printf '39m,\\033[0;90mnull\\033'\n  printf '[0m\\033[1;39m\\033[1;39'\n  printf 'm]\\033[0m\\n'\n} > $d/expect\ncmp $d/color $d/expect\n\n## Set non-default colors, complex input\nJQ_COLORS='0;30:0;31:0;32:0;33:0;34:1;35:1;36:1;37' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color\n{\n  printf '\\033[1;35m[\\033[1;36m{'\n  printf '\\033[0m\\033[1;37m\"a\"\\033['\n  printf '0m\\033[1;36m:\\033[0m\\033['\n  printf '0;32mtrue\\033[0m\\033[1'\n  printf ';36m,\\033[0m\\033[1;37m'\n  printf '\"b\"\\033[0m\\033[1;36m:\\033'\n  printf '[0m\\033[0;31mfalse\\033'\n  printf '[0m\\033[1;36m\\033[1;36'\n  printf 'm}\\033[0m\\033[1;35m,\\033['\n  printf '0;33m123\\033[0m\\033[1;'\n  printf '35m,\\033[0;30mnull\\033'\n  printf '[0m\\033[1;35m\\033[1;35'\n  printf 'm]\\033[0m\\n'\n} > $d/expect\ncmp $d/color $d/expect\n\n# Check garbage in JQ_COLORS.  We write each color sequence into a 16\n# char buffer that needs to hold ESC [ <color> m NUL, so each color\n# sequence can be no more than 12 chars (bytes).  These emit a warning\n# on stderr.\nset -vx\necho 'Failed to set $JQ_COLORS' > $d/expect_warning\n$JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/expect\nJQ_COLORS='garbage;30:*;31:,;3^:0;$%:0;34:1;35:1;36' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS='1234567890123456789;30:0;31:0;32:0;33:0;34:1;35:1;36' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS='1;31234567890123456789:0;31:0;32:0;33:0;34:1;35:1;36' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS='1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456:1234567890123456;1234567890123456' \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\nJQ_COLORS=\"0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:0123456789123:\" \\\n  $JQ -Ccn '[{\"a\":true,\"b\":false},123,null]' > $d/color 2>$d/warning\ncmp $d/color $d/expect\ncmp $d/warning $d/expect_warning\n\n# Check $NO_COLOR\ntest_no_color=true\n$msys  && test_no_color=false\n$mingw && test_no_color=false\nif $test_no_color && command -v script >/dev/null 2>&1; then\n  unset NO_COLOR\n  if script -qc echo /dev/null >/dev/null 2>&1; then\n    faketty() { script -qec \"$*\" /dev/null; }\n  else # macOS\n    faketty() { script -q /dev/null \"$@\" /dev/null |\n      sed 's/^\\x5E\\x44\\x08\\x08//'; }\n  fi\n\n  faketty $JQ_NO_B -n . > $d/color\n  printf '\\033[0;90mnull\\033[0m\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\n  NO_COLOR= faketty $JQ_NO_B -n . > $d/color\n  printf '\\033[0;90mnull\\033[0m\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\n  NO_COLOR=1 faketty $JQ_NO_B -n . > $d/color\n  printf 'null\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\n  NO_COLOR=1 faketty $JQ_NO_B -Cn . > $d/color\n  printf '\\033[0;90mnull\\033[0m\\r\\n' > $d/expect\n  od -tc $d/expect\n  od -tc $d/color\n  cmp $d/color $d/expect\nfi\n\n# #2785\nif $VALGRIND $Q $JQ -n -f \"$JQTESTDIR/no-main-program.jq\" > $d/out 2>&1; then\n  echo \"jq -f $JQTESTDIR/no-main-program.jq succeeded\"\n  exit 1\nelse\n  EC=$?\n  if [ $EC -eq 1 ]; then\n    echo \"jq -f $JQTESTDIR/no-main-program.jq failed with memory errors\"\n    exit 1\n  fi\n  if [ $EC -ne 3 ]; then\n    echo \"jq -f $JQTESTDIR/no-main-program.jq failed with wrong exit code ($EC)\"\n    exit 1\n  fi\nfi\ncat > $d/expected <<EOF\njq: error: Top-level program not given (try \".\")\njq: 1 compile error\nEOF\nif ! diff $d/expected $d/out; then\n  echo \"jq -f $JQTESTDIR/no-main-program.jq failed but its error message is not the expected one\"\n  exit 1\nfi\n\nif ! $VALGRIND $Q $JQ -n -f \"$JQTESTDIR/yes-main-program.jq\" > $d/out 2>&1; then\n  echo \"jq -f $JQTESTDIR/yes-main-program.jq failed\"\n  exit 1\nfi\n\nif ! $msys && ! $mingw && locales=$(locale -a); then\n  { l=$(grep -Ev '^(C|LANG|POSIX|en)' | grep -Ei '\\.utf-?8$' | head -n1) ;} \\\n<<EOF\n$locales\nEOF\n  if [ -z \"$l\" ]; then\n    echo \"WARNING: Not testing localization\"\n  else\n    date=$(LC_ALL=$l date +'%a %d %b %Y at %H:%M:%S')\n    if ! LC_ALL=$l $JQ -nR --arg date \"$date\" '$date|strptime(\"%a %d %b %Y at %H:%M:%S\")'; then\n      echo \"jq does not honor LC_ALL environment variable\"\n      exit 1\n    fi\n  fi\nfi\n\n# Comments!\nif ! x=$($JQ -n '123 # comment') || [ \"$x\" != 123 ]; then\n  echo 'comment did not work'\n  exit 1\nfi\n\ncr=$(printf \\\\r)\nif ! x=$($JQ -n \"1 # foo$cr + 2\") || [ \"$x\" != 1 ]; then\n  echo 'regression: carriage return terminates comment'\n  exit 1\nfi\n\n# CVE-2023-50268: No stack overflow comparing a nan with a large payload\n$VALGRIND $Q $JQ '1 != .' <<\\EOF >/dev/null\nNan4000\nEOF\n\n# Allow passing the inline jq script before -- #2919\nif ! r=$($JQ --args -rn -- '$ARGS.positional[0]' bar) || [ \"$r\" != bar ]; then\n    echo \"passing the inline script after -- didn't work\"\n    exit 1\nfi\nif ! r=$($JQ --args -rn 1 -- '$ARGS.positional[0]' bar) || [ \"$r\" != 1 ]; then\n    echo \"passing the inline script before -- didn't work\"\n    exit 1\nfi\n\nexit 0\n"], "filenames": ["NEWS.md", "src/jv.c", "tests/shtest"], "buggy_code_start_loc": [6, 743, 596], "buggy_code_end_loc": [7, 752, 596], "fixing_code_start_loc": [6, 743, 597], "fixing_code_end_loc": [7, 756, 602], "type": "CWE-787", "message": "jq is a command-line JSON processor. Version 1.7 is vulnerable to stack-based buffer overflow in builds using decNumber. Version 1.7.1 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-50268", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-13T21:15:09.360", "lastModified": "2023-12-19T01:32:51.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "jq is a command-line JSON processor. Version 1.7 is vulnerable to stack-based buffer overflow in builds using decNumber. Version 1.7.1 contains a patch for this issue."}, {"lang": "es", "value": "jq es un procesador JSON de l\u00ednea de comandos. La versi\u00f3n 1.7 es vulnerable al desbordamiento del b\u00fafer basado en pila en compilaciones que utilizan decNumber. La versi\u00f3n 1.7.1 contiene un parche para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}, {"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jqlang:jq:1.7:*:*:*:*:*:*:*", "matchCriteriaId": "AB4D6ED1-816E-4FB7-B9EE-188B66543156"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/12/15/10", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64771", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Mailing List"]}, {"url": "https://github.com/jqlang/jq/commit/c9a51565214eece8f1053089739aea73145bfd6b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jqlang/jq/pull/2804", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/jqlang/jq/security/advisories/GHSA-7hmr-442f-qc8j", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jqlang/jq/commit/c9a51565214eece8f1053089739aea73145bfd6b"}}