{"buggy_code": ["// termout.c (part of mintty)\n// Copyright 2008-12 Andy Koppe, 2017-20 Thomas Wolff\n// Adapted from code from PuTTY-0.60 by Simon Tatham and team.\n// Licensed under the terms of the GNU General Public License v3 or later.\n\n#include \"termpriv.h\"\n#include \"winpriv.h\"  // colours, win_get_font, win_change_font, win_led, win_set_scrollview\n\n#include \"win.h\"\n#include \"appinfo.h\"\n#include \"charset.h\"\n#include \"child.h\"\n#include \"print.h\"\n#include \"sixel.h\"\n#include \"winimg.h\"\n#include \"tek.h\"\n#include \"base64.h\"\n#include \"unicodever.t\"\n\n#include <termios.h>\n#include <sys/time.h>\n\n#define TERM_CMD_BUF_INC_STEP 128\n#define TERM_CMD_BUF_MAX_SIZE (1024 * 1024)\n\n#define SUB_PARS (1 << (sizeof(*term.csi_argv) * 8 - 1))\n\n/* This combines two characters into one value, for the purpose of pairing\n * any modifier byte and the final byte in escape sequences.\n */\n#define CPAIR(x, y) ((x) << 8 | (y))\n\nstatic string primary_da1 = \"\\e[?1;2c\";\nstatic string primary_da2 = \"\\e[?62;1;2;4;6;9;15;22;29c\";\nstatic string primary_da3 = \"\\e[?63;1;2;4;6;9;15;22;29c\";\nstatic string primary_da4 = \"\\e[?64;1;2;4;6;9;15;21;22;28;29c\";\nstatic string primary_da5 = \"\\e[?65;1;2;4;6;9;15;21;22;28;29c\";\n/* Registered Extensions to the Character Cell Display Service Class\n\t1\t132 Column Display\n\t2\tPrinter Port\n\t3\tReGIS Display\n\t4\tSixels Display\n\t6\tSelectively Erasable Characters\n\t9\tNational Replacement Character Sets\n\t15\tTechnical Character Set\n\t21\tHorizontal Scrolling\n\t22\tColor Text\n\t28\tRectangular Editing\n\t29\tText Locator\n*/\n\n\nstatic bool\nterm_push_cmd(char c)\n{\n  uint new_size;\n\n  /* Need 1 more for null byte */\n  if (term.cmd_len + 1 < term.cmd_buf_cap) {\n    term.cmd_buf[term.cmd_len++] = c;\n    term.cmd_buf[term.cmd_len] = 0;\n    return true;\n  }\n\n  if (term.cmd_buf_cap >= TERM_CMD_BUF_MAX_SIZE) {\n    /* Server sends too many cmd characters */\n    return false;\n  }\n  new_size = term.cmd_buf_cap + TERM_CMD_BUF_INC_STEP;\n  if (new_size >= TERM_CMD_BUF_MAX_SIZE) {\n    // cosmetic limitation (relevant limitation above)\n    new_size = TERM_CMD_BUF_MAX_SIZE;\n  }\n  term.cmd_buf = renewn(term.cmd_buf, new_size);\n  term.cmd_buf_cap = new_size;\n  term.cmd_buf[term.cmd_len++] = c;\n  term.cmd_buf[term.cmd_len] = 0;\n  return true;\n}\n\nstatic void\nenable_progress(void)\n{\n  term.lines[term.curs.y]->lattr |= LATTR_PROGRESS;\n}\n\n/*\n * Move the cursor to a given position, clipping at boundaries.\n * We may or may not want to clip at the scroll margin: marg_clip is\n * 0 not to,\n * 1 to disallow _passing_ the margins, and\n * 2 to disallow even _being_ outside the margins.\n */\nstatic void\nmove(int x, int y, int marg_clip)\n{\n  term_cursor *curs = &term.curs;\n\n  if (marg_clip) {\n    if ((curs->y >= term.marg_top || marg_clip == 2) && y < term.marg_top)\n      y = term.marg_top;\n    if ((curs->y <= term.marg_bot || marg_clip == 2) && y > term.marg_bot)\n      y = term.marg_bot;\n    if ((curs->x >= term.marg_left || marg_clip == 2) && x < term.marg_left)\n      x = term.marg_left;\n    if ((curs->x <= term.marg_right || marg_clip == 2) && x > term.marg_right)\n      x = term.marg_right;\n  }\n\n  if (x < 0)\n    x = 0;\n  if (x >= term.cols)\n    x = term.cols - 1;\n  if (y < 0)\n    y = 0;\n  if (y >= term.rows)\n    y = term.rows - 1;\n\n  curs->x = x;\n  curs->y = y;\n  curs->wrapnext = false;\n}\n\n/*\n * Save the cursor and SGR mode.\n */\nstatic void\nsave_cursor(void)\n{\n  term.saved_cursors[term.on_alt_screen] = term.curs;\n}\n\n/*\n * Restore the cursor and SGR mode.\n */\nstatic void\nrestore_cursor(void)\n{\n  term_cursor *curs = &term.curs;\n  *curs = term.saved_cursors[term.on_alt_screen];\n  term.erase_char.attr = curs->attr;\n  term.erase_char.attr.attr &= (ATTR_FGMASK | ATTR_BGMASK);\n  term.erase_char.attr.attr |= TATTR_CLEAR;\n\n /* Make sure the window hasn't shrunk since the save */\n  if (curs->x >= term.cols)\n    curs->x = term.cols - 1;\n  if (curs->y >= term.rows)\n    curs->y = term.rows - 1;\n\n /* In origin mode, make sure the cursor position is within margins */\n  if (curs->origin) {\n    if (curs->x < term.marg_left)\n      curs->x = term.marg_left;\n    else if (curs->x > term.marg_right)\n      curs->x = term.marg_right;\n    if (curs->y < term.marg_top)\n      curs->y = term.marg_top;\n    else if (curs->y > term.marg_bot)\n      curs->y = term.marg_bot;\n  }\n\n /*\n  * wrapnext might reset to False \n  * if the x position is no longer at the rightmost edge.\n  */\n  if (curs->wrapnext && curs->x < term.cols - 1 && curs->x != term.marg_right)\n    curs->wrapnext = false;\n\n  term_update_cs();\n}\n\n/*\n * Insert or delete characters within the current line.\n * n is +ve if insertion is desired, and -ve for deletion.\n */\nstatic void\ninsert_char(int n)\n{\n  if (term.curs.x < term.marg_left || term.curs.x > term.marg_right)\n    return;\n\n  bool del = n < 0;\n  int m;\n  term_cursor *curs = &term.curs;\n  termline *line = term.lines[curs->y];\n  int cols = min(line->cols, line->size);\n  cols = min(cols, term.marg_right + 1);\n\n  n = (n < 0 ? -n : n);\n  if (n > cols - curs->x)\n    n = cols - curs->x;\n  m = cols - curs->x - n;\n  term_check_boundary(curs->x, curs->y);\n  term_check_boundary(curs->x + m, curs->y);\n  if (del) {\n    for (int j = 0; j < m; j++)\n      move_termchar(line, line->chars + curs->x + j,\n                    line->chars + curs->x + j + n);\n    while (n--)\n      line->chars[curs->x + m++] = term.erase_char;\n  }\n  else {\n    for (int j = m; j--;)\n      move_termchar(line, line->chars + curs->x + j + n,\n                    line->chars + curs->x + j);\n    while (n--)\n      line->chars[curs->x + n] = term.erase_char;\n  }\n}\n\nstatic int\ncharwidth(xchar chr)\n{\n#if HAS_LOCALES\n  if (cfg.charwidth % 10)\n    return xcwidth(chr);\n  else\n    if (chr > 0xFFFF)\n      return wcswidth((wchar[]){high_surrogate(chr), low_surrogate(chr)}, 2);\n    else\n      return wcwidth(chr);\n#else\n  return xcwidth(chr);\n#endif\n}\n\nstatic void\nattr_rect(cattrflags add, cattrflags sub, cattrflags xor, short y0, short x0, short y1, short x1)\n{\n  //printf(\"attr_rect %d,%d..%d,%d +%llX -%llX ^%llX\\n\", y0, x0, y1, x1, add, sub, xor);\n  y0--; x0--; y1--; x1--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n  //printf(\"%d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  for (int y = y0; y <= y1; y++) {\n    termline * l = term.lines[y];\n    int xl = x0;\n    int xr = x1;\n    if (!term.attr_rect) {\n      if (y != y0)\n        xl = term.marg_left;\n      if (y != y1)\n        xr = term.marg_right;\n    }\n    for (int x = xl; x <= xr; x++) {\n      //printf(\"attr %d:%d\\n\", y, x);\n      cattrflags ca = l->chars[x].attr.attr;\n      ca ^= xor;\n      ca &= ~sub;\n      ca |= add;\n      if (ca != l->chars[x].attr.attr) {\n        if (x == xl)\n          term_check_boundary(x, y);\n        if (x == xr)\n          term_check_boundary(x + 1, y);\n      }\n      l->chars[x].attr.attr = ca;\n    }\n  }\n}\n\n//static void write_char(wchar c, int width);\nstatic void term_do_write(const char *buf, uint len);\n\nstatic void\nfill_rect(xchar chr, cattr attr, bool sel, short y0, short x0, short y1, short x1)\n{\n  //printf(\"fill_rect %d,%d..%d,%d\\n\", y0, x0, y1, x1);\n  int width = charwidth(chr);\n  if (chr == UCSWIDE || width < 1)\n    return;\n  wchar low = 0;\n  if (chr > 0xFFFF) {\n    low = low_surrogate(chr);\n    chr = high_surrogate(chr);\n  }\n\n  y0--; x0--; y1--; x1--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n  //printf(\"%d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  //printf(\"gl %d gr %d csets %d %d %d %d /%d sup %d acs %d\\n\", term.curs.gl, term.curs.gr, term.curs.csets[0], term.curs.csets[1], term.curs.csets[2], term.curs.csets[3], term.curs.cset_single, term.curs.decsupp, term.curs.oem_acs);\n  if ((chr > ' ' && chr < 0x80 \n       && (term.curs.csets[term.curs.gl] != CSET_ASCII\n           ||\n           term.curs.cset_single != CSET_ASCII\n          )\n      )\n      ||\n      (chr >= 0x80 && chr < 0x100 \n       && ((term.curs.gr && term.curs.csets[term.curs.gr] != CSET_ASCII)\n           || term.curs.oem_acs\n          )\n      )\n      || (chr >= 0x2580 && chr <= 0x259F)\n     )\n  {\n    term_cursor csav = term.curs;\n    term.curs.attr = attr;\n#ifdef debug_FRA_special\n    // make this code branch visible\n    term.curs.attr.attr &= ~ATTR_FGMASK;\n    term.curs.attr.attr |= RED_I << ATTR_FGSHIFT;\n#endif\n    term.curs.width = 1;\n    if (!(width < 2 || (cs_ambig_wide && is_ambig(chr))))\n      term.curs.attr.attr |= TATTR_CLEAR | TATTR_NARROW;\n    term.state = NORMAL;\n\n    char * cbuf = 0;\n    if (chr > 0xFF) {\n      wchar * wc = (wchar[]){chr, low, 0};\n      cbuf = cs__wcstombs(wc);\n    }\n    for (int y = y0; y <= y1; y++) {\n      term.curs.y = y;\n      for (int x = x0; x <= x1; x++) {\n        term.curs.x = x;\n        term.curs.cset_single = csav.cset_single;\n        if (chr > 0xFF) {\n          //write_char(chr, 1); // would skip NRCS handling in term_do_write\n          term_do_write(cbuf, strlen(cbuf));\n        }\n        else {\n          char c = chr;\n          term_do_write(&c, 1);\n        }\n      }\n    }\n    if (cbuf)\n      free(cbuf);\n\n    term.curs = csav;\n    term.curs.cset_single = CSET_ASCII;\n    return;\n  }\n\n  if (width > 1)\n    attr.attr |= TATTR_CLEAR | TATTR_NARROW;\n\n  for (int y = y0; y <= y1; y++) {\n    termline * l = term.lines[y];\n    bool prevprot = true;  // not false!\n    for (int x = x0; x <= x1; x++) {\n      //printf(\"fill %d:%d\\n\", y, x);\n      bool prot = sel && l->chars[x].attr.attr & ATTR_PROTECTED;\n      if (prot != prevprot) {\n        // |P not here, no check\n        // |N check\n        // NP check only current position\n        // PN check\n        if (!prot) {  // includes the case x == x0\n          // clear previous half of wide char, even if protected\n          term_check_boundary(x0, y);\n        }\n        else if (l->chars[x].chr == UCSWIDE) {\n          // clear right half of wide char, even if protected;\n          // calling term_check_boundary would overwrite previous fill char\n          clear_cc(l, x);\n          l->chars[x].chr = ' ';\n        }\n      }\n      // clear wide char on right area border unless protected\n      if (!prot && x == x1)\n        term_check_boundary(x1 + 1, y);\n      prevprot = prot;\n\n      if (!sel || !prot) {\n        clear_cc(l, x);\n        l->chars[x].chr = chr;\n        l->chars[x].attr = attr;\n        if (low)\n          add_cc(l, x, low, attr);\n      }\n    }\n  }\n}\n\nstatic void\ncopy_rect(short y0, short x0, short y1, short x1, short y2, short x2)\n{\n  //printf(\"copy_rect %d,%d..%d,%d -> %d,%d\\n\", y0, x0, y1, x1, y2, x2);\n  y0--; x0--; y1--; x1--; y2--; x2--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n    y2 += term.marg_top;\n    x2 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n\n  if (y2 < 0)\n    y2 = 0;\n  if (x2 < 0)\n    x2 = 0;\n  if (y2 + y1 - y0 >= term.rows)\n    y1 = term.rows + y0 - y2 - 1;\n  if (x2 + x1 - x0 >= term.cols)\n    x1 = term.cols + x0 - x2 - 1;\n  //printf(\"%d,%d..%d,%d -> %d,%d\\n\", y0, x0, y1, x1, y2, x2);\n\n  bool down = y2 > y0;\n  bool left = x2 > x0;\n  for (int y = down ? y1 : y0; down ? y >= y0 : y <= y1; down ? y-- : y++) {\n    termline * src = term.lines[y];\n    termline * dst = term.lines[y + y2 - y0];\n    term_check_boundary(x2, y + y2 - y0);\n    term_check_boundary(x2 + x1 - x0 + 1, y + y2 - y0);\n    for (int x = left ? x1 : x0; left ? x >= x0 : x <= x1; left ? x-- : x++) {\n      copy_termchar(dst, x + x2 - x0, &src->chars[x]);\n      //printf(\"copy %d:%d -> %d:%d\\n\", y, x, y + y2 - y0, x + x2 - x0);\n      if ((x == x0 && src->chars[x].chr == UCSWIDE)\n       || (x == x1 && charwidth(src->chars[x].chr) != 1)\n         )\n      {\n        clear_cc(dst, x);\n        dst->chars[x].chr = ' ';\n      }\n    }\n  }\n}\n\nvoid\nscroll_rect(int topline, int botline, int lines)\n{\n  //printf(\"scroll_rect %d..%d %s%d\\n\", topline, botline, lines > 0 ? \"+\" : \"\", lines);\n  int y0, y1, y2, e0, e1;\n  if (lines < 0) {  // downwards\n//\tscroll\t\tcopy\t\tclear\n//\t4\t-2\t4\t6\t4\n//\t20\t\t18\t\t5\n    if (topline - lines > term.marg_bot + 1)\n      lines = topline - term.marg_bot - 1;\n    y0 = topline;\n    y1 = botline + lines;\n    y2 = topline - lines;\n    e0 = y0;\n    e1 = y0 - lines - 1;\n  }\n  else {\n//\tscroll\t\tcopy\t\tclear\n//\t4\t+2\t6\t4\t19\n//\t20\t\t20\t\t20\n    if (topline + lines > term.marg_bot + 1)\n      lines = term.marg_bot + 1 - topline;\n    y0 = topline + lines;\n    y1 = botline;\n    y2 = topline;\n    e0 = y1 - lines + 1;\n    e1 = y1;\n  }\n  y0++; y1++; y2++; e0++; e1++;\n  int xl = term.marg_left + 1;\n  int xr = term.marg_right + 1;\n  if (term.curs.origin) {\n    // compensate for the originmode applied in the functions called below\n    xl = 1;\n    xr = term.marg_right - term.marg_left + 1;\n    y0 -= term.marg_top;\n    y1 -= term.marg_top;\n    y2 -= term.marg_top;\n    e0 -= term.marg_top;\n    e1 -= term.marg_top;\n  }\n  copy_rect(y0, xl, y1, xr, y2, xl);\n  fill_rect(' ', term.curs.attr, false, e0, xl, e1, xr);\n}\n\nstatic void\ninsdel_column(int col, bool del, int n)\n{\n  //printf(\"insdel_column @%d %d marg %d..%d\\n\", col, n, term.marg_left, term.marg_right);\n  int x0, x1, x2, e0, e1;\n  if (del) {\n    x0 = col + n;\n    x1 = term.marg_right;\n    x2 = col;\n    e0 = term.marg_right - n + 1;\n    e1 = term.marg_right;\n    if (x0 > term.marg_right) {\n      x0 = term.marg_right;\n      e0 = col;\n    }\n  }\n  else {\n    if (col + n > term.marg_right + 1)\n      n = term.marg_right + 1 - col;\n    x0 = col;\n    x1 = term.marg_right - n;\n    x2 = col + n;\n    e0 = col;\n    e1 = col + n - 1;\n  }\n  x0++; x1++; x2++; e0++; e1++;\n  int yt = term.marg_top + 1;\n  int yb = term.marg_bot + 1;\n  if (term.curs.origin) {\n    // compensate for the originmode applied in the functions called below\n    yt = 1;\n    yb = term.marg_bot - term.marg_top + 1;\n    x0 -= term.marg_left;\n    x1 -= term.marg_left;\n    x2 -= term.marg_left;\n    e0 -= term.marg_left;\n    e1 -= term.marg_left;\n  }\n  copy_rect(yt, x0, yb, x1, yt, x2);\n  fill_rect(' ', term.curs.attr, false, yt, e0, yb, e1);\n}\n\nstatic uint\nsum_rect(short y0, short x0, short y1, short x1)\n{\n  //printf(\"sum_rect %d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  y0--; x0--; y1--; x1--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n  //printf(\"%d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  uint sum = 0;\n  for (int y = y0; y <= y1; y++) {\n    termline * line = term.lines[y];\n    for (int x = x0; x <= x1; x++) {\n      //printf(\"add %d:%d\\n\", y, x);\n      if (line->chars[x].chr == UCSWIDE) {\n      }\n      else {\n        sum += line->chars[x].chr;  // xterm default would mask & 0xFF\n        cattrflags attr = line->chars[x].attr.attr;\n        if (attr & ATTR_UNDER)\n          sum += 0x10;\n        else if (attr & ATTR_REVERSE)\n          sum += 0x20;\n        else if (attr & ATTR_BLINK)\n          sum += 0x40;\n        else if (attr & ATTR_BOLD)\n          sum += 0x80;\n        int xc = x;\n        while (line->chars[xc].cc_next) {\n          xc += line->chars[xc].cc_next;\n          sum += line->chars[xc].chr & 0xFF;\n        }\n      }\n    }\n  }\n  return sum;\n}\n\n\nstatic void\nwrite_bell(void)\n{\n  if (cfg.bell_flash)\n    term_schedule_vbell(false, 0);\n  win_bell(&cfg);\n}\n\nstatic void\nwrite_backspace(void)\n{\n  term_cursor *curs = &term.curs;\n  if (curs->x == term.marg_left && curs->y == term.marg_top\n      && term.rev_wrap && !cfg.old_wrapmodes\n     )\n  {\n    curs->y = term.marg_bot;\n    curs->x = term.marg_right;\n  }\n  else if (curs->x == 0 && (curs->y == term.marg_top || !term.autowrap\n                       || (!cfg.old_wrapmodes && !term.rev_wrap)))\n    /* skip */;\n  else if (curs->x == term.marg_left && curs->y > term.marg_top) {\n    curs->y--;\n    curs->x = term.marg_right;\n  }\n  else if (curs->wrapnext) {\n    curs->wrapnext = false;\n    if (!term.rev_wrap && !cfg.old_wrapmodes)\n      curs->x--;\n  }\n  else if (curs->x > 0 && curs->x != term.marg_left)\n    curs->x--;\n}\n\nstatic void\nwrite_tab(void)\n{\n  term_cursor *curs = &term.curs;\n\n  int last = -1;\n  do {\n    if (curs->x == term.marg_right)\n      break;\n    last = curs->x;\n    if (term.lines[curs->y]->chars[last].chr == ' '\n        && (term.lines[curs->y]->chars[last].attr.attr & TATTR_CLEAR)\n       )\n      term.lines[curs->y]->chars[last].attr.attr |= ATTR_DIM;\n    curs->x++;\n  } while (curs->x < term.cols - 1 && !term.tabs[curs->x]);\n  if (last >= 0\n      && term.lines[curs->y]->chars[last].chr == ' '\n      && (term.lines[curs->y]->chars[last].attr.attr & TATTR_CLEAR)\n     )\n    term.lines[curs->y]->chars[last].attr.attr |= ATTR_BOLD;\n\n  if ((term.lines[curs->y]->lattr & LATTR_MODE) != LATTR_NORM) {\n    if (curs->x >= term.cols / 2)\n      curs->x = term.cols / 2 - 1;\n  }\n  else {\n    if (curs->x >= term.cols)\n      curs->x = term.cols - 1;\n  }\n}\n\nstatic void\nwrite_return(void)\n{\n  term.curs.wrapnext = false;\n  if (term.curs.x < term.marg_left)\n    term.curs.x = 0;\n  else\n    term.curs.x = term.marg_left;\n  enable_progress();\n}\n\nstatic void\nwrite_linefeed(void)\n{\n  term_cursor *curs = &term.curs;\n  if (curs->x < term.marg_left || curs->x > term.marg_right)\n    return;\n\n  clear_wrapcontd(term.lines[curs->y], curs->y);\n  if (curs->y == term.marg_bot)\n    term_do_scroll(term.marg_top, term.marg_bot, 1, true);\n  else if (curs->y < term.rows - 1)\n    curs->y++;\n  curs->wrapnext = false;\n}\n\nstatic void\nwrite_primary_da(void)\n{\n  string primary_da = primary_da4;\n  char * vt = strstr(cfg.term, \"vt\");\n  if (vt) {\n    unsigned int ver;\n    if (sscanf(vt + 2, \"%u\", &ver) == 1) {\n      if (ver >= 500)\n        primary_da = primary_da5;\n      else if (ver >= 400)\n        primary_da = primary_da4;\n      else if (ver >= 300)\n        primary_da = primary_da3;\n      else if (ver >= 200)\n        primary_da = primary_da2;\n      else\n        primary_da = primary_da1;\n    }\n  }\n  child_write(primary_da, strlen(primary_da));\n}\n\nstatic wchar last_high = 0;\nstatic wchar last_char = 0;\nstatic int last_width = 0;\ncattr last_attr = {.attr = ATTR_DEFAULT,\n                   .truefg = 0, .truebg = 0, .ulcolr = (colour)-1};\n\nstatic void\nwrite_char(wchar c, int width)\n{\n  //if (kb_trace) printf(\"[%ld] write_char 'q'\\n\", mtime());\n\n  if (tek_mode) {\n    tek_write(c, width);\n    return;\n  }\n\n  if (!c)\n    return;\n\n  term_cursor * curs = &term.curs;\n  termline * line = term.lines[curs->y];\n\n  // support non-BMP for the REP function;\n  // this is a hack, it would be cleaner to fold the term_write block\n  //   switch (term.state) when NORMAL:\n  // and repeat that\n  if (width == -1) {  // low surrogate\n    last_high = last_char;\n  }\n  else {\n    last_high = 0;\n    last_width = width;\n  }\n  last_char = c;\n  last_attr = curs->attr;\n\n  void wrapparabidi(ushort parabidi, termline * line, int y)\n  {\n    line->lattr = (line->lattr & ~LATTR_BIDIMASK) | parabidi | LATTR_WRAPCONTD;\n\n#ifdef determine_parabidi_during_output\n    if (parabidi & (LATTR_BIDISEL | LATTR_AUTOSEL))\n      return;\n\n    // if direction autodetection pending:\n    // from current line, extend backward and forward to adjust \n    // \"paragraph\" bidi attributes (esp. direction) to wrapped lines\n    termline * paraline = line;\n    int paray = y;\n    while ((paraline->lattr & LATTR_WRAPCONTD) && paray > -sblines()) {\n      paraline = fetch_line(--paray);\n      paraline->lattr = (paraline->lattr & ~LATTR_BIDIMASK) | parabidi;\n      release_line(paraline);\n    }\n    paraline = line;\n    paray = y;\n    while ((paraline->lattr & LATTR_WRAPPED) && paray < term.rows) {\n      paraline = fetch_line(++paray);\n      paraline->lattr = (paraline->lattr & ~LATTR_BIDIMASK) | parabidi;\n      release_line(paraline);\n    }\n#else\n    (void)y;\n#endif\n  }\n\n  void put_char(wchar c)\n  {\n    if (term.ring_enabled && curs->x == term.marg_right + 1 - 8) {\n      win_margin_bell(&cfg);\n      term.ring_enabled = false;\n    }\n\n    clear_cc(line, curs->x);\n    line->chars[curs->x].chr = c;\n    line->chars[curs->x].attr = curs->attr;\n#ifdef insufficient_approach\n#warning this does not help when scrolling via rectangular copy\n    if (term.lrmargmode)\n      line->lattr &= ~LATTR_MODE;\n#endif\n    if (!(line->lattr & LATTR_WRAPCONTD))\n      line->lattr = (line->lattr & ~LATTR_BIDIMASK) | curs->bidimode;\n    //TODO: if changed, propagate mode onto paragraph\n    if (cfg.ligatures_support)\n      term_invalidate(0, curs->y, curs->x, curs->y);\n  }\n\n  if (curs->wrapnext && term.autowrap && width > 0) {\n    line->lattr |= LATTR_WRAPPED;\n    line->wrappos = curs->x;\n    ushort parabidi = getparabidi(line);\n    if (curs->y == term.marg_bot)\n      term_do_scroll(term.marg_top, term.marg_bot, 1, true);\n    else if (curs->y < term.rows - 1)\n      curs->y++;\n    curs->x = term.marg_left;\n    curs->wrapnext = false;\n    line = term.lines[curs->y];\n    wrapparabidi(parabidi, line, curs->y);\n  }\n\n  bool overstrike = false;\n  if (curs->attr.attr & ATTR_OVERSTRIKE) {\n    width = 0;\n    overstrike = true;\n    curs->wrapnext = false;\n  }\n\n  bool single_width = false;\n\n  // adjust to explicit width attribute; not for combinings and low surrogates\n  if (curs->width && width > 0) {\n    //if ((c & 0xFFF) == 0x153) printf(\"%llX %d\\n\", curs->attr.attr, width);\n    if (curs->width == 1) {\n      if (!(width < 2 || (cs_ambig_wide && is_ambig(c))))\n        curs->attr.attr |= TATTR_CLEAR | TATTR_NARROW;\n      width = 1;\n    }\n    else if (curs->width == 11) {\n      if (width > 1) {\n        if (!(cs_ambig_wide && is_ambig(c))) {\n          single_width = true;\n          curs->attr.attr |= TATTR_SINGLE;\n        }\n        width = 1;\n      }\n    }\n    else if (curs->width == 2) {\n      if (width < 2) {\n        curs->attr.attr |= TATTR_EXPAND;\n        width = 2;\n      }\n    }\n#ifdef support_triple_width\n    else if (curs->width == 3) {\n      if (width < 2 || (cs_ambig_wide && is_ambig(c)))\n        curs->attr.attr |= TATTR_EXPAND;\n#define TATTR_TRIPLE 0x0080000000000000u\n      curs->attr.attr |= TATTR_TRIPLE;\n      width = 3;\n    }\n#endif\n  }\n\n#ifdef enforce_ambiguous_narrow_here\n  // enforce ambiguous-narrow as configured or for WSL;\n  // this could be done here but is now sufficiently achieved in charset.c\n  if (cs_ambig_narrow && width > 1 && is_ambig(c))\n    width = 1;\n#endif\n\n  if (cfg.charwidth >= 10 || cs_single_forced) {\n    if (width > 1) {\n      single_width = true;\n      width = 1;\n    }\n    else if (is_wide(c) || (cs_ambig_wide && is_ambig(c))) {\n      single_width = true;\n    }\n  }\n\n  if (term.insert && width > 0)\n    insert_char(width);\n\n  switch (width) {\n    when 1:  // Normal character.\n      term_check_boundary(curs->x, curs->y);\n      term_check_boundary(curs->x + 1, curs->y);\n      put_char(c);\n      if (single_width)\n        line->chars[curs->x].attr.attr |= TATTR_SINGLE;\n    when 2 or 3:  // Double-width char (Triple-width was an experimental option).\n     /*\n      * If we're about to display a double-width character \n      * starting in the rightmost column, \n      * then we do something special instead.\n      * We must print a space in the last column of the screen, then wrap;\n      * and we also set LATTR_WRAPPED2 which instructs subsequent \n      * cut-and-pasting not only to splice this line to the one after it, \n      * but to ignore the space in the last character position as well.\n      * (Because what was actually output to the terminal was presumably \n      * just a sequence of CJK characters, and we don't want a space to be\n      * pasted in the middle of those just because they had the misfortune \n      * to start in the wrong parity column. xterm concurs.)\n      */\n      term_check_boundary(curs->x, curs->y);\n      term_check_boundary(curs->x + width, curs->y);\n      if (curs->x == term.marg_right || curs->x == term.cols - 1) {\n        line->chars[curs->x] = term.erase_char;\n        line->lattr |= LATTR_WRAPPED | LATTR_WRAPPED2;\n        line->wrappos = curs->x;\n        ushort parabidi = getparabidi(line);\n        if (curs->y == term.marg_bot)\n          term_do_scroll(term.marg_top, term.marg_bot, 1, true);\n        else if (curs->y < term.rows - 1)\n          curs->y++;\n        curs->x = term.marg_left;\n        line = term.lines[curs->y];\n        wrapparabidi(parabidi, line, curs->y);\n       /* Now we must term_check_boundary again, of course. */\n        term_check_boundary(curs->x, curs->y);\n        term_check_boundary(curs->x + width, curs->y);\n      }\n      put_char(c);\n      curs->x++;\n      put_char(UCSWIDE);\n#ifdef support_triple_width\n      if (width > 2) {\n        for (int i = 2; i < width; i++) {\n          curs->x++;\n          put_char(UCSWIDE);\n        }\n      }\n#endif\n    when 0 or -1:  // Combining character or Low surrogate.\n#ifdef debug_surrogates\n      printf(\"write_char %04X %2d %08llX\\n\", c, width, curs->attr.attr);\n#endif\n      if (curs->x > 0 || overstrike) {\n       /* If we're in wrapnext state, the character\n        * to combine with is _here_, not to our left. */\n        int x = curs->x - !curs->wrapnext;\n       /* Same if we overstrike an actually not combining character. */\n        if (overstrike)\n          x = curs->x;\n       /*\n        * If the previous character is UCSWIDE, back up another one.\n        */\n        if (line->chars[x].chr == UCSWIDE) {\n          assert(x > 0);\n          x--;\n        }\n       /* Try to precompose with the cell's base codepoint */\n        wchar pc;\n        if (termattrs_equal_fg(&line->chars[x].attr, &curs->attr))\n          pc = win_combine_chars(line->chars[x].chr, c, curs->attr.attr);\n        else\n          pc = 0;\n        if (pc)\n          line->chars[x].chr = pc;\n        else\n          add_cc(line, x, c, curs->attr);\n      }\n      else {\n        // add initial combining characters, \n        // particularly to include initial bidi directional markers\n        add_cc(line, -1, c, curs->attr);\n      }\n      if (!overstrike)\n        return;\n      // otherwise width 0 was faked for this switch, \n      // and we still need to advance the cursor below\n    otherwise:  // Anything else. Probably shouldn't get here.\n      return;\n  }\n\n  curs->x++;\n  if (curs->x == term.marg_right + 1 || curs->x == term.cols) {\n    curs->x--;\n    if (term.autowrap || cfg.old_wrapmodes)\n      curs->wrapnext = true;\n  }\n}\n\n#define dont_debug_scriptfonts\n\nstruct rangefont {\n  ucschar first, last;\n  uchar font;\n  char * scriptname;\n};\nstatic struct rangefont scriptfonts[] = {\n#include \"scripts.t\"\n};\nstatic struct rangefont blockfonts[] = {\n#include \"blocks.t\"\n};\nstatic bool scriptfonts_init = false;\nstatic bool use_blockfonts = false;\n\nstatic void\nmapfont(struct rangefont * ranges, uint len, char * script, uchar f)\n{\n  for (uint i = 0; i < len; i++) {\n    if (0 == strcmp(ranges[i].scriptname, script))\n      ranges[i].font = f;\n  }\n  if (0 == strcmp(script, \"CJK\")) {\n    mapfont(ranges, len, \"Han\", f);\n    mapfont(ranges, len, \"Hangul\", f);\n    mapfont(ranges, len, \"Katakana\", f);\n    mapfont(ranges, len, \"Hiragana\", f);\n    mapfont(ranges, len, \"Bopomofo\", f);\n    mapfont(ranges, len, \"Kanbun\", f);\n    mapfont(ranges, len, \"Fullwidth\", f);\n    mapfont(ranges, len, \"Halfwidth\", f);\n  }\n}\n\nstatic char *\ncfg_apply(char * conf, char * item)\n{\n  char * cmdp = conf;\n  char sepch = ';';\n  if ((uchar)*cmdp <= (uchar)' ')\n    sepch = *cmdp++;\n\n  char * paramp;\n  while ((paramp = strchr(cmdp, ':'))) {\n    *paramp = '\\0';\n    paramp++;\n    char * sepp = strchr(paramp, sepch);\n    if (sepp)\n      *sepp = '\\0';\n\n    if (!item || !strcmp(cmdp, item)) {\n      if (*cmdp == '|')\n        mapfont(blockfonts, lengthof(blockfonts), cmdp + 1, atoi(paramp));\n      else\n        mapfont(scriptfonts, lengthof(scriptfonts), cmdp, atoi(paramp));\n    }\n\n    if (sepp) {\n      cmdp = sepp + 1;\n      // check for multi-line separation\n      if (*cmdp == '\\\\' && cmdp[1] == '\\n') {\n        cmdp += 2;\n        while (iswspace(*cmdp))\n          cmdp++;\n      }\n    }\n    else\n      break;\n  }\n  return 0;\n}\n\nstatic void\ninit_scriptfonts(void)\n{\n  if (*cfg.font_choice) {\n    char * cfg_scriptfonts = cs__wcstombs(cfg.font_choice);\n    cfg_apply(cfg_scriptfonts, 0);\n    free(cfg_scriptfonts);\n    use_blockfonts = wcschr(cfg.font_choice, '|');\n  }\n  scriptfonts_init = true;\n}\n\nuchar\nscriptfont(ucschar ch)\n{\n  if (!*cfg.font_choice)\n    return 0;\n  if (!scriptfonts_init)\n    init_scriptfonts();\n\n  int i, j, k;\n\n  if (use_blockfonts) {\n    i = -1;\n    j = lengthof(blockfonts);\n    while (j - i > 1) {\n      k = (i + j) / 2;\n      if (ch < blockfonts[k].first)\n        j = k;\n      else if (ch > blockfonts[k].last)\n        i = k;\n      else {\n        uchar f = blockfonts[k].font;\n        if (f)\n          return f;\n        break;\n      }\n    }\n  }\n\n  i = -1;\n  j = lengthof(scriptfonts);\n  while (j - i > 1) {\n    k = (i + j) / 2;\n    if (ch < scriptfonts[k].first)\n      j = k;\n    else if (ch > scriptfonts[k].last)\n      i = k;\n    else\n      return scriptfonts[k].font;\n  }\n  return 0;\n}\n\nstatic void\nwrite_ucschar(wchar hwc, wchar wc, int width)\n{\n  cattrflags attr = term.curs.attr.attr;\n  ucschar c = hwc ? combine_surrogates(hwc, wc) : wc;\n  uchar cf = scriptfont(c);\n#ifdef debug_scriptfonts\n  if (c && (cf || c > 0xFF))\n    printf(\"write_ucschar %04X scriptfont %d\\n\", c, cf);\n#endif\n  if (cf && cf <= 10 && !(attr & FONTFAM_MASK))\n    term.curs.attr.attr = attr | ((cattrflags)cf << ATTR_FONTFAM_SHIFT);\n\n  if (hwc) {\n    if (width == 1\n        && (cfg.charwidth == 10 || cs_single_forced)\n        && (is_wide(c) || (cs_ambig_wide && is_ambig(c)))\n       )\n    { // ensure indication of cjksingle width handling to trigger down-zooming\n      width = 2;\n    }\n    write_char(hwc, width);\n    write_char(wc, -1);  // -1 indicates low surrogate\n  }\n  else\n    write_char(wc, width);\n\n  term.curs.attr.attr = attr;\n}\n\nstatic void\nwrite_error(void)\n{\n  // Write one of REPLACEMENT CHARACTER or, if that does not exist,\n  // MEDIUM SHADE which looks appropriately erroneous.\n  wchar errch = 0xFFFD;\n  win_check_glyphs(&errch, 1, term.curs.attr.attr);\n  if (!errch)\n    errch = 0x2592;\n  write_char(errch, 1);\n}\n\n\nstatic bool\ncontains(string s, int i)\n{\n  while (*s) {\n    while (*s == ',' || *s == ' ')\n      s++;\n    int si = -1;\n    int len;\n    if (sscanf(s, \"%d%n\", &si, &len) <= 0)\n      return false;\n    s += len;\n    if (si == i && (!*s || *s == ',' || *s == ' '))\n      return true;\n  }\n  return false;\n}\n\n\nstatic short prev_state = 0;\n\n/* Process Tek mode ESC control */\nstatic void\ntek_esc(char c)\n{\n  if (prev_state)\n    term.state = prev_state;\n  else\n    term.state = NORMAL;\n\n  switch (c) {\n    when '\\e':   /* stay in ESC state */\n      term.state = TEK_ESCAPE;\n    when '\\n':   /* LF: stay in ESC state */\n      term.state = TEK_ESCAPE;\n    when 0 or '\\r':   /* stay in ESC state */\n      term.state = TEK_ESCAPE;\n    when '\\a':   /* BEL: Bell */\n      write_bell();\n    when '\\b' or '\\t' or '\\v':     /* BS or HT or VT */\n      tek_write(c, -2);\n    when CTRL('L'):   /* FF: Alpha mode, clear screen */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n      tek_bypass = false;\n      tek_clear();\n    when CTRL('E'):   /* ENQ: terminal type query */\n      tek_bypass = true;\n      tek_enq();\n    when CTRL('N'):   /* LS1: Locking-shift one */\n      tek_alt(true);\n    when CTRL('O'):   /* LS0: Locking-shift zero */\n      tek_alt(false);\n    when CTRL('W'):   /* ETB: Make Copy */\n      term_save_image();\n      tek_bypass = false;\n    when CTRL('X'):   /* CAN: Set Bypass */\n      tek_bypass = true;\n    when CTRL('Z'):   /* SUB: Gin mode */\n      tek_mode = TEKMODE_GIN;\n      tek_gin();\n      term.state = NORMAL;\n      tek_bypass = true;\n    when 0x1C:   /* FS: Special Plot mode */\n      tek_mode = TEKMODE_SPECIAL_PLOT;\n      term.state = TEK_ADDRESS0;\n    when 0x1D:   /* GS: Graph mode */\n      tek_mode = TEKMODE_GRAPH0;\n      term.state = TEK_ADDRESS0;\n    when 0x1E:   /* RS: Incremental Plot mode */\n      tek_mode = TEKMODE_INCREMENTAL_PLOT;\n      term.state = TEK_INCREMENTAL;\n    when 0x1F:   /* US: Normal mode */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n    when '`' ... 'g':  /* Normal mode */\n      tek_beam(false, false, c & 7);\n    when 'h' ... 'o':  /* Defocused mode */\n      tek_beam(true, false, c & 7);\n    when 'p' ... 'w':  /* Write-Thru mode */\n      tek_beam(false, true, c & 7);\n    when '8' ... ';':\n      tek_font(c - '8');\n    when '?':\n      if (term.state == TEK_ADDRESS0 || term.state == TEK_ADDRESS)\n        term_do_write(\"\u007f\", 1);\n    when CTRL('C'):\n      tek_mode = TEKMODE_OFF;\n      term.state = NORMAL;\n      win_invalidate_all(false);\n    when ']':  /* OSC: operating system command */\n      term.state = OSC_START;\n  }\n}\n\n/* Process Tek mode control character */\nstatic void\ntek_ctrl(char c)\n{\n  if (term.state == TEK_ADDRESS0 || term.state == TEK_ADDRESS)\n    prev_state = term.state;\n\n  switch (c) {\n    when '\\e':   /* ESC: Escape */\n      prev_state = term.state;\n      term.state = TEK_ESCAPE;\n    when '\\a':   /* BEL: Bell */\n      write_bell();\n      tek_bypass = false;\n    when '\\b' or '\\t' or '\\v':     /* BS or HT or VT */\n      if (tek_mode == TEKMODE_ALPHA)\n        tek_write(c, -2);\n    when '\\n':   /* LF: Line feed */\n      tek_bypass = false;\n      tek_write(c, -2);\n    when '\\r':   /* CR: Carriage return */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n      tek_bypass = false;\n      tek_write(c, -2);\n    when 0x1C:   /* FS: Point Plot mode */\n      tek_mode = TEKMODE_POINT_PLOT;\n      term.state = TEK_ADDRESS0;\n    when 0x1D:   /* GS: Graph mode */\n      tek_mode = TEKMODE_GRAPH0;\n      term.state = TEK_ADDRESS0;\n    when 0x1E:   /* RS: Incremental Plot mode */\n      tek_mode = TEKMODE_INCREMENTAL_PLOT;\n      term.state = TEK_INCREMENTAL;\n    when 0x1F:   /* US: Normal mode */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n      tek_bypass = false;\n  }\n}\n\n/* Process control character, returning whether it has been recognised. */\nstatic bool\ndo_ctrl(char c)\n{\n  if (tek_mode) {\n    tek_ctrl(c);\n    return true;\n  }\n\n  switch (c) {\n    when '\\e':   /* ESC: Escape */\n      term.state = ESCAPE;\n      term.esc_mod = 0;\n    when '\\a':   /* BEL: Bell */\n      write_bell();\n    when '\\b':     /* BS: Back space */\n      write_backspace();\n    when '\\t':     /* HT: Character tabulation */\n      write_tab();\n    when '\\v':   /* VT: Line tabulation */\n      write_linefeed();\n      if (term.newline_mode)\n        write_return();\n    when '\\f':   /* FF: Form feed */\n      write_linefeed();\n      if (term.newline_mode)\n        write_return();\n    when '\\r':   /* CR: Carriage return */\n      write_return();\n    when '\\n':   /* LF: Line feed */\n      write_linefeed();\n      if (term.newline_mode)\n        write_return();\n    when CTRL('E'):   /* ENQ: terminal type query */\n      if (!term.vt52_mode) {\n        char * ab = cs__wcstombs(cfg.answerback);\n        child_write(ab, strlen(ab));\n        free(ab);\n      }\n    when CTRL('N'):   /* LS1: Locking-shift one */\n      if (!term.vt52_mode) {\n        term.curs.gl = 1;\n        term_update_cs();\n      }\n    when CTRL('O'):   /* LS0: Locking-shift zero */\n      if (!term.vt52_mode) {\n        term.curs.gl = 0;\n        term_update_cs();\n      }\n    otherwise:\n      return false;\n  }\n  return true;\n}\n\nstatic void\ndo_vt52(uchar c)\n{\n  term_cursor *curs = &term.curs;\n  term.state = NORMAL;\n  term.autowrap = false;\n  term.rev_wrap = false;\n  term.esc_mod = 0;\n  switch (c) {\n    when '\\e':\n      term.state = ESCAPE;\n    when '<':  /* Exit VT52 mode (Enter VT100 mode). */\n      term.vt52_mode = 0;\n    when '=':  /* Enter alternate keypad mode. */\n      term.app_keypad = true;\n    when '>':  /* Exit alternate keypad mode. */\n      term.app_keypad = false;\n    when 'A':  /* Cursor up. */\n      move(curs->x, curs->y - 1, 0);\n    when 'B':  /* Cursor down. */\n      move(curs->x, curs->y + 1, 0);\n    when 'C':  /* Cursor right. */\n      move(curs->x + 1, curs->y, 0);\n    when 'D':  /* Cursor left. */\n      move(curs->x - 1, curs->y, 0);\n    when 'F':  /* Enter graphics mode. */\n      term.vt52_mode = 2;\n    when 'G':  /* Exit graphics mode. */\n      term.vt52_mode = 1;\n    when 'H':  /* Move the cursor to the home position. */\n      move(0, 0, 0);\n    when 'I':  /* Reverse line feed. */\n      if (curs->y == term.marg_top)\n        term_do_scroll(term.marg_top, term.marg_bot, -1, true);\n      else if (curs->y > 0)\n        curs->y--;\n      curs->wrapnext = false;\n    when 'J':  /* Erase from the cursor to the end of the screen. */\n      term_erase(false, false, false, true);\n    when 'K':  /* Erase from the cursor to the end of the line. */\n      term_erase(false, true, false, true);\n    when 'Y':  /* Move the cursor to given row and column. */\n      term.state = VT52_Y;\n    when 'Z':  /* Identify. */\n      child_write(\"\\e/Z\", 3);\n    // Atari ST extensions\n    when 'E':  /* Clear screen */\n      move(0, 0, 0);\n      term_erase(false, false, false, true);\n    when 'b':  /* Foreground color */\n      term.state = VT52_FG;\n    when 'c':  /* Background color */\n      term.state = VT52_BG;\n    when 'd':  /* Clear to start of screen */\n      term_erase(false, false, true, false);\n    when 'e':  /* Enable cursor */\n      term.cursor_on = true;\n    when 'f':  /* Disable cursor */\n      term.cursor_on = false;\n    when 'j':  /* Save cursor */\n      save_cursor();\n    when 'k':  /* Restore cursor */\n      restore_cursor();\n    when 'l':  /* Clear line */\n      term_erase(false, true, true, true);\n      write_return();\n    when 'o':  /* Clear to start of line */\n      term_erase(false, true, true, false);\n    when 'p':  /* Reverse video */\n      term.curs.attr.attr |= ATTR_REVERSE;\n    when 'q':  /* Normal video */\n      term.curs.attr.attr &= ~ATTR_REVERSE;\n    when 'v':  /* Wrap on */\n      term.autowrap = true;\n      term.curs.wrapnext = false;\n    when 'w':  /* Wrap off */\n      term.autowrap = false;\n      term.curs.wrapnext = false;\n  }\n}\n\nstatic void\ndo_vt52_move(void)\n{\n  term.state = NORMAL;\n  uchar y = term.cmd_buf[0];\n  uchar x = term.cmd_buf[1];\n  if (y < ' ' || x < ' ')\n    return;\n  move(x - ' ', y - ' ', 0);\n}\n\nstatic void\ndo_vt52_colour(bool fg, uchar c)\n{\n  term.state = NORMAL;\n  if (fg) {\n    term.curs.attr.attr &= ~ATTR_FGMASK;\n    term.curs.attr.attr |= ((c & 0xF) + ANSI0) << ATTR_FGSHIFT;\n  }\n  else {\n    term.curs.attr.attr &= ~ATTR_BGMASK;\n    term.curs.attr.attr |= ((c & 0xF) + ANSI0) << ATTR_BGSHIFT;\n  }\n}\n\nstatic term_cset\nlookup_cset(ushort nrc_code, uchar csmask, bool enabled)\n{\n  static struct {\n    ushort design;\n    uchar cstype;  // 1: 94-character set, 2: 96-character set, 3: both\n    bool free;     // does not need NRC enabling\n    uchar cs;\n  } csdesignations[] = {\n    {'B', 1, 1, CSET_ASCII},\t// ASCII\n    {'A', 3, 1, CSET_GBCHR},\t// UK Latin-1\n    {'0', 1, 1, CSET_LINEDRW},\t// DEC Special Line Drawing\n    {'>', 1, 1, CSET_TECH},\t\t// DEC Technical\n    {'U', 1, 1, CSET_OEM},\t\t// OEM Codepage 437\n    {'<', 1, 1, CSET_DECSUPP},\t// DEC User-preferred Supplemental (VT200)\n    {CPAIR('%', '5'), 1, 1, CSET_DECSPGR},\t// DEC Supplementary (VT300)\n    // definitions for NRC support:\n    {'4', 1, 0, CSET_NL},\t// Dutch\n    {'C', 1, 0, CSET_FI},\t// Finnish\n    {'5', 1, 0, CSET_FI},\t// Finnish\n    {'R', 1, 0, CSET_FR},\t// French\n    {'f', 1, 0, CSET_FR},\t// French\n    {'Q', 1, 0, CSET_CA},\t// French Canadian (VT200, VT300)\n    {'9', 1, 0, CSET_CA},\t// French Canadian (VT200, VT300)\n    {'K', 1, 0, CSET_DE},\t// German\n    {'Y', 1, 0, CSET_IT},\t// Italian\n    {'`', 1, 0, CSET_NO},\t// Norwegian/Danish\n    {'E', 1, 0, CSET_NO},\t// Norwegian/Danish\n    {'6', 1, 0, CSET_NO},\t// Norwegian/Danish\n    {CPAIR('%', '6'), 1, 0, CSET_PT},\t// Portuguese (VT300)\n    {'Z', 1, 0, CSET_ES},\t// Spanish\n    {'H', 1, 0, CSET_SE},\t// Swedish\n    {'7', 1, 0, CSET_SE},\t// Swedish\n    {'=', 1, 0, CSET_CH},\t// Swiss\n    // 96-character sets (xterm 336)\n    {'L', 2, 1, CSET_ISO_Latin_Cyrillic},\n    {'F', 2, 1, CSET_ISO_Greek_Supp},\n    {'H', 2, 1, CSET_ISO_Hebrew},\n    {'M', 2, 1, CSET_ISO_Latin_5},\n    {CPAIR('\"', '?'), 1, 1, CSET_DEC_Greek_Supp},\n    {CPAIR('\"', '4'), 1, 1, CSET_DEC_Hebrew_Supp},\n    {CPAIR('%', '0'), 1, 1, CSET_DEC_Turkish_Supp},\n    {CPAIR('&', '4'), 1, 1, CSET_DEC_Cyrillic},\n    {CPAIR('\"', '>'), 1, 0, CSET_NRCS_Greek},\n    {CPAIR('%', '='), 1, 0, CSET_NRCS_Hebrew},\n    {CPAIR('%', '2'), 1, 0, CSET_NRCS_Turkish},\n  };\n  for (uint i = 0; i < lengthof(csdesignations); i++)\n    if (csdesignations[i].design == nrc_code\n        && (csdesignations[i].cstype & csmask)\n        && (csdesignations[i].free || enabled)\n       )\n    {\n      return csdesignations[i].cs;\n    }\n  return 0;\n}\n\n// compatible state machine expansion for NCR and DECRQM\nstatic uchar esc_mod0 = 0;\nstatic uchar esc_mod1 = 0;\n\nstatic void\ndo_esc(uchar c)\n{\n  term_cursor *curs = &term.curs;\n  term.state = NORMAL;\n\n  // NRC designations\n  // representation of NRC sequences at this point:\n  //\t\tterm.esc_mod esc_mod0 esc_mod1 c\n  // ESC)B\t29 00 00 42\n  // ESC)%5\tFF 29 25 35\n  // 94-character set designation as G0...G3: ()*+\n  // 96-character set designation as G1...G3:  -./\n  uchar designator = term.esc_mod == 0xFF ? esc_mod0 : term.esc_mod;\n  uchar csmask = 0;\n  int gi;\n  if (designator) {\n    void check_designa(char * designa, uchar cstype) {\n      char * csdesigna = strchr(designa, designator);\n      if (csdesigna) {\n        csmask = cstype;\n        gi = csdesigna - designa + cstype - 1;\n      }\n    }\n    check_designa(\"()*+\", 1);  // 94-character set designation?\n    check_designa(\"-./\", 2);  // 96-character set designation?\n  }\n  if (csmask) {\n    ushort nrc_code = CPAIR(esc_mod1, c);\n    term_cset cs = lookup_cset(nrc_code, csmask, term.decnrc_enabled);\n    if (cs) {\n      curs->csets[gi] = cs;\n      term_update_cs();\n      return;\n    }\n  }\n\n  switch (CPAIR(term.esc_mod, c)) {\n    when '[':  /* CSI: control sequence introducer */\n      term.state = CSI_ARGS;\n      term.csi_argc = 1;\n      memset(term.csi_argv, 0, sizeof(term.csi_argv));\n      memset(term.csi_argv_defined, 0, sizeof(term.csi_argv_defined));\n      term.esc_mod = 0;\n    when ']':  /* OSC: operating system command */\n      term.state = OSC_START;\n    when 'P':  /* DCS: device control string */\n      term.state = DCS_START;\n    when '^' or '_' or 'X': /* PM, APC, SOS strings to be ignored */\n      term.state = IGNORE_STRING;\n    when '7':  /* DECSC: save cursor */\n      save_cursor();\n    when '8':  /* DECRC: restore cursor */\n      restore_cursor();\n    when '=':  /* DECKPAM: Keypad application mode */\n      term.app_keypad = true;\n    when '>':  /* DECKPNM: Keypad numeric mode */\n      term.app_keypad = false;\n    when 'D':  /* IND: exactly equivalent to LF */\n      write_linefeed();\n    when 'E':  /* NEL: exactly equivalent to CR-LF */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right) {\n        write_return();\n        write_linefeed();\n      }\n    when 'M':  /* RI: reverse index - backwards LF */\n      if (curs->y == term.marg_top)\n        term_do_scroll(term.marg_top, term.marg_bot, -1, true);\n      else if (curs->y > 0)\n        curs->y--;\n      curs->wrapnext = false;\n    when 'Z':  /* DECID: terminal type query */\n      write_primary_da();\n    when 'c':  /* RIS: restore power-on settings */\n      winimgs_clear();\n      term_reset(true);\n      if (term.reset_132) {\n        win_set_chars(term.rows, 80);\n        term.reset_132 = 0;\n      }\n    when 'H':  /* HTS: set a tab */\n      term.tabs[curs->x] = true;\n    when 'l':  /* HP Memory Lock */\n      if (curs->y < term.marg_bot)\n        term.marg_top = curs->y;\n    when 'm':  /* HP Memory Unlock */\n      term.marg_top = 0;\n    when CPAIR('#', '8'):    /* DECALN: fills screen with Es :-) */\n      term.curs.origin = false;\n      term.curs.wrapnext = false;\n      term.curs.attr = CATTR_DEFAULT;\n      term.marg_top = 0;\n      term.marg_bot = term.rows - 1;\n      term.marg_left = 0;\n      term.marg_right = term.cols - 1;\n      move(0, 0, 0);\n      for (int i = 0; i < term.rows; i++) {\n        termline *line = term.lines[i];\n        for (int j = 0; j < term.cols; j++) {\n          line->chars[j] =\n            (termchar) {.cc_next = 0, .chr = 'E', .attr = CATTR_DEFAULT};\n        }\n        line->lattr = LATTR_NORM;\n      }\n      term.disptop = 0;\n    when CPAIR('#', '3'):  /* DECDHL: 2*height, top */\n      if (!term.lrmargmode) {\n        term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n        term.lines[curs->y]->lattr |= LATTR_TOP;\n      }\n    when CPAIR('#', '4'):  /* DECDHL: 2*height, bottom */\n      if (!term.lrmargmode) {\n        term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n        term.lines[curs->y]->lattr |= LATTR_BOT;\n      }\n    when CPAIR('#', '5'):  /* DECSWL: normal */\n      term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n      term.lines[curs->y]->lattr |= LATTR_NORM;\n    when CPAIR('#', '6'):  /* DECDWL: 2*width */\n      if (!term.lrmargmode) {\n        term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n        term.lines[curs->y]->lattr |= LATTR_WIDE;\n      }\n    when CPAIR('%', '8') or CPAIR('%', 'G'):\n      curs->utf = true;\n      term_update_cs();\n    when CPAIR('%', '@'):\n      curs->utf = false;\n      term_update_cs();\n    when 'n':  /* LS2: Invoke G2 character set as GL */\n      term.curs.gl = 2;\n      term_update_cs();\n    when 'o':  /* LS3: Invoke G3 character set as GL */\n      term.curs.gl = 3;\n      term_update_cs();\n    when '~':  /* LS1R: Invoke G1 character set as GR */\n      term.curs.gr = 1;\n      term_update_cs();\n    when '}':  /* LS2R: Invoke G2 character set as GR */\n      term.curs.gr = 2;\n      term_update_cs();\n    when '|':  /* LS3R: Invoke G3 character set as GR */\n      term.curs.gr = 3;\n      term_update_cs();\n    when 'N':  /* SS2: Single Shift G2 character set */\n      term.curs.cset_single = curs->csets[2];\n    when 'O':  /* SS3: Single Shift G3 character set */\n      term.curs.cset_single = curs->csets[3];\n    when '6':  /* Back Index (DECBI), VT420 */\n      if (curs->x == term.marg_left)\n        insdel_column(term.marg_left, false, 1);\n      else\n        move(curs->x - 1, curs->y, 1);\n    when '9':  /* Forward Index (DECFI), VT420 */\n      if (curs->x == term.marg_right)\n        insdel_column(term.marg_left, true, 1);\n      else\n        move(curs->x + 1, curs->y, 1);\n  }\n}\n\nstatic void\ndo_sgr(void)\n{\n /* Set Graphics Rendition. */\n  uint argc = term.csi_argc;\n  cattr attr = term.curs.attr;\n  uint prot = attr.attr & ATTR_PROTECTED;\n  for (uint i = 0; i < argc; i++) {\n    // support colon-separated sub parameters as specified in\n    // ISO/IEC 8613-6 (ITU Recommendation T.416)\n    int sub_pars = 0;\n    // count sub parameters and clear their SUB_PARS flag \n    // (the last one does not have it)\n    // but not the SUB_PARS flag of the main parameter\n    if (term.csi_argv[i] & SUB_PARS)\n      for (uint j = i + 1; j < argc; j++) {\n        sub_pars++;\n        if (term.csi_argv[j] & SUB_PARS)\n          term.csi_argv[j] &= ~SUB_PARS;\n        else\n          break;\n      }\n    if (*cfg.suppress_sgr\n        && contains(cfg.suppress_sgr, term.csi_argv[i] & ~SUB_PARS))\n    {\n      // skip suppressed attribute (but keep processing sub_pars)\n      // but turn some sequences into virtual sub-parameters\n      // in order to get properly adjusted\n      if (term.csi_argv[i] == 38 || term.csi_argv[i] == 48) {\n        if (i + 2 < argc && term.csi_argv[i + 1] == 5)\n          sub_pars = 2;\n        else if (i + 4 < argc && term.csi_argv[i + 1] == 2)\n          sub_pars = 4;\n      }\n    }\n    else\n    switch (term.csi_argv[i]) {\n      when 0:\n        attr = CATTR_DEFAULT;\n        attr.attr |= prot;\n      when 1: attr.attr |= ATTR_BOLD;\n      when 2: attr.attr |= ATTR_DIM;\n      when 1 | SUB_PARS:\n        if (i + 1 < argc)\n          switch (term.csi_argv[i + 1]) {\n            when 2:\n              attr.attr |= ATTR_SHADOW;\n          }\n      when 3: attr.attr |= ATTR_ITALIC;\n      when 4:\n        attr.attr &= ~UNDER_MASK;\n        attr.attr |= ATTR_UNDER;\n      when 4 | SUB_PARS:\n        if (i + 1 < argc)\n          switch (term.csi_argv[i + 1]) {\n            when 0:\n              attr.attr &= ~UNDER_MASK;\n            when 1:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_UNDER;\n            when 2:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_DOUBLYUND;\n            when 3:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_CURLYUND;\n            when 4:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_BROKENUND;\n            when 5:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_BROKENUND | ATTR_DOUBLYUND;\n          }\n      when 5: attr.attr |= ATTR_BLINK;\n      when 6: attr.attr |= ATTR_BLINK2;\n      when 7: attr.attr |= ATTR_REVERSE;\n      when 8: attr.attr |= ATTR_INVISIBLE;\n      when 8 | SUB_PARS:\n        if (i + 1 < argc)\n          switch (term.csi_argv[i + 1]) {\n            when 7:\n              attr.attr |= ATTR_OVERSTRIKE;\n          }\n      when 9: attr.attr |= ATTR_STRIKEOUT;\n      when 73: attr.attr |= ATTR_SUPERSCR;\n      when 74: attr.attr |= ATTR_SUBSCR;\n      when 75: attr.attr &= ~(ATTR_SUPERSCR | ATTR_SUBSCR);\n      when 10 ... 11: {  // ... 12 disabled\n        // mode 10 is the configured character set\n        // mode 11 is the VGA character set (CP437 + control range graphics)\n        // mode 12 (VT520, Linux console, not cygwin console) \n        // clones VGA characters into the ASCII range; disabled;\n        // modes 11 (and 12) are overridden by alternative font if configured\n          uchar arg_10 = term.csi_argv[i] - 10;\n          if (arg_10 && *cfg.fontfams[arg_10].name) {\n            attr.attr &= ~FONTFAM_MASK;\n            attr.attr |= (cattrflags)arg_10 << ATTR_FONTFAM_SHIFT;\n          }\n          else {\n            if (!arg_10)\n              attr.attr &= ~FONTFAM_MASK;\n            term.curs.oem_acs = arg_10;\n            term_update_cs();\n          }\n        }\n      when 12 ... 20:\n        attr.attr &= ~FONTFAM_MASK;\n        attr.attr |= (cattrflags)(term.csi_argv[i] - 10) << ATTR_FONTFAM_SHIFT;\n      //when 21: attr.attr &= ~ATTR_BOLD;\n      when 21:\n        attr.attr &= ~UNDER_MASK;\n        attr.attr |= ATTR_DOUBLYUND;\n      when 22: attr.attr &= ~(ATTR_BOLD | ATTR_DIM | ATTR_SHADOW);\n      when 23:\n        attr.attr &= ~ATTR_ITALIC;\n        if (((attr.attr & FONTFAM_MASK) >> ATTR_FONTFAM_SHIFT) + 10 == 20)\n          attr.attr &= ~FONTFAM_MASK;\n      when 24: attr.attr &= ~UNDER_MASK;\n      when 25: attr.attr &= ~(ATTR_BLINK | ATTR_BLINK2);\n      when 27: attr.attr &= ~ATTR_REVERSE;\n      when 28: attr.attr &= ~(ATTR_INVISIBLE | ATTR_OVERSTRIKE);\n      when 29: attr.attr &= ~ATTR_STRIKEOUT;\n      when 30 ... 37: /* foreground */\n        attr.attr &= ~ATTR_FGMASK;\n        attr.attr |= (term.csi_argv[i] - 30 + ANSI0) << ATTR_FGSHIFT;\n      when 51 or 52: /* \"framed\" or \"encircled\" */\n        attr.attr |= ATTR_FRAMED;\n      when 54: /* not framed, not encircled */\n        attr.attr &= ~ATTR_FRAMED;\n      when 53: attr.attr |= ATTR_OVERL;\n      when 55: attr.attr &= ~ATTR_OVERL;\n      when 90 ... 97: /* bright foreground */\n        attr.attr &= ~ATTR_FGMASK;\n        attr.attr |= ((term.csi_argv[i] - 90 + 8 + ANSI0) << ATTR_FGSHIFT);\n      when 38: /* palette/true-colour foreground */\n        if (i + 2 < argc && term.csi_argv[i + 1] == 5) {\n          // set foreground to palette colour\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_FGSHIFT);\n          i += 2;\n        }\n        else if (i + 4 < argc && term.csi_argv[i + 1] == 2) {\n          // set foreground to RGB\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_FGSHIFT;\n          uint r = term.csi_argv[i + 2];\n          uint g = term.csi_argv[i + 3];\n          uint b = term.csi_argv[i + 4];\n          attr.truefg = make_colour(r, g, b);\n          i += 4;\n        }\n      when 38 | SUB_PARS: /* ISO/IEC 8613-6 foreground colour */\n        if (sub_pars >= 2 && term.csi_argv[i + 1] == 5) {\n          // set foreground to palette colour\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_FGSHIFT);\n        }\n        else if (sub_pars >= 4 && term.csi_argv[i + 1] == 2) {\n          // set foreground to RGB\n          uint pi = sub_pars >= 5;\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_FGSHIFT;\n          uint r = term.csi_argv[i + pi + 2];\n          uint g = term.csi_argv[i + pi + 3];\n          uint b = term.csi_argv[i + pi + 4];\n          attr.truefg = make_colour(r, g, b);\n        }\n        else if ((sub_pars >= 5 && term.csi_argv[i + 1] == 3) ||\n                 (sub_pars >= 6 && term.csi_argv[i + 1] == 4)) {\n          // set foreground to CMY(K)\n          ulong f = term.csi_argv[i + 2];\n          ulong c = term.csi_argv[i + 3];\n          ulong m = term.csi_argv[i + 4];\n          ulong y = term.csi_argv[i + 5];\n          ulong k = term.csi_argv[i + 1] == 4 ? term.csi_argv[i + 6] : 0;\n          if (c <= f && m <= f && y <= f && k <= f) {\n            uint r = (f - c) * (f - k) / f * 255 / f;\n            uint g = (f - m) * (f - k) / f * 255 / f;\n            uint b = (f - y) * (f - k) / f * 255 / f;\n            attr.attr &= ~ATTR_FGMASK;\n            attr.attr |= TRUE_COLOUR << ATTR_FGSHIFT;\n            attr.truefg = make_colour(r, g, b);\n          }\n        }\n      when 39: /* default foreground */\n        attr.attr &= ~ATTR_FGMASK;\n        attr.attr |= ATTR_DEFFG;\n      when 40 ... 47: /* background */\n        attr.attr &= ~ATTR_BGMASK;\n        attr.attr |= (term.csi_argv[i] - 40 + ANSI0) << ATTR_BGSHIFT;\n      when 100 ... 107: /* bright background */\n        attr.attr &= ~ATTR_BGMASK;\n        attr.attr |= ((term.csi_argv[i] - 100 + 8 + ANSI0) << ATTR_BGSHIFT);\n      when 48: /* palette/true-colour background */\n        if (i + 2 < argc && term.csi_argv[i + 1] == 5) {\n          // set background to palette colour\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_BGSHIFT);\n          i += 2;\n        }\n        else if (i + 4 < argc && term.csi_argv[i + 1] == 2) {\n          // set background to RGB\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_BGSHIFT;\n          uint r = term.csi_argv[i + 2];\n          uint g = term.csi_argv[i + 3];\n          uint b = term.csi_argv[i + 4];\n          attr.truebg = make_colour(r, g, b);\n          i += 4;\n        }\n      when 48 | SUB_PARS: /* ISO/IEC 8613-6 background colour */\n        if (sub_pars >= 2 && term.csi_argv[i + 1] == 5) {\n          // set background to palette colour\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_BGSHIFT);\n        }\n        else if (sub_pars >= 4 && term.csi_argv[i + 1] == 2) {\n          // set background to RGB\n          uint pi = sub_pars >= 5;\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_BGSHIFT;\n          uint r = term.csi_argv[i + pi + 2];\n          uint g = term.csi_argv[i + pi + 3];\n          uint b = term.csi_argv[i + pi + 4];\n          attr.truebg = make_colour(r, g, b);\n        }\n        else if ((sub_pars >= 5 && term.csi_argv[i + 1] == 3) ||\n                 (sub_pars >= 6 && term.csi_argv[i + 1] == 4)) {\n          // set background to CMY(K)\n          ulong f = term.csi_argv[i + 2];\n          ulong c = term.csi_argv[i + 3];\n          ulong m = term.csi_argv[i + 4];\n          ulong y = term.csi_argv[i + 5];\n          ulong k = term.csi_argv[i + 1] == 4 ? term.csi_argv[i + 6] : 0;\n          if (c <= f && m <= f && y <= f && k <= f) {\n            uint r = (f - c) * (f - k) / f * 255 / f;\n            uint g = (f - m) * (f - k) / f * 255 / f;\n            uint b = (f - y) * (f - k) / f * 255 / f;\n            attr.attr &= ~ATTR_BGMASK;\n            attr.attr |= TRUE_COLOUR << ATTR_BGSHIFT;\n            attr.truebg = make_colour(r, g, b);\n          }\n        }\n      when 49: /* default background */\n        attr.attr &= ~ATTR_BGMASK;\n        attr.attr |= ATTR_DEFBG;\n      when 58 | SUB_PARS: /* ISO/IEC 8613-6 format underline colour */\n        if (sub_pars >= 2 && term.csi_argv[i + 1] == 5) {\n          // set foreground to palette colour\n          attr.attr |= ATTR_ULCOLOUR;\n          attr.ulcolr = colours[term.csi_argv[i + 2] & 0xFF];\n        }\n        else if (sub_pars >= 4 && term.csi_argv[i + 1] == 2) {\n          // set foreground to RGB\n          uint pi = sub_pars >= 5;\n          uint r = term.csi_argv[i + pi + 2];\n          uint g = term.csi_argv[i + pi + 3];\n          uint b = term.csi_argv[i + pi + 4];\n          attr.attr |= ATTR_ULCOLOUR;\n          attr.ulcolr = make_colour(r, g, b);\n        }\n        else if ((sub_pars >= 5 && term.csi_argv[i + 1] == 3) ||\n                 (sub_pars >= 6 && term.csi_argv[i + 1] == 4)) {\n          // set foreground to CMY(K)\n          ulong f = term.csi_argv[i + 2];\n          ulong c = term.csi_argv[i + 3];\n          ulong m = term.csi_argv[i + 4];\n          ulong y = term.csi_argv[i + 5];\n          ulong k = term.csi_argv[i + 1] == 4 ? term.csi_argv[i + 6] : 0;\n          if (c <= f && m <= f && y <= f && k <= f) {\n            uint r = (f - c) * (f - k) / f * 255 / f;\n            uint g = (f - m) * (f - k) / f * 255 / f;\n            uint b = (f - y) * (f - k) / f * 255 / f;\n            attr.attr |= ATTR_ULCOLOUR;\n            attr.ulcolr = make_colour(r, g, b);\n          }\n        }\n      when 59: /* default underline colour */\n        attr.attr &= ~ATTR_ULCOLOUR;\n        attr.ulcolr = (colour)-1;\n    }\n    // skip sub parameters\n    i += sub_pars;\n  }\n  term.curs.attr = attr;\n  term.erase_char.attr = attr;\n  term.erase_char.attr.attr &= (ATTR_FGMASK | ATTR_BGMASK);\n  term.erase_char.attr.attr |= TATTR_CLEAR;\n}\n\n/*\n * Set terminal modes in escape arguments to state.\n */\nstatic void\nset_modes(bool state)\n{\n  for (uint i = 0; i < term.csi_argc; i++) {\n    uint arg = term.csi_argv[i];\n    if (term.esc_mod) { /* DECSET/DECRST: DEC private mode set/reset */\n      if (*cfg.suppress_dec && contains(cfg.suppress_dec, arg))\n        ; // skip suppressed DECSET/DECRST operation\n      else\n      switch (arg) {\n        when 1:  /* DECCKM: application cursor keys */\n          term.app_cursor_keys = state;\n        when 66:  /* DECNKM: application keypad */\n          term.app_keypad = state;\n        when 2:  /* DECANM: VT100/VT52 mode */\n          if (state) {\n            // Designate USASCII for character sets G0-G3\n            for (uint i = 0; i < lengthof(term.curs.csets); i++)\n              term.curs.csets[i] = CSET_ASCII;\n            term.curs.cset_single = CSET_ASCII;\n            term_update_cs();\n          }\n          else\n            term.vt52_mode = 1;\n        when 3:  /* DECCOLM: 80/132 columns */\n          if (term.deccolm_allowed) {\n            term.selected = false;\n            win_set_chars(term.rows, state ? 132 : 80);\n            term.reset_132 = state;\n            term.marg_top = 0;\n            term.marg_bot = term.rows - 1;\n            term.marg_left = 0;\n            term.marg_right = term.cols - 1;\n            move(0, 0, 0);\n            if (!term.deccolm_noclear)\n              term_erase(false, false, true, true);\n          }\n        when 5:  /* DECSCNM: reverse video */\n          if (state != term.rvideo) {\n            term.rvideo = state;\n            win_invalidate_all(false);\n          }\n        when 6:  /* DECOM: DEC origin mode */\n          term.curs.origin = state;\n          if (state)\n            move(term.marg_left, term.marg_top, 0);\n          else\n            move(0, 0, 0);\n        when 7:  /* DECAWM: auto wrap */\n          term.autowrap = state;\n          term.curs.wrapnext = false;\n        when 45:  /* xterm: reverse (auto) wraparound */\n          term.rev_wrap = state;\n          term.curs.wrapnext = false;\n        when 8:  /* DECARM: auto key repeat */\n          term.auto_repeat = state;\n        when 9:  /* X10_MOUSE */\n          term.mouse_mode = state ? MM_X10 : 0;\n          win_update_mouse();\n        when 12: /* AT&T 610 blinking cursor */\n          term.cursor_blinkmode = state;\n          term.cursor_invalid = true;\n          term_schedule_cblink();\n        when 25: /* DECTCEM: enable/disable cursor */\n          term.cursor_on = state;\n          // Should we set term.cursor_invalid or call term_invalidate ?\n        when 30: /* Show/hide scrollbar */\n          if (state != term.show_scrollbar) {\n            term.show_scrollbar = state;\n            win_update_scrollbar(false);\n          }\n        when 38: /* DECTEK: Enter Tektronix Mode (VT240, VT330) */\n          if (state) {\n            tek_mode = TEKMODE_ALPHA;\n            tek_init(true, cfg.tek_glow);\n          }\n        when 40: /* Allow/disallow DECCOLM (xterm c132 resource) */\n          term.deccolm_allowed = state;\n        when 95: /* VT510 DECNCSM: DECCOLM does not clear the screen */\n          term.deccolm_noclear = state;\n        when 42: /* DECNRCM: national replacement character sets */\n          term.decnrc_enabled = state;\n        when 44: /* turn on margin bell (xterm) */\n          term.margin_bell = state;\n        when 67: /* DECBKM: backarrow key mode */\n          term.backspace_sends_bs = state;\n        when 69: /* DECLRMM/VT420 DECVSSM: enable left/right margins DECSLRM */\n          term.lrmargmode = state;\n          if (state) {\n            for (int i = 0; i < term.rows; i++) {\n              termline *line = term.lines[i];\n              line->lattr = LATTR_NORM;\n            }\n          }\n          else {\n            term.marg_left = 0;\n            term.marg_right = term.cols - 1;\n          }\n        when 80: /* DECSDM: SIXEL display mode */\n          term.sixel_display = !state;\n        when 1000: /* VT200_MOUSE */\n          term.mouse_mode = state ? MM_VT200 : 0;\n          win_update_mouse();\n        when 1002: /* BTN_EVENT_MOUSE */\n          term.mouse_mode = state ? MM_BTN_EVENT : 0;\n          win_update_mouse();\n        when 1003: /* ANY_EVENT_MOUSE */\n          term.mouse_mode = state ? MM_ANY_EVENT : 0;\n          win_update_mouse();\n        when 1004: /* FOCUS_EVENT_MOUSE */\n          term.report_focus = state;\n        when 1005: /* Xterm's UTF8 encoding for mouse positions */\n          term.mouse_enc = state ? ME_UTF8 : 0;\n        when 1006: /* Xterm's CSI-style mouse encoding */\n          term.mouse_enc = state ? ME_XTERM_CSI : 0;\n        when 1016: /* Xterm's CSI-style mouse encoding with pixel resolution */\n          term.mouse_enc = state ? ME_PIXEL_CSI : 0;\n        when 1015: /* Urxvt's CSI-style mouse encoding */\n          term.mouse_enc = state ? ME_URXVT_CSI : 0;\n        when 1037:\n          term.delete_sends_del = state;\n        when 1042:\n          term.bell_taskbar = state;\n        when 1043:\n          term.bell_popup = state;\n        when 47: /* alternate screen */\n          if (!cfg.disable_alternate_screen) {\n            term.selected = false;\n            term_switch_screen(state, false);\n            term.disptop = 0;\n          }\n        when 1047:       /* alternate screen */\n          if (!cfg.disable_alternate_screen) {\n            term.selected = false;\n            term_switch_screen(state, true);\n            term.disptop = 0;\n          }\n        when 1046:       /* enable/disable alternate screen switching */\n          if (term.on_alt_screen && !state)\n            term_switch_screen(false, false);\n          cfg.disable_alternate_screen = !state;\n        when 1048:       /* save/restore cursor */\n          if (!cfg.disable_alternate_screen) {\n            if (state)\n              save_cursor();\n            else\n              restore_cursor();\n          }\n        when 1049:       /* cursor & alternate screen */\n          if (!cfg.disable_alternate_screen) {\n            if (state)\n              save_cursor();\n            term.selected = false;\n            term_switch_screen(state, true);\n            if (!state)\n              restore_cursor();\n            term.disptop = 0;\n          }\n        when 1061:       /* VT220 keyboard emulation */\n          term.vt220_keys = state;\n        when 2004:       /* xterm bracketed paste mode */\n          term.bracketed_paste = state;\n\n        /* Mintty private modes */\n        when 7700:       /* CJK ambigous width reporting */\n          term.report_ambig_width = state;\n        when 7711:       /* Scroll marker in current line */\n          if (state)\n            term.lines[term.curs.y]->lattr |= LATTR_MARKED;\n          else\n            term.lines[term.curs.y]->lattr |= LATTR_UNMARKED;\n        when 7727:       /* Application escape key mode */\n          term.app_escape_key = state;\n        when 7728:       /* Escape sends FS (instead of ESC) */\n          term.escape_sends_fs = state;\n        when 7730:       /* Sixel scrolling end position */\n          /* on: sixel scrolling moves cursor to beginning of the line\n             off(default): sixel scrolling moves cursor to left of graphics */\n          term.sixel_scrolls_left = state;\n        when 7766:       /* 'B': Show/hide scrollbar (if enabled in config) */\n          if (cfg.scrollbar && state != term.show_scrollbar) {\n            term.show_scrollbar = state;\n            win_update_scrollbar(true);\n          }\n        when 7767:       /* 'C': Changed font reporting */\n          term.report_font_changed = state;\n        when 7783:       /* 'S': Shortcut override */\n          term.shortcut_override = state;\n        when 1007:       /* Alternate Scroll Mode, xterm */\n          term.wheel_reporting_xterm = state;\n        when 7786:       /* 'V': Mousewheel reporting */\n          term.wheel_reporting = state;\n        when 7787:       /* 'W': Application mousewheel mode */\n          term.app_wheel = state;\n        when 7796:       /* Bidi disable in current line */\n          if (state)\n            term.lines[term.curs.y]->lattr |= LATTR_NOBIDI;\n          else\n            term.lines[term.curs.y]->lattr &= ~LATTR_NOBIDI;\n        when 77096:      /* Bidi disable */\n          term.disable_bidi = state;\n        when 8452:       /* Sixel scrolling end position right */\n          /* on: sixel scrolling leaves cursor to right of graphic\n             off(default): position after sixel depends on sixel_scrolls_left */\n          term.sixel_scrolls_right = state;\n        when 77000 ... 77031: { /* Application control key modes */\n          int ctrl = arg - 77000;\n          term.app_control = (term.app_control & ~(1 << ctrl)) | (state << ctrl);\n        }\n        when 2500: /* bidi box graphics mirroring */\n          if (state)\n            term.curs.bidimode |= LATTR_BOXMIRROR;\n          else\n            term.curs.bidimode &= ~LATTR_BOXMIRROR;\n        when 2501: /* bidi direction auto-detection */\n          if (state)\n            term.curs.bidimode &= ~LATTR_BIDISEL;\n          else\n            term.curs.bidimode |= LATTR_BIDISEL;\n      }\n    }\n    else { /* SM/RM: set/reset mode */\n      switch (arg) {\n        when 4:  /* IRM: set insert mode */\n          term.insert = state;\n        when 8: /* BDSM: ECMA-48 bidirectional support mode */\n          if (state)\n            term.curs.bidimode &= ~LATTR_NOBIDI;\n          else\n            term.curs.bidimode |= LATTR_NOBIDI;\n        when 12: /* SRM: set echo mode */\n          term.echoing = !state;\n        when 20: /* LNM: Return sends ... */\n          term.newline_mode = state;\n#ifdef support_Wyse_cursor_modes\n        when 33: /* WYSTCURM: steady Wyse cursor */\n          term.cursor_blinkmode = !state;\n          term.cursor_invalid = true;\n          term_schedule_cblink();\n        when 34: /* WYULCURM: Wyse underline cursor */\n          term.cursor_type = state;\n          term.cursor_blinkmode = false;\n          term.cursor_invalid = true;\n          term_schedule_cblink();\n#endif\n      }\n    }\n  }\n}\n\n/*\n * Get terminal mode.\n            0 - not recognized\n            1 - set\n            2 - reset\n            3 - permanently set\n            4 - permanently reset\n */\nstatic int\nget_mode(bool privatemode, int arg)\n{\n  if (privatemode) { /* DECRQM for DECSET/DECRST: DEC private mode */\n    switch (arg) {\n      when 1:  /* DECCKM: application cursor keys */\n        return 2 - term.app_cursor_keys;\n      when 66:  /* DECNKM: application keypad */\n        return 2 - term.app_keypad;\n      when 2:  /* DECANM: VT100/VT52 mode */\n        // Check USASCII for character sets G0-G3\n        for (uint i = 0; i < lengthof(term.curs.csets); i++)\n          if (term.curs.csets[i] != CSET_ASCII)\n            return 2;\n        return 1;\n      when 3:  /* DECCOLM: 80/132 columns */\n        return 2 - term.reset_132;\n      when 5:  /* DECSCNM: reverse video */\n        return 2 - term.rvideo;\n      when 6:  /* DECOM: DEC origin mode */\n        return 2 - term.curs.origin;\n      when 7:  /* DECAWM: auto wrap */\n        return 2 - term.autowrap;\n      when 45:  /* xterm: reverse (auto) wraparound */\n        return 2 - term.rev_wrap;\n      when 8:  /* DECARM: auto key repeat */\n        return 2 - term.auto_repeat;\n        //return 3; // ignored\n      when 9:  /* X10_MOUSE */\n        return 2 - (term.mouse_mode == MM_X10);\n      when 12: /* AT&T 610 blinking cursor */\n        return 2 - term.cursor_blinkmode;\n      when 25: /* DECTCEM: enable/disable cursor */\n        return 2 - term.cursor_on;\n      when 30: /* Show/hide scrollbar */\n        return 2 - term.show_scrollbar;\n      when 40: /* Allow/disallow DECCOLM (xterm c132 resource) */\n        return 2 - term.deccolm_allowed;\n      when 42: /* DECNRCM: national replacement character sets */\n        return 2 - term.decnrc_enabled;\n      when 44: /* margin bell (xterm) */\n        return 2 - term.margin_bell;\n      when 67: /* DECBKM: backarrow key mode */\n        return 2 - term.backspace_sends_bs;\n      when 69: /* DECLRMM: enable left and right margin mode DECSLRM */\n        return 2 - term.lrmargmode;\n      when 80: /* DECSDM: SIXEL display mode */\n        return 2 - !term.sixel_display;\n      when 1000: /* VT200_MOUSE */\n        return 2 - (term.mouse_mode == MM_VT200);\n      when 1002: /* BTN_EVENT_MOUSE */\n        return 2 - (term.mouse_mode == MM_BTN_EVENT);\n      when 1003: /* ANY_EVENT_MOUSE */\n        return 2 - (term.mouse_mode == MM_ANY_EVENT);\n      when 1004: /* FOCUS_EVENT_MOUSE */\n        return 2 - term.report_focus;\n      when 1005: /* Xterm's UTF8 encoding for mouse positions */\n        return 2 - (term.mouse_enc == ME_UTF8);\n      when 1006: /* Xterm's CSI-style mouse encoding */\n        return 2 - (term.mouse_enc == ME_XTERM_CSI);\n      when 1016: /* Xterm's CSI-style mouse encoding with pixel resolution */\n        return 2 - (term.mouse_enc == ME_PIXEL_CSI);\n      when 1015: /* Urxvt's CSI-style mouse encoding */\n        return 2 - (term.mouse_enc == ME_URXVT_CSI);\n      when 1037:\n        return 2 - term.delete_sends_del;\n      when 1042:\n        return 2 - term.bell_taskbar;\n      when 1043:\n        return 2 - term.bell_popup;\n      when 47: /* alternate screen */\n        return 2 - term.on_alt_screen;\n      when 1047:       /* alternate screen */\n        return 2 - term.on_alt_screen;\n      when 1048:       /* save/restore cursor */\n        return 4;\n      when 1049:       /* cursor & alternate screen */\n        return 2 - term.on_alt_screen;\n      when 1061:       /* VT220 keyboard emulation */\n        return 2 - term.vt220_keys;\n      when 2004:       /* xterm bracketed paste mode */\n        return 2 - term.bracketed_paste;\n\n      /* Mintty private modes */\n      when 7700:       /* CJK ambigous width reporting */\n        return 2 - term.report_ambig_width;\n      when 7711:       /* Scroll marker in current line */\n        return 2 - !!(term.lines[term.curs.y]->lattr & LATTR_MARKED);\n      when 7727:       /* Application escape key mode */\n        return 2 - term.app_escape_key;\n      when 7728:       /* Escape sends FS (instead of ESC) */\n        return 2 - term.escape_sends_fs;\n      when 7730:       /* Sixel scrolling end position */\n        return 2 - term.sixel_scrolls_left;\n      when 7766:       /* 'B': Show/hide scrollbar (if enabled in config) */\n        return 2 - term.show_scrollbar;\n      when 7767:       /* 'C': Changed font reporting */\n        return 2 - term.report_font_changed;\n      when 7783:       /* 'S': Shortcut override */\n        return 2 - term.shortcut_override;\n      when 1007:       /* Alternate Scroll Mode, xterm */\n        return 2 - term.wheel_reporting_xterm;\n      when 7786:       /* 'V': Mousewheel reporting */\n        return 2 - term.wheel_reporting;\n      when 7787:       /* 'W': Application mousewheel mode */\n        return 2 - term.app_wheel;\n      when 7796:       /* Bidi disable in current line */\n        return 2 - !!(term.lines[term.curs.y]->lattr & LATTR_NOBIDI);\n      when 77096:      /* Bidi disable */\n        return 2 - term.disable_bidi;\n      when 8452:       /* Sixel scrolling end position right */\n        return 2 - term.sixel_scrolls_right;\n      when 77000 ... 77031: { /* Application control key modes */\n        int ctrl = arg - 77000;\n        return 2 - !!(term.app_control & (1 << ctrl));\n      }\n      when 2500: /* bidi box graphics mirroring */\n        return 2 - !!(term.curs.bidimode & LATTR_BOXMIRROR);\n      when 2501: /* bidi direction auto-detection */\n        return 2 - !(term.curs.bidimode & LATTR_BIDISEL);\n      otherwise:\n        return 0;\n    }\n  }\n  else { /* DECRQM for SM/RM: mode */\n    switch (arg) {\n      when 4:  /* IRM: insert mode */\n        return 2 - term.insert;\n      when 8: /* BDSM: bidirectional support mode */\n        return 2 - !(term.curs.bidimode & LATTR_NOBIDI);\n      when 12: /* SRM: echo mode */\n        return 2 - !term.echoing;\n      when 20: /* LNM: Return sends ... */\n        return 2 - term.newline_mode;\n#ifdef support_Wyse_cursor_modes\n      when 33: /* WYSTCURM: steady Wyse cursor */\n        return 2 - (!term.cursor_blinkmode);\n      when 34: /* WYULCURM: Wyse underline cursor */\n        if (term.cursor_type <= 1)\n          return 2 - (term.cursor_type == 1);\n        else\n          return 0;\n#endif\n      otherwise:\n        return 0;\n    }\n  }\n}\n\nstruct mode_entry {\n  int mode, val;\n};\nstatic struct mode_entry * mode_stack = 0;\nstatic int mode_stack_len = 0;\n\nstatic void\npush_mode(int mode, int val)\n{\n  struct mode_entry * new_stack = renewn(mode_stack, mode_stack_len + 1);\n  if (new_stack) {\n    mode_stack = new_stack;\n    mode_stack[mode_stack_len].mode = mode;\n    mode_stack[mode_stack_len].val = val;\n    mode_stack_len++;\n  }\n}\n\nstatic int\npop_mode(int mode)\n{\n  for (int i = mode_stack_len - 1; i >= 0; i--)\n    if (mode_stack[i].mode == mode) {\n      int val = mode_stack[i].val;\n      mode_stack_len--;\n      for (int j = i; j < mode_stack_len; j++)\n        mode_stack[j] = mode_stack[j + 1];\n      struct mode_entry * new_stack = renewn(mode_stack, mode_stack_len);\n      if (new_stack)\n        mode_stack = new_stack;\n      return val;\n    }\n  return -1;\n}\n\nstruct cattr_entry {\n  cattr ca;\n  cattrflags mask;\n};\nstatic struct cattr_entry cattr_stack[10];\nstatic int cattr_stack_len = 0;\n\nstatic void\npush_attrs(cattr ca, cattrflags caflagsmask)\n{\n  if (cattr_stack_len == lengthof(cattr_stack)) {\n    for (int i = 1; i < cattr_stack_len; i++)\n      cattr_stack[i - 1] = cattr_stack[i];\n    cattr_stack_len--;\n  }\n  //printf(\"push_attrs[%d] %llX\\n\", cattr_stack_len, caflagsmask);\n  cattr_stack[cattr_stack_len].ca = ca;\n  cattr_stack[cattr_stack_len].mask = caflagsmask;\n  cattr_stack_len++;\n}\n\nstatic bool\npop_attrs(cattr * _ca, cattrflags * _caflagsmask)\n{\n  if (!cattr_stack_len)\n    return false;\n  cattr_stack_len--;\n  //printf(\"pop_attrs[%d] %llX\\n\", cattr_stack_len, cattr_stack[cattr_stack_len].mask);\n  *_ca = cattr_stack[cattr_stack_len].ca;\n  *_caflagsmask = cattr_stack[cattr_stack_len].mask;\n  return true;\n}\n\nstatic COLORREF * colours_stack[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nstatic int colours_cur = 0;\nstatic int colours_num = 0;\n\nstatic void\npush_colours(uint ix)\n{\n  if (ix > 10)\n    return;\n\n  if (ix) {  // store\n    colours_cur = ix;\n    ix--;\n  }\n  else {  // push\n    if (colours_cur < 10) {\n      ix = colours_cur;\n      colours_cur++;\n    }\n    else\n      return;\n  }\n  //printf(\"push %d\\n\", ix);\n\n  if (!colours_stack[ix]) {\n    colours_stack[ix] = malloc(COLOUR_NUM * sizeof(COLORREF));\n    if (colours_stack[ix])\n      colours_num++;\n  }\n  if (colours_stack[ix])\n    memcpy(colours_stack[ix], colours, COLOUR_NUM * sizeof(COLORREF));\n}\n\nstatic void\npop_colours(uint ix)\n{\n  if (ix > 10)\n    return;\n\n  if (ix) {  // retrieve\n    colours_cur = ix;\n    ix--;\n  }\n  else {  // pop\n    if (colours_cur) {\n      colours_cur--;\n      ix = colours_cur;\n    }\n    else\n      return;\n  }\n  //printf(\"pop %d\\n\", ix);\n\n  if (colours_stack[ix])\n    memcpy(colours, colours_stack[ix], COLOUR_NUM * sizeof(COLORREF));\n}\n\n/*\n * dtterm window operations and xterm extensions.\n   CSI Ps ; Ps ; Ps t\n */\nstatic void\ndo_winop(void)\n{\n  int arg1 = term.csi_argv[1], arg2 = term.csi_argv[2];\n  if (*cfg.suppress_win && contains(cfg.suppress_win, term.csi_argv[0]))\n    // skip suppressed window operation\n    return;\n  switch (term.csi_argv[0]) {\n    when 1: win_set_iconic(false);\n    when 2: win_set_iconic(true);\n    when 3: win_set_pos(arg1, arg2);\n    when 4: win_set_pixels(arg1, arg2);\n    when 5:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(true);  // top\n    when 6:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(false); // bottom\n    when 7: win_invalidate_all(false);  // refresh\n    when 8: {\n      int def1 = term.csi_argv_defined[1], def2 = term.csi_argv_defined[2];\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      win_set_chars(arg1 ?: def1 ? rows : term.rows, arg2 ?: def2 ? cols : term.cols);\n    }\n    when 9: {\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 9 ; 0  -> Restore maximized window.\n      // Ps = 9 ; 1  -> Maximize window (i.e., resize to screen size).\n      // Ps = 9 ; 2  -> Maximize window vertically.\n      // Ps = 9 ; 3  -> Maximize window horizontally.\n      int rows0 = term.rows0, cols0 = term.cols0;\n      if (arg1 == 2) {\n        // maximize window vertically\n        win_set_geom(0, -1, 0, -1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 3) {\n        // maximize window horizontally\n        win_set_geom(-1, 0, -1, 0);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 1) {\n        win_maximise(1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 0) {\n        win_maximise(0);\n        win_set_chars(rows0, cols0);\n      }\n    }\n    when 10:\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 1 0 ; 0  -> Undo full-screen mode.\n      // Ps = 1 0 ; 1  -> Change to full-screen.\n      // Ps = 1 0 ; 2  -> Toggle full-screen.\n      if (arg1 == 2)\n        win_maximise(-2);\n      else if (arg1 == 1 || arg1 == 0)\n        win_maximise(arg1 ? 2 : 0);\n    when 11: child_write(win_is_iconic() ? \"\\e[2t\" : \"\\e[1t\", 4);\n    when 13: {\n      int x, y;\n      win_get_scrpos(&x, &y, arg1 == 2);\n      child_printf(\"\\e[3;%u;%ut\", (ushort)x, (ushort)y);\n    }\n    when 14: {\n      int height, width;\n      win_get_pixels(&height, &width, arg1 == 2);\n      child_printf(\"\\e[4;%d;%dt\", height, width);\n    }\n    when 15: {\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[5;%d;%dt\", h, w);\n    }\n    when 16: child_printf(\"\\e[6;%d;%dt\", cell_height, cell_width);\n    when 18: child_printf(\"\\e[8;%d;%dt\", term.rows, term.cols);\n    when 19: {\n#ifdef size_of_monitor_only\n#warning not what xterm reports\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      child_printf(\"\\e[9;%d;%dt\", rows, cols);\n#else\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[9;%d;%dt\", h / cell_height, w / cell_width);\n#endif\n    }\n    when 22:\n      if (arg1 == 0 || arg1 == 2)\n        win_save_title();\n    when 23:\n      if (arg1 == 0 || arg1 == 2)\n        win_restore_title();\n  }\n}\n\nstatic void\nset_taskbar_progress(int state, int percent)\n{\n  if (state == 0) {  // disable progress indication\n    taskbar_progress(-9);\n    term.detect_progress = 0;\n  }\n  else if (state == 8) {  // \"busy\"\n    taskbar_progress(-8);\n    term.detect_progress = 0;\n  }\n  else if (state <= 3) {\n    taskbar_progress(- state);\n    if (percent >= 0) {\n      taskbar_progress(percent);\n      term.detect_progress = 0;\n    }\n    else  // enable automatic progress detection\n      term.detect_progress = state;\n  }\n}\n\nstatic void\ndo_csi(uchar c)\n{\n  term_cursor *curs = &term.curs;\n  int arg0 = term.csi_argv[0], arg1 = term.csi_argv[1];\n  if (arg0 < 0)\n    arg0 = 0;\n  if (arg1 < 0)\n    arg1 = 0;\n  int arg0_def1 = arg0 ?: 1;  // first arg with default 1\n\n  // DECRQM quirk\n  if (term.esc_mod == 0xFF && esc_mod0 == '?' && esc_mod1 == '$' && c == 'p')\n    term.esc_mod = '$';\n\n  switch (CPAIR(term.esc_mod, c)) {\n    when CPAIR('!', 'p'):     /* DECSTR: soft terminal reset */\n      term_reset(false);\n    when 'b': {      /* REP: repeat preceding character */\n      cattr cur_attr = term.curs.attr;\n      term.curs.attr = last_attr;\n      wchar h = last_high, c = last_char;\n      for (int i = 0; i < arg0_def1; i++)\n        write_ucschar(h, c, last_width);\n      term.curs.attr = cur_attr;\n    }\n    when 'A':        /* CUU: move up N lines */\n      move(curs->x, curs->y - arg0_def1, 1);\n    when 'e':        /* VPR: move down N lines */\n      move(curs->x, curs->y + arg0_def1, 1);\n    when 'B':        /* CUD: Cursor down */\n      move(curs->x, curs->y + arg0_def1, 1);\n    when 'c':        /* Primary DA: report device/terminal type */\n      if (!arg0)\n        write_primary_da();\n    when CPAIR('>', 'c'):     /* Secondary DA: report device version */\n      if (!arg0) {\n        if (cfg.charwidth % 10)\n          child_printf(\"\\e[>77;%u;%uc\", DECIMAL_VERSION, UNICODE_VERSION);\n        else\n          child_printf(\"\\e[>77;%u;0c\", DECIMAL_VERSION);\n      }\n    when CPAIR('>', 'q'):     /* Report terminal name and version */\n      if (!arg0)\n        child_printf(\"\\eP>|%s %s\\e\\\\\", APPNAME, VERSION);\n    when 'a':        /* HPR: move right N cols */\n      move(curs->x + arg0_def1, curs->y, 1);\n    when 'C':        /* CUF: Cursor right */\n      move(curs->x + arg0_def1, curs->y, 1);\n    when 'D':        /* CUB: move left N cols */\n      if (arg0_def1 > curs->x) {\n        arg0_def1 -= curs->x + 1;\n        move(0, curs->y, 1);\n        write_backspace();\n        move(curs->x - arg0_def1, curs->y, 1);\n      }\n      else\n        move(curs->x - arg0_def1, curs->y, 1);\n      enable_progress();\n    when 'E':        /* CNL: move down N lines and CR */\n      move(0, curs->y + arg0_def1, 1);\n    when 'F':        /* CPL: move up N lines and CR */\n      move(0, curs->y - arg0_def1, 1);\n    when 'G' or '`': { /* CHA or HPA: set horizontal position */\n      short x = (curs->origin ? term.marg_left : 0) + arg0_def1 - 1;\n      if (x < curs->x)\n        enable_progress();\n      move(x, curs->y, curs->origin ? 2 : 0);\n    }\n    when 'd':        /* VPA: set vertical position */\n      move(curs->x,\n           (curs->origin ? term.marg_top : 0) + arg0_def1 - 1,\n           curs->origin ? 2 : 0);\n    when 'H' or 'f':  /* CUP or HVP: set horiz. and vert. positions at once */\n      move((curs->origin ? term.marg_left : 0) + (arg1 ?: 1) - 1,\n           (curs->origin ? term.marg_top : 0) + arg0_def1 - 1,\n           curs->origin ? 2 : 0);\n    when 'I':  /* CHT: move right N TABs */\n      for (int i = 0; i < arg0_def1; i++)\n        write_tab();\n    when 'J' or CPAIR('?', 'J'):  /* ED/DECSED: (selective) erase in display */\n      if (arg0 == 3) { /* Erase Saved Lines (xterm) */\n        // don't care if (term.esc_mod) // ignore selective\n        term_clear_scrollback();\n        term.disptop = 0;\n      }\n      else if (arg0 <= 2) {\n        bool above = arg0 == 1 || arg0 == 2;\n        bool below = arg0 == 0 || arg0 == 2;\n        term_erase(term.esc_mod, false, above, below);\n      }\n    when 'K' or CPAIR('?', 'K'):  /* EL/DECSEL: (selective) erase in line */\n      if (arg0 <= 2) {\n        bool right = arg0 == 0 || arg0 == 2;\n        bool left  = arg0 == 1 || arg0 == 2;\n        term_erase(term.esc_mod, true, left, right);\n      }\n    when 'L':        /* IL: insert lines */\n      if (curs->y >= term.marg_top && curs->y <= term.marg_bot\n       && curs->x >= term.marg_left && curs->x <= term.marg_right\n         )\n      {\n        term_do_scroll(curs->y, term.marg_bot, -arg0_def1, false);\n        curs->x = term.marg_left;\n      }\n    when 'M':        /* DL: delete lines */\n      if (curs->y >= term.marg_top && curs->y <= term.marg_bot\n       && curs->x >= term.marg_left && curs->x <= term.marg_right\n         )\n      {\n        term_do_scroll(curs->y, term.marg_bot, arg0_def1, true);\n        curs->x = term.marg_left;\n      }\n    when '@':        /* ICH: insert chars */\n      insert_char(arg0_def1);\n    when 'P':        /* DCH: delete chars */\n      insert_char(-arg0_def1);\n    when 'h' or CPAIR('?', 'h'):  /* SM/DECSET: set (private) modes */\n      set_modes(true);\n    when 'l' or CPAIR('?', 'l'):  /* RM/DECRST: reset (private) modes */\n      set_modes(false);\n    when CPAIR('?', 's'): { /* Save DEC Private Mode (DECSET) values */\n      int arg = term.csi_argv[0];\n      int val = get_mode(true, arg);\n      if (val)\n        push_mode(arg, val);\n    }\n    when CPAIR('?', 'r'): { /* Restore DEC Private Mode (DECSET) values */\n      int arg = term.csi_argv[0];\n      int val = pop_mode(arg);\n      if (val >= 0) {\n        term.csi_argc = 1;\n        set_modes(val & 1);\n      }\n    }\n    when CPAIR('#', '{') or CPAIR('#', 'p'): { /* Push video attributes onto stack (XTPUSHSGR) */\n      cattr ca = term.curs.attr;\n      cattrflags caflagsmask = 0;\n\n      void set_push(int attr) {\n        switch (attr) {\n          when 1: caflagsmask |= ATTR_BOLD | ATTR_SHADOW;\n          when 2: caflagsmask |= ATTR_DIM;\n          when 3: caflagsmask |= ATTR_ITALIC;\n          when 4 or 21: caflagsmask |= UNDER_MASK;\n          when 5 or 6: caflagsmask |= ATTR_BLINK | ATTR_BLINK2;\n          when 7: caflagsmask |= ATTR_REVERSE;\n          when 8: caflagsmask |= ATTR_INVISIBLE | ATTR_OVERSTRIKE;\n          when 9: caflagsmask |= ATTR_STRIKEOUT;\n          when 20: caflagsmask |= FONTFAM_MASK;\n          when 53: caflagsmask |= ATTR_OVERL;\n          when 58: caflagsmask |= ATTR_ULCOLOUR;\n          when 30 or 10: caflagsmask |= ATTR_FGMASK;\n          when 31 or 11: caflagsmask |= ATTR_BGMASK;\n          when 73: caflagsmask |= ATTR_SUPERSCR;\n          when 74: caflagsmask |= ATTR_SUBSCR;\n        }\n      }\n\n      if (!term.csi_argv_defined[0])\n        for (int a = 1; a < 90; a++)\n          set_push(a);\n      else\n        for (uint i = 0; i < term.csi_argc; i++) {\n          //printf(\"XTPUSHSGR[%d] %d\\n\", i, term.csi_argv[i]);\n          set_push(term.csi_argv[i]);\n        }\n      if ((ca.attr & caflagsmask & ATTR_FGMASK) != TRUE_COLOUR)\n        ca.truefg = 0;\n      if ((ca.attr & caflagsmask & ATTR_BGMASK) != TRUE_COLOUR << ATTR_BGSHIFT)\n        ca.truebg = 0;\n      if (!(caflagsmask & ATTR_ULCOLOUR))\n        ca.ulcolr = (colour)-1;\n      // push\n      //printf(\"XTPUSHSGR &%llX %llX %06X %06X %06X\\n\", caflagsmask, ca.attr, ca.truefg, ca.truebg, ca.ulcolr);\n      push_attrs(ca, caflagsmask);\n    }\n    when CPAIR('#', '}') or CPAIR('#', 'q'): { /* Pop video attributes from stack (XTPOPSGR) */\n      //printf(\"XTPOPSGR\\n\");\n      // pop\n      cattr ca;\n      cattrflags caflagsmask;\n      if (pop_attrs(&ca, &caflagsmask)) {\n        //printf(\"XTPOPSGR &%llX %llX %06X %06X %06X\\n\", caflagsmask, ca.attr, ca.truefg, ca.truebg, ca.ulcolr);\n        // merge\n        term.curs.attr.attr = (term.curs.attr.attr & ~caflagsmask)\n                              | (ca.attr & caflagsmask);\n        if ((ca.attr & caflagsmask & ATTR_FGMASK) == TRUE_COLOUR)\n          term.curs.attr.truefg = ca.truefg;\n        if ((ca.attr & caflagsmask & ATTR_BGMASK) == TRUE_COLOUR << ATTR_BGSHIFT)\n          term.curs.attr.truebg = ca.truebg;\n        if (caflagsmask & ATTR_ULCOLOUR)\n          term.curs.attr.ulcolr = ca.ulcolr;\n      }\n    }\n    when CPAIR('#', 'P'):  /* Push dynamic colours onto stack (XTPUSHCOLORS) */\n      push_colours(arg0);\n    when CPAIR('#', 'Q'):  /* Pop dynamic colours from stack (XTPOPCOLORS) */\n      pop_colours(arg0);\n      win_invalidate_all(false);  // refresh\n    when CPAIR('#', 'R'):  /* Report colours stack entry (XTREPORTCOLORS) */\n      child_printf(\"\\e[?%d;%d#Q\", colours_cur, colours_num);\n    when CPAIR('$', 'p'): { /* DECRQM: request (private) mode */\n      int arg = term.csi_argv[0];\n      child_printf(\"\\e[%s%u;%u$y\",\n                   esc_mod0 ? \"?\" : \"\",\n                   arg,\n                   get_mode(esc_mod0, arg));\n    }\n    when 'i' or CPAIR('?', 'i'):  /* MC: Media copy */\n      if (arg0 == 5 && *cfg.printer) {\n        term.printing = true;\n        term.only_printing = !term.esc_mod;\n        term.print_state = 0;\n        if (*cfg.printer == '*')\n          printer_start_job(printer_get_default());\n        else\n          printer_start_job(cfg.printer);\n      }\n      else if (arg0 == 4 && term.printing) {\n        // Drop escape sequence from print buffer and finish printing.\n        while (term.printbuf[--term.printbuf_pos] != '\\e');\n        term_print_finish();\n      }\n      else if (arg0 == 10 && !term.esc_mod) {\n        term_export_html(false);\n      }\n#ifdef support_SVG\n      else if (arg0 == 11 && !term.esc_mod) {\n        term_export_svg();\n      }\n#endif\n      else if (arg0 == 12 && !term.esc_mod) {\n        term_save_image();\n      }\n      else if (arg0 == 0 && !term.esc_mod) {\n        print_screen();\n      }\n    when 'g':        /* TBC: clear tabs */\n      if (!arg0)\n        term.tabs[curs->x] = false;\n      else if (arg0 == 3) {\n        for (int i = 0; i < term.cols; i++)\n          term.tabs[i] = false;\n        term.newtab = 0;  // don't set new default tabs on resize\n      }\n    when 'r': {      /* DECSTBM: set scrolling region */\n      int top = arg0_def1 - 1;\n      int bot = (arg1 ? min(arg1, term.rows) : term.rows) - 1;\n      if (bot > top) {\n        term.marg_top = top;\n        term.marg_bot = bot;\n        curs->x = curs->origin ? term.marg_left : 0;\n        curs->y = curs->origin ? term.marg_top : 0;\n      }\n    }\n    when 's':\n      if (term.lrmargmode) {  /* DECSLRM: set left and right margin */\n        int left = arg0_def1 - 1;\n        int right = (arg1 ? min(arg1, term.cols) : term.cols) - 1;\n        if (right > left) {\n          term.marg_left = left;\n          term.marg_right = right;\n          curs->x = curs->origin ? term.marg_left : 0;\n          curs->y = curs->origin ? term.marg_top : 0;\n        }\n      }\n      else           /* SCOSC: save cursor */\n        save_cursor();\n    when 'u':        /* SCORC: restore cursor */\n      restore_cursor();\n    when 'm':        /* SGR: set graphics rendition */\n      do_sgr();\n    when 't':\n     /*\n      * VT340/VT420 sequence DECSLPP, for setting the height of the window.\n      * DEC only allowed values 24/25/36/48/72/144, so dtterm and xterm\n      * claimed values below 24 for various window operations, \n      * and also allowed any number of rows from 24 and above to be set.\n      */\n      if (arg0 >= 24) {  /* DECSLPP: set page size - ie window height */\n        if (*cfg.suppress_win && contains(cfg.suppress_win, 24))\n          ; // skip suppressed window operation\n        else {\n          win_set_chars(arg0, term.cols);\n          term.selected = false;\n        }\n      }\n      else\n        do_winop();\n    when 'S':        /* SU: Scroll up */\n      term_do_scroll(term.marg_top, term.marg_bot, arg0_def1, true);\n      curs->wrapnext = false;\n    when 'T':        /* SD: Scroll down */\n      /* Avoid clash with unsupported hilight mouse tracking mode sequence */\n      if (term.csi_argc <= 1) {\n        term_do_scroll(term.marg_top, term.marg_bot, -arg0_def1, true);\n        curs->wrapnext = false;\n      }\n    when CPAIR('*', '|'):     /* DECSNLS */\n     /*\n      * Set number of lines on screen\n      * VT420 uses VGA like hardware and can support any size \n      * in reasonable range (24..49 AIUI) with no default specified.\n      */\n      win_set_chars(arg0 ?: cfg.rows, term.cols);\n      term.selected = false;\n    when CPAIR('$', '|'):     /* DECSCPP */\n     /*\n      * Set number of columns per page\n      * Docs imply range is only 80 or 132, but I'll allow any.\n      */\n      win_set_chars(term.rows, arg0 ?: cfg.cols);\n      term.selected = false;\n    when 'X': {      /* ECH: write N spaces w/o moving cursor */\n      termline *line = term.lines[curs->y];\n      int cols = min(line->cols, line->size);\n      int n = min(arg0_def1, cols - curs->x);\n      if (n > 0) {\n        int p = curs->x;\n        term_check_boundary(curs->x, curs->y);\n        term_check_boundary(curs->x + n, curs->y);\n        while (n--)\n          line->chars[p++] = term.erase_char;\n      }\n    }\n    when 'x':        /* DECREQTPARM: report terminal characteristics */\n      if (arg0 <= 1)\n        child_printf(\"\\e[%u;1;1;120;120;1;0x\", arg0 + 2);\n    when 'Z': {      /* CBT (Cursor Backward Tabulation) */\n      int n = arg0_def1;\n      while (--n >= 0 && curs->x > 0) {\n        do\n          curs->x--;\n        while (curs->x > 0 && !term.tabs[curs->x]);\n      }\n      enable_progress();\n    }\n    when CPAIR('$', 'w'):     /* DECTABSR: tab stop report */\n      if (arg0 == 2) {\n        child_printf(\"\\eP2$\");\n        char sep = 'u';\n        for (int i = 0; i < term.cols; i++)\n          if (term.tabs[i]) {\n            child_printf(\"%c%d\", sep, i + 1);\n            sep = '/';\n          }\n        child_printf(\"\\e\\\\\");\n      }\n    when CPAIR('>', 'm'):     /* xterm: modifier key setting */\n      /* only the modifyOtherKeys setting is implemented */\n      if (!arg0)\n        term.modify_other_keys = 0;\n      else if (arg0 == 4)\n        term.modify_other_keys = arg1;\n    when CPAIR('>', 'p'):     /* xterm: pointerMode */\n      if (arg0 == 0)\n        term.hide_mouse = false;\n      else if (arg0 == 2)\n        term.hide_mouse = true;\n    when CPAIR('>', 'n'):     /* xterm: modifier key setting */\n      /* only the modifyOtherKeys setting is implemented */\n      if (arg0 == 4)\n        term.modify_other_keys = 0;\n    when CPAIR(' ', 'q'):     /* DECSCUSR: set cursor style */\n      term.cursor_type = arg0 ? (arg0 - 1) / 2 : -1;\n      term.cursor_blinks = arg0 ? arg0 % 2 : -1;\n      if (term.cursor_blinks)\n        term.cursor_blink_interval = arg1;\n      term.cursor_invalid = true;\n      term_schedule_cblink();\n    when CPAIR('?', 'c'):  /* Cursor size (Linux console) */\n      term.cursor_size = arg0;\n    when CPAIR('\"', 'q'):  /* DECSCA: select character protection attribute */\n      switch (arg0) {\n        when 0 or 2: term.curs.attr.attr &= ~ATTR_PROTECTED;\n        when 1: term.curs.attr.attr |= ATTR_PROTECTED;\n      }\n    when 'n':        /* DSR: device status report */\n      if (arg0 == 6)  // CPR\n        child_printf(\"\\e[%d;%dR\",\n                     curs->y + 1 - (curs->origin ? term.marg_top : 0),\n                     curs->x + 1 - (curs->origin ? term.marg_left : 0));\n      else if (arg0 == 5)\n        child_write(\"\\e[0n\", 4);\n    when CPAIR('?', 'n'):  /* DSR, DEC specific */\n      switch (arg0) {\n        when 6:  // DECXCPR\n          child_printf(\"\\e[?%d;%dR\",  // VT420: third parameter \"page\"...\n                       curs->y + 1 - (curs->origin ? term.marg_top : 0),\n                       curs->x + 1 - (curs->origin ? term.marg_left : 0));\n        when 15:\n          child_printf(\"\\e[?%un\", 11 - !!*cfg.printer);\n        // DEC Locator\n        when 53 or 55:\n          child_printf(\"\\e[?53n\");\n        when 56:\n          child_printf(\"\\e[?57;1n\");\n      }\n    // DEC Locator\n    when CPAIR('\\'', 'z'): {  /* DECELR: enable locator reporting */\n      switch (arg0) {\n        when 0:\n          if (term.mouse_mode == MM_LOCATOR) {\n            term.mouse_mode = 0;\n            win_update_mouse();\n          }\n          term.locator_1_enabled = false;\n        when 1:\n          term.mouse_mode = MM_LOCATOR;\n          win_update_mouse();\n        when 2:\n          term.locator_1_enabled = true;\n          win_update_mouse();\n      }\n      switch (arg1) {\n        when 0 or 2:\n          term.locator_by_pixels = false;\n        when 1:\n          term.locator_by_pixels = true;\n      }\n      term.locator_rectangle = false;\n    }\n    when CPAIR('\\'', '{'): {  /* DECSLE: select locator events */\n      for (uint i = 0; i < term.csi_argc; i++)\n        switch (term.csi_argv[i]) {\n          when 0: term.locator_report_up = term.locator_report_dn = false;\n          when 1: term.locator_report_dn = true;\n          when 2: term.locator_report_dn = false;\n          when 3: term.locator_report_up = true;\n          when 4: term.locator_report_up = false;\n        }\n    }\n    when CPAIR('\\'', '|'): {  /* DECRQLP: request locator position */\n      if (term.mouse_mode == MM_LOCATOR || term.locator_1_enabled) {\n        int x, y, buttons;\n        win_get_locator_info(&x, &y, &buttons, term.locator_by_pixels);\n        child_printf(\"\\e[1;%d;%d;%d;0&w\", buttons, y, x);\n        term.locator_1_enabled = false;\n      }\n      else {\n        //child_printf(\"\\e[0&w\");  // xterm reports this if loc. compiled in\n      }\n    }\n    when CPAIR('\\'', 'w'): {  /* DECEFR: enable filter rectangle */\n      int arg2 = term.csi_argv[2], arg3 = term.csi_argv[3];\n      int x, y, buttons;\n      win_get_locator_info(&x, &y, &buttons, term.locator_by_pixels);\n      term.locator_top = arg0 ?: y;\n      term.locator_left = arg1 ?: x;\n      term.locator_bottom = arg2 ?: y;\n      term.locator_right = arg3 ?: x;\n      term.locator_rectangle = true;\n    }\n    when 'q': {  /* DECLL: load keyboard LEDs */\n      if (arg0 > 20)\n        win_led(arg0 - 20, false);\n      else if (arg0)\n        win_led(arg0, true);\n      else {\n        win_led(0, false);\n      }\n    }\n    when CPAIR(' ', 'k'):  /* SCP: ECMA-48 Set Character Path (LTR/RTL) */\n      if (arg0 <= 2) {\n        if (arg0 == 2)\n          curs->bidimode |= LATTR_BIDIRTL;\n        else if (arg0 == 1)\n          curs->bidimode &= ~LATTR_BIDIRTL;\n        else {  // default\n          curs->bidimode &= ~(LATTR_BIDISEL | LATTR_BIDIRTL);\n        }\n        // postpone propagation to line until char is written (put_char)\n        //termline *line = term.lines[curs->y];\n        //line->lattr &= ~(LATTR_BIDISEL | LATTR_BIDIRTL);\n        //line->lattr |= curs->bidimode & ~LATTR_BIDISEL | LATTR_BIDIRTL);\n      }\n    when CPAIR(' ', 'S'):  /* SPD: ECMA-48 Select Presentation Direction */\n      if (arg0 == 0)\n          curs->bidimode &= ~LATTR_PRESRTL;\n      else if (arg0 == 3)\n          curs->bidimode |= LATTR_PRESRTL;\n#define urows (uint) term.rows\n#define ucols (uint) term.cols\n    when CPAIR('$', 'v'):  /* DECCRA: VT420 Copy Rectangular Area */\n      copy_rect(arg0_def1, arg1 ?: 1, \n                term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols,\n                // skip term.csi_argv[4] (source page)\n                term.csi_argv[5] ?: urows, term.csi_argv[6] ?: ucols\n                // skip term.csi_argv[7] (destination page)\n                );\n    when CPAIR('$', 'x'):  /* DECFRA: VT420 Fill Rectangular Area */\n      fill_rect(arg0 ?: ' ', curs->attr, false,\n                arg1 ?: 1, term.csi_argv[2] ?: 1,\n                term.csi_argv[3] ?: urows, term.csi_argv[4] ?: ucols);\n    when CPAIR('$', 'z'):  /* DECERA: VT420 Erase Rectangular Area */\n      fill_rect(' ', term.erase_char.attr, false,\n                arg0_def1, arg1 ?: 1,\n                term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n    when CPAIR('$', '{'):  /* DECSERA: VT420 Selective Erase Rectangular Area */\n      fill_rect(' ', term.erase_char.attr, true,\n                arg0_def1, arg1 ?: 1,\n                term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n    when CPAIR('*', 'x'):  /* DECSACE: VT420 Select Attribute Change Extent */\n      switch (arg0) {\n        when 2: term.attr_rect = true;\n        when 0 or 1: term.attr_rect = false;\n      }\n    when CPAIR('$', 'r')  /* DECCARA: VT420 Change Attributes in Area */\n      or CPAIR('$', 't'): {  /* DECRARA: VT420 Reverse Attributes in Area */\n      cattrflags a1 = 0, a2 = 0;\n      for (uint i = 4; i < term.csi_argc; i++)\n        switch (term.csi_argv[i]) {\n          when 0: a2 = ATTR_BOLD | ATTR_UNDER | ATTR_BLINK | ATTR_REVERSE;\n          when 1: a1 |= ATTR_BOLD;\n          when 4: a1 |= ATTR_UNDER;\n          when 5: a1 |= ATTR_BLINK;\n          when 7: a1 |= ATTR_REVERSE;\n          when 22: a2 |= ATTR_BOLD;\n          when 24: a2 |= ATTR_UNDER;\n          when 25: a2 |= ATTR_BLINK;\n          when 27: a2 |= ATTR_REVERSE;\n          //when 2: a1 |= ATTR_DIM;\n          //when 3: a1 |= ATTR_ITALIC;\n          //when 6: a1 |= ATTR_BLINK2;\n          //when 8: a1 |= ATTR_INVISIBLE;\n          //when 9: a1 |= ATTR_STRIKEOUT;\n        }\n      a1 &= ~a2;\n      if (c == 'r')\n        attr_rect(a1, a2, 0, arg0_def1, arg1 ?: 1,\n                  term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n      else\n        attr_rect(0, 0, a1, arg0_def1, arg1 ?: 1,\n                  term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n    }\n    when CPAIR('*', 'y'): { /* DECRQCRA: VT420 Request Rectangular Checksum */\n      uint s = sum_rect(term.csi_argv[2] ?: 1, term.csi_argv[3] ?: 1,\n                        term.csi_argv[4] ?: urows, term.csi_argv[5] ?: ucols);\n      child_printf(\"\\eP%u!~%04X\\e\\\\\", arg0, -s & 0xFFFF);\n    }\n    when CPAIR('\\'', '}'):  /* DECIC: VT420 Insert Columns */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(curs->x, false, arg0_def1);\n    when CPAIR('\\'', '~'):  /* DECDC: VT420 Delete Columns */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(curs->x, true, arg0_def1);\n    when CPAIR(' ', 'A'):     /* SR: ECMA-48 shift columns right */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(term.marg_left, false, arg0_def1);\n    when CPAIR(' ', '@'):     /* SR: ECMA-48 shift columns left */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(term.marg_left, true, arg0_def1);\n    when CPAIR('#', 't'):  /* application scrollbar */\n      win_set_scrollview(arg0, arg1, term.csi_argc > 2 ? (int)term.csi_argv[2] : -1);\n    when CPAIR('<', 't'):  /* TTIMEST: change IME state (Tera Term) */\n      win_set_ime(arg0);\n    when CPAIR('<', 's'):  /* TTIMESV: save IME state (Tera Term) */\n      push_mode(-1, win_get_ime());\n    when CPAIR('<', 'r'):  /* TTIMERS: restore IME state (Tera Term) */\n      win_set_ime(pop_mode(-1));\n    when CPAIR(' ', 't'):     /* DECSWBV: VT520 warning bell volume */\n      if (arg0 <= 8)\n        term.bell.vol = arg0;\n    when CPAIR(' ', 'u'):     /* DECSMBV: VT520 margin bell volume */\n      if (!arg0)\n        term.marginbell.vol = 8;\n      else if (arg0 <= 8)\n        term.marginbell.vol = arg0;\n    when CPAIR(' ', 'Z'): /* PEC: ECMA-48 Presentation Expand Or Contract */\n      if (!arg0)\n        curs->width = 0;\n      else if (arg0 == 1)   // expanded\n        curs->width = 2;\n      else if (arg0 == 2) { // condensed\n        if (arg1 == 2)      // single-cell zoomed down\n          curs->width = 11;\n        else\n          curs->width = 1;\n      }\n      else if (arg0 == 22)  // single-cell zoomed down\n        curs->width = 11;\n#ifdef support_triple_width\n      else if (arg0 == 3)   // triple-cell\n        curs->width = 3;\n#endif\n    when CPAIR('-', 'p'): /* DECARR: VT520 Select Auto Repeat Rate */\n      if (arg0 <= 30)\n        term.repeat_rate = arg0;\n    when CPAIR('%', 'q'):  /* setup progress indicator on taskbar icon */\n      set_taskbar_progress(arg0, term.csi_argc > 1 ? arg1 : -1);\n    when 'y':  /* DECTST */\n      if (arg0 == 4) {\n        cattr attr = (cattr)\n                     {.attr = ATTR_DEFFG | (TRUE_COLOUR << ATTR_BGSHIFT),\n                      .truefg = 0, .truebg = 0, .ulcolr = (colour)-1,\n                      .link = -1\n                     };\n        switch (arg1) {\n          when 10: attr.truebg = RGB(0, 0, 255);\n          when 11: attr.truebg = RGB(255, 0, 0);\n          when 12: attr.truebg = RGB(0, 255, 0);\n          when 13: attr.truebg = RGB(255, 255, 255);\n          otherwise: return;\n        }\n        for (int i = 0; i < term.rows; i++) {\n          termline *line = term.lines[i];\n          for (int j = 0; j < term.cols; j++) {\n            line->chars[j] =\n              (termchar) {.cc_next = 0, .chr = ' ', attr};\n          }\n          line->lattr = LATTR_NORM;\n        }\n        term.disptop = 0;\n      }\n  }\n}\n\n/*\n * Fill image area with sixel placeholder characters and set cursor.\n */\nstatic void\nfill_image_space(imglist * img)\n{\n  cattrflags attr0 = term.curs.attr.attr;\n  // refer SIXELCH cells to image for display/discard management\n  term.curs.attr.imgi = img->imgi;\n#ifdef debug_img_disp\n  printf(\"fill %d:%d %d\\n\", term.curs.y, term.curs.x, img->imgi);\n#endif\n\n  short x0 = term.curs.x;\n  if (term.sixel_display) {  // sixel display mode\n    short y0 = term.curs.y;\n    term.curs.y = 0;\n    for (int y = 0; y < img->height && y < term.rows; ++y) {\n      term.curs.y = y;\n      term.curs.x = 0;\n      //printf(\"SIXELCH @%d imgi %d\\n\", y, term.curs.attr.imgi);\n      for (int x = x0; x < x0 + img->width && x < term.cols; ++x)\n        write_char(SIXELCH, 1);\n    }\n    term.curs.y = y0;\n    term.curs.x = x0;\n  } else {  // sixel scrolling mode\n    for (int i = 0; i < img->height; ++i) {\n      term.curs.x = x0;\n      //printf(\"SIXELCH @%d imgi %d\\n\", term.curs.y, term.curs.attr.imgi);\n      for (int x = x0; x < x0 + img->width && x < term.cols; ++x)\n        write_char(SIXELCH, 1);\n      if (i == img->height - 1) {  // in the last line\n        if (!term.sixel_scrolls_right) {\n          write_linefeed();\n          term.curs.x = term.sixel_scrolls_left ? 0: x0;\n        }\n      } else {\n        write_linefeed();\n      }\n    }\n  }\n\n  term.curs.attr.attr = attr0;\n}\n\nstatic void\ndo_dcs(void)\n{\n  // Implemented:\n  // DECRQSS (Request Status String)\n  // DECAUPSS (Assign User-Preferred Supplemental Set)\n  // DECSIXEL\n  // No DECUDK (User-Defined Keys) or xterm termcap/terminfo data.\n\n  char *s = term.cmd_buf;\n  if (!term.cmd_len)\n    *s = 0;\n\n  switch (term.dcs_cmd) {\n\n  when CPAIR('!', 'u'):  // DECAUPSS\n    if (term.state == DCS_ESCAPE) {\n      ushort nrc_code = 0;\n      if (term.cmd_len == 1)\n        nrc_code = *s;\n      else if (term.cmd_len == 2)\n        nrc_code = CPAIR(s[0], s[1]);\n      term_cset cs = lookup_cset(nrc_code, 7, false);\n      if (cs) {\n        term.curs.decsupp = cs;\n        term_update_cs();\n        return;\n      }\n    }\n\n  when 'q': {\n   sixel_state_t * st = (sixel_state_t *)term.imgs.parser_state;\n   int status = -1;\n\n   switch (term.state) {\n    when DCS_PASSTHROUGH:\n      if (!st)\n        return;\n      status = sixel_parser_parse(st, (unsigned char *)s, term.cmd_len);\n      if (status < 0) {\n        sixel_parser_deinit(st);\n        //printf(\"free state 1 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        term.state = DCS_IGNORE;\n        return;\n      }\n\n    when DCS_ESCAPE:\n      if (!st)\n        return;\n      status = sixel_parser_parse(st, (unsigned char *)s, term.cmd_len);\n      if (status < 0) {\n        sixel_parser_deinit(st);\n        //printf(\"free state 2 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        return;\n      }\n\n      unsigned char * pixels = sixel_parser_finalize(st);\n      //printf(\"sixel_parser_finalize %p\\n\", pixels);\n      sixel_parser_deinit(st);\n      if (!pixels) {\n        //printf(\"free state 3 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        return;\n      }\n\n      short left = term.curs.x;\n      short top = term.virtuallines + (term.sixel_display ? 0: term.curs.y);\n      int width = (st->image.width -1 ) / st->grid_width + 1;\n      int height = (st->image.height -1 ) / st->grid_height + 1;\n      int pixelwidth = st->image.width;\n      int pixelheight = st->image.height;\n      //printf(\"w %d/%d %d h %d/%d %d\\n\", pixelwidth, st->grid_width, width, pixelheight, st->grid_height, height);\n\n      imglist * img;\n      if (!winimg_new(&img, 0, pixels, 0, left, top, width, height, pixelwidth, pixelheight, false, 0, 0, 0, 0)) {\n        free(pixels);\n        sixel_parser_deinit(st);\n        //printf(\"free state 4 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        return;\n      }\n      img->cwidth = st->max_x;\n      img->cheight = st->max_y;\n\n      fill_image_space(img);\n\n      // add image to image list;\n      // replace previous for optimisation in some cases\n      if (term.imgs.first == NULL) {\n        term.imgs.first = term.imgs.last = img;\n      } else {\n        // try some optimization: replace existing images if overwritten\n#ifdef debug_sixel_list\n        printf(\"do_dcs checking imglist\\n\");\n#endif\n#ifdef replace_images\n#warning do not replace images in the list anymore\n        // with new flicker-reduce strategy of rendering overlapped images,\n        // new images should always be added to the end of the queue;\n        // completely overlayed images should be collected for removal \n        // during the rendering loop (winimgs_paint),\n        // or latest when they are scrolled out of the scrollback buffer\n        for (imglist * cur = term.imgs.first; cur; cur = cur->next) {\n          if (cur->pixelwidth == cur->width * st->grid_width &&\n              cur->pixelheight == cur->height * st->grid_height)\n          {\n            // if same size, replace\n            if (img->top == cur->top && img->left == cur->left &&\n                img->width == cur->width &&\n                img->height == cur->height)\n            {\n#ifdef debug_sixel_list\n              printf(\"img replace\\n\");\n#endif\n              memcpy(cur->pixels, img->pixels, img->pixelwidth * img->pixelheight * 4);\n              cur->imgi = img->imgi;\n              winimg_destroy(img);\n              return;\n            }\n            // if new image within area of previous image, ...\n#ifdef handle_overlay_images\n#warning this creates some crash conditions...\n            if (img->top >= cur->top && img->left >= cur->left &&\n                img->left + img->width <= cur->left + cur->width &&\n                img->top + img->height <= cur->top + cur->height)\n            {\n              // inject new img into old structure;\n              // copy img data in stripes, for unknown reason\n              for (y = 0; y < img->pixelheight; ++y) {\n                memcpy(cur->pixels +\n                         ((img->top - cur->top) * st->grid_height + y) * cur->pixelwidth * 4 +\n                         (img->left - cur->left) * st->grid_width * 4,\n                       img->pixels + y * img->pixelwidth * 4,\n                       img->pixelwidth * 4);\n              }\n              cur->imgi = img->imgi;\n              winimg_destroy(img);\n              return;\n            }\n#endif\n          }\n        }\n#endif\n        // append image to list\n        img->prev = term.imgs.last;\n        term.imgs.last->next = img;\n        term.imgs.last = img;\n      }\n\n    otherwise: {\n      /* parser status initialization */\n      colour fg = win_get_colour(FG_COLOUR_I);\n      colour bg = win_get_colour(BG_COLOUR_I);\n      if (!st) {\n        st = term.imgs.parser_state = calloc(1, sizeof(sixel_state_t));\n        //printf(\"alloc state %d -> %p\\n\", (int)sizeof(sixel_state_t), st);\n        sixel_parser_set_default_color(st);\n      }\n      status = sixel_parser_init(st, fg, bg, term.private_color_registers);\n      if (status < 0)\n        return;\n    }\n   }\n  }\n\n  when CPAIR('$', 'q'):\n    switch (term.state) {\n    when DCS_ESCAPE: {     // DECRQSS\n      cattr attr = term.curs.attr;\n      if (!strcmp(s, \"m\")) { // SGR\n        char buf[90], *p = buf;\n        p += sprintf(p, \"\\eP1$r0\");\n\n        if (attr.attr & ATTR_BOLD)\n          p += sprintf(p, \";1\");\n        if (attr.attr & ATTR_DIM)\n          p += sprintf(p, \";2\");\n        if (attr.attr & ATTR_SHADOW)\n          p += sprintf(p, \";1:2\");\n        if (attr.attr & ATTR_ITALIC)\n          p += sprintf(p, \";3\");\n\n        if (attr.attr & ATTR_BROKENUND)\n          if (attr.attr & ATTR_DOUBLYUND)\n            p += sprintf(p, \";4:5\");\n          else\n            p += sprintf(p, \";4:4\");\n        else if ((attr.attr & UNDER_MASK) == ATTR_CURLYUND)\n          p += sprintf(p, \";4:3\");\n        else if (attr.attr & ATTR_UNDER)\n          p += sprintf(p, \";4\");\n\n        if (attr.attr & ATTR_BLINK)\n          p += sprintf(p, \";5\");\n        if (attr.attr & ATTR_BLINK2)\n          p += sprintf(p, \";6\");\n        if (attr.attr & ATTR_REVERSE)\n          p += sprintf(p, \";7\");\n        if (attr.attr & ATTR_INVISIBLE)\n          p += sprintf(p, \";8\");\n        if (attr.attr & ATTR_OVERSTRIKE)\n          p += sprintf(p, \";8:7\");\n        if (attr.attr & ATTR_STRIKEOUT)\n          p += sprintf(p, \";9\");\n        if ((attr.attr & UNDER_MASK) == ATTR_DOUBLYUND)\n          p += sprintf(p, \";21\");\n        if (attr.attr & ATTR_FRAMED)\n          p += sprintf(p, \";51;52\");\n        if (attr.attr & ATTR_OVERL)\n          p += sprintf(p, \";53\");\n        if (attr.attr & ATTR_SUPERSCR)\n          p += sprintf(p, \";73\");\n        if (attr.attr & ATTR_SUBSCR)\n          p += sprintf(p, \";74\");\n\n        if (term.curs.oem_acs)\n          p += sprintf(p, \";%u\", 10 + term.curs.oem_acs);\n        else {\n          uint ff = (attr.attr & FONTFAM_MASK) >> ATTR_FONTFAM_SHIFT;\n          if (ff)\n            p += sprintf(p, \";%u\", 10 + ff);\n        }\n\n        uint fg = (attr.attr & ATTR_FGMASK) >> ATTR_FGSHIFT;\n        if (fg != FG_COLOUR_I) {\n          if (fg >= TRUE_COLOUR)\n            //p += sprintf(p, \";38;2;%u;%u;%u\", attr.truefg & 0xFF, \n            //             (attr.truefg >> 8) & 0xFF, (attr.truefg >> 16) & 0xFF);\n            p += sprintf(p, \";38:2::%u:%u:%u\", attr.truefg & 0xFF, \n                         (attr.truefg >> 8) & 0xFF, (attr.truefg >> 16) & 0xFF);\n          else if (fg < 16)\n            p += sprintf(p, \";%u\", (fg < 8 ? 30 : 90) + (fg & 7));\n          else\n            //p += sprintf(p, \";38;5;%u\", fg);\n            p += sprintf(p, \";38:5:%u\", fg);\n        }\n\n        uint bg = (attr.attr & ATTR_BGMASK) >> ATTR_BGSHIFT;\n        if (bg != BG_COLOUR_I) {\n          if (bg >= TRUE_COLOUR)\n            //p += sprintf(p, \";48;2;%u;%u;%u\", attr.truebg & 0xFF, \n            //             (attr.truebg >> 8) & 0xFF, (attr.truebg >> 16) & 0xFF);\n            p += sprintf(p, \";48:2::%u:%u:%u\", attr.truebg & 0xFF, \n                         (attr.truebg >> 8) & 0xFF, (attr.truebg >> 16) & 0xFF);\n          else if (bg < 16)\n            p += sprintf(p, \";%u\", (bg < 8 ? 40 : 100) + (bg & 7));\n          else\n            //p += sprintf(p, \";48;5;%u\", bg);\n            p += sprintf(p, \";48:5:%u\", bg);\n        }\n\n        if (attr.attr & ATTR_ULCOLOUR) {\n          p += sprintf(p, \";58:2::%u:%u:%u\", attr.ulcolr & 0xFF, \n                       (attr.ulcolr >> 8) & 0xFF, (attr.ulcolr >> 16) & 0xFF);\n        }\n\n        p += sprintf(p, \"m\\e\\\\\");  // m for SGR, followed by ST\n\n        child_write(buf, p - buf);\n      } else if (!strcmp(s, \"r\")) {  // DECSTBM (scrolling region margins)\n        child_printf(\"\\eP1$r%u;%ur\\e\\\\\", term.marg_top + 1, term.marg_bot + 1);\n      } else if (!strcmp(s, \"s\")) {  // DECSLRM (left and right margins)\n        child_printf(\"\\eP1$r%u;%us\\e\\\\\", term.marg_left + 1, term.marg_right + 1);\n      } else if (!strcmp(s, \"\\\"p\")) {  // DECSCL (conformance level)\n        child_printf(\"\\eP1$r%u;%u\\\"p\\e\\\\\", 65, 1);  // report as VT500 S7C1T\n      } else if (!strcmp(s, \"\\\"q\")) {  // DECSCA (protection attribute)\n        child_printf(\"\\eP1$r%u\\\"q\\e\\\\\", (attr.attr & ATTR_PROTECTED) != 0);\n      } else if (!strcmp(s, \" q\")) {  // DECSCUSR (cursor style)\n        child_printf(\"\\eP1$r%u q\\e\\\\\", \n                     (term.cursor_type >= 0 ? term.cursor_type * 2 : 0) + 1\n                     + !(term.cursor_blinks & 1));\n      } else if (!strcmp(s, \"t\") && term.rows >= 24) {  // DECSLPP (lines)\n        child_printf(\"\\eP1$r%ut\\e\\\\\", term.rows);\n      } else if (!strcmp(s, \"$|\")) {  // DECSCPP (columns)\n        child_printf(\"\\eP1$r%u$|\\e\\\\\", term.cols);\n      } else if (!strcmp(s, \"*|\")) {  // DECSNLS (lines)\n        child_printf(\"\\eP1$r%u*|\\e\\\\\", term.rows);\n      } else {\n        child_printf(\"\\eP0$r%s\\e\\\\\", s);\n      }\n    }\n    otherwise:\n      return;\n    }\n\n  }\n}\n\nstatic void\ndo_colour_osc(bool has_index_arg, uint i, bool reset)\n{\n  int osc_num = term.cmd_num;  // 4, 5, 10..19, 104, 105, 110..119\n  char *s = term.cmd_buf;\n  int index;\n\ndo_osc_control:\n  //printf(\"OSC %d <%s>\\n\", osc_num, s);\n  if (has_index_arg) {  // OSC 4, 5, 104, 105\n    int osc = i;  // 4, 5\n    int len = 0;\n    sscanf(s, \"%u;%n\", &index, &len);\n    i = index;\n    if ((reset ? len != 0 : len == 0) || i >= COLOUR_NUM)\n      return;\n    s += len;\n    if (osc % 100 == 5) {\n      if (i == 0)\n        i = BOLD_COLOUR_I;\n#ifdef other_color_substitutes\n      else if (i == 1)\n        i = UNDERLINE_COLOUR_I;\n      else if (i == 2)\n        i = BLINK_COLOUR_I;\n      else if (i == 3)\n        i = REVERSE_COLOUR_I;\n      else if (i == 4)\n        i = ITALIC_COLOUR_I;\n#endif\n      else if (i > 4)\n        return;\n      else {\n        // skip unimplemented setting, continue to process multiple controls\n        i = COLOUR_NUM;\n      }\n    }\n    else if (i >= 256)\n      return;\n  }\n\n  char * cont = strchr(s, ';');\n  if (cont)\n    *cont = 0;  // enable colour parsing with subsequent multiple values\n\n  colour c;\n  if (i >= COLOUR_NUM) {\n    // skip this setting\n  }\n  else if (reset)\n    win_set_colour(i, (colour)-1);\n  else if (!strcmp(s, \"?\")) {\n    child_printf(\"\\e]%u;\", osc_num);\n    if (has_index_arg)\n      child_printf(\"%u;\", index);\n    c = i < COLOUR_NUM ? colours[i] : 0;  // should not be affected by rvideo\n    char * osc_fini = term.state == CMD_ESCAPE ? \"\\e\\\\\" : \"\\a\";\n    child_printf(\"rgb:%04x/%04x/%04x%s\",\n                 red(c) * 0x101, green(c) * 0x101, blue(c) * 0x101, osc_fini);\n  }\n  else if (parse_colour(s, &c))\n    win_set_colour(i, c);\n\n  if (cont) {  // support multiple osc controls\n    s = cont;  // original ';' position\n    s++;\n    if (osc_num >= 10 && osc_num <= 19) {  // \"dynamic colors\"\n      int new_num;\n      int len = 0;\n      sscanf(s, \"%u;%n\", &new_num, &len);\n      if (len) {  // OSC 10;blue;12;red\n        s += len;\n        osc_num = new_num;\n      }\n      else  // OSC 10;blue;pink: auto-increment dynamic color index\n        osc_num++;\n      // adjust i (the extended colour palette index)\n      // to the new dynamic color number;\n      // what a hack! this should have been done in do_cmd\n      switch (osc_num) {\n        when 10:   i = FG_COLOUR_I;\n        when 11:   i = BG_COLOUR_I;\n        when 12:   i = CURSOR_COLOUR_I;\n        when 17:   i = SEL_COLOUR_I;\n        when 19:   i = SEL_TEXT_COLOUR_I;\n        when 15:   i = TEK_FG_COLOUR_I;\n        when 16:   i = TEK_BG_COLOUR_I;\n        when 18:   i = TEK_CURSOR_COLOUR_I;\n        otherwise: i = COLOUR_NUM;\n      }\n    }\n    goto do_osc_control;\n  }\n}\n\n/*\n * OSC 52: \\e]52;[cp0-6];?|base64-string\\07\"\n * Only system clipboard is supported now.\n */\nstatic void\ndo_clipboard(void)\n{\n  char *s = term.cmd_buf;\n  char *output;\n  int len;\n  int ret;\n\n  if (!cfg.allow_set_selection) {\n    return;\n  }\n\n  while (*s != ';' && *s != '\\0') {\n    s += 1;\n  }\n  if (*s != ';') {\n    return;\n  }\n  s += 1;\n  if (*s == '?') {\n    /* Reading from clipboard is unsupported */\n    return;\n  }\n  len = strlen(s);\n\n  output = malloc(len + 1);\n  if (output == NULL) {\n    return;\n  }\n\n  ret = base64_decode_clip(s, len, output, len);\n  if (ret > 0) {\n    output[ret] = '\\0';\n    win_copy_text(output);\n  }\n  free(output);\n}\n\n/*\n * Process OSC command sequences.\n */\nstatic void\ndo_cmd(void)\n{\n  char *s = term.cmd_buf;\n  s[term.cmd_len] = 0;\n  //printf(\"OSC %d <%s> %s\\n\", term.cmd_num, s, term.state == CMD_ESCAPE ? \"ST\" : \"BEL\");\n  char * osc_fini = term.state == CMD_ESCAPE ? \"\\e\\\\\" : \"\\a\";\n\n  if (*cfg.suppress_osc && contains(cfg.suppress_osc, term.cmd_num))\n    // skip suppressed OSC command\n    return;\n\n  switch (term.cmd_num) {\n    when 0 or 2: win_set_title(s);  // ignore icon title\n    when 4:   do_colour_osc(true, 4, false);\n    when 5:   do_colour_osc(true, 5, false);\n    when 6 or 106: {\n      int col, on;\n      if (sscanf(term.cmd_buf, \"%u;%u\", &col, &on) == 2)\n        if (col == 0)\n          term.enable_bold_colour = on;\n    }\n    when 104: do_colour_osc(true, 4, true);\n    when 105: do_colour_osc(true, 5, true);\n    when 10:  do_colour_osc(false, FG_COLOUR_I, false);\n    when 11:  if (strchr(\"*_%=\", *term.cmd_buf)) {\n                wchar * bn = cs__mbstowcs(term.cmd_buf);\n                wstrset(&cfg.background, bn);\n                free(bn);\n                if (*term.cmd_buf == '%')\n                  scale_to_image_ratio();\n                win_invalidate_all(true);\n              }\n              else\n                do_colour_osc(false, BG_COLOUR_I, false);\n    when 12:  do_colour_osc(false, CURSOR_COLOUR_I, false);\n    when 17:  do_colour_osc(false, SEL_COLOUR_I, false);\n    when 19:  do_colour_osc(false, SEL_TEXT_COLOUR_I, false);\n    when 15:  do_colour_osc(false, TEK_FG_COLOUR_I, false);\n    when 16:  do_colour_osc(false, TEK_BG_COLOUR_I, false);\n    when 18:  do_colour_osc(false, TEK_CURSOR_COLOUR_I, false);\n    when 110: do_colour_osc(false, FG_COLOUR_I, true);\n    when 111: do_colour_osc(false, BG_COLOUR_I, true);\n    when 112: do_colour_osc(false, CURSOR_COLOUR_I, true);\n    when 117: do_colour_osc(false, SEL_COLOUR_I, true);\n    when 119: do_colour_osc(false, SEL_TEXT_COLOUR_I, true);\n    when 115: do_colour_osc(false, TEK_FG_COLOUR_I, true);\n    when 116: do_colour_osc(false, TEK_BG_COLOUR_I, true);\n    when 118: do_colour_osc(false, TEK_CURSOR_COLOUR_I, true);\n    when 7:  // Set working directory (from Mac Terminal) for Alt+F2\n      // extract dirname from file://host/path scheme\n      if (!strncmp(s, \"file:\", 5))\n        s += 5;\n      if (!strncmp(s, \"//localhost/\", 12))\n        s += 11;\n      else if (!strncmp(s, \"///\", 3))\n        s += 2;\n      if (!*s || *s == '/')\n        child_set_fork_dir(s);\n    when 701:  // Set/get locale (from urxvt).\n      if (!strcmp(s, \"?\"))\n        child_printf(\"\\e]701;%s%s\", cs_get_locale(), osc_fini);\n      else\n        cs_set_locale(s);\n    when 7721:  // Copy window title to clipboard.\n      win_copy_title();\n    when 7773: {  // Change icon.\n      uint icon_index = 0;\n      char *comma = strrchr(s, ',');\n      if (comma) {\n        char *start = comma + 1, *end;\n        icon_index = strtoul(start, &end, 0);\n        if (start != end && !*end)\n          *comma = 0;\n        else\n          icon_index = 0;\n      }\n      win_set_icon(s, icon_index);\n    }\n    when 7770:  // Change font size.\n      if (!strcmp(s, \"?\"))\n        child_printf(\"\\e]7770;%u%s\", win_get_font_size(), osc_fini);\n      else {\n        char *end;\n        int i = strtol(s, &end, 10);\n        if (*end)\n          ; // Ignore if parameter contains unexpected characters\n        else if (*s == '+' || *s == '-')\n          win_zoom_font(i, false);\n        else\n          win_set_font_size(i, false);\n      }\n    when 7777:  // Change font and window size.\n      if (!strcmp(s, \"?\"))\n        child_printf(\"\\e]7777;%u%s\", win_get_font_size(), osc_fini);\n      else {\n        char *end;\n        int i = strtol(s, &end, 10);\n        if (*end)\n          ; // Ignore if parameter contains unexpected characters\n        else if (*s == '+' || *s == '-')\n          win_zoom_font(i, true);\n        else\n          win_set_font_size(i, true);\n      }\n    when 7771: {  // Enquire about font support for a list of characters\n      if (*s++ != '?')\n        return;\n      wchar wcs[term.cmd_len];\n      uint n = 0;\n      while (*s) {\n        if (*s++ != ';')\n          return;\n        wcs[n++] = strtoul(s, &s, 10);\n      }\n      win_check_glyphs(wcs, n, term.curs.attr.attr);\n      s = term.cmd_buf;\n      for (size_t i = 0; i < n; i++) {\n        *s++ = ';';\n        if (wcs[i])\n          s += sprintf(s, \"%u\", wcs[i]);\n      }\n      *s = 0;\n      child_printf(\"\\e]7771;!%s%s\", term.cmd_buf, osc_fini);\n    }\n    when 77119: {  // Indic and Extra characters wide handling\n      int what = atoi(s);\n      term.wide_indic = false;\n      term.wide_extra = false;\n      if (what & 1)\n        term.wide_indic = true;\n      if (what & 2)\n        term.wide_extra = true;\n    }\n    when 52: do_clipboard();\n    when 50:\n      if (tek_mode) {\n        tek_set_font(cs__mbstowcs(s));\n        tek_init(false, cfg.tek_glow);\n      }\n      else {\n        uint ff = (term.curs.attr.attr & FONTFAM_MASK) >> ATTR_FONTFAM_SHIFT;\n        if (!strcmp(s, \"?\")) {\n          char * fn = cs__wcstombs(win_get_font(ff) ?: W(\"\"));\n          child_printf(\"\\e]50;%s%s\", fn, osc_fini);\n          free(fn);\n        }\n        else {\n          if (ff < lengthof(cfg.fontfams) - 1) {\n            wstring wfont = cs__mbstowcs(s);  // let this leak...\n            win_change_font(ff, wfont);\n          }\n        }\n      }\n    when 8: {  // hyperlink attribute\n      char * link = s;\n      char * url = strchr(s, ';');\n      if (url++ && *url) {\n        term.curs.attr.link = putlink(link);\n      }\n      else\n        term.curs.attr.link = -1;\n    }\n    when 1337: {  // iTerm2 image protocol\n                  // https://www.iterm2.com/documentation-images.html\n      char * payload = strchr(s, ':');\n      if (payload) {\n        *payload = 0;\n        payload++;\n      }\n\n      // verify protocol\n      if (0 == strncmp(\"File=\", s, 5))\n        s += 5;\n      else\n        return;\n\n      char * name = 0;\n      int width = 0;\n      int height = 0;\n      int pixelwidth = 0;\n      int pixelheight = 0;\n      bool pAR = true;\n      int crop_x = 0;\n      int crop_y = 0;\n      int crop_width = 0;\n      int crop_height = 0;\n\n      // process parameters\n      while (s && *s) {\n        char * nxt = strchr(s, ';');\n        if (nxt) {\n          *nxt = 0;\n          nxt++;\n        }\n        char * sval = strchr(s, '=');\n        if (sval) {\n          *sval = 0;\n          sval++;\n        }\n        else\n          sval = \"\";\n        int val = atoi(sval);\n        char * suf = sval;\n        while (isdigit((uchar)*suf))\n          suf++;\n        bool pix = 0 == strcmp(\"px\", suf);\n        bool per = 0 == strcmp(\"%\", suf);\n        //printf(\"<%s>=<%s>%d<%s>\\n\", s, sval, val, suf);\n\n        if (0 == strcmp(\"name\", s))\n          name = s;  // can serve as cache id\n        else if (0 == strcmp(\"width\", s)) {\n          if (pix) {\n            pixelwidth = val;\n            width = (val - 1) / cell_width + 1;\n          }\n          else if (per) {\n            width = term.cols * val / 100;\n            pixelwidth = width * cell_width;\n          }\n          else {\n            width = val;\n            pixelwidth = val * cell_width;\n          }\n        }\n        else if (0 == strcmp(\"height\", s)) {\n          if (pix) {\n            pixelheight = val;\n            height = (val - 1) / cell_height + 1;\n          }\n          else if (per) {\n            height = term.rows * val / 100;\n            pixelheight = height * cell_height;\n          }\n          else {\n            height = val;\n            pixelheight = val * cell_height;\n          }\n        }\n        else if (0 == strcmp(\"preserveAspectRatio\", s)) {\n          pAR = val;\n        }\n        else if (0 == strcmp(\"cropX\", s) || 0 == strcmp(\"cropLeft\", s)) {\n          if (pix) {\n            crop_x = val;\n          }\n        }\n        else if (0 == strcmp(\"cropY\", s) || 0 == strcmp(\"cropTop\", s)) {\n          if (pix) {\n            crop_y = val;\n          }\n        }\n        else if (0 == strcmp(\"cropWidth\", s)) {\n          if (pix) {\n            crop_width = val;\n          }\n        }\n        else if (0 == strcmp(\"cropHeight\", s)) {\n          if (pix) {\n            crop_height = val;\n          }\n        }\n        else if (0 == strcmp(\"cropRight\", s)) {\n          if (pix) {\n            crop_width = - val;\n          }\n        }\n        else if (0 == strcmp(\"cropBottom\", s)) {\n          if (pix) {\n            crop_height = - val;\n          }\n        }\n\n        s = nxt;\n      }\n\n      if (payload) {\n#ifdef strip_newlines\n#warning not applicable as preprocessing OSC would not pass it here\n        char * from = strpbrk(payload, \"\\r\\n\");\n        if (from) {  // strip new lines\n          char * to = from;\n          while (*from) {\n            if (*from >= ' ')\n              *to++ = *from;\n            from++;\n          }\n          *to = 0;\n        }\n#endif\n        int len = strlen(payload);\n        int datalen = len - (len / 4);\n        void * data = malloc(datalen);\n        if (!data)\n          return;\n        datalen = base64_decode_clip(payload, len, data, datalen);\n        if (datalen > 0) {\n          // OK\n          imglist * img;\n          short left = term.curs.x;\n          short top = term.virtuallines + term.curs.y;\n          if (winimg_new(&img, name, data, datalen, left, top, width, height, pixelwidth, pixelheight, pAR, crop_x, crop_y, crop_width, crop_height)) {\n            fill_image_space(img);\n\n            if (term.imgs.first == NULL) {\n              term.imgs.first = term.imgs.last = img;\n            } else {\n              // append image to list\n              img->prev = term.imgs.last;\n              term.imgs.last->next = img;\n              term.imgs.last = img;\n            }\n          }\n          else\n            free(data);\n        }\n        else\n          free(data);\n      }\n    }\n    when 9: {\ntypedef struct {\n  char * p;\n  int v;\n} paramap;\n      int scanenum(char * s, int * _i, paramap * p, bool donum) {\n        char * sep = strchr(s, ';');\n        int len = sep ? (uint)(sep - s) : strlen(s);\n        while (p->p) {\n          if (0 == strncasecmp(s, p->p, len)) {\n            *_i = p->v;\n            return len;\n          }\n          p++;\n        }\n        if (donum) {\n          // fallback scan for number\n          int numlen = sscanf(s, \"%d\", _i);\n          if (numlen && numlen == len)\n            return numlen;\n        }\n        // not found\n        return 0;\n      }\n\n      int cmd;\n      int len = scanenum(s, &cmd,\n                         (paramap[]){{\"4\", 4}, {\"progress\", 4}, {0, 0}},\n                         false);\n      if (!len || cmd != 4)\n        return;\n      s += len;\n\n      if (!*s)\n        return;\n      s++;\n      int state;\n      len = scanenum(s, &state,\n                     (paramap[]){\n                                 {\"off\", 0},\n                                 {\"green\", 1},\n                                 {\"yellow\", 2},\n                                 {\"red\", 3},\n                                 {\"busy\", 8},\n                                 {\"0\", 0},\n                                 {\"1\", 1},\n                                 {\"4\", 2},\n                                 {\"2\", 3},\n                                 {\"3\", 8},\n                                 {0, 0}},\n                     false);\n      if (!len)\n        return;\n      s += len;\n\n      int percent = -1;\n      if (*s) {\n        s++;\n        sscanf(s, \"%d\", &percent);\n      }\n\n      set_taskbar_progress(state, percent);\n    }\n  }\n}\n\nvoid\nterm_print_finish(void)\n{\n  if (term.printing) {\n    printer_write(term.printbuf, term.printbuf_pos);\n    free(term.printbuf);\n    term.printbuf = 0;\n    term.printbuf_size = term.printbuf_pos = 0;\n    printer_finish_job();\n    term.printing = term.only_printing = false;\n  }\n}\n\nstatic void\nterm_do_write(const char *buf, uint len)\n{\n  //check e.g. if progress indication is following by CR\n  //printf(\"[%ld] write %02X...%02X\\n\", mtime(), *buf, buf[len - 1]);\n\n  // Reset cursor blinking.\n  term.cblinker = 1;\n  term_schedule_cblink();\n\n  short oldy = term.curs.y;\n\n  uint pos = 0;\n  while (pos < len) {\n    uchar c = buf[pos++];\n\n   /*\n    * If we're printing, add the character to the printer buffer.\n    */\n    if (term.printing) {\n      if (term.printbuf_pos >= term.printbuf_size) {\n        term.printbuf_size = term.printbuf_size * 4 + 4096;\n        term.printbuf = renewn(term.printbuf, term.printbuf_size);\n      }\n      term.printbuf[term.printbuf_pos++] = c;\n\n     /*\n      * If we're in print-only mode, we use a much simpler state machine \n      * designed only to recognise the ESC[4i termination sequence.\n      */\n      if (term.only_printing) {\n        if (c == '\\e')\n          term.print_state = 1;\n        else if (c == '[' && term.print_state == 1)\n          term.print_state = 2;\n        else if (c == '4' && term.print_state == 2)\n          term.print_state = 3;\n        else if (c == 'i' && term.print_state == 3) {\n          term.printbuf_pos -= 4;\n          term_print_finish();\n        }\n        else\n          term.print_state = 0;\n        continue;\n      }\n    }\n\n    switch (term.state) {\n      when NORMAL: {\n        wchar wc;\n\n        if (term.curs.oem_acs && !memchr(\"\\e\\n\\r\\b\", c, 4)) {\n          if (term.curs.oem_acs == 2)\n            c |= 0x80;\n          write_ucschar(0, cs_btowc_glyph(c), 1);\n          continue;\n        }\n\n        // handle NRC single shift and NRC GR invocation;\n        // maybe we should handle control characters first?\n        short cset = term.curs.csets[term.curs.gl];\n        if (term.curs.cset_single != CSET_ASCII && c > 0x20 && c < 0xFF) {\n          cset = term.curs.cset_single;\n          term.curs.cset_single = CSET_ASCII;\n        }\n        else if (term.decnrc_enabled\n         && term.curs.gr && term.curs.csets[term.curs.gr] != CSET_ASCII\n         && !term.curs.oem_acs && !term.curs.utf\n         && c >= 0x80 && c < 0xFF) {\n          // tune C1 behaviour to mimic xterm\n          if (c < 0xA0)\n            continue;\n\n          c &= 0x7F;\n          cset = term.curs.csets[term.curs.gr];\n        }\n\n        if (term.vt52_mode) {\n          if (term.vt52_mode > 1)\n            cset = CSET_VT52DRW;\n          else\n            cset = CSET_ASCII;\n        }\n        else if (cset == CSET_DECSUPP)\n          cset = term.curs.decsupp;\n\n        switch (cs_mb1towc(&wc, c)) {\n          when 0: // NUL or low surrogate\n            if (wc)\n              pos--;\n          when -1: // Encoding error\n            if (!tek_mode)\n              write_error();\n            if (term.in_mb_char || term.high_surrogate)\n              pos--;\n            term.high_surrogate = 0;\n            term.in_mb_char = false;\n            cs_mb1towc(0, 0); // Clear decoder state\n            continue;\n          when -2: // Incomplete character\n            term.in_mb_char = true;\n            continue;\n        }\n\n        term.in_mb_char = false;\n\n        // Fetch previous high surrogate\n        wchar hwc = term.high_surrogate;\n        term.high_surrogate = 0;\n\n        if (is_low_surrogate(wc)) {\n          if (hwc) {\n#if HAS_LOCALES\n            int width = (cfg.charwidth % 10)\n                        ? xcwidth(combine_surrogates(hwc, wc)) :\n# ifdef __midipix__\n                        wcwidth(combine_surrogates(hwc, wc));\n# else\n                        wcswidth((wchar[]){hwc, wc}, 2);\n# endif\n#else\n            int width = xcwidth(combine_surrogates(hwc, wc));\n#endif\n#ifdef support_triple_width\n            // do not handle triple-width here\n            //if (term.curs.width)\n            //  width = term.curs.width % 10;\n#endif\n            write_ucschar(hwc, wc, width);\n          }\n          else\n            write_error();\n          continue;\n        }\n\n        if (hwc) // Previous high surrogate not followed by low one\n          write_error();\n\n        // ASCII shortcut for some speedup (~5%), earliest applied here\n        if (wc >= ' ' && wc <= 0x7E && cset == CSET_ASCII) {\n          write_ucschar(0, wc, 1);\n          continue;\n        }\n\n        if (is_high_surrogate(wc)) {\n          term.high_surrogate = wc;\n          continue;\n        }\n\n        // Non-characters\n        if (wc == 0xFFFE || wc == 0xFFFF) {\n          write_error();\n          continue;\n        }\n\n        // Everything else\n        wchar NRC(wchar * map)\n        {\n          static char * rpl = \"#@[\\\\]^_`{|}~\";\n          char * match = strchr(rpl, c);\n          if (match)\n            return map[match - rpl];\n          else\n            return wc;\n        }\n\n        cattrflags asav = term.curs.attr.attr;\n\n        switch (cset) {\n          when CSET_VT52DRW:  // VT52 \"graphics\" mode\n            if (0x5E <= wc && wc <= 0x7E) {\n              uchar dispcode = 0;\n              uchar gcode = 0;\n              if ('l' <= wc && wc <= 's') {\n                dispcode = wc - 'l' + 1;\n                gcode = 13;\n              }\n              else if ('c' <= wc && wc <= 'e') {\n                dispcode = 0xF;\n              }\n              wc = W(\"^ \uffff\u25ae\u215f\u00b3\u2075\u2077\u00b0\u00b1\u2192\u2026\u00f7\u2193\u23ba\u23ba\u23bb\u23bb\u23bc\u23bc\u23bd\u23bd\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\u00b6\") [c - 0x5E];\n              term.curs.attr.attr |= ((cattrflags)dispcode) << ATTR_GRAPH_SHIFT;\n              if (gcode) {\n                // extend graph encoding with unused font number\n                term.curs.attr.attr &= ~FONTFAM_MASK;\n                term.curs.attr.attr |= (cattrflags)gcode << ATTR_FONTFAM_SHIFT;\n              }\n            }\n          when CSET_LINEDRW:  // VT100 line drawing characters\n            if (0x60 <= wc && wc <= 0x7E) {\n              wchar dispwc = win_linedraw_char(wc - 0x60);\n#define draw_vt100_line_drawing_chars\n#ifdef draw_vt100_line_drawing_chars\n              if ('j' <= wc && wc <= 'x') {\n                static uchar linedraw_code[31] = {\n                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n#if __GNUC__ >= 5\n                  0b1001, 0b1100, 0b0110, 0b0011, 0b1111,  // \u2518\u2510\u250c\u2514\u253c\n                  0x10, 0x20, 0b1010, 0x40, 0x50,          // \u23ba\u23bb\u2500\u23bc\u23bd\n                  0b0111, 0b1101, 0b1011, 0b1110, 0b0101,  // \u251c\u2524\u2534\u252c\u2502\n#else // < 4.3\n                  0x09, 0x0C, 0x06, 0x03, 0x0F,  // \u2518\u2510\u250c\u2514\u253c\n                  0x10, 0x20, 0x0A, 0x40, 0x50,  // \u23ba\u23bb\u2500\u23bc\u23bd\n                  0x07, 0x0D, 0x0B, 0x0E, 0x05,  // \u251c\u2524\u2534\u252c\u2502\n#endif\n                  0, 0, 0, 0, 0, 0\n                };\n                uchar dispcode = linedraw_code[wc - 0x60];\n                if (dispcode) {\n                  uchar gcode = 11;\n                  if (dispcode >> 4) {\n                    dispcode >>= 4;\n                    gcode++;\n                  }\n                  term.curs.attr.attr |= ((cattrflags)dispcode) << ATTR_GRAPH_SHIFT;\n                  // extend graph encoding with unused font numbers\n                  term.curs.attr.attr &= ~FONTFAM_MASK;\n                  term.curs.attr.attr |= (cattrflags)gcode << ATTR_FONTFAM_SHIFT;\n                }\n              }\n#endif\n              wc = dispwc;\n            }\n          when CSET_TECH:  // DEC Technical character set\n            if (c > ' ' && c < 0x7F) {\n              // = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u239b\u239d\u239e\u23a0\u23a8\u23ac\uffff\uffff\u2572\u2571\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7\u0394\u2207\u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n              // = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u239b\u239d\u239e\u23a0\u23a8\u23ac\u2576\u2576\u2572\u2571\u2574\u2574\u2573\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7\u0394\u2207\u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n              // = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u23a7\u23a9\u23ab\u23ad\u23a8\u23ac\u2576\u2576\u2572\u2571\u2574\u2574\u2573\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7\u0394\u2207\u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n              wc = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u23a7\u23a9\u23ab\u23ad\u23a8\u23ac\u2576\u2576\u2572\u2571\u2574\u2574\u2573\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7  \u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n                   [c - ' ' - 1];\n              uchar dispcode = 0;\n              if (c <= 0x37) {\n                static uchar techdraw_code[23] = {\n                  0xE,                          // square root base\n                  0, 0, 0, 0, 0,\n                  0x8, 0x9, 0xA, 0xB,           // square bracket corners\n                  0, 0, 0, 0,                   // curly bracket hooks\n                  0, 0,                         // curly bracket middle pieces\n                  0x1, 0x2, 0, 0, 0x5, 0x6, 0x7 // sum segments\n                };\n                dispcode = techdraw_code[c - 0x21];\n              }\n              else if (c == 0x44)\n                dispcode = 0xC;\n              else if (c == 0x45)\n                dispcode = 0xD;\n              term.curs.attr.attr |= ((cattrflags)dispcode) << ATTR_GRAPH_SHIFT;\n            }\n          when CSET_NL:\n            wc = NRC(W(\"\u00a3\u00be\u0133\u00bd|^_`\u00a8\u0192\u00bc\u00b4\"));  // Dutch\n          when CSET_FI:\n            wc = NRC(W(\"#@\u00c4\u00d6\u00c5\u00dc_\u00e9\u00e4\u00f6\u00e5\u00fc\"));  // Finnish\n          when CSET_FR:\n            wc = NRC(W(\"\u00a3\u00e0\u00b0\u00e7\u00a7^_`\u00e9\u00f9\u00e8\u00a8\"));  // French\n          when CSET_CA:\n            wc = NRC(W(\"#\u00e0\u00e2\u00e7\u00ea\u00ee_\u00f4\u00e9\u00f9\u00e8\u00fb\"));  // French Canadian\n          when CSET_DE:\n            wc = NRC(W(\"#\u00a7\u00c4\u00d6\u00dc^_`\u00e4\u00f6\u00fc\u00df\"));  // German\n          when CSET_IT:\n            wc = NRC(W(\"\u00a3\u00a7\u00b0\u00e7\u00e9^_\u00f9\u00e0\u00f2\u00e8\u00ec\"));  // Italian\n          when CSET_NO:\n            wc = NRC(W(\"#\u00c4\u00c6\u00d8\u00c5\u00dc_\u00e4\u00e6\u00f8\u00e5\u00fc\"));  // Norwegian/Danish\n          when CSET_PT:\n            wc = NRC(W(\"#@\u00c3\u00c7\u00d5^_`\u00e3\u00e7\u00f5~\"));  // Portuguese\n          when CSET_ES:\n            wc = NRC(W(\"\u00a3\u00a7\u00a1\u00d1\u00bf^_`\u00b0\u00f1\u00e7~\"));  // Spanish\n          when CSET_SE:\n            wc = NRC(W(\"#\u00c9\u00c4\u00d6\u00c5\u00dc_\u00e9\u00e4\u00f6\u00e5\u00fc\"));  // Swedish\n          when CSET_CH:\n            wc = NRC(W(\"\u00f9\u00e0\u00e9\u00e7\u00ea\u00ee\u00e8\u00f4\u00e4\u00f6\u00fc\u00fb\"));  // Swiss\n          when CSET_DECSPGR   // DEC Supplemental Graphic\n            or CSET_DECSUPP:  // DEC Supplemental (user-preferred in VT*)\n            if (c > ' ' && c < 0x7F) {\n              wc = W(\"\u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a4\u00a9\u00aa\u00ab\uffff\uffff\uffff\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00ba\u00bb\u00bc\u00bd\uffff\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\uffff\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0152\u00d8\u00d9\u00da\u00db\u00dc\u0178\uffff\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\uffff\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0153\u00f8\u00f9\u00fa\u00fb\u00fc\u00ff\uffff\")\n                   [c - ' ' - 1];\n            }\n          // 96-character sets (UK / xterm 336)\n          when CSET_GBCHR:  // NRC United Kingdom\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Latin_Cyrillic:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040a\u040b\u040c\u00ad\u040e\u040f\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045a\u045b\u045c\u00a7\u045e\u045f\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Greek_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u2018\u2019\u00a3\u20ac\u20af\u00a6\u00a7\u00a8\u00a9\u037a\u00ab\u00ac\u00ad\uffff\u2015\u00b0\u00b1\u00b2\u00b3\u0384\u0385\u0386\u00b7\u0388\u0389\u038a\u00bb\u038c\u00bd\u038e\u038f\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\uffff\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\u03aa\u03ab\u03ac\u03ad\u03ae\u03af\u03b0\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c2\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\u03ca\u03cb\u03cc\u03cd\u03ce\u007f\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Hebrew:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\uffff\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00d7\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00f7\u00bb\u00bc\u00bd\u00be\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u2017\u05d0\u05d1\u05d2\u05d3\u05d4\u05d5\u05d6\u05d7\u05d8\u05d9\u05da\u05db\u05dc\u05dd\u05de\u05df\u05e0\u05e1\u05e2\u05e3\u05e4\u05e5\u05e6\u05e7\u05e8\u05e9\u05ea\uffff\uffff\u200e\u200f\u007f\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Latin_5:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u011e\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u0130\u015e\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u011f\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u0131\u015f\u00ff\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Greek_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a4\u00a9\u00aa\u00ab\uffff\uffff\uffff\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00ba\u00bb\u00bc\u00bd\uffff\u00bf\u03ca\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\uffff\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\u03ac\u03ad\u03ae\u03af\uffff\u03cc\u03cb\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\uffff\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\u03c2\u03cd\u03ce\u0384\uffff\u007f\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Hebrew_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" \u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a8\u00a9\u00d7\u00ab\uffff\uffff\uffff\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00f7\u00bb\u00bc\u00bd\uffff\u00bf\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u05d0\u05d1\u05d2\u05d3\u05d4\u05d5\u05d6\u05d7\u05d8\u05d9\u05da\u05db\u05dc\u05dd\u05de\u05df\u05e0\u05e1\u05e2\u05e3\u05e4\u05e5\u05e6\u05e7\u05e8\u05e9\u05ea\uffff\uffff\uffff\uffff\u007f\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Turkish_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" \u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a8\u00a9\u00aa\u00ab\uffff\uffff\u0130\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00ba\u00bb\u00bc\u00bd\u0131\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u011e\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0152\u00d8\u00d9\u00da\u00db\u00dc\u0178\u015e\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u011f\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0153\u00f8\u00f9\u00fa\u00fb\u00fc\u00ff\u015f\u007f\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Cyrillic:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u044e\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u044f\u0440\u0441\u0442\u0443\u0436\u0432\u044c\u044b\u0437\u0448\u044d\u0449\u0447\u044a\u042e\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u042f\u0420\u0421\u0422\u0423\u0416\u0412\u042c\u042b\u0417\u0428\u042d\u0429\u0427\u042a\")\n                   [c - ' '];\n            }\n          when CSET_NRCS_Greek:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u03a7\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u039e\u03a8\u03a9\uffff\uffff{|}~\u007f\")\n                   [c - ' '];\n            }\n          when CSET_NRCS_Hebrew:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\u05d0\u05d1\u05d2\u05d3\u05d4\u05d5\u05d6\u05d7\u05d8\u05d9\u05da\u05db\u05dc\u05dd\u05de\u05df\u05e0\u05e1\u05e2\u05e3\u05e4\u05e5\u05e6\u05e7\u05e8\u05e9\u05ea{|}~\u007f\")\n                   [c - ' '];\n            }\n          when CSET_NRCS_Turkish:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" !\\\"#$%\u011f'()*+,-./0123456789:;<=>?\u0130ABCDEFGHIJKLMNOPQRSTUVWXYZ\u015e\u00d6\u00c7\u00dc_\u011eabcdefghijklmnopqrstuvwxyz\u015f\u00f6\u00e7\u00fc\u007f\")\n                   [c - ' '];\n            }\n          otherwise: ;\n        }\n\n        // Some more special graphic renderings\n        if (wc >= 0x2580 && wc <= 0x259F) {\n          // Block Elements (U+2580-U+259F)\n          // \u2580\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588\u2589\u258a\u258b\u258c\u258d\u258e\u258f\u2590\u2591\u2592\u2593\u2594\u2595\u2596\u2597\u2598\u2599\u259a\u259b\u259c\u259d\u259e\u259f\n          term.curs.attr.attr |= ((cattrflags)(wc & 0xF)) << ATTR_GRAPH_SHIFT;\n          uchar gcode = 14 + ((wc >> 4) & 1);\n          // extend graph encoding with unused font numbers\n          term.curs.attr.attr &= ~FONTFAM_MASK;\n          term.curs.attr.attr |= (cattrflags)gcode << ATTR_FONTFAM_SHIFT;\n        }\n#ifdef draw_powerline_geometric_symbols\n#warning graphical results of this approach are unpleasant; not enabled\n        else if (wc >= 0xE0B0 && wc <= 0xE0BF && wc != 0xE0B5 && wc != 0xE0B7) {\n          // draw geometric full-cell Powerline symbols,\n          // to avoid artefacts at their borders (#943)\n          term.curs.attr.attr &= ~FONTFAM_MASK;\n          term.curs.attr.attr |= (cattrflags)13 << ATTR_FONTFAM_SHIFT;\n          term.curs.attr.attr |= (cattrflags)15 << ATTR_GRAPH_SHIFT;\n        }\n#endif\n\n        // Determine width of character to be rendered\n        int width;\n        if (term.wide_indic && wc >= 0x0900 && indicwide(wc))\n          width = 2;\n        else if (term.wide_extra && wc >= 0x2000 && extrawide(wc)) {\n          width = 2;\n          // Note: this check is currently not implemented for\n          // non-BMP characters (see case if is_low_surrogate(wc) above)\n          if (win_char_width(wc, term.curs.attr.attr) < 2)\n            term.curs.attr.attr |= TATTR_EXPAND;\n        }\n        else {\n#if HAS_LOCALES\n          if (cfg.charwidth % 10)\n            width = xcwidth(wc);\n          else\n            width = wcwidth(wc);\n#ifdef support_triple_width\n          // do not handle triple-width here\n          //if (term.curs.width)\n          //  width = term.curs.width % 10;\n#endif\n# ifdef hide_isolate_marks\n          // force bidi isolate marks to be zero-width;\n          // however, this is inconsistent with locale width\n          if (wc >= 0x2066 && wc <= 0x2069)\n            width = 0;  // bidi isolate marks\n# endif\n#else\n          width = xcwidth(wc);\n#endif\n        }\n        if (width < 0 && cfg.printable_controls) {\n          if (wc >= 0x80 && wc < 0xA0)\n            width = 1;\n          else if (wc < ' ' && cfg.printable_controls > 1)\n            width = 1;\n        }\n\n        // Auto-expanded glyphs\n        if (width == 2\n            // && wcschr(W(\"\u3008\u3009\u300a\u300b\u300c\u300d\u300e\u300f\u3010\u3011\u3012\u3013\u3014\u3015\u3016\u3017\u3018\u3019\u301a\u301b\"), wc)\n            && wc >= 0x3008 && wc <= 0x301B && (wc | 1) != 0x3013\n            && win_char_width(wc, term.curs.attr.attr) < 2\n            // ensure symmetric handling of matching brackets\n            && win_char_width(wc ^ 1, term.curs.attr.attr) < 2)\n        {\n          term.curs.attr.attr |= TATTR_EXPAND;\n        }\n\n        // Control characters\n        if (wc < 0x20 || wc == 0x7F) {\n          if (!do_ctrl(wc) && c == wc) {\n            wc = cs_btowc_glyph(c);\n            if (wc != c)\n              write_ucschar(0, wc, 1);\n            else if (cfg.printable_controls > 1)\n              goto goon;\n          }\n          term.curs.attr.attr = asav;\n          continue;\n\n          goon:;\n        }\n\n        // Finally, write it and restore cursor attribute\n        write_ucschar(0, wc, width);\n        term.curs.attr.attr = asav;\n      } // end term_write switch (term.state) when NORMAL\n\n      when VT52_Y:\n        term.cmd_len = 0;\n        term_push_cmd(c);\n        term.state = VT52_X;\n\n      when VT52_X:\n        term_push_cmd(c);\n        do_vt52_move();\n\n      when VT52_FG:\n        do_vt52_colour(true, c);\n\n      when VT52_BG:\n        do_vt52_colour(false, c);\n\n      when TEK_ESCAPE:\n        tek_esc(c);\n\n      when TEK_ADDRESS0 or TEK_ADDRESS:\n        if (c < ' ')\n          tek_ctrl(c);\n        else if (tek_mode == TEKMODE_SPECIAL_PLOT && term.state == TEK_ADDRESS0) {\n          term.state = TEK_ADDRESS;\n          term.cmd_len = 0;\n          tek_intensity(c & 0x40, c & 0x37);\n        }\n        //else if (term.cmd_len > 5) {\n        // no length checking here, interferes with previous OSC!\n        // let term_push_cmd do it\n        //}\n        //else if (!(c & 0x60)) {\n        // no error checking here, let tek_address catch it\n        //}\n        else {\n          if (term.state == TEK_ADDRESS0) {\n            term.state = TEK_ADDRESS;\n            term.cmd_len = 0;\n          }\n\n          term_push_cmd(c);\n          if ((c & 0x60) == 0x40) {\n            tek_address(term.cmd_buf);\n            term.state = TEK_ADDRESS0;\n            if (tek_mode == TEKMODE_GRAPH0)\n              tek_mode = TEKMODE_GRAPH;\n          }\n        }\n\n      when TEK_INCREMENTAL:\n        if (c < ' ')\n          tek_ctrl(c);\n        else if (c == ' ' || c == 'P')\n          tek_pen(c == 'P');\n        else if (strchr(\"DEAIHJBF\", c))\n          tek_step(c);\n\n      when ESCAPE or CMD_ESCAPE:\n        if (term.vt52_mode)\n          do_vt52(c);\n        else if (c < 0x20)\n          do_ctrl(c);\n        else if (c < 0x30) {\n          //term.esc_mod = term.esc_mod ? 0xFF : c;\n          if (term.esc_mod) {\n            esc_mod0 = term.esc_mod;\n            esc_mod1 = c;\n            term.esc_mod = 0xFF;\n          }\n          else {\n            esc_mod0 = 0;\n            esc_mod1 = 0;\n            term.esc_mod = c;\n          }\n        }\n        else if (c == '\\\\' && term.state == CMD_ESCAPE) {\n          /* Process DCS or OSC sequence if we see ST. */\n          do_cmd();\n          term.state = NORMAL;\n        }\n        else {\n          do_esc(c);\n          // term.state: NORMAL/CSI_ARGS/OSC_START/DCS_START/IGNORE_STRING\n        }\n\n      when CSI_ARGS:\n        if (c < 0x20)\n          do_ctrl(c);\n        else if (c == ';') {\n          if (term.csi_argc < lengthof(term.csi_argv))\n            term.csi_argc++;\n        }\n        else if (c == ':') {\n          // support colon-separated sub parameters as specified in\n          // ISO/IEC 8613-6 (ITU Recommendation T.416)\n          uint i = term.csi_argc - 1;\n          term.csi_argv[i] |= SUB_PARS;\n          if (term.csi_argc < lengthof(term.csi_argv))\n            term.csi_argc++;\n        }\n        else if (c >= '0' && c <= '9') {\n          uint i = term.csi_argc - 1;\n          if (i < lengthof(term.csi_argv)) {\n            term.csi_argv[i] = 10 * term.csi_argv[i] + c - '0';\n            if ((int)term.csi_argv[i] < 0)\n              term.csi_argv[i] = INT_MAX;  // capture overflow\n            term.csi_argv_defined[i] = 1;\n          }\n        }\n        else if (c < 0x40) {\n          //term.esc_mod = term.esc_mod ? 0xFF : c;\n          if (term.esc_mod) {\n            esc_mod0 = term.esc_mod;\n            esc_mod1 = c;\n            term.esc_mod = 0xFF;\n          }\n          else {\n            esc_mod0 = 0;\n            esc_mod1 = 0;\n            term.esc_mod = c;\n          }\n        }\n        else {\n          do_csi(c);\n          term.state = NORMAL;\n        }\n\n      when OSC_START:\n        term.cmd_len = 0;\n        switch (c) {\n          when 'P':  /* Linux palette sequence */\n            term.state = OSC_PALETTE;\n          when 'R':  /* Linux palette reset */\n            win_reset_colours();\n            term.state = NORMAL;\n          when 'I':  /* OSC set icon file (dtterm, shelltool) */\n            term.cmd_num = 7773;\n            term.state = OSC_NUM;\n          when 'L':  /* OSC set icon label (dtterm, shelltool) */\n            term.cmd_num = 1;\n            term.state = OSC_NUM;\n          when 'l':  /* OSC set window title (dtterm, shelltool) */\n            term.cmd_num = 2;\n            term.state = OSC_NUM;\n          when '0' ... '9':  /* OSC command number */\n            term.cmd_num = c - '0';\n            term.state = OSC_NUM;\n          when ';':\n            term.cmd_num = 0;\n            term.state = CMD_STRING;\n          when '\\a':\n            term.state = NORMAL;\n          when '\\e':\n            term.state = ESCAPE;\n          when '\\n' or '\\r':\n            term.state = IGNORE_STRING;\n          otherwise:\n            term.state = IGNORE_STRING;\n        }\n\n      when OSC_NUM:\n        switch (c) {\n          when '0' ... '9':  /* OSC command number */\n            term.cmd_num = term.cmd_num * 10 + c - '0';\n            if (term.cmd_num < 0)\n              term.cmd_num = -99;  // prevent wrong valid param\n          when ';':\n            term.state = CMD_STRING;\n          when '\\a':\n            do_cmd();\n            term.state = NORMAL;\n          when '\\e':\n            term.state = CMD_ESCAPE;\n          when '\\n' or '\\r':\n            term.state = IGNORE_STRING;\n          otherwise:\n            term.state = IGNORE_STRING;\n        }\n\n      when OSC_PALETTE:\n        if (isxdigit(c)) {\n          // The dodgy Linux palette sequence: keep going until we have\n          // seven hexadecimal digits.\n          term_push_cmd(c);\n          if (term.cmd_len == 7) {\n            uint n, r, g, b;\n            sscanf(term.cmd_buf, \"%1x%2x%2x%2x\", &n, &r, &g, &b);\n            win_set_colour(n, make_colour(r, g, b));\n            term.state = NORMAL;\n          }\n        }\n        else {\n          // End of sequence. Put the character back unless the sequence was\n          // terminated properly.\n          term.state = NORMAL;\n          if (c != '\\a') {\n            pos--;\n            continue;\n          }\n        }\n\n      when CMD_STRING:\n        switch (c) {\n          when '\\a':\n            do_cmd();\n            term.state = NORMAL;\n          when '\\e':\n            term.state = CMD_ESCAPE;\n          when '\\n' or '\\r':\n            // accept new lines in OSC strings\n            if (term.cmd_num != 1337)\n              term_push_cmd(c);\n            // else ignore new lines in base64-encoded images\n          otherwise:\n            term_push_cmd(c);\n        }\n\n      when IGNORE_STRING:\n        switch (c) {\n          when '\\a':\n            term.state = NORMAL;\n          when '\\e':\n            term.state = ESCAPE;\n          when '\\n' or '\\r':\n            // keep IGNORE_STRING\n            ;\n        }\n\n      when DCS_START:\n        term.cmd_num = -1;\n        term.cmd_len = 0;\n        term.dcs_cmd = 0;\n        switch (c) {\n          when '@' ... '~':  /* DCS cmd final byte */\n            term.dcs_cmd = c;\n            do_dcs();\n            term.state = DCS_PASSTHROUGH;\n          when '\\e':\n            term.state = DCS_ESCAPE;\n          when '0' ... '9':  /* DCS parameter */\n            term.state = DCS_PARAM;\n          when ';':          /* DCS separator */\n            term.state = DCS_PARAM;\n          when ':':\n            term.state = DCS_IGNORE;\n          when '<' ... '?':\n            term.dcs_cmd = c;\n            term.state = DCS_PARAM;\n          when ' ' ... '/':  /* DCS intermediate byte */\n            term.dcs_cmd = c;\n            term.state = DCS_INTERMEDIATE;\n          otherwise:\n            term.state = DCS_IGNORE;\n        }\n\n      when DCS_PARAM:\n        switch (c) {\n          when '@' ... '~':  /* DCS cmd final byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            do_dcs();\n            term.state = DCS_PASSTHROUGH;\n          when '\\e':\n            term.state = DCS_ESCAPE;\n            term.esc_mod = 0;\n          when '0' ... '9' or ';' or ':':  /* DCS parameter */\n            term.state = DCS_PARAM;\n          when '<' ... '?':\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            term.state = DCS_PARAM;\n          when ' ' ... '/':  /* DCS intermediate byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            term.state = DCS_INTERMEDIATE;\n          otherwise:\n            term.state = DCS_IGNORE;\n        }\n\n      when DCS_INTERMEDIATE:\n        switch (c) {\n          when '@' ... '~':  /* DCS cmd final byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            do_dcs();\n            term.state = DCS_PASSTHROUGH;\n          when '\\e':\n            term.state = DCS_ESCAPE;\n            term.esc_mod = 0;\n          when '0' ... '?':  /* DCS parameter byte */\n            term.state = DCS_IGNORE;\n          when ' ' ... '/':  /* DCS intermediate byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n          otherwise:\n            term.state = DCS_IGNORE;\n        }\n\n      when DCS_PASSTHROUGH:\n        switch (c) {\n          when '\\e':\n            term.state = DCS_ESCAPE;\n            term.esc_mod = 0;\n          otherwise:\n            if (!term_push_cmd(c)) {\n              do_dcs();\n              term.cmd_buf[0] = c;\n              term.cmd_len = 1;\n            }\n        }\n\n      when DCS_IGNORE:\n        switch (c) {\n          when '\\e':\n            term.state = ESCAPE;\n            term.esc_mod = 0;\n        }\n\n      when DCS_ESCAPE:\n        if (c < 0x20) {\n          do_ctrl(c);\n          term.state = NORMAL;\n        } else if (c < 0x30) {\n          term.esc_mod = term.esc_mod ? 0xFF : c;\n          term.state = ESCAPE;\n        } else if (c == '\\\\') {\n          /* Process DCS sequence if we see ST. */\n          do_dcs();\n          term.state = NORMAL;\n        } else {\n          term.state = ESCAPE;\n          term.imgs.parser_state = NULL;\n          do_esc(c);\n        }\n    }\n  }\n\n  if (term.ring_enabled && term.curs.y != oldy)\n    term.ring_enabled = false;\n\n  if (cfg.ligatures_support > 1) {\n    // refresh ligature rendering in old cursor line\n    term_invalidate(0, oldy, term.cols - 1, oldy);\n  }\n\n  // Update search match highlighting\n  //term_schedule_search_partial_update();\n  term_schedule_search_update();\n\n  // Update screen\n  win_schedule_update();\n\n  // Print\n  if (term.printing) {\n    printer_write(term.printbuf, term.printbuf_pos);\n    term.printbuf_pos = 0;\n  }\n}\n\n/* Empty the input buffer */\nvoid\nterm_flush(void)\n{\n  if (term.suspbuf) {\n    term_do_write(term.suspbuf, term.suspbuf_pos);\n    free(term.suspbuf);\n    term.suspbuf = 0;\n    term.suspbuf_pos = 0;\n    term.suspbuf_size = 0;\n  }\n}\n\nvoid\nterm_write(const char *buf, uint len)\n{\n /*\n    During drag-selects, some people do not wish to process terminal output,\n    because the user may want the screen to hold still to be selected.\n    Therefore, we maintain a suspend-output-on-selection buffer which \n    can grow up to a configurable size.\n  */\n  if (term_selecting() && cfg.suspbuf_max > 0) {\n    // if buffer size would be exceeded, flush; prevent uint overflow\n    if (len > cfg.suspbuf_max - term.suspbuf_pos)\n      term_flush();\n    // if buffer length does not exceed max size, append output\n    if (len <= cfg.suspbuf_max - term.suspbuf_pos) {\n      // make sure buffer is large enough\n      if (term.suspbuf_pos + len > term.suspbuf_size) {\n        term.suspbuf_size = term.suspbuf_pos + len;\n        term.suspbuf = renewn(term.suspbuf, term.suspbuf_size);\n      }\n      memcpy(term.suspbuf + term.suspbuf_pos, buf, len);\n      term.suspbuf_pos += len;\n      return;\n    }\n    // if we cannot buffer, output directly;\n    // in this case, we've either flushed already or didn't need to\n  }\n\n  term_do_write(buf, len);\n}\n\n"], "fixing_code": ["// termout.c (part of mintty)\n// Copyright 2008-12 Andy Koppe, 2017-20 Thomas Wolff\n// Adapted from code from PuTTY-0.60 by Simon Tatham and team.\n// Licensed under the terms of the GNU General Public License v3 or later.\n\n#include \"termpriv.h\"\n#include \"winpriv.h\"  // colours, win_get_font, win_change_font, win_led, win_set_scrollview\n\n#include \"win.h\"\n#include \"appinfo.h\"\n#include \"charset.h\"\n#include \"child.h\"\n#include \"print.h\"\n#include \"sixel.h\"\n#include \"winimg.h\"\n#include \"tek.h\"\n#include \"base64.h\"\n#include \"unicodever.t\"\n\n#include <termios.h>\n#include <sys/time.h>\n\n#define TERM_CMD_BUF_INC_STEP 128\n#define TERM_CMD_BUF_MAX_SIZE (1024 * 1024)\n\n#define SUB_PARS (1 << (sizeof(*term.csi_argv) * 8 - 1))\n\n/* This combines two characters into one value, for the purpose of pairing\n * any modifier byte and the final byte in escape sequences.\n */\n#define CPAIR(x, y) ((x) << 8 | (y))\n\nstatic string primary_da1 = \"\\e[?1;2c\";\nstatic string primary_da2 = \"\\e[?62;1;2;4;6;9;15;22;29c\";\nstatic string primary_da3 = \"\\e[?63;1;2;4;6;9;15;22;29c\";\nstatic string primary_da4 = \"\\e[?64;1;2;4;6;9;15;21;22;28;29c\";\nstatic string primary_da5 = \"\\e[?65;1;2;4;6;9;15;21;22;28;29c\";\n/* Registered Extensions to the Character Cell Display Service Class\n\t1\t132 Column Display\n\t2\tPrinter Port\n\t3\tReGIS Display\n\t4\tSixels Display\n\t6\tSelectively Erasable Characters\n\t9\tNational Replacement Character Sets\n\t15\tTechnical Character Set\n\t21\tHorizontal Scrolling\n\t22\tColor Text\n\t28\tRectangular Editing\n\t29\tText Locator\n*/\n\n\nstatic bool\nterm_push_cmd(char c)\n{\n  uint new_size;\n\n  /* Need 1 more for null byte */\n  if (term.cmd_len + 1 < term.cmd_buf_cap) {\n    term.cmd_buf[term.cmd_len++] = c;\n    term.cmd_buf[term.cmd_len] = 0;\n    return true;\n  }\n\n  if (term.cmd_buf_cap >= TERM_CMD_BUF_MAX_SIZE) {\n    /* Server sends too many cmd characters */\n    return false;\n  }\n  new_size = term.cmd_buf_cap + TERM_CMD_BUF_INC_STEP;\n  if (new_size >= TERM_CMD_BUF_MAX_SIZE) {\n    // cosmetic limitation (relevant limitation above)\n    new_size = TERM_CMD_BUF_MAX_SIZE;\n  }\n  term.cmd_buf = renewn(term.cmd_buf, new_size);\n  term.cmd_buf_cap = new_size;\n  term.cmd_buf[term.cmd_len++] = c;\n  term.cmd_buf[term.cmd_len] = 0;\n  return true;\n}\n\nstatic void\nenable_progress(void)\n{\n  term.lines[term.curs.y]->lattr |= LATTR_PROGRESS;\n}\n\n/*\n * Move the cursor to a given position, clipping at boundaries.\n * We may or may not want to clip at the scroll margin: marg_clip is\n * 0 not to,\n * 1 to disallow _passing_ the margins, and\n * 2 to disallow even _being_ outside the margins.\n */\nstatic void\nmove(int x, int y, int marg_clip)\n{\n  term_cursor *curs = &term.curs;\n\n  if (marg_clip) {\n    if ((curs->y >= term.marg_top || marg_clip == 2) && y < term.marg_top)\n      y = term.marg_top;\n    if ((curs->y <= term.marg_bot || marg_clip == 2) && y > term.marg_bot)\n      y = term.marg_bot;\n    if ((curs->x >= term.marg_left || marg_clip == 2) && x < term.marg_left)\n      x = term.marg_left;\n    if ((curs->x <= term.marg_right || marg_clip == 2) && x > term.marg_right)\n      x = term.marg_right;\n  }\n\n  if (x < 0)\n    x = 0;\n  if (x >= term.cols)\n    x = term.cols - 1;\n  if (y < 0)\n    y = 0;\n  if (y >= term.rows)\n    y = term.rows - 1;\n\n  curs->x = x;\n  curs->y = y;\n  curs->wrapnext = false;\n}\n\n/*\n * Save the cursor and SGR mode.\n */\nstatic void\nsave_cursor(void)\n{\n  term.saved_cursors[term.on_alt_screen] = term.curs;\n}\n\n/*\n * Restore the cursor and SGR mode.\n */\nstatic void\nrestore_cursor(void)\n{\n  term_cursor *curs = &term.curs;\n  *curs = term.saved_cursors[term.on_alt_screen];\n  term.erase_char.attr = curs->attr;\n  term.erase_char.attr.attr &= (ATTR_FGMASK | ATTR_BGMASK);\n  term.erase_char.attr.attr |= TATTR_CLEAR;\n\n /* Make sure the window hasn't shrunk since the save */\n  if (curs->x >= term.cols)\n    curs->x = term.cols - 1;\n  if (curs->y >= term.rows)\n    curs->y = term.rows - 1;\n\n /* In origin mode, make sure the cursor position is within margins */\n  if (curs->origin) {\n    if (curs->x < term.marg_left)\n      curs->x = term.marg_left;\n    else if (curs->x > term.marg_right)\n      curs->x = term.marg_right;\n    if (curs->y < term.marg_top)\n      curs->y = term.marg_top;\n    else if (curs->y > term.marg_bot)\n      curs->y = term.marg_bot;\n  }\n\n /*\n  * wrapnext might reset to False \n  * if the x position is no longer at the rightmost edge.\n  */\n  if (curs->wrapnext && curs->x < term.cols - 1 && curs->x != term.marg_right)\n    curs->wrapnext = false;\n\n  term_update_cs();\n}\n\n/*\n * Insert or delete characters within the current line.\n * n is +ve if insertion is desired, and -ve for deletion.\n */\nstatic void\ninsert_char(int n)\n{\n  if (term.curs.x < term.marg_left || term.curs.x > term.marg_right)\n    return;\n\n  bool del = n < 0;\n  int m;\n  term_cursor *curs = &term.curs;\n  termline *line = term.lines[curs->y];\n  int cols = min(line->cols, line->size);\n  cols = min(cols, term.marg_right + 1);\n\n  n = (n < 0 ? -n : n);\n  if (n > cols - curs->x)\n    n = cols - curs->x;\n  m = cols - curs->x - n;\n  term_check_boundary(curs->x, curs->y);\n  term_check_boundary(curs->x + m, curs->y);\n  if (del) {\n    for (int j = 0; j < m; j++)\n      move_termchar(line, line->chars + curs->x + j,\n                    line->chars + curs->x + j + n);\n    while (n--)\n      line->chars[curs->x + m++] = term.erase_char;\n  }\n  else {\n    for (int j = m; j--;)\n      move_termchar(line, line->chars + curs->x + j + n,\n                    line->chars + curs->x + j);\n    while (n--)\n      line->chars[curs->x + n] = term.erase_char;\n  }\n}\n\nstatic int\ncharwidth(xchar chr)\n{\n#if HAS_LOCALES\n  if (cfg.charwidth % 10)\n    return xcwidth(chr);\n  else\n    if (chr > 0xFFFF)\n      return wcswidth((wchar[]){high_surrogate(chr), low_surrogate(chr)}, 2);\n    else\n      return wcwidth(chr);\n#else\n  return xcwidth(chr);\n#endif\n}\n\nstatic void\nattr_rect(cattrflags add, cattrflags sub, cattrflags xor, short y0, short x0, short y1, short x1)\n{\n  //printf(\"attr_rect %d,%d..%d,%d +%llX -%llX ^%llX\\n\", y0, x0, y1, x1, add, sub, xor);\n  y0--; x0--; y1--; x1--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n  //printf(\"%d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  for (int y = y0; y <= y1; y++) {\n    termline * l = term.lines[y];\n    int xl = x0;\n    int xr = x1;\n    if (!term.attr_rect) {\n      if (y != y0)\n        xl = term.marg_left;\n      if (y != y1)\n        xr = term.marg_right;\n    }\n    for (int x = xl; x <= xr; x++) {\n      //printf(\"attr %d:%d\\n\", y, x);\n      cattrflags ca = l->chars[x].attr.attr;\n      ca ^= xor;\n      ca &= ~sub;\n      ca |= add;\n      if (ca != l->chars[x].attr.attr) {\n        if (x == xl)\n          term_check_boundary(x, y);\n        if (x == xr)\n          term_check_boundary(x + 1, y);\n      }\n      l->chars[x].attr.attr = ca;\n    }\n  }\n}\n\n//static void write_char(wchar c, int width);\nstatic void term_do_write(const char *buf, uint len);\n\nstatic void\nfill_rect(xchar chr, cattr attr, bool sel, short y0, short x0, short y1, short x1)\n{\n  //printf(\"fill_rect %d,%d..%d,%d\\n\", y0, x0, y1, x1);\n  int width = charwidth(chr);\n  if (chr == UCSWIDE || width < 1)\n    return;\n  wchar low = 0;\n  if (chr > 0xFFFF) {\n    low = low_surrogate(chr);\n    chr = high_surrogate(chr);\n  }\n\n  y0--; x0--; y1--; x1--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n  //printf(\"%d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  //printf(\"gl %d gr %d csets %d %d %d %d /%d sup %d acs %d\\n\", term.curs.gl, term.curs.gr, term.curs.csets[0], term.curs.csets[1], term.curs.csets[2], term.curs.csets[3], term.curs.cset_single, term.curs.decsupp, term.curs.oem_acs);\n  if ((chr > ' ' && chr < 0x80 \n       && (term.curs.csets[term.curs.gl] != CSET_ASCII\n           ||\n           term.curs.cset_single != CSET_ASCII\n          )\n      )\n      ||\n      (chr >= 0x80 && chr < 0x100 \n       && ((term.curs.gr && term.curs.csets[term.curs.gr] != CSET_ASCII)\n           || term.curs.oem_acs\n          )\n      )\n      || (chr >= 0x2580 && chr <= 0x259F)\n     )\n  {\n    term_cursor csav = term.curs;\n    term.curs.attr = attr;\n#ifdef debug_FRA_special\n    // make this code branch visible\n    term.curs.attr.attr &= ~ATTR_FGMASK;\n    term.curs.attr.attr |= RED_I << ATTR_FGSHIFT;\n#endif\n    term.curs.width = 1;\n    if (!(width < 2 || (cs_ambig_wide && is_ambig(chr))))\n      term.curs.attr.attr |= TATTR_CLEAR | TATTR_NARROW;\n    term.state = NORMAL;\n\n    char * cbuf = 0;\n    if (chr > 0xFF) {\n      wchar * wc = (wchar[]){chr, low, 0};\n      cbuf = cs__wcstombs(wc);\n    }\n    for (int y = y0; y <= y1; y++) {\n      term.curs.y = y;\n      for (int x = x0; x <= x1; x++) {\n        term.curs.x = x;\n        term.curs.cset_single = csav.cset_single;\n        if (chr > 0xFF) {\n          //write_char(chr, 1); // would skip NRCS handling in term_do_write\n          term_do_write(cbuf, strlen(cbuf));\n        }\n        else {\n          char c = chr;\n          term_do_write(&c, 1);\n        }\n      }\n    }\n    if (cbuf)\n      free(cbuf);\n\n    term.curs = csav;\n    term.curs.cset_single = CSET_ASCII;\n    return;\n  }\n\n  if (width > 1)\n    attr.attr |= TATTR_CLEAR | TATTR_NARROW;\n\n  for (int y = y0; y <= y1; y++) {\n    termline * l = term.lines[y];\n    bool prevprot = true;  // not false!\n    for (int x = x0; x <= x1; x++) {\n      //printf(\"fill %d:%d\\n\", y, x);\n      bool prot = sel && l->chars[x].attr.attr & ATTR_PROTECTED;\n      if (prot != prevprot) {\n        // |P not here, no check\n        // |N check\n        // NP check only current position\n        // PN check\n        if (!prot) {  // includes the case x == x0\n          // clear previous half of wide char, even if protected\n          term_check_boundary(x0, y);\n        }\n        else if (l->chars[x].chr == UCSWIDE) {\n          // clear right half of wide char, even if protected;\n          // calling term_check_boundary would overwrite previous fill char\n          clear_cc(l, x);\n          l->chars[x].chr = ' ';\n        }\n      }\n      // clear wide char on right area border unless protected\n      if (!prot && x == x1)\n        term_check_boundary(x1 + 1, y);\n      prevprot = prot;\n\n      if (!sel || !prot) {\n        clear_cc(l, x);\n        l->chars[x].chr = chr;\n        l->chars[x].attr = attr;\n        if (low)\n          add_cc(l, x, low, attr);\n      }\n    }\n  }\n}\n\nstatic void\ncopy_rect(short y0, short x0, short y1, short x1, short y2, short x2)\n{\n  //printf(\"copy_rect %d,%d..%d,%d -> %d,%d\\n\", y0, x0, y1, x1, y2, x2);\n  y0--; x0--; y1--; x1--; y2--; x2--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n    y2 += term.marg_top;\n    x2 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n\n  if (y2 < 0)\n    y2 = 0;\n  if (x2 < 0)\n    x2 = 0;\n  if (y2 + y1 - y0 >= term.rows)\n    y1 = term.rows + y0 - y2 - 1;\n  if (x2 + x1 - x0 >= term.cols)\n    x1 = term.cols + x0 - x2 - 1;\n  //printf(\"%d,%d..%d,%d -> %d,%d\\n\", y0, x0, y1, x1, y2, x2);\n\n  bool down = y2 > y0;\n  bool left = x2 > x0;\n  for (int y = down ? y1 : y0; down ? y >= y0 : y <= y1; down ? y-- : y++) {\n    termline * src = term.lines[y];\n    termline * dst = term.lines[y + y2 - y0];\n    term_check_boundary(x2, y + y2 - y0);\n    term_check_boundary(x2 + x1 - x0 + 1, y + y2 - y0);\n    for (int x = left ? x1 : x0; left ? x >= x0 : x <= x1; left ? x-- : x++) {\n      copy_termchar(dst, x + x2 - x0, &src->chars[x]);\n      //printf(\"copy %d:%d -> %d:%d\\n\", y, x, y + y2 - y0, x + x2 - x0);\n      if ((x == x0 && src->chars[x].chr == UCSWIDE)\n       || (x == x1 && charwidth(src->chars[x].chr) != 1)\n         )\n      {\n        clear_cc(dst, x);\n        dst->chars[x].chr = ' ';\n      }\n    }\n  }\n}\n\nvoid\nscroll_rect(int topline, int botline, int lines)\n{\n  //printf(\"scroll_rect %d..%d %s%d\\n\", topline, botline, lines > 0 ? \"+\" : \"\", lines);\n  int y0, y1, y2, e0, e1;\n  if (lines < 0) {  // downwards\n//\tscroll\t\tcopy\t\tclear\n//\t4\t-2\t4\t6\t4\n//\t20\t\t18\t\t5\n    if (topline - lines > term.marg_bot + 1)\n      lines = topline - term.marg_bot - 1;\n    y0 = topline;\n    y1 = botline + lines;\n    y2 = topline - lines;\n    e0 = y0;\n    e1 = y0 - lines - 1;\n  }\n  else {\n//\tscroll\t\tcopy\t\tclear\n//\t4\t+2\t6\t4\t19\n//\t20\t\t20\t\t20\n    if (topline + lines > term.marg_bot + 1)\n      lines = term.marg_bot + 1 - topline;\n    y0 = topline + lines;\n    y1 = botline;\n    y2 = topline;\n    e0 = y1 - lines + 1;\n    e1 = y1;\n  }\n  y0++; y1++; y2++; e0++; e1++;\n  int xl = term.marg_left + 1;\n  int xr = term.marg_right + 1;\n  if (term.curs.origin) {\n    // compensate for the originmode applied in the functions called below\n    xl = 1;\n    xr = term.marg_right - term.marg_left + 1;\n    y0 -= term.marg_top;\n    y1 -= term.marg_top;\n    y2 -= term.marg_top;\n    e0 -= term.marg_top;\n    e1 -= term.marg_top;\n  }\n  copy_rect(y0, xl, y1, xr, y2, xl);\n  fill_rect(' ', term.curs.attr, false, e0, xl, e1, xr);\n}\n\nstatic void\ninsdel_column(int col, bool del, int n)\n{\n  //printf(\"insdel_column @%d %d marg %d..%d\\n\", col, n, term.marg_left, term.marg_right);\n  int x0, x1, x2, e0, e1;\n  if (del) {\n    x0 = col + n;\n    x1 = term.marg_right;\n    x2 = col;\n    e0 = term.marg_right - n + 1;\n    e1 = term.marg_right;\n    if (x0 > term.marg_right) {\n      x0 = term.marg_right;\n      e0 = col;\n    }\n  }\n  else {\n    if (col + n > term.marg_right + 1)\n      n = term.marg_right + 1 - col;\n    x0 = col;\n    x1 = term.marg_right - n;\n    x2 = col + n;\n    e0 = col;\n    e1 = col + n - 1;\n  }\n  x0++; x1++; x2++; e0++; e1++;\n  int yt = term.marg_top + 1;\n  int yb = term.marg_bot + 1;\n  if (term.curs.origin) {\n    // compensate for the originmode applied in the functions called below\n    yt = 1;\n    yb = term.marg_bot - term.marg_top + 1;\n    x0 -= term.marg_left;\n    x1 -= term.marg_left;\n    x2 -= term.marg_left;\n    e0 -= term.marg_left;\n    e1 -= term.marg_left;\n  }\n  copy_rect(yt, x0, yb, x1, yt, x2);\n  fill_rect(' ', term.curs.attr, false, yt, e0, yb, e1);\n}\n\nstatic uint\nsum_rect(short y0, short x0, short y1, short x1)\n{\n  //printf(\"sum_rect %d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  y0--; x0--; y1--; x1--;\n\n  if (term.curs.origin) {\n    y0 += term.marg_top;\n    x0 += term.marg_left;\n    y1 += term.marg_top;\n    x1 += term.marg_left;\n  }\n  if (y0 < 0)\n    y0 = 0;\n  if (x0 < 0)\n    x0 = 0;\n  if (y1 >= term.rows)\n    y1 = term.rows - 1;\n  if (x1 >= term.cols)\n    x1 = term.cols - 1;\n  //printf(\"%d,%d..%d,%d\\n\", y0, x0, y1, x1);\n\n  uint sum = 0;\n  for (int y = y0; y <= y1; y++) {\n    termline * line = term.lines[y];\n    for (int x = x0; x <= x1; x++) {\n      //printf(\"add %d:%d\\n\", y, x);\n      if (line->chars[x].chr == UCSWIDE) {\n      }\n      else {\n        sum += line->chars[x].chr;  // xterm default would mask & 0xFF\n        cattrflags attr = line->chars[x].attr.attr;\n        if (attr & ATTR_UNDER)\n          sum += 0x10;\n        else if (attr & ATTR_REVERSE)\n          sum += 0x20;\n        else if (attr & ATTR_BLINK)\n          sum += 0x40;\n        else if (attr & ATTR_BOLD)\n          sum += 0x80;\n        int xc = x;\n        while (line->chars[xc].cc_next) {\n          xc += line->chars[xc].cc_next;\n          sum += line->chars[xc].chr & 0xFF;\n        }\n      }\n    }\n  }\n  return sum;\n}\n\n\nstatic void\nwrite_bell(void)\n{\n  if (cfg.bell_flash)\n    term_schedule_vbell(false, 0);\n  win_bell(&cfg);\n}\n\nstatic void\nwrite_backspace(void)\n{\n  term_cursor *curs = &term.curs;\n  if (curs->x == term.marg_left && curs->y == term.marg_top\n      && term.rev_wrap && !cfg.old_wrapmodes\n     )\n  {\n    curs->y = term.marg_bot;\n    curs->x = term.marg_right;\n  }\n  else if (curs->x == 0 && (curs->y == term.marg_top || !term.autowrap\n                       || (!cfg.old_wrapmodes && !term.rev_wrap)))\n    /* skip */;\n  else if (curs->x == term.marg_left && curs->y > term.marg_top) {\n    curs->y--;\n    curs->x = term.marg_right;\n  }\n  else if (curs->wrapnext) {\n    curs->wrapnext = false;\n    if (!term.rev_wrap && !cfg.old_wrapmodes)\n      curs->x--;\n  }\n  else if (curs->x > 0 && curs->x != term.marg_left)\n    curs->x--;\n}\n\nstatic void\nwrite_tab(void)\n{\n  term_cursor *curs = &term.curs;\n\n  int last = -1;\n  do {\n    if (curs->x == term.marg_right)\n      break;\n    last = curs->x;\n    if (term.lines[curs->y]->chars[last].chr == ' '\n        && (term.lines[curs->y]->chars[last].attr.attr & TATTR_CLEAR)\n       )\n      term.lines[curs->y]->chars[last].attr.attr |= ATTR_DIM;\n    curs->x++;\n  } while (curs->x < term.cols - 1 && !term.tabs[curs->x]);\n  if (last >= 0\n      && term.lines[curs->y]->chars[last].chr == ' '\n      && (term.lines[curs->y]->chars[last].attr.attr & TATTR_CLEAR)\n     )\n    term.lines[curs->y]->chars[last].attr.attr |= ATTR_BOLD;\n\n  if ((term.lines[curs->y]->lattr & LATTR_MODE) != LATTR_NORM) {\n    if (curs->x >= term.cols / 2)\n      curs->x = term.cols / 2 - 1;\n  }\n  else {\n    if (curs->x >= term.cols)\n      curs->x = term.cols - 1;\n  }\n}\n\nstatic void\nwrite_return(void)\n{\n  term.curs.wrapnext = false;\n  if (term.curs.x < term.marg_left)\n    term.curs.x = 0;\n  else\n    term.curs.x = term.marg_left;\n  enable_progress();\n}\n\nstatic void\nwrite_linefeed(void)\n{\n  term_cursor *curs = &term.curs;\n  if (curs->x < term.marg_left || curs->x > term.marg_right)\n    return;\n\n  clear_wrapcontd(term.lines[curs->y], curs->y);\n  if (curs->y == term.marg_bot)\n    term_do_scroll(term.marg_top, term.marg_bot, 1, true);\n  else if (curs->y < term.rows - 1)\n    curs->y++;\n  curs->wrapnext = false;\n}\n\nstatic void\nwrite_primary_da(void)\n{\n  string primary_da = primary_da4;\n  char * vt = strstr(cfg.term, \"vt\");\n  if (vt) {\n    unsigned int ver;\n    if (sscanf(vt + 2, \"%u\", &ver) == 1) {\n      if (ver >= 500)\n        primary_da = primary_da5;\n      else if (ver >= 400)\n        primary_da = primary_da4;\n      else if (ver >= 300)\n        primary_da = primary_da3;\n      else if (ver >= 200)\n        primary_da = primary_da2;\n      else\n        primary_da = primary_da1;\n    }\n  }\n  child_write(primary_da, strlen(primary_da));\n}\n\nstatic wchar last_high = 0;\nstatic wchar last_char = 0;\nstatic int last_width = 0;\ncattr last_attr = {.attr = ATTR_DEFAULT,\n                   .truefg = 0, .truebg = 0, .ulcolr = (colour)-1};\n\nstatic void\nwrite_char(wchar c, int width)\n{\n  //if (kb_trace) printf(\"[%ld] write_char 'q'\\n\", mtime());\n\n  if (tek_mode) {\n    tek_write(c, width);\n    return;\n  }\n\n  if (!c)\n    return;\n\n  term_cursor * curs = &term.curs;\n  termline * line = term.lines[curs->y];\n\n  // support non-BMP for the REP function;\n  // this is a hack, it would be cleaner to fold the term_write block\n  //   switch (term.state) when NORMAL:\n  // and repeat that\n  if (width == -1) {  // low surrogate\n    last_high = last_char;\n  }\n  else {\n    last_high = 0;\n    last_width = width;\n  }\n  last_char = c;\n  last_attr = curs->attr;\n\n  void wrapparabidi(ushort parabidi, termline * line, int y)\n  {\n    line->lattr = (line->lattr & ~LATTR_BIDIMASK) | parabidi | LATTR_WRAPCONTD;\n\n#ifdef determine_parabidi_during_output\n    if (parabidi & (LATTR_BIDISEL | LATTR_AUTOSEL))\n      return;\n\n    // if direction autodetection pending:\n    // from current line, extend backward and forward to adjust \n    // \"paragraph\" bidi attributes (esp. direction) to wrapped lines\n    termline * paraline = line;\n    int paray = y;\n    while ((paraline->lattr & LATTR_WRAPCONTD) && paray > -sblines()) {\n      paraline = fetch_line(--paray);\n      paraline->lattr = (paraline->lattr & ~LATTR_BIDIMASK) | parabidi;\n      release_line(paraline);\n    }\n    paraline = line;\n    paray = y;\n    while ((paraline->lattr & LATTR_WRAPPED) && paray < term.rows) {\n      paraline = fetch_line(++paray);\n      paraline->lattr = (paraline->lattr & ~LATTR_BIDIMASK) | parabidi;\n      release_line(paraline);\n    }\n#else\n    (void)y;\n#endif\n  }\n\n  void put_char(wchar c)\n  {\n    if (term.ring_enabled && curs->x == term.marg_right + 1 - 8) {\n      win_margin_bell(&cfg);\n      term.ring_enabled = false;\n    }\n\n    clear_cc(line, curs->x);\n    line->chars[curs->x].chr = c;\n    line->chars[curs->x].attr = curs->attr;\n#ifdef insufficient_approach\n#warning this does not help when scrolling via rectangular copy\n    if (term.lrmargmode)\n      line->lattr &= ~LATTR_MODE;\n#endif\n    if (!(line->lattr & LATTR_WRAPCONTD))\n      line->lattr = (line->lattr & ~LATTR_BIDIMASK) | curs->bidimode;\n    //TODO: if changed, propagate mode onto paragraph\n    if (cfg.ligatures_support)\n      term_invalidate(0, curs->y, curs->x, curs->y);\n  }\n\n  if (curs->wrapnext && term.autowrap && width > 0) {\n    line->lattr |= LATTR_WRAPPED;\n    line->wrappos = curs->x;\n    ushort parabidi = getparabidi(line);\n    if (curs->y == term.marg_bot)\n      term_do_scroll(term.marg_top, term.marg_bot, 1, true);\n    else if (curs->y < term.rows - 1)\n      curs->y++;\n    curs->x = term.marg_left;\n    curs->wrapnext = false;\n    line = term.lines[curs->y];\n    wrapparabidi(parabidi, line, curs->y);\n  }\n\n  bool overstrike = false;\n  if (curs->attr.attr & ATTR_OVERSTRIKE) {\n    width = 0;\n    overstrike = true;\n    curs->wrapnext = false;\n  }\n\n  bool single_width = false;\n\n  // adjust to explicit width attribute; not for combinings and low surrogates\n  if (curs->width && width > 0) {\n    //if ((c & 0xFFF) == 0x153) printf(\"%llX %d\\n\", curs->attr.attr, width);\n    if (curs->width == 1) {\n      if (!(width < 2 || (cs_ambig_wide && is_ambig(c))))\n        curs->attr.attr |= TATTR_CLEAR | TATTR_NARROW;\n      width = 1;\n    }\n    else if (curs->width == 11) {\n      if (width > 1) {\n        if (!(cs_ambig_wide && is_ambig(c))) {\n          single_width = true;\n          curs->attr.attr |= TATTR_SINGLE;\n        }\n        width = 1;\n      }\n    }\n    else if (curs->width == 2) {\n      if (width < 2) {\n        curs->attr.attr |= TATTR_EXPAND;\n        width = 2;\n      }\n    }\n#ifdef support_triple_width\n    else if (curs->width == 3) {\n      if (width < 2 || (cs_ambig_wide && is_ambig(c)))\n        curs->attr.attr |= TATTR_EXPAND;\n#define TATTR_TRIPLE 0x0080000000000000u\n      curs->attr.attr |= TATTR_TRIPLE;\n      width = 3;\n    }\n#endif\n  }\n\n#ifdef enforce_ambiguous_narrow_here\n  // enforce ambiguous-narrow as configured or for WSL;\n  // this could be done here but is now sufficiently achieved in charset.c\n  if (cs_ambig_narrow && width > 1 && is_ambig(c))\n    width = 1;\n#endif\n\n  if (cfg.charwidth >= 10 || cs_single_forced) {\n    if (width > 1) {\n      single_width = true;\n      width = 1;\n    }\n    else if (is_wide(c) || (cs_ambig_wide && is_ambig(c))) {\n      single_width = true;\n    }\n  }\n\n  if (term.insert && width > 0)\n    insert_char(width);\n\n  switch (width) {\n    when 1:  // Normal character.\n      term_check_boundary(curs->x, curs->y);\n      term_check_boundary(curs->x + 1, curs->y);\n      put_char(c);\n      if (single_width)\n        line->chars[curs->x].attr.attr |= TATTR_SINGLE;\n    when 2 or 3:  // Double-width char (Triple-width was an experimental option).\n     /*\n      * If we're about to display a double-width character \n      * starting in the rightmost column, \n      * then we do something special instead.\n      * We must print a space in the last column of the screen, then wrap;\n      * and we also set LATTR_WRAPPED2 which instructs subsequent \n      * cut-and-pasting not only to splice this line to the one after it, \n      * but to ignore the space in the last character position as well.\n      * (Because what was actually output to the terminal was presumably \n      * just a sequence of CJK characters, and we don't want a space to be\n      * pasted in the middle of those just because they had the misfortune \n      * to start in the wrong parity column. xterm concurs.)\n      */\n      term_check_boundary(curs->x, curs->y);\n      term_check_boundary(curs->x + width, curs->y);\n      if (curs->x == term.marg_right || curs->x == term.cols - 1) {\n        line->chars[curs->x] = term.erase_char;\n        line->lattr |= LATTR_WRAPPED | LATTR_WRAPPED2;\n        line->wrappos = curs->x;\n        ushort parabidi = getparabidi(line);\n        if (curs->y == term.marg_bot)\n          term_do_scroll(term.marg_top, term.marg_bot, 1, true);\n        else if (curs->y < term.rows - 1)\n          curs->y++;\n        curs->x = term.marg_left;\n        line = term.lines[curs->y];\n        wrapparabidi(parabidi, line, curs->y);\n       /* Now we must term_check_boundary again, of course. */\n        term_check_boundary(curs->x, curs->y);\n        term_check_boundary(curs->x + width, curs->y);\n      }\n      put_char(c);\n      curs->x++;\n      put_char(UCSWIDE);\n#ifdef support_triple_width\n      if (width > 2) {\n        for (int i = 2; i < width; i++) {\n          curs->x++;\n          put_char(UCSWIDE);\n        }\n      }\n#endif\n    when 0 or -1:  // Combining character or Low surrogate.\n#ifdef debug_surrogates\n      printf(\"write_char %04X %2d %08llX\\n\", c, width, curs->attr.attr);\n#endif\n      if (curs->x > 0 || overstrike) {\n       /* If we're in wrapnext state, the character\n        * to combine with is _here_, not to our left. */\n        int x = curs->x - !curs->wrapnext;\n       /* Same if we overstrike an actually not combining character. */\n        if (overstrike)\n          x = curs->x;\n       /*\n        * If the previous character is UCSWIDE, back up another one.\n        */\n        if (line->chars[x].chr == UCSWIDE) {\n          assert(x > 0);\n          x--;\n        }\n       /* Try to precompose with the cell's base codepoint */\n        wchar pc;\n        if (termattrs_equal_fg(&line->chars[x].attr, &curs->attr))\n          pc = win_combine_chars(line->chars[x].chr, c, curs->attr.attr);\n        else\n          pc = 0;\n        if (pc)\n          line->chars[x].chr = pc;\n        else\n          add_cc(line, x, c, curs->attr);\n      }\n      else {\n        // add initial combining characters, \n        // particularly to include initial bidi directional markers\n        add_cc(line, -1, c, curs->attr);\n      }\n      if (!overstrike)\n        return;\n      // otherwise width 0 was faked for this switch, \n      // and we still need to advance the cursor below\n    otherwise:  // Anything else. Probably shouldn't get here.\n      return;\n  }\n\n  curs->x++;\n  if (curs->x == term.marg_right + 1 || curs->x == term.cols) {\n    curs->x--;\n    if (term.autowrap || cfg.old_wrapmodes)\n      curs->wrapnext = true;\n  }\n}\n\n#define dont_debug_scriptfonts\n\nstruct rangefont {\n  ucschar first, last;\n  uchar font;\n  char * scriptname;\n};\nstatic struct rangefont scriptfonts[] = {\n#include \"scripts.t\"\n};\nstatic struct rangefont blockfonts[] = {\n#include \"blocks.t\"\n};\nstatic bool scriptfonts_init = false;\nstatic bool use_blockfonts = false;\n\nstatic void\nmapfont(struct rangefont * ranges, uint len, char * script, uchar f)\n{\n  for (uint i = 0; i < len; i++) {\n    if (0 == strcmp(ranges[i].scriptname, script))\n      ranges[i].font = f;\n  }\n  if (0 == strcmp(script, \"CJK\")) {\n    mapfont(ranges, len, \"Han\", f);\n    mapfont(ranges, len, \"Hangul\", f);\n    mapfont(ranges, len, \"Katakana\", f);\n    mapfont(ranges, len, \"Hiragana\", f);\n    mapfont(ranges, len, \"Bopomofo\", f);\n    mapfont(ranges, len, \"Kanbun\", f);\n    mapfont(ranges, len, \"Fullwidth\", f);\n    mapfont(ranges, len, \"Halfwidth\", f);\n  }\n}\n\nstatic char *\ncfg_apply(char * conf, char * item)\n{\n  char * cmdp = conf;\n  char sepch = ';';\n  if ((uchar)*cmdp <= (uchar)' ')\n    sepch = *cmdp++;\n\n  char * paramp;\n  while ((paramp = strchr(cmdp, ':'))) {\n    *paramp = '\\0';\n    paramp++;\n    char * sepp = strchr(paramp, sepch);\n    if (sepp)\n      *sepp = '\\0';\n\n    if (!item || !strcmp(cmdp, item)) {\n      if (*cmdp == '|')\n        mapfont(blockfonts, lengthof(blockfonts), cmdp + 1, atoi(paramp));\n      else\n        mapfont(scriptfonts, lengthof(scriptfonts), cmdp, atoi(paramp));\n    }\n\n    if (sepp) {\n      cmdp = sepp + 1;\n      // check for multi-line separation\n      if (*cmdp == '\\\\' && cmdp[1] == '\\n') {\n        cmdp += 2;\n        while (iswspace(*cmdp))\n          cmdp++;\n      }\n    }\n    else\n      break;\n  }\n  return 0;\n}\n\nstatic void\ninit_scriptfonts(void)\n{\n  if (*cfg.font_choice) {\n    char * cfg_scriptfonts = cs__wcstombs(cfg.font_choice);\n    cfg_apply(cfg_scriptfonts, 0);\n    free(cfg_scriptfonts);\n    use_blockfonts = wcschr(cfg.font_choice, '|');\n  }\n  scriptfonts_init = true;\n}\n\nuchar\nscriptfont(ucschar ch)\n{\n  if (!*cfg.font_choice)\n    return 0;\n  if (!scriptfonts_init)\n    init_scriptfonts();\n\n  int i, j, k;\n\n  if (use_blockfonts) {\n    i = -1;\n    j = lengthof(blockfonts);\n    while (j - i > 1) {\n      k = (i + j) / 2;\n      if (ch < blockfonts[k].first)\n        j = k;\n      else if (ch > blockfonts[k].last)\n        i = k;\n      else {\n        uchar f = blockfonts[k].font;\n        if (f)\n          return f;\n        break;\n      }\n    }\n  }\n\n  i = -1;\n  j = lengthof(scriptfonts);\n  while (j - i > 1) {\n    k = (i + j) / 2;\n    if (ch < scriptfonts[k].first)\n      j = k;\n    else if (ch > scriptfonts[k].last)\n      i = k;\n    else\n      return scriptfonts[k].font;\n  }\n  return 0;\n}\n\nstatic void\nwrite_ucschar(wchar hwc, wchar wc, int width)\n{\n  cattrflags attr = term.curs.attr.attr;\n  ucschar c = hwc ? combine_surrogates(hwc, wc) : wc;\n  uchar cf = scriptfont(c);\n#ifdef debug_scriptfonts\n  if (c && (cf || c > 0xFF))\n    printf(\"write_ucschar %04X scriptfont %d\\n\", c, cf);\n#endif\n  if (cf && cf <= 10 && !(attr & FONTFAM_MASK))\n    term.curs.attr.attr = attr | ((cattrflags)cf << ATTR_FONTFAM_SHIFT);\n\n  if (hwc) {\n    if (width == 1\n        && (cfg.charwidth == 10 || cs_single_forced)\n        && (is_wide(c) || (cs_ambig_wide && is_ambig(c)))\n       )\n    { // ensure indication of cjksingle width handling to trigger down-zooming\n      width = 2;\n    }\n    write_char(hwc, width);\n    write_char(wc, -1);  // -1 indicates low surrogate\n  }\n  else\n    write_char(wc, width);\n\n  term.curs.attr.attr = attr;\n}\n\nstatic void\nwrite_error(void)\n{\n  // Write one of REPLACEMENT CHARACTER or, if that does not exist,\n  // MEDIUM SHADE which looks appropriately erroneous.\n  wchar errch = 0xFFFD;\n  win_check_glyphs(&errch, 1, term.curs.attr.attr);\n  if (!errch)\n    errch = 0x2592;\n  write_char(errch, 1);\n}\n\n\nstatic bool\ncontains(string s, int i)\n{\n  while (*s) {\n    while (*s == ',' || *s == ' ')\n      s++;\n    int si = -1;\n    int len;\n    if (sscanf(s, \"%d%n\", &si, &len) <= 0)\n      return false;\n    s += len;\n    if (si == i && (!*s || *s == ',' || *s == ' '))\n      return true;\n  }\n  return false;\n}\n\n\nstatic short prev_state = 0;\n\n/* Process Tek mode ESC control */\nstatic void\ntek_esc(char c)\n{\n  if (prev_state)\n    term.state = prev_state;\n  else\n    term.state = NORMAL;\n\n  switch (c) {\n    when '\\e':   /* stay in ESC state */\n      term.state = TEK_ESCAPE;\n    when '\\n':   /* LF: stay in ESC state */\n      term.state = TEK_ESCAPE;\n    when 0 or '\\r':   /* stay in ESC state */\n      term.state = TEK_ESCAPE;\n    when '\\a':   /* BEL: Bell */\n      write_bell();\n    when '\\b' or '\\t' or '\\v':     /* BS or HT or VT */\n      tek_write(c, -2);\n    when CTRL('L'):   /* FF: Alpha mode, clear screen */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n      tek_bypass = false;\n      tek_clear();\n    when CTRL('E'):   /* ENQ: terminal type query */\n      tek_bypass = true;\n      tek_enq();\n    when CTRL('N'):   /* LS1: Locking-shift one */\n      tek_alt(true);\n    when CTRL('O'):   /* LS0: Locking-shift zero */\n      tek_alt(false);\n    when CTRL('W'):   /* ETB: Make Copy */\n      term_save_image();\n      tek_bypass = false;\n    when CTRL('X'):   /* CAN: Set Bypass */\n      tek_bypass = true;\n    when CTRL('Z'):   /* SUB: Gin mode */\n      tek_mode = TEKMODE_GIN;\n      tek_gin();\n      term.state = NORMAL;\n      tek_bypass = true;\n    when 0x1C:   /* FS: Special Plot mode */\n      tek_mode = TEKMODE_SPECIAL_PLOT;\n      term.state = TEK_ADDRESS0;\n    when 0x1D:   /* GS: Graph mode */\n      tek_mode = TEKMODE_GRAPH0;\n      term.state = TEK_ADDRESS0;\n    when 0x1E:   /* RS: Incremental Plot mode */\n      tek_mode = TEKMODE_INCREMENTAL_PLOT;\n      term.state = TEK_INCREMENTAL;\n    when 0x1F:   /* US: Normal mode */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n    when '`' ... 'g':  /* Normal mode */\n      tek_beam(false, false, c & 7);\n    when 'h' ... 'o':  /* Defocused mode */\n      tek_beam(true, false, c & 7);\n    when 'p' ... 'w':  /* Write-Thru mode */\n      tek_beam(false, true, c & 7);\n    when '8' ... ';':\n      tek_font(c - '8');\n    when '?':\n      if (term.state == TEK_ADDRESS0 || term.state == TEK_ADDRESS)\n        term_do_write(\"\u007f\", 1);\n    when CTRL('C'):\n      tek_mode = TEKMODE_OFF;\n      term.state = NORMAL;\n      win_invalidate_all(false);\n    when ']':  /* OSC: operating system command */\n      term.state = OSC_START;\n  }\n}\n\n/* Process Tek mode control character */\nstatic void\ntek_ctrl(char c)\n{\n  if (term.state == TEK_ADDRESS0 || term.state == TEK_ADDRESS)\n    prev_state = term.state;\n\n  switch (c) {\n    when '\\e':   /* ESC: Escape */\n      prev_state = term.state;\n      term.state = TEK_ESCAPE;\n    when '\\a':   /* BEL: Bell */\n      write_bell();\n      tek_bypass = false;\n    when '\\b' or '\\t' or '\\v':     /* BS or HT or VT */\n      if (tek_mode == TEKMODE_ALPHA)\n        tek_write(c, -2);\n    when '\\n':   /* LF: Line feed */\n      tek_bypass = false;\n      tek_write(c, -2);\n    when '\\r':   /* CR: Carriage return */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n      tek_bypass = false;\n      tek_write(c, -2);\n    when 0x1C:   /* FS: Point Plot mode */\n      tek_mode = TEKMODE_POINT_PLOT;\n      term.state = TEK_ADDRESS0;\n    when 0x1D:   /* GS: Graph mode */\n      tek_mode = TEKMODE_GRAPH0;\n      term.state = TEK_ADDRESS0;\n    when 0x1E:   /* RS: Incremental Plot mode */\n      tek_mode = TEKMODE_INCREMENTAL_PLOT;\n      term.state = TEK_INCREMENTAL;\n    when 0x1F:   /* US: Normal mode */\n      tek_mode = TEKMODE_ALPHA;\n      term.state = NORMAL;\n      tek_bypass = false;\n  }\n}\n\n/* Process control character, returning whether it has been recognised. */\nstatic bool\ndo_ctrl(char c)\n{\n  if (tek_mode) {\n    tek_ctrl(c);\n    return true;\n  }\n\n  switch (c) {\n    when '\\e':   /* ESC: Escape */\n      term.state = ESCAPE;\n      term.esc_mod = 0;\n    when '\\a':   /* BEL: Bell */\n      write_bell();\n    when '\\b':     /* BS: Back space */\n      write_backspace();\n    when '\\t':     /* HT: Character tabulation */\n      write_tab();\n    when '\\v':   /* VT: Line tabulation */\n      write_linefeed();\n      if (term.newline_mode)\n        write_return();\n    when '\\f':   /* FF: Form feed */\n      write_linefeed();\n      if (term.newline_mode)\n        write_return();\n    when '\\r':   /* CR: Carriage return */\n      write_return();\n    when '\\n':   /* LF: Line feed */\n      write_linefeed();\n      if (term.newline_mode)\n        write_return();\n    when CTRL('E'):   /* ENQ: terminal type query */\n      if (!term.vt52_mode) {\n        char * ab = cs__wcstombs(cfg.answerback);\n        child_write(ab, strlen(ab));\n        free(ab);\n      }\n    when CTRL('N'):   /* LS1: Locking-shift one */\n      if (!term.vt52_mode) {\n        term.curs.gl = 1;\n        term_update_cs();\n      }\n    when CTRL('O'):   /* LS0: Locking-shift zero */\n      if (!term.vt52_mode) {\n        term.curs.gl = 0;\n        term_update_cs();\n      }\n    otherwise:\n      return false;\n  }\n  return true;\n}\n\nstatic void\ndo_vt52(uchar c)\n{\n  term_cursor *curs = &term.curs;\n  term.state = NORMAL;\n  term.autowrap = false;\n  term.rev_wrap = false;\n  term.esc_mod = 0;\n  switch (c) {\n    when '\\e':\n      term.state = ESCAPE;\n    when '<':  /* Exit VT52 mode (Enter VT100 mode). */\n      term.vt52_mode = 0;\n    when '=':  /* Enter alternate keypad mode. */\n      term.app_keypad = true;\n    when '>':  /* Exit alternate keypad mode. */\n      term.app_keypad = false;\n    when 'A':  /* Cursor up. */\n      move(curs->x, curs->y - 1, 0);\n    when 'B':  /* Cursor down. */\n      move(curs->x, curs->y + 1, 0);\n    when 'C':  /* Cursor right. */\n      move(curs->x + 1, curs->y, 0);\n    when 'D':  /* Cursor left. */\n      move(curs->x - 1, curs->y, 0);\n    when 'F':  /* Enter graphics mode. */\n      term.vt52_mode = 2;\n    when 'G':  /* Exit graphics mode. */\n      term.vt52_mode = 1;\n    when 'H':  /* Move the cursor to the home position. */\n      move(0, 0, 0);\n    when 'I':  /* Reverse line feed. */\n      if (curs->y == term.marg_top)\n        term_do_scroll(term.marg_top, term.marg_bot, -1, true);\n      else if (curs->y > 0)\n        curs->y--;\n      curs->wrapnext = false;\n    when 'J':  /* Erase from the cursor to the end of the screen. */\n      term_erase(false, false, false, true);\n    when 'K':  /* Erase from the cursor to the end of the line. */\n      term_erase(false, true, false, true);\n    when 'Y':  /* Move the cursor to given row and column. */\n      term.state = VT52_Y;\n    when 'Z':  /* Identify. */\n      child_write(\"\\e/Z\", 3);\n    // Atari ST extensions\n    when 'E':  /* Clear screen */\n      move(0, 0, 0);\n      term_erase(false, false, false, true);\n    when 'b':  /* Foreground color */\n      term.state = VT52_FG;\n    when 'c':  /* Background color */\n      term.state = VT52_BG;\n    when 'd':  /* Clear to start of screen */\n      term_erase(false, false, true, false);\n    when 'e':  /* Enable cursor */\n      term.cursor_on = true;\n    when 'f':  /* Disable cursor */\n      term.cursor_on = false;\n    when 'j':  /* Save cursor */\n      save_cursor();\n    when 'k':  /* Restore cursor */\n      restore_cursor();\n    when 'l':  /* Clear line */\n      term_erase(false, true, true, true);\n      write_return();\n    when 'o':  /* Clear to start of line */\n      term_erase(false, true, true, false);\n    when 'p':  /* Reverse video */\n      term.curs.attr.attr |= ATTR_REVERSE;\n    when 'q':  /* Normal video */\n      term.curs.attr.attr &= ~ATTR_REVERSE;\n    when 'v':  /* Wrap on */\n      term.autowrap = true;\n      term.curs.wrapnext = false;\n    when 'w':  /* Wrap off */\n      term.autowrap = false;\n      term.curs.wrapnext = false;\n  }\n}\n\nstatic void\ndo_vt52_move(void)\n{\n  term.state = NORMAL;\n  uchar y = term.cmd_buf[0];\n  uchar x = term.cmd_buf[1];\n  if (y < ' ' || x < ' ')\n    return;\n  move(x - ' ', y - ' ', 0);\n}\n\nstatic void\ndo_vt52_colour(bool fg, uchar c)\n{\n  term.state = NORMAL;\n  if (fg) {\n    term.curs.attr.attr &= ~ATTR_FGMASK;\n    term.curs.attr.attr |= ((c & 0xF) + ANSI0) << ATTR_FGSHIFT;\n  }\n  else {\n    term.curs.attr.attr &= ~ATTR_BGMASK;\n    term.curs.attr.attr |= ((c & 0xF) + ANSI0) << ATTR_BGSHIFT;\n  }\n}\n\nstatic term_cset\nlookup_cset(ushort nrc_code, uchar csmask, bool enabled)\n{\n  static struct {\n    ushort design;\n    uchar cstype;  // 1: 94-character set, 2: 96-character set, 3: both\n    bool free;     // does not need NRC enabling\n    uchar cs;\n  } csdesignations[] = {\n    {'B', 1, 1, CSET_ASCII},\t// ASCII\n    {'A', 3, 1, CSET_GBCHR},\t// UK Latin-1\n    {'0', 1, 1, CSET_LINEDRW},\t// DEC Special Line Drawing\n    {'>', 1, 1, CSET_TECH},\t\t// DEC Technical\n    {'U', 1, 1, CSET_OEM},\t\t// OEM Codepage 437\n    {'<', 1, 1, CSET_DECSUPP},\t// DEC User-preferred Supplemental (VT200)\n    {CPAIR('%', '5'), 1, 1, CSET_DECSPGR},\t// DEC Supplementary (VT300)\n    // definitions for NRC support:\n    {'4', 1, 0, CSET_NL},\t// Dutch\n    {'C', 1, 0, CSET_FI},\t// Finnish\n    {'5', 1, 0, CSET_FI},\t// Finnish\n    {'R', 1, 0, CSET_FR},\t// French\n    {'f', 1, 0, CSET_FR},\t// French\n    {'Q', 1, 0, CSET_CA},\t// French Canadian (VT200, VT300)\n    {'9', 1, 0, CSET_CA},\t// French Canadian (VT200, VT300)\n    {'K', 1, 0, CSET_DE},\t// German\n    {'Y', 1, 0, CSET_IT},\t// Italian\n    {'`', 1, 0, CSET_NO},\t// Norwegian/Danish\n    {'E', 1, 0, CSET_NO},\t// Norwegian/Danish\n    {'6', 1, 0, CSET_NO},\t// Norwegian/Danish\n    {CPAIR('%', '6'), 1, 0, CSET_PT},\t// Portuguese (VT300)\n    {'Z', 1, 0, CSET_ES},\t// Spanish\n    {'H', 1, 0, CSET_SE},\t// Swedish\n    {'7', 1, 0, CSET_SE},\t// Swedish\n    {'=', 1, 0, CSET_CH},\t// Swiss\n    // 96-character sets (xterm 336)\n    {'L', 2, 1, CSET_ISO_Latin_Cyrillic},\n    {'F', 2, 1, CSET_ISO_Greek_Supp},\n    {'H', 2, 1, CSET_ISO_Hebrew},\n    {'M', 2, 1, CSET_ISO_Latin_5},\n    {CPAIR('\"', '?'), 1, 1, CSET_DEC_Greek_Supp},\n    {CPAIR('\"', '4'), 1, 1, CSET_DEC_Hebrew_Supp},\n    {CPAIR('%', '0'), 1, 1, CSET_DEC_Turkish_Supp},\n    {CPAIR('&', '4'), 1, 1, CSET_DEC_Cyrillic},\n    {CPAIR('\"', '>'), 1, 0, CSET_NRCS_Greek},\n    {CPAIR('%', '='), 1, 0, CSET_NRCS_Hebrew},\n    {CPAIR('%', '2'), 1, 0, CSET_NRCS_Turkish},\n  };\n  for (uint i = 0; i < lengthof(csdesignations); i++)\n    if (csdesignations[i].design == nrc_code\n        && (csdesignations[i].cstype & csmask)\n        && (csdesignations[i].free || enabled)\n       )\n    {\n      return csdesignations[i].cs;\n    }\n  return 0;\n}\n\n// compatible state machine expansion for NCR and DECRQM\nstatic uchar esc_mod0 = 0;\nstatic uchar esc_mod1 = 0;\n\nstatic void\ndo_esc(uchar c)\n{\n  term_cursor *curs = &term.curs;\n  term.state = NORMAL;\n\n  // NRC designations\n  // representation of NRC sequences at this point:\n  //\t\tterm.esc_mod esc_mod0 esc_mod1 c\n  // ESC)B\t29 00 00 42\n  // ESC)%5\tFF 29 25 35\n  // 94-character set designation as G0...G3: ()*+\n  // 96-character set designation as G1...G3:  -./\n  uchar designator = term.esc_mod == 0xFF ? esc_mod0 : term.esc_mod;\n  uchar csmask = 0;\n  int gi;\n  if (designator) {\n    void check_designa(char * designa, uchar cstype) {\n      char * csdesigna = strchr(designa, designator);\n      if (csdesigna) {\n        csmask = cstype;\n        gi = csdesigna - designa + cstype - 1;\n      }\n    }\n    check_designa(\"()*+\", 1);  // 94-character set designation?\n    check_designa(\"-./\", 2);  // 96-character set designation?\n  }\n  if (csmask) {\n    ushort nrc_code = CPAIR(esc_mod1, c);\n    term_cset cs = lookup_cset(nrc_code, csmask, term.decnrc_enabled);\n    if (cs) {\n      curs->csets[gi] = cs;\n      term_update_cs();\n      return;\n    }\n  }\n\n  switch (CPAIR(term.esc_mod, c)) {\n    when '[':  /* CSI: control sequence introducer */\n      term.state = CSI_ARGS;\n      term.csi_argc = 1;\n      memset(term.csi_argv, 0, sizeof(term.csi_argv));\n      memset(term.csi_argv_defined, 0, sizeof(term.csi_argv_defined));\n      term.esc_mod = 0;\n    when ']':  /* OSC: operating system command */\n      term.state = OSC_START;\n    when 'P':  /* DCS: device control string */\n      term.state = DCS_START;\n    when '^' or '_' or 'X': /* PM, APC, SOS strings to be ignored */\n      term.state = IGNORE_STRING;\n    when '7':  /* DECSC: save cursor */\n      save_cursor();\n    when '8':  /* DECRC: restore cursor */\n      restore_cursor();\n    when '=':  /* DECKPAM: Keypad application mode */\n      term.app_keypad = true;\n    when '>':  /* DECKPNM: Keypad numeric mode */\n      term.app_keypad = false;\n    when 'D':  /* IND: exactly equivalent to LF */\n      write_linefeed();\n    when 'E':  /* NEL: exactly equivalent to CR-LF */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right) {\n        write_return();\n        write_linefeed();\n      }\n    when 'M':  /* RI: reverse index - backwards LF */\n      if (curs->y == term.marg_top)\n        term_do_scroll(term.marg_top, term.marg_bot, -1, true);\n      else if (curs->y > 0)\n        curs->y--;\n      curs->wrapnext = false;\n    when 'Z':  /* DECID: terminal type query */\n      write_primary_da();\n    when 'c':  /* RIS: restore power-on settings */\n      winimgs_clear();\n      term_reset(true);\n      if (term.reset_132) {\n        win_set_chars(term.rows, 80);\n        term.reset_132 = 0;\n      }\n    when 'H':  /* HTS: set a tab */\n      term.tabs[curs->x] = true;\n    when 'l':  /* HP Memory Lock */\n      if (curs->y < term.marg_bot)\n        term.marg_top = curs->y;\n    when 'm':  /* HP Memory Unlock */\n      term.marg_top = 0;\n    when CPAIR('#', '8'):    /* DECALN: fills screen with Es :-) */\n      term.curs.origin = false;\n      term.curs.wrapnext = false;\n      term.curs.attr = CATTR_DEFAULT;\n      term.marg_top = 0;\n      term.marg_bot = term.rows - 1;\n      term.marg_left = 0;\n      term.marg_right = term.cols - 1;\n      move(0, 0, 0);\n      for (int i = 0; i < term.rows; i++) {\n        termline *line = term.lines[i];\n        for (int j = 0; j < term.cols; j++) {\n          line->chars[j] =\n            (termchar) {.cc_next = 0, .chr = 'E', .attr = CATTR_DEFAULT};\n        }\n        line->lattr = LATTR_NORM;\n      }\n      term.disptop = 0;\n    when CPAIR('#', '3'):  /* DECDHL: 2*height, top */\n      if (!term.lrmargmode) {\n        term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n        term.lines[curs->y]->lattr |= LATTR_TOP;\n      }\n    when CPAIR('#', '4'):  /* DECDHL: 2*height, bottom */\n      if (!term.lrmargmode) {\n        term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n        term.lines[curs->y]->lattr |= LATTR_BOT;\n      }\n    when CPAIR('#', '5'):  /* DECSWL: normal */\n      term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n      term.lines[curs->y]->lattr |= LATTR_NORM;\n    when CPAIR('#', '6'):  /* DECDWL: 2*width */\n      if (!term.lrmargmode) {\n        term.lines[curs->y]->lattr &= LATTR_BIDIMASK;\n        term.lines[curs->y]->lattr |= LATTR_WIDE;\n      }\n    when CPAIR('%', '8') or CPAIR('%', 'G'):\n      curs->utf = true;\n      term_update_cs();\n    when CPAIR('%', '@'):\n      curs->utf = false;\n      term_update_cs();\n    when 'n':  /* LS2: Invoke G2 character set as GL */\n      term.curs.gl = 2;\n      term_update_cs();\n    when 'o':  /* LS3: Invoke G3 character set as GL */\n      term.curs.gl = 3;\n      term_update_cs();\n    when '~':  /* LS1R: Invoke G1 character set as GR */\n      term.curs.gr = 1;\n      term_update_cs();\n    when '}':  /* LS2R: Invoke G2 character set as GR */\n      term.curs.gr = 2;\n      term_update_cs();\n    when '|':  /* LS3R: Invoke G3 character set as GR */\n      term.curs.gr = 3;\n      term_update_cs();\n    when 'N':  /* SS2: Single Shift G2 character set */\n      term.curs.cset_single = curs->csets[2];\n    when 'O':  /* SS3: Single Shift G3 character set */\n      term.curs.cset_single = curs->csets[3];\n    when '6':  /* Back Index (DECBI), VT420 */\n      if (curs->x == term.marg_left)\n        insdel_column(term.marg_left, false, 1);\n      else\n        move(curs->x - 1, curs->y, 1);\n    when '9':  /* Forward Index (DECFI), VT420 */\n      if (curs->x == term.marg_right)\n        insdel_column(term.marg_left, true, 1);\n      else\n        move(curs->x + 1, curs->y, 1);\n  }\n}\n\nstatic void\ndo_sgr(void)\n{\n /* Set Graphics Rendition. */\n  uint argc = term.csi_argc;\n  cattr attr = term.curs.attr;\n  uint prot = attr.attr & ATTR_PROTECTED;\n  for (uint i = 0; i < argc; i++) {\n    // support colon-separated sub parameters as specified in\n    // ISO/IEC 8613-6 (ITU Recommendation T.416)\n    int sub_pars = 0;\n    // count sub parameters and clear their SUB_PARS flag \n    // (the last one does not have it)\n    // but not the SUB_PARS flag of the main parameter\n    if (term.csi_argv[i] & SUB_PARS)\n      for (uint j = i + 1; j < argc; j++) {\n        sub_pars++;\n        if (term.csi_argv[j] & SUB_PARS)\n          term.csi_argv[j] &= ~SUB_PARS;\n        else\n          break;\n      }\n    if (*cfg.suppress_sgr\n        && contains(cfg.suppress_sgr, term.csi_argv[i] & ~SUB_PARS))\n    {\n      // skip suppressed attribute (but keep processing sub_pars)\n      // but turn some sequences into virtual sub-parameters\n      // in order to get properly adjusted\n      if (term.csi_argv[i] == 38 || term.csi_argv[i] == 48) {\n        if (i + 2 < argc && term.csi_argv[i + 1] == 5)\n          sub_pars = 2;\n        else if (i + 4 < argc && term.csi_argv[i + 1] == 2)\n          sub_pars = 4;\n      }\n    }\n    else\n    switch (term.csi_argv[i]) {\n      when 0:\n        attr = CATTR_DEFAULT;\n        attr.attr |= prot;\n      when 1: attr.attr |= ATTR_BOLD;\n      when 2: attr.attr |= ATTR_DIM;\n      when 1 | SUB_PARS:\n        if (i + 1 < argc)\n          switch (term.csi_argv[i + 1]) {\n            when 2:\n              attr.attr |= ATTR_SHADOW;\n          }\n      when 3: attr.attr |= ATTR_ITALIC;\n      when 4:\n        attr.attr &= ~UNDER_MASK;\n        attr.attr |= ATTR_UNDER;\n      when 4 | SUB_PARS:\n        if (i + 1 < argc)\n          switch (term.csi_argv[i + 1]) {\n            when 0:\n              attr.attr &= ~UNDER_MASK;\n            when 1:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_UNDER;\n            when 2:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_DOUBLYUND;\n            when 3:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_CURLYUND;\n            when 4:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_BROKENUND;\n            when 5:\n              attr.attr &= ~UNDER_MASK;\n              attr.attr |= ATTR_BROKENUND | ATTR_DOUBLYUND;\n          }\n      when 5: attr.attr |= ATTR_BLINK;\n      when 6: attr.attr |= ATTR_BLINK2;\n      when 7: attr.attr |= ATTR_REVERSE;\n      when 8: attr.attr |= ATTR_INVISIBLE;\n      when 8 | SUB_PARS:\n        if (i + 1 < argc)\n          switch (term.csi_argv[i + 1]) {\n            when 7:\n              attr.attr |= ATTR_OVERSTRIKE;\n          }\n      when 9: attr.attr |= ATTR_STRIKEOUT;\n      when 73: attr.attr |= ATTR_SUPERSCR;\n      when 74: attr.attr |= ATTR_SUBSCR;\n      when 75: attr.attr &= ~(ATTR_SUPERSCR | ATTR_SUBSCR);\n      when 10 ... 11: {  // ... 12 disabled\n        // mode 10 is the configured character set\n        // mode 11 is the VGA character set (CP437 + control range graphics)\n        // mode 12 (VT520, Linux console, not cygwin console) \n        // clones VGA characters into the ASCII range; disabled;\n        // modes 11 (and 12) are overridden by alternative font if configured\n          uchar arg_10 = term.csi_argv[i] - 10;\n          if (arg_10 && *cfg.fontfams[arg_10].name) {\n            attr.attr &= ~FONTFAM_MASK;\n            attr.attr |= (cattrflags)arg_10 << ATTR_FONTFAM_SHIFT;\n          }\n          else {\n            if (!arg_10)\n              attr.attr &= ~FONTFAM_MASK;\n            term.curs.oem_acs = arg_10;\n            term_update_cs();\n          }\n        }\n      when 12 ... 20:\n        attr.attr &= ~FONTFAM_MASK;\n        attr.attr |= (cattrflags)(term.csi_argv[i] - 10) << ATTR_FONTFAM_SHIFT;\n      //when 21: attr.attr &= ~ATTR_BOLD;\n      when 21:\n        attr.attr &= ~UNDER_MASK;\n        attr.attr |= ATTR_DOUBLYUND;\n      when 22: attr.attr &= ~(ATTR_BOLD | ATTR_DIM | ATTR_SHADOW);\n      when 23:\n        attr.attr &= ~ATTR_ITALIC;\n        if (((attr.attr & FONTFAM_MASK) >> ATTR_FONTFAM_SHIFT) + 10 == 20)\n          attr.attr &= ~FONTFAM_MASK;\n      when 24: attr.attr &= ~UNDER_MASK;\n      when 25: attr.attr &= ~(ATTR_BLINK | ATTR_BLINK2);\n      when 27: attr.attr &= ~ATTR_REVERSE;\n      when 28: attr.attr &= ~(ATTR_INVISIBLE | ATTR_OVERSTRIKE);\n      when 29: attr.attr &= ~ATTR_STRIKEOUT;\n      when 30 ... 37: /* foreground */\n        attr.attr &= ~ATTR_FGMASK;\n        attr.attr |= (term.csi_argv[i] - 30 + ANSI0) << ATTR_FGSHIFT;\n      when 51 or 52: /* \"framed\" or \"encircled\" */\n        attr.attr |= ATTR_FRAMED;\n      when 54: /* not framed, not encircled */\n        attr.attr &= ~ATTR_FRAMED;\n      when 53: attr.attr |= ATTR_OVERL;\n      when 55: attr.attr &= ~ATTR_OVERL;\n      when 90 ... 97: /* bright foreground */\n        attr.attr &= ~ATTR_FGMASK;\n        attr.attr |= ((term.csi_argv[i] - 90 + 8 + ANSI0) << ATTR_FGSHIFT);\n      when 38: /* palette/true-colour foreground */\n        if (i + 2 < argc && term.csi_argv[i + 1] == 5) {\n          // set foreground to palette colour\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_FGSHIFT);\n          i += 2;\n        }\n        else if (i + 4 < argc && term.csi_argv[i + 1] == 2) {\n          // set foreground to RGB\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_FGSHIFT;\n          uint r = term.csi_argv[i + 2];\n          uint g = term.csi_argv[i + 3];\n          uint b = term.csi_argv[i + 4];\n          attr.truefg = make_colour(r, g, b);\n          i += 4;\n        }\n      when 38 | SUB_PARS: /* ISO/IEC 8613-6 foreground colour */\n        if (sub_pars >= 2 && term.csi_argv[i + 1] == 5) {\n          // set foreground to palette colour\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_FGSHIFT);\n        }\n        else if (sub_pars >= 4 && term.csi_argv[i + 1] == 2) {\n          // set foreground to RGB\n          uint pi = sub_pars >= 5;\n          attr.attr &= ~ATTR_FGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_FGSHIFT;\n          uint r = term.csi_argv[i + pi + 2];\n          uint g = term.csi_argv[i + pi + 3];\n          uint b = term.csi_argv[i + pi + 4];\n          attr.truefg = make_colour(r, g, b);\n        }\n        else if ((sub_pars >= 5 && term.csi_argv[i + 1] == 3) ||\n                 (sub_pars >= 6 && term.csi_argv[i + 1] == 4)) {\n          // set foreground to CMY(K)\n          ulong f = term.csi_argv[i + 2];\n          ulong c = term.csi_argv[i + 3];\n          ulong m = term.csi_argv[i + 4];\n          ulong y = term.csi_argv[i + 5];\n          ulong k = term.csi_argv[i + 1] == 4 ? term.csi_argv[i + 6] : 0;\n          if (c <= f && m <= f && y <= f && k <= f) {\n            uint r = (f - c) * (f - k) / f * 255 / f;\n            uint g = (f - m) * (f - k) / f * 255 / f;\n            uint b = (f - y) * (f - k) / f * 255 / f;\n            attr.attr &= ~ATTR_FGMASK;\n            attr.attr |= TRUE_COLOUR << ATTR_FGSHIFT;\n            attr.truefg = make_colour(r, g, b);\n          }\n        }\n      when 39: /* default foreground */\n        attr.attr &= ~ATTR_FGMASK;\n        attr.attr |= ATTR_DEFFG;\n      when 40 ... 47: /* background */\n        attr.attr &= ~ATTR_BGMASK;\n        attr.attr |= (term.csi_argv[i] - 40 + ANSI0) << ATTR_BGSHIFT;\n      when 100 ... 107: /* bright background */\n        attr.attr &= ~ATTR_BGMASK;\n        attr.attr |= ((term.csi_argv[i] - 100 + 8 + ANSI0) << ATTR_BGSHIFT);\n      when 48: /* palette/true-colour background */\n        if (i + 2 < argc && term.csi_argv[i + 1] == 5) {\n          // set background to palette colour\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_BGSHIFT);\n          i += 2;\n        }\n        else if (i + 4 < argc && term.csi_argv[i + 1] == 2) {\n          // set background to RGB\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_BGSHIFT;\n          uint r = term.csi_argv[i + 2];\n          uint g = term.csi_argv[i + 3];\n          uint b = term.csi_argv[i + 4];\n          attr.truebg = make_colour(r, g, b);\n          i += 4;\n        }\n      when 48 | SUB_PARS: /* ISO/IEC 8613-6 background colour */\n        if (sub_pars >= 2 && term.csi_argv[i + 1] == 5) {\n          // set background to palette colour\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= ((term.csi_argv[i + 2] & 0xFF) << ATTR_BGSHIFT);\n        }\n        else if (sub_pars >= 4 && term.csi_argv[i + 1] == 2) {\n          // set background to RGB\n          uint pi = sub_pars >= 5;\n          attr.attr &= ~ATTR_BGMASK;\n          attr.attr |= TRUE_COLOUR << ATTR_BGSHIFT;\n          uint r = term.csi_argv[i + pi + 2];\n          uint g = term.csi_argv[i + pi + 3];\n          uint b = term.csi_argv[i + pi + 4];\n          attr.truebg = make_colour(r, g, b);\n        }\n        else if ((sub_pars >= 5 && term.csi_argv[i + 1] == 3) ||\n                 (sub_pars >= 6 && term.csi_argv[i + 1] == 4)) {\n          // set background to CMY(K)\n          ulong f = term.csi_argv[i + 2];\n          ulong c = term.csi_argv[i + 3];\n          ulong m = term.csi_argv[i + 4];\n          ulong y = term.csi_argv[i + 5];\n          ulong k = term.csi_argv[i + 1] == 4 ? term.csi_argv[i + 6] : 0;\n          if (c <= f && m <= f && y <= f && k <= f) {\n            uint r = (f - c) * (f - k) / f * 255 / f;\n            uint g = (f - m) * (f - k) / f * 255 / f;\n            uint b = (f - y) * (f - k) / f * 255 / f;\n            attr.attr &= ~ATTR_BGMASK;\n            attr.attr |= TRUE_COLOUR << ATTR_BGSHIFT;\n            attr.truebg = make_colour(r, g, b);\n          }\n        }\n      when 49: /* default background */\n        attr.attr &= ~ATTR_BGMASK;\n        attr.attr |= ATTR_DEFBG;\n      when 58 | SUB_PARS: /* ISO/IEC 8613-6 format underline colour */\n        if (sub_pars >= 2 && term.csi_argv[i + 1] == 5) {\n          // set foreground to palette colour\n          attr.attr |= ATTR_ULCOLOUR;\n          attr.ulcolr = colours[term.csi_argv[i + 2] & 0xFF];\n        }\n        else if (sub_pars >= 4 && term.csi_argv[i + 1] == 2) {\n          // set foreground to RGB\n          uint pi = sub_pars >= 5;\n          uint r = term.csi_argv[i + pi + 2];\n          uint g = term.csi_argv[i + pi + 3];\n          uint b = term.csi_argv[i + pi + 4];\n          attr.attr |= ATTR_ULCOLOUR;\n          attr.ulcolr = make_colour(r, g, b);\n        }\n        else if ((sub_pars >= 5 && term.csi_argv[i + 1] == 3) ||\n                 (sub_pars >= 6 && term.csi_argv[i + 1] == 4)) {\n          // set foreground to CMY(K)\n          ulong f = term.csi_argv[i + 2];\n          ulong c = term.csi_argv[i + 3];\n          ulong m = term.csi_argv[i + 4];\n          ulong y = term.csi_argv[i + 5];\n          ulong k = term.csi_argv[i + 1] == 4 ? term.csi_argv[i + 6] : 0;\n          if (c <= f && m <= f && y <= f && k <= f) {\n            uint r = (f - c) * (f - k) / f * 255 / f;\n            uint g = (f - m) * (f - k) / f * 255 / f;\n            uint b = (f - y) * (f - k) / f * 255 / f;\n            attr.attr |= ATTR_ULCOLOUR;\n            attr.ulcolr = make_colour(r, g, b);\n          }\n        }\n      when 59: /* default underline colour */\n        attr.attr &= ~ATTR_ULCOLOUR;\n        attr.ulcolr = (colour)-1;\n    }\n    // skip sub parameters\n    i += sub_pars;\n  }\n  term.curs.attr = attr;\n  term.erase_char.attr = attr;\n  term.erase_char.attr.attr &= (ATTR_FGMASK | ATTR_BGMASK);\n  term.erase_char.attr.attr |= TATTR_CLEAR;\n}\n\n/*\n * Set terminal modes in escape arguments to state.\n */\nstatic void\nset_modes(bool state)\n{\n  for (uint i = 0; i < term.csi_argc; i++) {\n    uint arg = term.csi_argv[i];\n    if (term.esc_mod) { /* DECSET/DECRST: DEC private mode set/reset */\n      if (*cfg.suppress_dec && contains(cfg.suppress_dec, arg))\n        ; // skip suppressed DECSET/DECRST operation\n      else\n      switch (arg) {\n        when 1:  /* DECCKM: application cursor keys */\n          term.app_cursor_keys = state;\n        when 66:  /* DECNKM: application keypad */\n          term.app_keypad = state;\n        when 2:  /* DECANM: VT100/VT52 mode */\n          if (state) {\n            // Designate USASCII for character sets G0-G3\n            for (uint i = 0; i < lengthof(term.curs.csets); i++)\n              term.curs.csets[i] = CSET_ASCII;\n            term.curs.cset_single = CSET_ASCII;\n            term_update_cs();\n          }\n          else\n            term.vt52_mode = 1;\n        when 3:  /* DECCOLM: 80/132 columns */\n          if (term.deccolm_allowed) {\n            term.selected = false;\n            win_set_chars(term.rows, state ? 132 : 80);\n            term.reset_132 = state;\n            term.marg_top = 0;\n            term.marg_bot = term.rows - 1;\n            term.marg_left = 0;\n            term.marg_right = term.cols - 1;\n            move(0, 0, 0);\n            if (!term.deccolm_noclear)\n              term_erase(false, false, true, true);\n          }\n        when 5:  /* DECSCNM: reverse video */\n          if (state != term.rvideo) {\n            term.rvideo = state;\n            win_invalidate_all(false);\n          }\n        when 6:  /* DECOM: DEC origin mode */\n          term.curs.origin = state;\n          if (state)\n            move(term.marg_left, term.marg_top, 0);\n          else\n            move(0, 0, 0);\n        when 7:  /* DECAWM: auto wrap */\n          term.autowrap = state;\n          term.curs.wrapnext = false;\n        when 45:  /* xterm: reverse (auto) wraparound */\n          term.rev_wrap = state;\n          term.curs.wrapnext = false;\n        when 8:  /* DECARM: auto key repeat */\n          term.auto_repeat = state;\n        when 9:  /* X10_MOUSE */\n          term.mouse_mode = state ? MM_X10 : 0;\n          win_update_mouse();\n        when 12: /* AT&T 610 blinking cursor */\n          term.cursor_blinkmode = state;\n          term.cursor_invalid = true;\n          term_schedule_cblink();\n        when 25: /* DECTCEM: enable/disable cursor */\n          term.cursor_on = state;\n          // Should we set term.cursor_invalid or call term_invalidate ?\n        when 30: /* Show/hide scrollbar */\n          if (state != term.show_scrollbar) {\n            term.show_scrollbar = state;\n            win_update_scrollbar(false);\n          }\n        when 38: /* DECTEK: Enter Tektronix Mode (VT240, VT330) */\n          if (state) {\n            tek_mode = TEKMODE_ALPHA;\n            tek_init(true, cfg.tek_glow);\n          }\n        when 40: /* Allow/disallow DECCOLM (xterm c132 resource) */\n          term.deccolm_allowed = state;\n        when 95: /* VT510 DECNCSM: DECCOLM does not clear the screen */\n          term.deccolm_noclear = state;\n        when 42: /* DECNRCM: national replacement character sets */\n          term.decnrc_enabled = state;\n        when 44: /* turn on margin bell (xterm) */\n          term.margin_bell = state;\n        when 67: /* DECBKM: backarrow key mode */\n          term.backspace_sends_bs = state;\n        when 69: /* DECLRMM/VT420 DECVSSM: enable left/right margins DECSLRM */\n          term.lrmargmode = state;\n          if (state) {\n            for (int i = 0; i < term.rows; i++) {\n              termline *line = term.lines[i];\n              line->lattr = LATTR_NORM;\n            }\n          }\n          else {\n            term.marg_left = 0;\n            term.marg_right = term.cols - 1;\n          }\n        when 80: /* DECSDM: SIXEL display mode */\n          term.sixel_display = !state;\n        when 1000: /* VT200_MOUSE */\n          term.mouse_mode = state ? MM_VT200 : 0;\n          win_update_mouse();\n        when 1002: /* BTN_EVENT_MOUSE */\n          term.mouse_mode = state ? MM_BTN_EVENT : 0;\n          win_update_mouse();\n        when 1003: /* ANY_EVENT_MOUSE */\n          term.mouse_mode = state ? MM_ANY_EVENT : 0;\n          win_update_mouse();\n        when 1004: /* FOCUS_EVENT_MOUSE */\n          term.report_focus = state;\n        when 1005: /* Xterm's UTF8 encoding for mouse positions */\n          term.mouse_enc = state ? ME_UTF8 : 0;\n        when 1006: /* Xterm's CSI-style mouse encoding */\n          term.mouse_enc = state ? ME_XTERM_CSI : 0;\n        when 1016: /* Xterm's CSI-style mouse encoding with pixel resolution */\n          term.mouse_enc = state ? ME_PIXEL_CSI : 0;\n        when 1015: /* Urxvt's CSI-style mouse encoding */\n          term.mouse_enc = state ? ME_URXVT_CSI : 0;\n        when 1037:\n          term.delete_sends_del = state;\n        when 1042:\n          term.bell_taskbar = state;\n        when 1043:\n          term.bell_popup = state;\n        when 47: /* alternate screen */\n          if (!cfg.disable_alternate_screen) {\n            term.selected = false;\n            term_switch_screen(state, false);\n            term.disptop = 0;\n          }\n        when 1047:       /* alternate screen */\n          if (!cfg.disable_alternate_screen) {\n            term.selected = false;\n            term_switch_screen(state, true);\n            term.disptop = 0;\n          }\n        when 1046:       /* enable/disable alternate screen switching */\n          if (term.on_alt_screen && !state)\n            term_switch_screen(false, false);\n          cfg.disable_alternate_screen = !state;\n        when 1048:       /* save/restore cursor */\n          if (!cfg.disable_alternate_screen) {\n            if (state)\n              save_cursor();\n            else\n              restore_cursor();\n          }\n        when 1049:       /* cursor & alternate screen */\n          if (!cfg.disable_alternate_screen) {\n            if (state)\n              save_cursor();\n            term.selected = false;\n            term_switch_screen(state, true);\n            if (!state)\n              restore_cursor();\n            term.disptop = 0;\n          }\n        when 1061:       /* VT220 keyboard emulation */\n          term.vt220_keys = state;\n        when 2004:       /* xterm bracketed paste mode */\n          term.bracketed_paste = state;\n\n        /* Mintty private modes */\n        when 7700:       /* CJK ambigous width reporting */\n          term.report_ambig_width = state;\n        when 7711:       /* Scroll marker in current line */\n          if (state)\n            term.lines[term.curs.y]->lattr |= LATTR_MARKED;\n          else\n            term.lines[term.curs.y]->lattr |= LATTR_UNMARKED;\n        when 7727:       /* Application escape key mode */\n          term.app_escape_key = state;\n        when 7728:       /* Escape sends FS (instead of ESC) */\n          term.escape_sends_fs = state;\n        when 7730:       /* Sixel scrolling end position */\n          /* on: sixel scrolling moves cursor to beginning of the line\n             off(default): sixel scrolling moves cursor to left of graphics */\n          term.sixel_scrolls_left = state;\n        when 7766:       /* 'B': Show/hide scrollbar (if enabled in config) */\n          if (cfg.scrollbar && state != term.show_scrollbar) {\n            term.show_scrollbar = state;\n            win_update_scrollbar(true);\n          }\n        when 7767:       /* 'C': Changed font reporting */\n          term.report_font_changed = state;\n        when 7783:       /* 'S': Shortcut override */\n          term.shortcut_override = state;\n        when 1007:       /* Alternate Scroll Mode, xterm */\n          term.wheel_reporting_xterm = state;\n        when 7786:       /* 'V': Mousewheel reporting */\n          term.wheel_reporting = state;\n        when 7787:       /* 'W': Application mousewheel mode */\n          term.app_wheel = state;\n        when 7796:       /* Bidi disable in current line */\n          if (state)\n            term.lines[term.curs.y]->lattr |= LATTR_NOBIDI;\n          else\n            term.lines[term.curs.y]->lattr &= ~LATTR_NOBIDI;\n        when 77096:      /* Bidi disable */\n          term.disable_bidi = state;\n        when 8452:       /* Sixel scrolling end position right */\n          /* on: sixel scrolling leaves cursor to right of graphic\n             off(default): position after sixel depends on sixel_scrolls_left */\n          term.sixel_scrolls_right = state;\n        when 77000 ... 77031: { /* Application control key modes */\n          int ctrl = arg - 77000;\n          term.app_control = (term.app_control & ~(1 << ctrl)) | (state << ctrl);\n        }\n        when 2500: /* bidi box graphics mirroring */\n          if (state)\n            term.curs.bidimode |= LATTR_BOXMIRROR;\n          else\n            term.curs.bidimode &= ~LATTR_BOXMIRROR;\n        when 2501: /* bidi direction auto-detection */\n          if (state)\n            term.curs.bidimode &= ~LATTR_BIDISEL;\n          else\n            term.curs.bidimode |= LATTR_BIDISEL;\n      }\n    }\n    else { /* SM/RM: set/reset mode */\n      switch (arg) {\n        when 4:  /* IRM: set insert mode */\n          term.insert = state;\n        when 8: /* BDSM: ECMA-48 bidirectional support mode */\n          if (state)\n            term.curs.bidimode &= ~LATTR_NOBIDI;\n          else\n            term.curs.bidimode |= LATTR_NOBIDI;\n        when 12: /* SRM: set echo mode */\n          term.echoing = !state;\n        when 20: /* LNM: Return sends ... */\n          term.newline_mode = state;\n#ifdef support_Wyse_cursor_modes\n        when 33: /* WYSTCURM: steady Wyse cursor */\n          term.cursor_blinkmode = !state;\n          term.cursor_invalid = true;\n          term_schedule_cblink();\n        when 34: /* WYULCURM: Wyse underline cursor */\n          term.cursor_type = state;\n          term.cursor_blinkmode = false;\n          term.cursor_invalid = true;\n          term_schedule_cblink();\n#endif\n      }\n    }\n  }\n}\n\n/*\n * Get terminal mode.\n            0 - not recognized\n            1 - set\n            2 - reset\n            3 - permanently set\n            4 - permanently reset\n */\nstatic int\nget_mode(bool privatemode, int arg)\n{\n  if (privatemode) { /* DECRQM for DECSET/DECRST: DEC private mode */\n    switch (arg) {\n      when 1:  /* DECCKM: application cursor keys */\n        return 2 - term.app_cursor_keys;\n      when 66:  /* DECNKM: application keypad */\n        return 2 - term.app_keypad;\n      when 2:  /* DECANM: VT100/VT52 mode */\n        // Check USASCII for character sets G0-G3\n        for (uint i = 0; i < lengthof(term.curs.csets); i++)\n          if (term.curs.csets[i] != CSET_ASCII)\n            return 2;\n        return 1;\n      when 3:  /* DECCOLM: 80/132 columns */\n        return 2 - term.reset_132;\n      when 5:  /* DECSCNM: reverse video */\n        return 2 - term.rvideo;\n      when 6:  /* DECOM: DEC origin mode */\n        return 2 - term.curs.origin;\n      when 7:  /* DECAWM: auto wrap */\n        return 2 - term.autowrap;\n      when 45:  /* xterm: reverse (auto) wraparound */\n        return 2 - term.rev_wrap;\n      when 8:  /* DECARM: auto key repeat */\n        return 2 - term.auto_repeat;\n        //return 3; // ignored\n      when 9:  /* X10_MOUSE */\n        return 2 - (term.mouse_mode == MM_X10);\n      when 12: /* AT&T 610 blinking cursor */\n        return 2 - term.cursor_blinkmode;\n      when 25: /* DECTCEM: enable/disable cursor */\n        return 2 - term.cursor_on;\n      when 30: /* Show/hide scrollbar */\n        return 2 - term.show_scrollbar;\n      when 40: /* Allow/disallow DECCOLM (xterm c132 resource) */\n        return 2 - term.deccolm_allowed;\n      when 42: /* DECNRCM: national replacement character sets */\n        return 2 - term.decnrc_enabled;\n      when 44: /* margin bell (xterm) */\n        return 2 - term.margin_bell;\n      when 67: /* DECBKM: backarrow key mode */\n        return 2 - term.backspace_sends_bs;\n      when 69: /* DECLRMM: enable left and right margin mode DECSLRM */\n        return 2 - term.lrmargmode;\n      when 80: /* DECSDM: SIXEL display mode */\n        return 2 - !term.sixel_display;\n      when 1000: /* VT200_MOUSE */\n        return 2 - (term.mouse_mode == MM_VT200);\n      when 1002: /* BTN_EVENT_MOUSE */\n        return 2 - (term.mouse_mode == MM_BTN_EVENT);\n      when 1003: /* ANY_EVENT_MOUSE */\n        return 2 - (term.mouse_mode == MM_ANY_EVENT);\n      when 1004: /* FOCUS_EVENT_MOUSE */\n        return 2 - term.report_focus;\n      when 1005: /* Xterm's UTF8 encoding for mouse positions */\n        return 2 - (term.mouse_enc == ME_UTF8);\n      when 1006: /* Xterm's CSI-style mouse encoding */\n        return 2 - (term.mouse_enc == ME_XTERM_CSI);\n      when 1016: /* Xterm's CSI-style mouse encoding with pixel resolution */\n        return 2 - (term.mouse_enc == ME_PIXEL_CSI);\n      when 1015: /* Urxvt's CSI-style mouse encoding */\n        return 2 - (term.mouse_enc == ME_URXVT_CSI);\n      when 1037:\n        return 2 - term.delete_sends_del;\n      when 1042:\n        return 2 - term.bell_taskbar;\n      when 1043:\n        return 2 - term.bell_popup;\n      when 47: /* alternate screen */\n        return 2 - term.on_alt_screen;\n      when 1047:       /* alternate screen */\n        return 2 - term.on_alt_screen;\n      when 1048:       /* save/restore cursor */\n        return 4;\n      when 1049:       /* cursor & alternate screen */\n        return 2 - term.on_alt_screen;\n      when 1061:       /* VT220 keyboard emulation */\n        return 2 - term.vt220_keys;\n      when 2004:       /* xterm bracketed paste mode */\n        return 2 - term.bracketed_paste;\n\n      /* Mintty private modes */\n      when 7700:       /* CJK ambigous width reporting */\n        return 2 - term.report_ambig_width;\n      when 7711:       /* Scroll marker in current line */\n        return 2 - !!(term.lines[term.curs.y]->lattr & LATTR_MARKED);\n      when 7727:       /* Application escape key mode */\n        return 2 - term.app_escape_key;\n      when 7728:       /* Escape sends FS (instead of ESC) */\n        return 2 - term.escape_sends_fs;\n      when 7730:       /* Sixel scrolling end position */\n        return 2 - term.sixel_scrolls_left;\n      when 7766:       /* 'B': Show/hide scrollbar (if enabled in config) */\n        return 2 - term.show_scrollbar;\n      when 7767:       /* 'C': Changed font reporting */\n        return 2 - term.report_font_changed;\n      when 7783:       /* 'S': Shortcut override */\n        return 2 - term.shortcut_override;\n      when 1007:       /* Alternate Scroll Mode, xterm */\n        return 2 - term.wheel_reporting_xterm;\n      when 7786:       /* 'V': Mousewheel reporting */\n        return 2 - term.wheel_reporting;\n      when 7787:       /* 'W': Application mousewheel mode */\n        return 2 - term.app_wheel;\n      when 7796:       /* Bidi disable in current line */\n        return 2 - !!(term.lines[term.curs.y]->lattr & LATTR_NOBIDI);\n      when 77096:      /* Bidi disable */\n        return 2 - term.disable_bidi;\n      when 8452:       /* Sixel scrolling end position right */\n        return 2 - term.sixel_scrolls_right;\n      when 77000 ... 77031: { /* Application control key modes */\n        int ctrl = arg - 77000;\n        return 2 - !!(term.app_control & (1 << ctrl));\n      }\n      when 2500: /* bidi box graphics mirroring */\n        return 2 - !!(term.curs.bidimode & LATTR_BOXMIRROR);\n      when 2501: /* bidi direction auto-detection */\n        return 2 - !(term.curs.bidimode & LATTR_BIDISEL);\n      otherwise:\n        return 0;\n    }\n  }\n  else { /* DECRQM for SM/RM: mode */\n    switch (arg) {\n      when 4:  /* IRM: insert mode */\n        return 2 - term.insert;\n      when 8: /* BDSM: bidirectional support mode */\n        return 2 - !(term.curs.bidimode & LATTR_NOBIDI);\n      when 12: /* SRM: echo mode */\n        return 2 - !term.echoing;\n      when 20: /* LNM: Return sends ... */\n        return 2 - term.newline_mode;\n#ifdef support_Wyse_cursor_modes\n      when 33: /* WYSTCURM: steady Wyse cursor */\n        return 2 - (!term.cursor_blinkmode);\n      when 34: /* WYULCURM: Wyse underline cursor */\n        if (term.cursor_type <= 1)\n          return 2 - (term.cursor_type == 1);\n        else\n          return 0;\n#endif\n      otherwise:\n        return 0;\n    }\n  }\n}\n\nstruct mode_entry {\n  int mode, val;\n};\nstatic struct mode_entry * mode_stack = 0;\nstatic int mode_stack_len = 0;\n\nstatic void\npush_mode(int mode, int val)\n{\n  struct mode_entry * new_stack = renewn(mode_stack, mode_stack_len + 1);\n  if (new_stack) {\n    mode_stack = new_stack;\n    mode_stack[mode_stack_len].mode = mode;\n    mode_stack[mode_stack_len].val = val;\n    mode_stack_len++;\n  }\n}\n\nstatic int\npop_mode(int mode)\n{\n  for (int i = mode_stack_len - 1; i >= 0; i--)\n    if (mode_stack[i].mode == mode) {\n      int val = mode_stack[i].val;\n      mode_stack_len--;\n      for (int j = i; j < mode_stack_len; j++)\n        mode_stack[j] = mode_stack[j + 1];\n      struct mode_entry * new_stack = renewn(mode_stack, mode_stack_len);\n      if (new_stack)\n        mode_stack = new_stack;\n      return val;\n    }\n  return -1;\n}\n\nstruct cattr_entry {\n  cattr ca;\n  cattrflags mask;\n};\nstatic struct cattr_entry cattr_stack[10];\nstatic int cattr_stack_len = 0;\n\nstatic void\npush_attrs(cattr ca, cattrflags caflagsmask)\n{\n  if (cattr_stack_len == lengthof(cattr_stack)) {\n    for (int i = 1; i < cattr_stack_len; i++)\n      cattr_stack[i - 1] = cattr_stack[i];\n    cattr_stack_len--;\n  }\n  //printf(\"push_attrs[%d] %llX\\n\", cattr_stack_len, caflagsmask);\n  cattr_stack[cattr_stack_len].ca = ca;\n  cattr_stack[cattr_stack_len].mask = caflagsmask;\n  cattr_stack_len++;\n}\n\nstatic bool\npop_attrs(cattr * _ca, cattrflags * _caflagsmask)\n{\n  if (!cattr_stack_len)\n    return false;\n  cattr_stack_len--;\n  //printf(\"pop_attrs[%d] %llX\\n\", cattr_stack_len, cattr_stack[cattr_stack_len].mask);\n  *_ca = cattr_stack[cattr_stack_len].ca;\n  *_caflagsmask = cattr_stack[cattr_stack_len].mask;\n  return true;\n}\n\nstatic COLORREF * colours_stack[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nstatic int colours_cur = 0;\nstatic int colours_num = 0;\n\nstatic void\npush_colours(uint ix)\n{\n  if (ix > 10)\n    return;\n\n  if (ix) {  // store\n    colours_cur = ix;\n    ix--;\n  }\n  else {  // push\n    if (colours_cur < 10) {\n      ix = colours_cur;\n      colours_cur++;\n    }\n    else\n      return;\n  }\n  //printf(\"push %d\\n\", ix);\n\n  if (!colours_stack[ix]) {\n    colours_stack[ix] = malloc(COLOUR_NUM * sizeof(COLORREF));\n    if (colours_stack[ix])\n      colours_num++;\n  }\n  if (colours_stack[ix])\n    memcpy(colours_stack[ix], colours, COLOUR_NUM * sizeof(COLORREF));\n}\n\nstatic void\npop_colours(uint ix)\n{\n  if (ix > 10)\n    return;\n\n  if (ix) {  // retrieve\n    colours_cur = ix;\n    ix--;\n  }\n  else {  // pop\n    if (colours_cur) {\n      colours_cur--;\n      ix = colours_cur;\n    }\n    else\n      return;\n  }\n  //printf(\"pop %d\\n\", ix);\n\n  if (colours_stack[ix])\n    memcpy(colours, colours_stack[ix], COLOUR_NUM * sizeof(COLORREF));\n}\n\n/*\n * dtterm window operations and xterm extensions.\n   CSI Ps ; Ps ; Ps t\n */\nstatic void\ndo_winop(void)\n{\n  int arg1 = term.csi_argv[1], arg2 = term.csi_argv[2];\n  if (*cfg.suppress_win && contains(cfg.suppress_win, term.csi_argv[0]))\n    // skip suppressed window operation\n    return;\n  switch (term.csi_argv[0]) {\n    when 1: win_set_iconic(false);\n    when 2: win_set_iconic(true);\n    when 3: win_set_pos(arg1, arg2);\n    when 4: win_set_pixels(arg1, arg2);\n    when 5:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(true);  // top\n    when 6:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(false); // bottom\n    when 7: win_invalidate_all(false);  // refresh\n    when 8: {\n      int def1 = term.csi_argv_defined[1], def2 = term.csi_argv_defined[2];\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      win_set_chars(arg1 ?: def1 ? rows : term.rows, arg2 ?: def2 ? cols : term.cols);\n    }\n    when 9: {\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 9 ; 0  -> Restore maximized window.\n      // Ps = 9 ; 1  -> Maximize window (i.e., resize to screen size).\n      // Ps = 9 ; 2  -> Maximize window vertically.\n      // Ps = 9 ; 3  -> Maximize window horizontally.\n      int rows0 = term.rows0, cols0 = term.cols0;\n      if (arg1 == 2) {\n        // maximize window vertically\n        win_set_geom(0, -1, 0, -1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 3) {\n        // maximize window horizontally\n        win_set_geom(-1, 0, -1, 0);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 1) {\n        win_maximise(1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 0) {\n        win_maximise(0);\n        win_set_chars(rows0, cols0);\n      }\n      usleep(1000);\n    }\n    when 10:\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 1 0 ; 0  -> Undo full-screen mode.\n      // Ps = 1 0 ; 1  -> Change to full-screen.\n      // Ps = 1 0 ; 2  -> Toggle full-screen.\n      if (arg1 == 2)\n        win_maximise(-2);\n      else if (arg1 == 1 || arg1 == 0)\n        win_maximise(arg1 ? 2 : 0);\n      usleep(1000);\n    when 11: child_write(win_is_iconic() ? \"\\e[2t\" : \"\\e[1t\", 4);\n    when 13: {\n      int x, y;\n      win_get_scrpos(&x, &y, arg1 == 2);\n      child_printf(\"\\e[3;%u;%ut\", (ushort)x, (ushort)y);\n    }\n    when 14: {\n      int height, width;\n      win_get_pixels(&height, &width, arg1 == 2);\n      child_printf(\"\\e[4;%d;%dt\", height, width);\n    }\n    when 15: {\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[5;%d;%dt\", h, w);\n    }\n    when 16: child_printf(\"\\e[6;%d;%dt\", cell_height, cell_width);\n    when 18: child_printf(\"\\e[8;%d;%dt\", term.rows, term.cols);\n    when 19: {\n#ifdef size_of_monitor_only\n#warning not what xterm reports\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      child_printf(\"\\e[9;%d;%dt\", rows, cols);\n#else\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[9;%d;%dt\", h / cell_height, w / cell_width);\n#endif\n    }\n    when 22:\n      if (arg1 == 0 || arg1 == 2)\n        win_save_title();\n    when 23:\n      if (arg1 == 0 || arg1 == 2)\n        win_restore_title();\n  }\n}\n\nstatic void\nset_taskbar_progress(int state, int percent)\n{\n  if (state == 0) {  // disable progress indication\n    taskbar_progress(-9);\n    term.detect_progress = 0;\n  }\n  else if (state == 8) {  // \"busy\"\n    taskbar_progress(-8);\n    term.detect_progress = 0;\n  }\n  else if (state <= 3) {\n    taskbar_progress(- state);\n    if (percent >= 0) {\n      taskbar_progress(percent);\n      term.detect_progress = 0;\n    }\n    else  // enable automatic progress detection\n      term.detect_progress = state;\n  }\n}\n\nstatic void\ndo_csi(uchar c)\n{\n  term_cursor *curs = &term.curs;\n  int arg0 = term.csi_argv[0], arg1 = term.csi_argv[1];\n  if (arg0 < 0)\n    arg0 = 0;\n  if (arg1 < 0)\n    arg1 = 0;\n  int arg0_def1 = arg0 ?: 1;  // first arg with default 1\n\n  // DECRQM quirk\n  if (term.esc_mod == 0xFF && esc_mod0 == '?' && esc_mod1 == '$' && c == 'p')\n    term.esc_mod = '$';\n\n  switch (CPAIR(term.esc_mod, c)) {\n    when CPAIR('!', 'p'):     /* DECSTR: soft terminal reset */\n      term_reset(false);\n    when 'b': {      /* REP: repeat preceding character */\n      cattr cur_attr = term.curs.attr;\n      term.curs.attr = last_attr;\n      wchar h = last_high, c = last_char;\n      for (int i = 0; i < arg0_def1; i++)\n        write_ucschar(h, c, last_width);\n      term.curs.attr = cur_attr;\n    }\n    when 'A':        /* CUU: move up N lines */\n      move(curs->x, curs->y - arg0_def1, 1);\n    when 'e':        /* VPR: move down N lines */\n      move(curs->x, curs->y + arg0_def1, 1);\n    when 'B':        /* CUD: Cursor down */\n      move(curs->x, curs->y + arg0_def1, 1);\n    when 'c':        /* Primary DA: report device/terminal type */\n      if (!arg0)\n        write_primary_da();\n    when CPAIR('>', 'c'):     /* Secondary DA: report device version */\n      if (!arg0) {\n        if (cfg.charwidth % 10)\n          child_printf(\"\\e[>77;%u;%uc\", DECIMAL_VERSION, UNICODE_VERSION);\n        else\n          child_printf(\"\\e[>77;%u;0c\", DECIMAL_VERSION);\n      }\n    when CPAIR('>', 'q'):     /* Report terminal name and version */\n      if (!arg0)\n        child_printf(\"\\eP>|%s %s\\e\\\\\", APPNAME, VERSION);\n    when 'a':        /* HPR: move right N cols */\n      move(curs->x + arg0_def1, curs->y, 1);\n    when 'C':        /* CUF: Cursor right */\n      move(curs->x + arg0_def1, curs->y, 1);\n    when 'D':        /* CUB: move left N cols */\n      if (arg0_def1 > curs->x) {\n        arg0_def1 -= curs->x + 1;\n        move(0, curs->y, 1);\n        write_backspace();\n        move(curs->x - arg0_def1, curs->y, 1);\n      }\n      else\n        move(curs->x - arg0_def1, curs->y, 1);\n      enable_progress();\n    when 'E':        /* CNL: move down N lines and CR */\n      move(0, curs->y + arg0_def1, 1);\n    when 'F':        /* CPL: move up N lines and CR */\n      move(0, curs->y - arg0_def1, 1);\n    when 'G' or '`': { /* CHA or HPA: set horizontal position */\n      short x = (curs->origin ? term.marg_left : 0) + arg0_def1 - 1;\n      if (x < curs->x)\n        enable_progress();\n      move(x, curs->y, curs->origin ? 2 : 0);\n    }\n    when 'd':        /* VPA: set vertical position */\n      move(curs->x,\n           (curs->origin ? term.marg_top : 0) + arg0_def1 - 1,\n           curs->origin ? 2 : 0);\n    when 'H' or 'f':  /* CUP or HVP: set horiz. and vert. positions at once */\n      move((curs->origin ? term.marg_left : 0) + (arg1 ?: 1) - 1,\n           (curs->origin ? term.marg_top : 0) + arg0_def1 - 1,\n           curs->origin ? 2 : 0);\n    when 'I':  /* CHT: move right N TABs */\n      for (int i = 0; i < arg0_def1; i++)\n        write_tab();\n    when 'J' or CPAIR('?', 'J'):  /* ED/DECSED: (selective) erase in display */\n      if (arg0 == 3) { /* Erase Saved Lines (xterm) */\n        // don't care if (term.esc_mod) // ignore selective\n        term_clear_scrollback();\n        term.disptop = 0;\n      }\n      else if (arg0 <= 2) {\n        bool above = arg0 == 1 || arg0 == 2;\n        bool below = arg0 == 0 || arg0 == 2;\n        term_erase(term.esc_mod, false, above, below);\n      }\n    when 'K' or CPAIR('?', 'K'):  /* EL/DECSEL: (selective) erase in line */\n      if (arg0 <= 2) {\n        bool right = arg0 == 0 || arg0 == 2;\n        bool left  = arg0 == 1 || arg0 == 2;\n        term_erase(term.esc_mod, true, left, right);\n      }\n    when 'L':        /* IL: insert lines */\n      if (curs->y >= term.marg_top && curs->y <= term.marg_bot\n       && curs->x >= term.marg_left && curs->x <= term.marg_right\n         )\n      {\n        term_do_scroll(curs->y, term.marg_bot, -arg0_def1, false);\n        curs->x = term.marg_left;\n      }\n    when 'M':        /* DL: delete lines */\n      if (curs->y >= term.marg_top && curs->y <= term.marg_bot\n       && curs->x >= term.marg_left && curs->x <= term.marg_right\n         )\n      {\n        term_do_scroll(curs->y, term.marg_bot, arg0_def1, true);\n        curs->x = term.marg_left;\n      }\n    when '@':        /* ICH: insert chars */\n      insert_char(arg0_def1);\n    when 'P':        /* DCH: delete chars */\n      insert_char(-arg0_def1);\n    when 'h' or CPAIR('?', 'h'):  /* SM/DECSET: set (private) modes */\n      set_modes(true);\n    when 'l' or CPAIR('?', 'l'):  /* RM/DECRST: reset (private) modes */\n      set_modes(false);\n    when CPAIR('?', 's'): { /* Save DEC Private Mode (DECSET) values */\n      int arg = term.csi_argv[0];\n      int val = get_mode(true, arg);\n      if (val)\n        push_mode(arg, val);\n    }\n    when CPAIR('?', 'r'): { /* Restore DEC Private Mode (DECSET) values */\n      int arg = term.csi_argv[0];\n      int val = pop_mode(arg);\n      if (val >= 0) {\n        term.csi_argc = 1;\n        set_modes(val & 1);\n      }\n    }\n    when CPAIR('#', '{') or CPAIR('#', 'p'): { /* Push video attributes onto stack (XTPUSHSGR) */\n      cattr ca = term.curs.attr;\n      cattrflags caflagsmask = 0;\n\n      void set_push(int attr) {\n        switch (attr) {\n          when 1: caflagsmask |= ATTR_BOLD | ATTR_SHADOW;\n          when 2: caflagsmask |= ATTR_DIM;\n          when 3: caflagsmask |= ATTR_ITALIC;\n          when 4 or 21: caflagsmask |= UNDER_MASK;\n          when 5 or 6: caflagsmask |= ATTR_BLINK | ATTR_BLINK2;\n          when 7: caflagsmask |= ATTR_REVERSE;\n          when 8: caflagsmask |= ATTR_INVISIBLE | ATTR_OVERSTRIKE;\n          when 9: caflagsmask |= ATTR_STRIKEOUT;\n          when 20: caflagsmask |= FONTFAM_MASK;\n          when 53: caflagsmask |= ATTR_OVERL;\n          when 58: caflagsmask |= ATTR_ULCOLOUR;\n          when 30 or 10: caflagsmask |= ATTR_FGMASK;\n          when 31 or 11: caflagsmask |= ATTR_BGMASK;\n          when 73: caflagsmask |= ATTR_SUPERSCR;\n          when 74: caflagsmask |= ATTR_SUBSCR;\n        }\n      }\n\n      if (!term.csi_argv_defined[0])\n        for (int a = 1; a < 90; a++)\n          set_push(a);\n      else\n        for (uint i = 0; i < term.csi_argc; i++) {\n          //printf(\"XTPUSHSGR[%d] %d\\n\", i, term.csi_argv[i]);\n          set_push(term.csi_argv[i]);\n        }\n      if ((ca.attr & caflagsmask & ATTR_FGMASK) != TRUE_COLOUR)\n        ca.truefg = 0;\n      if ((ca.attr & caflagsmask & ATTR_BGMASK) != TRUE_COLOUR << ATTR_BGSHIFT)\n        ca.truebg = 0;\n      if (!(caflagsmask & ATTR_ULCOLOUR))\n        ca.ulcolr = (colour)-1;\n      // push\n      //printf(\"XTPUSHSGR &%llX %llX %06X %06X %06X\\n\", caflagsmask, ca.attr, ca.truefg, ca.truebg, ca.ulcolr);\n      push_attrs(ca, caflagsmask);\n    }\n    when CPAIR('#', '}') or CPAIR('#', 'q'): { /* Pop video attributes from stack (XTPOPSGR) */\n      //printf(\"XTPOPSGR\\n\");\n      // pop\n      cattr ca;\n      cattrflags caflagsmask;\n      if (pop_attrs(&ca, &caflagsmask)) {\n        //printf(\"XTPOPSGR &%llX %llX %06X %06X %06X\\n\", caflagsmask, ca.attr, ca.truefg, ca.truebg, ca.ulcolr);\n        // merge\n        term.curs.attr.attr = (term.curs.attr.attr & ~caflagsmask)\n                              | (ca.attr & caflagsmask);\n        if ((ca.attr & caflagsmask & ATTR_FGMASK) == TRUE_COLOUR)\n          term.curs.attr.truefg = ca.truefg;\n        if ((ca.attr & caflagsmask & ATTR_BGMASK) == TRUE_COLOUR << ATTR_BGSHIFT)\n          term.curs.attr.truebg = ca.truebg;\n        if (caflagsmask & ATTR_ULCOLOUR)\n          term.curs.attr.ulcolr = ca.ulcolr;\n      }\n    }\n    when CPAIR('#', 'P'):  /* Push dynamic colours onto stack (XTPUSHCOLORS) */\n      push_colours(arg0);\n    when CPAIR('#', 'Q'):  /* Pop dynamic colours from stack (XTPOPCOLORS) */\n      pop_colours(arg0);\n      win_invalidate_all(false);  // refresh\n    when CPAIR('#', 'R'):  /* Report colours stack entry (XTREPORTCOLORS) */\n      child_printf(\"\\e[?%d;%d#Q\", colours_cur, colours_num);\n    when CPAIR('$', 'p'): { /* DECRQM: request (private) mode */\n      int arg = term.csi_argv[0];\n      child_printf(\"\\e[%s%u;%u$y\",\n                   esc_mod0 ? \"?\" : \"\",\n                   arg,\n                   get_mode(esc_mod0, arg));\n    }\n    when 'i' or CPAIR('?', 'i'):  /* MC: Media copy */\n      if (arg0 == 5 && *cfg.printer) {\n        term.printing = true;\n        term.only_printing = !term.esc_mod;\n        term.print_state = 0;\n        if (*cfg.printer == '*')\n          printer_start_job(printer_get_default());\n        else\n          printer_start_job(cfg.printer);\n      }\n      else if (arg0 == 4 && term.printing) {\n        // Drop escape sequence from print buffer and finish printing.\n        while (term.printbuf[--term.printbuf_pos] != '\\e');\n        term_print_finish();\n      }\n      else if (arg0 == 10 && !term.esc_mod) {\n        term_export_html(false);\n      }\n#ifdef support_SVG\n      else if (arg0 == 11 && !term.esc_mod) {\n        term_export_svg();\n      }\n#endif\n      else if (arg0 == 12 && !term.esc_mod) {\n        term_save_image();\n      }\n      else if (arg0 == 0 && !term.esc_mod) {\n        print_screen();\n      }\n    when 'g':        /* TBC: clear tabs */\n      if (!arg0)\n        term.tabs[curs->x] = false;\n      else if (arg0 == 3) {\n        for (int i = 0; i < term.cols; i++)\n          term.tabs[i] = false;\n        term.newtab = 0;  // don't set new default tabs on resize\n      }\n    when 'r': {      /* DECSTBM: set scrolling region */\n      int top = arg0_def1 - 1;\n      int bot = (arg1 ? min(arg1, term.rows) : term.rows) - 1;\n      if (bot > top) {\n        term.marg_top = top;\n        term.marg_bot = bot;\n        curs->x = curs->origin ? term.marg_left : 0;\n        curs->y = curs->origin ? term.marg_top : 0;\n      }\n    }\n    when 's':\n      if (term.lrmargmode) {  /* DECSLRM: set left and right margin */\n        int left = arg0_def1 - 1;\n        int right = (arg1 ? min(arg1, term.cols) : term.cols) - 1;\n        if (right > left) {\n          term.marg_left = left;\n          term.marg_right = right;\n          curs->x = curs->origin ? term.marg_left : 0;\n          curs->y = curs->origin ? term.marg_top : 0;\n        }\n      }\n      else           /* SCOSC: save cursor */\n        save_cursor();\n    when 'u':        /* SCORC: restore cursor */\n      restore_cursor();\n    when 'm':        /* SGR: set graphics rendition */\n      do_sgr();\n    when 't':\n     /*\n      * VT340/VT420 sequence DECSLPP, for setting the height of the window.\n      * DEC only allowed values 24/25/36/48/72/144, so dtterm and xterm\n      * claimed values below 24 for various window operations, \n      * and also allowed any number of rows from 24 and above to be set.\n      */\n      if (arg0 >= 24) {  /* DECSLPP: set page size - ie window height */\n        if (*cfg.suppress_win && contains(cfg.suppress_win, 24))\n          ; // skip suppressed window operation\n        else {\n          win_set_chars(arg0, term.cols);\n          term.selected = false;\n        }\n      }\n      else\n        do_winop();\n    when 'S':        /* SU: Scroll up */\n      term_do_scroll(term.marg_top, term.marg_bot, arg0_def1, true);\n      curs->wrapnext = false;\n    when 'T':        /* SD: Scroll down */\n      /* Avoid clash with unsupported hilight mouse tracking mode sequence */\n      if (term.csi_argc <= 1) {\n        term_do_scroll(term.marg_top, term.marg_bot, -arg0_def1, true);\n        curs->wrapnext = false;\n      }\n    when CPAIR('*', '|'):     /* DECSNLS */\n     /*\n      * Set number of lines on screen\n      * VT420 uses VGA like hardware and can support any size \n      * in reasonable range (24..49 AIUI) with no default specified.\n      */\n      win_set_chars(arg0 ?: cfg.rows, term.cols);\n      term.selected = false;\n    when CPAIR('$', '|'):     /* DECSCPP */\n     /*\n      * Set number of columns per page\n      * Docs imply range is only 80 or 132, but I'll allow any.\n      */\n      win_set_chars(term.rows, arg0 ?: cfg.cols);\n      term.selected = false;\n    when 'X': {      /* ECH: write N spaces w/o moving cursor */\n      termline *line = term.lines[curs->y];\n      int cols = min(line->cols, line->size);\n      int n = min(arg0_def1, cols - curs->x);\n      if (n > 0) {\n        int p = curs->x;\n        term_check_boundary(curs->x, curs->y);\n        term_check_boundary(curs->x + n, curs->y);\n        while (n--)\n          line->chars[p++] = term.erase_char;\n      }\n    }\n    when 'x':        /* DECREQTPARM: report terminal characteristics */\n      if (arg0 <= 1)\n        child_printf(\"\\e[%u;1;1;120;120;1;0x\", arg0 + 2);\n    when 'Z': {      /* CBT (Cursor Backward Tabulation) */\n      int n = arg0_def1;\n      while (--n >= 0 && curs->x > 0) {\n        do\n          curs->x--;\n        while (curs->x > 0 && !term.tabs[curs->x]);\n      }\n      enable_progress();\n    }\n    when CPAIR('$', 'w'):     /* DECTABSR: tab stop report */\n      if (arg0 == 2) {\n        child_printf(\"\\eP2$\");\n        char sep = 'u';\n        for (int i = 0; i < term.cols; i++)\n          if (term.tabs[i]) {\n            child_printf(\"%c%d\", sep, i + 1);\n            sep = '/';\n          }\n        child_printf(\"\\e\\\\\");\n      }\n    when CPAIR('>', 'm'):     /* xterm: modifier key setting */\n      /* only the modifyOtherKeys setting is implemented */\n      if (!arg0)\n        term.modify_other_keys = 0;\n      else if (arg0 == 4)\n        term.modify_other_keys = arg1;\n    when CPAIR('>', 'p'):     /* xterm: pointerMode */\n      if (arg0 == 0)\n        term.hide_mouse = false;\n      else if (arg0 == 2)\n        term.hide_mouse = true;\n    when CPAIR('>', 'n'):     /* xterm: modifier key setting */\n      /* only the modifyOtherKeys setting is implemented */\n      if (arg0 == 4)\n        term.modify_other_keys = 0;\n    when CPAIR(' ', 'q'):     /* DECSCUSR: set cursor style */\n      term.cursor_type = arg0 ? (arg0 - 1) / 2 : -1;\n      term.cursor_blinks = arg0 ? arg0 % 2 : -1;\n      if (term.cursor_blinks)\n        term.cursor_blink_interval = arg1;\n      term.cursor_invalid = true;\n      term_schedule_cblink();\n    when CPAIR('?', 'c'):  /* Cursor size (Linux console) */\n      term.cursor_size = arg0;\n    when CPAIR('\"', 'q'):  /* DECSCA: select character protection attribute */\n      switch (arg0) {\n        when 0 or 2: term.curs.attr.attr &= ~ATTR_PROTECTED;\n        when 1: term.curs.attr.attr |= ATTR_PROTECTED;\n      }\n    when 'n':        /* DSR: device status report */\n      if (arg0 == 6)  // CPR\n        child_printf(\"\\e[%d;%dR\",\n                     curs->y + 1 - (curs->origin ? term.marg_top : 0),\n                     curs->x + 1 - (curs->origin ? term.marg_left : 0));\n      else if (arg0 == 5)\n        child_write(\"\\e[0n\", 4);\n    when CPAIR('?', 'n'):  /* DSR, DEC specific */\n      switch (arg0) {\n        when 6:  // DECXCPR\n          child_printf(\"\\e[?%d;%dR\",  // VT420: third parameter \"page\"...\n                       curs->y + 1 - (curs->origin ? term.marg_top : 0),\n                       curs->x + 1 - (curs->origin ? term.marg_left : 0));\n        when 15:\n          child_printf(\"\\e[?%un\", 11 - !!*cfg.printer);\n        // DEC Locator\n        when 53 or 55:\n          child_printf(\"\\e[?53n\");\n        when 56:\n          child_printf(\"\\e[?57;1n\");\n      }\n    // DEC Locator\n    when CPAIR('\\'', 'z'): {  /* DECELR: enable locator reporting */\n      switch (arg0) {\n        when 0:\n          if (term.mouse_mode == MM_LOCATOR) {\n            term.mouse_mode = 0;\n            win_update_mouse();\n          }\n          term.locator_1_enabled = false;\n        when 1:\n          term.mouse_mode = MM_LOCATOR;\n          win_update_mouse();\n        when 2:\n          term.locator_1_enabled = true;\n          win_update_mouse();\n      }\n      switch (arg1) {\n        when 0 or 2:\n          term.locator_by_pixels = false;\n        when 1:\n          term.locator_by_pixels = true;\n      }\n      term.locator_rectangle = false;\n    }\n    when CPAIR('\\'', '{'): {  /* DECSLE: select locator events */\n      for (uint i = 0; i < term.csi_argc; i++)\n        switch (term.csi_argv[i]) {\n          when 0: term.locator_report_up = term.locator_report_dn = false;\n          when 1: term.locator_report_dn = true;\n          when 2: term.locator_report_dn = false;\n          when 3: term.locator_report_up = true;\n          when 4: term.locator_report_up = false;\n        }\n    }\n    when CPAIR('\\'', '|'): {  /* DECRQLP: request locator position */\n      if (term.mouse_mode == MM_LOCATOR || term.locator_1_enabled) {\n        int x, y, buttons;\n        win_get_locator_info(&x, &y, &buttons, term.locator_by_pixels);\n        child_printf(\"\\e[1;%d;%d;%d;0&w\", buttons, y, x);\n        term.locator_1_enabled = false;\n      }\n      else {\n        //child_printf(\"\\e[0&w\");  // xterm reports this if loc. compiled in\n      }\n    }\n    when CPAIR('\\'', 'w'): {  /* DECEFR: enable filter rectangle */\n      int arg2 = term.csi_argv[2], arg3 = term.csi_argv[3];\n      int x, y, buttons;\n      win_get_locator_info(&x, &y, &buttons, term.locator_by_pixels);\n      term.locator_top = arg0 ?: y;\n      term.locator_left = arg1 ?: x;\n      term.locator_bottom = arg2 ?: y;\n      term.locator_right = arg3 ?: x;\n      term.locator_rectangle = true;\n    }\n    when 'q': {  /* DECLL: load keyboard LEDs */\n      if (arg0 > 20)\n        win_led(arg0 - 20, false);\n      else if (arg0)\n        win_led(arg0, true);\n      else {\n        win_led(0, false);\n      }\n    }\n    when CPAIR(' ', 'k'):  /* SCP: ECMA-48 Set Character Path (LTR/RTL) */\n      if (arg0 <= 2) {\n        if (arg0 == 2)\n          curs->bidimode |= LATTR_BIDIRTL;\n        else if (arg0 == 1)\n          curs->bidimode &= ~LATTR_BIDIRTL;\n        else {  // default\n          curs->bidimode &= ~(LATTR_BIDISEL | LATTR_BIDIRTL);\n        }\n        // postpone propagation to line until char is written (put_char)\n        //termline *line = term.lines[curs->y];\n        //line->lattr &= ~(LATTR_BIDISEL | LATTR_BIDIRTL);\n        //line->lattr |= curs->bidimode & ~LATTR_BIDISEL | LATTR_BIDIRTL);\n      }\n    when CPAIR(' ', 'S'):  /* SPD: ECMA-48 Select Presentation Direction */\n      if (arg0 == 0)\n          curs->bidimode &= ~LATTR_PRESRTL;\n      else if (arg0 == 3)\n          curs->bidimode |= LATTR_PRESRTL;\n#define urows (uint) term.rows\n#define ucols (uint) term.cols\n    when CPAIR('$', 'v'):  /* DECCRA: VT420 Copy Rectangular Area */\n      copy_rect(arg0_def1, arg1 ?: 1, \n                term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols,\n                // skip term.csi_argv[4] (source page)\n                term.csi_argv[5] ?: urows, term.csi_argv[6] ?: ucols\n                // skip term.csi_argv[7] (destination page)\n                );\n    when CPAIR('$', 'x'):  /* DECFRA: VT420 Fill Rectangular Area */\n      fill_rect(arg0 ?: ' ', curs->attr, false,\n                arg1 ?: 1, term.csi_argv[2] ?: 1,\n                term.csi_argv[3] ?: urows, term.csi_argv[4] ?: ucols);\n    when CPAIR('$', 'z'):  /* DECERA: VT420 Erase Rectangular Area */\n      fill_rect(' ', term.erase_char.attr, false,\n                arg0_def1, arg1 ?: 1,\n                term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n    when CPAIR('$', '{'):  /* DECSERA: VT420 Selective Erase Rectangular Area */\n      fill_rect(' ', term.erase_char.attr, true,\n                arg0_def1, arg1 ?: 1,\n                term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n    when CPAIR('*', 'x'):  /* DECSACE: VT420 Select Attribute Change Extent */\n      switch (arg0) {\n        when 2: term.attr_rect = true;\n        when 0 or 1: term.attr_rect = false;\n      }\n    when CPAIR('$', 'r')  /* DECCARA: VT420 Change Attributes in Area */\n      or CPAIR('$', 't'): {  /* DECRARA: VT420 Reverse Attributes in Area */\n      cattrflags a1 = 0, a2 = 0;\n      for (uint i = 4; i < term.csi_argc; i++)\n        switch (term.csi_argv[i]) {\n          when 0: a2 = ATTR_BOLD | ATTR_UNDER | ATTR_BLINK | ATTR_REVERSE;\n          when 1: a1 |= ATTR_BOLD;\n          when 4: a1 |= ATTR_UNDER;\n          when 5: a1 |= ATTR_BLINK;\n          when 7: a1 |= ATTR_REVERSE;\n          when 22: a2 |= ATTR_BOLD;\n          when 24: a2 |= ATTR_UNDER;\n          when 25: a2 |= ATTR_BLINK;\n          when 27: a2 |= ATTR_REVERSE;\n          //when 2: a1 |= ATTR_DIM;\n          //when 3: a1 |= ATTR_ITALIC;\n          //when 6: a1 |= ATTR_BLINK2;\n          //when 8: a1 |= ATTR_INVISIBLE;\n          //when 9: a1 |= ATTR_STRIKEOUT;\n        }\n      a1 &= ~a2;\n      if (c == 'r')\n        attr_rect(a1, a2, 0, arg0_def1, arg1 ?: 1,\n                  term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n      else\n        attr_rect(0, 0, a1, arg0_def1, arg1 ?: 1,\n                  term.csi_argv[2] ?: urows, term.csi_argv[3] ?: ucols);\n    }\n    when CPAIR('*', 'y'): { /* DECRQCRA: VT420 Request Rectangular Checksum */\n      uint s = sum_rect(term.csi_argv[2] ?: 1, term.csi_argv[3] ?: 1,\n                        term.csi_argv[4] ?: urows, term.csi_argv[5] ?: ucols);\n      child_printf(\"\\eP%u!~%04X\\e\\\\\", arg0, -s & 0xFFFF);\n    }\n    when CPAIR('\\'', '}'):  /* DECIC: VT420 Insert Columns */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(curs->x, false, arg0_def1);\n    when CPAIR('\\'', '~'):  /* DECDC: VT420 Delete Columns */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(curs->x, true, arg0_def1);\n    when CPAIR(' ', 'A'):     /* SR: ECMA-48 shift columns right */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(term.marg_left, false, arg0_def1);\n    when CPAIR(' ', '@'):     /* SR: ECMA-48 shift columns left */\n      if (curs->x >= term.marg_left && curs->x <= term.marg_right\n       && curs->y >= term.marg_top && curs->y <= term.marg_bot\n         )\n        insdel_column(term.marg_left, true, arg0_def1);\n    when CPAIR('#', 't'):  /* application scrollbar */\n      win_set_scrollview(arg0, arg1, term.csi_argc > 2 ? (int)term.csi_argv[2] : -1);\n    when CPAIR('<', 't'):  /* TTIMEST: change IME state (Tera Term) */\n      win_set_ime(arg0);\n    when CPAIR('<', 's'):  /* TTIMESV: save IME state (Tera Term) */\n      push_mode(-1, win_get_ime());\n    when CPAIR('<', 'r'):  /* TTIMERS: restore IME state (Tera Term) */\n      win_set_ime(pop_mode(-1));\n    when CPAIR(' ', 't'):     /* DECSWBV: VT520 warning bell volume */\n      if (arg0 <= 8)\n        term.bell.vol = arg0;\n    when CPAIR(' ', 'u'):     /* DECSMBV: VT520 margin bell volume */\n      if (!arg0)\n        term.marginbell.vol = 8;\n      else if (arg0 <= 8)\n        term.marginbell.vol = arg0;\n    when CPAIR(' ', 'Z'): /* PEC: ECMA-48 Presentation Expand Or Contract */\n      if (!arg0)\n        curs->width = 0;\n      else if (arg0 == 1)   // expanded\n        curs->width = 2;\n      else if (arg0 == 2) { // condensed\n        if (arg1 == 2)      // single-cell zoomed down\n          curs->width = 11;\n        else\n          curs->width = 1;\n      }\n      else if (arg0 == 22)  // single-cell zoomed down\n        curs->width = 11;\n#ifdef support_triple_width\n      else if (arg0 == 3)   // triple-cell\n        curs->width = 3;\n#endif\n    when CPAIR('-', 'p'): /* DECARR: VT520 Select Auto Repeat Rate */\n      if (arg0 <= 30)\n        term.repeat_rate = arg0;\n    when CPAIR('%', 'q'):  /* setup progress indicator on taskbar icon */\n      set_taskbar_progress(arg0, term.csi_argc > 1 ? arg1 : -1);\n    when 'y':  /* DECTST */\n      if (arg0 == 4) {\n        cattr attr = (cattr)\n                     {.attr = ATTR_DEFFG | (TRUE_COLOUR << ATTR_BGSHIFT),\n                      .truefg = 0, .truebg = 0, .ulcolr = (colour)-1,\n                      .link = -1\n                     };\n        switch (arg1) {\n          when 10: attr.truebg = RGB(0, 0, 255);\n          when 11: attr.truebg = RGB(255, 0, 0);\n          when 12: attr.truebg = RGB(0, 255, 0);\n          when 13: attr.truebg = RGB(255, 255, 255);\n          otherwise: return;\n        }\n        for (int i = 0; i < term.rows; i++) {\n          termline *line = term.lines[i];\n          for (int j = 0; j < term.cols; j++) {\n            line->chars[j] =\n              (termchar) {.cc_next = 0, .chr = ' ', attr};\n          }\n          line->lattr = LATTR_NORM;\n        }\n        term.disptop = 0;\n      }\n  }\n}\n\n/*\n * Fill image area with sixel placeholder characters and set cursor.\n */\nstatic void\nfill_image_space(imglist * img)\n{\n  cattrflags attr0 = term.curs.attr.attr;\n  // refer SIXELCH cells to image for display/discard management\n  term.curs.attr.imgi = img->imgi;\n#ifdef debug_img_disp\n  printf(\"fill %d:%d %d\\n\", term.curs.y, term.curs.x, img->imgi);\n#endif\n\n  short x0 = term.curs.x;\n  if (term.sixel_display) {  // sixel display mode\n    short y0 = term.curs.y;\n    term.curs.y = 0;\n    for (int y = 0; y < img->height && y < term.rows; ++y) {\n      term.curs.y = y;\n      term.curs.x = 0;\n      //printf(\"SIXELCH @%d imgi %d\\n\", y, term.curs.attr.imgi);\n      for (int x = x0; x < x0 + img->width && x < term.cols; ++x)\n        write_char(SIXELCH, 1);\n    }\n    term.curs.y = y0;\n    term.curs.x = x0;\n  } else {  // sixel scrolling mode\n    for (int i = 0; i < img->height; ++i) {\n      term.curs.x = x0;\n      //printf(\"SIXELCH @%d imgi %d\\n\", term.curs.y, term.curs.attr.imgi);\n      for (int x = x0; x < x0 + img->width && x < term.cols; ++x)\n        write_char(SIXELCH, 1);\n      if (i == img->height - 1) {  // in the last line\n        if (!term.sixel_scrolls_right) {\n          write_linefeed();\n          term.curs.x = term.sixel_scrolls_left ? 0: x0;\n        }\n      } else {\n        write_linefeed();\n      }\n    }\n  }\n\n  term.curs.attr.attr = attr0;\n}\n\nstatic void\ndo_dcs(void)\n{\n  // Implemented:\n  // DECRQSS (Request Status String)\n  // DECAUPSS (Assign User-Preferred Supplemental Set)\n  // DECSIXEL\n  // No DECUDK (User-Defined Keys) or xterm termcap/terminfo data.\n\n  char *s = term.cmd_buf;\n  if (!term.cmd_len)\n    *s = 0;\n\n  switch (term.dcs_cmd) {\n\n  when CPAIR('!', 'u'):  // DECAUPSS\n    if (term.state == DCS_ESCAPE) {\n      ushort nrc_code = 0;\n      if (term.cmd_len == 1)\n        nrc_code = *s;\n      else if (term.cmd_len == 2)\n        nrc_code = CPAIR(s[0], s[1]);\n      term_cset cs = lookup_cset(nrc_code, 7, false);\n      if (cs) {\n        term.curs.decsupp = cs;\n        term_update_cs();\n        return;\n      }\n    }\n\n  when 'q': {\n   sixel_state_t * st = (sixel_state_t *)term.imgs.parser_state;\n   int status = -1;\n\n   switch (term.state) {\n    when DCS_PASSTHROUGH:\n      if (!st)\n        return;\n      status = sixel_parser_parse(st, (unsigned char *)s, term.cmd_len);\n      if (status < 0) {\n        sixel_parser_deinit(st);\n        //printf(\"free state 1 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        term.state = DCS_IGNORE;\n        return;\n      }\n\n    when DCS_ESCAPE:\n      if (!st)\n        return;\n      status = sixel_parser_parse(st, (unsigned char *)s, term.cmd_len);\n      if (status < 0) {\n        sixel_parser_deinit(st);\n        //printf(\"free state 2 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        return;\n      }\n\n      unsigned char * pixels = sixel_parser_finalize(st);\n      //printf(\"sixel_parser_finalize %p\\n\", pixels);\n      sixel_parser_deinit(st);\n      if (!pixels) {\n        //printf(\"free state 3 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        return;\n      }\n\n      short left = term.curs.x;\n      short top = term.virtuallines + (term.sixel_display ? 0: term.curs.y);\n      int width = (st->image.width -1 ) / st->grid_width + 1;\n      int height = (st->image.height -1 ) / st->grid_height + 1;\n      int pixelwidth = st->image.width;\n      int pixelheight = st->image.height;\n      //printf(\"w %d/%d %d h %d/%d %d\\n\", pixelwidth, st->grid_width, width, pixelheight, st->grid_height, height);\n\n      imglist * img;\n      if (!winimg_new(&img, 0, pixels, 0, left, top, width, height, pixelwidth, pixelheight, false, 0, 0, 0, 0)) {\n        free(pixels);\n        sixel_parser_deinit(st);\n        //printf(\"free state 4 %p\\n\", term.imgs.parser_state);\n        free(term.imgs.parser_state);\n        term.imgs.parser_state = NULL;\n        return;\n      }\n      img->cwidth = st->max_x;\n      img->cheight = st->max_y;\n\n      fill_image_space(img);\n\n      // add image to image list;\n      // replace previous for optimisation in some cases\n      if (term.imgs.first == NULL) {\n        term.imgs.first = term.imgs.last = img;\n      } else {\n        // try some optimization: replace existing images if overwritten\n#ifdef debug_sixel_list\n        printf(\"do_dcs checking imglist\\n\");\n#endif\n#ifdef replace_images\n#warning do not replace images in the list anymore\n        // with new flicker-reduce strategy of rendering overlapped images,\n        // new images should always be added to the end of the queue;\n        // completely overlayed images should be collected for removal \n        // during the rendering loop (winimgs_paint),\n        // or latest when they are scrolled out of the scrollback buffer\n        for (imglist * cur = term.imgs.first; cur; cur = cur->next) {\n          if (cur->pixelwidth == cur->width * st->grid_width &&\n              cur->pixelheight == cur->height * st->grid_height)\n          {\n            // if same size, replace\n            if (img->top == cur->top && img->left == cur->left &&\n                img->width == cur->width &&\n                img->height == cur->height)\n            {\n#ifdef debug_sixel_list\n              printf(\"img replace\\n\");\n#endif\n              memcpy(cur->pixels, img->pixels, img->pixelwidth * img->pixelheight * 4);\n              cur->imgi = img->imgi;\n              winimg_destroy(img);\n              return;\n            }\n            // if new image within area of previous image, ...\n#ifdef handle_overlay_images\n#warning this creates some crash conditions...\n            if (img->top >= cur->top && img->left >= cur->left &&\n                img->left + img->width <= cur->left + cur->width &&\n                img->top + img->height <= cur->top + cur->height)\n            {\n              // inject new img into old structure;\n              // copy img data in stripes, for unknown reason\n              for (y = 0; y < img->pixelheight; ++y) {\n                memcpy(cur->pixels +\n                         ((img->top - cur->top) * st->grid_height + y) * cur->pixelwidth * 4 +\n                         (img->left - cur->left) * st->grid_width * 4,\n                       img->pixels + y * img->pixelwidth * 4,\n                       img->pixelwidth * 4);\n              }\n              cur->imgi = img->imgi;\n              winimg_destroy(img);\n              return;\n            }\n#endif\n          }\n        }\n#endif\n        // append image to list\n        img->prev = term.imgs.last;\n        term.imgs.last->next = img;\n        term.imgs.last = img;\n      }\n\n    otherwise: {\n      /* parser status initialization */\n      colour fg = win_get_colour(FG_COLOUR_I);\n      colour bg = win_get_colour(BG_COLOUR_I);\n      if (!st) {\n        st = term.imgs.parser_state = calloc(1, sizeof(sixel_state_t));\n        //printf(\"alloc state %d -> %p\\n\", (int)sizeof(sixel_state_t), st);\n        sixel_parser_set_default_color(st);\n      }\n      status = sixel_parser_init(st, fg, bg, term.private_color_registers);\n      if (status < 0)\n        return;\n    }\n   }\n  }\n\n  when CPAIR('$', 'q'):\n    switch (term.state) {\n    when DCS_ESCAPE: {     // DECRQSS\n      cattr attr = term.curs.attr;\n      if (!strcmp(s, \"m\")) { // SGR\n        char buf[90], *p = buf;\n        p += sprintf(p, \"\\eP1$r0\");\n\n        if (attr.attr & ATTR_BOLD)\n          p += sprintf(p, \";1\");\n        if (attr.attr & ATTR_DIM)\n          p += sprintf(p, \";2\");\n        if (attr.attr & ATTR_SHADOW)\n          p += sprintf(p, \";1:2\");\n        if (attr.attr & ATTR_ITALIC)\n          p += sprintf(p, \";3\");\n\n        if (attr.attr & ATTR_BROKENUND)\n          if (attr.attr & ATTR_DOUBLYUND)\n            p += sprintf(p, \";4:5\");\n          else\n            p += sprintf(p, \";4:4\");\n        else if ((attr.attr & UNDER_MASK) == ATTR_CURLYUND)\n          p += sprintf(p, \";4:3\");\n        else if (attr.attr & ATTR_UNDER)\n          p += sprintf(p, \";4\");\n\n        if (attr.attr & ATTR_BLINK)\n          p += sprintf(p, \";5\");\n        if (attr.attr & ATTR_BLINK2)\n          p += sprintf(p, \";6\");\n        if (attr.attr & ATTR_REVERSE)\n          p += sprintf(p, \";7\");\n        if (attr.attr & ATTR_INVISIBLE)\n          p += sprintf(p, \";8\");\n        if (attr.attr & ATTR_OVERSTRIKE)\n          p += sprintf(p, \";8:7\");\n        if (attr.attr & ATTR_STRIKEOUT)\n          p += sprintf(p, \";9\");\n        if ((attr.attr & UNDER_MASK) == ATTR_DOUBLYUND)\n          p += sprintf(p, \";21\");\n        if (attr.attr & ATTR_FRAMED)\n          p += sprintf(p, \";51;52\");\n        if (attr.attr & ATTR_OVERL)\n          p += sprintf(p, \";53\");\n        if (attr.attr & ATTR_SUPERSCR)\n          p += sprintf(p, \";73\");\n        if (attr.attr & ATTR_SUBSCR)\n          p += sprintf(p, \";74\");\n\n        if (term.curs.oem_acs)\n          p += sprintf(p, \";%u\", 10 + term.curs.oem_acs);\n        else {\n          uint ff = (attr.attr & FONTFAM_MASK) >> ATTR_FONTFAM_SHIFT;\n          if (ff)\n            p += sprintf(p, \";%u\", 10 + ff);\n        }\n\n        uint fg = (attr.attr & ATTR_FGMASK) >> ATTR_FGSHIFT;\n        if (fg != FG_COLOUR_I) {\n          if (fg >= TRUE_COLOUR)\n            //p += sprintf(p, \";38;2;%u;%u;%u\", attr.truefg & 0xFF, \n            //             (attr.truefg >> 8) & 0xFF, (attr.truefg >> 16) & 0xFF);\n            p += sprintf(p, \";38:2::%u:%u:%u\", attr.truefg & 0xFF, \n                         (attr.truefg >> 8) & 0xFF, (attr.truefg >> 16) & 0xFF);\n          else if (fg < 16)\n            p += sprintf(p, \";%u\", (fg < 8 ? 30 : 90) + (fg & 7));\n          else\n            //p += sprintf(p, \";38;5;%u\", fg);\n            p += sprintf(p, \";38:5:%u\", fg);\n        }\n\n        uint bg = (attr.attr & ATTR_BGMASK) >> ATTR_BGSHIFT;\n        if (bg != BG_COLOUR_I) {\n          if (bg >= TRUE_COLOUR)\n            //p += sprintf(p, \";48;2;%u;%u;%u\", attr.truebg & 0xFF, \n            //             (attr.truebg >> 8) & 0xFF, (attr.truebg >> 16) & 0xFF);\n            p += sprintf(p, \";48:2::%u:%u:%u\", attr.truebg & 0xFF, \n                         (attr.truebg >> 8) & 0xFF, (attr.truebg >> 16) & 0xFF);\n          else if (bg < 16)\n            p += sprintf(p, \";%u\", (bg < 8 ? 40 : 100) + (bg & 7));\n          else\n            //p += sprintf(p, \";48;5;%u\", bg);\n            p += sprintf(p, \";48:5:%u\", bg);\n        }\n\n        if (attr.attr & ATTR_ULCOLOUR) {\n          p += sprintf(p, \";58:2::%u:%u:%u\", attr.ulcolr & 0xFF, \n                       (attr.ulcolr >> 8) & 0xFF, (attr.ulcolr >> 16) & 0xFF);\n        }\n\n        p += sprintf(p, \"m\\e\\\\\");  // m for SGR, followed by ST\n\n        child_write(buf, p - buf);\n      } else if (!strcmp(s, \"r\")) {  // DECSTBM (scrolling region margins)\n        child_printf(\"\\eP1$r%u;%ur\\e\\\\\", term.marg_top + 1, term.marg_bot + 1);\n      } else if (!strcmp(s, \"s\")) {  // DECSLRM (left and right margins)\n        child_printf(\"\\eP1$r%u;%us\\e\\\\\", term.marg_left + 1, term.marg_right + 1);\n      } else if (!strcmp(s, \"\\\"p\")) {  // DECSCL (conformance level)\n        child_printf(\"\\eP1$r%u;%u\\\"p\\e\\\\\", 65, 1);  // report as VT500 S7C1T\n      } else if (!strcmp(s, \"\\\"q\")) {  // DECSCA (protection attribute)\n        child_printf(\"\\eP1$r%u\\\"q\\e\\\\\", (attr.attr & ATTR_PROTECTED) != 0);\n      } else if (!strcmp(s, \" q\")) {  // DECSCUSR (cursor style)\n        child_printf(\"\\eP1$r%u q\\e\\\\\", \n                     (term.cursor_type >= 0 ? term.cursor_type * 2 : 0) + 1\n                     + !(term.cursor_blinks & 1));\n      } else if (!strcmp(s, \"t\") && term.rows >= 24) {  // DECSLPP (lines)\n        child_printf(\"\\eP1$r%ut\\e\\\\\", term.rows);\n      } else if (!strcmp(s, \"$|\")) {  // DECSCPP (columns)\n        child_printf(\"\\eP1$r%u$|\\e\\\\\", term.cols);\n      } else if (!strcmp(s, \"*|\")) {  // DECSNLS (lines)\n        child_printf(\"\\eP1$r%u*|\\e\\\\\", term.rows);\n      } else {\n        child_printf(\"\\eP0$r%s\\e\\\\\", s);\n      }\n    }\n    otherwise:\n      return;\n    }\n\n  }\n}\n\nstatic void\ndo_colour_osc(bool has_index_arg, uint i, bool reset)\n{\n  int osc_num = term.cmd_num;  // 4, 5, 10..19, 104, 105, 110..119\n  char *s = term.cmd_buf;\n  int index;\n\ndo_osc_control:\n  //printf(\"OSC %d <%s>\\n\", osc_num, s);\n  if (has_index_arg) {  // OSC 4, 5, 104, 105\n    int osc = i;  // 4, 5\n    int len = 0;\n    sscanf(s, \"%u;%n\", &index, &len);\n    i = index;\n    if ((reset ? len != 0 : len == 0) || i >= COLOUR_NUM)\n      return;\n    s += len;\n    if (osc % 100 == 5) {\n      if (i == 0)\n        i = BOLD_COLOUR_I;\n#ifdef other_color_substitutes\n      else if (i == 1)\n        i = UNDERLINE_COLOUR_I;\n      else if (i == 2)\n        i = BLINK_COLOUR_I;\n      else if (i == 3)\n        i = REVERSE_COLOUR_I;\n      else if (i == 4)\n        i = ITALIC_COLOUR_I;\n#endif\n      else if (i > 4)\n        return;\n      else {\n        // skip unimplemented setting, continue to process multiple controls\n        i = COLOUR_NUM;\n      }\n    }\n    else if (i >= 256)\n      return;\n  }\n\n  char * cont = strchr(s, ';');\n  if (cont)\n    *cont = 0;  // enable colour parsing with subsequent multiple values\n\n  colour c;\n  if (i >= COLOUR_NUM) {\n    // skip this setting\n  }\n  else if (reset)\n    win_set_colour(i, (colour)-1);\n  else if (!strcmp(s, \"?\")) {\n    child_printf(\"\\e]%u;\", osc_num);\n    if (has_index_arg)\n      child_printf(\"%u;\", index);\n    c = i < COLOUR_NUM ? colours[i] : 0;  // should not be affected by rvideo\n    char * osc_fini = term.state == CMD_ESCAPE ? \"\\e\\\\\" : \"\\a\";\n    child_printf(\"rgb:%04x/%04x/%04x%s\",\n                 red(c) * 0x101, green(c) * 0x101, blue(c) * 0x101, osc_fini);\n  }\n  else if (parse_colour(s, &c))\n    win_set_colour(i, c);\n\n  if (cont) {  // support multiple osc controls\n    s = cont;  // original ';' position\n    s++;\n    if (osc_num >= 10 && osc_num <= 19) {  // \"dynamic colors\"\n      int new_num;\n      int len = 0;\n      sscanf(s, \"%u;%n\", &new_num, &len);\n      if (len) {  // OSC 10;blue;12;red\n        s += len;\n        osc_num = new_num;\n      }\n      else  // OSC 10;blue;pink: auto-increment dynamic color index\n        osc_num++;\n      // adjust i (the extended colour palette index)\n      // to the new dynamic color number;\n      // what a hack! this should have been done in do_cmd\n      switch (osc_num) {\n        when 10:   i = FG_COLOUR_I;\n        when 11:   i = BG_COLOUR_I;\n        when 12:   i = CURSOR_COLOUR_I;\n        when 17:   i = SEL_COLOUR_I;\n        when 19:   i = SEL_TEXT_COLOUR_I;\n        when 15:   i = TEK_FG_COLOUR_I;\n        when 16:   i = TEK_BG_COLOUR_I;\n        when 18:   i = TEK_CURSOR_COLOUR_I;\n        otherwise: i = COLOUR_NUM;\n      }\n    }\n    goto do_osc_control;\n  }\n}\n\n/*\n * OSC 52: \\e]52;[cp0-6];?|base64-string\\07\"\n * Only system clipboard is supported now.\n */\nstatic void\ndo_clipboard(void)\n{\n  char *s = term.cmd_buf;\n  char *output;\n  int len;\n  int ret;\n\n  if (!cfg.allow_set_selection) {\n    return;\n  }\n\n  while (*s != ';' && *s != '\\0') {\n    s += 1;\n  }\n  if (*s != ';') {\n    return;\n  }\n  s += 1;\n  if (*s == '?') {\n    /* Reading from clipboard is unsupported */\n    return;\n  }\n  len = strlen(s);\n\n  output = malloc(len + 1);\n  if (output == NULL) {\n    return;\n  }\n\n  ret = base64_decode_clip(s, len, output, len);\n  if (ret > 0) {\n    output[ret] = '\\0';\n    win_copy_text(output);\n  }\n  free(output);\n}\n\n/*\n * Process OSC command sequences.\n */\nstatic void\ndo_cmd(void)\n{\n  char *s = term.cmd_buf;\n  s[term.cmd_len] = 0;\n  //printf(\"OSC %d <%s> %s\\n\", term.cmd_num, s, term.state == CMD_ESCAPE ? \"ST\" : \"BEL\");\n  char * osc_fini = term.state == CMD_ESCAPE ? \"\\e\\\\\" : \"\\a\";\n\n  if (*cfg.suppress_osc && contains(cfg.suppress_osc, term.cmd_num))\n    // skip suppressed OSC command\n    return;\n\n  switch (term.cmd_num) {\n    when 0 or 2: win_set_title(s);  // ignore icon title\n    when 4:   do_colour_osc(true, 4, false);\n    when 5:   do_colour_osc(true, 5, false);\n    when 6 or 106: {\n      int col, on;\n      if (sscanf(term.cmd_buf, \"%u;%u\", &col, &on) == 2)\n        if (col == 0)\n          term.enable_bold_colour = on;\n    }\n    when 104: do_colour_osc(true, 4, true);\n    when 105: do_colour_osc(true, 5, true);\n    when 10:  do_colour_osc(false, FG_COLOUR_I, false);\n    when 11:  if (strchr(\"*_%=\", *term.cmd_buf)) {\n                wchar * bn = cs__mbstowcs(term.cmd_buf);\n                wstrset(&cfg.background, bn);\n                free(bn);\n                if (*term.cmd_buf == '%')\n                  scale_to_image_ratio();\n                win_invalidate_all(true);\n              }\n              else\n                do_colour_osc(false, BG_COLOUR_I, false);\n    when 12:  do_colour_osc(false, CURSOR_COLOUR_I, false);\n    when 17:  do_colour_osc(false, SEL_COLOUR_I, false);\n    when 19:  do_colour_osc(false, SEL_TEXT_COLOUR_I, false);\n    when 15:  do_colour_osc(false, TEK_FG_COLOUR_I, false);\n    when 16:  do_colour_osc(false, TEK_BG_COLOUR_I, false);\n    when 18:  do_colour_osc(false, TEK_CURSOR_COLOUR_I, false);\n    when 110: do_colour_osc(false, FG_COLOUR_I, true);\n    when 111: do_colour_osc(false, BG_COLOUR_I, true);\n    when 112: do_colour_osc(false, CURSOR_COLOUR_I, true);\n    when 117: do_colour_osc(false, SEL_COLOUR_I, true);\n    when 119: do_colour_osc(false, SEL_TEXT_COLOUR_I, true);\n    when 115: do_colour_osc(false, TEK_FG_COLOUR_I, true);\n    when 116: do_colour_osc(false, TEK_BG_COLOUR_I, true);\n    when 118: do_colour_osc(false, TEK_CURSOR_COLOUR_I, true);\n    when 7:  // Set working directory (from Mac Terminal) for Alt+F2\n      // extract dirname from file://host/path scheme\n      if (!strncmp(s, \"file:\", 5))\n        s += 5;\n      if (!strncmp(s, \"//localhost/\", 12))\n        s += 11;\n      else if (!strncmp(s, \"///\", 3))\n        s += 2;\n      if (!*s || *s == '/')\n        child_set_fork_dir(s);\n    when 701:  // Set/get locale (from urxvt).\n      if (!strcmp(s, \"?\"))\n        child_printf(\"\\e]701;%s%s\", cs_get_locale(), osc_fini);\n      else\n        cs_set_locale(s);\n    when 7721:  // Copy window title to clipboard.\n      win_copy_title();\n    when 7773: {  // Change icon.\n      uint icon_index = 0;\n      char *comma = strrchr(s, ',');\n      if (comma) {\n        char *start = comma + 1, *end;\n        icon_index = strtoul(start, &end, 0);\n        if (start != end && !*end)\n          *comma = 0;\n        else\n          icon_index = 0;\n      }\n      win_set_icon(s, icon_index);\n    }\n    when 7770:  // Change font size.\n      if (!strcmp(s, \"?\"))\n        child_printf(\"\\e]7770;%u%s\", win_get_font_size(), osc_fini);\n      else {\n        char *end;\n        int i = strtol(s, &end, 10);\n        if (*end)\n          ; // Ignore if parameter contains unexpected characters\n        else if (*s == '+' || *s == '-')\n          win_zoom_font(i, false);\n        else\n          win_set_font_size(i, false);\n      }\n    when 7777:  // Change font and window size.\n      if (!strcmp(s, \"?\"))\n        child_printf(\"\\e]7777;%u%s\", win_get_font_size(), osc_fini);\n      else {\n        char *end;\n        int i = strtol(s, &end, 10);\n        if (*end)\n          ; // Ignore if parameter contains unexpected characters\n        else if (*s == '+' || *s == '-')\n          win_zoom_font(i, true);\n        else\n          win_set_font_size(i, true);\n      }\n    when 7771: {  // Enquire about font support for a list of characters\n      if (*s++ != '?')\n        return;\n      wchar wcs[term.cmd_len];\n      uint n = 0;\n      while (*s) {\n        if (*s++ != ';')\n          return;\n        wcs[n++] = strtoul(s, &s, 10);\n      }\n      win_check_glyphs(wcs, n, term.curs.attr.attr);\n      s = term.cmd_buf;\n      for (size_t i = 0; i < n; i++) {\n        *s++ = ';';\n        if (wcs[i])\n          s += sprintf(s, \"%u\", wcs[i]);\n      }\n      *s = 0;\n      child_printf(\"\\e]7771;!%s%s\", term.cmd_buf, osc_fini);\n    }\n    when 77119: {  // Indic and Extra characters wide handling\n      int what = atoi(s);\n      term.wide_indic = false;\n      term.wide_extra = false;\n      if (what & 1)\n        term.wide_indic = true;\n      if (what & 2)\n        term.wide_extra = true;\n    }\n    when 52: do_clipboard();\n    when 50:\n      if (tek_mode) {\n        tek_set_font(cs__mbstowcs(s));\n        tek_init(false, cfg.tek_glow);\n      }\n      else {\n        uint ff = (term.curs.attr.attr & FONTFAM_MASK) >> ATTR_FONTFAM_SHIFT;\n        if (!strcmp(s, \"?\")) {\n          char * fn = cs__wcstombs(win_get_font(ff) ?: W(\"\"));\n          child_printf(\"\\e]50;%s%s\", fn, osc_fini);\n          free(fn);\n        }\n        else {\n          if (ff < lengthof(cfg.fontfams) - 1) {\n            wstring wfont = cs__mbstowcs(s);  // let this leak...\n            win_change_font(ff, wfont);\n          }\n        }\n      }\n    when 8: {  // hyperlink attribute\n      char * link = s;\n      char * url = strchr(s, ';');\n      if (url++ && *url) {\n        term.curs.attr.link = putlink(link);\n      }\n      else\n        term.curs.attr.link = -1;\n    }\n    when 1337: {  // iTerm2 image protocol\n                  // https://www.iterm2.com/documentation-images.html\n      char * payload = strchr(s, ':');\n      if (payload) {\n        *payload = 0;\n        payload++;\n      }\n\n      // verify protocol\n      if (0 == strncmp(\"File=\", s, 5))\n        s += 5;\n      else\n        return;\n\n      char * name = 0;\n      int width = 0;\n      int height = 0;\n      int pixelwidth = 0;\n      int pixelheight = 0;\n      bool pAR = true;\n      int crop_x = 0;\n      int crop_y = 0;\n      int crop_width = 0;\n      int crop_height = 0;\n\n      // process parameters\n      while (s && *s) {\n        char * nxt = strchr(s, ';');\n        if (nxt) {\n          *nxt = 0;\n          nxt++;\n        }\n        char * sval = strchr(s, '=');\n        if (sval) {\n          *sval = 0;\n          sval++;\n        }\n        else\n          sval = \"\";\n        int val = atoi(sval);\n        char * suf = sval;\n        while (isdigit((uchar)*suf))\n          suf++;\n        bool pix = 0 == strcmp(\"px\", suf);\n        bool per = 0 == strcmp(\"%\", suf);\n        //printf(\"<%s>=<%s>%d<%s>\\n\", s, sval, val, suf);\n\n        if (0 == strcmp(\"name\", s))\n          name = s;  // can serve as cache id\n        else if (0 == strcmp(\"width\", s)) {\n          if (pix) {\n            pixelwidth = val;\n            width = (val - 1) / cell_width + 1;\n          }\n          else if (per) {\n            width = term.cols * val / 100;\n            pixelwidth = width * cell_width;\n          }\n          else {\n            width = val;\n            pixelwidth = val * cell_width;\n          }\n        }\n        else if (0 == strcmp(\"height\", s)) {\n          if (pix) {\n            pixelheight = val;\n            height = (val - 1) / cell_height + 1;\n          }\n          else if (per) {\n            height = term.rows * val / 100;\n            pixelheight = height * cell_height;\n          }\n          else {\n            height = val;\n            pixelheight = val * cell_height;\n          }\n        }\n        else if (0 == strcmp(\"preserveAspectRatio\", s)) {\n          pAR = val;\n        }\n        else if (0 == strcmp(\"cropX\", s) || 0 == strcmp(\"cropLeft\", s)) {\n          if (pix) {\n            crop_x = val;\n          }\n        }\n        else if (0 == strcmp(\"cropY\", s) || 0 == strcmp(\"cropTop\", s)) {\n          if (pix) {\n            crop_y = val;\n          }\n        }\n        else if (0 == strcmp(\"cropWidth\", s)) {\n          if (pix) {\n            crop_width = val;\n          }\n        }\n        else if (0 == strcmp(\"cropHeight\", s)) {\n          if (pix) {\n            crop_height = val;\n          }\n        }\n        else if (0 == strcmp(\"cropRight\", s)) {\n          if (pix) {\n            crop_width = - val;\n          }\n        }\n        else if (0 == strcmp(\"cropBottom\", s)) {\n          if (pix) {\n            crop_height = - val;\n          }\n        }\n\n        s = nxt;\n      }\n\n      if (payload) {\n#ifdef strip_newlines\n#warning not applicable as preprocessing OSC would not pass it here\n        char * from = strpbrk(payload, \"\\r\\n\");\n        if (from) {  // strip new lines\n          char * to = from;\n          while (*from) {\n            if (*from >= ' ')\n              *to++ = *from;\n            from++;\n          }\n          *to = 0;\n        }\n#endif\n        int len = strlen(payload);\n        int datalen = len - (len / 4);\n        void * data = malloc(datalen);\n        if (!data)\n          return;\n        datalen = base64_decode_clip(payload, len, data, datalen);\n        if (datalen > 0) {\n          // OK\n          imglist * img;\n          short left = term.curs.x;\n          short top = term.virtuallines + term.curs.y;\n          if (winimg_new(&img, name, data, datalen, left, top, width, height, pixelwidth, pixelheight, pAR, crop_x, crop_y, crop_width, crop_height)) {\n            fill_image_space(img);\n\n            if (term.imgs.first == NULL) {\n              term.imgs.first = term.imgs.last = img;\n            } else {\n              // append image to list\n              img->prev = term.imgs.last;\n              term.imgs.last->next = img;\n              term.imgs.last = img;\n            }\n          }\n          else\n            free(data);\n        }\n        else\n          free(data);\n      }\n    }\n    when 9: {\ntypedef struct {\n  char * p;\n  int v;\n} paramap;\n      int scanenum(char * s, int * _i, paramap * p, bool donum) {\n        char * sep = strchr(s, ';');\n        int len = sep ? (uint)(sep - s) : strlen(s);\n        while (p->p) {\n          if (0 == strncasecmp(s, p->p, len)) {\n            *_i = p->v;\n            return len;\n          }\n          p++;\n        }\n        if (donum) {\n          // fallback scan for number\n          int numlen = sscanf(s, \"%d\", _i);\n          if (numlen && numlen == len)\n            return numlen;\n        }\n        // not found\n        return 0;\n      }\n\n      int cmd;\n      int len = scanenum(s, &cmd,\n                         (paramap[]){{\"4\", 4}, {\"progress\", 4}, {0, 0}},\n                         false);\n      if (!len || cmd != 4)\n        return;\n      s += len;\n\n      if (!*s)\n        return;\n      s++;\n      int state;\n      len = scanenum(s, &state,\n                     (paramap[]){\n                                 {\"off\", 0},\n                                 {\"green\", 1},\n                                 {\"yellow\", 2},\n                                 {\"red\", 3},\n                                 {\"busy\", 8},\n                                 {\"0\", 0},\n                                 {\"1\", 1},\n                                 {\"4\", 2},\n                                 {\"2\", 3},\n                                 {\"3\", 8},\n                                 {0, 0}},\n                     false);\n      if (!len)\n        return;\n      s += len;\n\n      int percent = -1;\n      if (*s) {\n        s++;\n        sscanf(s, \"%d\", &percent);\n      }\n\n      set_taskbar_progress(state, percent);\n    }\n  }\n}\n\nvoid\nterm_print_finish(void)\n{\n  if (term.printing) {\n    printer_write(term.printbuf, term.printbuf_pos);\n    free(term.printbuf);\n    term.printbuf = 0;\n    term.printbuf_size = term.printbuf_pos = 0;\n    printer_finish_job();\n    term.printing = term.only_printing = false;\n  }\n}\n\nstatic void\nterm_do_write(const char *buf, uint len)\n{\n  //check e.g. if progress indication is following by CR\n  //printf(\"[%ld] write %02X...%02X\\n\", mtime(), *buf, buf[len - 1]);\n\n  // Reset cursor blinking.\n  term.cblinker = 1;\n  term_schedule_cblink();\n\n  short oldy = term.curs.y;\n\n  uint pos = 0;\n  while (pos < len) {\n    uchar c = buf[pos++];\n\n   /*\n    * If we're printing, add the character to the printer buffer.\n    */\n    if (term.printing) {\n      if (term.printbuf_pos >= term.printbuf_size) {\n        term.printbuf_size = term.printbuf_size * 4 + 4096;\n        term.printbuf = renewn(term.printbuf, term.printbuf_size);\n      }\n      term.printbuf[term.printbuf_pos++] = c;\n\n     /*\n      * If we're in print-only mode, we use a much simpler state machine \n      * designed only to recognise the ESC[4i termination sequence.\n      */\n      if (term.only_printing) {\n        if (c == '\\e')\n          term.print_state = 1;\n        else if (c == '[' && term.print_state == 1)\n          term.print_state = 2;\n        else if (c == '4' && term.print_state == 2)\n          term.print_state = 3;\n        else if (c == 'i' && term.print_state == 3) {\n          term.printbuf_pos -= 4;\n          term_print_finish();\n        }\n        else\n          term.print_state = 0;\n        continue;\n      }\n    }\n\n    switch (term.state) {\n      when NORMAL: {\n        wchar wc;\n\n        if (term.curs.oem_acs && !memchr(\"\\e\\n\\r\\b\", c, 4)) {\n          if (term.curs.oem_acs == 2)\n            c |= 0x80;\n          write_ucschar(0, cs_btowc_glyph(c), 1);\n          continue;\n        }\n\n        // handle NRC single shift and NRC GR invocation;\n        // maybe we should handle control characters first?\n        short cset = term.curs.csets[term.curs.gl];\n        if (term.curs.cset_single != CSET_ASCII && c > 0x20 && c < 0xFF) {\n          cset = term.curs.cset_single;\n          term.curs.cset_single = CSET_ASCII;\n        }\n        else if (term.decnrc_enabled\n         && term.curs.gr && term.curs.csets[term.curs.gr] != CSET_ASCII\n         && !term.curs.oem_acs && !term.curs.utf\n         && c >= 0x80 && c < 0xFF) {\n          // tune C1 behaviour to mimic xterm\n          if (c < 0xA0)\n            continue;\n\n          c &= 0x7F;\n          cset = term.curs.csets[term.curs.gr];\n        }\n\n        if (term.vt52_mode) {\n          if (term.vt52_mode > 1)\n            cset = CSET_VT52DRW;\n          else\n            cset = CSET_ASCII;\n        }\n        else if (cset == CSET_DECSUPP)\n          cset = term.curs.decsupp;\n\n        switch (cs_mb1towc(&wc, c)) {\n          when 0: // NUL or low surrogate\n            if (wc)\n              pos--;\n          when -1: // Encoding error\n            if (!tek_mode)\n              write_error();\n            if (term.in_mb_char || term.high_surrogate)\n              pos--;\n            term.high_surrogate = 0;\n            term.in_mb_char = false;\n            cs_mb1towc(0, 0); // Clear decoder state\n            continue;\n          when -2: // Incomplete character\n            term.in_mb_char = true;\n            continue;\n        }\n\n        term.in_mb_char = false;\n\n        // Fetch previous high surrogate\n        wchar hwc = term.high_surrogate;\n        term.high_surrogate = 0;\n\n        if (is_low_surrogate(wc)) {\n          if (hwc) {\n#if HAS_LOCALES\n            int width = (cfg.charwidth % 10)\n                        ? xcwidth(combine_surrogates(hwc, wc)) :\n# ifdef __midipix__\n                        wcwidth(combine_surrogates(hwc, wc));\n# else\n                        wcswidth((wchar[]){hwc, wc}, 2);\n# endif\n#else\n            int width = xcwidth(combine_surrogates(hwc, wc));\n#endif\n#ifdef support_triple_width\n            // do not handle triple-width here\n            //if (term.curs.width)\n            //  width = term.curs.width % 10;\n#endif\n            write_ucschar(hwc, wc, width);\n          }\n          else\n            write_error();\n          continue;\n        }\n\n        if (hwc) // Previous high surrogate not followed by low one\n          write_error();\n\n        // ASCII shortcut for some speedup (~5%), earliest applied here\n        if (wc >= ' ' && wc <= 0x7E && cset == CSET_ASCII) {\n          write_ucschar(0, wc, 1);\n          continue;\n        }\n\n        if (is_high_surrogate(wc)) {\n          term.high_surrogate = wc;\n          continue;\n        }\n\n        // Non-characters\n        if (wc == 0xFFFE || wc == 0xFFFF) {\n          write_error();\n          continue;\n        }\n\n        // Everything else\n        wchar NRC(wchar * map)\n        {\n          static char * rpl = \"#@[\\\\]^_`{|}~\";\n          char * match = strchr(rpl, c);\n          if (match)\n            return map[match - rpl];\n          else\n            return wc;\n        }\n\n        cattrflags asav = term.curs.attr.attr;\n\n        switch (cset) {\n          when CSET_VT52DRW:  // VT52 \"graphics\" mode\n            if (0x5E <= wc && wc <= 0x7E) {\n              uchar dispcode = 0;\n              uchar gcode = 0;\n              if ('l' <= wc && wc <= 's') {\n                dispcode = wc - 'l' + 1;\n                gcode = 13;\n              }\n              else if ('c' <= wc && wc <= 'e') {\n                dispcode = 0xF;\n              }\n              wc = W(\"^ \uffff\u25ae\u215f\u00b3\u2075\u2077\u00b0\u00b1\u2192\u2026\u00f7\u2193\u23ba\u23ba\u23bb\u23bb\u23bc\u23bc\u23bd\u23bd\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\u00b6\") [c - 0x5E];\n              term.curs.attr.attr |= ((cattrflags)dispcode) << ATTR_GRAPH_SHIFT;\n              if (gcode) {\n                // extend graph encoding with unused font number\n                term.curs.attr.attr &= ~FONTFAM_MASK;\n                term.curs.attr.attr |= (cattrflags)gcode << ATTR_FONTFAM_SHIFT;\n              }\n            }\n          when CSET_LINEDRW:  // VT100 line drawing characters\n            if (0x60 <= wc && wc <= 0x7E) {\n              wchar dispwc = win_linedraw_char(wc - 0x60);\n#define draw_vt100_line_drawing_chars\n#ifdef draw_vt100_line_drawing_chars\n              if ('j' <= wc && wc <= 'x') {\n                static uchar linedraw_code[31] = {\n                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n#if __GNUC__ >= 5\n                  0b1001, 0b1100, 0b0110, 0b0011, 0b1111,  // \u2518\u2510\u250c\u2514\u253c\n                  0x10, 0x20, 0b1010, 0x40, 0x50,          // \u23ba\u23bb\u2500\u23bc\u23bd\n                  0b0111, 0b1101, 0b1011, 0b1110, 0b0101,  // \u251c\u2524\u2534\u252c\u2502\n#else // < 4.3\n                  0x09, 0x0C, 0x06, 0x03, 0x0F,  // \u2518\u2510\u250c\u2514\u253c\n                  0x10, 0x20, 0x0A, 0x40, 0x50,  // \u23ba\u23bb\u2500\u23bc\u23bd\n                  0x07, 0x0D, 0x0B, 0x0E, 0x05,  // \u251c\u2524\u2534\u252c\u2502\n#endif\n                  0, 0, 0, 0, 0, 0\n                };\n                uchar dispcode = linedraw_code[wc - 0x60];\n                if (dispcode) {\n                  uchar gcode = 11;\n                  if (dispcode >> 4) {\n                    dispcode >>= 4;\n                    gcode++;\n                  }\n                  term.curs.attr.attr |= ((cattrflags)dispcode) << ATTR_GRAPH_SHIFT;\n                  // extend graph encoding with unused font numbers\n                  term.curs.attr.attr &= ~FONTFAM_MASK;\n                  term.curs.attr.attr |= (cattrflags)gcode << ATTR_FONTFAM_SHIFT;\n                }\n              }\n#endif\n              wc = dispwc;\n            }\n          when CSET_TECH:  // DEC Technical character set\n            if (c > ' ' && c < 0x7F) {\n              // = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u239b\u239d\u239e\u23a0\u23a8\u23ac\uffff\uffff\u2572\u2571\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7\u0394\u2207\u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n              // = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u239b\u239d\u239e\u23a0\u23a8\u23ac\u2576\u2576\u2572\u2571\u2574\u2574\u2573\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7\u0394\u2207\u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n              // = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u23a7\u23a9\u23ab\u23ad\u23a8\u23ac\u2576\u2576\u2572\u2571\u2574\u2574\u2573\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7\u0394\u2207\u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n              wc = W(\"\u23b7\u250c\u2500\u2320\u2321\u2502\u23a1\u23a3\u23a4\u23a6\u23a7\u23a9\u23ab\u23ad\u23a8\u23ac\u2576\u2576\u2572\u2571\u2574\u2574\u2573\uffff\uffff\uffff\uffff\u2264\u2260\u2265\u222b\u2234\u221d\u221e\u00f7  \u03a6\u0393\u223c\u2243\u0398\u00d7\u039b\u21d4\u21d2\u2261\u03a0\u03a8\uffff\u03a3\uffff\uffff\u221a\u03a9\u039e\u03a5\u2282\u2283\u2229\u222a\u2227\u2228\u00ac\u03b1\u03b2\u03c7\u03b4\u03b5\u03c6\u03b3\u03b7\u03b9\u03b8\u03ba\u03bb\uffff\u03bd\u2202\u03c0\u03c8\u03c1\u03c3\u03c4\uffff\u0192\u03c9\u03be\u03c5\u03b6\u2190\u2191\u2192\u2193\")\n                   [c - ' ' - 1];\n              uchar dispcode = 0;\n              if (c <= 0x37) {\n                static uchar techdraw_code[23] = {\n                  0xE,                          // square root base\n                  0, 0, 0, 0, 0,\n                  0x8, 0x9, 0xA, 0xB,           // square bracket corners\n                  0, 0, 0, 0,                   // curly bracket hooks\n                  0, 0,                         // curly bracket middle pieces\n                  0x1, 0x2, 0, 0, 0x5, 0x6, 0x7 // sum segments\n                };\n                dispcode = techdraw_code[c - 0x21];\n              }\n              else if (c == 0x44)\n                dispcode = 0xC;\n              else if (c == 0x45)\n                dispcode = 0xD;\n              term.curs.attr.attr |= ((cattrflags)dispcode) << ATTR_GRAPH_SHIFT;\n            }\n          when CSET_NL:\n            wc = NRC(W(\"\u00a3\u00be\u0133\u00bd|^_`\u00a8\u0192\u00bc\u00b4\"));  // Dutch\n          when CSET_FI:\n            wc = NRC(W(\"#@\u00c4\u00d6\u00c5\u00dc_\u00e9\u00e4\u00f6\u00e5\u00fc\"));  // Finnish\n          when CSET_FR:\n            wc = NRC(W(\"\u00a3\u00e0\u00b0\u00e7\u00a7^_`\u00e9\u00f9\u00e8\u00a8\"));  // French\n          when CSET_CA:\n            wc = NRC(W(\"#\u00e0\u00e2\u00e7\u00ea\u00ee_\u00f4\u00e9\u00f9\u00e8\u00fb\"));  // French Canadian\n          when CSET_DE:\n            wc = NRC(W(\"#\u00a7\u00c4\u00d6\u00dc^_`\u00e4\u00f6\u00fc\u00df\"));  // German\n          when CSET_IT:\n            wc = NRC(W(\"\u00a3\u00a7\u00b0\u00e7\u00e9^_\u00f9\u00e0\u00f2\u00e8\u00ec\"));  // Italian\n          when CSET_NO:\n            wc = NRC(W(\"#\u00c4\u00c6\u00d8\u00c5\u00dc_\u00e4\u00e6\u00f8\u00e5\u00fc\"));  // Norwegian/Danish\n          when CSET_PT:\n            wc = NRC(W(\"#@\u00c3\u00c7\u00d5^_`\u00e3\u00e7\u00f5~\"));  // Portuguese\n          when CSET_ES:\n            wc = NRC(W(\"\u00a3\u00a7\u00a1\u00d1\u00bf^_`\u00b0\u00f1\u00e7~\"));  // Spanish\n          when CSET_SE:\n            wc = NRC(W(\"#\u00c9\u00c4\u00d6\u00c5\u00dc_\u00e9\u00e4\u00f6\u00e5\u00fc\"));  // Swedish\n          when CSET_CH:\n            wc = NRC(W(\"\u00f9\u00e0\u00e9\u00e7\u00ea\u00ee\u00e8\u00f4\u00e4\u00f6\u00fc\u00fb\"));  // Swiss\n          when CSET_DECSPGR   // DEC Supplemental Graphic\n            or CSET_DECSUPP:  // DEC Supplemental (user-preferred in VT*)\n            if (c > ' ' && c < 0x7F) {\n              wc = W(\"\u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a4\u00a9\u00aa\u00ab\uffff\uffff\uffff\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00ba\u00bb\u00bc\u00bd\uffff\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\uffff\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0152\u00d8\u00d9\u00da\u00db\u00dc\u0178\uffff\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\uffff\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0153\u00f8\u00f9\u00fa\u00fb\u00fc\u00ff\uffff\")\n                   [c - ' ' - 1];\n            }\n          // 96-character sets (UK / xterm 336)\n          when CSET_GBCHR:  // NRC United Kingdom\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Latin_Cyrillic:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040a\u040b\u040c\u00ad\u040e\u040f\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045a\u045b\u045c\u00a7\u045e\u045f\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Greek_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u2018\u2019\u00a3\u20ac\u20af\u00a6\u00a7\u00a8\u00a9\u037a\u00ab\u00ac\u00ad\uffff\u2015\u00b0\u00b1\u00b2\u00b3\u0384\u0385\u0386\u00b7\u0388\u0389\u038a\u00bb\u038c\u00bd\u038e\u038f\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\uffff\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\u03aa\u03ab\u03ac\u03ad\u03ae\u03af\u03b0\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c2\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\u03ca\u03cb\u03cc\u03cd\u03ce\u007f\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Hebrew:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\uffff\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00d7\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00f7\u00bb\u00bc\u00bd\u00be\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u2017\u05d0\u05d1\u05d2\u05d3\u05d4\u05d5\u05d6\u05d7\u05d8\u05d9\u05da\u05db\u05dc\u05dd\u05de\u05df\u05e0\u05e1\u05e2\u05e3\u05e4\u05e5\u05e6\u05e7\u05e8\u05e9\u05ea\uffff\uffff\u200e\u200f\u007f\")\n                   [c - ' '];\n            }\n          when CSET_ISO_Latin_5:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u011e\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u0130\u015e\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u011f\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u0131\u015f\u00ff\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Greek_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a4\u00a9\u00aa\u00ab\uffff\uffff\uffff\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00ba\u00bb\u00bc\u00bd\uffff\u00bf\u03ca\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\uffff\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\u03ac\u03ad\u03ae\u03af\uffff\u03cc\u03cb\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\uffff\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\u03c2\u03cd\u03ce\u0384\uffff\u007f\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Hebrew_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" \u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a8\u00a9\u00d7\u00ab\uffff\uffff\uffff\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00f7\u00bb\u00bc\u00bd\uffff\u00bf\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u05d0\u05d1\u05d2\u05d3\u05d4\u05d5\u05d6\u05d7\u05d8\u05d9\u05da\u05db\u05dc\u05dd\u05de\u05df\u05e0\u05e1\u05e2\u05e3\u05e4\u05e5\u05e6\u05e7\u05e8\u05e9\u05ea\uffff\uffff\uffff\uffff\u007f\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Turkish_Supp:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" \u00a1\u00a2\u00a3\uffff\u00a5\uffff\u00a7\u00a8\u00a9\u00aa\u00ab\uffff\uffff\u0130\uffff\u00b0\u00b1\u00b2\u00b3\uffff\u00b5\u00b6\u00b7\uffff\u00b9\u00ba\u00bb\u00bc\u00bd\u0131\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u011e\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0152\u00d8\u00d9\u00da\u00db\u00dc\u0178\u015e\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u011f\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0153\u00f8\u00f9\u00fa\u00fb\u00fc\u00ff\u015f\u007f\")\n                   [c - ' '];\n            }\n          when CSET_DEC_Cyrillic:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\"\u00a0\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\u044e\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u044f\u0440\u0441\u0442\u0443\u0436\u0432\u044c\u044b\u0437\u0448\u044d\u0449\u0447\u044a\u042e\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u042f\u0420\u0421\u0422\u0423\u0416\u0412\u042c\u042b\u0417\u0428\u042d\u0429\u0427\u042a\")\n                   [c - ' '];\n            }\n          when CSET_NRCS_Greek:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u03a7\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u039e\u03a8\u03a9\uffff\uffff{|}~\u007f\")\n                   [c - ' '];\n            }\n          when CSET_NRCS_Hebrew:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\u05d0\u05d1\u05d2\u05d3\u05d4\u05d5\u05d6\u05d7\u05d8\u05d9\u05da\u05db\u05dc\u05dd\u05de\u05df\u05e0\u05e1\u05e2\u05e3\u05e4\u05e5\u05e6\u05e7\u05e8\u05e9\u05ea{|}~\u007f\")\n                   [c - ' '];\n            }\n          when CSET_NRCS_Turkish:\n            if (c >= ' ' && c <= 0x7F) {\n              wc = W(\" !\\\"#$%\u011f'()*+,-./0123456789:;<=>?\u0130ABCDEFGHIJKLMNOPQRSTUVWXYZ\u015e\u00d6\u00c7\u00dc_\u011eabcdefghijklmnopqrstuvwxyz\u015f\u00f6\u00e7\u00fc\u007f\")\n                   [c - ' '];\n            }\n          otherwise: ;\n        }\n\n        // Some more special graphic renderings\n        if (wc >= 0x2580 && wc <= 0x259F) {\n          // Block Elements (U+2580-U+259F)\n          // \u2580\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588\u2589\u258a\u258b\u258c\u258d\u258e\u258f\u2590\u2591\u2592\u2593\u2594\u2595\u2596\u2597\u2598\u2599\u259a\u259b\u259c\u259d\u259e\u259f\n          term.curs.attr.attr |= ((cattrflags)(wc & 0xF)) << ATTR_GRAPH_SHIFT;\n          uchar gcode = 14 + ((wc >> 4) & 1);\n          // extend graph encoding with unused font numbers\n          term.curs.attr.attr &= ~FONTFAM_MASK;\n          term.curs.attr.attr |= (cattrflags)gcode << ATTR_FONTFAM_SHIFT;\n        }\n#ifdef draw_powerline_geometric_symbols\n#warning graphical results of this approach are unpleasant; not enabled\n        else if (wc >= 0xE0B0 && wc <= 0xE0BF && wc != 0xE0B5 && wc != 0xE0B7) {\n          // draw geometric full-cell Powerline symbols,\n          // to avoid artefacts at their borders (#943)\n          term.curs.attr.attr &= ~FONTFAM_MASK;\n          term.curs.attr.attr |= (cattrflags)13 << ATTR_FONTFAM_SHIFT;\n          term.curs.attr.attr |= (cattrflags)15 << ATTR_GRAPH_SHIFT;\n        }\n#endif\n\n        // Determine width of character to be rendered\n        int width;\n        if (term.wide_indic && wc >= 0x0900 && indicwide(wc))\n          width = 2;\n        else if (term.wide_extra && wc >= 0x2000 && extrawide(wc)) {\n          width = 2;\n          // Note: this check is currently not implemented for\n          // non-BMP characters (see case if is_low_surrogate(wc) above)\n          if (win_char_width(wc, term.curs.attr.attr) < 2)\n            term.curs.attr.attr |= TATTR_EXPAND;\n        }\n        else {\n#if HAS_LOCALES\n          if (cfg.charwidth % 10)\n            width = xcwidth(wc);\n          else\n            width = wcwidth(wc);\n#ifdef support_triple_width\n          // do not handle triple-width here\n          //if (term.curs.width)\n          //  width = term.curs.width % 10;\n#endif\n# ifdef hide_isolate_marks\n          // force bidi isolate marks to be zero-width;\n          // however, this is inconsistent with locale width\n          if (wc >= 0x2066 && wc <= 0x2069)\n            width = 0;  // bidi isolate marks\n# endif\n#else\n          width = xcwidth(wc);\n#endif\n        }\n        if (width < 0 && cfg.printable_controls) {\n          if (wc >= 0x80 && wc < 0xA0)\n            width = 1;\n          else if (wc < ' ' && cfg.printable_controls > 1)\n            width = 1;\n        }\n\n        // Auto-expanded glyphs\n        if (width == 2\n            // && wcschr(W(\"\u3008\u3009\u300a\u300b\u300c\u300d\u300e\u300f\u3010\u3011\u3012\u3013\u3014\u3015\u3016\u3017\u3018\u3019\u301a\u301b\"), wc)\n            && wc >= 0x3008 && wc <= 0x301B && (wc | 1) != 0x3013\n            && win_char_width(wc, term.curs.attr.attr) < 2\n            // ensure symmetric handling of matching brackets\n            && win_char_width(wc ^ 1, term.curs.attr.attr) < 2)\n        {\n          term.curs.attr.attr |= TATTR_EXPAND;\n        }\n\n        // Control characters\n        if (wc < 0x20 || wc == 0x7F) {\n          if (!do_ctrl(wc) && c == wc) {\n            wc = cs_btowc_glyph(c);\n            if (wc != c)\n              write_ucschar(0, wc, 1);\n            else if (cfg.printable_controls > 1)\n              goto goon;\n          }\n          term.curs.attr.attr = asav;\n          continue;\n\n          goon:;\n        }\n\n        // Finally, write it and restore cursor attribute\n        write_ucschar(0, wc, width);\n        term.curs.attr.attr = asav;\n      } // end term_write switch (term.state) when NORMAL\n\n      when VT52_Y:\n        term.cmd_len = 0;\n        term_push_cmd(c);\n        term.state = VT52_X;\n\n      when VT52_X:\n        term_push_cmd(c);\n        do_vt52_move();\n\n      when VT52_FG:\n        do_vt52_colour(true, c);\n\n      when VT52_BG:\n        do_vt52_colour(false, c);\n\n      when TEK_ESCAPE:\n        tek_esc(c);\n\n      when TEK_ADDRESS0 or TEK_ADDRESS:\n        if (c < ' ')\n          tek_ctrl(c);\n        else if (tek_mode == TEKMODE_SPECIAL_PLOT && term.state == TEK_ADDRESS0) {\n          term.state = TEK_ADDRESS;\n          term.cmd_len = 0;\n          tek_intensity(c & 0x40, c & 0x37);\n        }\n        //else if (term.cmd_len > 5) {\n        // no length checking here, interferes with previous OSC!\n        // let term_push_cmd do it\n        //}\n        //else if (!(c & 0x60)) {\n        // no error checking here, let tek_address catch it\n        //}\n        else {\n          if (term.state == TEK_ADDRESS0) {\n            term.state = TEK_ADDRESS;\n            term.cmd_len = 0;\n          }\n\n          term_push_cmd(c);\n          if ((c & 0x60) == 0x40) {\n            tek_address(term.cmd_buf);\n            term.state = TEK_ADDRESS0;\n            if (tek_mode == TEKMODE_GRAPH0)\n              tek_mode = TEKMODE_GRAPH;\n          }\n        }\n\n      when TEK_INCREMENTAL:\n        if (c < ' ')\n          tek_ctrl(c);\n        else if (c == ' ' || c == 'P')\n          tek_pen(c == 'P');\n        else if (strchr(\"DEAIHJBF\", c))\n          tek_step(c);\n\n      when ESCAPE or CMD_ESCAPE:\n        if (term.vt52_mode)\n          do_vt52(c);\n        else if (c < 0x20)\n          do_ctrl(c);\n        else if (c < 0x30) {\n          //term.esc_mod = term.esc_mod ? 0xFF : c;\n          if (term.esc_mod) {\n            esc_mod0 = term.esc_mod;\n            esc_mod1 = c;\n            term.esc_mod = 0xFF;\n          }\n          else {\n            esc_mod0 = 0;\n            esc_mod1 = 0;\n            term.esc_mod = c;\n          }\n        }\n        else if (c == '\\\\' && term.state == CMD_ESCAPE) {\n          /* Process DCS or OSC sequence if we see ST. */\n          do_cmd();\n          term.state = NORMAL;\n        }\n        else {\n          do_esc(c);\n          // term.state: NORMAL/CSI_ARGS/OSC_START/DCS_START/IGNORE_STRING\n        }\n\n      when CSI_ARGS:\n        if (c < 0x20)\n          do_ctrl(c);\n        else if (c == ';') {\n          if (term.csi_argc < lengthof(term.csi_argv))\n            term.csi_argc++;\n        }\n        else if (c == ':') {\n          // support colon-separated sub parameters as specified in\n          // ISO/IEC 8613-6 (ITU Recommendation T.416)\n          uint i = term.csi_argc - 1;\n          term.csi_argv[i] |= SUB_PARS;\n          if (term.csi_argc < lengthof(term.csi_argv))\n            term.csi_argc++;\n        }\n        else if (c >= '0' && c <= '9') {\n          uint i = term.csi_argc - 1;\n          if (i < lengthof(term.csi_argv)) {\n            term.csi_argv[i] = 10 * term.csi_argv[i] + c - '0';\n            if ((int)term.csi_argv[i] < 0)\n              term.csi_argv[i] = INT_MAX;  // capture overflow\n            term.csi_argv_defined[i] = 1;\n          }\n        }\n        else if (c < 0x40) {\n          //term.esc_mod = term.esc_mod ? 0xFF : c;\n          if (term.esc_mod) {\n            esc_mod0 = term.esc_mod;\n            esc_mod1 = c;\n            term.esc_mod = 0xFF;\n          }\n          else {\n            esc_mod0 = 0;\n            esc_mod1 = 0;\n            term.esc_mod = c;\n          }\n        }\n        else {\n          do_csi(c);\n          term.state = NORMAL;\n        }\n\n      when OSC_START:\n        term.cmd_len = 0;\n        switch (c) {\n          when 'P':  /* Linux palette sequence */\n            term.state = OSC_PALETTE;\n          when 'R':  /* Linux palette reset */\n            win_reset_colours();\n            term.state = NORMAL;\n          when 'I':  /* OSC set icon file (dtterm, shelltool) */\n            term.cmd_num = 7773;\n            term.state = OSC_NUM;\n          when 'L':  /* OSC set icon label (dtterm, shelltool) */\n            term.cmd_num = 1;\n            term.state = OSC_NUM;\n          when 'l':  /* OSC set window title (dtterm, shelltool) */\n            term.cmd_num = 2;\n            term.state = OSC_NUM;\n          when '0' ... '9':  /* OSC command number */\n            term.cmd_num = c - '0';\n            term.state = OSC_NUM;\n          when ';':\n            term.cmd_num = 0;\n            term.state = CMD_STRING;\n          when '\\a':\n            term.state = NORMAL;\n          when '\\e':\n            term.state = ESCAPE;\n          when '\\n' or '\\r':\n            term.state = IGNORE_STRING;\n          otherwise:\n            term.state = IGNORE_STRING;\n        }\n\n      when OSC_NUM:\n        switch (c) {\n          when '0' ... '9':  /* OSC command number */\n            term.cmd_num = term.cmd_num * 10 + c - '0';\n            if (term.cmd_num < 0)\n              term.cmd_num = -99;  // prevent wrong valid param\n          when ';':\n            term.state = CMD_STRING;\n          when '\\a':\n            do_cmd();\n            term.state = NORMAL;\n          when '\\e':\n            term.state = CMD_ESCAPE;\n          when '\\n' or '\\r':\n            term.state = IGNORE_STRING;\n          otherwise:\n            term.state = IGNORE_STRING;\n        }\n\n      when OSC_PALETTE:\n        if (isxdigit(c)) {\n          // The dodgy Linux palette sequence: keep going until we have\n          // seven hexadecimal digits.\n          term_push_cmd(c);\n          if (term.cmd_len == 7) {\n            uint n, r, g, b;\n            sscanf(term.cmd_buf, \"%1x%2x%2x%2x\", &n, &r, &g, &b);\n            win_set_colour(n, make_colour(r, g, b));\n            term.state = NORMAL;\n          }\n        }\n        else {\n          // End of sequence. Put the character back unless the sequence was\n          // terminated properly.\n          term.state = NORMAL;\n          if (c != '\\a') {\n            pos--;\n            continue;\n          }\n        }\n\n      when CMD_STRING:\n        switch (c) {\n          when '\\a':\n            do_cmd();\n            term.state = NORMAL;\n          when '\\e':\n            term.state = CMD_ESCAPE;\n          when '\\n' or '\\r':\n            // accept new lines in OSC strings\n            if (term.cmd_num != 1337)\n              term_push_cmd(c);\n            // else ignore new lines in base64-encoded images\n          otherwise:\n            term_push_cmd(c);\n        }\n\n      when IGNORE_STRING:\n        switch (c) {\n          when '\\a':\n            term.state = NORMAL;\n          when '\\e':\n            term.state = ESCAPE;\n          when '\\n' or '\\r':\n            // keep IGNORE_STRING\n            ;\n        }\n\n      when DCS_START:\n        term.cmd_num = -1;\n        term.cmd_len = 0;\n        term.dcs_cmd = 0;\n        switch (c) {\n          when '@' ... '~':  /* DCS cmd final byte */\n            term.dcs_cmd = c;\n            do_dcs();\n            term.state = DCS_PASSTHROUGH;\n          when '\\e':\n            term.state = DCS_ESCAPE;\n          when '0' ... '9':  /* DCS parameter */\n            term.state = DCS_PARAM;\n          when ';':          /* DCS separator */\n            term.state = DCS_PARAM;\n          when ':':\n            term.state = DCS_IGNORE;\n          when '<' ... '?':\n            term.dcs_cmd = c;\n            term.state = DCS_PARAM;\n          when ' ' ... '/':  /* DCS intermediate byte */\n            term.dcs_cmd = c;\n            term.state = DCS_INTERMEDIATE;\n          otherwise:\n            term.state = DCS_IGNORE;\n        }\n\n      when DCS_PARAM:\n        switch (c) {\n          when '@' ... '~':  /* DCS cmd final byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            do_dcs();\n            term.state = DCS_PASSTHROUGH;\n          when '\\e':\n            term.state = DCS_ESCAPE;\n            term.esc_mod = 0;\n          when '0' ... '9' or ';' or ':':  /* DCS parameter */\n            term.state = DCS_PARAM;\n          when '<' ... '?':\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            term.state = DCS_PARAM;\n          when ' ' ... '/':  /* DCS intermediate byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            term.state = DCS_INTERMEDIATE;\n          otherwise:\n            term.state = DCS_IGNORE;\n        }\n\n      when DCS_INTERMEDIATE:\n        switch (c) {\n          when '@' ... '~':  /* DCS cmd final byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n            do_dcs();\n            term.state = DCS_PASSTHROUGH;\n          when '\\e':\n            term.state = DCS_ESCAPE;\n            term.esc_mod = 0;\n          when '0' ... '?':  /* DCS parameter byte */\n            term.state = DCS_IGNORE;\n          when ' ' ... '/':  /* DCS intermediate byte */\n            term.dcs_cmd = term.dcs_cmd << 8 | c;\n          otherwise:\n            term.state = DCS_IGNORE;\n        }\n\n      when DCS_PASSTHROUGH:\n        switch (c) {\n          when '\\e':\n            term.state = DCS_ESCAPE;\n            term.esc_mod = 0;\n          otherwise:\n            if (!term_push_cmd(c)) {\n              do_dcs();\n              term.cmd_buf[0] = c;\n              term.cmd_len = 1;\n            }\n        }\n\n      when DCS_IGNORE:\n        switch (c) {\n          when '\\e':\n            term.state = ESCAPE;\n            term.esc_mod = 0;\n        }\n\n      when DCS_ESCAPE:\n        if (c < 0x20) {\n          do_ctrl(c);\n          term.state = NORMAL;\n        } else if (c < 0x30) {\n          term.esc_mod = term.esc_mod ? 0xFF : c;\n          term.state = ESCAPE;\n        } else if (c == '\\\\') {\n          /* Process DCS sequence if we see ST. */\n          do_dcs();\n          term.state = NORMAL;\n        } else {\n          term.state = ESCAPE;\n          term.imgs.parser_state = NULL;\n          do_esc(c);\n        }\n    }\n  }\n\n  if (term.ring_enabled && term.curs.y != oldy)\n    term.ring_enabled = false;\n\n  if (cfg.ligatures_support > 1) {\n    // refresh ligature rendering in old cursor line\n    term_invalidate(0, oldy, term.cols - 1, oldy);\n  }\n\n  // Update search match highlighting\n  //term_schedule_search_partial_update();\n  term_schedule_search_update();\n\n  // Update screen\n  win_schedule_update();\n\n  // Print\n  if (term.printing) {\n    printer_write(term.printbuf, term.printbuf_pos);\n    term.printbuf_pos = 0;\n  }\n}\n\n/* Empty the input buffer */\nvoid\nterm_flush(void)\n{\n  if (term.suspbuf) {\n    term_do_write(term.suspbuf, term.suspbuf_pos);\n    free(term.suspbuf);\n    term.suspbuf = 0;\n    term.suspbuf_pos = 0;\n    term.suspbuf_size = 0;\n  }\n}\n\nvoid\nterm_write(const char *buf, uint len)\n{\n /*\n    During drag-selects, some people do not wish to process terminal output,\n    because the user may want the screen to hold still to be selected.\n    Therefore, we maintain a suspend-output-on-selection buffer which \n    can grow up to a configurable size.\n  */\n  if (term_selecting() && cfg.suspbuf_max > 0) {\n    // if buffer size would be exceeded, flush; prevent uint overflow\n    if (len > cfg.suspbuf_max - term.suspbuf_pos)\n      term_flush();\n    // if buffer length does not exceed max size, append output\n    if (len <= cfg.suspbuf_max - term.suspbuf_pos) {\n      // make sure buffer is large enough\n      if (term.suspbuf_pos + len > term.suspbuf_size) {\n        term.suspbuf_size = term.suspbuf_pos + len;\n        term.suspbuf = renewn(term.suspbuf, term.suspbuf_size);\n      }\n      memcpy(term.suspbuf + term.suspbuf_pos, buf, len);\n      term.suspbuf_pos += len;\n      return;\n    }\n    // if we cannot buffer, output directly;\n    // in this case, we've either flushed already or didn't need to\n  }\n\n  term_do_write(buf, len);\n}\n\n"], "filenames": ["src/termout.c"], "buggy_code_start_loc": [2554], "buggy_code_end_loc": [2565], "fixing_code_start_loc": [2555], "fixing_code_end_loc": [2568], "type": "CWE-770", "message": "Mintty before 3.4.5 allows remote servers to cause a denial of service (Windows GUI hang) by telling the Mintty window to change its title repeatedly at high speed, which results in many SetWindowTextA or SetWindowTextW calls. In other words, it does not implement a usleep or similar delay upon processing a title change.", "other": {"cve": {"id": "CVE-2021-28848", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-03T12:15:07.757", "lastModified": "2021-06-14T17:01:08.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mintty before 3.4.5 allows remote servers to cause a denial of service (Windows GUI hang) by telling the Mintty window to change its title repeatedly at high speed, which results in many SetWindowTextA or SetWindowTextW calls. In other words, it does not implement a usleep or similar delay upon processing a title change."}, {"lang": "es", "value": "Mintty versiones anteriores a 3.4.5, permite a los servidores remotos causar una denegaci\u00f3n de servicio (suspensi\u00f3n de  la GUI de Windows) al decirle a la ventana de Mintty que cambie su t\u00edtulo repetidamente a gran velocidad, lo que resulta en muchas llamadas SetWindowTextA o SetWindowTextW. En otras palabras, no implementa un retardo usleep o similar al procesar un cambio de t\u00edtulo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mintty_project:mintty:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.5", "matchCriteriaId": "E80E1781-DAED-47F2-B4F8-295AF018B39B"}]}]}], "references": [{"url": "https://github.com/mintty/mintty/commit/bd52109993440b6996760aaccb66e68e782762b9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mintty/mintty/compare/3.4.4...3.4.5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mintty.github.io/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mintty/mintty/commit/bd52109993440b6996760aaccb66e68e782762b9"}}