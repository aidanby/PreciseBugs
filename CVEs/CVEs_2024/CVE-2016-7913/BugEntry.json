{"buggy_code": ["/* tuner-xc2028\n *\n * Copyright (c) 2007-2008 Mauro Carvalho Chehab (mchehab@infradead.org)\n *\n * Copyright (c) 2007 Michel Ludwig (michel.ludwig@gmail.com)\n *       - frontend interface\n *\n * This code is placed under the terms of the GNU General Public License v2\n */\n\n#include <linux/i2c.h>\n#include <asm/div64.h>\n#include <linux/firmware.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <media/tuner.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"tuner-i2c.h\"\n#include \"tuner-xc2028.h\"\n#include \"tuner-xc2028-types.h\"\n\n#include <linux/dvb/frontend.h>\n#include \"dvb_frontend.h\"\n\n/* Max transfer size done by I2C transfer functions */\n#define MAX_XFER_SIZE  80\n\n/* Registers (Write-only) */\n#define XREG_INIT         0x00\n#define XREG_RF_FREQ      0x02\n#define XREG_POWER_DOWN   0x08\n\n/* Registers (Read-only) */\n#define XREG_FREQ_ERROR   0x01\n#define XREG_LOCK         0x02\n#define XREG_VERSION      0x04\n#define XREG_PRODUCT_ID   0x08\n#define XREG_HSYNC_FREQ   0x10\n#define XREG_FRAME_LINES  0x20\n#define XREG_SNR          0x40\n\n#define XREG_ADC_ENV      0x0100\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\nstatic int no_poweroff;\nmodule_param(no_poweroff, int, 0644);\nMODULE_PARM_DESC(no_poweroff, \"0 (default) powers device off when not used.\\n\"\n\t\"1 keep device energized and with tuner ready all the times.\\n\"\n\t\"  Faster, but consumes more power and keeps the device hotter\\n\");\n\nstatic char audio_std[8];\nmodule_param_string(audio_std, audio_std, sizeof(audio_std), 0);\nMODULE_PARM_DESC(audio_std,\n\t\"Audio standard. XC3028 audio decoder explicitly \"\n\t\"needs to know what audio\\n\"\n\t\"standard is needed for some video standards with audio A2 or NICAM.\\n\"\n\t\"The valid values are:\\n\"\n\t\"A2\\n\"\n\t\"A2/A\\n\"\n\t\"A2/B\\n\"\n\t\"NICAM\\n\"\n\t\"NICAM/A\\n\"\n\t\"NICAM/B\\n\");\n\nstatic char firmware_name[30];\nmodule_param_string(firmware_name, firmware_name, sizeof(firmware_name), 0);\nMODULE_PARM_DESC(firmware_name, \"Firmware file name. Allows overriding the \"\n\t\t\t\t\"default firmware name\\n\");\n\nstatic LIST_HEAD(hybrid_tuner_instance_list);\nstatic DEFINE_MUTEX(xc2028_list_mutex);\n\n/* struct for storing firmware table */\nstruct firmware_description {\n\tunsigned int  type;\n\tv4l2_std_id   id;\n\t__u16         int_freq;\n\tunsigned char *ptr;\n\tunsigned int  size;\n};\n\nstruct firmware_properties {\n\tunsigned int\ttype;\n\tv4l2_std_id\tid;\n\tv4l2_std_id\tstd_req;\n\t__u16\t\tint_freq;\n\tunsigned int\tscode_table;\n\tint \t\tscode_nr;\n};\n\nenum xc2028_state {\n\tXC2028_NO_FIRMWARE = 0,\n\tXC2028_WAITING_FIRMWARE,\n\tXC2028_ACTIVE,\n\tXC2028_SLEEP,\n\tXC2028_NODEV,\n};\n\nstruct xc2028_data {\n\tstruct list_head        hybrid_tuner_instance_list;\n\tstruct tuner_i2c_props  i2c_props;\n\t__u32\t\t\tfrequency;\n\n\tenum xc2028_state\tstate;\n\tconst char\t\t*fname;\n\n\tstruct firmware_description *firm;\n\tint\t\t\tfirm_size;\n\t__u16\t\t\tfirm_version;\n\n\t__u16\t\t\thwmodel;\n\t__u16\t\t\thwvers;\n\n\tstruct xc2028_ctrl\tctrl;\n\n\tstruct firmware_properties cur_fw;\n\n\tstruct mutex lock;\n};\n\n#define i2c_send(priv, buf, size) ({\t\t\t\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\t_rc = tuner_i2c_xfer_send(&priv->i2c_props, buf, size);\t\t\\\n\tif (size != _rc)\t\t\t\t\t\t\\\n\t\ttuner_info(\"i2c output error: rc = %d (should be %d)\\n\",\\\n\t\t\t   _rc, (int)size);\t\t\t\t\\\n\tif (priv->ctrl.msleep)\t\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\n#define i2c_send_recv(priv, obuf, osize, ibuf, isize) ({\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\t_rc = tuner_i2c_xfer_send_recv(&priv->i2c_props, obuf, osize,\t\\\n\t\t\t\t       ibuf, isize);\t\t\t\\\n\tif (isize != _rc)\t\t\t\t\t\t\\\n\t\ttuner_err(\"i2c input error: rc = %d (should be %d)\\n\",\t\\\n\t\t\t   _rc, (int)isize); \t\t\t\t\\\n\tif (priv->ctrl.msleep)\t\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\n#define send_seq(priv, data...)\t({\t\t\t\t\t\\\n\tstatic u8 _val[] = data;\t\t\t\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\tif (sizeof(_val) !=\t\t\t\t\t\t\\\n\t\t\t(_rc = tuner_i2c_xfer_send(&priv->i2c_props,\t\\\n\t\t\t\t\t\t_val, sizeof(_val)))) {\t\\\n\t\ttuner_err(\"Error on line %d: %d\\n\", __LINE__, _rc);\t\\\n\t} else if (priv->ctrl.msleep)\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\nstatic int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\n{\n\tunsigned char buf[2];\n\tunsigned char ibuf[2];\n\n\ttuner_dbg(\"%s %04x called\\n\", __func__, reg);\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = (unsigned char) reg;\n\n\tif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\n\t\treturn -EIO;\n\n\t*val = (ibuf[1]) | (ibuf[0] << 8);\n\treturn 0;\n}\n\n#define dump_firm_type(t) \tdump_firm_type_and_int_freq(t, 0)\nstatic void dump_firm_type_and_int_freq(unsigned int type, u16 int_freq)\n{\n\tif (type & BASE)\n\t\tprintk(\"BASE \");\n\tif (type & INIT1)\n\t\tprintk(\"INIT1 \");\n\tif (type & F8MHZ)\n\t\tprintk(\"F8MHZ \");\n\tif (type & MTS)\n\t\tprintk(\"MTS \");\n\tif (type & D2620)\n\t\tprintk(\"D2620 \");\n\tif (type & D2633)\n\t\tprintk(\"D2633 \");\n\tif (type & DTV6)\n\t\tprintk(\"DTV6 \");\n\tif (type & QAM)\n\t\tprintk(\"QAM \");\n\tif (type & DTV7)\n\t\tprintk(\"DTV7 \");\n\tif (type & DTV78)\n\t\tprintk(\"DTV78 \");\n\tif (type & DTV8)\n\t\tprintk(\"DTV8 \");\n\tif (type & FM)\n\t\tprintk(\"FM \");\n\tif (type & INPUT1)\n\t\tprintk(\"INPUT1 \");\n\tif (type & LCD)\n\t\tprintk(\"LCD \");\n\tif (type & NOGD)\n\t\tprintk(\"NOGD \");\n\tif (type & MONO)\n\t\tprintk(\"MONO \");\n\tif (type & ATSC)\n\t\tprintk(\"ATSC \");\n\tif (type & IF)\n\t\tprintk(\"IF \");\n\tif (type & LG60)\n\t\tprintk(\"LG60 \");\n\tif (type & ATI638)\n\t\tprintk(\"ATI638 \");\n\tif (type & OREN538)\n\t\tprintk(\"OREN538 \");\n\tif (type & OREN36)\n\t\tprintk(\"OREN36 \");\n\tif (type & TOYOTA388)\n\t\tprintk(\"TOYOTA388 \");\n\tif (type & TOYOTA794)\n\t\tprintk(\"TOYOTA794 \");\n\tif (type & DIBCOM52)\n\t\tprintk(\"DIBCOM52 \");\n\tif (type & ZARLINK456)\n\t\tprintk(\"ZARLINK456 \");\n\tif (type & CHINA)\n\t\tprintk(\"CHINA \");\n\tif (type & F6MHZ)\n\t\tprintk(\"F6MHZ \");\n\tif (type & INPUT2)\n\t\tprintk(\"INPUT2 \");\n\tif (type & SCODE)\n\t\tprintk(\"SCODE \");\n\tif (type & HAS_IF)\n\t\tprintk(\"HAS_IF_%d \", int_freq);\n}\n\nstatic  v4l2_std_id parse_audio_std_option(void)\n{\n\tif (strcasecmp(audio_std, \"A2\") == 0)\n\t\treturn V4L2_STD_A2;\n\tif (strcasecmp(audio_std, \"A2/A\") == 0)\n\t\treturn V4L2_STD_A2_A;\n\tif (strcasecmp(audio_std, \"A2/B\") == 0)\n\t\treturn V4L2_STD_A2_B;\n\tif (strcasecmp(audio_std, \"NICAM\") == 0)\n\t\treturn V4L2_STD_NICAM;\n\tif (strcasecmp(audio_std, \"NICAM/A\") == 0)\n\t\treturn V4L2_STD_NICAM_A;\n\tif (strcasecmp(audio_std, \"NICAM/B\") == 0)\n\t\treturn V4L2_STD_NICAM_B;\n\n\treturn 0;\n}\n\nstatic int check_device_status(struct xc2028_data *priv)\n{\n\tswitch (priv->state) {\n\tcase XC2028_NO_FIRMWARE:\n\tcase XC2028_WAITING_FIRMWARE:\n\t\treturn -EAGAIN;\n\tcase XC2028_ACTIVE:\n\t\treturn 1;\n\tcase XC2028_SLEEP:\n\t\treturn 0;\n\tcase XC2028_NODEV:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void free_firmware(struct xc2028_data *priv)\n{\n\tint i;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (!priv->firm)\n\t\treturn;\n\n\tfor (i = 0; i < priv->firm_size; i++)\n\t\tkfree(priv->firm[i].ptr);\n\n\tkfree(priv->firm);\n\n\tpriv->firm = NULL;\n\tpriv->firm_size = 0;\n\tpriv->state = XC2028_NO_FIRMWARE;\n\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n}\n\nstatic int load_all_firmwares(struct dvb_frontend *fe,\n\t\t\t      const struct firmware *fw)\n{\n\tstruct xc2028_data    *priv = fe->tuner_priv;\n\tconst unsigned char   *p, *endp;\n\tint                   rc = 0;\n\tint\t\t      n, n_array;\n\tchar\t\t      name[33];\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tp = fw->data;\n\tendp = p + fw->size;\n\n\tif (fw->size < sizeof(name) - 1 + 2 + 2) {\n\t\ttuner_err(\"Error: firmware file %s has invalid size!\\n\",\n\t\t\t  priv->fname);\n\t\tgoto corrupt;\n\t}\n\n\tmemcpy(name, p, sizeof(name) - 1);\n\tname[sizeof(name) - 1] = 0;\n\tp += sizeof(name) - 1;\n\n\tpriv->firm_version = get_unaligned_le16(p);\n\tp += 2;\n\n\tn_array = get_unaligned_le16(p);\n\tp += 2;\n\n\ttuner_info(\"Loading %d firmware images from %s, type: %s, ver %d.%d\\n\",\n\t\t   n_array, priv->fname, name,\n\t\t   priv->firm_version >> 8, priv->firm_version & 0xff);\n\n\tpriv->firm = kcalloc(n_array, sizeof(*priv->firm), GFP_KERNEL);\n\tif (priv->firm == NULL) {\n\t\ttuner_err(\"Not enough memory to load firmware file.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tpriv->firm_size = n_array;\n\n\tn = -1;\n\twhile (p < endp) {\n\t\t__u32 type, size;\n\t\tv4l2_std_id id;\n\t\t__u16 int_freq = 0;\n\n\t\tn++;\n\t\tif (n >= n_array) {\n\t\t\ttuner_err(\"More firmware images in file than \"\n\t\t\t\t  \"were expected!\\n\");\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\t/* Checks if there's enough bytes to read */\n\t\tif (endp - p < sizeof(type) + sizeof(id) + sizeof(size))\n\t\t\tgoto header;\n\n\t\ttype = get_unaligned_le32(p);\n\t\tp += sizeof(type);\n\n\t\tid = get_unaligned_le64(p);\n\t\tp += sizeof(id);\n\n\t\tif (type & HAS_IF) {\n\t\t\tint_freq = get_unaligned_le16(p);\n\t\t\tp += sizeof(int_freq);\n\t\t\tif (endp - p < sizeof(size))\n\t\t\t\tgoto header;\n\t\t}\n\n\t\tsize = get_unaligned_le32(p);\n\t\tp += sizeof(size);\n\n\t\tif (!size || size > endp - p) {\n\t\t\ttuner_err(\"Firmware type \");\n\t\t\tdump_firm_type(type);\n\t\t\tprintk(\"(%x), id %llx is corrupted \"\n\t\t\t       \"(size=%d, expected %d)\\n\",\n\t\t\t       type, (unsigned long long)id,\n\t\t\t       (unsigned)(endp - p), size);\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\tpriv->firm[n].ptr = kzalloc(size, GFP_KERNEL);\n\t\tif (priv->firm[n].ptr == NULL) {\n\t\t\ttuner_err(\"Not enough memory to load firmware file.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\ttuner_dbg(\"Reading firmware type \");\n\t\tif (debug) {\n\t\t\tdump_firm_type_and_int_freq(type, int_freq);\n\t\t\tprintk(\"(%x), id %llx, size=%d.\\n\",\n\t\t\t       type, (unsigned long long)id, size);\n\t\t}\n\n\t\tmemcpy(priv->firm[n].ptr, p, size);\n\t\tpriv->firm[n].type = type;\n\t\tpriv->firm[n].id   = id;\n\t\tpriv->firm[n].size = size;\n\t\tpriv->firm[n].int_freq = int_freq;\n\n\t\tp += size;\n\t}\n\n\tif (n + 1 != priv->firm_size) {\n\t\ttuner_err(\"Firmware file is incomplete!\\n\");\n\t\tgoto corrupt;\n\t}\n\n\tgoto done;\n\nheader:\n\ttuner_err(\"Firmware header is incomplete!\\n\");\ncorrupt:\n\trc = -EINVAL;\n\ttuner_err(\"Error: firmware file is corrupted!\\n\");\n\nerr:\n\ttuner_info(\"Releasing partially loaded firmware file.\\n\");\n\tfree_firmware(priv);\n\ndone:\n\tif (rc == 0)\n\t\ttuner_dbg(\"Firmware files loaded.\\n\");\n\telse\n\t\tpriv->state = XC2028_NODEV;\n\n\treturn rc;\n}\n\nstatic int seek_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                 i, best_i = -1, best_nr_matches = 0;\n\tunsigned int        type_mask = 0;\n\n\ttuner_dbg(\"%s called, want type=\", __func__);\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\n\tif (!priv->firm) {\n\t\ttuner_err(\"Error! firmware not loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((type & ~SCODE) == 0) && (*id == 0))\n\t\t*id = V4L2_STD_PAL;\n\n\tif (type & BASE)\n\t\ttype_mask = BASE_TYPES;\n\telse if (type & SCODE) {\n\t\ttype &= SCODE_TYPES;\n\t\ttype_mask = SCODE_TYPES & ~HAS_IF;\n\t} else if (type & DTV_TYPES)\n\t\ttype_mask = DTV_TYPES;\n\telse if (type & STD_SPECIFIC_TYPES)\n\t\ttype_mask = STD_SPECIFIC_TYPES;\n\n\ttype &= type_mask;\n\n\tif (!(type & SCODE))\n\t\ttype_mask = ~0;\n\n\t/* Seek for exact match */\n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tif ((type == (priv->firm[i].type & type_mask)) &&\n\t\t    (*id == priv->firm[i].id))\n\t\t\tgoto found;\n\t}\n\n\t/* Seek for generic video standard match */\n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tv4l2_std_id match_mask;\n\t\tint nr_matches;\n\n\t\tif (type != (priv->firm[i].type & type_mask))\n\t\t\tcontinue;\n\n\t\tmatch_mask = *id & priv->firm[i].id;\n\t\tif (!match_mask)\n\t\t\tcontinue;\n\n\t\tif ((*id & match_mask) == *id)\n\t\t\tgoto found; /* Supports all the requested standards */\n\n\t\tnr_matches = hweight64(match_mask);\n\t\tif (nr_matches > best_nr_matches) {\n\t\t\tbest_nr_matches = nr_matches;\n\t\t\tbest_i = i;\n\t\t}\n\t}\n\n\tif (best_nr_matches > 0) {\n\t\ttuner_dbg(\"Selecting best matching firmware (%d bits) for \"\n\t\t\t  \"type=\", best_nr_matches);\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx:\\n\", type, (unsigned long long)*id);\n\t\ti = best_i;\n\t\tgoto found;\n\t}\n\n\t/*FIXME: Would make sense to seek for type \"hint\" match ? */\n\n\ti = -ENOENT;\n\tgoto ret;\n\nfound:\n\t*id = priv->firm[i].id;\n\nret:\n\ttuner_dbg(\"%s firmware for type=\", (i < 0) ? \"Can't find\" : \"Found\");\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\treturn i;\n}\n\nstatic inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\n\t/* analog side (tuner-core) uses i2c_adap->algo_data.\n\t * digital side is not guaranteed to have algo_data defined.\n\t *\n\t * digital side will always have fe->dvb defined.\n\t * analog side (tuner-core) doesn't (yet) define fe->dvb.\n\t */\n\n\treturn (!fe->callback) ? -EINVAL :\n\t\tfe->callback(((fe->dvb) && (fe->dvb->priv)) ?\n\t\t\t\tfe->dvb->priv : priv->i2c_props.adap->algo_data,\n\t\t\t     DVB_FRONTEND_COMPONENT_TUNER, cmd, arg);\n}\n\nstatic int load_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char      *p, *endp, buf[MAX_XFER_SIZE];\n\n\tif (priv->ctrl.max_len > sizeof(buf))\n\t\tpriv->ctrl.max_len = sizeof(buf);\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tpos = seek_firmware(fe, type, id);\n\tif (pos < 0)\n\t\treturn pos;\n\n\ttuner_info(\"Loading firmware for type=\");\n\tdump_firm_type(priv->firm[pos].type);\n\tprintk(\"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t       (unsigned long long)*id);\n\n\tp = priv->firm[pos].ptr;\n\tendp = p + priv->firm[pos].size;\n\n\twhile (p < endp) {\n\t\t__u16 size;\n\n\t\t/* Checks if there's enough bytes to read */\n\t\tif (p + sizeof(size) > endp) {\n\t\t\ttuner_err(\"Firmware chunk size is wrong\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsize = le16_to_cpu(*(__le16 *) p);\n\t\tp += sizeof(size);\n\n\t\tif (size == 0xffff)\n\t\t\treturn 0;\n\n\t\tif (!size) {\n\t\t\t/* Special callback command received */\n\t\t\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\t\t\tif (rc < 0) {\n\t\t\t\ttuner_err(\"Error at RESET code %d\\n\",\n\t\t\t\t\t   (*p) & 0x7f);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (size >= 0xff00) {\n\t\t\tswitch (size) {\n\t\t\tcase 0xff00:\n\t\t\t\trc = do_tuner_callback(fe, XC2028_RESET_CLK, 0);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\ttuner_err(\"Error at RESET code %d\\n\",\n\t\t\t\t\t\t  (*p) & 0x7f);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttuner_info(\"Invalid RESET code %d\\n\",\n\t\t\t\t\t   size & 0x7f);\n\t\t\t\treturn -EINVAL;\n\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Checks for a sleep command */\n\t\tif (size & 0x8000) {\n\t\t\tmsleep(size & 0x7fff);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((size + p > endp)) {\n\t\t\ttuner_err(\"missing bytes: need %d, have %d\\n\",\n\t\t\t\t   size, (int)(endp - p));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuf[0] = *p;\n\t\tp++;\n\t\tsize--;\n\n\t\t/* Sends message chunks */\n\t\twhile (size > 0) {\n\t\t\tint len = (size < priv->ctrl.max_len - 1) ?\n\t\t\t\t   size : priv->ctrl.max_len - 1;\n\n\t\t\tmemcpy(buf + 1, p, len);\n\n\t\t\trc = i2c_send(priv, buf, len + 1);\n\t\t\tif (rc < 0) {\n\t\t\t\ttuner_err(\"%d returned from send\\n\", rc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tp += len;\n\t\t\tsize -= len;\n\t\t}\n\n\t\t/* silently fail if the frontend doesn't support I2C flush */\n\t\trc = do_tuner_callback(fe, XC2028_I2C_FLUSH, 0);\n\t\tif ((rc < 0) && (rc != -EINVAL)) {\n\t\t\ttuner_err(\"error executing flush: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int load_scode(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id, __u16 int_freq, int scode)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char\t   *p;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (!int_freq) {\n\t\tpos = seek_firmware(fe, type, id);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\t} else {\n\t\tfor (pos = 0; pos < priv->firm_size; pos++) {\n\t\t\tif ((priv->firm[pos].int_freq == int_freq) &&\n\t\t\t    (priv->firm[pos].type & HAS_IF))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pos == priv->firm_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tp = priv->firm[pos].ptr;\n\n\tif (priv->firm[pos].type & HAS_IF) {\n\t\tif (priv->firm[pos].size != 12 * 16 || scode >= 16)\n\t\t\treturn -EINVAL;\n\t\tp += 12 * scode;\n\t} else {\n\t\t/* 16 SCODE entries per file; each SCODE entry is 12 bytes and\n\t\t * has a 2-byte size header in the firmware format. */\n\t\tif (priv->firm[pos].size != 14 * 16 || scode >= 16 ||\n\t\t    le16_to_cpu(*(__le16 *)(p + 14 * scode)) != 12)\n\t\t\treturn -EINVAL;\n\t\tp += 14 * scode + 2;\n\t}\n\n\ttuner_info(\"Loading SCODE for type=\");\n\tdump_firm_type_and_int_freq(priv->firm[pos].type,\n\t\t\t\t    priv->firm[pos].int_freq);\n\tprintk(\"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t       (unsigned long long)*id);\n\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0xa0, 0x00, 0x00, 0x00});\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\trc = i2c_send(priv, p, 12);\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\trc = send_seq(priv, {0x00, 0x8c});\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int xc2028_sleep(struct dvb_frontend *fe);\n\nstatic int check_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t  v4l2_std_id std, __u16 int_freq)\n{\n\tstruct xc2028_data         *priv = fe->tuner_priv;\n\tstruct firmware_properties new_fw;\n\tint\t\t\t   rc, retry_count = 0;\n\tu16\t\t\t   version, hwmodel;\n\tv4l2_std_id\t\t   std0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (priv->ctrl.mts && !(type & FM))\n\t\ttype |= MTS;\n\nretry:\n\tnew_fw.type = type;\n\tnew_fw.id = std;\n\tnew_fw.std_req = std;\n\tnew_fw.scode_table = SCODE | priv->ctrl.scode_table;\n\tnew_fw.scode_nr = 0;\n\tnew_fw.int_freq = int_freq;\n\n\ttuner_dbg(\"checking firmware, user requested type=\");\n\tif (debug) {\n\t\tdump_firm_type(new_fw.type);\n\t\tprintk(\"(%x), id %016llx, \", new_fw.type,\n\t\t       (unsigned long long)new_fw.std_req);\n\t\tif (!int_freq) {\n\t\t\tprintk(\"scode_tbl \");\n\t\t\tdump_firm_type(priv->ctrl.scode_table);\n\t\t\tprintk(\"(%x), \", priv->ctrl.scode_table);\n\t\t} else\n\t\t\tprintk(\"int_freq %d, \", new_fw.int_freq);\n\t\tprintk(\"scode_nr %d\\n\", new_fw.scode_nr);\n\t}\n\n\t/*\n\t * No need to reload base firmware if it matches and if the tuner\n\t * is not at sleep mode\n\t */\n\tif ((priv->state == XC2028_ACTIVE) &&\n\t    (((BASE | new_fw.type) & BASE_TYPES) ==\n\t    (priv->cur_fw.type & BASE_TYPES))) {\n\t\ttuner_dbg(\"BASE firmware not changed.\\n\");\n\t\tgoto skip_base;\n\t}\n\n\t/* Updating BASE - forget about all currently loaded firmware */\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\n\t/* Reset is needed before loading firmware */\n\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* BASE firmwares are all std0 */\n\tstd0 = 0;\n\trc = load_firmware(fe, BASE | new_fw.type, &std0);\n\tif (rc < 0) {\n\t\ttuner_err(\"Error %d while loading base firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\n\t/* Load INIT1, if needed */\n\ttuner_dbg(\"Load init1 firmware, if exists\\n\");\n\n\trc = load_firmware(fe, BASE | INIT1 | new_fw.type, &std0);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, (BASE | INIT1 | new_fw.type) & ~F8MHZ,\n\t\t\t\t   &std0);\n\tif (rc < 0 && rc != -ENOENT) {\n\t\ttuner_err(\"Error %d while loading init1 firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\nskip_base:\n\t/*\n\t * No need to reload standard specific firmware if base firmware\n\t * was not reloaded and requested video standards have not changed.\n\t */\n\tif (priv->cur_fw.type == (BASE | new_fw.type) &&\n\t    priv->cur_fw.std_req == std) {\n\t\ttuner_dbg(\"Std-specific firmware already loaded.\\n\");\n\t\tgoto skip_std_specific;\n\t}\n\n\t/* Reloading std-specific firmware forces a SCODE update */\n\tpriv->cur_fw.scode_table = 0;\n\n\trc = load_firmware(fe, new_fw.type, &new_fw.id);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, new_fw.type & ~F8MHZ, &new_fw.id);\n\n\tif (rc < 0)\n\t\tgoto fail;\n\nskip_std_specific:\n\tif (priv->cur_fw.scode_table == new_fw.scode_table &&\n\t    priv->cur_fw.scode_nr == new_fw.scode_nr) {\n\t\ttuner_dbg(\"SCODE firmware already loaded.\\n\");\n\t\tgoto check_device;\n\t}\n\n\tif (new_fw.type & FM)\n\t\tgoto check_device;\n\n\t/* Load SCODE firmware, if exists */\n\ttuner_dbg(\"Trying to load scode %d\\n\", new_fw.scode_nr);\n\n\trc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\n\t\t\tnew_fw.int_freq, new_fw.scode_nr);\n\ncheck_device:\n\tif (xc2028_get_reg(priv, 0x0004, &version) < 0 ||\n\t    xc2028_get_reg(priv, 0x0008, &hwmodel) < 0) {\n\t\ttuner_err(\"Unable to read tuner registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\ttuner_dbg(\"Device is Xceive %d version %d.%d, \"\n\t\t  \"firmware version %d.%d\\n\",\n\t\t  hwmodel, (version & 0xf000) >> 12, (version & 0xf00) >> 8,\n\t\t  (version & 0xf0) >> 4, version & 0xf);\n\n\n\tif (priv->ctrl.read_not_reliable)\n\t\tgoto read_not_reliable;\n\n\t/* Check firmware version against what we downloaded. */\n\tif (priv->firm_version != ((version & 0xf0) << 4 | (version & 0x0f))) {\n\t\tif (!priv->ctrl.read_not_reliable) {\n\t\t\ttuner_err(\"Incorrect readback of firmware version.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\ttuner_err(\"Returned an incorrect version. However, \"\n\t\t\t\t  \"read is not reliable enough. Ignoring it.\\n\");\n\t\t\thwmodel = 3028;\n\t\t}\n\t}\n\n\t/* Check that the tuner hardware model remains consistent over time. */\n\tif (priv->hwmodel == 0 && (hwmodel == 2028 || hwmodel == 3028)) {\n\t\tpriv->hwmodel = hwmodel;\n\t\tpriv->hwvers  = version & 0xff00;\n\t} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel ||\n\t\t   priv->hwvers != (version & 0xff00)) {\n\t\ttuner_err(\"Read invalid device hardware information - tuner \"\n\t\t\t  \"hung?\\n\");\n\t\tgoto fail;\n\t}\n\nread_not_reliable:\n\tpriv->cur_fw = new_fw;\n\n\t/*\n\t * By setting BASE in cur_fw.type only after successfully loading all\n\t * firmwares, we can:\n\t * 1. Identify that BASE firmware with type=0 has been loaded;\n\t * 2. Tell whether BASE firmware was just changed the next time through.\n\t */\n\tpriv->cur_fw.type |= BASE;\n\tpriv->state = XC2028_ACTIVE;\n\n\treturn 0;\n\nfail:\n\tpriv->state = XC2028_NO_FIRMWARE;\n\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\tif (retry_count < 8) {\n\t\tmsleep(50);\n\t\tretry_count++;\n\t\ttuner_dbg(\"Retrying firmware load\\n\");\n\t\tgoto retry;\n\t}\n\n\t/* Firmware didn't load. Put the device to sleep */\n\txc2028_sleep(fe);\n\n\tif (rc == -ENOENT)\n\t\trc = -EINVAL;\n\treturn rc;\n}\n\nstatic int xc2028_signal(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tu16                 frq_lock, signal = 0;\n\tint                 rc, i;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* If the device is sleeping, no channel is tuned */\n\tif (!rc) {\n\t\t*strength = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t/* Sync Lock Indicator */\n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t/* Frequency didn't lock */\n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t/* Get SNR of the video signal */\n\trc = xc2028_get_reg(priv, XREG_SNR, &signal);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t/* Signal level is 3 bits only */\n\n\tsignal = ((1 << 12) - 1) | ((signal & 0x07) << 12);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\t*strength = signal;\n\n\ttuner_dbg(\"signal strength is %d\\n\", signal);\n\n\treturn rc;\n}\n\nstatic int xc2028_get_afc(struct dvb_frontend *fe, s32 *afc)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint i, rc;\n\tu16 frq_lock = 0;\n\ts16 afc_reg = 0;\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* If the device is sleeping, no channel is tuned */\n\tif (!rc) {\n\t\t*afc = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t/* Sync Lock Indicator */\n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t/* Frequency didn't lock */\n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t/* Get AFC */\n\trc = xc2028_get_reg(priv, XREG_FREQ_ERROR, &afc_reg);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t*afc = afc_reg * 15625; /* Hz */\n\n\ttuner_dbg(\"AFC is %d Hz\\n\", *afc);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\n#define DIV 15625\n\nstatic int generic_set_freq(struct dvb_frontend *fe, u32 freq /* in HZ */,\n\t\t\t    enum v4l2_tuner_type new_type,\n\t\t\t    unsigned int type,\n\t\t\t    v4l2_std_id std,\n\t\t\t    u16 int_freq)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint\t\t   rc = -EINVAL;\n\tunsigned char\t   buf[4];\n\tu32\t\t   div, offset = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\ttuner_dbg(\"should set frequency %d kHz\\n\", freq / 1000);\n\n\tif (check_firmware(fe, type, std, int_freq) < 0)\n\t\tgoto ret;\n\n\t/* On some cases xc2028 can disable video output, if\n\t * very weak signals are received. By sending a soft\n\t * reset, this is re-enabled. So, it is better to always\n\t * send a soft reset before changing channels, to be sure\n\t * that xc2028 will be in a safe state.\n\t * Maybe this might also be needed for DTV.\n\t */\n\tswitch (new_type) {\n\tcase V4L2_TUNER_ANALOG_TV:\n\t\trc = send_seq(priv, {0x00, 0x00});\n\n\t\t/* Analog mode requires offset = 0 */\n\t\tbreak;\n\tcase V4L2_TUNER_RADIO:\n\t\t/* Radio mode requires offset = 0 */\n\t\tbreak;\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\t/*\n\t\t * Digital modes require an offset to adjust to the\n\t\t * proper frequency. The offset depends on what\n\t\t * firmware version is used.\n\t\t */\n\n\t\t/*\n\t\t * Adjust to the center frequency. This is calculated by the\n\t\t * formula: offset = 1.25MHz - BW/2\n\t\t * For DTV 7/8, the firmware uses BW = 8000, so it needs a\n\t\t * further adjustment to get the frequency center on VHF\n\t\t */\n\n\t\t/*\n\t\t * The firmware DTV78 used to work fine in UHF band (8 MHz\n\t\t * bandwidth) but not at all in VHF band (7 MHz bandwidth).\n\t\t * The real problem was connected to the formula used to\n\t\t * calculate the center frequency offset in VHF band.\n\t\t * In fact, removing the 500KHz adjustment fixed the problem.\n\t\t * This is coherent to what was implemented for the DTV7\n\t\t * firmware.\n\t\t * In the end, now the center frequency is the same for all 3\n\t\t * firmwares (DTV7, DTV8, DTV78) and doesn't depend on channel\n\t\t * bandwidth.\n\t\t */\n\n\t\tif (priv->cur_fw.type & DTV6)\n\t\t\toffset = 1750000;\n\t\telse\t/* DTV7 or DTV8 or DTV78 */\n\t\t\toffset = 2750000;\n\n\t\t/*\n\t\t * xc3028 additional \"magic\"\n\t\t * Depending on the firmware version, it needs some adjustments\n\t\t * to properly centralize the frequency. This seems to be\n\t\t * needed to compensate the SCODE table adjustments made by\n\t\t * newer firmwares\n\t\t */\n\n\t\t/*\n\t\t * The proper adjustment would be to do it at s-code table.\n\t\t * However, this didn't work, as reported by\n\t\t * Robert Lowery <rglowery@exemail.com.au>\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * Still need tests for XC3028L (firmware 3.2 or upper)\n\t\t * So, for now, let's just comment the per-firmware\n\t\t * version of this change. Reports with xc3028l working\n\t\t * with and without the lines below are welcome\n\t\t */\n\n\t\tif (priv->firm_version < 0x0302) {\n\t\t\tif (priv->cur_fw.type & DTV7)\n\t\t\t\toffset += 500000;\n\t\t} else {\n\t\t\tif (priv->cur_fw.type & DTV7)\n\t\t\t\toffset -= 300000;\n\t\t\telse if (type != ATSC) /* DVB @6MHz, DTV 8 and DTV 7/8 */\n\t\t\t\toffset += 200000;\n\t\t}\n#endif\n\t\tbreak;\n\tdefault:\n\t\ttuner_err(\"Unsupported tuner type %d.\\n\", new_type);\n\t\tbreak;\n\t}\n\n\tdiv = (freq - offset + DIV / 2) / DIV;\n\n\t/* CMD= Set frequency */\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_RF_FREQ, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_RF_FREQ, 0x00, 0x00});\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t/* Return code shouldn't be checked.\n\t   The reset CLK is needed only with tm6000.\n\t   Driver should work fine even if this fails.\n\t */\n\tif (priv->ctrl.msleep)\n\t\tmsleep(priv->ctrl.msleep);\n\tdo_tuner_callback(fe, XC2028_RESET_CLK, 1);\n\n\tmsleep(10);\n\n\tbuf[0] = 0xff & (div >> 24);\n\tbuf[1] = 0xff & (div >> 16);\n\tbuf[2] = 0xff & (div >> 8);\n\tbuf[3] = 0xff & (div);\n\n\trc = i2c_send(priv, buf, sizeof(buf));\n\tif (rc < 0)\n\t\tgoto ret;\n\tmsleep(100);\n\n\tpriv->frequency = freq;\n\n\ttuner_dbg(\"divisor= %*ph (freq=%d.%03d)\\n\", 4, buf,\n\t       freq / 1000000, (freq % 1000000) / 1000);\n\n\trc = 0;\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic int xc2028_set_analog_freq(struct dvb_frontend *fe,\n\t\t\t      struct analog_parameters *p)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tunsigned int       type=0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (p->mode == V4L2_TUNER_RADIO) {\n\t\ttype |= FM;\n\t\tif (priv->ctrl.input1)\n\t\t\ttype |= INPUT1;\n\t\treturn generic_set_freq(fe, (625l * p->frequency) / 10,\n\t\t\t\tV4L2_TUNER_RADIO, type, 0, 0);\n\t}\n\n\t/* if std is not defined, choose one */\n\tif (!p->std)\n\t\tp->std = V4L2_STD_MN;\n\n\t/* PAL/M, PAL/N, PAL/Nc and NTSC variants should use 6MHz firmware */\n\tif (!(p->std & V4L2_STD_MN))\n\t\ttype |= F8MHZ;\n\n\t/* Add audio hack to std mask */\n\tp->std |= parse_audio_std_option();\n\n\treturn generic_set_freq(fe, 62500l * p->frequency,\n\t\t\t\tV4L2_TUNER_ANALOG_TV, type, p->std, 0);\n}\n\nstatic int xc2028_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\tunsigned int       type = 0;\n\tu16                demod = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (delsys) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\t/*\n\t\t * The only countries with 6MHz seem to be Taiwan/Uruguay.\n\t\t * Both seem to require QAM firmware for OFDM decoding\n\t\t * Tested in Taiwan by Terry Wu <terrywu2009@gmail.com>\n\t\t */\n\t\tif (bw <= 6000000)\n\t\t\ttype |= QAM;\n\n\t\tswitch (priv->ctrl.type) {\n\t\tcase XC2028_D2633:\n\t\t\ttype |= D2633;\n\t\t\tbreak;\n\t\tcase XC2028_D2620:\n\t\t\ttype |= D2620;\n\t\t\tbreak;\n\t\tcase XC2028_AUTO:\n\t\tdefault:\n\t\t\t/* Zarlink seems to need D2633 */\n\t\t\tif (priv->ctrl.demod == XC3028_FE_ZARLINK456)\n\t\t\t\ttype |= D2633;\n\t\t\telse\n\t\t\t\ttype |= D2620;\n\t\t}\n\t\tbreak;\n\tcase SYS_ATSC:\n\t\t/* The only ATSC firmware (at least on v2.7) is D2633 */\n\t\ttype |= ATSC | D2633;\n\t\tbreak;\n\t/* DVB-S and pure QAM (FE_QAM) are not supported */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (bw <= 6000000) {\n\t\ttype |= DTV6;\n\t\tpriv->ctrl.vhfbw7 = 0;\n\t\tpriv->ctrl.uhfbw8 = 0;\n\t} else if (bw <= 7000000) {\n\t\tif (c->frequency < 470000000)\n\t\t\tpriv->ctrl.vhfbw7 = 1;\n\t\telse\n\t\t\tpriv->ctrl.uhfbw8 = 0;\n\t\ttype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV7;\n\t\ttype |= F8MHZ;\n\t} else {\n\t\tif (c->frequency < 470000000)\n\t\t\tpriv->ctrl.vhfbw7 = 0;\n\t\telse\n\t\t\tpriv->ctrl.uhfbw8 = 1;\n\t\ttype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV8;\n\t\ttype |= F8MHZ;\n\t}\n\n\t/* All S-code tables need a 200kHz shift */\n\tif (priv->ctrl.demod) {\n\t\tdemod = priv->ctrl.demod;\n\n\t\t/*\n\t\t * Newer firmwares require a 200 kHz offset only for ATSC\n\t\t */\n\t\tif (type == ATSC || priv->firm_version < 0x0302)\n\t\t\tdemod += 200;\n\t\t/*\n\t\t * The DTV7 S-code table needs a 700 kHz shift.\n\t\t *\n\t\t * DTV7 is only used in Australia.  Germany or Italy may also\n\t\t * use this firmware after initialization, but a tune to a UHF\n\t\t * channel should then cause DTV78 to be used.\n\t\t *\n\t\t * Unfortunately, on real-field tests, the s-code offset\n\t\t * didn't work as expected, as reported by\n\t\t * Robert Lowery <rglowery@exemail.com.au>\n\t\t */\n\t}\n\n\treturn generic_set_freq(fe, c->frequency,\n\t\t\t\tV4L2_TUNER_DIGITAL_TV, type, 0, demod);\n}\n\nstatic int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Device is already in sleep mode */\n\tif (!rc)\n\t\treturn 0;\n\n\t/* Avoid firmware reload on slow devices or if PM disabled */\n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic int xc2028_dvb_release(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&xc2028_list_mutex);\n\n\t/* only perform final cleanup if this is the last instance */\n\tif (hybrid_tuner_report_instance_count(priv) == 1) {\n\t\tfree_firmware(priv);\n\t\tkfree(priv->ctrl.fname);\n\t\tpriv->ctrl.fname = NULL;\n\t}\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&xc2028_list_mutex);\n\n\tfe->tuner_priv = NULL;\n\n\treturn 0;\n}\n\nstatic int xc2028_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*frequency = priv->frequency;\n\n\treturn 0;\n}\n\nstatic void load_firmware_cb(const struct firmware *fw,\n\t\t\t     void *context)\n{\n\tstruct dvb_frontend *fe = context;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"request_firmware_nowait(): %s\\n\", fw ? \"OK\" : \"error\");\n\tif (!fw) {\n\t\ttuner_err(\"Could not load firmware %s.\\n\", priv->fname);\n\t\tpriv->state = XC2028_NODEV;\n\t\treturn;\n\t}\n\n\trc = load_all_firmwares(fe, fw);\n\n\trelease_firmware(fw);\n\n\tif (rc < 0)\n\t\treturn;\n\tpriv->state = XC2028_ACTIVE;\n}\n\nstatic int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic const struct dvb_tuner_ops xc2028_dvb_tuner_ops = {\n\t.info = {\n\t\t .name = \"Xceive XC3028\",\n\t\t .frequency_min = 42000000,\n\t\t .frequency_max = 864000000,\n\t\t .frequency_step = 50000,\n\t\t },\n\n\t.set_config\t   = xc2028_set_config,\n\t.set_analog_params = xc2028_set_analog_freq,\n\t.release           = xc2028_dvb_release,\n\t.get_frequency     = xc2028_get_frequency,\n\t.get_rf_strength   = xc2028_signal,\n\t.get_afc           = xc2028_get_afc,\n\t.set_params        = xc2028_set_params,\n\t.sleep             = xc2028_sleep,\n};\n\nstruct dvb_frontend *xc2028_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct xc2028_config *cfg)\n{\n\tstruct xc2028_data *priv;\n\tint instance;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"xc2028: Xcv2028/3028 init called!\\n\");\n\n\tif (NULL == cfg)\n\t\treturn NULL;\n\n\tif (!fe) {\n\t\tprintk(KERN_ERR \"xc2028: No frontend!\\n\");\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&xc2028_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct xc2028_data, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      cfg->i2c_adap, cfg->i2c_addr,\n\t\t\t\t\t      \"xc2028\");\n\tswitch (instance) {\n\tcase 0:\n\t\t/* memory allocation failure */\n\t\tgoto fail;\n\tcase 1:\n\t\t/* new tuner instance */\n\t\tpriv->ctrl.max_len = 13;\n\n\t\tmutex_init(&priv->lock);\n\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\tcase 2:\n\t\t/* existing tuner instance */\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tmemcpy(&fe->ops.tuner_ops, &xc2028_dvb_tuner_ops,\n\t       sizeof(xc2028_dvb_tuner_ops));\n\n\ttuner_info(\"type set to %s\\n\", \"XCeive xc2028/xc3028 tuner\");\n\n\tif (cfg->ctrl)\n\t\txc2028_set_config(fe, cfg->ctrl);\n\n\tmutex_unlock(&xc2028_list_mutex);\n\n\treturn fe;\nfail:\n\tmutex_unlock(&xc2028_list_mutex);\n\n\txc2028_dvb_release(fe);\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(xc2028_attach);\n\nMODULE_DESCRIPTION(\"Xceive xc2028/xc3028 tuner driver\");\nMODULE_AUTHOR(\"Michel Ludwig <michel.ludwig@gmail.com>\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(XC2028_DEFAULT_FIRMWARE);\nMODULE_FIRMWARE(XC3028L_DEFAULT_FIRMWARE);\n"], "fixing_code": ["/* tuner-xc2028\n *\n * Copyright (c) 2007-2008 Mauro Carvalho Chehab (mchehab@infradead.org)\n *\n * Copyright (c) 2007 Michel Ludwig (michel.ludwig@gmail.com)\n *       - frontend interface\n *\n * This code is placed under the terms of the GNU General Public License v2\n */\n\n#include <linux/i2c.h>\n#include <asm/div64.h>\n#include <linux/firmware.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <media/tuner.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"tuner-i2c.h\"\n#include \"tuner-xc2028.h\"\n#include \"tuner-xc2028-types.h\"\n\n#include <linux/dvb/frontend.h>\n#include \"dvb_frontend.h\"\n\n/* Max transfer size done by I2C transfer functions */\n#define MAX_XFER_SIZE  80\n\n/* Registers (Write-only) */\n#define XREG_INIT         0x00\n#define XREG_RF_FREQ      0x02\n#define XREG_POWER_DOWN   0x08\n\n/* Registers (Read-only) */\n#define XREG_FREQ_ERROR   0x01\n#define XREG_LOCK         0x02\n#define XREG_VERSION      0x04\n#define XREG_PRODUCT_ID   0x08\n#define XREG_HSYNC_FREQ   0x10\n#define XREG_FRAME_LINES  0x20\n#define XREG_SNR          0x40\n\n#define XREG_ADC_ENV      0x0100\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\nstatic int no_poweroff;\nmodule_param(no_poweroff, int, 0644);\nMODULE_PARM_DESC(no_poweroff, \"0 (default) powers device off when not used.\\n\"\n\t\"1 keep device energized and with tuner ready all the times.\\n\"\n\t\"  Faster, but consumes more power and keeps the device hotter\\n\");\n\nstatic char audio_std[8];\nmodule_param_string(audio_std, audio_std, sizeof(audio_std), 0);\nMODULE_PARM_DESC(audio_std,\n\t\"Audio standard. XC3028 audio decoder explicitly \"\n\t\"needs to know what audio\\n\"\n\t\"standard is needed for some video standards with audio A2 or NICAM.\\n\"\n\t\"The valid values are:\\n\"\n\t\"A2\\n\"\n\t\"A2/A\\n\"\n\t\"A2/B\\n\"\n\t\"NICAM\\n\"\n\t\"NICAM/A\\n\"\n\t\"NICAM/B\\n\");\n\nstatic char firmware_name[30];\nmodule_param_string(firmware_name, firmware_name, sizeof(firmware_name), 0);\nMODULE_PARM_DESC(firmware_name, \"Firmware file name. Allows overriding the \"\n\t\t\t\t\"default firmware name\\n\");\n\nstatic LIST_HEAD(hybrid_tuner_instance_list);\nstatic DEFINE_MUTEX(xc2028_list_mutex);\n\n/* struct for storing firmware table */\nstruct firmware_description {\n\tunsigned int  type;\n\tv4l2_std_id   id;\n\t__u16         int_freq;\n\tunsigned char *ptr;\n\tunsigned int  size;\n};\n\nstruct firmware_properties {\n\tunsigned int\ttype;\n\tv4l2_std_id\tid;\n\tv4l2_std_id\tstd_req;\n\t__u16\t\tint_freq;\n\tunsigned int\tscode_table;\n\tint \t\tscode_nr;\n};\n\nenum xc2028_state {\n\tXC2028_NO_FIRMWARE = 0,\n\tXC2028_WAITING_FIRMWARE,\n\tXC2028_ACTIVE,\n\tXC2028_SLEEP,\n\tXC2028_NODEV,\n};\n\nstruct xc2028_data {\n\tstruct list_head        hybrid_tuner_instance_list;\n\tstruct tuner_i2c_props  i2c_props;\n\t__u32\t\t\tfrequency;\n\n\tenum xc2028_state\tstate;\n\tconst char\t\t*fname;\n\n\tstruct firmware_description *firm;\n\tint\t\t\tfirm_size;\n\t__u16\t\t\tfirm_version;\n\n\t__u16\t\t\thwmodel;\n\t__u16\t\t\thwvers;\n\n\tstruct xc2028_ctrl\tctrl;\n\n\tstruct firmware_properties cur_fw;\n\n\tstruct mutex lock;\n};\n\n#define i2c_send(priv, buf, size) ({\t\t\t\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\t_rc = tuner_i2c_xfer_send(&priv->i2c_props, buf, size);\t\t\\\n\tif (size != _rc)\t\t\t\t\t\t\\\n\t\ttuner_info(\"i2c output error: rc = %d (should be %d)\\n\",\\\n\t\t\t   _rc, (int)size);\t\t\t\t\\\n\tif (priv->ctrl.msleep)\t\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\n#define i2c_send_recv(priv, obuf, osize, ibuf, isize) ({\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\t_rc = tuner_i2c_xfer_send_recv(&priv->i2c_props, obuf, osize,\t\\\n\t\t\t\t       ibuf, isize);\t\t\t\\\n\tif (isize != _rc)\t\t\t\t\t\t\\\n\t\ttuner_err(\"i2c input error: rc = %d (should be %d)\\n\",\t\\\n\t\t\t   _rc, (int)isize); \t\t\t\t\\\n\tif (priv->ctrl.msleep)\t\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\n#define send_seq(priv, data...)\t({\t\t\t\t\t\\\n\tstatic u8 _val[] = data;\t\t\t\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\tif (sizeof(_val) !=\t\t\t\t\t\t\\\n\t\t\t(_rc = tuner_i2c_xfer_send(&priv->i2c_props,\t\\\n\t\t\t\t\t\t_val, sizeof(_val)))) {\t\\\n\t\ttuner_err(\"Error on line %d: %d\\n\", __LINE__, _rc);\t\\\n\t} else if (priv->ctrl.msleep)\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\nstatic int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\n{\n\tunsigned char buf[2];\n\tunsigned char ibuf[2];\n\n\ttuner_dbg(\"%s %04x called\\n\", __func__, reg);\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = (unsigned char) reg;\n\n\tif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\n\t\treturn -EIO;\n\n\t*val = (ibuf[1]) | (ibuf[0] << 8);\n\treturn 0;\n}\n\n#define dump_firm_type(t) \tdump_firm_type_and_int_freq(t, 0)\nstatic void dump_firm_type_and_int_freq(unsigned int type, u16 int_freq)\n{\n\tif (type & BASE)\n\t\tprintk(\"BASE \");\n\tif (type & INIT1)\n\t\tprintk(\"INIT1 \");\n\tif (type & F8MHZ)\n\t\tprintk(\"F8MHZ \");\n\tif (type & MTS)\n\t\tprintk(\"MTS \");\n\tif (type & D2620)\n\t\tprintk(\"D2620 \");\n\tif (type & D2633)\n\t\tprintk(\"D2633 \");\n\tif (type & DTV6)\n\t\tprintk(\"DTV6 \");\n\tif (type & QAM)\n\t\tprintk(\"QAM \");\n\tif (type & DTV7)\n\t\tprintk(\"DTV7 \");\n\tif (type & DTV78)\n\t\tprintk(\"DTV78 \");\n\tif (type & DTV8)\n\t\tprintk(\"DTV8 \");\n\tif (type & FM)\n\t\tprintk(\"FM \");\n\tif (type & INPUT1)\n\t\tprintk(\"INPUT1 \");\n\tif (type & LCD)\n\t\tprintk(\"LCD \");\n\tif (type & NOGD)\n\t\tprintk(\"NOGD \");\n\tif (type & MONO)\n\t\tprintk(\"MONO \");\n\tif (type & ATSC)\n\t\tprintk(\"ATSC \");\n\tif (type & IF)\n\t\tprintk(\"IF \");\n\tif (type & LG60)\n\t\tprintk(\"LG60 \");\n\tif (type & ATI638)\n\t\tprintk(\"ATI638 \");\n\tif (type & OREN538)\n\t\tprintk(\"OREN538 \");\n\tif (type & OREN36)\n\t\tprintk(\"OREN36 \");\n\tif (type & TOYOTA388)\n\t\tprintk(\"TOYOTA388 \");\n\tif (type & TOYOTA794)\n\t\tprintk(\"TOYOTA794 \");\n\tif (type & DIBCOM52)\n\t\tprintk(\"DIBCOM52 \");\n\tif (type & ZARLINK456)\n\t\tprintk(\"ZARLINK456 \");\n\tif (type & CHINA)\n\t\tprintk(\"CHINA \");\n\tif (type & F6MHZ)\n\t\tprintk(\"F6MHZ \");\n\tif (type & INPUT2)\n\t\tprintk(\"INPUT2 \");\n\tif (type & SCODE)\n\t\tprintk(\"SCODE \");\n\tif (type & HAS_IF)\n\t\tprintk(\"HAS_IF_%d \", int_freq);\n}\n\nstatic  v4l2_std_id parse_audio_std_option(void)\n{\n\tif (strcasecmp(audio_std, \"A2\") == 0)\n\t\treturn V4L2_STD_A2;\n\tif (strcasecmp(audio_std, \"A2/A\") == 0)\n\t\treturn V4L2_STD_A2_A;\n\tif (strcasecmp(audio_std, \"A2/B\") == 0)\n\t\treturn V4L2_STD_A2_B;\n\tif (strcasecmp(audio_std, \"NICAM\") == 0)\n\t\treturn V4L2_STD_NICAM;\n\tif (strcasecmp(audio_std, \"NICAM/A\") == 0)\n\t\treturn V4L2_STD_NICAM_A;\n\tif (strcasecmp(audio_std, \"NICAM/B\") == 0)\n\t\treturn V4L2_STD_NICAM_B;\n\n\treturn 0;\n}\n\nstatic int check_device_status(struct xc2028_data *priv)\n{\n\tswitch (priv->state) {\n\tcase XC2028_NO_FIRMWARE:\n\tcase XC2028_WAITING_FIRMWARE:\n\t\treturn -EAGAIN;\n\tcase XC2028_ACTIVE:\n\t\treturn 1;\n\tcase XC2028_SLEEP:\n\t\treturn 0;\n\tcase XC2028_NODEV:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void free_firmware(struct xc2028_data *priv)\n{\n\tint i;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (!priv->firm)\n\t\treturn;\n\n\tfor (i = 0; i < priv->firm_size; i++)\n\t\tkfree(priv->firm[i].ptr);\n\n\tkfree(priv->firm);\n\n\tpriv->firm = NULL;\n\tpriv->firm_size = 0;\n\tpriv->state = XC2028_NO_FIRMWARE;\n\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n}\n\nstatic int load_all_firmwares(struct dvb_frontend *fe,\n\t\t\t      const struct firmware *fw)\n{\n\tstruct xc2028_data    *priv = fe->tuner_priv;\n\tconst unsigned char   *p, *endp;\n\tint                   rc = 0;\n\tint\t\t      n, n_array;\n\tchar\t\t      name[33];\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tp = fw->data;\n\tendp = p + fw->size;\n\n\tif (fw->size < sizeof(name) - 1 + 2 + 2) {\n\t\ttuner_err(\"Error: firmware file %s has invalid size!\\n\",\n\t\t\t  priv->fname);\n\t\tgoto corrupt;\n\t}\n\n\tmemcpy(name, p, sizeof(name) - 1);\n\tname[sizeof(name) - 1] = 0;\n\tp += sizeof(name) - 1;\n\n\tpriv->firm_version = get_unaligned_le16(p);\n\tp += 2;\n\n\tn_array = get_unaligned_le16(p);\n\tp += 2;\n\n\ttuner_info(\"Loading %d firmware images from %s, type: %s, ver %d.%d\\n\",\n\t\t   n_array, priv->fname, name,\n\t\t   priv->firm_version >> 8, priv->firm_version & 0xff);\n\n\tpriv->firm = kcalloc(n_array, sizeof(*priv->firm), GFP_KERNEL);\n\tif (priv->firm == NULL) {\n\t\ttuner_err(\"Not enough memory to load firmware file.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tpriv->firm_size = n_array;\n\n\tn = -1;\n\twhile (p < endp) {\n\t\t__u32 type, size;\n\t\tv4l2_std_id id;\n\t\t__u16 int_freq = 0;\n\n\t\tn++;\n\t\tif (n >= n_array) {\n\t\t\ttuner_err(\"More firmware images in file than \"\n\t\t\t\t  \"were expected!\\n\");\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\t/* Checks if there's enough bytes to read */\n\t\tif (endp - p < sizeof(type) + sizeof(id) + sizeof(size))\n\t\t\tgoto header;\n\n\t\ttype = get_unaligned_le32(p);\n\t\tp += sizeof(type);\n\n\t\tid = get_unaligned_le64(p);\n\t\tp += sizeof(id);\n\n\t\tif (type & HAS_IF) {\n\t\t\tint_freq = get_unaligned_le16(p);\n\t\t\tp += sizeof(int_freq);\n\t\t\tif (endp - p < sizeof(size))\n\t\t\t\tgoto header;\n\t\t}\n\n\t\tsize = get_unaligned_le32(p);\n\t\tp += sizeof(size);\n\n\t\tif (!size || size > endp - p) {\n\t\t\ttuner_err(\"Firmware type \");\n\t\t\tdump_firm_type(type);\n\t\t\tprintk(\"(%x), id %llx is corrupted \"\n\t\t\t       \"(size=%d, expected %d)\\n\",\n\t\t\t       type, (unsigned long long)id,\n\t\t\t       (unsigned)(endp - p), size);\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\tpriv->firm[n].ptr = kzalloc(size, GFP_KERNEL);\n\t\tif (priv->firm[n].ptr == NULL) {\n\t\t\ttuner_err(\"Not enough memory to load firmware file.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\ttuner_dbg(\"Reading firmware type \");\n\t\tif (debug) {\n\t\t\tdump_firm_type_and_int_freq(type, int_freq);\n\t\t\tprintk(\"(%x), id %llx, size=%d.\\n\",\n\t\t\t       type, (unsigned long long)id, size);\n\t\t}\n\n\t\tmemcpy(priv->firm[n].ptr, p, size);\n\t\tpriv->firm[n].type = type;\n\t\tpriv->firm[n].id   = id;\n\t\tpriv->firm[n].size = size;\n\t\tpriv->firm[n].int_freq = int_freq;\n\n\t\tp += size;\n\t}\n\n\tif (n + 1 != priv->firm_size) {\n\t\ttuner_err(\"Firmware file is incomplete!\\n\");\n\t\tgoto corrupt;\n\t}\n\n\tgoto done;\n\nheader:\n\ttuner_err(\"Firmware header is incomplete!\\n\");\ncorrupt:\n\trc = -EINVAL;\n\ttuner_err(\"Error: firmware file is corrupted!\\n\");\n\nerr:\n\ttuner_info(\"Releasing partially loaded firmware file.\\n\");\n\tfree_firmware(priv);\n\ndone:\n\tif (rc == 0)\n\t\ttuner_dbg(\"Firmware files loaded.\\n\");\n\telse\n\t\tpriv->state = XC2028_NODEV;\n\n\treturn rc;\n}\n\nstatic int seek_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                 i, best_i = -1, best_nr_matches = 0;\n\tunsigned int        type_mask = 0;\n\n\ttuner_dbg(\"%s called, want type=\", __func__);\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\n\tif (!priv->firm) {\n\t\ttuner_err(\"Error! firmware not loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((type & ~SCODE) == 0) && (*id == 0))\n\t\t*id = V4L2_STD_PAL;\n\n\tif (type & BASE)\n\t\ttype_mask = BASE_TYPES;\n\telse if (type & SCODE) {\n\t\ttype &= SCODE_TYPES;\n\t\ttype_mask = SCODE_TYPES & ~HAS_IF;\n\t} else if (type & DTV_TYPES)\n\t\ttype_mask = DTV_TYPES;\n\telse if (type & STD_SPECIFIC_TYPES)\n\t\ttype_mask = STD_SPECIFIC_TYPES;\n\n\ttype &= type_mask;\n\n\tif (!(type & SCODE))\n\t\ttype_mask = ~0;\n\n\t/* Seek for exact match */\n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tif ((type == (priv->firm[i].type & type_mask)) &&\n\t\t    (*id == priv->firm[i].id))\n\t\t\tgoto found;\n\t}\n\n\t/* Seek for generic video standard match */\n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tv4l2_std_id match_mask;\n\t\tint nr_matches;\n\n\t\tif (type != (priv->firm[i].type & type_mask))\n\t\t\tcontinue;\n\n\t\tmatch_mask = *id & priv->firm[i].id;\n\t\tif (!match_mask)\n\t\t\tcontinue;\n\n\t\tif ((*id & match_mask) == *id)\n\t\t\tgoto found; /* Supports all the requested standards */\n\n\t\tnr_matches = hweight64(match_mask);\n\t\tif (nr_matches > best_nr_matches) {\n\t\t\tbest_nr_matches = nr_matches;\n\t\t\tbest_i = i;\n\t\t}\n\t}\n\n\tif (best_nr_matches > 0) {\n\t\ttuner_dbg(\"Selecting best matching firmware (%d bits) for \"\n\t\t\t  \"type=\", best_nr_matches);\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx:\\n\", type, (unsigned long long)*id);\n\t\ti = best_i;\n\t\tgoto found;\n\t}\n\n\t/*FIXME: Would make sense to seek for type \"hint\" match ? */\n\n\ti = -ENOENT;\n\tgoto ret;\n\nfound:\n\t*id = priv->firm[i].id;\n\nret:\n\ttuner_dbg(\"%s firmware for type=\", (i < 0) ? \"Can't find\" : \"Found\");\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\treturn i;\n}\n\nstatic inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\n\t/* analog side (tuner-core) uses i2c_adap->algo_data.\n\t * digital side is not guaranteed to have algo_data defined.\n\t *\n\t * digital side will always have fe->dvb defined.\n\t * analog side (tuner-core) doesn't (yet) define fe->dvb.\n\t */\n\n\treturn (!fe->callback) ? -EINVAL :\n\t\tfe->callback(((fe->dvb) && (fe->dvb->priv)) ?\n\t\t\t\tfe->dvb->priv : priv->i2c_props.adap->algo_data,\n\t\t\t     DVB_FRONTEND_COMPONENT_TUNER, cmd, arg);\n}\n\nstatic int load_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char      *p, *endp, buf[MAX_XFER_SIZE];\n\n\tif (priv->ctrl.max_len > sizeof(buf))\n\t\tpriv->ctrl.max_len = sizeof(buf);\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tpos = seek_firmware(fe, type, id);\n\tif (pos < 0)\n\t\treturn pos;\n\n\ttuner_info(\"Loading firmware for type=\");\n\tdump_firm_type(priv->firm[pos].type);\n\tprintk(\"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t       (unsigned long long)*id);\n\n\tp = priv->firm[pos].ptr;\n\tendp = p + priv->firm[pos].size;\n\n\twhile (p < endp) {\n\t\t__u16 size;\n\n\t\t/* Checks if there's enough bytes to read */\n\t\tif (p + sizeof(size) > endp) {\n\t\t\ttuner_err(\"Firmware chunk size is wrong\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsize = le16_to_cpu(*(__le16 *) p);\n\t\tp += sizeof(size);\n\n\t\tif (size == 0xffff)\n\t\t\treturn 0;\n\n\t\tif (!size) {\n\t\t\t/* Special callback command received */\n\t\t\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\t\t\tif (rc < 0) {\n\t\t\t\ttuner_err(\"Error at RESET code %d\\n\",\n\t\t\t\t\t   (*p) & 0x7f);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (size >= 0xff00) {\n\t\t\tswitch (size) {\n\t\t\tcase 0xff00:\n\t\t\t\trc = do_tuner_callback(fe, XC2028_RESET_CLK, 0);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\ttuner_err(\"Error at RESET code %d\\n\",\n\t\t\t\t\t\t  (*p) & 0x7f);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttuner_info(\"Invalid RESET code %d\\n\",\n\t\t\t\t\t   size & 0x7f);\n\t\t\t\treturn -EINVAL;\n\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Checks for a sleep command */\n\t\tif (size & 0x8000) {\n\t\t\tmsleep(size & 0x7fff);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((size + p > endp)) {\n\t\t\ttuner_err(\"missing bytes: need %d, have %d\\n\",\n\t\t\t\t   size, (int)(endp - p));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuf[0] = *p;\n\t\tp++;\n\t\tsize--;\n\n\t\t/* Sends message chunks */\n\t\twhile (size > 0) {\n\t\t\tint len = (size < priv->ctrl.max_len - 1) ?\n\t\t\t\t   size : priv->ctrl.max_len - 1;\n\n\t\t\tmemcpy(buf + 1, p, len);\n\n\t\t\trc = i2c_send(priv, buf, len + 1);\n\t\t\tif (rc < 0) {\n\t\t\t\ttuner_err(\"%d returned from send\\n\", rc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tp += len;\n\t\t\tsize -= len;\n\t\t}\n\n\t\t/* silently fail if the frontend doesn't support I2C flush */\n\t\trc = do_tuner_callback(fe, XC2028_I2C_FLUSH, 0);\n\t\tif ((rc < 0) && (rc != -EINVAL)) {\n\t\t\ttuner_err(\"error executing flush: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int load_scode(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id, __u16 int_freq, int scode)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char\t   *p;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (!int_freq) {\n\t\tpos = seek_firmware(fe, type, id);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\t} else {\n\t\tfor (pos = 0; pos < priv->firm_size; pos++) {\n\t\t\tif ((priv->firm[pos].int_freq == int_freq) &&\n\t\t\t    (priv->firm[pos].type & HAS_IF))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pos == priv->firm_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tp = priv->firm[pos].ptr;\n\n\tif (priv->firm[pos].type & HAS_IF) {\n\t\tif (priv->firm[pos].size != 12 * 16 || scode >= 16)\n\t\t\treturn -EINVAL;\n\t\tp += 12 * scode;\n\t} else {\n\t\t/* 16 SCODE entries per file; each SCODE entry is 12 bytes and\n\t\t * has a 2-byte size header in the firmware format. */\n\t\tif (priv->firm[pos].size != 14 * 16 || scode >= 16 ||\n\t\t    le16_to_cpu(*(__le16 *)(p + 14 * scode)) != 12)\n\t\t\treturn -EINVAL;\n\t\tp += 14 * scode + 2;\n\t}\n\n\ttuner_info(\"Loading SCODE for type=\");\n\tdump_firm_type_and_int_freq(priv->firm[pos].type,\n\t\t\t\t    priv->firm[pos].int_freq);\n\tprintk(\"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t       (unsigned long long)*id);\n\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0xa0, 0x00, 0x00, 0x00});\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\trc = i2c_send(priv, p, 12);\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\trc = send_seq(priv, {0x00, 0x8c});\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int xc2028_sleep(struct dvb_frontend *fe);\n\nstatic int check_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t  v4l2_std_id std, __u16 int_freq)\n{\n\tstruct xc2028_data         *priv = fe->tuner_priv;\n\tstruct firmware_properties new_fw;\n\tint\t\t\t   rc, retry_count = 0;\n\tu16\t\t\t   version, hwmodel;\n\tv4l2_std_id\t\t   std0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (priv->ctrl.mts && !(type & FM))\n\t\ttype |= MTS;\n\nretry:\n\tnew_fw.type = type;\n\tnew_fw.id = std;\n\tnew_fw.std_req = std;\n\tnew_fw.scode_table = SCODE | priv->ctrl.scode_table;\n\tnew_fw.scode_nr = 0;\n\tnew_fw.int_freq = int_freq;\n\n\ttuner_dbg(\"checking firmware, user requested type=\");\n\tif (debug) {\n\t\tdump_firm_type(new_fw.type);\n\t\tprintk(\"(%x), id %016llx, \", new_fw.type,\n\t\t       (unsigned long long)new_fw.std_req);\n\t\tif (!int_freq) {\n\t\t\tprintk(\"scode_tbl \");\n\t\t\tdump_firm_type(priv->ctrl.scode_table);\n\t\t\tprintk(\"(%x), \", priv->ctrl.scode_table);\n\t\t} else\n\t\t\tprintk(\"int_freq %d, \", new_fw.int_freq);\n\t\tprintk(\"scode_nr %d\\n\", new_fw.scode_nr);\n\t}\n\n\t/*\n\t * No need to reload base firmware if it matches and if the tuner\n\t * is not at sleep mode\n\t */\n\tif ((priv->state == XC2028_ACTIVE) &&\n\t    (((BASE | new_fw.type) & BASE_TYPES) ==\n\t    (priv->cur_fw.type & BASE_TYPES))) {\n\t\ttuner_dbg(\"BASE firmware not changed.\\n\");\n\t\tgoto skip_base;\n\t}\n\n\t/* Updating BASE - forget about all currently loaded firmware */\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\n\t/* Reset is needed before loading firmware */\n\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t/* BASE firmwares are all std0 */\n\tstd0 = 0;\n\trc = load_firmware(fe, BASE | new_fw.type, &std0);\n\tif (rc < 0) {\n\t\ttuner_err(\"Error %d while loading base firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\n\t/* Load INIT1, if needed */\n\ttuner_dbg(\"Load init1 firmware, if exists\\n\");\n\n\trc = load_firmware(fe, BASE | INIT1 | new_fw.type, &std0);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, (BASE | INIT1 | new_fw.type) & ~F8MHZ,\n\t\t\t\t   &std0);\n\tif (rc < 0 && rc != -ENOENT) {\n\t\ttuner_err(\"Error %d while loading init1 firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\nskip_base:\n\t/*\n\t * No need to reload standard specific firmware if base firmware\n\t * was not reloaded and requested video standards have not changed.\n\t */\n\tif (priv->cur_fw.type == (BASE | new_fw.type) &&\n\t    priv->cur_fw.std_req == std) {\n\t\ttuner_dbg(\"Std-specific firmware already loaded.\\n\");\n\t\tgoto skip_std_specific;\n\t}\n\n\t/* Reloading std-specific firmware forces a SCODE update */\n\tpriv->cur_fw.scode_table = 0;\n\n\trc = load_firmware(fe, new_fw.type, &new_fw.id);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, new_fw.type & ~F8MHZ, &new_fw.id);\n\n\tif (rc < 0)\n\t\tgoto fail;\n\nskip_std_specific:\n\tif (priv->cur_fw.scode_table == new_fw.scode_table &&\n\t    priv->cur_fw.scode_nr == new_fw.scode_nr) {\n\t\ttuner_dbg(\"SCODE firmware already loaded.\\n\");\n\t\tgoto check_device;\n\t}\n\n\tif (new_fw.type & FM)\n\t\tgoto check_device;\n\n\t/* Load SCODE firmware, if exists */\n\ttuner_dbg(\"Trying to load scode %d\\n\", new_fw.scode_nr);\n\n\trc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\n\t\t\tnew_fw.int_freq, new_fw.scode_nr);\n\ncheck_device:\n\tif (xc2028_get_reg(priv, 0x0004, &version) < 0 ||\n\t    xc2028_get_reg(priv, 0x0008, &hwmodel) < 0) {\n\t\ttuner_err(\"Unable to read tuner registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\ttuner_dbg(\"Device is Xceive %d version %d.%d, \"\n\t\t  \"firmware version %d.%d\\n\",\n\t\t  hwmodel, (version & 0xf000) >> 12, (version & 0xf00) >> 8,\n\t\t  (version & 0xf0) >> 4, version & 0xf);\n\n\n\tif (priv->ctrl.read_not_reliable)\n\t\tgoto read_not_reliable;\n\n\t/* Check firmware version against what we downloaded. */\n\tif (priv->firm_version != ((version & 0xf0) << 4 | (version & 0x0f))) {\n\t\tif (!priv->ctrl.read_not_reliable) {\n\t\t\ttuner_err(\"Incorrect readback of firmware version.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\ttuner_err(\"Returned an incorrect version. However, \"\n\t\t\t\t  \"read is not reliable enough. Ignoring it.\\n\");\n\t\t\thwmodel = 3028;\n\t\t}\n\t}\n\n\t/* Check that the tuner hardware model remains consistent over time. */\n\tif (priv->hwmodel == 0 && (hwmodel == 2028 || hwmodel == 3028)) {\n\t\tpriv->hwmodel = hwmodel;\n\t\tpriv->hwvers  = version & 0xff00;\n\t} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel ||\n\t\t   priv->hwvers != (version & 0xff00)) {\n\t\ttuner_err(\"Read invalid device hardware information - tuner \"\n\t\t\t  \"hung?\\n\");\n\t\tgoto fail;\n\t}\n\nread_not_reliable:\n\tpriv->cur_fw = new_fw;\n\n\t/*\n\t * By setting BASE in cur_fw.type only after successfully loading all\n\t * firmwares, we can:\n\t * 1. Identify that BASE firmware with type=0 has been loaded;\n\t * 2. Tell whether BASE firmware was just changed the next time through.\n\t */\n\tpriv->cur_fw.type |= BASE;\n\tpriv->state = XC2028_ACTIVE;\n\n\treturn 0;\n\nfail:\n\tpriv->state = XC2028_NO_FIRMWARE;\n\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\tif (retry_count < 8) {\n\t\tmsleep(50);\n\t\tretry_count++;\n\t\ttuner_dbg(\"Retrying firmware load\\n\");\n\t\tgoto retry;\n\t}\n\n\t/* Firmware didn't load. Put the device to sleep */\n\txc2028_sleep(fe);\n\n\tif (rc == -ENOENT)\n\t\trc = -EINVAL;\n\treturn rc;\n}\n\nstatic int xc2028_signal(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tu16                 frq_lock, signal = 0;\n\tint                 rc, i;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* If the device is sleeping, no channel is tuned */\n\tif (!rc) {\n\t\t*strength = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t/* Sync Lock Indicator */\n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t/* Frequency didn't lock */\n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t/* Get SNR of the video signal */\n\trc = xc2028_get_reg(priv, XREG_SNR, &signal);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t/* Signal level is 3 bits only */\n\n\tsignal = ((1 << 12) - 1) | ((signal & 0x07) << 12);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\t*strength = signal;\n\n\ttuner_dbg(\"signal strength is %d\\n\", signal);\n\n\treturn rc;\n}\n\nstatic int xc2028_get_afc(struct dvb_frontend *fe, s32 *afc)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint i, rc;\n\tu16 frq_lock = 0;\n\ts16 afc_reg = 0;\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* If the device is sleeping, no channel is tuned */\n\tif (!rc) {\n\t\t*afc = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t/* Sync Lock Indicator */\n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t/* Frequency didn't lock */\n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t/* Get AFC */\n\trc = xc2028_get_reg(priv, XREG_FREQ_ERROR, &afc_reg);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t*afc = afc_reg * 15625; /* Hz */\n\n\ttuner_dbg(\"AFC is %d Hz\\n\", *afc);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\n#define DIV 15625\n\nstatic int generic_set_freq(struct dvb_frontend *fe, u32 freq /* in HZ */,\n\t\t\t    enum v4l2_tuner_type new_type,\n\t\t\t    unsigned int type,\n\t\t\t    v4l2_std_id std,\n\t\t\t    u16 int_freq)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint\t\t   rc = -EINVAL;\n\tunsigned char\t   buf[4];\n\tu32\t\t   div, offset = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\ttuner_dbg(\"should set frequency %d kHz\\n\", freq / 1000);\n\n\tif (check_firmware(fe, type, std, int_freq) < 0)\n\t\tgoto ret;\n\n\t/* On some cases xc2028 can disable video output, if\n\t * very weak signals are received. By sending a soft\n\t * reset, this is re-enabled. So, it is better to always\n\t * send a soft reset before changing channels, to be sure\n\t * that xc2028 will be in a safe state.\n\t * Maybe this might also be needed for DTV.\n\t */\n\tswitch (new_type) {\n\tcase V4L2_TUNER_ANALOG_TV:\n\t\trc = send_seq(priv, {0x00, 0x00});\n\n\t\t/* Analog mode requires offset = 0 */\n\t\tbreak;\n\tcase V4L2_TUNER_RADIO:\n\t\t/* Radio mode requires offset = 0 */\n\t\tbreak;\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\t/*\n\t\t * Digital modes require an offset to adjust to the\n\t\t * proper frequency. The offset depends on what\n\t\t * firmware version is used.\n\t\t */\n\n\t\t/*\n\t\t * Adjust to the center frequency. This is calculated by the\n\t\t * formula: offset = 1.25MHz - BW/2\n\t\t * For DTV 7/8, the firmware uses BW = 8000, so it needs a\n\t\t * further adjustment to get the frequency center on VHF\n\t\t */\n\n\t\t/*\n\t\t * The firmware DTV78 used to work fine in UHF band (8 MHz\n\t\t * bandwidth) but not at all in VHF band (7 MHz bandwidth).\n\t\t * The real problem was connected to the formula used to\n\t\t * calculate the center frequency offset in VHF band.\n\t\t * In fact, removing the 500KHz adjustment fixed the problem.\n\t\t * This is coherent to what was implemented for the DTV7\n\t\t * firmware.\n\t\t * In the end, now the center frequency is the same for all 3\n\t\t * firmwares (DTV7, DTV8, DTV78) and doesn't depend on channel\n\t\t * bandwidth.\n\t\t */\n\n\t\tif (priv->cur_fw.type & DTV6)\n\t\t\toffset = 1750000;\n\t\telse\t/* DTV7 or DTV8 or DTV78 */\n\t\t\toffset = 2750000;\n\n\t\t/*\n\t\t * xc3028 additional \"magic\"\n\t\t * Depending on the firmware version, it needs some adjustments\n\t\t * to properly centralize the frequency. This seems to be\n\t\t * needed to compensate the SCODE table adjustments made by\n\t\t * newer firmwares\n\t\t */\n\n\t\t/*\n\t\t * The proper adjustment would be to do it at s-code table.\n\t\t * However, this didn't work, as reported by\n\t\t * Robert Lowery <rglowery@exemail.com.au>\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * Still need tests for XC3028L (firmware 3.2 or upper)\n\t\t * So, for now, let's just comment the per-firmware\n\t\t * version of this change. Reports with xc3028l working\n\t\t * with and without the lines below are welcome\n\t\t */\n\n\t\tif (priv->firm_version < 0x0302) {\n\t\t\tif (priv->cur_fw.type & DTV7)\n\t\t\t\toffset += 500000;\n\t\t} else {\n\t\t\tif (priv->cur_fw.type & DTV7)\n\t\t\t\toffset -= 300000;\n\t\t\telse if (type != ATSC) /* DVB @6MHz, DTV 8 and DTV 7/8 */\n\t\t\t\toffset += 200000;\n\t\t}\n#endif\n\t\tbreak;\n\tdefault:\n\t\ttuner_err(\"Unsupported tuner type %d.\\n\", new_type);\n\t\tbreak;\n\t}\n\n\tdiv = (freq - offset + DIV / 2) / DIV;\n\n\t/* CMD= Set frequency */\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_RF_FREQ, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_RF_FREQ, 0x00, 0x00});\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t/* Return code shouldn't be checked.\n\t   The reset CLK is needed only with tm6000.\n\t   Driver should work fine even if this fails.\n\t */\n\tif (priv->ctrl.msleep)\n\t\tmsleep(priv->ctrl.msleep);\n\tdo_tuner_callback(fe, XC2028_RESET_CLK, 1);\n\n\tmsleep(10);\n\n\tbuf[0] = 0xff & (div >> 24);\n\tbuf[1] = 0xff & (div >> 16);\n\tbuf[2] = 0xff & (div >> 8);\n\tbuf[3] = 0xff & (div);\n\n\trc = i2c_send(priv, buf, sizeof(buf));\n\tif (rc < 0)\n\t\tgoto ret;\n\tmsleep(100);\n\n\tpriv->frequency = freq;\n\n\ttuner_dbg(\"divisor= %*ph (freq=%d.%03d)\\n\", 4, buf,\n\t       freq / 1000000, (freq % 1000000) / 1000);\n\n\trc = 0;\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic int xc2028_set_analog_freq(struct dvb_frontend *fe,\n\t\t\t      struct analog_parameters *p)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tunsigned int       type=0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (p->mode == V4L2_TUNER_RADIO) {\n\t\ttype |= FM;\n\t\tif (priv->ctrl.input1)\n\t\t\ttype |= INPUT1;\n\t\treturn generic_set_freq(fe, (625l * p->frequency) / 10,\n\t\t\t\tV4L2_TUNER_RADIO, type, 0, 0);\n\t}\n\n\t/* if std is not defined, choose one */\n\tif (!p->std)\n\t\tp->std = V4L2_STD_MN;\n\n\t/* PAL/M, PAL/N, PAL/Nc and NTSC variants should use 6MHz firmware */\n\tif (!(p->std & V4L2_STD_MN))\n\t\ttype |= F8MHZ;\n\n\t/* Add audio hack to std mask */\n\tp->std |= parse_audio_std_option();\n\n\treturn generic_set_freq(fe, 62500l * p->frequency,\n\t\t\t\tV4L2_TUNER_ANALOG_TV, type, p->std, 0);\n}\n\nstatic int xc2028_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\tunsigned int       type = 0;\n\tu16                demod = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (delsys) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\t/*\n\t\t * The only countries with 6MHz seem to be Taiwan/Uruguay.\n\t\t * Both seem to require QAM firmware for OFDM decoding\n\t\t * Tested in Taiwan by Terry Wu <terrywu2009@gmail.com>\n\t\t */\n\t\tif (bw <= 6000000)\n\t\t\ttype |= QAM;\n\n\t\tswitch (priv->ctrl.type) {\n\t\tcase XC2028_D2633:\n\t\t\ttype |= D2633;\n\t\t\tbreak;\n\t\tcase XC2028_D2620:\n\t\t\ttype |= D2620;\n\t\t\tbreak;\n\t\tcase XC2028_AUTO:\n\t\tdefault:\n\t\t\t/* Zarlink seems to need D2633 */\n\t\t\tif (priv->ctrl.demod == XC3028_FE_ZARLINK456)\n\t\t\t\ttype |= D2633;\n\t\t\telse\n\t\t\t\ttype |= D2620;\n\t\t}\n\t\tbreak;\n\tcase SYS_ATSC:\n\t\t/* The only ATSC firmware (at least on v2.7) is D2633 */\n\t\ttype |= ATSC | D2633;\n\t\tbreak;\n\t/* DVB-S and pure QAM (FE_QAM) are not supported */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (bw <= 6000000) {\n\t\ttype |= DTV6;\n\t\tpriv->ctrl.vhfbw7 = 0;\n\t\tpriv->ctrl.uhfbw8 = 0;\n\t} else if (bw <= 7000000) {\n\t\tif (c->frequency < 470000000)\n\t\t\tpriv->ctrl.vhfbw7 = 1;\n\t\telse\n\t\t\tpriv->ctrl.uhfbw8 = 0;\n\t\ttype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV7;\n\t\ttype |= F8MHZ;\n\t} else {\n\t\tif (c->frequency < 470000000)\n\t\t\tpriv->ctrl.vhfbw7 = 0;\n\t\telse\n\t\t\tpriv->ctrl.uhfbw8 = 1;\n\t\ttype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV8;\n\t\ttype |= F8MHZ;\n\t}\n\n\t/* All S-code tables need a 200kHz shift */\n\tif (priv->ctrl.demod) {\n\t\tdemod = priv->ctrl.demod;\n\n\t\t/*\n\t\t * Newer firmwares require a 200 kHz offset only for ATSC\n\t\t */\n\t\tif (type == ATSC || priv->firm_version < 0x0302)\n\t\t\tdemod += 200;\n\t\t/*\n\t\t * The DTV7 S-code table needs a 700 kHz shift.\n\t\t *\n\t\t * DTV7 is only used in Australia.  Germany or Italy may also\n\t\t * use this firmware after initialization, but a tune to a UHF\n\t\t * channel should then cause DTV78 to be used.\n\t\t *\n\t\t * Unfortunately, on real-field tests, the s-code offset\n\t\t * didn't work as expected, as reported by\n\t\t * Robert Lowery <rglowery@exemail.com.au>\n\t\t */\n\t}\n\n\treturn generic_set_freq(fe, c->frequency,\n\t\t\t\tV4L2_TUNER_DIGITAL_TV, type, 0, demod);\n}\n\nstatic int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/* Device is already in sleep mode */\n\tif (!rc)\n\t\treturn 0;\n\n\t/* Avoid firmware reload on slow devices or if PM disabled */\n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic int xc2028_dvb_release(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&xc2028_list_mutex);\n\n\t/* only perform final cleanup if this is the last instance */\n\tif (hybrid_tuner_report_instance_count(priv) == 1) {\n\t\tfree_firmware(priv);\n\t\tkfree(priv->ctrl.fname);\n\t\tpriv->ctrl.fname = NULL;\n\t}\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&xc2028_list_mutex);\n\n\tfe->tuner_priv = NULL;\n\n\treturn 0;\n}\n\nstatic int xc2028_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*frequency = priv->frequency;\n\n\treturn 0;\n}\n\nstatic void load_firmware_cb(const struct firmware *fw,\n\t\t\t     void *context)\n{\n\tstruct dvb_frontend *fe = context;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"request_firmware_nowait(): %s\\n\", fw ? \"OK\" : \"error\");\n\tif (!fw) {\n\t\ttuner_err(\"Could not load firmware %s.\\n\", priv->fname);\n\t\tpriv->state = XC2028_NODEV;\n\t\treturn;\n\t}\n\n\trc = load_all_firmwares(fe, fw);\n\n\trelease_firmware(fw);\n\n\tif (rc < 0)\n\t\treturn;\n\tpriv->state = XC2028_ACTIVE;\n}\n\nstatic int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tpriv->ctrl.fname = NULL;\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic const struct dvb_tuner_ops xc2028_dvb_tuner_ops = {\n\t.info = {\n\t\t .name = \"Xceive XC3028\",\n\t\t .frequency_min = 42000000,\n\t\t .frequency_max = 864000000,\n\t\t .frequency_step = 50000,\n\t\t },\n\n\t.set_config\t   = xc2028_set_config,\n\t.set_analog_params = xc2028_set_analog_freq,\n\t.release           = xc2028_dvb_release,\n\t.get_frequency     = xc2028_get_frequency,\n\t.get_rf_strength   = xc2028_signal,\n\t.get_afc           = xc2028_get_afc,\n\t.set_params        = xc2028_set_params,\n\t.sleep             = xc2028_sleep,\n};\n\nstruct dvb_frontend *xc2028_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct xc2028_config *cfg)\n{\n\tstruct xc2028_data *priv;\n\tint instance;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"xc2028: Xcv2028/3028 init called!\\n\");\n\n\tif (NULL == cfg)\n\t\treturn NULL;\n\n\tif (!fe) {\n\t\tprintk(KERN_ERR \"xc2028: No frontend!\\n\");\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&xc2028_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct xc2028_data, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      cfg->i2c_adap, cfg->i2c_addr,\n\t\t\t\t\t      \"xc2028\");\n\tswitch (instance) {\n\tcase 0:\n\t\t/* memory allocation failure */\n\t\tgoto fail;\n\tcase 1:\n\t\t/* new tuner instance */\n\t\tpriv->ctrl.max_len = 13;\n\n\t\tmutex_init(&priv->lock);\n\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\tcase 2:\n\t\t/* existing tuner instance */\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tmemcpy(&fe->ops.tuner_ops, &xc2028_dvb_tuner_ops,\n\t       sizeof(xc2028_dvb_tuner_ops));\n\n\ttuner_info(\"type set to %s\\n\", \"XCeive xc2028/xc3028 tuner\");\n\n\tif (cfg->ctrl)\n\t\txc2028_set_config(fe, cfg->ctrl);\n\n\tmutex_unlock(&xc2028_list_mutex);\n\n\treturn fe;\nfail:\n\tmutex_unlock(&xc2028_list_mutex);\n\n\txc2028_dvb_release(fe);\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(xc2028_attach);\n\nMODULE_DESCRIPTION(\"Xceive xc2028/xc3028 tuner driver\");\nMODULE_AUTHOR(\"Michel Ludwig <michel.ludwig@gmail.com>\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(XC2028_DEFAULT_FIRMWARE);\nMODULE_FIRMWARE(XC3028L_DEFAULT_FIRMWARE);\n"], "filenames": ["drivers/media/tuners/tuner-xc2028.c"], "buggy_code_start_loc": [1405], "buggy_code_end_loc": [1411], "fixing_code_start_loc": [1406], "fixing_code_end_loc": [1412], "type": "CWE-416", "message": "The xc2028_set_config function in drivers/media/tuners/tuner-xc2028.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) via vectors involving omission of the firmware name from a certain data structure.", "other": {"cve": {"id": "CVE-2016-7913", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:08.030", "lastModified": "2022-12-09T18:12:39.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The xc2028_set_config function in drivers/media/tuners/tuner-xc2028.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) via vectors involving omission of the firmware name from a certain data structure."}, {"lang": "es", "value": "La funci\u00f3n xc2028_set_config en drivers/media/tuners/tuner-xc2028.c en el kernel de Linux en versiones anteriores a 4.6 permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n de memoria) mediante vectores que implican la omisi\u00f3n del nombre de firmware de una determinada estructura de datos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.10.106", "matchCriteriaId": "B2CFCC64-F13E-4ED9-B677-090ED539576A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.70", "matchCriteriaId": "62D40056-DC08-4609-8FAB-B6D924994367"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.18.51", "matchCriteriaId": "F52F8D37-A451-49FF-AED2-53E3118F6789"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.41", "matchCriteriaId": "9019BEC9-FE77-4506-A019-B8B4D8BCEBAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.65", "matchCriteriaId": "68BF7913-3500-47F8-9563-A09C85A2BC6F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.6", "matchCriteriaId": "628AFDA5-6C82-4DB8-8280-D1D7C58BBFE7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8dfbcc4351a0b6d2f2d77f367552f48ffefafe18", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94201", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0676", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1062", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1170", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1190", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3798-1/", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3798-2/", "source": "security@android.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18"}}