{"buggy_code": ["/*\n** class.c - Class class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <stdarg.h>\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/data.h>\n#include <mruby/istruct.h>\n\nKHASH_DEFINE(mt, mrb_sym, mrb_method_t, TRUE, kh_int_hash_func, kh_int_hash_equal)\n\nvoid\nmrb_gc_mark_mt(mrb_state *mrb, struct RClass *c)\n{\n  khiter_t k;\n  khash_t(mt) *h = c->mt;\n\n  if (!h) return;\n  for (k = kh_begin(h); k != kh_end(h); k++) {\n    if (kh_exist(h, k)) {\n      mrb_method_t m = kh_value(h, k);\n\n      if (MRB_METHOD_PROC_P(m)) {\n        struct RProc *p = MRB_METHOD_PROC(m);\n        mrb_gc_mark(mrb, (struct RBasic*)p);\n      }\n    }\n  }\n}\n\nsize_t\nmrb_gc_mark_mt_size(mrb_state *mrb, struct RClass *c)\n{\n  khash_t(mt) *h = c->mt;\n\n  if (!h) return 0;\n  return kh_size(h);\n}\n\nvoid\nmrb_gc_free_mt(mrb_state *mrb, struct RClass *c)\n{\n  kh_destroy(mt, mrb, c->mt);\n}\n\nvoid\nmrb_class_name_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_value name;\n  mrb_sym nsym = mrb_intern_lit(mrb, \"__classname__\");\n\n  if (mrb_obj_iv_defined(mrb, (struct RObject*)c, nsym)) return;\n  if (outer == NULL || outer == mrb->object_class) {\n    name = mrb_symbol_value(id);\n  }\n  else {\n    name = mrb_class_path(mrb, outer);\n    if (mrb_nil_p(name)) {      /* unnamed outer class */\n      if (outer != mrb->object_class) {\n        mrb_obj_iv_set(mrb, (struct RObject*)c, mrb_intern_lit(mrb, \"__outer__\"),\n                       mrb_obj_value(outer));\n      }\n      return;\n    }\n    mrb_str_cat_cstr(mrb, name, \"::\");\n    mrb_str_cat_cstr(mrb, name, mrb_sym2name(mrb, id));\n  }\n  mrb_obj_iv_set(mrb, (struct RObject*)c, nsym, name);\n}\n\nstatic void\nsetup_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_class_name_class(mrb, outer, c, id);\n  mrb_obj_iv_set(mrb, (struct RObject*)outer, id, mrb_obj_value(c));\n}\n\n#define make_metaclass(mrb, c) prepare_singleton_class((mrb), (struct RBasic*)(c))\n\nstatic void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FLAG_IS_INHERITED;\n  sc->mt = kh_init(mt, mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, mrb_intern_lit(mrb, \"__attached__\"), mrb_obj_value(o));\n}\n\nstatic struct RClass*\nclass_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}\n\nstatic struct RClass*\nmodule_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_MODULE);\n  return mrb_class_ptr(c);\n}\n\nstatic mrb_bool\nclass_ptr_p(mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n  case MRB_TT_CLASS:\n  case MRB_TT_SCLASS:\n  case MRB_TT_MODULE:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ncheck_if_class_or_module(mrb_state *mrb, mrb_value obj)\n{\n  if (!class_ptr_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a class/module\", mrb_inspect(mrb, obj));\n  }\n}\n\nstatic struct RClass*\ndefine_module(mrb_state *mrb, mrb_sym name, struct RClass *outer)\n{\n  struct RClass *m;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    return module_from_sym(mrb, outer, name);\n  }\n  m = mrb_module_new(mrb);\n  setup_class(mrb, outer, m, name);\n\n  return m;\n}\n\nMRB_API struct RClass*\nmrb_define_module_id(mrb_state *mrb, mrb_sym name)\n{\n  return define_module(mrb, name, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_module(mrb_state *mrb, const char *name)\n{\n  return define_module(mrb, mrb_intern_cstr(mrb, name), mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_vm_define_module(mrb_state *mrb, mrb_value outer, mrb_sym id)\n{\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (mrb_type(old) != MRB_TT_MODULE) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a module\", mrb_inspect(mrb, old));\n    }\n    return mrb_class_ptr(old);\n  }\n  return define_module(mrb, id, mrb_class_ptr(outer));\n}\n\nMRB_API struct RClass*\nmrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c = define_module(mrb, id, outer);\n\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nstatic struct RClass*\nfind_origin(struct RClass *c)\n{\n  MRB_CLASS_ORIGIN(c);\n  return c;\n}\n\nstatic struct RClass*\ndefine_class(mrb_state *mrb, mrb_sym name, struct RClass *super, struct RClass *outer)\n{\n  struct RClass * c;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    c = class_from_sym(mrb, outer, name);\n    MRB_CLASS_ORIGIN(c);\n    if (super && mrb_class_real(c->super) != super) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for Class %S (%S not %S)\",\n                 mrb_sym2str(mrb, name),\n                 mrb_obj_value(c->super), mrb_obj_value(super));\n    }\n    return c;\n  }\n\n  c = mrb_class_new(mrb, super);\n  setup_class(mrb, outer, c, name);\n\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_id(mrb_state *mrb, mrb_sym name, struct RClass *super)\n{\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%S', Object assumed\", mrb_sym2str(mrb, name));\n  }\n  return define_class(mrb, name, super, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_class(mrb_state *mrb, const char *name, struct RClass *super)\n{\n  return mrb_define_class_id(mrb, mrb_intern_cstr(mrb, name), super);\n}\n\nstatic mrb_value mrb_bob_init(mrb_state *mrb, mrb_value);\n#ifdef MRB_METHOD_CACHE\nstatic void mc_clear_all(mrb_state *mrb);\nstatic void mc_clear_by_class(mrb_state *mrb, struct RClass*);\nstatic void mc_clear_by_id(mrb_state *mrb, struct RClass*, mrb_sym);\n#else\n#define mc_clear_all(mrb)\n#define mc_clear_by_class(mrb,c)\n#define mc_clear_by_id(mrb,c,s)\n#endif\n\nstatic void\nmrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FLAG_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mc_clear_by_class(mrb, klass);\n  mid = mrb_intern_lit(mrb, \"inherited\");\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_bob_init)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n\nMRB_API struct RClass*\nmrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (mrb_type(super) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%S given)\",\n                 mrb_inspect(mrb, super));\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (mrb_type(old) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a class\", mrb_inspect(mrb, old));\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %S\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n\nMRB_API mrb_bool\nmrb_class_defined(mrb_state *mrb, const char *name)\n{\n  mrb_value sym = mrb_check_intern_cstr(mrb, name);\n  if (mrb_nil_p(sym)) {\n    return FALSE;\n  }\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), mrb_symbol(sym));\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_value sym = mrb_check_intern_cstr(mrb, name);\n  if (mrb_nil_p(sym)) {\n    return FALSE;\n  }\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), mrb_symbol(sym));\n}\n\nMRB_API struct RClass*\nmrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_class_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_exc_get(mrb_state *mrb, const char *name)\n{\n  struct RClass *exc, *e;\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(mrb->object_class),\n                              mrb_intern_cstr(mrb, name));\n\n  if (mrb_type(c) != MRB_TT_CLASS) {\n    mrb_raise(mrb, mrb->eException_class, \"exception corrupted\");\n  }\n  exc = e = mrb_class_ptr(c);\n\n  while (e) {\n    if (e == mrb->eException_class)\n      return exc;\n    e = e->super;\n  }\n  return mrb->eException_class;\n}\n\nMRB_API struct RClass*\nmrb_module_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return module_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_module_get_under(mrb, mrb->object_class, name);\n}\n\n/*!\n * Defines a class under the namespace of \\a outer.\n * \\param outer  a class which contains the new class.\n * \\param id     name of the new class\n * \\param super  a class from which the new class will derive.\n *               NULL means \\c Object class.\n * \\return the created class\n * \\throw TypeError if the constant name \\a name is already taken but\n *                  the constant is not a \\c Class.\n * \\throw NameError if the class is already defined but the class can not\n *                  be reopened because its superclass is not \\a super.\n * \\post top-level constant named \\a name refers the returned class.\n *\n * \\note if a class named \\a name is already defined and its superclass is\n *       \\a super, the function just returns the defined class.\n */\nMRB_API struct RClass*\nmrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c;\n\n#if 0\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%S::%S', Object assumed\",\n             mrb_obj_value(outer), mrb_sym2str(mrb, id));\n  }\n#endif\n  c = define_class(mrb, id, super, outer);\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nMRB_API void\nmrb_define_method_raw(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_method_t m)\n{\n  khash_t(mt) *h;\n  khiter_t k;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (MRB_FROZEN_P(c)) {\n    if (c->tt == MRB_TT_MODULE)\n      mrb_raise(mrb, E_FROZEN_ERROR, \"can't modify frozen module\");\n    else\n      mrb_raise(mrb, E_FROZEN_ERROR, \"can't modify frozen class\");\n  }\n  if (!h) h = c->mt = kh_init(mt, mrb);\n  k = kh_put(mt, mrb, h, mid);\n  kh_value(h, k) = m;\n  if (MRB_METHOD_PROC_P(m) && !MRB_METHOD_UNDEF_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    p->flags |= MRB_PROC_SCOPE;\n    p->c = NULL;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)p);\n    if (!MRB_PROC_ENV_P(p)) {\n      MRB_PROC_SET_TARGET_CLASS(p, c);\n    }\n  }\n  mc_clear_by_id(mrb, c, mid);\n}\n\nMRB_API void\nmrb_define_method_id(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_method_t m;\n  int ai = mrb_gc_arena_save(mrb);\n\n  MRB_METHOD_FROM_FUNC(m, func);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_gc_arena_restore(mrb, ai);\n}\n\nMRB_API void\nmrb_define_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_method_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n/* a function to raise NotImplementedError with current method name */\nMRB_API void\nmrb_notimplement(mrb_state *mrb)\n{\n  const char *str;\n  mrb_int len;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  if (ci->mid) {\n    str = mrb_sym2name_len(mrb, ci->mid, &len);\n    mrb_raisef(mrb, E_NOTIMP_ERROR,\n      \"%S() function is unimplemented on this machine\",\n      mrb_str_new_static(mrb, str, (size_t)len));\n  }\n}\n\n/* a function to be replacement of unimplemented method */\nMRB_API mrb_value\nmrb_notimplement_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_notimplement(mrb);\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic mrb_value\ncheck_type(mrb_state *mrb, mrb_value val, enum mrb_vtype t, const char *c, const char *m)\n{\n  mrb_value tmp;\n\n  tmp = mrb_check_convert_type(mrb, val, t, c, m);\n  if (mrb_nil_p(tmp)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"expected %S\", mrb_str_new_cstr(mrb, c));\n  }\n  return tmp;\n}\n\nstatic mrb_value\nto_str(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_STRING, \"String\", \"to_str\");\n}\n\nstatic mrb_value\nto_ary(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_ARRAY, \"Array\", \"to_ary\");\n}\n\nstatic mrb_value\nto_hash(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_HASH, \"Hash\", \"to_hash\");\n}\n\nstatic mrb_sym\nto_sym(mrb_state *mrb, mrb_value ss)\n{\n  if (mrb_type(ss) == MRB_TT_SYMBOL) {\n    return mrb_symbol(ss);\n  }\n  else if (mrb_string_p(ss)) {\n    return mrb_intern_str(mrb, to_str(mrb, ss));\n  }\n  else {\n    mrb_value obj = mrb_funcall(mrb, ss, \"inspect\", 0);\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a symbol\", obj);\n    /* not reached */\n    return 0;\n  }\n}\n\nMRB_API mrb_int\nmrb_get_argc(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->argc;\n\n  if (argc < 0) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->stack[1]);\n\n    argc = ARY_LEN(a);\n  }\n  return argc;\n}\n\nMRB_API mrb_value*\nmrb_get_argv(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->argc;\n  mrb_value *array_argv;\n  if (argc < 0) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->stack[1]);\n\n    array_argv = ARY_PTR(a);\n  }\n  else {\n    array_argv = NULL;\n  }\n  return array_argv;\n}\n\n/*\n  retrieve arguments from mrb_state.\n\n  mrb_get_args(mrb, format, ...)\n\n  returns number of arguments parsed.\n\n  format specifiers:\n\n    string  mruby type     C type                 note\n    ----------------------------------------------------------------------------------------------\n    o:      Object         [mrb_value]\n    C:      class/module   [mrb_value]\n    S:      String         [mrb_value]            when ! follows, the value may be nil\n    A:      Array          [mrb_value]            when ! follows, the value may be nil\n    H:      Hash           [mrb_value]            when ! follows, the value may be nil\n    s:      String         [char*,mrb_int]        Receive two arguments; s! gives (NULL,0) for nil\n    z:      String         [char*]                NUL terminated string; z! gives NULL for nil\n    a:      Array          [mrb_value*,mrb_int]   Receive two arguments; a! gives (NULL,0) for nil\n    f:      Float          [mrb_float]\n    i:      Integer        [mrb_int]\n    b:      Boolean        [mrb_bool]\n    n:      Symbol         [mrb_sym]\n    d:      Data           [void*,mrb_data_type const] 2nd argument will be used to check data type so it won't be modified\n    I:      Inline struct  [void*]\n    &:      Block          [mrb_value]            &! raises exception if no block given\n    *:      rest argument  [mrb_value*,mrb_int]   The rest of the arguments as an array; *! avoid copy of the stack\n    |:      optional                              Following arguments are optional\n    ?:      optional given [mrb_bool]             true if preceding argument (optional) is given\n */\nMRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  const char *fmt = format;\n  char c;\n  mrb_int i = 0;\n  va_list ap;\n  mrb_int argc = mrb_get_argc(mrb);\n  mrb_int arg_i = 0;\n  mrb_value *array_argv = mrb_get_argv(mrb);\n  mrb_bool opt = FALSE;\n  mrb_bool opt_skip = TRUE;\n  mrb_bool given = TRUE;\n\n  va_start(ap, format);\n\n#define ARGV \\\n  (array_argv ? array_argv : (mrb->c->stack + 1))\n\n  while ((c = *fmt++)) {\n    switch (c) {\n    case '|':\n      opt = TRUE;\n      break;\n    case '*':\n      opt_skip = FALSE;\n      goto check_exit;\n    case '!':\n      break;\n    case '&': case '?':\n      if (opt) opt_skip = FALSE;\n      break;\n    default:\n      break;\n    }\n  }\n\n check_exit:\n  opt = FALSE;\n  i = 0;\n  while ((c = *format++)) {\n    switch (c) {\n    case '|': case '*': case '&': case '?':\n      break;\n    default:\n      if (argc <= i) {\n        if (opt) {\n          given = FALSE;\n        }\n        else {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          *p = ARGV[arg_i++];\n          i++;\n        }\n      }\n      break;\n    case 'C':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          if (!class_ptr_p(ss)) {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not class/module\", ss);\n          }\n          *p = ss;\n          i++;\n        }\n      }\n      break;\n    case 'S':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_str(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'A':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_ary(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_hash(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 's':\n      {\n        mrb_value ss;\n        char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, char**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = RSTRING_PTR(ss);\n          *pl = RSTRING_LEN(ss);\n          i++;\n        }\n      }\n      break;\n    case 'z':\n      {\n        mrb_value ss;\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = mrb_string_value_cstr(mrb, &ss);\n          i++;\n        }\n      }\n      break;\n    case 'a':\n      {\n        mrb_value aa;\n        struct RArray *a;\n        mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *pb = 0;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          aa = to_ary(mrb, ARGV[arg_i++]);\n          a = mrb_ary_ptr(aa);\n          *pb = ARY_PTR(a);\n          *pl = ARY_LEN(a);\n          i++;\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        mrb_value ss;\n\n        p = va_arg(ap, void**);\n        if (i < argc) {\n          ss = ARGV[arg_i];\n          if (mrb_type(ss) != MRB_TT_ISTRUCT)\n          {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not inline struct\", ss);\n          }\n          *p = mrb_istruct_ptr(ss);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n#ifndef MRB_WITHOUT_FLOAT\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (i < argc) {\n          *p = mrb_to_flo(mrb, ARGV[arg_i]);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n#endif\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (i < argc) {\n          switch (mrb_type(ARGV[arg_i])) {\n            case MRB_TT_FIXNUM:\n              *p = mrb_fixnum(ARGV[arg_i]);\n              break;\n#ifndef MRB_WITHOUT_FLOAT\n            case MRB_TT_FLOAT:\n              {\n                mrb_float f = mrb_float(ARGV[arg_i]);\n\n                if (!FIXABLE_FLOAT(f)) {\n                  mrb_raise(mrb, E_RANGE_ERROR, \"float too big for int\");\n                }\n                *p = (mrb_int)f;\n              }\n              break;\n#endif\n            case MRB_TT_STRING:\n              mrb_raise(mrb, E_TYPE_ERROR, \"no implicit conversion of String into Integer\");\n              break;\n            default:\n              *p = mrb_fixnum(mrb_Integer(mrb, ARGV[arg_i]));\n              break;\n          }\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (i < argc) {\n          mrb_value b = ARGV[arg_i++];\n          *boolp = mrb_test(b);\n          i++;\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          *symp = to_sym(mrb, ss);\n          i++;\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *datap = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *datap = mrb_data_get_ptr(mrb, ARGV[arg_i++], type);\n          ++i;\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        if (mrb->c->ci->argc < 0) {\n          bp = mrb->c->stack + 2;\n        }\n        else {\n          bp = mrb->c->stack + mrb->c->ci->argc + 1;\n        }\n        if (*format == '!') {\n          format ++;\n          if (mrb_nil_p(*bp)) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n          }\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      if (opt_skip && i == argc) return argc;\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = given;\n      }\n      break;\n\n    case '*':\n      {\n        mrb_value **var;\n        mrb_int *pl;\n        mrb_bool nocopy = array_argv ? TRUE : FALSE;\n\n        if (*format == '!') {\n          format++;\n          nocopy = TRUE;\n        }\n        var = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            if (nocopy) {\n              *var = ARGV+arg_i;\n            }\n            else {\n              mrb_value args = mrb_ary_new_from_values(mrb, *pl, ARGV+arg_i);\n              RARRAY(args)->c = NULL;\n              *var = RARRAY_PTR(args);\n            }\n          }\n          i = argc;\n          arg_i += *pl;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %S\", mrb_str_new(mrb, &c, 1));\n      break;\n    }\n  }\n\n#undef ARGV\n\n  if (!c && argc > i) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n  }\n  va_end(ap);\n  return i;\n}\n\nstatic struct RClass*\nboot_defclass(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  c = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_CLASS, mrb->class_class);\n  if (super) {\n    c->super = super;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)super);\n  }\n  else {\n    c->super = mrb->object_class;\n  }\n  c->mt = kh_init(mt, mrb);\n  return c;\n}\n\nstatic void\nboot_initmod(mrb_state *mrb, struct RClass *mod)\n{\n  if (!mod->mt) {\n    mod->mt = kh_init(mt, mrb);\n  }\n}\n\nstatic struct RClass*\ninclude_class_new(mrb_state *mrb, struct RClass *m, struct RClass *super)\n{\n  struct RClass *ic = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_ICLASS, mrb->class_class);\n  if (m->tt == MRB_TT_ICLASS) {\n    m = m->c;\n  }\n  MRB_CLASS_ORIGIN(m);\n  ic->iv = m->iv;\n  ic->mt = m->mt;\n  ic->super = super;\n  if (m->tt == MRB_TT_ICLASS) {\n    ic->c = m->c;\n  }\n  else {\n    ic->c = m;\n  }\n  return ic;\n}\n\nstatic int\ninclude_module_at(mrb_state *mrb, struct RClass *c, struct RClass *ins_pos, struct RClass *m, int search_super)\n{\n  struct RClass *p, *ic;\n  void *klass_mt = find_origin(c)->mt;\n\n  while (m) {\n    int superclass_seen = 0;\n\n    if (m->flags & MRB_FLAG_IS_PREPENDED)\n      goto skip;\n\n    if (klass_mt && klass_mt == m->mt)\n      return -1;\n\n    p = c->super;\n    while (p) {\n      if (p->tt == MRB_TT_ICLASS) {\n        if (p->mt == m->mt) {\n          if (!superclass_seen) {\n            ins_pos = p; /* move insert point */\n          }\n          goto skip;\n        }\n      } else if (p->tt == MRB_TT_CLASS) {\n        if (!search_super) break;\n        superclass_seen = 1;\n      }\n      p = p->super;\n    }\n\n    ic = include_class_new(mrb, m, ins_pos->super);\n    m->flags |= MRB_FLAG_IS_INHERITED;\n    ins_pos->super = ic;\n    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);\n    mc_clear_by_class(mrb, ins_pos);\n    ins_pos = ic;\n  skip:\n    m = m->super;\n  }\n  mc_clear_all(mrb);\n  return 0;\n}\n\nMRB_API void\nmrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  int changed = include_module_at(mrb, c, find_origin(c), m, 1);\n  if (changed < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n}\n\nMRB_API void\nmrb_prepend_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  struct RClass *origin;\n  int changed = 0;\n\n  if (!(c->flags & MRB_FLAG_IS_PREPENDED)) {\n    origin = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_ICLASS, c);\n    origin->flags |= MRB_FLAG_IS_ORIGIN | MRB_FLAG_IS_INHERITED;\n    origin->super = c->super;\n    c->super = origin;\n    origin->mt = c->mt;\n    c->mt = kh_init(mt, mrb);\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)origin);\n    c->flags |= MRB_FLAG_IS_PREPENDED;\n  }\n  changed = include_module_at(mrb, c, c, m, 0);\n  if (changed < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic prepend detected\");\n  }\n}\n\nstatic mrb_value\nmrb_mod_prepend_features(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value klass;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"C\", &klass);\n  mrb_prepend_module(mrb, mrb_class_ptr(klass), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_append_features(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value klass;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"C\", &klass);\n  mrb_include_module(mrb, mrb_class_ptr(klass), mrb_class_ptr(mod));\n  return mod;\n}\n\n/* 15.2.2.4.28 */\n/*\n *  call-seq:\n *     mod.include?(module)    -> true or false\n *\n *  Returns <code>true</code> if <i>module</i> is included in\n *  <i>mod</i> or one of <i>mod</i>'s ancestors.\n *\n *     module A\n *     end\n *     class B\n *       include A\n *     end\n *     class C < B\n *     end\n *     B.include?(A)   #=> true\n *     C.include?(A)   #=> true\n *     A.include?(A)   #=> false\n */\nstatic mrb_value\nmrb_mod_include_p(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value mod2;\n  struct RClass *c = mrb_class_ptr(mod);\n\n  mrb_get_args(mrb, \"C\", &mod2);\n  mrb_check_type(mrb, mod2, MRB_TT_MODULE);\n\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      if (c->c == mrb_class_ptr(mod2)) return mrb_true_value();\n    }\n    c = c->super;\n  }\n  return mrb_false_value();\n}\n\nstatic mrb_value\nmrb_mod_ancestors(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n    }\n    else if (!(c->flags & MRB_FLAG_IS_PREPENDED)) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c));\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_extend_object(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"o\", &obj);\n  mrb_include_module(mrb, mrb_class_ptr(mrb_singleton_class(mrb, obj)), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_included_modules(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  struct RClass *origin = c;\n\n  MRB_CLASS_ORIGIN(origin);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c != origin && c->tt == MRB_TT_ICLASS) {\n      if (c->c->tt == MRB_TT_MODULE) {\n        mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n      }\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_initialize(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value b;\n  struct RClass *m = mrb_class_ptr(mod);\n  boot_initmod(mrb, m); /* bootstrap a newly initialized module */\n  mrb_get_args(mrb, \"|&\", &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &mod, mod, m);\n  }\n  return mod;\n}\n\nmrb_value mrb_class_instance_method_list(mrb_state*, mrb_bool, struct RClass*, int);\n\n/* 15.2.2.4.33 */\n/*\n *  call-seq:\n *     mod.instance_methods(include_super=true)   -> array\n *\n *  Returns an array containing the names of the public and protected instance\n *  methods in the receiver. For a module, these are the public and protected methods;\n *  for a class, they are the instance (not singleton) methods. With no\n *  argument, or with an argument that is <code>false</code>, the\n *  instance methods in <i>mod</i> are returned, otherwise the methods\n *  in <i>mod</i> and <i>mod</i>'s superclasses are returned.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       def method3()  end\n *     end\n *\n *     A.instance_methods                #=> [:method1]\n *     B.instance_methods(false)         #=> [:method2]\n *     C.instance_methods(false)         #=> [:method3]\n *     C.instance_methods(true).length   #=> 43\n */\n\nstatic mrb_value\nmrb_mod_instance_methods(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_class_instance_method_list(mrb, recur, c, 0);\n}\n\n/* implementation of module_eval/class_eval */\nmrb_value mrb_mod_module_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\nmrb_mod_dummy_visibility(mrb_state *mrb, mrb_value mod)\n{\n  return mod;\n}\n\nMRB_API mrb_value\nmrb_singleton_class(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb_obj_value(mrb->nil_class);\n    return mrb_obj_value(mrb->false_class);\n  case MRB_TT_TRUE:\n    return mrb_obj_value(mrb->true_class);\n  case MRB_TT_CPTR:\n    return mrb_obj_value(mrb->object_class);\n  case MRB_TT_SYMBOL:\n  case MRB_TT_FIXNUM:\n#ifndef MRB_WITHOUT_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't define singleton\");\n    return mrb_nil_value();    /* not reached */\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  prepare_singleton_class(mrb, obj);\n  return mrb_obj_value(obj->c);\n}\n\nMRB_API void\nmrb_define_singleton_method(mrb_state *mrb, struct RObject *o, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_class_method(mrb, c, name, func, aspec);\n  mrb_define_method(mrb, c, name, func, aspec);\n}\n\n#ifdef MRB_METHOD_CACHE\nstatic void\nmc_clear_all(mrb_state *mrb)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mc[i].c = 0;\n  }\n}\n\nstatic void\nmc_clear_by_class(mrb_state *mrb, struct RClass *c)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FLAG_IS_INHERITED) {\n    mc_clear_all(mrb);\n    c->flags &= ~MRB_FLAG_IS_INHERITED;\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c) mc[i].c = 0;\n  }\n}\n\nstatic void\nmc_clear_by_id(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FLAG_IS_INHERITED) {\n    mc_clear_all(mrb);\n    c->flags &= ~MRB_FLAG_IS_INHERITED;\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c || mc[i].mid == mid)\n      mc[i].c = 0;\n  }\n}\n#endif\n\nMRB_API mrb_method_t\nmrb_method_search_vm(mrb_state *mrb, struct RClass **cp, mrb_sym mid)\n{\n  khiter_t k;\n  mrb_method_t m;\n  struct RClass *c = *cp;\n#ifdef MRB_METHOD_CACHE\n  struct RClass *oc = c;\n  int h = kh_int_hash_func(mrb, ((intptr_t)oc) ^ mid) & (MRB_METHOD_CACHE_SIZE-1);\n  struct mrb_cache_entry *mc = &mrb->cache[h];\n\n  if (mc->c == c && mc->mid == mid) {\n    *cp = mc->c0;\n    return mc->m;\n  }\n#endif\n\n  while (c) {\n    khash_t(mt) *h = c->mt;\n\n    if (h) {\n      k = kh_get(mt, mrb, h, mid);\n      if (k != kh_end(h)) {\n        m = kh_value(h, k);\n        if (MRB_METHOD_UNDEF_P(m)) break;\n        *cp = c;\n#ifdef MRB_METHOD_CACHE\n        mc->c = oc;\n        mc->c0 = c;\n        mc->mid = mid;\n        mc->m = m;\n#endif\n        return m;\n      }\n    }\n    c = c->super;\n  }\n  MRB_METHOD_FROM_PROC(m, NULL);\n  return m;                  /* no method */\n}\n\nMRB_API mrb_method_t\nmrb_method_search(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    mrb_value inspect = mrb_funcall(mrb, mrb_obj_value(c), \"inspect\", 0);\n    if (mrb_string_p(inspect) && RSTRING_LEN(inspect) > 64) {\n      inspect = mrb_any_to_s(mrb, mrb_obj_value(c));\n    }\n    mrb_name_error(mrb, mid, \"undefined method '%S' for class %S\",\n               mrb_sym2str(mrb, mid), inspect);\n  }\n  return m;\n}\n\nstatic mrb_value\nattr_reader(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  return mrb_iv_get(mrb, obj, to_sym(mrb, name));\n}\n\nstatic mrb_value\nmrb_mod_attr_reader(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name, str;\n    mrb_sym method, sym;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n    name = mrb_sym2str(mrb, method);\n    str = mrb_str_new_capa(mrb, RSTRING_LEN(name)+1);\n    mrb_str_cat_lit(mrb, str, \"@\");\n    mrb_str_cat_str(mrb, str, name);\n    sym = mrb_intern_str(mrb, str);\n    mrb_iv_check(mrb, sym);\n    name = mrb_symbol_value(sym);\n    p = mrb_proc_new_cfunc_with_env(mrb, attr_reader, 1, &name);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nattr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val;\n\n  mrb_get_args(mrb, \"o\", &val);\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_attr_writer(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name, str, attr;\n    mrb_sym method, sym;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n\n    /* prepare iv name (@name) */\n    name = mrb_sym2str(mrb, method);\n    str = mrb_str_new_capa(mrb, RSTRING_LEN(name)+1);\n    mrb_str_cat_lit(mrb, str, \"@\");\n    mrb_str_cat_str(mrb, str, name);\n    sym = mrb_intern_str(mrb, str);\n    mrb_iv_check(mrb, sym);\n    attr = mrb_symbol_value(sym);\n\n    /* prepare method name (name=) */\n    str = mrb_str_new_capa(mrb, RSTRING_LEN(str));\n    mrb_str_cat_str(mrb, str, name);\n    mrb_str_cat_lit(mrb, str, \"=\");\n    method = mrb_intern_str(mrb, str);\n\n    p = mrb_proc_new_cfunc_with_env(mrb, attr_writer, 1, &attr);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_instance_alloc(mrb_state *mrb, mrb_value cv)\n{\n  struct RClass *c = mrb_class_ptr(cv);\n  struct RObject *o;\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n\n  if (c->tt == MRB_TT_SCLASS)\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't create instance of singleton class\");\n\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  if (ttype <= MRB_TT_CPTR) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't create instance of %S\", cv);\n  }\n  o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);\n  return mrb_obj_value(o);\n}\n\n/*\n *  call-seq:\n *     class.new(args, ...)    ->  obj\n *\n *  Creates a new object of <i>class</i>'s class, then\n *  invokes that object's <code>initialize</code> method,\n *  passing it <i>args</i>. This is the method that ends\n *  up getting called whenever an object is constructed using\n *  `.new`.\n *\n */\n\nMRB_API mrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n  mrb_method_t m;\n\n  mrb_get_args(mrb, \"*&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = mrb_intern_lit(mrb, \"initialize\");\n  m = mrb_method_search(mrb, mrb_class(mrb, obj), init);\n  if (MRB_METHOD_CFUNC_P(m)) {\n    mrb_func_t f = MRB_METHOD_CFUNC(m);\n    if (f != mrb_bob_init) {\n      f(mrb, obj);\n    }\n  }\n  else {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_obj_new(mrb_state *mrb, struct RClass *c, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value obj;\n  mrb_sym mid;\n\n  obj = mrb_instance_alloc(mrb, mrb_obj_value(c));\n  mid = mrb_intern_lit(mrb, \"initialize\");\n  if (!mrb_func_basic_p(mrb, obj, mid, mrb_bob_init)) {\n    mrb_funcall_argv(mrb, obj, mid, argc, argv);\n  }\n  return obj;\n}\n\nstatic mrb_value\nmrb_class_initialize(mrb_state *mrb, mrb_value c)\n{\n  mrb_value a, b;\n\n  mrb_get_args(mrb, \"|C&\", &a, &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &c, c, mrb_class_ptr(c));\n  }\n  return c;\n}\n\nstatic mrb_value\nmrb_class_new_class(mrb_state *mrb, mrb_value cv)\n{\n  mrb_int n;\n  mrb_value super, blk;\n  mrb_value new_class;\n  mrb_sym mid;\n\n  n = mrb_get_args(mrb, \"|C&\", &super, &blk);\n  if (n == 0) {\n    super = mrb_obj_value(mrb->object_class);\n  }\n  new_class = mrb_obj_value(mrb_class_new(mrb, mrb_class_ptr(super)));\n  mid = mrb_intern_lit(mrb, \"initialize\");\n  if (!mrb_func_basic_p(mrb, new_class, mid, mrb_bob_init)) {\n    mrb_funcall_with_block(mrb, new_class, mid, n, &super, blk);\n  }\n  mrb_class_inherited(mrb, mrb_class_ptr(super), mrb_class_ptr(new_class));\n  return new_class;\n}\n\nstatic mrb_value\nmrb_class_superclass(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c;\n\n  c = mrb_class_ptr(klass);\n  c = find_origin(c)->super;\n  while (c && c->tt == MRB_TT_ICLASS) {\n    c = find_origin(c)->super;\n  }\n  if (!c) return mrb_nil_value();\n  return mrb_obj_value(c);\n}\n\nstatic mrb_value\nmrb_bob_init(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n\n/* 15.3.1.3.1  */\n/* 15.3.1.3.10 */\n/* 15.3.1.3.11 */\n/*\n *  call-seq:\n *     obj == other        -> true or false\n *     obj.equal?(other)   -> true or false\n *     obj.eql?(other)     -> true or false\n *\n *  Equality---At the <code>Object</code> level, <code>==</code> returns\n *  <code>true</code> only if <i>obj</i> and <i>other</i> are the\n *  same object. Typically, this method is overridden in descendant\n *  classes to provide class-specific meaning.\n *\n *  Unlike <code>==</code>, the <code>equal?</code> method should never be\n *  overridden by subclasses: it is used to determine object identity\n *  (that is, <code>a.equal?(b)</code> iff <code>a</code> is the same\n *  object as <code>b</code>).\n *\n *  The <code>eql?</code> method returns <code>true</code> if\n *  <i>obj</i> and <i>anObject</i> have the same value. Used by\n *  <code>Hash</code> to test members for equality.  For objects of\n *  class <code>Object</code>, <code>eql?</code> is synonymous with\n *  <code>==</code>. Subclasses normally continue this tradition, but\n *  there are exceptions. <code>Numeric</code> types, for example,\n *  perform type conversion across <code>==</code>, but not across\n *  <code>eql?</code>, so:\n *\n *     1 == 1.0     #=> true\n *     1.eql? 1.0   #=> false\n */\nmrb_value\nmrb_obj_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"o\", &arg);\n  return mrb_bool_value(mrb_obj_equal(mrb, self, arg));\n}\n\nstatic mrb_value\nmrb_obj_not_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"o\", &arg);\n  return mrb_bool_value(!mrb_equal(mrb, self, arg));\n}\n\nMRB_API mrb_bool\nmrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\nMRB_API mrb_bool\nmrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid)\n{\n  return mrb_obj_respond_to(mrb, mrb_class(mrb, obj), mid);\n}\n\nMRB_API mrb_value\nmrb_class_path(mrb_state *mrb, struct RClass *c)\n{\n  mrb_value path;\n  mrb_sym nsym = mrb_intern_lit(mrb, \"__classname__\");\n\n  path = mrb_obj_iv_get(mrb, (struct RObject*)c, nsym);\n  if (mrb_nil_p(path)) {\n    /* no name (yet) */\n    return mrb_class_find_path(mrb, c);\n  }\n  else if (mrb_symbol_p(path)) {\n    /* toplevel class/module */\n    const char *str;\n    mrb_int len;\n\n    str = mrb_sym2name_len(mrb, mrb_symbol(path), &len);\n    return mrb_str_new(mrb, str, len);\n  }\n  return mrb_str_dup(mrb, path);\n}\n\nMRB_API struct RClass*\nmrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}\n\nMRB_API const char*\nmrb_class_name(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value path = mrb_class_path(mrb, c);\n  if (mrb_nil_p(path)) {\n    path = mrb_str_new_lit(mrb, \"#<Class:\");\n    mrb_str_concat(mrb, path, mrb_ptr_to_str(mrb, c));\n    mrb_str_cat_lit(mrb, path, \">\");\n  }\n  return RSTRING_PTR(path);\n}\n\nMRB_API const char*\nmrb_obj_classname(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_name(mrb, mrb_obj_class(mrb, obj));\n}\n\n/*!\n * Ensures a class can be derived from super.\n *\n * \\param super a reference to an object.\n * \\exception TypeError if \\a super is not a Class or \\a super is a singleton class.\n */\nstatic void\nmrb_check_inheritable(mrb_state *mrb, struct RClass *super)\n{\n  if (super->tt != MRB_TT_CLASS) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%S given)\", mrb_obj_value(super));\n  }\n  if (super->tt == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of singleton class\");\n  }\n  if (super == mrb->class_class) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of Class\");\n  }\n}\n\n/*!\n * Creates a new class.\n * \\param super     a class from which the new class derives.\n * \\exception TypeError \\a super is not inheritable.\n * \\exception TypeError \\a super is the Class class.\n */\nMRB_API struct RClass*\nmrb_class_new(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  if (super) {\n    mrb_check_inheritable(mrb, super);\n  }\n  c = boot_defclass(mrb, super);\n  if (super) {\n    MRB_SET_INSTANCE_TT(c, MRB_INSTANCE_TT(super));\n  }\n  make_metaclass(mrb, c);\n\n  return c;\n}\n\n/*!\n * Creates a new module.\n */\nMRB_API struct RClass*\nmrb_module_new(mrb_state *mrb)\n{\n  struct RClass *m = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_MODULE, mrb->module_class);\n  boot_initmod(mrb, m);\n  return m;\n}\n\n/*\n *  call-seq:\n *     obj.class    => class\n *\n *  Returns the class of <i>obj</i>, now preferred over\n *  <code>Object#type</code>, as an object's type in Ruby is only\n *  loosely tied to that object's class. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Fixnum\n *     self.class   #=> Object\n */\n\nMRB_API struct RClass*\nmrb_obj_class(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_real(mrb_class(mrb, obj));\n}\n\nMRB_API void\nmrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\n/*!\n * Defines an alias of a method.\n * \\param klass  the class which the original method belongs to\n * \\param name1  a new name for the method\n * \\param name2  the original name of the method\n */\nMRB_API void\nmrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2)\n{\n  mrb_alias_method(mrb, klass, mrb_intern_cstr(mrb, name1), mrb_intern_cstr(mrb, name2));\n}\n\n/*\n * call-seq:\n *   mod.to_s   -> string\n *\n * Return a string representing this module or class. For basic\n * classes and modules, this is the name. For singletons, we\n * show information on the thing we're attached to as well.\n */\n\nstatic mrb_value\nmrb_mod_to_s(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value str;\n\n  if (mrb_type(klass) == MRB_TT_SCLASS) {\n    mrb_value v = mrb_iv_get(mrb, klass, mrb_intern_lit(mrb, \"__attached__\"));\n\n    str = mrb_str_new_lit(mrb, \"#<Class:\");\n\n    if (class_ptr_p(v)) {\n      mrb_str_cat_str(mrb, str, mrb_inspect(mrb, v));\n    }\n    else {\n      mrb_str_cat_str(mrb, str, mrb_any_to_s(mrb, v));\n    }\n    return mrb_str_cat_lit(mrb, str, \">\");\n  }\n  else {\n    struct RClass *c;\n    mrb_value path;\n\n    str = mrb_str_new_capa(mrb, 32);\n    c = mrb_class_ptr(klass);\n    path = mrb_class_path(mrb, c);\n\n    if (mrb_nil_p(path)) {\n      switch (mrb_type(klass)) {\n        case MRB_TT_CLASS:\n          mrb_str_cat_lit(mrb, str, \"#<Class:\");\n          break;\n\n        case MRB_TT_MODULE:\n          mrb_str_cat_lit(mrb, str, \"#<Module:\");\n          break;\n\n        default:\n          /* Shouldn't be happened? */\n          mrb_str_cat_lit(mrb, str, \"#<??????:\");\n          break;\n      }\n      mrb_str_concat(mrb, str, mrb_ptr_to_str(mrb, c));\n      return mrb_str_cat_lit(mrb, str, \">\");\n    }\n    else {\n      return path;\n    }\n  }\n}\n\nstatic mrb_value\nmrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  return mrb_nil_value();\n}\n\nstatic void\nundef_method(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  if (!mrb_obj_respond_to(mrb, c, a)) {\n    mrb_name_error(mrb, a, \"undefined method '%S' for class '%S'\", mrb_sym2str(mrb, a), mrb_obj_value(c));\n  }\n  else {\n    mrb_method_t m;\n\n    MRB_METHOD_FROM_PROC(m, NULL);\n    mrb_define_method_raw(mrb, c, a, m);\n  }\n}\n\nMRB_API void\nmrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API void\nmrb_undef_class_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  mrb_undef_method(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nstatic mrb_value\nmrb_mod_undef(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_int argc;\n  mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    undef_method(mrb, c, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmod_define_method(mrb_state *mrb, mrb_value self)\n{\n  struct RClass *c = mrb_class_ptr(self);\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %S (expected Proc)\", mrb_obj_value(mrb_obj_class(mrb, proc)));\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\ntop_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mod_define_method(mrb, mrb_obj_value(mrb->object_class));\n}\n\nstatic void\ncheck_cv_name_str(mrb_state *mrb, mrb_value str)\n{\n  const char *s = RSTRING_PTR(str);\n  mrb_int len = RSTRING_LEN(str);\n\n  if (len < 3 || !(s[0] == '@' && s[1] == '@')) {\n    mrb_name_error(mrb, mrb_intern_str(mrb, str), \"'%S' is not allowed as a class variable name\", str);\n  }\n}\n\nstatic void\ncheck_cv_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  check_cv_name_str(mrb, mrb_sym2str(mrb, id));\n}\n\n/* 15.2.2.4.16 */\n/*\n *  call-seq:\n *     obj.class_variable_defined?(symbol)    -> true or false\n *\n *  Returns <code>true</code> if the given class variable is defined\n *  in <i>obj</i>.\n *\n *     class Fred\n *       @@foo = 99\n *     end\n *     Fred.class_variable_defined?(:@@foo)    #=> true\n *     Fred.class_variable_defined?(:@@bar)    #=> false\n */\n\nstatic mrb_value\nmrb_mod_cvar_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_cv_name_sym(mrb, id);\n  return mrb_bool_value(mrb_cv_defined(mrb, mod, id));\n}\n\n/* 15.2.2.4.17 */\n/*\n *  call-seq:\n *     mod.class_variable_get(symbol)    -> obj\n *\n *  Returns the value of the given class variable (or throws a\n *  <code>NameError</code> exception). The <code>@@</code> part of the\n *  variable name should be included for regular class variables\n *\n *     class Fred\n *       @@foo = 99\n *     end\n *     Fred.class_variable_get(:@@foo)     #=> 99\n */\n\nstatic mrb_value\nmrb_mod_cvar_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_cv_name_sym(mrb, id);\n  return mrb_cv_get(mrb, mod, id);\n}\n\n/* 15.2.2.4.18 */\n/*\n *  call-seq:\n *     obj.class_variable_set(symbol, obj)    -> obj\n *\n *  Sets the class variable names by <i>symbol</i> to\n *  <i>object</i>.\n *\n *     class Fred\n *       @@foo = 99\n *       def foo\n *         @@foo\n *       end\n *     end\n *     Fred.class_variable_set(:@@foo, 101)     #=> 101\n *     Fred.new.foo                             #=> 101\n */\n\nstatic mrb_value\nmrb_mod_cvar_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value value;\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_cv_name_sym(mrb, id);\n  mrb_cv_set(mrb, mod, id, value);\n  return value;\n}\n\n/* 15.2.2.4.39 */\n/*\n *  call-seq:\n *     remove_class_variable(sym)    -> obj\n *\n *  Removes the definition of the <i>sym</i>, returning that\n *  constant's value.\n *\n *     class Dummy\n *       @@var = 99\n *       puts @@var\n *       p class_variables\n *       remove_class_variable(:@@var)\n *       p class_variables\n *     end\n *\n *  <em>produces:</em>\n *\n *     99\n *     [:@@var]\n *     []\n */\n\nstatic mrb_value\nmrb_mod_remove_cvar(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value val;\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_cv_name_sym(mrb, id);\n\n  val = mrb_iv_remove(mrb, mod, id);\n  if (!mrb_undef_p(val)) return val;\n\n  if (mrb_cv_defined(mrb, mod, id)) {\n    mrb_name_error(mrb, id, \"cannot remove %S for %S\",\n                   mrb_sym2str(mrb, id), mod);\n  }\n\n  mrb_name_error(mrb, id, \"class variable %S not defined for %S\",\n                 mrb_sym2str(mrb, id), mod);\n\n /* not reached */\n return mrb_nil_value();\n}\n\n/* 15.2.2.4.34 */\n/*\n *  call-seq:\n *     mod.method_defined?(symbol)    -> true or false\n *\n *  Returns +true+ if the named method is defined by\n *  _mod_ (or its included modules and, if _mod_ is a class,\n *  its ancestors). Public and protected methods are matched.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       include A\n *       def method3()  end\n *     end\n *\n *     A.method_defined? :method1    #=> true\n *     C.method_defined? \"method1\"   #=> true\n *     C.method_defined? \"method2\"   #=> true\n *     C.method_defined? \"method3\"   #=> true\n *     C.method_defined? \"method4\"   #=> false\n */\n\nstatic mrb_value\nmrb_mod_method_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  return mrb_bool_value(mrb_obj_respond_to(mrb, mrb_class_ptr(mod), id));\n}\n\nstatic void\nremove_method(mrb_state *mrb, mrb_value mod, mrb_sym mid)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  khash_t(mt) *h = find_origin(c)->mt;\n  khiter_t k;\n\n  if (h) {\n    k = kh_get(mt, mrb, h, mid);\n    if (k != kh_end(h)) {\n      kh_del(mt, mrb, h, k);\n      mrb_funcall(mrb, mod, \"method_removed\", 1, mrb_symbol_value(mid));\n      return;\n    }\n  }\n\n  mrb_name_error(mrb, mid, \"method '%S' not defined in %S\",\n    mrb_sym2str(mrb, mid), mod);\n}\n\n/* 15.2.2.4.41 */\n/*\n *  call-seq:\n *     remove_method(symbol)   -> self\n *\n *  Removes the method identified by _symbol_ from the current\n *  class. For an example, see <code>Module.undef_method</code>.\n */\n\nstatic mrb_value\nmrb_mod_remove_method(mrb_state *mrb, mrb_value mod)\n{\n  mrb_int argc;\n  mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    remove_method(mrb, mod, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mod;\n}\n\n\n\nstatic void\ncheck_const_name_str(mrb_state *mrb, mrb_value str)\n{\n  if (RSTRING_LEN(str) < 1 || !ISUPPER(*RSTRING_PTR(str))) {\n    mrb_name_error(mrb, mrb_intern_str(mrb, str), \"wrong constant name %S\", str);\n  }\n}\n\nstatic void\ncheck_const_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  check_const_name_str(mrb, mrb_sym2str(mrb, id));\n}\n\nstatic mrb_value\nconst_defined(mrb_state *mrb, mrb_value mod, mrb_sym id, mrb_bool inherit)\n{\n  if (inherit) {\n    return mrb_bool_value(mrb_const_defined(mrb, mod, id));\n  }\n  return mrb_bool_value(mrb_const_defined_at(mrb, mod, id));\n}\n\nstatic mrb_value\nmrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  return const_defined(mrb, mod, id, inherit);\n}\n\nstatic mrb_value\nmrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}\n\nstatic mrb_value\nmrb_mod_const_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value path;\n  mrb_sym id;\n  char *ptr;\n  mrb_int off, end, len;\n\n  mrb_get_args(mrb, \"o\", &path);\n\n  if (mrb_symbol_p(path)) {\n    /* const get with symbol */\n    id = mrb_symbol(path);\n    return mrb_const_get_sym(mrb, mod, id);\n  }\n\n  /* const get with class path string */\n  path = mrb_string_type(mrb, path);\n  ptr = RSTRING_PTR(path);\n  len = RSTRING_LEN(path);\n  off = 0;\n\n  while (off < len) {\n    end = mrb_str_index_lit(mrb, path, \"::\", off);\n    end = (end == -1) ? len : end;\n    id = mrb_intern(mrb, ptr+off, end-off);\n    mod = mrb_const_get_sym(mrb, mod, id);\n    off = (end == len) ? end : end+2;\n  }\n\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_const_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value value;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_const_name_sym(mrb, id);\n  mrb_const_set(mrb, mod, id, value);\n  return value;\n}\n\nstatic mrb_value\nmrb_mod_remove_const(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_const_name_sym(mrb, id);\n  val = mrb_iv_remove(mrb, mod, id);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, id, \"constant %S not defined\", mrb_sym2str(mrb, id));\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_const_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n\n  if (mrb_class_real(mrb_class_ptr(mod)) != mrb->object_class) {\n    mrb_name_error(mrb, sym, \"uninitialized constant %S::%S\",\n                   mod,\n                   mrb_sym2str(mrb, sym));\n  }\n  else {\n    mrb_name_error(mrb, sym, \"uninitialized constant %S\",\n                   mrb_sym2str(mrb, sym));\n  }\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_mod_s_constants(mrb_state *mrb, mrb_value mod)\n{\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"Module.constants not implemented\");\n  return mrb_nil_value();       /* not reached */\n}\n\nstatic mrb_value\nmrb_mod_eqq(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj;\n  mrb_bool eqq;\n\n  mrb_get_args(mrb, \"o\", &obj);\n  eqq = mrb_obj_is_kind_of(mrb, obj, mrb_class_ptr(mod));\n\n  return mrb_bool_value(eqq);\n}\n\nMRB_API mrb_value\nmrb_mod_module_function(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value *argv;\n  mrb_int argc, i;\n  mrb_sym mid;\n  mrb_method_t m;\n  struct RClass *rclass;\n  int ai;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  if (argc == 0) {\n    /* set MODFUNC SCOPE if implemented */\n    return mod;\n  }\n\n  /* set PRIVATE method visibility if implemented */\n  /* mrb_mod_dummy_visibility(mrb, mod); */\n\n  for (i=0; i<argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_SYMBOL);\n\n    mid = mrb_symbol(argv[i]);\n    rclass = mrb_class_ptr(mod);\n    m = mrb_method_search(mrb, rclass, mid);\n\n    prepare_singleton_class(mrb, (struct RBasic*)rclass);\n    ai = mrb_gc_arena_save(mrb);\n    mrb_define_method_raw(mrb, rclass->c, mid, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n\n  return mod;\n}\n\n/* implementation of __id__ */\nmrb_value mrb_obj_id_m(mrb_state *mrb, mrb_value self);\n/* implementation of instance_eval */\nmrb_value mrb_obj_instance_eval(mrb_state*, mrb_value);\n/* implementation of Module.nesting */\nmrb_value mrb_mod_s_nesting(mrb_state*, mrb_value);\n\nstatic mrb_value\ninspect_main(mrb_state *mrb, mrb_value mod)\n{\n  return mrb_str_new_lit(mrb, \"main\");\n}\n\nvoid\nmrb_init_class(mrb_state *mrb)\n{\n  struct RClass *bob;           /* BasicObject */\n  struct RClass *obj;           /* Object */\n  struct RClass *mod;           /* Module */\n  struct RClass *cls;           /* Class */\n\n  /* boot class hierarchy */\n  bob = boot_defclass(mrb, 0);\n  obj = boot_defclass(mrb, bob); mrb->object_class = obj;\n  mod = boot_defclass(mrb, obj); mrb->module_class = mod;/* obj -> mod */\n  cls = boot_defclass(mrb, mod); mrb->class_class = cls; /* obj -> cls */\n  /* fix-up loose ends */\n  bob->c = obj->c = mod->c = cls->c = cls;\n  make_metaclass(mrb, bob);\n  make_metaclass(mrb, obj);\n  make_metaclass(mrb, mod);\n  make_metaclass(mrb, cls);\n\n  /* name basic classes */\n  mrb_define_const(mrb, bob, \"BasicObject\", mrb_obj_value(bob));\n  mrb_define_const(mrb, obj, \"BasicObject\", mrb_obj_value(bob));\n  mrb_define_const(mrb, obj, \"Object\",      mrb_obj_value(obj));\n  mrb_define_const(mrb, obj, \"Module\",      mrb_obj_value(mod));\n  mrb_define_const(mrb, obj, \"Class\",       mrb_obj_value(cls));\n\n  /* name each classes */\n  mrb_class_name_class(mrb, NULL, bob, mrb_intern_lit(mrb, \"BasicObject\"));\n  mrb_class_name_class(mrb, NULL, obj, mrb_intern_lit(mrb, \"Object\")); /* 15.2.1 */\n  mrb_class_name_class(mrb, NULL, mod, mrb_intern_lit(mrb, \"Module\")); /* 15.2.2 */\n  mrb_class_name_class(mrb, NULL, cls, mrb_intern_lit(mrb, \"Class\"));  /* 15.2.3 */\n\n  mrb->proc_class = mrb_define_class(mrb, \"Proc\", mrb->object_class);  /* 15.2.17 */\n  MRB_SET_INSTANCE_TT(mrb->proc_class, MRB_TT_PROC);\n\n  MRB_SET_INSTANCE_TT(cls, MRB_TT_CLASS);\n  mrb_define_method(mrb, bob, \"initialize\",              mrb_bob_init,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"!\",                       mrb_bob_not,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"==\",                      mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.1  */\n  mrb_define_method(mrb, bob, \"!=\",                      mrb_obj_not_equal_m,      MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, bob, \"__id__\",                  mrb_obj_id_m,             MRB_ARGS_NONE()); /* 15.3.1.3.3  */\n  mrb_define_method(mrb, bob, \"__send__\",                mrb_f_send,               MRB_ARGS_ANY());  /* 15.3.1.3.4  */\n  mrb_define_method(mrb, bob, \"instance_eval\",           mrb_obj_instance_eval,    MRB_ARGS_ANY());  /* 15.3.1.3.18 */\n\n  mrb_define_class_method(mrb, cls, \"new\",               mrb_class_new_class,      MRB_ARGS_OPT(1));\n  mrb_define_method(mrb, cls, \"superclass\",              mrb_class_superclass,     MRB_ARGS_NONE()); /* 15.2.3.3.4 */\n  mrb_define_method(mrb, cls, \"new\",                     mrb_instance_new,         MRB_ARGS_ANY());  /* 15.2.3.3.3 */\n  mrb_define_method(mrb, cls, \"initialize\",              mrb_class_initialize,     MRB_ARGS_OPT(1)); /* 15.2.3.3.1 */\n  mrb_define_method(mrb, cls, \"inherited\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  MRB_SET_INSTANCE_TT(mod, MRB_TT_MODULE);\n  mrb_define_method(mrb, mod, \"class_variable_defined?\", mrb_mod_cvar_defined,     MRB_ARGS_REQ(1)); /* 15.2.2.4.16 */\n  mrb_define_method(mrb, mod, \"class_variable_get\",      mrb_mod_cvar_get,         MRB_ARGS_REQ(1)); /* 15.2.2.4.17 */\n  mrb_define_method(mrb, mod, \"class_variable_set\",      mrb_mod_cvar_set,         MRB_ARGS_REQ(2)); /* 15.2.2.4.18 */\n  mrb_define_method(mrb, mod, \"extend_object\",           mrb_mod_extend_object,    MRB_ARGS_REQ(1)); /* 15.2.2.4.25 */\n  mrb_define_method(mrb, mod, \"extended\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.26 */\n  mrb_define_method(mrb, mod, \"prepended\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"prepend_features\",        mrb_mod_prepend_features, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"include?\",                mrb_mod_include_p,        MRB_ARGS_REQ(1)); /* 15.2.2.4.28 */\n  mrb_define_method(mrb, mod, \"append_features\",         mrb_mod_append_features,  MRB_ARGS_REQ(1)); /* 15.2.2.4.10 */\n  mrb_define_method(mrb, mod, \"class_eval\",              mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.15 */\n  mrb_define_method(mrb, mod, \"included\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.29 */\n  mrb_define_method(mrb, mod, \"included_modules\",        mrb_mod_included_modules, MRB_ARGS_NONE()); /* 15.2.2.4.30 */\n  mrb_define_method(mrb, mod, \"initialize\",              mrb_mod_initialize,       MRB_ARGS_NONE()); /* 15.2.2.4.31 */\n  mrb_define_method(mrb, mod, \"instance_methods\",        mrb_mod_instance_methods, MRB_ARGS_ANY());  /* 15.2.2.4.33 */\n  mrb_define_method(mrb, mod, \"method_defined?\",         mrb_mod_method_defined,   MRB_ARGS_REQ(1)); /* 15.2.2.4.34 */\n  mrb_define_method(mrb, mod, \"module_eval\",             mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.35 */\n  mrb_define_method(mrb, mod, \"module_function\",         mrb_mod_module_function,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, mod, \"private\",                 mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.36 */\n  mrb_define_method(mrb, mod, \"protected\",               mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.37 */\n  mrb_define_method(mrb, mod, \"public\",                  mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.38 */\n  mrb_define_method(mrb, mod, \"remove_class_variable\",   mrb_mod_remove_cvar,      MRB_ARGS_REQ(1)); /* 15.2.2.4.39 */\n  mrb_define_method(mrb, mod, \"remove_method\",           mrb_mod_remove_method,    MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"method_removed\",          mrb_bob_init,             MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"attr_reader\",             mrb_mod_attr_reader,      MRB_ARGS_ANY());  /* 15.2.2.4.13 */\n  mrb_define_method(mrb, mod, \"attr_writer\",             mrb_mod_attr_writer,      MRB_ARGS_ANY());  /* 15.2.2.4.14 */\n  mrb_define_method(mrb, mod, \"to_s\",                    mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"inspect\",                 mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"alias_method\",            mrb_mod_alias,            MRB_ARGS_ANY());  /* 15.2.2.4.8 */\n  mrb_define_method(mrb, mod, \"ancestors\",               mrb_mod_ancestors,        MRB_ARGS_NONE()); /* 15.2.2.4.9 */\n  mrb_define_method(mrb, mod, \"undef_method\",            mrb_mod_undef,            MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"const_defined?\",          mrb_mod_const_defined,    MRB_ARGS_ARG(1,1)); /* 15.2.2.4.20 */\n  mrb_define_method(mrb, mod, \"const_get\",               mrb_mod_const_get,        MRB_ARGS_REQ(1)); /* 15.2.2.4.21 */\n  mrb_define_method(mrb, mod, \"const_set\",               mrb_mod_const_set,        MRB_ARGS_REQ(2)); /* 15.2.2.4.23 */\n  mrb_define_method(mrb, mod, \"constants\",               mrb_mod_constants,        MRB_ARGS_OPT(1)); /* 15.2.2.4.24 */\n  mrb_define_method(mrb, mod, \"remove_const\",            mrb_mod_remove_const,     MRB_ARGS_REQ(1)); /* 15.2.2.4.40 */\n  mrb_define_method(mrb, mod, \"const_missing\",           mrb_mod_const_missing,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"define_method\",           mod_define_method,        MRB_ARGS_ARG(1,1));\n  mrb_define_method(mrb, mod, \"class_variables\",         mrb_mod_class_variables,  MRB_ARGS_NONE()); /* 15.2.2.4.19 */\n  mrb_define_method(mrb, mod, \"===\",                     mrb_mod_eqq,              MRB_ARGS_REQ(1));\n  mrb_define_class_method(mrb, mod, \"constants\",         mrb_mod_s_constants,      MRB_ARGS_ANY());  /* 15.2.2.3.1 */\n  mrb_define_class_method(mrb, mod, \"nesting\",           mrb_mod_s_nesting,        MRB_ARGS_REQ(0)); /* 15.2.2.3.2 */\n\n  mrb_undef_method(mrb, cls, \"append_features\");\n  mrb_undef_method(mrb, cls, \"extend_object\");\n\n  mrb->top_self = (struct RObject*)mrb_obj_alloc(mrb, MRB_TT_OBJECT, mrb->object_class);\n  mrb_define_singleton_method(mrb, mrb->top_self, \"inspect\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"to_s\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"define_method\", top_define_method, MRB_ARGS_ARG(1,1));\n}\n"], "fixing_code": ["/*\n** class.c - Class class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <stdarg.h>\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/data.h>\n#include <mruby/istruct.h>\n\nKHASH_DEFINE(mt, mrb_sym, mrb_method_t, TRUE, kh_int_hash_func, kh_int_hash_equal)\n\nvoid\nmrb_gc_mark_mt(mrb_state *mrb, struct RClass *c)\n{\n  khiter_t k;\n  khash_t(mt) *h = c->mt;\n\n  if (!h) return;\n  for (k = kh_begin(h); k != kh_end(h); k++) {\n    if (kh_exist(h, k)) {\n      mrb_method_t m = kh_value(h, k);\n\n      if (MRB_METHOD_PROC_P(m)) {\n        struct RProc *p = MRB_METHOD_PROC(m);\n        mrb_gc_mark(mrb, (struct RBasic*)p);\n      }\n    }\n  }\n}\n\nsize_t\nmrb_gc_mark_mt_size(mrb_state *mrb, struct RClass *c)\n{\n  khash_t(mt) *h = c->mt;\n\n  if (!h) return 0;\n  return kh_size(h);\n}\n\nvoid\nmrb_gc_free_mt(mrb_state *mrb, struct RClass *c)\n{\n  kh_destroy(mt, mrb, c->mt);\n}\n\nvoid\nmrb_class_name_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_value name;\n  mrb_sym nsym = mrb_intern_lit(mrb, \"__classname__\");\n\n  if (mrb_obj_iv_defined(mrb, (struct RObject*)c, nsym)) return;\n  if (outer == NULL || outer == mrb->object_class) {\n    name = mrb_symbol_value(id);\n  }\n  else {\n    name = mrb_class_path(mrb, outer);\n    if (mrb_nil_p(name)) {      /* unnamed outer class */\n      if (outer != mrb->object_class) {\n        mrb_obj_iv_set(mrb, (struct RObject*)c, mrb_intern_lit(mrb, \"__outer__\"),\n                       mrb_obj_value(outer));\n      }\n      return;\n    }\n    mrb_str_cat_cstr(mrb, name, \"::\");\n    mrb_str_cat_cstr(mrb, name, mrb_sym2name(mrb, id));\n  }\n  mrb_obj_iv_set(mrb, (struct RObject*)c, nsym, name);\n}\n\nstatic void\nsetup_class(mrb_state *mrb, struct RClass *outer, struct RClass *c, mrb_sym id)\n{\n  mrb_class_name_class(mrb, outer, c, id);\n  mrb_obj_iv_set(mrb, (struct RObject*)outer, id, mrb_obj_value(c));\n}\n\n#define make_metaclass(mrb, c) prepare_singleton_class((mrb), (struct RBasic*)(c))\n\nstatic void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FLAG_IS_INHERITED;\n  sc->mt = kh_init(mt, mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, mrb_intern_lit(mrb, \"__attached__\"), mrb_obj_value(o));\n}\n\nstatic struct RClass*\nclass_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_CLASS);\n  return mrb_class_ptr(c);\n}\n\nstatic struct RClass*\nmodule_from_sym(mrb_state *mrb, struct RClass *klass, mrb_sym id)\n{\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(klass), id);\n\n  mrb_check_type(mrb, c, MRB_TT_MODULE);\n  return mrb_class_ptr(c);\n}\n\nstatic mrb_bool\nclass_ptr_p(mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n  case MRB_TT_CLASS:\n  case MRB_TT_SCLASS:\n  case MRB_TT_MODULE:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ncheck_if_class_or_module(mrb_state *mrb, mrb_value obj)\n{\n  if (!class_ptr_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a class/module\", mrb_inspect(mrb, obj));\n  }\n}\n\nstatic struct RClass*\ndefine_module(mrb_state *mrb, mrb_sym name, struct RClass *outer)\n{\n  struct RClass *m;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    return module_from_sym(mrb, outer, name);\n  }\n  m = mrb_module_new(mrb);\n  setup_class(mrb, outer, m, name);\n\n  return m;\n}\n\nMRB_API struct RClass*\nmrb_define_module_id(mrb_state *mrb, mrb_sym name)\n{\n  return define_module(mrb, name, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_module(mrb_state *mrb, const char *name)\n{\n  return define_module(mrb, mrb_intern_cstr(mrb, name), mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_vm_define_module(mrb_state *mrb, mrb_value outer, mrb_sym id)\n{\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (mrb_type(old) != MRB_TT_MODULE) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a module\", mrb_inspect(mrb, old));\n    }\n    return mrb_class_ptr(old);\n  }\n  return define_module(mrb, id, mrb_class_ptr(outer));\n}\n\nMRB_API struct RClass*\nmrb_define_module_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c = define_module(mrb, id, outer);\n\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nstatic struct RClass*\nfind_origin(struct RClass *c)\n{\n  MRB_CLASS_ORIGIN(c);\n  return c;\n}\n\nstatic struct RClass*\ndefine_class(mrb_state *mrb, mrb_sym name, struct RClass *super, struct RClass *outer)\n{\n  struct RClass * c;\n\n  if (mrb_const_defined_at(mrb, mrb_obj_value(outer), name)) {\n    c = class_from_sym(mrb, outer, name);\n    MRB_CLASS_ORIGIN(c);\n    if (super && mrb_class_real(c->super) != super) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for Class %S (%S not %S)\",\n                 mrb_sym2str(mrb, name),\n                 mrb_obj_value(c->super), mrb_obj_value(super));\n    }\n    return c;\n  }\n\n  c = mrb_class_new(mrb, super);\n  setup_class(mrb, outer, c, name);\n\n  return c;\n}\n\nMRB_API struct RClass*\nmrb_define_class_id(mrb_state *mrb, mrb_sym name, struct RClass *super)\n{\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%S', Object assumed\", mrb_sym2str(mrb, name));\n  }\n  return define_class(mrb, name, super, mrb->object_class);\n}\n\nMRB_API struct RClass*\nmrb_define_class(mrb_state *mrb, const char *name, struct RClass *super)\n{\n  return mrb_define_class_id(mrb, mrb_intern_cstr(mrb, name), super);\n}\n\nstatic mrb_value mrb_bob_init(mrb_state *mrb, mrb_value);\n#ifdef MRB_METHOD_CACHE\nstatic void mc_clear_all(mrb_state *mrb);\nstatic void mc_clear_by_class(mrb_state *mrb, struct RClass*);\nstatic void mc_clear_by_id(mrb_state *mrb, struct RClass*, mrb_sym);\n#else\n#define mc_clear_all(mrb)\n#define mc_clear_by_class(mrb,c)\n#define mc_clear_by_id(mrb,c,s)\n#endif\n\nstatic void\nmrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FLAG_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mc_clear_by_class(mrb, klass);\n  mid = mrb_intern_lit(mrb, \"inherited\");\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_bob_init)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n\nMRB_API struct RClass*\nmrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (mrb_type(super) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%S given)\",\n                 mrb_inspect(mrb, super));\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (mrb_type(old) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a class\", mrb_inspect(mrb, old));\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %S\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n\nMRB_API mrb_bool\nmrb_class_defined(mrb_state *mrb, const char *name)\n{\n  mrb_value sym = mrb_check_intern_cstr(mrb, name);\n  if (mrb_nil_p(sym)) {\n    return FALSE;\n  }\n  return mrb_const_defined(mrb, mrb_obj_value(mrb->object_class), mrb_symbol(sym));\n}\n\nMRB_API mrb_bool\nmrb_class_defined_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  mrb_value sym = mrb_check_intern_cstr(mrb, name);\n  if (mrb_nil_p(sym)) {\n    return FALSE;\n  }\n  return mrb_const_defined_at(mrb, mrb_obj_value(outer), mrb_symbol(sym));\n}\n\nMRB_API struct RClass*\nmrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_class_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get_under(mrb, mrb->object_class, name);\n}\n\nMRB_API struct RClass*\nmrb_exc_get(mrb_state *mrb, const char *name)\n{\n  struct RClass *exc, *e;\n  mrb_value c = mrb_const_get(mrb, mrb_obj_value(mrb->object_class),\n                              mrb_intern_cstr(mrb, name));\n\n  if (mrb_type(c) != MRB_TT_CLASS) {\n    mrb_raise(mrb, mrb->eException_class, \"exception corrupted\");\n  }\n  exc = e = mrb_class_ptr(c);\n\n  while (e) {\n    if (e == mrb->eException_class)\n      return exc;\n    e = e->super;\n  }\n  return mrb->eException_class;\n}\n\nMRB_API struct RClass*\nmrb_module_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return module_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API struct RClass*\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_module_get_under(mrb, mrb->object_class, name);\n}\n\n/*!\n * Defines a class under the namespace of \\a outer.\n * \\param outer  a class which contains the new class.\n * \\param id     name of the new class\n * \\param super  a class from which the new class will derive.\n *               NULL means \\c Object class.\n * \\return the created class\n * \\throw TypeError if the constant name \\a name is already taken but\n *                  the constant is not a \\c Class.\n * \\throw NameError if the class is already defined but the class can not\n *                  be reopened because its superclass is not \\a super.\n * \\post top-level constant named \\a name refers the returned class.\n *\n * \\note if a class named \\a name is already defined and its superclass is\n *       \\a super, the function just returns the defined class.\n */\nMRB_API struct RClass*\nmrb_define_class_under(mrb_state *mrb, struct RClass *outer, const char *name, struct RClass *super)\n{\n  mrb_sym id = mrb_intern_cstr(mrb, name);\n  struct RClass * c;\n\n#if 0\n  if (!super) {\n    mrb_warn(mrb, \"no super class for '%S::%S', Object assumed\",\n             mrb_obj_value(outer), mrb_sym2str(mrb, id));\n  }\n#endif\n  c = define_class(mrb, id, super, outer);\n  setup_class(mrb, outer, c, id);\n  return c;\n}\n\nMRB_API void\nmrb_define_method_raw(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_method_t m)\n{\n  khash_t(mt) *h;\n  khiter_t k;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (MRB_FROZEN_P(c)) {\n    if (c->tt == MRB_TT_MODULE)\n      mrb_raise(mrb, E_FROZEN_ERROR, \"can't modify frozen module\");\n    else\n      mrb_raise(mrb, E_FROZEN_ERROR, \"can't modify frozen class\");\n  }\n  if (!h) h = c->mt = kh_init(mt, mrb);\n  k = kh_put(mt, mrb, h, mid);\n  kh_value(h, k) = m;\n  if (MRB_METHOD_PROC_P(m) && !MRB_METHOD_UNDEF_P(m)) {\n    struct RProc *p = MRB_METHOD_PROC(m);\n\n    p->flags |= MRB_PROC_SCOPE;\n    p->c = NULL;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)p);\n    if (!MRB_PROC_ENV_P(p)) {\n      MRB_PROC_SET_TARGET_CLASS(p, c);\n    }\n  }\n  mc_clear_by_id(mrb, c, mid);\n}\n\nMRB_API void\nmrb_define_method_id(mrb_state *mrb, struct RClass *c, mrb_sym mid, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_method_t m;\n  int ai = mrb_gc_arena_save(mrb);\n\n  MRB_METHOD_FROM_FUNC(m, func);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_gc_arena_restore(mrb, ai);\n}\n\nMRB_API void\nmrb_define_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_method_id(mrb, c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\n/* a function to raise NotImplementedError with current method name */\nMRB_API void\nmrb_notimplement(mrb_state *mrb)\n{\n  const char *str;\n  mrb_int len;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  if (ci->mid) {\n    str = mrb_sym2name_len(mrb, ci->mid, &len);\n    mrb_raisef(mrb, E_NOTIMP_ERROR,\n      \"%S() function is unimplemented on this machine\",\n      mrb_str_new_static(mrb, str, (size_t)len));\n  }\n}\n\n/* a function to be replacement of unimplemented method */\nMRB_API mrb_value\nmrb_notimplement_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_notimplement(mrb);\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic mrb_value\ncheck_type(mrb_state *mrb, mrb_value val, enum mrb_vtype t, const char *c, const char *m)\n{\n  mrb_value tmp;\n\n  tmp = mrb_check_convert_type(mrb, val, t, c, m);\n  if (mrb_nil_p(tmp)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"expected %S\", mrb_str_new_cstr(mrb, c));\n  }\n  return tmp;\n}\n\nstatic mrb_value\nto_str(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_STRING, \"String\", \"to_str\");\n}\n\nstatic mrb_value\nto_ary(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_ARRAY, \"Array\", \"to_ary\");\n}\n\nstatic mrb_value\nto_hash(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_HASH, \"Hash\", \"to_hash\");\n}\n\nstatic mrb_sym\nto_sym(mrb_state *mrb, mrb_value ss)\n{\n  if (mrb_type(ss) == MRB_TT_SYMBOL) {\n    return mrb_symbol(ss);\n  }\n  else if (mrb_string_p(ss)) {\n    return mrb_intern_str(mrb, to_str(mrb, ss));\n  }\n  else {\n    mrb_value obj = mrb_funcall(mrb, ss, \"inspect\", 0);\n    mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a symbol\", obj);\n    /* not reached */\n    return 0;\n  }\n}\n\nMRB_API mrb_int\nmrb_get_argc(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->argc;\n\n  if (argc < 0) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->stack[1]);\n\n    argc = ARY_LEN(a);\n  }\n  return argc;\n}\n\nMRB_API mrb_value*\nmrb_get_argv(mrb_state *mrb)\n{\n  mrb_int argc = mrb->c->ci->argc;\n  mrb_value *array_argv;\n  if (argc < 0) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->stack[1]);\n\n    array_argv = ARY_PTR(a);\n  }\n  else {\n    array_argv = NULL;\n  }\n  return array_argv;\n}\n\n/*\n  retrieve arguments from mrb_state.\n\n  mrb_get_args(mrb, format, ...)\n\n  returns number of arguments parsed.\n\n  format specifiers:\n\n    string  mruby type     C type                 note\n    ----------------------------------------------------------------------------------------------\n    o:      Object         [mrb_value]\n    C:      class/module   [mrb_value]\n    S:      String         [mrb_value]            when ! follows, the value may be nil\n    A:      Array          [mrb_value]            when ! follows, the value may be nil\n    H:      Hash           [mrb_value]            when ! follows, the value may be nil\n    s:      String         [char*,mrb_int]        Receive two arguments; s! gives (NULL,0) for nil\n    z:      String         [char*]                NUL terminated string; z! gives NULL for nil\n    a:      Array          [mrb_value*,mrb_int]   Receive two arguments; a! gives (NULL,0) for nil\n    f:      Float          [mrb_float]\n    i:      Integer        [mrb_int]\n    b:      Boolean        [mrb_bool]\n    n:      Symbol         [mrb_sym]\n    d:      Data           [void*,mrb_data_type const] 2nd argument will be used to check data type so it won't be modified\n    I:      Inline struct  [void*]\n    &:      Block          [mrb_value]            &! raises exception if no block given\n    *:      rest argument  [mrb_value*,mrb_int]   The rest of the arguments as an array; *! avoid copy of the stack\n    |:      optional                              Following arguments are optional\n    ?:      optional given [mrb_bool]             true if preceding argument (optional) is given\n */\nMRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  const char *fmt = format;\n  char c;\n  mrb_int i = 0;\n  va_list ap;\n  mrb_int argc = mrb_get_argc(mrb);\n  mrb_int arg_i = 0;\n  mrb_value *array_argv = mrb_get_argv(mrb);\n  mrb_bool opt = FALSE;\n  mrb_bool opt_skip = TRUE;\n  mrb_bool given = TRUE;\n\n  va_start(ap, format);\n\n#define ARGV \\\n  (array_argv ? array_argv : (mrb->c->stack + 1))\n\n  while ((c = *fmt++)) {\n    switch (c) {\n    case '|':\n      opt = TRUE;\n      break;\n    case '*':\n      opt_skip = FALSE;\n      goto check_exit;\n    case '!':\n      break;\n    case '&': case '?':\n      if (opt) opt_skip = FALSE;\n      break;\n    default:\n      break;\n    }\n  }\n\n check_exit:\n  opt = FALSE;\n  i = 0;\n  while ((c = *format++)) {\n    switch (c) {\n    case '|': case '*': case '&': case '?':\n      break;\n    default:\n      if (argc <= i) {\n        if (opt) {\n          given = FALSE;\n        }\n        else {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          *p = ARGV[arg_i++];\n          i++;\n        }\n      }\n      break;\n    case 'C':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          if (!class_ptr_p(ss)) {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not class/module\", ss);\n          }\n          *p = ss;\n          i++;\n        }\n      }\n      break;\n    case 'S':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_str(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'A':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_ary(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_hash(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 's':\n      {\n        mrb_value ss;\n        char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, char**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = RSTRING_PTR(ss);\n          *pl = RSTRING_LEN(ss);\n          i++;\n        }\n      }\n      break;\n    case 'z':\n      {\n        mrb_value ss;\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = mrb_string_value_cstr(mrb, &ss);\n          i++;\n        }\n      }\n      break;\n    case 'a':\n      {\n        mrb_value aa;\n        struct RArray *a;\n        mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *pb = 0;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          aa = to_ary(mrb, ARGV[arg_i++]);\n          a = mrb_ary_ptr(aa);\n          *pb = ARY_PTR(a);\n          *pl = ARY_LEN(a);\n          i++;\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        mrb_value ss;\n\n        p = va_arg(ap, void**);\n        if (i < argc) {\n          ss = ARGV[arg_i];\n          if (mrb_type(ss) != MRB_TT_ISTRUCT)\n          {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not inline struct\", ss);\n          }\n          *p = mrb_istruct_ptr(ss);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n#ifndef MRB_WITHOUT_FLOAT\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (i < argc) {\n          *p = mrb_to_flo(mrb, ARGV[arg_i]);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n#endif\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (i < argc) {\n          switch (mrb_type(ARGV[arg_i])) {\n            case MRB_TT_FIXNUM:\n              *p = mrb_fixnum(ARGV[arg_i]);\n              break;\n#ifndef MRB_WITHOUT_FLOAT\n            case MRB_TT_FLOAT:\n              {\n                mrb_float f = mrb_float(ARGV[arg_i]);\n\n                if (!FIXABLE_FLOAT(f)) {\n                  mrb_raise(mrb, E_RANGE_ERROR, \"float too big for int\");\n                }\n                *p = (mrb_int)f;\n              }\n              break;\n#endif\n            case MRB_TT_STRING:\n              mrb_raise(mrb, E_TYPE_ERROR, \"no implicit conversion of String into Integer\");\n              break;\n            default:\n              *p = mrb_fixnum(mrb_Integer(mrb, ARGV[arg_i]));\n              break;\n          }\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (i < argc) {\n          mrb_value b = ARGV[arg_i++];\n          *boolp = mrb_test(b);\n          i++;\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          *symp = to_sym(mrb, ss);\n          i++;\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *datap = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *datap = mrb_data_get_ptr(mrb, ARGV[arg_i++], type);\n          ++i;\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        if (mrb->c->ci->argc < 0) {\n          bp = mrb->c->stack + 2;\n        }\n        else {\n          bp = mrb->c->stack + mrb->c->ci->argc + 1;\n        }\n        if (*format == '!') {\n          format ++;\n          if (mrb_nil_p(*bp)) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n          }\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      if (opt_skip && i == argc) return argc;\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = given;\n      }\n      break;\n\n    case '*':\n      {\n        mrb_value **var;\n        mrb_int *pl;\n        mrb_bool nocopy = array_argv ? TRUE : FALSE;\n\n        if (*format == '!') {\n          format++;\n          nocopy = TRUE;\n        }\n        var = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            if (nocopy) {\n              *var = ARGV+arg_i;\n            }\n            else {\n              mrb_value args = mrb_ary_new_from_values(mrb, *pl, ARGV+arg_i);\n              RARRAY(args)->c = NULL;\n              *var = RARRAY_PTR(args);\n            }\n          }\n          i = argc;\n          arg_i += *pl;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %S\", mrb_str_new(mrb, &c, 1));\n      break;\n    }\n  }\n\n#undef ARGV\n\n  if (!c && argc > i) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n  }\n  va_end(ap);\n  return i;\n}\n\nstatic struct RClass*\nboot_defclass(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  c = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_CLASS, mrb->class_class);\n  if (super) {\n    c->super = super;\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)super);\n  }\n  else {\n    c->super = mrb->object_class;\n  }\n  c->mt = kh_init(mt, mrb);\n  return c;\n}\n\nstatic void\nboot_initmod(mrb_state *mrb, struct RClass *mod)\n{\n  if (!mod->mt) {\n    mod->mt = kh_init(mt, mrb);\n  }\n}\n\nstatic struct RClass*\ninclude_class_new(mrb_state *mrb, struct RClass *m, struct RClass *super)\n{\n  struct RClass *ic = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_ICLASS, mrb->class_class);\n  if (m->tt == MRB_TT_ICLASS) {\n    m = m->c;\n  }\n  MRB_CLASS_ORIGIN(m);\n  ic->iv = m->iv;\n  ic->mt = m->mt;\n  ic->super = super;\n  if (m->tt == MRB_TT_ICLASS) {\n    ic->c = m->c;\n  }\n  else {\n    ic->c = m;\n  }\n  return ic;\n}\n\nstatic int\ninclude_module_at(mrb_state *mrb, struct RClass *c, struct RClass *ins_pos, struct RClass *m, int search_super)\n{\n  struct RClass *p, *ic;\n  void *klass_mt = find_origin(c)->mt;\n\n  while (m) {\n    int superclass_seen = 0;\n\n    if (m->flags & MRB_FLAG_IS_PREPENDED)\n      goto skip;\n\n    if (klass_mt && klass_mt == m->mt)\n      return -1;\n\n    p = c->super;\n    while (p) {\n      if (p->tt == MRB_TT_ICLASS) {\n        if (p->mt == m->mt) {\n          if (!superclass_seen) {\n            ins_pos = p; /* move insert point */\n          }\n          goto skip;\n        }\n      } else if (p->tt == MRB_TT_CLASS) {\n        if (!search_super) break;\n        superclass_seen = 1;\n      }\n      p = p->super;\n    }\n\n    ic = include_class_new(mrb, m, ins_pos->super);\n    m->flags |= MRB_FLAG_IS_INHERITED;\n    ins_pos->super = ic;\n    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);\n    mc_clear_by_class(mrb, ins_pos);\n    ins_pos = ic;\n  skip:\n    m = m->super;\n  }\n  mc_clear_all(mrb);\n  return 0;\n}\n\nMRB_API void\nmrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  int changed = include_module_at(mrb, c, find_origin(c), m, 1);\n  if (changed < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n}\n\nMRB_API void\nmrb_prepend_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  struct RClass *origin;\n  int changed = 0;\n\n  if (!(c->flags & MRB_FLAG_IS_PREPENDED)) {\n    origin = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_ICLASS, c);\n    origin->flags |= MRB_FLAG_IS_ORIGIN | MRB_FLAG_IS_INHERITED;\n    origin->super = c->super;\n    c->super = origin;\n    origin->mt = c->mt;\n    c->mt = kh_init(mt, mrb);\n    mrb_field_write_barrier(mrb, (struct RBasic*)c, (struct RBasic*)origin);\n    c->flags |= MRB_FLAG_IS_PREPENDED;\n  }\n  changed = include_module_at(mrb, c, c, m, 0);\n  if (changed < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic prepend detected\");\n  }\n}\n\nstatic mrb_value\nmrb_mod_prepend_features(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value klass;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"C\", &klass);\n  mrb_prepend_module(mrb, mrb_class_ptr(klass), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_append_features(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value klass;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"C\", &klass);\n  mrb_include_module(mrb, mrb_class_ptr(klass), mrb_class_ptr(mod));\n  return mod;\n}\n\n/* 15.2.2.4.28 */\n/*\n *  call-seq:\n *     mod.include?(module)    -> true or false\n *\n *  Returns <code>true</code> if <i>module</i> is included in\n *  <i>mod</i> or one of <i>mod</i>'s ancestors.\n *\n *     module A\n *     end\n *     class B\n *       include A\n *     end\n *     class C < B\n *     end\n *     B.include?(A)   #=> true\n *     C.include?(A)   #=> true\n *     A.include?(A)   #=> false\n */\nstatic mrb_value\nmrb_mod_include_p(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value mod2;\n  struct RClass *c = mrb_class_ptr(mod);\n\n  mrb_get_args(mrb, \"C\", &mod2);\n  mrb_check_type(mrb, mod2, MRB_TT_MODULE);\n\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      if (c->c == mrb_class_ptr(mod2)) return mrb_true_value();\n    }\n    c = c->super;\n  }\n  return mrb_false_value();\n}\n\nstatic mrb_value\nmrb_mod_ancestors(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c->tt == MRB_TT_ICLASS) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n    }\n    else if (!(c->flags & MRB_FLAG_IS_PREPENDED)) {\n      mrb_ary_push(mrb, result, mrb_obj_value(c));\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_extend_object(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n  mrb_get_args(mrb, \"o\", &obj);\n  mrb_include_module(mrb, mrb_class_ptr(mrb_singleton_class(mrb, obj)), mrb_class_ptr(mod));\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_included_modules(mrb_state *mrb, mrb_value self)\n{\n  mrb_value result;\n  struct RClass *c = mrb_class_ptr(self);\n  struct RClass *origin = c;\n\n  MRB_CLASS_ORIGIN(origin);\n  result = mrb_ary_new(mrb);\n  while (c) {\n    if (c != origin && c->tt == MRB_TT_ICLASS) {\n      if (c->c->tt == MRB_TT_MODULE) {\n        mrb_ary_push(mrb, result, mrb_obj_value(c->c));\n      }\n    }\n    c = c->super;\n  }\n\n  return result;\n}\n\nstatic mrb_value\nmrb_mod_initialize(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value b;\n  struct RClass *m = mrb_class_ptr(mod);\n  boot_initmod(mrb, m); /* bootstrap a newly initialized module */\n  mrb_get_args(mrb, \"|&\", &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &mod, mod, m);\n  }\n  return mod;\n}\n\nmrb_value mrb_class_instance_method_list(mrb_state*, mrb_bool, struct RClass*, int);\n\n/* 15.2.2.4.33 */\n/*\n *  call-seq:\n *     mod.instance_methods(include_super=true)   -> array\n *\n *  Returns an array containing the names of the public and protected instance\n *  methods in the receiver. For a module, these are the public and protected methods;\n *  for a class, they are the instance (not singleton) methods. With no\n *  argument, or with an argument that is <code>false</code>, the\n *  instance methods in <i>mod</i> are returned, otherwise the methods\n *  in <i>mod</i> and <i>mod</i>'s superclasses are returned.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       def method3()  end\n *     end\n *\n *     A.instance_methods                #=> [:method1]\n *     B.instance_methods(false)         #=> [:method2]\n *     C.instance_methods(false)         #=> [:method3]\n *     C.instance_methods(true).length   #=> 43\n */\n\nstatic mrb_value\nmrb_mod_instance_methods(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_class_instance_method_list(mrb, recur, c, 0);\n}\n\n/* implementation of module_eval/class_eval */\nmrb_value mrb_mod_module_eval(mrb_state*, mrb_value);\n\nstatic mrb_value\nmrb_mod_dummy_visibility(mrb_state *mrb, mrb_value mod)\n{\n  return mod;\n}\n\nMRB_API mrb_value\nmrb_singleton_class(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb_obj_value(mrb->nil_class);\n    return mrb_obj_value(mrb->false_class);\n  case MRB_TT_TRUE:\n    return mrb_obj_value(mrb->true_class);\n  case MRB_TT_CPTR:\n    return mrb_obj_value(mrb->object_class);\n  case MRB_TT_SYMBOL:\n  case MRB_TT_FIXNUM:\n#ifndef MRB_WITHOUT_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't define singleton\");\n    return mrb_nil_value();    /* not reached */\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  prepare_singleton_class(mrb, obj);\n  return mrb_obj_value(obj->c);\n}\n\nMRB_API void\nmrb_define_singleton_method(mrb_state *mrb, struct RObject *o, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  prepare_singleton_class(mrb, (struct RBasic*)o);\n  mrb_define_method_id(mrb, o->c, mrb_intern_cstr(mrb, name), func, aspec);\n}\n\nMRB_API void\nmrb_define_class_method(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_singleton_method(mrb, (struct RObject*)c, name, func, aspec);\n}\n\nMRB_API void\nmrb_define_module_function(mrb_state *mrb, struct RClass *c, const char *name, mrb_func_t func, mrb_aspec aspec)\n{\n  mrb_define_class_method(mrb, c, name, func, aspec);\n  mrb_define_method(mrb, c, name, func, aspec);\n}\n\n#ifdef MRB_METHOD_CACHE\nstatic void\nmc_clear_all(mrb_state *mrb)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mc[i].c = 0;\n  }\n}\n\nstatic void\nmc_clear_by_class(mrb_state *mrb, struct RClass *c)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FLAG_IS_INHERITED) {\n    mc_clear_all(mrb);\n    c->flags &= ~MRB_FLAG_IS_INHERITED;\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c) mc[i].c = 0;\n  }\n}\n\nstatic void\nmc_clear_by_id(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  if (c->flags & MRB_FLAG_IS_INHERITED) {\n    mc_clear_all(mrb);\n    c->flags &= ~MRB_FLAG_IS_INHERITED;\n    return;\n  }\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    if (mc[i].c == c || mc[i].mid == mid)\n      mc[i].c = 0;\n  }\n}\n#endif\n\nMRB_API mrb_method_t\nmrb_method_search_vm(mrb_state *mrb, struct RClass **cp, mrb_sym mid)\n{\n  khiter_t k;\n  mrb_method_t m;\n  struct RClass *c = *cp;\n#ifdef MRB_METHOD_CACHE\n  struct RClass *oc = c;\n  int h = kh_int_hash_func(mrb, ((intptr_t)oc) ^ mid) & (MRB_METHOD_CACHE_SIZE-1);\n  struct mrb_cache_entry *mc = &mrb->cache[h];\n\n  if (mc->c == c && mc->mid == mid) {\n    *cp = mc->c0;\n    return mc->m;\n  }\n#endif\n\n  while (c) {\n    khash_t(mt) *h = c->mt;\n\n    if (h) {\n      k = kh_get(mt, mrb, h, mid);\n      if (k != kh_end(h)) {\n        m = kh_value(h, k);\n        if (MRB_METHOD_UNDEF_P(m)) break;\n        *cp = c;\n#ifdef MRB_METHOD_CACHE\n        mc->c = oc;\n        mc->c0 = c;\n        mc->mid = mid;\n        mc->m = m;\n#endif\n        return m;\n      }\n    }\n    c = c->super;\n  }\n  MRB_METHOD_FROM_PROC(m, NULL);\n  return m;                  /* no method */\n}\n\nMRB_API mrb_method_t\nmrb_method_search(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    mrb_value inspect = mrb_funcall(mrb, mrb_obj_value(c), \"inspect\", 0);\n    if (mrb_string_p(inspect) && RSTRING_LEN(inspect) > 64) {\n      inspect = mrb_any_to_s(mrb, mrb_obj_value(c));\n    }\n    mrb_name_error(mrb, mid, \"undefined method '%S' for class %S\",\n               mrb_sym2str(mrb, mid), inspect);\n  }\n  return m;\n}\n\nstatic mrb_value\nattr_reader(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  return mrb_iv_get(mrb, obj, to_sym(mrb, name));\n}\n\nstatic mrb_value\nmrb_mod_attr_reader(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name, str;\n    mrb_sym method, sym;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n    name = mrb_sym2str(mrb, method);\n    str = mrb_str_new_capa(mrb, RSTRING_LEN(name)+1);\n    mrb_str_cat_lit(mrb, str, \"@\");\n    mrb_str_cat_str(mrb, str, name);\n    sym = mrb_intern_str(mrb, str);\n    mrb_iv_check(mrb, sym);\n    name = mrb_symbol_value(sym);\n    p = mrb_proc_new_cfunc_with_env(mrb, attr_reader, 1, &name);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nattr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val;\n\n  mrb_get_args(mrb, \"o\", &val);\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_attr_writer(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_value *argv;\n  mrb_int argc, i;\n  int ai;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  ai = mrb_gc_arena_save(mrb);\n  for (i=0; i<argc; i++) {\n    mrb_value name, str, attr;\n    mrb_sym method, sym;\n    struct RProc *p;\n    mrb_method_t m;\n\n    method = to_sym(mrb, argv[i]);\n\n    /* prepare iv name (@name) */\n    name = mrb_sym2str(mrb, method);\n    str = mrb_str_new_capa(mrb, RSTRING_LEN(name)+1);\n    mrb_str_cat_lit(mrb, str, \"@\");\n    mrb_str_cat_str(mrb, str, name);\n    sym = mrb_intern_str(mrb, str);\n    mrb_iv_check(mrb, sym);\n    attr = mrb_symbol_value(sym);\n\n    /* prepare method name (name=) */\n    str = mrb_str_new_capa(mrb, RSTRING_LEN(str));\n    mrb_str_cat_str(mrb, str, name);\n    mrb_str_cat_lit(mrb, str, \"=\");\n    method = mrb_intern_str(mrb, str);\n\n    p = mrb_proc_new_cfunc_with_env(mrb, attr_writer, 1, &attr);\n    MRB_METHOD_FROM_PROC(m, p);\n    mrb_define_method_raw(mrb, c, method, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_instance_alloc(mrb_state *mrb, mrb_value cv)\n{\n  struct RClass *c = mrb_class_ptr(cv);\n  struct RObject *o;\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n\n  if (c->tt == MRB_TT_SCLASS)\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't create instance of singleton class\");\n\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  if (ttype <= MRB_TT_CPTR) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't create instance of %S\", cv);\n  }\n  o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);\n  return mrb_obj_value(o);\n}\n\n/*\n *  call-seq:\n *     class.new(args, ...)    ->  obj\n *\n *  Creates a new object of <i>class</i>'s class, then\n *  invokes that object's <code>initialize</code> method,\n *  passing it <i>args</i>. This is the method that ends\n *  up getting called whenever an object is constructed using\n *  `.new`.\n *\n */\n\nMRB_API mrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n  mrb_method_t m;\n\n  mrb_get_args(mrb, \"*&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = mrb_intern_lit(mrb, \"initialize\");\n  m = mrb_method_search(mrb, mrb_class(mrb, obj), init);\n  if (MRB_METHOD_CFUNC_P(m)) {\n    mrb_func_t f = MRB_METHOD_CFUNC(m);\n    if (f != mrb_bob_init) {\n      f(mrb, obj);\n    }\n  }\n  else {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n\n  return obj;\n}\n\nMRB_API mrb_value\nmrb_obj_new(mrb_state *mrb, struct RClass *c, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value obj;\n  mrb_sym mid;\n\n  obj = mrb_instance_alloc(mrb, mrb_obj_value(c));\n  mid = mrb_intern_lit(mrb, \"initialize\");\n  if (!mrb_func_basic_p(mrb, obj, mid, mrb_bob_init)) {\n    mrb_funcall_argv(mrb, obj, mid, argc, argv);\n  }\n  return obj;\n}\n\nstatic mrb_value\nmrb_class_initialize(mrb_state *mrb, mrb_value c)\n{\n  mrb_value a, b;\n\n  mrb_get_args(mrb, \"|C&\", &a, &b);\n  if (!mrb_nil_p(b)) {\n    mrb_yield_with_class(mrb, b, 1, &c, c, mrb_class_ptr(c));\n  }\n  return c;\n}\n\nstatic mrb_value\nmrb_class_new_class(mrb_state *mrb, mrb_value cv)\n{\n  mrb_int n;\n  mrb_value super, blk;\n  mrb_value new_class;\n  mrb_sym mid;\n\n  n = mrb_get_args(mrb, \"|C&\", &super, &blk);\n  if (n == 0) {\n    super = mrb_obj_value(mrb->object_class);\n  }\n  new_class = mrb_obj_value(mrb_class_new(mrb, mrb_class_ptr(super)));\n  mid = mrb_intern_lit(mrb, \"initialize\");\n  if (!mrb_func_basic_p(mrb, new_class, mid, mrb_bob_init)) {\n    mrb_funcall_with_block(mrb, new_class, mid, n, &super, blk);\n  }\n  mrb_class_inherited(mrb, mrb_class_ptr(super), mrb_class_ptr(new_class));\n  return new_class;\n}\n\nstatic mrb_value\nmrb_class_superclass(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c;\n\n  c = mrb_class_ptr(klass);\n  c = find_origin(c)->super;\n  while (c && c->tt == MRB_TT_ICLASS) {\n    c = find_origin(c)->super;\n  }\n  if (!c) return mrb_nil_value();\n  return mrb_obj_value(c);\n}\n\nstatic mrb_value\nmrb_bob_init(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_bob_not(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_bool_value(!mrb_test(cv));\n}\n\n/* 15.3.1.3.1  */\n/* 15.3.1.3.10 */\n/* 15.3.1.3.11 */\n/*\n *  call-seq:\n *     obj == other        -> true or false\n *     obj.equal?(other)   -> true or false\n *     obj.eql?(other)     -> true or false\n *\n *  Equality---At the <code>Object</code> level, <code>==</code> returns\n *  <code>true</code> only if <i>obj</i> and <i>other</i> are the\n *  same object. Typically, this method is overridden in descendant\n *  classes to provide class-specific meaning.\n *\n *  Unlike <code>==</code>, the <code>equal?</code> method should never be\n *  overridden by subclasses: it is used to determine object identity\n *  (that is, <code>a.equal?(b)</code> iff <code>a</code> is the same\n *  object as <code>b</code>).\n *\n *  The <code>eql?</code> method returns <code>true</code> if\n *  <i>obj</i> and <i>anObject</i> have the same value. Used by\n *  <code>Hash</code> to test members for equality.  For objects of\n *  class <code>Object</code>, <code>eql?</code> is synonymous with\n *  <code>==</code>. Subclasses normally continue this tradition, but\n *  there are exceptions. <code>Numeric</code> types, for example,\n *  perform type conversion across <code>==</code>, but not across\n *  <code>eql?</code>, so:\n *\n *     1 == 1.0     #=> true\n *     1.eql? 1.0   #=> false\n */\nmrb_value\nmrb_obj_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"o\", &arg);\n  return mrb_bool_value(mrb_obj_equal(mrb, self, arg));\n}\n\nstatic mrb_value\nmrb_obj_not_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"o\", &arg);\n  return mrb_bool_value(!mrb_equal(mrb, self, arg));\n}\n\nMRB_API mrb_bool\nmrb_obj_respond_to(mrb_state *mrb, struct RClass* c, mrb_sym mid)\n{\n  mrb_method_t m;\n\n  m = mrb_method_search_vm(mrb, &c, mid);\n  if (MRB_METHOD_UNDEF_P(m)) {\n    return FALSE;\n  }\n  return TRUE;\n}\n\nMRB_API mrb_bool\nmrb_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym mid)\n{\n  return mrb_obj_respond_to(mrb, mrb_class(mrb, obj), mid);\n}\n\nMRB_API mrb_value\nmrb_class_path(mrb_state *mrb, struct RClass *c)\n{\n  mrb_value path;\n  mrb_sym nsym = mrb_intern_lit(mrb, \"__classname__\");\n\n  path = mrb_obj_iv_get(mrb, (struct RObject*)c, nsym);\n  if (mrb_nil_p(path)) {\n    /* no name (yet) */\n    return mrb_class_find_path(mrb, c);\n  }\n  else if (mrb_symbol_p(path)) {\n    /* toplevel class/module */\n    const char *str;\n    mrb_int len;\n\n    str = mrb_sym2name_len(mrb, mrb_symbol(path), &len);\n    return mrb_str_new(mrb, str, len);\n  }\n  return mrb_str_dup(mrb, path);\n}\n\nMRB_API struct RClass*\nmrb_class_real(struct RClass* cl)\n{\n  if (cl == 0) return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n    if (cl == 0) return NULL;\n  }\n  return cl;\n}\n\nMRB_API const char*\nmrb_class_name(mrb_state *mrb, struct RClass* c)\n{\n  mrb_value path = mrb_class_path(mrb, c);\n  if (mrb_nil_p(path)) {\n    path = mrb_str_new_lit(mrb, \"#<Class:\");\n    mrb_str_concat(mrb, path, mrb_ptr_to_str(mrb, c));\n    mrb_str_cat_lit(mrb, path, \">\");\n  }\n  return RSTRING_PTR(path);\n}\n\nMRB_API const char*\nmrb_obj_classname(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_name(mrb, mrb_obj_class(mrb, obj));\n}\n\n/*!\n * Ensures a class can be derived from super.\n *\n * \\param super a reference to an object.\n * \\exception TypeError if \\a super is not a Class or \\a super is a singleton class.\n */\nstatic void\nmrb_check_inheritable(mrb_state *mrb, struct RClass *super)\n{\n  if (super->tt != MRB_TT_CLASS) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%S given)\", mrb_obj_value(super));\n  }\n  if (super->tt == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of singleton class\");\n  }\n  if (super == mrb->class_class) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't make subclass of Class\");\n  }\n}\n\n/*!\n * Creates a new class.\n * \\param super     a class from which the new class derives.\n * \\exception TypeError \\a super is not inheritable.\n * \\exception TypeError \\a super is the Class class.\n */\nMRB_API struct RClass*\nmrb_class_new(mrb_state *mrb, struct RClass *super)\n{\n  struct RClass *c;\n\n  if (super) {\n    mrb_check_inheritable(mrb, super);\n  }\n  c = boot_defclass(mrb, super);\n  if (super) {\n    MRB_SET_INSTANCE_TT(c, MRB_INSTANCE_TT(super));\n  }\n  make_metaclass(mrb, c);\n\n  return c;\n}\n\n/*!\n * Creates a new module.\n */\nMRB_API struct RClass*\nmrb_module_new(mrb_state *mrb)\n{\n  struct RClass *m = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_MODULE, mrb->module_class);\n  boot_initmod(mrb, m);\n  return m;\n}\n\n/*\n *  call-seq:\n *     obj.class    => class\n *\n *  Returns the class of <i>obj</i>, now preferred over\n *  <code>Object#type</code>, as an object's type in Ruby is only\n *  loosely tied to that object's class. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Fixnum\n *     self.class   #=> Object\n */\n\nMRB_API struct RClass*\nmrb_obj_class(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_class_real(mrb_class(mrb, obj));\n}\n\nMRB_API void\nmrb_alias_method(mrb_state *mrb, struct RClass *c, mrb_sym a, mrb_sym b)\n{\n  mrb_method_t m = mrb_method_search(mrb, c, b);\n\n  mrb_define_method_raw(mrb, c, a, m);\n}\n\n/*!\n * Defines an alias of a method.\n * \\param klass  the class which the original method belongs to\n * \\param name1  a new name for the method\n * \\param name2  the original name of the method\n */\nMRB_API void\nmrb_define_alias(mrb_state *mrb, struct RClass *klass, const char *name1, const char *name2)\n{\n  mrb_alias_method(mrb, klass, mrb_intern_cstr(mrb, name1), mrb_intern_cstr(mrb, name2));\n}\n\n/*\n * call-seq:\n *   mod.to_s   -> string\n *\n * Return a string representing this module or class. For basic\n * classes and modules, this is the name. For singletons, we\n * show information on the thing we're attached to as well.\n */\n\nstatic mrb_value\nmrb_mod_to_s(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value str;\n\n  if (mrb_type(klass) == MRB_TT_SCLASS) {\n    mrb_value v = mrb_iv_get(mrb, klass, mrb_intern_lit(mrb, \"__attached__\"));\n\n    str = mrb_str_new_lit(mrb, \"#<Class:\");\n\n    if (class_ptr_p(v)) {\n      mrb_str_cat_str(mrb, str, mrb_inspect(mrb, v));\n    }\n    else {\n      mrb_str_cat_str(mrb, str, mrb_any_to_s(mrb, v));\n    }\n    return mrb_str_cat_lit(mrb, str, \">\");\n  }\n  else {\n    struct RClass *c;\n    mrb_value path;\n\n    str = mrb_str_new_capa(mrb, 32);\n    c = mrb_class_ptr(klass);\n    path = mrb_class_path(mrb, c);\n\n    if (mrb_nil_p(path)) {\n      switch (mrb_type(klass)) {\n        case MRB_TT_CLASS:\n          mrb_str_cat_lit(mrb, str, \"#<Class:\");\n          break;\n\n        case MRB_TT_MODULE:\n          mrb_str_cat_lit(mrb, str, \"#<Module:\");\n          break;\n\n        default:\n          /* Shouldn't be happened? */\n          mrb_str_cat_lit(mrb, str, \"#<??????:\");\n          break;\n      }\n      mrb_str_concat(mrb, str, mrb_ptr_to_str(mrb, c));\n      return mrb_str_cat_lit(mrb, str, \">\");\n    }\n    else {\n      return path;\n    }\n  }\n}\n\nstatic mrb_value\nmrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  return mrb_nil_value();\n}\n\nstatic void\nundef_method(mrb_state *mrb, struct RClass *c, mrb_sym a)\n{\n  if (!mrb_obj_respond_to(mrb, c, a)) {\n    mrb_name_error(mrb, a, \"undefined method '%S' for class '%S'\", mrb_sym2str(mrb, a), mrb_obj_value(c));\n  }\n  else {\n    mrb_method_t m;\n\n    MRB_METHOD_FROM_PROC(m, NULL);\n    mrb_define_method_raw(mrb, c, a, m);\n  }\n}\n\nMRB_API void\nmrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n\nMRB_API void\nmrb_undef_class_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  mrb_undef_method(mrb,  mrb_class_ptr(mrb_singleton_class(mrb, mrb_obj_value(c))), name);\n}\n\nstatic mrb_value\nmrb_mod_undef(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_int argc;\n  mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    undef_method(mrb, c, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmod_define_method(mrb_state *mrb, mrb_value self)\n{\n  struct RClass *c = mrb_class_ptr(self);\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      /* ignored */\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %S (expected Proc)\", mrb_obj_value(mrb_obj_class(mrb, proc)));\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\ntop_define_method(mrb_state *mrb, mrb_value self)\n{\n  return mod_define_method(mrb, mrb_obj_value(mrb->object_class));\n}\n\nstatic void\ncheck_cv_name_str(mrb_state *mrb, mrb_value str)\n{\n  const char *s = RSTRING_PTR(str);\n  mrb_int len = RSTRING_LEN(str);\n\n  if (len < 3 || !(s[0] == '@' && s[1] == '@')) {\n    mrb_name_error(mrb, mrb_intern_str(mrb, str), \"'%S' is not allowed as a class variable name\", str);\n  }\n}\n\nstatic void\ncheck_cv_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  check_cv_name_str(mrb, mrb_sym2str(mrb, id));\n}\n\n/* 15.2.2.4.16 */\n/*\n *  call-seq:\n *     obj.class_variable_defined?(symbol)    -> true or false\n *\n *  Returns <code>true</code> if the given class variable is defined\n *  in <i>obj</i>.\n *\n *     class Fred\n *       @@foo = 99\n *     end\n *     Fred.class_variable_defined?(:@@foo)    #=> true\n *     Fred.class_variable_defined?(:@@bar)    #=> false\n */\n\nstatic mrb_value\nmrb_mod_cvar_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_cv_name_sym(mrb, id);\n  return mrb_bool_value(mrb_cv_defined(mrb, mod, id));\n}\n\n/* 15.2.2.4.17 */\n/*\n *  call-seq:\n *     mod.class_variable_get(symbol)    -> obj\n *\n *  Returns the value of the given class variable (or throws a\n *  <code>NameError</code> exception). The <code>@@</code> part of the\n *  variable name should be included for regular class variables\n *\n *     class Fred\n *       @@foo = 99\n *     end\n *     Fred.class_variable_get(:@@foo)     #=> 99\n */\n\nstatic mrb_value\nmrb_mod_cvar_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_cv_name_sym(mrb, id);\n  return mrb_cv_get(mrb, mod, id);\n}\n\n/* 15.2.2.4.18 */\n/*\n *  call-seq:\n *     obj.class_variable_set(symbol, obj)    -> obj\n *\n *  Sets the class variable names by <i>symbol</i> to\n *  <i>object</i>.\n *\n *     class Fred\n *       @@foo = 99\n *       def foo\n *         @@foo\n *       end\n *     end\n *     Fred.class_variable_set(:@@foo, 101)     #=> 101\n *     Fred.new.foo                             #=> 101\n */\n\nstatic mrb_value\nmrb_mod_cvar_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value value;\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_cv_name_sym(mrb, id);\n  mrb_cv_set(mrb, mod, id, value);\n  return value;\n}\n\n/* 15.2.2.4.39 */\n/*\n *  call-seq:\n *     remove_class_variable(sym)    -> obj\n *\n *  Removes the definition of the <i>sym</i>, returning that\n *  constant's value.\n *\n *     class Dummy\n *       @@var = 99\n *       puts @@var\n *       p class_variables\n *       remove_class_variable(:@@var)\n *       p class_variables\n *     end\n *\n *  <em>produces:</em>\n *\n *     99\n *     [:@@var]\n *     []\n */\n\nstatic mrb_value\nmrb_mod_remove_cvar(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value val;\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_cv_name_sym(mrb, id);\n\n  val = mrb_iv_remove(mrb, mod, id);\n  if (!mrb_undef_p(val)) return val;\n\n  if (mrb_cv_defined(mrb, mod, id)) {\n    mrb_name_error(mrb, id, \"cannot remove %S for %S\",\n                   mrb_sym2str(mrb, id), mod);\n  }\n\n  mrb_name_error(mrb, id, \"class variable %S not defined for %S\",\n                 mrb_sym2str(mrb, id), mod);\n\n /* not reached */\n return mrb_nil_value();\n}\n\n/* 15.2.2.4.34 */\n/*\n *  call-seq:\n *     mod.method_defined?(symbol)    -> true or false\n *\n *  Returns +true+ if the named method is defined by\n *  _mod_ (or its included modules and, if _mod_ is a class,\n *  its ancestors). Public and protected methods are matched.\n *\n *     module A\n *       def method1()  end\n *     end\n *     class B\n *       def method2()  end\n *     end\n *     class C < B\n *       include A\n *       def method3()  end\n *     end\n *\n *     A.method_defined? :method1    #=> true\n *     C.method_defined? \"method1\"   #=> true\n *     C.method_defined? \"method2\"   #=> true\n *     C.method_defined? \"method3\"   #=> true\n *     C.method_defined? \"method4\"   #=> false\n */\n\nstatic mrb_value\nmrb_mod_method_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n\n  mrb_get_args(mrb, \"n\", &id);\n  return mrb_bool_value(mrb_obj_respond_to(mrb, mrb_class_ptr(mod), id));\n}\n\nstatic void\nremove_method(mrb_state *mrb, mrb_value mod, mrb_sym mid)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  khash_t(mt) *h = find_origin(c)->mt;\n  khiter_t k;\n\n  if (h) {\n    k = kh_get(mt, mrb, h, mid);\n    if (k != kh_end(h)) {\n      kh_del(mt, mrb, h, k);\n      mrb_funcall(mrb, mod, \"method_removed\", 1, mrb_symbol_value(mid));\n      return;\n    }\n  }\n\n  mrb_name_error(mrb, mid, \"method '%S' not defined in %S\",\n    mrb_sym2str(mrb, mid), mod);\n}\n\n/* 15.2.2.4.41 */\n/*\n *  call-seq:\n *     remove_method(symbol)   -> self\n *\n *  Removes the method identified by _symbol_ from the current\n *  class. For an example, see <code>Module.undef_method</code>.\n */\n\nstatic mrb_value\nmrb_mod_remove_method(mrb_state *mrb, mrb_value mod)\n{\n  mrb_int argc;\n  mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  while (argc--) {\n    remove_method(mrb, mod, to_sym(mrb, *argv));\n    argv++;\n  }\n  return mod;\n}\n\n\n\nstatic void\ncheck_const_name_str(mrb_state *mrb, mrb_value str)\n{\n  if (RSTRING_LEN(str) < 1 || !ISUPPER(*RSTRING_PTR(str))) {\n    mrb_name_error(mrb, mrb_intern_str(mrb, str), \"wrong constant name %S\", str);\n  }\n}\n\nstatic void\ncheck_const_name_sym(mrb_state *mrb, mrb_sym id)\n{\n  check_const_name_str(mrb, mrb_sym2str(mrb, id));\n}\n\nstatic mrb_value\nconst_defined(mrb_state *mrb, mrb_value mod, mrb_sym id, mrb_bool inherit)\n{\n  if (inherit) {\n    return mrb_bool_value(mrb_const_defined(mrb, mod, id));\n  }\n  return mrb_bool_value(mrb_const_defined_at(mrb, mod, id));\n}\n\nstatic mrb_value\nmrb_mod_const_defined(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_bool inherit = TRUE;\n\n  mrb_get_args(mrb, \"n|b\", &id, &inherit);\n  check_const_name_sym(mrb, id);\n  return const_defined(mrb, mod, id, inherit);\n}\n\nstatic mrb_value\nmrb_const_get_sym(mrb_state *mrb, mrb_value mod, mrb_sym id)\n{\n  check_const_name_sym(mrb, id);\n  return mrb_const_get(mrb, mod, id);\n}\n\nstatic mrb_value\nmrb_mod_const_get(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value path;\n  mrb_sym id;\n  char *ptr;\n  mrb_int off, end, len;\n\n  mrb_get_args(mrb, \"o\", &path);\n\n  if (mrb_symbol_p(path)) {\n    /* const get with symbol */\n    id = mrb_symbol(path);\n    return mrb_const_get_sym(mrb, mod, id);\n  }\n\n  /* const get with class path string */\n  path = mrb_string_type(mrb, path);\n  ptr = RSTRING_PTR(path);\n  len = RSTRING_LEN(path);\n  off = 0;\n\n  while (off < len) {\n    end = mrb_str_index_lit(mrb, path, \"::\", off);\n    end = (end == -1) ? len : end;\n    id = mrb_intern(mrb, ptr+off, end-off);\n    mod = mrb_const_get_sym(mrb, mod, id);\n    off = (end == len) ? end : end+2;\n  }\n\n  return mod;\n}\n\nstatic mrb_value\nmrb_mod_const_set(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value value;\n\n  mrb_get_args(mrb, \"no\", &id, &value);\n  check_const_name_sym(mrb, id);\n  mrb_const_set(mrb, mod, id, value);\n  return value;\n}\n\nstatic mrb_value\nmrb_mod_remove_const(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym id;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &id);\n  check_const_name_sym(mrb, id);\n  val = mrb_iv_remove(mrb, mod, id);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, id, \"constant %S not defined\", mrb_sym2str(mrb, id));\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_mod_const_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n\n  if (mrb_class_real(mrb_class_ptr(mod)) != mrb->object_class) {\n    mrb_name_error(mrb, sym, \"uninitialized constant %S::%S\",\n                   mod,\n                   mrb_sym2str(mrb, sym));\n  }\n  else {\n    mrb_name_error(mrb, sym, \"uninitialized constant %S\",\n                   mrb_sym2str(mrb, sym));\n  }\n  /* not reached */\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_mod_s_constants(mrb_state *mrb, mrb_value mod)\n{\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"Module.constants not implemented\");\n  return mrb_nil_value();       /* not reached */\n}\n\nstatic mrb_value\nmrb_mod_eqq(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value obj;\n  mrb_bool eqq;\n\n  mrb_get_args(mrb, \"o\", &obj);\n  eqq = mrb_obj_is_kind_of(mrb, obj, mrb_class_ptr(mod));\n\n  return mrb_bool_value(eqq);\n}\n\nMRB_API mrb_value\nmrb_mod_module_function(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value *argv;\n  mrb_int argc, i;\n  mrb_sym mid;\n  mrb_method_t m;\n  struct RClass *rclass;\n  int ai;\n\n  mrb_check_type(mrb, mod, MRB_TT_MODULE);\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  if (argc == 0) {\n    /* set MODFUNC SCOPE if implemented */\n    return mod;\n  }\n\n  /* set PRIVATE method visibility if implemented */\n  /* mrb_mod_dummy_visibility(mrb, mod); */\n\n  for (i=0; i<argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_SYMBOL);\n\n    mid = mrb_symbol(argv[i]);\n    rclass = mrb_class_ptr(mod);\n    m = mrb_method_search(mrb, rclass, mid);\n\n    prepare_singleton_class(mrb, (struct RBasic*)rclass);\n    ai = mrb_gc_arena_save(mrb);\n    mrb_define_method_raw(mrb, rclass->c, mid, m);\n    mrb_gc_arena_restore(mrb, ai);\n  }\n\n  return mod;\n}\n\n/* implementation of __id__ */\nmrb_value mrb_obj_id_m(mrb_state *mrb, mrb_value self);\n/* implementation of instance_eval */\nmrb_value mrb_obj_instance_eval(mrb_state*, mrb_value);\n/* implementation of Module.nesting */\nmrb_value mrb_mod_s_nesting(mrb_state*, mrb_value);\n\nstatic mrb_value\ninspect_main(mrb_state *mrb, mrb_value mod)\n{\n  return mrb_str_new_lit(mrb, \"main\");\n}\n\nvoid\nmrb_init_class(mrb_state *mrb)\n{\n  struct RClass *bob;           /* BasicObject */\n  struct RClass *obj;           /* Object */\n  struct RClass *mod;           /* Module */\n  struct RClass *cls;           /* Class */\n\n  /* boot class hierarchy */\n  bob = boot_defclass(mrb, 0);\n  obj = boot_defclass(mrb, bob); mrb->object_class = obj;\n  mod = boot_defclass(mrb, obj); mrb->module_class = mod;/* obj -> mod */\n  cls = boot_defclass(mrb, mod); mrb->class_class = cls; /* obj -> cls */\n  /* fix-up loose ends */\n  bob->c = obj->c = mod->c = cls->c = cls;\n  make_metaclass(mrb, bob);\n  make_metaclass(mrb, obj);\n  make_metaclass(mrb, mod);\n  make_metaclass(mrb, cls);\n\n  /* name basic classes */\n  mrb_define_const(mrb, bob, \"BasicObject\", mrb_obj_value(bob));\n  mrb_define_const(mrb, obj, \"BasicObject\", mrb_obj_value(bob));\n  mrb_define_const(mrb, obj, \"Object\",      mrb_obj_value(obj));\n  mrb_define_const(mrb, obj, \"Module\",      mrb_obj_value(mod));\n  mrb_define_const(mrb, obj, \"Class\",       mrb_obj_value(cls));\n\n  /* name each classes */\n  mrb_class_name_class(mrb, NULL, bob, mrb_intern_lit(mrb, \"BasicObject\"));\n  mrb_class_name_class(mrb, NULL, obj, mrb_intern_lit(mrb, \"Object\")); /* 15.2.1 */\n  mrb_class_name_class(mrb, NULL, mod, mrb_intern_lit(mrb, \"Module\")); /* 15.2.2 */\n  mrb_class_name_class(mrb, NULL, cls, mrb_intern_lit(mrb, \"Class\"));  /* 15.2.3 */\n\n  mrb->proc_class = mrb_define_class(mrb, \"Proc\", mrb->object_class);  /* 15.2.17 */\n  MRB_SET_INSTANCE_TT(mrb->proc_class, MRB_TT_PROC);\n\n  MRB_SET_INSTANCE_TT(cls, MRB_TT_CLASS);\n  mrb_define_method(mrb, bob, \"initialize\",              mrb_bob_init,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"!\",                       mrb_bob_not,              MRB_ARGS_NONE());\n  mrb_define_method(mrb, bob, \"==\",                      mrb_obj_equal_m,          MRB_ARGS_REQ(1)); /* 15.3.1.3.1  */\n  mrb_define_method(mrb, bob, \"!=\",                      mrb_obj_not_equal_m,      MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, bob, \"__id__\",                  mrb_obj_id_m,             MRB_ARGS_NONE()); /* 15.3.1.3.3  */\n  mrb_define_method(mrb, bob, \"__send__\",                mrb_f_send,               MRB_ARGS_ANY());  /* 15.3.1.3.4  */\n  mrb_define_method(mrb, bob, \"instance_eval\",           mrb_obj_instance_eval,    MRB_ARGS_ANY());  /* 15.3.1.3.18 */\n\n  mrb_define_class_method(mrb, cls, \"new\",               mrb_class_new_class,      MRB_ARGS_OPT(1));\n  mrb_define_method(mrb, cls, \"superclass\",              mrb_class_superclass,     MRB_ARGS_NONE()); /* 15.2.3.3.4 */\n  mrb_define_method(mrb, cls, \"new\",                     mrb_instance_new,         MRB_ARGS_ANY());  /* 15.2.3.3.3 */\n  mrb_define_method(mrb, cls, \"initialize\",              mrb_class_initialize,     MRB_ARGS_OPT(1)); /* 15.2.3.3.1 */\n  mrb_define_method(mrb, cls, \"inherited\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n\n  MRB_SET_INSTANCE_TT(mod, MRB_TT_MODULE);\n  mrb_define_method(mrb, mod, \"class_variable_defined?\", mrb_mod_cvar_defined,     MRB_ARGS_REQ(1)); /* 15.2.2.4.16 */\n  mrb_define_method(mrb, mod, \"class_variable_get\",      mrb_mod_cvar_get,         MRB_ARGS_REQ(1)); /* 15.2.2.4.17 */\n  mrb_define_method(mrb, mod, \"class_variable_set\",      mrb_mod_cvar_set,         MRB_ARGS_REQ(2)); /* 15.2.2.4.18 */\n  mrb_define_method(mrb, mod, \"extend_object\",           mrb_mod_extend_object,    MRB_ARGS_REQ(1)); /* 15.2.2.4.25 */\n  mrb_define_method(mrb, mod, \"extended\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.26 */\n  mrb_define_method(mrb, mod, \"prepended\",               mrb_bob_init,             MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"prepend_features\",        mrb_mod_prepend_features, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"include?\",                mrb_mod_include_p,        MRB_ARGS_REQ(1)); /* 15.2.2.4.28 */\n  mrb_define_method(mrb, mod, \"append_features\",         mrb_mod_append_features,  MRB_ARGS_REQ(1)); /* 15.2.2.4.10 */\n  mrb_define_method(mrb, mod, \"class_eval\",              mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.15 */\n  mrb_define_method(mrb, mod, \"included\",                mrb_bob_init,             MRB_ARGS_REQ(1)); /* 15.2.2.4.29 */\n  mrb_define_method(mrb, mod, \"included_modules\",        mrb_mod_included_modules, MRB_ARGS_NONE()); /* 15.2.2.4.30 */\n  mrb_define_method(mrb, mod, \"initialize\",              mrb_mod_initialize,       MRB_ARGS_NONE()); /* 15.2.2.4.31 */\n  mrb_define_method(mrb, mod, \"instance_methods\",        mrb_mod_instance_methods, MRB_ARGS_ANY());  /* 15.2.2.4.33 */\n  mrb_define_method(mrb, mod, \"method_defined?\",         mrb_mod_method_defined,   MRB_ARGS_REQ(1)); /* 15.2.2.4.34 */\n  mrb_define_method(mrb, mod, \"module_eval\",             mrb_mod_module_eval,      MRB_ARGS_ANY());  /* 15.2.2.4.35 */\n  mrb_define_method(mrb, mod, \"module_function\",         mrb_mod_module_function,  MRB_ARGS_ANY());\n  mrb_define_method(mrb, mod, \"private\",                 mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.36 */\n  mrb_define_method(mrb, mod, \"protected\",               mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.37 */\n  mrb_define_method(mrb, mod, \"public\",                  mrb_mod_dummy_visibility, MRB_ARGS_ANY());  /* 15.2.2.4.38 */\n  mrb_define_method(mrb, mod, \"remove_class_variable\",   mrb_mod_remove_cvar,      MRB_ARGS_REQ(1)); /* 15.2.2.4.39 */\n  mrb_define_method(mrb, mod, \"remove_method\",           mrb_mod_remove_method,    MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"method_removed\",          mrb_bob_init,             MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"attr_reader\",             mrb_mod_attr_reader,      MRB_ARGS_ANY());  /* 15.2.2.4.13 */\n  mrb_define_method(mrb, mod, \"attr_writer\",             mrb_mod_attr_writer,      MRB_ARGS_ANY());  /* 15.2.2.4.14 */\n  mrb_define_method(mrb, mod, \"to_s\",                    mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"inspect\",                 mrb_mod_to_s,             MRB_ARGS_NONE());\n  mrb_define_method(mrb, mod, \"alias_method\",            mrb_mod_alias,            MRB_ARGS_ANY());  /* 15.2.2.4.8 */\n  mrb_define_method(mrb, mod, \"ancestors\",               mrb_mod_ancestors,        MRB_ARGS_NONE()); /* 15.2.2.4.9 */\n  mrb_define_method(mrb, mod, \"undef_method\",            mrb_mod_undef,            MRB_ARGS_ANY());  /* 15.2.2.4.41 */\n  mrb_define_method(mrb, mod, \"const_defined?\",          mrb_mod_const_defined,    MRB_ARGS_ARG(1,1)); /* 15.2.2.4.20 */\n  mrb_define_method(mrb, mod, \"const_get\",               mrb_mod_const_get,        MRB_ARGS_REQ(1)); /* 15.2.2.4.21 */\n  mrb_define_method(mrb, mod, \"const_set\",               mrb_mod_const_set,        MRB_ARGS_REQ(2)); /* 15.2.2.4.23 */\n  mrb_define_method(mrb, mod, \"constants\",               mrb_mod_constants,        MRB_ARGS_OPT(1)); /* 15.2.2.4.24 */\n  mrb_define_method(mrb, mod, \"remove_const\",            mrb_mod_remove_const,     MRB_ARGS_REQ(1)); /* 15.2.2.4.40 */\n  mrb_define_method(mrb, mod, \"const_missing\",           mrb_mod_const_missing,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, mod, \"define_method\",           mod_define_method,        MRB_ARGS_ARG(1,1));\n  mrb_define_method(mrb, mod, \"class_variables\",         mrb_mod_class_variables,  MRB_ARGS_NONE()); /* 15.2.2.4.19 */\n  mrb_define_method(mrb, mod, \"===\",                     mrb_mod_eqq,              MRB_ARGS_REQ(1));\n  mrb_define_class_method(mrb, mod, \"constants\",         mrb_mod_s_constants,      MRB_ARGS_ANY());  /* 15.2.2.3.1 */\n  mrb_define_class_method(mrb, mod, \"nesting\",           mrb_mod_s_nesting,        MRB_ARGS_REQ(0)); /* 15.2.2.3.2 */\n\n  mrb_undef_method(mrb, cls, \"append_features\");\n  mrb_undef_method(mrb, cls, \"extend_object\");\n\n  mrb->top_self = (struct RObject*)mrb_obj_alloc(mrb, MRB_TT_OBJECT, mrb->object_class);\n  mrb_define_singleton_method(mrb, mrb->top_self, \"inspect\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"to_s\", inspect_main, MRB_ARGS_NONE());\n  mrb_define_singleton_method(mrb, mrb->top_self, \"define_method\", top_define_method, MRB_ARGS_ARG(1,1));\n}\n"], "filenames": ["src/class.c"], "buggy_code_start_loc": [1766], "buggy_code_end_loc": [1769], "fixing_code_start_loc": [1766], "fixing_code_end_loc": [1770], "type": "CWE-476", "message": "An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class_real because \"class BasicObject\" is not properly supported in class.c.", "other": {"cve": {"id": "CVE-2018-12249", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-12T14:29:00.460", "lastModified": "2022-05-12T20:12:06.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class_real because \"class BasicObject\" is not properly supported in class.c."}, {"lang": "es", "value": "Se ha descubierto un problema en mruby 1.4.1. Hay una desreferencia de puntero NULL en mrb_class_real debido a que \"class BasicObject\" no se soporta correctamente en class.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "C4A86E77-13CC-41B4-AB91-4A7C513791BC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/faa4eaf6803bd11669bc324b4c34e7162286bfa3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mruby/mruby/issues/4037", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/faa4eaf6803bd11669bc324b4c34e7162286bfa3"}}