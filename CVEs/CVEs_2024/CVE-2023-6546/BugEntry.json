{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * n_gsm.c GSM 0710 tty multiplexor\n * Copyright (c) 2009/10 Intel Corporation\n *\n *\t* THIS IS A DEVELOPMENT SNAPSHOT IT IS NOT A FINAL RELEASE *\n *\n * Outgoing path:\n * tty -> DLCI fifo -> scheduler -> GSM MUX data queue    ---o-> ldisc\n * control message               -> GSM MUX control queue --\u00b4\n *\n * Incoming path:\n * ldisc -> gsm_queue() -o--> tty\n *                        `-> gsm_control_response()\n *\n * TO DO:\n *\tMostly done:\tioctls for setting modes/timing\n *\tPartly done:\thooks so you can pull off frames to non tty devs\n *\tRestart DLCI 0 when it closes ?\n *\tImprove the tx engine\n *\tResolve tx side locking by adding a queue_head and routing\n *\t\tall control traffic via it\n *\tGeneral tidy/document\n *\tReview the locking/move to refcounts more (mux now moved to an\n *\t\talloc/free model ready)\n *\tUse newest tty open/close port helpers and install hooks\n *\tWhat to do about power functions ?\n *\tTermios setting and negotiation\n *\tDo we need a 'which mux are you' ioctl to correlate mux and tty sets\n *\n */\n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/bitfield.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/math.h>\n#include <linux/nospec.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/tty_flip.h>\n#include <linux/tty_driver.h>\n#include <linux/serial.h>\n#include <linux/kfifo.h>\n#include <linux/skbuff.h>\n#include <net/arp.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/gsmmux.h>\n#include \"tty.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0600);\n\n/* Module debug bits */\n#define DBG_DUMP\tBIT(0) /* Data transmission dump. */\n#define DBG_CD_ON\tBIT(1) /* Always assume CD line on. */\n#define DBG_DATA\tBIT(2) /* Data transmission details. */\n#define DBG_ERRORS\tBIT(3) /* Details for fail conditions. */\n#define DBG_TTY\t\tBIT(4) /* Transmission statistics for DLCI TTYs. */\n#define DBG_PAYLOAD\tBIT(5) /* Limits DBG_DUMP to payload frames. */\n\n/* Defaults: these are from the specification */\n\n#define T1\t10\t\t/* 100mS */\n#define T2\t34\t\t/* 333mS */\n#define T3\t10\t\t/* 10s */\n#define N2\t3\t\t/* Retry 3 times */\n#define K\t2\t\t/* outstanding I frames */\n\n#define MAX_T3 255\t\t/* In seconds. */\n#define MAX_WINDOW_SIZE 7\t/* Limit of K in error recovery mode. */\n\n/* Use long timers for testing at low speed with debug on */\n#ifdef DEBUG_TIMING\n#define T1\t100\n#define T2\t200\n#endif\n\n/*\n * Semi-arbitrary buffer size limits. 0710 is normally run with 32-64 byte\n * limits so this is plenty\n */\n#define MAX_MRU 1500\n#define MAX_MTU 1500\n#define MIN_MTU (PROT_OVERHEAD + 1)\n/* SOF, ADDR, CTRL, LEN1, LEN2, ..., FCS, EOF */\n#define PROT_OVERHEAD 7\n#define\tGSM_NET_TX_TIMEOUT (HZ*10)\n\n/*\n *\tstruct gsm_mux_net\t-\tnetwork interface\n *\n *\tCreated when net interface is initialized.\n */\nstruct gsm_mux_net {\n\tstruct kref ref;\n\tstruct gsm_dlci *dlci;\n};\n\n/*\n *\tEach block of data we have queued to go out is in the form of\n *\ta gsm_msg which holds everything we need in a link layer independent\n *\tformat\n */\n\nstruct gsm_msg {\n\tstruct list_head list;\n\tu8 addr;\t\t/* DLCI address + flags */\n\tu8 ctrl;\t\t/* Control byte + flags */\n\tunsigned int len;\t/* Length of data block (can be zero) */\n\tunsigned char *data;\t/* Points into buffer but not at the start */\n\tunsigned char buffer[];\n};\n\nenum gsm_dlci_state {\n\tDLCI_CLOSED,\n\tDLCI_WAITING_CONFIG,\t/* Waiting for DLCI configuration from user */\n\tDLCI_CONFIGURE,\t\t/* Sending PN (for adaption > 1) */\n\tDLCI_OPENING,\t\t/* Sending SABM not seen UA */\n\tDLCI_OPEN,\t\t/* SABM/UA complete */\n\tDLCI_CLOSING,\t\t/* Sending DISC not seen UA/DM */\n};\n\nenum gsm_dlci_mode {\n\tDLCI_MODE_ABM,\t\t/* Normal Asynchronous Balanced Mode */\n\tDLCI_MODE_ADM,\t\t/* Asynchronous Disconnected Mode */\n};\n\n/*\n *\tEach active data link has a gsm_dlci structure associated which ties\n *\tthe link layer to an optional tty (if the tty side is open). To avoid\n *\tcomplexity right now these are only ever freed up when the mux is\n *\tshut down.\n *\n *\tAt the moment we don't free DLCI objects until the mux is torn down\n *\tthis avoid object life time issues but might be worth review later.\n */\n\nstruct gsm_dlci {\n\tstruct gsm_mux *gsm;\n\tint addr;\n\tenum gsm_dlci_state state;\n\tstruct mutex mutex;\n\n\t/* Link layer */\n\tenum gsm_dlci_mode mode;\n\tspinlock_t lock;\t/* Protects the internal state */\n\tstruct timer_list t1;\t/* Retransmit timer for SABM and UA */\n\tint retries;\n\t/* Uplink tty if active */\n\tstruct tty_port port;\t/* The tty bound to this DLCI if there is one */\n#define TX_SIZE\t\t4096    /* Must be power of 2. */\n\tstruct kfifo fifo;\t/* Queue fifo for the DLCI */\n\tint adaption;\t\t/* Adaption layer in use */\n\tint prev_adaption;\n\tu32 modem_rx;\t\t/* Our incoming virtual modem lines */\n\tu32 modem_tx;\t\t/* Our outgoing modem lines */\n\tunsigned int mtu;\n\tbool dead;\t\t/* Refuse re-open */\n\t/* Configuration */\n\tu8 prio;\t\t/* Priority */\n\tu8 ftype;\t\t/* Frame type */\n\tu8 k;\t\t\t/* Window size */\n\t/* Flow control */\n\tbool throttled;\t\t/* Private copy of throttle state */\n\tbool constipated;\t/* Throttle status for outgoing */\n\t/* Packetised I/O */\n\tstruct sk_buff *skb;\t/* Frame being sent */\n\tstruct sk_buff_head skb_list;\t/* Queued frames */\n\t/* Data handling callback */\n\tvoid (*data)(struct gsm_dlci *dlci, const u8 *data, int len);\n\tvoid (*prev_data)(struct gsm_dlci *dlci, const u8 *data, int len);\n\tstruct net_device *net; /* network interface, if created */\n};\n\n/*\n * Parameter bits used for parameter negotiation according to 3GPP 27.010\n * chapter 5.4.6.3.1.\n */\n\nstruct gsm_dlci_param_bits {\n\tu8 d_bits;\n\tu8 i_cl_bits;\n\tu8 p_bits;\n\tu8 t_bits;\n\t__le16 n_bits;\n\tu8 na_bits;\n\tu8 k_bits;\n};\n\nstatic_assert(sizeof(struct gsm_dlci_param_bits) == 8);\n\n#define PN_D_FIELD_DLCI\t\tGENMASK(5, 0)\n#define PN_I_CL_FIELD_FTYPE\tGENMASK(3, 0)\n#define PN_I_CL_FIELD_ADAPTION\tGENMASK(7, 4)\n#define PN_P_FIELD_PRIO\t\tGENMASK(5, 0)\n#define PN_T_FIELD_T1\t\tGENMASK(7, 0)\n#define PN_N_FIELD_N1\t\tGENMASK(15, 0)\n#define PN_NA_FIELD_N2\t\tGENMASK(7, 0)\n#define PN_K_FIELD_K\t\tGENMASK(2, 0)\n\n/* Total number of supported devices */\n#define GSM_TTY_MINORS\t\t256\n\n/* DLCI 0, 62/63 are special or reserved see gsmtty_open */\n\n#define NUM_DLCI\t\t64\n\n/*\n *\tDLCI 0 is used to pass control blocks out of band of the data\n *\tflow (and with a higher link priority). One command can be outstanding\n *\tat a time and we use this structure to manage them. They are created\n *\tand destroyed by the user context, and updated by the receive paths\n *\tand timers\n */\n\nstruct gsm_control {\n\tu8 cmd;\t\t/* Command we are issuing */\n\tu8 *data;\t/* Data for the command in case we retransmit */\n\tint len;\t/* Length of block for retransmission */\n\tint done;\t/* Done flag */\n\tint error;\t/* Error if any */\n};\n\nenum gsm_encoding {\n\tGSM_BASIC_OPT,\n\tGSM_ADV_OPT,\n};\n\nenum gsm_mux_state {\n\tGSM_SEARCH,\n\tGSM_START,\n\tGSM_ADDRESS,\n\tGSM_CONTROL,\n\tGSM_LEN,\n\tGSM_DATA,\n\tGSM_FCS,\n\tGSM_OVERRUN,\n\tGSM_LEN0,\n\tGSM_LEN1,\n\tGSM_SSOF,\n};\n\n/*\n *\tEach GSM mux we have is represented by this structure. If we are\n *\toperating as an ldisc then we use this structure as our ldisc\n *\tstate. We need to sort out lifetimes and locking with respect\n *\tto the gsm mux array. For now we don't free DLCI objects that\n *\thave been instantiated until the mux itself is terminated.\n *\n *\tTo consider further: tty open versus mux shutdown.\n */\n\nstruct gsm_mux {\n\tstruct tty_struct *tty;\t\t/* The tty our ldisc is bound to */\n\tspinlock_t lock;\n\tstruct mutex mutex;\n\tunsigned int num;\n\tstruct kref ref;\n\n\t/* Events on the GSM channel */\n\twait_queue_head_t event;\n\n\t/* ldisc send work */\n\tstruct work_struct tx_work;\n\n\t/* Bits for GSM mode decoding */\n\n\t/* Framing Layer */\n\tunsigned char *buf;\n\tenum gsm_mux_state state;\n\tunsigned int len;\n\tunsigned int address;\n\tunsigned int count;\n\tbool escape;\n\tenum gsm_encoding encoding;\n\tu8 control;\n\tu8 fcs;\n\tu8 *txframe;\t\t\t/* TX framing buffer */\n\n\t/* Method for the receiver side */\n\tvoid (*receive)(struct gsm_mux *gsm, u8 ch);\n\n\t/* Link Layer */\n\tunsigned int mru;\n\tunsigned int mtu;\n\tint initiator;\t\t\t/* Did we initiate connection */\n\tbool dead;\t\t\t/* Has the mux been shut down */\n\tstruct gsm_dlci *dlci[NUM_DLCI];\n\tint old_c_iflag;\t\t/* termios c_iflag value before attach */\n\tbool constipated;\t\t/* Asked by remote to shut up */\n\tbool has_devices;\t\t/* Devices were registered */\n\n\tspinlock_t tx_lock;\n\tunsigned int tx_bytes;\t\t/* TX data outstanding */\n#define TX_THRESH_HI\t\t8192\n#define TX_THRESH_LO\t\t2048\n\tstruct list_head tx_ctrl_list;\t/* Pending control packets */\n\tstruct list_head tx_data_list;\t/* Pending data packets */\n\n\t/* Control messages */\n\tstruct timer_list kick_timer;\t/* Kick TX queuing on timeout */\n\tstruct timer_list t2_timer;\t/* Retransmit timer for commands */\n\tint cretries;\t\t\t/* Command retry counter */\n\tstruct gsm_control *pending_cmd;/* Our current pending command */\n\tspinlock_t control_lock;\t/* Protects the pending command */\n\n\t/* Keep-alive */\n\tstruct timer_list ka_timer;\t/* Keep-alive response timer */\n\tu8 ka_num;\t\t\t/* Keep-alive match pattern */\n\tsigned int ka_retries;\t\t/* Keep-alive retry counter, -1 if not yet initialized */\n\n\t/* Configuration */\n\tint adaption;\t\t/* 1 or 2 supported */\n\tu8 ftype;\t\t/* UI or UIH */\n\tint t1, t2;\t\t/* Timers in 1/100th of a sec */\n\tunsigned int t3;\t/* Power wake-up timer in seconds. */\n\tint n2;\t\t\t/* Retry count */\n\tu8 k;\t\t\t/* Window size */\n\tbool wait_config;\t/* Wait for configuration by ioctl before DLCI open */\n\tu32 keep_alive;\t\t/* Control channel keep-alive in 10ms */\n\n\t/* Statistics (not currently exposed) */\n\tunsigned long bad_fcs;\n\tunsigned long malformed;\n\tunsigned long io_error;\n\tunsigned long bad_size;\n\tunsigned long unsupported;\n};\n\n\n/*\n *\tMux objects - needed so that we can translate a tty index into the\n *\trelevant mux and DLCI.\n */\n\n#define MAX_MUX\t\t4\t\t\t/* 256 minors */\nstatic struct gsm_mux *gsm_mux[MAX_MUX];\t/* GSM muxes */\nstatic DEFINE_SPINLOCK(gsm_mux_lock);\n\nstatic struct tty_driver *gsm_tty_driver;\n\n/*\n *\tThis section of the driver logic implements the GSM encodings\n *\tboth the basic and the 'advanced'. Reliable transport is not\n *\tsupported.\n */\n\n#define CR\t\t\t0x02\n#define EA\t\t\t0x01\n#define\tPF\t\t\t0x10\n\n/* I is special: the rest are ..*/\n#define RR\t\t\t0x01\n#define UI\t\t\t0x03\n#define RNR\t\t\t0x05\n#define REJ\t\t\t0x09\n#define DM\t\t\t0x0F\n#define SABM\t\t\t0x2F\n#define DISC\t\t\t0x43\n#define UA\t\t\t0x63\n#define\tUIH\t\t\t0xEF\n\n/* Channel commands */\n#define CMD_NSC\t\t\t0x09\n#define CMD_TEST\t\t0x11\n#define CMD_PSC\t\t\t0x21\n#define CMD_RLS\t\t\t0x29\n#define CMD_FCOFF\t\t0x31\n#define CMD_PN\t\t\t0x41\n#define CMD_RPN\t\t\t0x49\n#define CMD_FCON\t\t0x51\n#define CMD_CLD\t\t\t0x61\n#define CMD_SNC\t\t\t0x69\n#define CMD_MSC\t\t\t0x71\n\n/* Virtual modem bits */\n#define MDM_FC\t\t\t0x01\n#define MDM_RTC\t\t\t0x02\n#define MDM_RTR\t\t\t0x04\n#define MDM_IC\t\t\t0x20\n#define MDM_DV\t\t\t0x40\n\n#define GSM0_SOF\t\t0xF9\n#define GSM1_SOF\t\t0x7E\n#define GSM1_ESCAPE\t\t0x7D\n#define GSM1_ESCAPE_BITS\t0x20\n#define XON\t\t\t0x11\n#define XOFF\t\t\t0x13\n#define ISO_IEC_646_MASK\t0x7F\n\nstatic const struct tty_port_operations gsm_port_ops;\n\n/*\n *\tCRC table for GSM 0710\n */\n\nstatic const u8 gsm_fcs8[256] = {\n\t0x00, 0x91, 0xE3, 0x72, 0x07, 0x96, 0xE4, 0x75,\n\t0x0E, 0x9F, 0xED, 0x7C, 0x09, 0x98, 0xEA, 0x7B,\n\t0x1C, 0x8D, 0xFF, 0x6E, 0x1B, 0x8A, 0xF8, 0x69,\n\t0x12, 0x83, 0xF1, 0x60, 0x15, 0x84, 0xF6, 0x67,\n\t0x38, 0xA9, 0xDB, 0x4A, 0x3F, 0xAE, 0xDC, 0x4D,\n\t0x36, 0xA7, 0xD5, 0x44, 0x31, 0xA0, 0xD2, 0x43,\n\t0x24, 0xB5, 0xC7, 0x56, 0x23, 0xB2, 0xC0, 0x51,\n\t0x2A, 0xBB, 0xC9, 0x58, 0x2D, 0xBC, 0xCE, 0x5F,\n\t0x70, 0xE1, 0x93, 0x02, 0x77, 0xE6, 0x94, 0x05,\n\t0x7E, 0xEF, 0x9D, 0x0C, 0x79, 0xE8, 0x9A, 0x0B,\n\t0x6C, 0xFD, 0x8F, 0x1E, 0x6B, 0xFA, 0x88, 0x19,\n\t0x62, 0xF3, 0x81, 0x10, 0x65, 0xF4, 0x86, 0x17,\n\t0x48, 0xD9, 0xAB, 0x3A, 0x4F, 0xDE, 0xAC, 0x3D,\n\t0x46, 0xD7, 0xA5, 0x34, 0x41, 0xD0, 0xA2, 0x33,\n\t0x54, 0xC5, 0xB7, 0x26, 0x53, 0xC2, 0xB0, 0x21,\n\t0x5A, 0xCB, 0xB9, 0x28, 0x5D, 0xCC, 0xBE, 0x2F,\n\t0xE0, 0x71, 0x03, 0x92, 0xE7, 0x76, 0x04, 0x95,\n\t0xEE, 0x7F, 0x0D, 0x9C, 0xE9, 0x78, 0x0A, 0x9B,\n\t0xFC, 0x6D, 0x1F, 0x8E, 0xFB, 0x6A, 0x18, 0x89,\n\t0xF2, 0x63, 0x11, 0x80, 0xF5, 0x64, 0x16, 0x87,\n\t0xD8, 0x49, 0x3B, 0xAA, 0xDF, 0x4E, 0x3C, 0xAD,\n\t0xD6, 0x47, 0x35, 0xA4, 0xD1, 0x40, 0x32, 0xA3,\n\t0xC4, 0x55, 0x27, 0xB6, 0xC3, 0x52, 0x20, 0xB1,\n\t0xCA, 0x5B, 0x29, 0xB8, 0xCD, 0x5C, 0x2E, 0xBF,\n\t0x90, 0x01, 0x73, 0xE2, 0x97, 0x06, 0x74, 0xE5,\n\t0x9E, 0x0F, 0x7D, 0xEC, 0x99, 0x08, 0x7A, 0xEB,\n\t0x8C, 0x1D, 0x6F, 0xFE, 0x8B, 0x1A, 0x68, 0xF9,\n\t0x82, 0x13, 0x61, 0xF0, 0x85, 0x14, 0x66, 0xF7,\n\t0xA8, 0x39, 0x4B, 0xDA, 0xAF, 0x3E, 0x4C, 0xDD,\n\t0xA6, 0x37, 0x45, 0xD4, 0xA1, 0x30, 0x42, 0xD3,\n\t0xB4, 0x25, 0x57, 0xC6, 0xB3, 0x22, 0x50, 0xC1,\n\t0xBA, 0x2B, 0x59, 0xC8, 0xBD, 0x2C, 0x5E, 0xCF\n};\n\n#define INIT_FCS\t0xFF\n#define GOOD_FCS\t0xCF\n\nstatic void gsm_dlci_close(struct gsm_dlci *dlci);\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len);\nstatic int gsm_modem_update(struct gsm_dlci *dlci, u8 brk);\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\n\t\t\t\t\t\t\t\tu8 ctrl);\nstatic int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg);\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr);\nstatic void gsmld_write_trigger(struct gsm_mux *gsm);\nstatic void gsmld_write_task(struct work_struct *work);\n\n/**\n *\tgsm_fcs_add\t-\tupdate FCS\n *\t@fcs: Current FCS\n *\t@c: Next data\n *\n *\tUpdate the FCS to include c. Uses the algorithm in the specification\n *\tnotes.\n */\n\nstatic inline u8 gsm_fcs_add(u8 fcs, u8 c)\n{\n\treturn gsm_fcs8[fcs ^ c];\n}\n\n/**\n *\tgsm_fcs_add_block\t-\tupdate FCS for a block\n *\t@fcs: Current FCS\n *\t@c: buffer of data\n *\t@len: length of buffer\n *\n *\tUpdate the FCS to include c. Uses the algorithm in the specification\n *\tnotes.\n */\n\nstatic inline u8 gsm_fcs_add_block(u8 fcs, u8 *c, int len)\n{\n\twhile (len--)\n\t\tfcs = gsm_fcs8[fcs ^ *c++];\n\treturn fcs;\n}\n\n/**\n *\tgsm_read_ea\t\t-\tread a byte into an EA\n *\t@val: variable holding value\n *\t@c: byte going into the EA\n *\n *\tProcesses one byte of an EA. Updates the passed variable\n *\tand returns 1 if the EA is now completely read\n */\n\nstatic int gsm_read_ea(unsigned int *val, u8 c)\n{\n\t/* Add the next 7 bits into the value */\n\t*val <<= 7;\n\t*val |= c >> 1;\n\t/* Was this the last byte of the EA 1 = yes*/\n\treturn c & EA;\n}\n\n/**\n *\tgsm_read_ea_val\t-\tread a value until EA\n *\t@val: variable holding value\n *\t@data: buffer of data\n *\t@dlen: length of data\n *\n *\tProcesses an EA value. Updates the passed variable and\n *\treturns the processed data length.\n */\nstatic unsigned int gsm_read_ea_val(unsigned int *val, const u8 *data, int dlen)\n{\n\tunsigned int len = 0;\n\n\tfor (; dlen > 0; dlen--) {\n\t\tlen++;\n\t\tif (gsm_read_ea(val, *data++))\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\n/**\n *\tgsm_encode_modem\t-\tencode modem data bits\n *\t@dlci: DLCI to encode from\n *\n *\tReturns the correct GSM encoded modem status bits (6 bit field) for\n *\tthe current status of the DLCI and attached tty object\n */\n\nstatic u8 gsm_encode_modem(const struct gsm_dlci *dlci)\n{\n\tu8 modembits = 0;\n\t/* FC is true flow control not modem bits */\n\tif (dlci->throttled)\n\t\tmodembits |= MDM_FC;\n\tif (dlci->modem_tx & TIOCM_DTR)\n\t\tmodembits |= MDM_RTC;\n\tif (dlci->modem_tx & TIOCM_RTS)\n\t\tmodembits |= MDM_RTR;\n\tif (dlci->modem_tx & TIOCM_RI)\n\t\tmodembits |= MDM_IC;\n\tif (dlci->modem_tx & TIOCM_CD || dlci->gsm->initiator)\n\t\tmodembits |= MDM_DV;\n\t/* special mappings for passive side to operate as UE */\n\tif (dlci->modem_tx & TIOCM_OUT1)\n\t\tmodembits |= MDM_IC;\n\tif (dlci->modem_tx & TIOCM_OUT2)\n\t\tmodembits |= MDM_DV;\n\treturn modembits;\n}\n\nstatic void gsm_hex_dump_bytes(const char *fname, const u8 *data,\n\t\t\t       unsigned long len)\n{\n\tchar *prefix;\n\n\tif (!fname) {\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1, data, len,\n\t\t\t       true);\n\t\treturn;\n\t}\n\n\tprefix = kasprintf(GFP_ATOMIC, \"%s: \", fname);\n\tif (!prefix)\n\t\treturn;\n\tprint_hex_dump(KERN_INFO, prefix, DUMP_PREFIX_OFFSET, 16, 1, data, len,\n\t\t       true);\n\tkfree(prefix);\n}\n\n/**\n * gsm_encode_params\t-\tencode DLCI parameters\n * @dlci: DLCI to encode from\n * @params: buffer to fill with the encoded parameters\n *\n * Encodes the parameters according to GSM 07.10 section 5.4.6.3.1\n * table 3.\n */\nstatic int gsm_encode_params(const struct gsm_dlci *dlci,\n\t\t\t     struct gsm_dlci_param_bits *params)\n{\n\tconst struct gsm_mux *gsm = dlci->gsm;\n\tunsigned int i, cl;\n\n\tswitch (dlci->ftype) {\n\tcase UIH:\n\t\ti = 0; /* UIH */\n\t\tbreak;\n\tcase UI:\n\t\ti = 1; /* UI */\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unsupported frame type %d\\n\", dlci->ftype);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tcl = 0; /* convergence layer type 1 */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits. */\n\t\tcl = 1; /* convergence layer type 2 */\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unsupported adaption %d\\n\", dlci->adaption);\n\t\treturn -EINVAL;\n\t}\n\n\tparams->d_bits = FIELD_PREP(PN_D_FIELD_DLCI, dlci->addr);\n\t/* UIH, convergence layer type 1 */\n\tparams->i_cl_bits = FIELD_PREP(PN_I_CL_FIELD_FTYPE, i) |\n\t\t\t    FIELD_PREP(PN_I_CL_FIELD_ADAPTION, cl);\n\tparams->p_bits = FIELD_PREP(PN_P_FIELD_PRIO, dlci->prio);\n\tparams->t_bits = FIELD_PREP(PN_T_FIELD_T1, gsm->t1);\n\tparams->n_bits = cpu_to_le16(FIELD_PREP(PN_N_FIELD_N1, dlci->mtu));\n\tparams->na_bits = FIELD_PREP(PN_NA_FIELD_N2, gsm->n2);\n\tparams->k_bits = FIELD_PREP(PN_K_FIELD_K, dlci->k);\n\n\treturn 0;\n}\n\n/**\n *\tgsm_register_devices\t-\tregister all tty devices for a given mux index\n *\n *\t@driver: the tty driver that describes the tty devices\n *\t@index:  the mux number is used to calculate the minor numbers of the\n *\t         ttys for this mux and may differ from the position in the\n *\t         mux array.\n */\nstatic int gsm_register_devices(struct tty_driver *driver, unsigned int index)\n{\n\tstruct device *dev;\n\tint i;\n\tunsigned int base;\n\n\tif (!driver || index >= MAX_MUX)\n\t\treturn -EINVAL;\n\n\tbase = index * NUM_DLCI; /* first minor for this index */\n\tfor (i = 1; i < NUM_DLCI; i++) {\n\t\t/* Don't register device 0 - this is the control channel\n\t\t * and not a usable tty interface\n\t\t */\n\t\tdev = tty_register_device(gsm_tty_driver, base + i, NULL);\n\t\tif (IS_ERR(dev)) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s failed to register device minor %u\",\n\t\t\t\t\t__func__, base + i);\n\t\t\tfor (i--; i >= 1; i--)\n\t\t\t\ttty_unregister_device(gsm_tty_driver, base + i);\n\t\t\treturn PTR_ERR(dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tgsm_unregister_devices\t-\tunregister all tty devices for a given mux index\n *\n *\t@driver: the tty driver that describes the tty devices\n *\t@index:  the mux number is used to calculate the minor numbers of the\n *\t         ttys for this mux and may differ from the position in the\n *\t         mux array.\n */\nstatic void gsm_unregister_devices(struct tty_driver *driver,\n\t\t\t\t   unsigned int index)\n{\n\tint i;\n\tunsigned int base;\n\n\tif (!driver || index >= MAX_MUX)\n\t\treturn;\n\n\tbase = index * NUM_DLCI; /* first minor for this index */\n\tfor (i = 1; i < NUM_DLCI; i++) {\n\t\t/* Don't unregister device 0 - this is the control\n\t\t * channel and not a usable tty interface\n\t\t */\n\t\ttty_unregister_device(gsm_tty_driver, base + i);\n\t}\n}\n\n/**\n *\tgsm_print_packet\t-\tdisplay a frame for debug\n *\t@hdr: header to print before decode\n *\t@addr: address EA from the frame\n *\t@cr: C/R bit seen as initiator\n *\t@control: control including PF bit\n *\t@data: following data bytes\n *\t@dlen: length of data\n *\n *\tDisplays a packet in human readable format for debugging purposes. The\n *\tstyle is based on amateur radio LAP-B dump display.\n */\n\nstatic void gsm_print_packet(const char *hdr, int addr, int cr,\n\t\t\t\t\tu8 control, const u8 *data, int dlen)\n{\n\tif (!(debug & DBG_DUMP))\n\t\treturn;\n\t/* Only show user payload frames if debug & DBG_PAYLOAD */\n\tif (!(debug & DBG_PAYLOAD) && addr != 0)\n\t\tif ((control & ~PF) == UI || (control & ~PF) == UIH)\n\t\t\treturn;\n\n\tpr_info(\"%s %d) %c: \", hdr, addr, \"RC\"[cr]);\n\n\tswitch (control & ~PF) {\n\tcase SABM:\n\t\tpr_cont(\"SABM\");\n\t\tbreak;\n\tcase UA:\n\t\tpr_cont(\"UA\");\n\t\tbreak;\n\tcase DISC:\n\t\tpr_cont(\"DISC\");\n\t\tbreak;\n\tcase DM:\n\t\tpr_cont(\"DM\");\n\t\tbreak;\n\tcase UI:\n\t\tpr_cont(\"UI\");\n\t\tbreak;\n\tcase UIH:\n\t\tpr_cont(\"UIH\");\n\t\tbreak;\n\tdefault:\n\t\tif (!(control & 0x01)) {\n\t\t\tpr_cont(\"I N(S)%d N(R)%d\",\n\t\t\t\t(control & 0x0E) >> 1, (control & 0xE0) >> 5);\n\t\t} else switch (control & 0x0F) {\n\t\t\tcase RR:\n\t\t\t\tpr_cont(\"RR(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tcase RNR:\n\t\t\t\tpr_cont(\"RNR(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tcase REJ:\n\t\t\t\tpr_cont(\"REJ(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_cont(\"[%02X]\", control);\n\t\t}\n\t}\n\n\tif (control & PF)\n\t\tpr_cont(\"(P)\");\n\telse\n\t\tpr_cont(\"(F)\");\n\n\tgsm_hex_dump_bytes(NULL, data, dlen);\n}\n\n\n/*\n *\tLink level transmission side\n */\n\n/**\n *\tgsm_stuff_frame\t-\tbytestuff a packet\n *\t@input: input buffer\n *\t@output: output buffer\n *\t@len: length of input\n *\n *\tExpand a buffer by bytestuffing it. The worst case size change\n *\tis doubling and the caller is responsible for handing out\n *\tsuitable sized buffers.\n */\n\nstatic int gsm_stuff_frame(const u8 *input, u8 *output, int len)\n{\n\tint olen = 0;\n\twhile (len--) {\n\t\tif (*input == GSM1_SOF || *input == GSM1_ESCAPE\n\t\t    || (*input & ISO_IEC_646_MASK) == XON\n\t\t    || (*input & ISO_IEC_646_MASK) == XOFF) {\n\t\t\t*output++ = GSM1_ESCAPE;\n\t\t\t*output++ = *input++ ^ GSM1_ESCAPE_BITS;\n\t\t\tolen++;\n\t\t} else\n\t\t\t*output++ = *input++;\n\t\tolen++;\n\t}\n\treturn olen;\n}\n\n/**\n *\tgsm_send\t-\tsend a control frame\n *\t@gsm: our GSM mux\n *\t@addr: address for control frame\n *\t@cr: command/response bit seen as initiator\n *\t@control:  control byte including PF bit\n *\n *\tFormat up and transmit a control frame. These should be transmitted\n *\tahead of data when they are needed.\n */\nstatic int gsm_send(struct gsm_mux *gsm, int addr, int cr, int control)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint ocr;\n\tunsigned long flags;\n\n\tmsg = gsm_data_alloc(gsm, addr, 0, control);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t/* toggle C/R coding if not initiator */\n\tocr = cr ^ (gsm->initiator ? 0 : 1);\n\n\tmsg->data -= 3;\n\tdp = msg->data;\n\t*dp++ = (addr << 2) | (ocr << 1) | EA;\n\t*dp++ = control;\n\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\t*dp++ = EA; /* Length of data = 0 */\n\n\t*dp = 0xFF - gsm_fcs_add_block(INIT_FCS, msg->data, dp - msg->data);\n\tmsg->len = (dp - msg->data) + 1;\n\n\tgsm_print_packet(\"Q->\", addr, cr, control, NULL, 0);\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tlist_add_tail(&msg->list, &gsm->tx_ctrl_list);\n\tgsm->tx_bytes += msg->len;\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\tgsmld_write_trigger(gsm);\n\n\treturn 0;\n}\n\n/**\n *\tgsm_dlci_clear_queues\t-\tremove outstanding data for a DLCI\n *\t@gsm: mux\n *\t@dlci: clear for this DLCI\n *\n *\tClears the data queues for a given DLCI.\n */\nstatic void gsm_dlci_clear_queues(struct gsm_mux *gsm, struct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg, *nmsg;\n\tint addr = dlci->addr;\n\tunsigned long flags;\n\n\t/* Clear DLCI write fifo first */\n\tspin_lock_irqsave(&dlci->lock, flags);\n\tkfifo_reset(&dlci->fifo);\n\tspin_unlock_irqrestore(&dlci->lock, flags);\n\n\t/* Clear data packets in MUX write queue */\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_data_list, list) {\n\t\tif (msg->addr != addr)\n\t\t\tcontinue;\n\t\tgsm->tx_bytes -= msg->len;\n\t\tlist_del(&msg->list);\n\t\tkfree(msg);\n\t}\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n}\n\n/**\n *\tgsm_response\t-\tsend a control response\n *\t@gsm: our GSM mux\n *\t@addr: address for control frame\n *\t@control:  control byte including PF bit\n *\n *\tFormat up and transmit a link level response frame.\n */\n\nstatic inline void gsm_response(struct gsm_mux *gsm, int addr, int control)\n{\n\tgsm_send(gsm, addr, 0, control);\n}\n\n/**\n *\tgsm_command\t-\tsend a control command\n *\t@gsm: our GSM mux\n *\t@addr: address for control frame\n *\t@control:  control byte including PF bit\n *\n *\tFormat up and transmit a link level command frame.\n */\n\nstatic inline void gsm_command(struct gsm_mux *gsm, int addr, int control)\n{\n\tgsm_send(gsm, addr, 1, control);\n}\n\n/* Data transmission */\n\n#define HDR_LEN\t\t6\t/* ADDR CTRL [LEN.2] DATA FCS */\n\n/**\n *\tgsm_data_alloc\t\t-\tallocate data frame\n *\t@gsm: GSM mux\n *\t@addr: DLCI address\n *\t@len: length excluding header and FCS\n *\t@ctrl: control byte\n *\n *\tAllocate a new data buffer for sending frames with data. Space is left\n *\tat the front for header bytes but that is treated as an implementation\n *\tdetail and not for the high level code to use\n */\n\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\n\t\t\t\t\t\t\t\tu8 ctrl)\n{\n\tstruct gsm_msg *m = kmalloc(sizeof(struct gsm_msg) + len + HDR_LEN,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\tif (m == NULL)\n\t\treturn NULL;\n\tm->data = m->buffer + HDR_LEN - 1;\t/* Allow for FCS */\n\tm->len = len;\n\tm->addr = addr;\n\tm->ctrl = ctrl;\n\tINIT_LIST_HEAD(&m->list);\n\treturn m;\n}\n\n/**\n *\tgsm_send_packet\t-\tsends a single packet\n *\t@gsm: GSM Mux\n *\t@msg: packet to send\n *\n *\tThe given packet is encoded and sent out. No memory is freed.\n *\tThe caller must hold the gsm tx lock.\n */\nstatic int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg)\n{\n\tint len, ret;\n\n\n\tif (gsm->encoding == GSM_BASIC_OPT) {\n\t\tgsm->txframe[0] = GSM0_SOF;\n\t\tmemcpy(gsm->txframe + 1, msg->data, msg->len);\n\t\tgsm->txframe[msg->len + 1] = GSM0_SOF;\n\t\tlen = msg->len + 2;\n\t} else {\n\t\tgsm->txframe[0] = GSM1_SOF;\n\t\tlen = gsm_stuff_frame(msg->data, gsm->txframe + 1, msg->len);\n\t\tgsm->txframe[len + 1] = GSM1_SOF;\n\t\tlen += 2;\n\t}\n\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, gsm->txframe, len);\n\tgsm_print_packet(\"-->\", msg->addr, gsm->initiator, msg->ctrl, msg->data,\n\t\t\t msg->len);\n\n\tret = gsmld_output(gsm, gsm->txframe, len);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/* FIXME: Can eliminate one SOF in many more cases */\n\tgsm->tx_bytes -= msg->len;\n\n\treturn 0;\n}\n\n/**\n *\tgsm_is_flow_ctrl_msg\t-\tchecks if flow control message\n *\t@msg: message to check\n *\n *\tReturns true if the given message is a flow control command of the\n *\tcontrol channel. False is returned in any other case.\n */\nstatic bool gsm_is_flow_ctrl_msg(struct gsm_msg *msg)\n{\n\tunsigned int cmd;\n\n\tif (msg->addr > 0)\n\t\treturn false;\n\n\tswitch (msg->ctrl & ~PF) {\n\tcase UI:\n\tcase UIH:\n\t\tcmd = 0;\n\t\tif (gsm_read_ea_val(&cmd, msg->data + 2, msg->len - 2) < 1)\n\t\t\tbreak;\n\t\tswitch (cmd & ~PF) {\n\t\tcase CMD_FCOFF:\n\t\tcase CMD_FCON:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n/**\n *\tgsm_data_kick\t-\tpoke the queue\n *\t@gsm: GSM Mux\n *\n *\tThe tty device has called us to indicate that room has appeared in\n *\tthe transmit queue. Ram more data into the pipe if we have any.\n *\tIf we have been flow-stopped by a CMD_FCOFF, then we can only\n *\tsend messages on DLCI0 until CMD_FCON. The caller must hold\n *\tthe gsm tx lock.\n */\nstatic int gsm_data_kick(struct gsm_mux *gsm)\n{\n\tstruct gsm_msg *msg, *nmsg;\n\tstruct gsm_dlci *dlci;\n\tint ret;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\n\n\t/* Serialize control messages and control channel messages first */\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_ctrl_list, list) {\n\t\tif (gsm->constipated && !gsm_is_flow_ctrl_msg(msg))\n\t\t\tcontinue;\n\t\tret = gsm_send_packet(gsm, msg);\n\t\tswitch (ret) {\n\t\tcase -ENOSPC:\n\t\t\treturn -ENOSPC;\n\t\tcase -ENODEV:\n\t\t\t/* ldisc not open */\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (ret >= 0) {\n\t\t\t\tlist_del(&msg->list);\n\t\t\t\tkfree(msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (gsm->constipated)\n\t\treturn -EAGAIN;\n\n\t/* Serialize other channels */\n\tif (list_empty(&gsm->tx_data_list))\n\t\treturn 0;\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_data_list, list) {\n\t\tdlci = gsm->dlci[msg->addr];\n\t\t/* Send only messages for DLCIs with valid state */\n\t\tif (dlci->state != DLCI_OPEN) {\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tret = gsm_send_packet(gsm, msg);\n\t\tswitch (ret) {\n\t\tcase -ENOSPC:\n\t\t\treturn -ENOSPC;\n\t\tcase -ENODEV:\n\t\t\t/* ldisc not open */\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (ret >= 0) {\n\t\t\t\tlist_del(&msg->list);\n\t\t\t\tkfree(msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/**\n *\t__gsm_data_queue\t\t-\tqueue a UI or UIH frame\n *\t@dlci: DLCI sending the data\n *\t@msg: message queued\n *\n *\tAdd data to the transmit queue and try and get stuff moving\n *\tout of the mux tty if not already doing so. The Caller must hold\n *\tthe gsm tx lock.\n */\n\nstatic void __gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tu8 *dp = msg->data;\n\tu8 *fcs = dp + msg->len;\n\n\t/* Fill in the header */\n\tif (gsm->encoding == GSM_BASIC_OPT) {\n\t\tif (msg->len < 128)\n\t\t\t*--dp = (msg->len << 1) | EA;\n\t\telse {\n\t\t\t*--dp = (msg->len >> 7);\t/* bits 7 - 15 */\n\t\t\t*--dp = (msg->len & 127) << 1;\t/* bits 0 - 6 */\n\t\t}\n\t}\n\n\t*--dp = msg->ctrl;\n\tif (gsm->initiator)\n\t\t*--dp = (msg->addr << 2) | CR | EA;\n\telse\n\t\t*--dp = (msg->addr << 2) | EA;\n\t*fcs = gsm_fcs_add_block(INIT_FCS, dp , msg->data - dp);\n\t/* Ugly protocol layering violation */\n\tif (msg->ctrl == UI || msg->ctrl == (UI|PF))\n\t\t*fcs = gsm_fcs_add_block(*fcs, msg->data, msg->len);\n\t*fcs = 0xFF - *fcs;\n\n\tgsm_print_packet(\"Q> \", msg->addr, gsm->initiator, msg->ctrl,\n\t\t\t\t\t\t\tmsg->data, msg->len);\n\n\t/* Move the header back and adjust the length, also allow for the FCS\n\t   now tacked on the end */\n\tmsg->len += (msg->data - dp) + 1;\n\tmsg->data = dp;\n\n\t/* Add to the actual output queue */\n\tswitch (msg->ctrl & ~PF) {\n\tcase UI:\n\tcase UIH:\n\t\tif (msg->addr > 0) {\n\t\t\tlist_add_tail(&msg->list, &gsm->tx_data_list);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tlist_add_tail(&msg->list, &gsm->tx_ctrl_list);\n\t\tbreak;\n\t}\n\tgsm->tx_bytes += msg->len;\n\n\tgsmld_write_trigger(gsm);\n\tmod_timer(&gsm->kick_timer, jiffies + 10 * gsm->t1 * HZ / 100);\n}\n\n/**\n *\tgsm_data_queue\t\t-\tqueue a UI or UIH frame\n *\t@dlci: DLCI sending the data\n *\t@msg: message queued\n *\n *\tAdd data to the transmit queue and try and get stuff moving\n *\tout of the mux tty if not already doing so. Take the\n *\tthe gsm tx lock and dlci lock.\n */\n\nstatic void gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\n\t__gsm_data_queue(dlci, msg);\n\tspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\n}\n\n/**\n *\tgsm_dlci_data_output\t-\ttry and push data out of a DLCI\n *\t@gsm: mux\n *\t@dlci: the DLCI to pull data from\n *\n *\tPull data from a DLCI and send it into the transmit queue if there\n *\tis data. Keep to the MRU of the mux. This path handles the usual tty\n *\tinterface which is a byte stream with optional modem data.\n *\n *\tCaller must hold the tx_lock of the mux.\n */\n\nstatic int gsm_dlci_data_output(struct gsm_mux *gsm, struct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint h, len, size;\n\n\t/* for modem bits without break data */\n\th = ((dlci->adaption == 1) ? 0 : 1);\n\n\tlen = kfifo_len(&dlci->fifo);\n\tif (len == 0)\n\t\treturn 0;\n\n\t/* MTU/MRU count only the data bits but watch adaption mode */\n\tif ((len + h) > dlci->mtu)\n\t\tlen = dlci->mtu - h;\n\n\tsize = len + h;\n\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tdp = msg->data;\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits.\n\t\t * Always one byte as we never send inline break data\n\t\t */\n\t\t*dp++ = (gsm_encode_modem(dlci) << 1) | EA;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported adaption %d\\n\", __func__,\n\t\t       dlci->adaption);\n\t\tbreak;\n\t}\n\n\tWARN_ON(len != kfifo_out_locked(&dlci->fifo, dp, len,\n\t\t&dlci->lock));\n\n\t/* Notify upper layer about available send space. */\n\ttty_port_tty_wakeup(&dlci->port);\n\n\t__gsm_data_queue(dlci, msg);\n\t/* Bytes of data we used up */\n\treturn size;\n}\n\n/**\n *\tgsm_dlci_data_output_framed  -\ttry and push data out of a DLCI\n *\t@gsm: mux\n *\t@dlci: the DLCI to pull data from\n *\n *\tPull data from a DLCI and send it into the transmit queue if there\n *\tis data. Keep to the MRU of the mux. This path handles framed data\n *\tqueued as skbuffs to the DLCI.\n *\n *\tCaller must hold the tx_lock of the mux.\n */\n\nstatic int gsm_dlci_data_output_framed(struct gsm_mux *gsm,\n\t\t\t\t\t\tstruct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint len, size;\n\tint last = 0, first = 0;\n\tint overhead = 0;\n\n\t/* One byte per frame is used for B/F flags */\n\tif (dlci->adaption == 4)\n\t\toverhead = 1;\n\n\t/* dlci->skb is locked by tx_lock */\n\tif (dlci->skb == NULL) {\n\t\tdlci->skb = skb_dequeue_tail(&dlci->skb_list);\n\t\tif (dlci->skb == NULL)\n\t\t\treturn 0;\n\t\tfirst = 1;\n\t}\n\tlen = dlci->skb->len + overhead;\n\n\t/* MTU/MRU count only the data bits */\n\tif (len > dlci->mtu) {\n\t\tif (dlci->adaption == 3) {\n\t\t\t/* Over long frame, bin it */\n\t\t\tdev_kfree_skb_any(dlci->skb);\n\t\t\tdlci->skb = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tlen = dlci->mtu;\n\t} else\n\t\tlast = 1;\n\n\tsize = len + overhead;\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (msg == NULL) {\n\t\tskb_queue_tail(&dlci->skb_list, dlci->skb);\n\t\tdlci->skb = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tdp = msg->data;\n\n\tif (dlci->adaption == 4) { /* Interruptible framed (Packetised Data) */\n\t\t/* Flag byte to carry the start/end info */\n\t\t*dp++ = last << 7 | first << 6 | 1;\t/* EA */\n\t\tlen--;\n\t}\n\tmemcpy(dp, dlci->skb->data, len);\n\tskb_pull(dlci->skb, len);\n\t__gsm_data_queue(dlci, msg);\n\tif (last) {\n\t\tdev_kfree_skb_any(dlci->skb);\n\t\tdlci->skb = NULL;\n\t}\n\treturn size;\n}\n\n/**\n *\tgsm_dlci_modem_output\t-\ttry and push modem status out of a DLCI\n *\t@gsm: mux\n *\t@dlci: the DLCI to pull modem status from\n *\t@brk: break signal\n *\n *\tPush an empty frame in to the transmit queue to update the modem status\n *\tbits and to transmit an optional break.\n *\n *\tCaller must hold the tx_lock of the mux.\n */\n\nstatic int gsm_dlci_modem_output(struct gsm_mux *gsm, struct gsm_dlci *dlci,\n\t\t\t\t u8 brk)\n{\n\tu8 *dp = NULL;\n\tstruct gsm_msg *msg;\n\tint size = 0;\n\n\t/* for modem bits without break data */\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits. */\n\t\tsize++;\n\t\tif (brk > 0)\n\t\t\tsize++;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported adaption %d\\n\", __func__,\n\t\t       dlci->adaption);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (!msg) {\n\t\tpr_err(\"%s: gsm_data_alloc error\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdp = msg->data;\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits. */\n\t\tif (brk == 0) {\n\t\t\t*dp++ = (gsm_encode_modem(dlci) << 1) | EA;\n\t\t} else {\n\t\t\t*dp++ = gsm_encode_modem(dlci) << 1;\n\t\t\t*dp++ = (brk << 4) | 2 | EA; /* Length, Break, EA */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Handled above */\n\t\tbreak;\n\t}\n\n\t__gsm_data_queue(dlci, msg);\n\treturn size;\n}\n\n/**\n *\tgsm_dlci_data_sweep\t\t-\tlook for data to send\n *\t@gsm: the GSM mux\n *\n *\tSweep the GSM mux channels in priority order looking for ones with\n *\tdata to send. We could do with optimising this scan a bit. We aim\n *\tto fill the queue totally or up to TX_THRESH_HI bytes. Once we hit\n *\tTX_THRESH_LO we get called again\n *\n *\tFIXME: We should round robin between groups and in theory you can\n *\trenegotiate DLCI priorities with optional stuff. Needs optimising.\n */\n\nstatic int gsm_dlci_data_sweep(struct gsm_mux *gsm)\n{\n\t/* Priority ordering: We should do priority with RR of the groups */\n\tint i, len, ret = 0;\n\tbool sent;\n\tstruct gsm_dlci *dlci;\n\n\twhile (gsm->tx_bytes < TX_THRESH_HI) {\n\t\tfor (sent = false, i = 1; i < NUM_DLCI; i++) {\n\t\t\tdlci = gsm->dlci[i];\n\t\t\t/* skip unused or blocked channel */\n\t\t\tif (!dlci || dlci->constipated)\n\t\t\t\tcontinue;\n\t\t\t/* skip channels with invalid state */\n\t\t\tif (dlci->state != DLCI_OPEN)\n\t\t\t\tcontinue;\n\t\t\t/* count the sent data per adaption */\n\t\t\tif (dlci->adaption < 3 && !dlci->net)\n\t\t\t\tlen = gsm_dlci_data_output(gsm, dlci);\n\t\t\telse\n\t\t\t\tlen = gsm_dlci_data_output_framed(gsm, dlci);\n\t\t\t/* on error exit */\n\t\t\tif (len < 0)\n\t\t\t\treturn ret;\n\t\t\tif (len > 0) {\n\t\t\t\tret++;\n\t\t\t\tsent = true;\n\t\t\t\t/* The lower DLCs can starve the higher DLCs! */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* try next */\n\t\t}\n\t\tif (!sent)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/**\n *\tgsm_dlci_data_kick\t-\ttransmit if possible\n *\t@dlci: DLCI to kick\n *\n *\tTransmit data from this DLCI if the queue is empty. We can't rely on\n *\ta tty wakeup except when we filled the pipe so we need to fire off\n *\tnew data ourselves in other cases.\n */\n\nstatic void gsm_dlci_data_kick(struct gsm_dlci *dlci)\n{\n\tunsigned long flags;\n\tint sweep;\n\n\tif (dlci->constipated)\n\t\treturn;\n\n\tspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\n\t/* If we have nothing running then we need to fire up */\n\tsweep = (dlci->gsm->tx_bytes < TX_THRESH_LO);\n\tif (dlci->gsm->tx_bytes == 0) {\n\t\tif (dlci->net)\n\t\t\tgsm_dlci_data_output_framed(dlci->gsm, dlci);\n\t\telse\n\t\t\tgsm_dlci_data_output(dlci->gsm, dlci);\n\t}\n\tif (sweep)\n\t\tgsm_dlci_data_sweep(dlci->gsm);\n\tspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\n}\n\n/*\n *\tControl message processing\n */\n\n\n/**\n * gsm_control_command\t-\tsend a command frame to a control\n * @gsm: gsm channel\n * @cmd: the command to use\n * @data: data to follow encoded info\n * @dlen: length of data\n *\n * Encode up and queue a UI/UIH frame containing our command.\n */\nstatic int gsm_control_command(struct gsm_mux *gsm, int cmd, const u8 *data,\n\t\t\t       int dlen)\n{\n\tstruct gsm_msg *msg;\n\n\tmsg = gsm_data_alloc(gsm, 0, dlen + 2, gsm->dlci[0]->ftype);\n\tif (msg == NULL)\n\t\treturn -ENOMEM;\n\n\tmsg->data[0] = (cmd << 1) | CR | EA;\t/* Set C/R */\n\tmsg->data[1] = (dlen << 1) | EA;\n\tmemcpy(msg->data + 2, data, dlen);\n\tgsm_data_queue(gsm->dlci[0], msg);\n\n\treturn 0;\n}\n\n/**\n *\tgsm_control_reply\t-\tsend a response frame to a control\n *\t@gsm: gsm channel\n *\t@cmd: the command to use\n *\t@data: data to follow encoded info\n *\t@dlen: length of data\n *\n *\tEncode up and queue a UI/UIH frame containing our response.\n */\n\nstatic void gsm_control_reply(struct gsm_mux *gsm, int cmd, const u8 *data,\n\t\t\t\t\tint dlen)\n{\n\tstruct gsm_msg *msg;\n\n\tmsg = gsm_data_alloc(gsm, 0, dlen + 2, gsm->dlci[0]->ftype);\n\tif (msg == NULL)\n\t\treturn;\n\tmsg->data[0] = (cmd & 0xFE) << 1 | EA;\t/* Clear C/R */\n\tmsg->data[1] = (dlen << 1) | EA;\n\tmemcpy(msg->data + 2, data, dlen);\n\tgsm_data_queue(gsm->dlci[0], msg);\n}\n\n/**\n *\tgsm_process_modem\t-\tprocess received modem status\n *\t@tty: virtual tty bound to the DLCI\n *\t@dlci: DLCI to affect\n *\t@modem: modem bits (full EA)\n *\t@slen: number of signal octets\n *\n *\tUsed when a modem control message or line state inline in adaption\n *\tlayer 2 is processed. Sort out the local modem state and throttles\n */\n\nstatic void gsm_process_modem(struct tty_struct *tty, struct gsm_dlci *dlci,\n\t\t\t\t\t\t\tu32 modem, int slen)\n{\n\tint  mlines = 0;\n\tu8 brk = 0;\n\tint fc;\n\n\t/* The modem status command can either contain one octet (V.24 signals)\n\t * or two octets (V.24 signals + break signals). This is specified in\n\t * section 5.4.6.3.7 of the 07.10 mux spec.\n\t */\n\n\tif (slen == 1)\n\t\tmodem = modem & 0x7f;\n\telse {\n\t\tbrk = modem & 0x7f;\n\t\tmodem = (modem >> 7) & 0x7f;\n\t}\n\n\t/* Flow control/ready to communicate */\n\tfc = (modem & MDM_FC) || !(modem & MDM_RTR);\n\tif (fc && !dlci->constipated) {\n\t\t/* Need to throttle our output on this device */\n\t\tdlci->constipated = true;\n\t} else if (!fc && dlci->constipated) {\n\t\tdlci->constipated = false;\n\t\tgsm_dlci_data_kick(dlci);\n\t}\n\n\t/* Map modem bits */\n\tif (modem & MDM_RTC)\n\t\tmlines |= TIOCM_DSR | TIOCM_DTR;\n\tif (modem & MDM_RTR)\n\t\tmlines |= TIOCM_RTS | TIOCM_CTS;\n\tif (modem & MDM_IC)\n\t\tmlines |= TIOCM_RI;\n\tif (modem & MDM_DV)\n\t\tmlines |= TIOCM_CD;\n\n\t/* Carrier drop -> hangup */\n\tif (tty) {\n\t\tif ((mlines & TIOCM_CD) == 0 && (dlci->modem_rx & TIOCM_CD))\n\t\t\tif (!C_CLOCAL(tty))\n\t\t\t\ttty_hangup(tty);\n\t}\n\tif (brk & 0x01)\n\t\ttty_insert_flip_char(&dlci->port, 0, TTY_BREAK);\n\tdlci->modem_rx = mlines;\n\twake_up_interruptible(&dlci->gsm->event);\n}\n\n/**\n * gsm_process_negotiation\t-\tprocess received parameters\n * @gsm: GSM channel\n * @addr: DLCI address\n * @cr: command/response\n * @params: encoded parameters from the parameter negotiation message\n *\n * Used when the response for our parameter negotiation command was\n * received.\n */\nstatic int gsm_process_negotiation(struct gsm_mux *gsm, unsigned int addr,\n\t\t\t\t   unsigned int cr,\n\t\t\t\t   const struct gsm_dlci_param_bits *params)\n{\n\tstruct gsm_dlci *dlci = gsm->dlci[addr];\n\tunsigned int ftype, i, adaption, prio, n1, k;\n\n\ti = FIELD_GET(PN_I_CL_FIELD_FTYPE, params->i_cl_bits);\n\tadaption = FIELD_GET(PN_I_CL_FIELD_ADAPTION, params->i_cl_bits) + 1;\n\tprio = FIELD_GET(PN_P_FIELD_PRIO, params->p_bits);\n\tn1 = FIELD_GET(PN_N_FIELD_N1, get_unaligned_le16(&params->n_bits));\n\tk = FIELD_GET(PN_K_FIELD_K, params->k_bits);\n\n\tif (n1 < MIN_MTU) {\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s N1 out of range in PN\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (i) {\n\tcase 0x00:\n\t\tftype = UIH;\n\t\tbreak;\n\tcase 0x01:\n\t\tftype = UI;\n\t\tbreak;\n\tcase 0x02: /* I frames are not supported */\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s unsupported I frame request in PN\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s i out of range in PN\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cr && gsm->initiator) {\n\t\tif (adaption != dlci->adaption) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid adaption %d in PN\\n\",\n\t\t\t\t\t__func__, adaption);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (prio != dlci->prio) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid priority %d in PN\",\n\t\t\t\t\t__func__, prio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n1 > gsm->mru || n1 > dlci->mtu) {\n\t\t\t/* We requested a frame size but the other party wants\n\t\t\t * to send larger frames. The standard allows only a\n\t\t\t * smaller response value than requested (5.4.6.3.1).\n\t\t\t */\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid N1 %d in PN\\n\", __func__,\n\t\t\t\t\tn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->mtu = n1;\n\t\tif (ftype != dlci->ftype) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid i %d in PN\\n\", __func__, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ftype != UI && ftype != UIH && k > dlci->k) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid k %d in PN\\n\", __func__, k);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->k = k;\n\t} else if (cr && !gsm->initiator) {\n\t\t/* Only convergence layer type 1 and 2 are supported. */\n\t\tif (adaption != 1 && adaption != 2) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid adaption %d in PN\\n\",\n\t\t\t\t\t__func__, adaption);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->adaption = adaption;\n\t\tif (n1 > gsm->mru) {\n\t\t\t/* Propose a smaller value */\n\t\t\tdlci->mtu = gsm->mru;\n\t\t} else if (n1 > MAX_MTU) {\n\t\t\t/* Propose a smaller value */\n\t\t\tdlci->mtu = MAX_MTU;\n\t\t} else {\n\t\t\tdlci->mtu = n1;\n\t\t}\n\t\tdlci->prio = prio;\n\t\tdlci->ftype = ftype;\n\t\tdlci->k = k;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tgsm_control_modem\t-\tmodem status received\n *\t@gsm: GSM channel\n *\t@data: data following command\n *\t@clen: command length\n *\n *\tWe have received a modem status control message. This is used by\n *\tthe GSM mux protocol to pass virtual modem line status and optionally\n *\tto indicate break signals. Unpack it, convert to Linux representation\n *\tand if need be stuff a break message down the tty.\n */\n\nstatic void gsm_control_modem(struct gsm_mux *gsm, const u8 *data, int clen)\n{\n\tunsigned int addr = 0;\n\tunsigned int modem = 0;\n\tstruct gsm_dlci *dlci;\n\tint len = clen;\n\tint cl = clen;\n\tconst u8 *dp = data;\n\tstruct tty_struct *tty;\n\n\tlen = gsm_read_ea_val(&addr, data, cl);\n\tif (len < 1)\n\t\treturn;\n\n\taddr >>= 1;\n\t/* Closed port, or invalid ? */\n\tif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\n\t\treturn;\n\tdlci = gsm->dlci[addr];\n\n\t/* Must be at least one byte following the EA */\n\tif ((cl - len) < 1)\n\t\treturn;\n\n\tdp += len;\n\tcl -= len;\n\n\t/* get the modem status */\n\tlen = gsm_read_ea_val(&modem, dp, cl);\n\tif (len < 1)\n\t\treturn;\n\n\ttty = tty_port_tty_get(&dlci->port);\n\tgsm_process_modem(tty, dlci, modem, cl);\n\tif (tty) {\n\t\ttty_wakeup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\tgsm_control_reply(gsm, CMD_MSC, data, clen);\n}\n\n/**\n * gsm_control_negotiation\t-\tparameter negotiation received\n * @gsm: GSM channel\n * @cr: command/response flag\n * @data: data following command\n * @dlen: data length\n *\n * We have received a parameter negotiation message. This is used by\n * the GSM mux protocol to configure protocol parameters for a new DLCI.\n */\nstatic void gsm_control_negotiation(struct gsm_mux *gsm, unsigned int cr,\n\t\t\t\t    const u8 *data, unsigned int dlen)\n{\n\tunsigned int addr;\n\tstruct gsm_dlci_param_bits pn_reply;\n\tstruct gsm_dlci *dlci;\n\tstruct gsm_dlci_param_bits *params;\n\n\tif (dlen < sizeof(struct gsm_dlci_param_bits))\n\t\treturn;\n\n\t/* Invalid DLCI? */\n\tparams = (struct gsm_dlci_param_bits *)data;\n\taddr = FIELD_GET(PN_D_FIELD_DLCI, params->d_bits);\n\tif (addr == 0 || addr >= NUM_DLCI || !gsm->dlci[addr])\n\t\treturn;\n\tdlci = gsm->dlci[addr];\n\n\t/* Too late for parameter negotiation? */\n\tif ((!cr && dlci->state == DLCI_OPENING) || dlci->state == DLCI_OPEN)\n\t\treturn;\n\n\t/* Process the received parameters */\n\tif (gsm_process_negotiation(gsm, addr, cr, params) != 0) {\n\t\t/* Negotiation failed. Close the link. */\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN failed\\n\", __func__);\n\t\tgsm_dlci_close(dlci);\n\t\treturn;\n\t}\n\n\tif (cr) {\n\t\t/* Reply command with accepted parameters. */\n\t\tif (gsm_encode_params(dlci, &pn_reply) == 0)\n\t\t\tgsm_control_reply(gsm, CMD_PN, (const u8 *)&pn_reply,\n\t\t\t\t\t  sizeof(pn_reply));\n\t\telse if (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN invalid\\n\", __func__);\n\t} else if (dlci->state == DLCI_CONFIGURE) {\n\t\t/* Proceed with link setup by sending SABM before UA */\n\t\tdlci->state = DLCI_OPENING;\n\t\tgsm_command(gsm, dlci->addr, SABM|PF);\n\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t} else {\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN in invalid state\\n\", __func__);\n\t}\n}\n\n/**\n *\tgsm_control_rls\t\t-\tremote line status\n *\t@gsm: GSM channel\n *\t@data: data bytes\n *\t@clen: data length\n *\n *\tThe modem sends us a two byte message on the control channel whenever\n *\tit wishes to send us an error state from the virtual link. Stuff\n *\tthis into the uplink tty if present\n */\n\nstatic void gsm_control_rls(struct gsm_mux *gsm, const u8 *data, int clen)\n{\n\tstruct tty_port *port;\n\tunsigned int addr = 0;\n\tu8 bits;\n\tint len = clen;\n\tconst u8 *dp = data;\n\n\twhile (gsm_read_ea(&addr, *dp++) == 0) {\n\t\tlen--;\n\t\tif (len == 0)\n\t\t\treturn;\n\t}\n\t/* Must be at least one byte following ea */\n\tlen--;\n\tif (len <= 0)\n\t\treturn;\n\taddr >>= 1;\n\t/* Closed port, or invalid ? */\n\tif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\n\t\treturn;\n\t/* No error ? */\n\tbits = *dp;\n\tif ((bits & 1) == 0)\n\t\treturn;\n\n\tport = &gsm->dlci[addr]->port;\n\n\tif (bits & 2)\n\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\tif (bits & 4)\n\t\ttty_insert_flip_char(port, 0, TTY_PARITY);\n\tif (bits & 8)\n\t\ttty_insert_flip_char(port, 0, TTY_FRAME);\n\n\ttty_flip_buffer_push(port);\n\n\tgsm_control_reply(gsm, CMD_RLS, data, clen);\n}\n\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci);\n\n/**\n *\tgsm_control_message\t-\tDLCI 0 control processing\n *\t@gsm: our GSM mux\n *\t@command:  the command EA\n *\t@data: data beyond the command/length EAs\n *\t@clen: length\n *\n *\tInput processor for control messages from the other end of the link.\n *\tProcesses the incoming request and queues a response frame or an\n *\tNSC response if not supported\n */\n\nstatic void gsm_control_message(struct gsm_mux *gsm, unsigned int command,\n\t\t\t\t\t\tconst u8 *data, int clen)\n{\n\tu8 buf[1];\n\n\tswitch (command) {\n\tcase CMD_CLD: {\n\t\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\t\t/* Modem wishes to close down */\n\t\tif (dlci) {\n\t\t\tdlci->dead = true;\n\t\t\tgsm->dead = true;\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase CMD_TEST:\n\t\t/* Modem wishes to test, reply with the data */\n\t\tgsm_control_reply(gsm, CMD_TEST, data, clen);\n\t\tbreak;\n\tcase CMD_FCON:\n\t\t/* Modem can accept data again */\n\t\tgsm->constipated = false;\n\t\tgsm_control_reply(gsm, CMD_FCON, NULL, 0);\n\t\t/* Kick the link in case it is idling */\n\t\tgsmld_write_trigger(gsm);\n\t\tbreak;\n\tcase CMD_FCOFF:\n\t\t/* Modem wants us to STFU */\n\t\tgsm->constipated = true;\n\t\tgsm_control_reply(gsm, CMD_FCOFF, NULL, 0);\n\t\tbreak;\n\tcase CMD_MSC:\n\t\t/* Out of band modem line change indicator for a DLCI */\n\t\tgsm_control_modem(gsm, data, clen);\n\t\tbreak;\n\tcase CMD_RLS:\n\t\t/* Out of band error reception for a DLCI */\n\t\tgsm_control_rls(gsm, data, clen);\n\t\tbreak;\n\tcase CMD_PSC:\n\t\t/* Modem wishes to enter power saving state */\n\t\tgsm_control_reply(gsm, CMD_PSC, NULL, 0);\n\t\tbreak;\n\t\t/* Optional commands */\n\tcase CMD_PN:\n\t\t/* Modem sends a parameter negotiation command */\n\t\tgsm_control_negotiation(gsm, 1, data, clen);\n\t\tbreak;\n\t\t/* Optional unsupported commands */\n\tcase CMD_RPN:\t/* Remote port negotiation */\n\tcase CMD_SNC:\t/* Service negotiation command */\n\tdefault:\n\t\t/* Reply to bad commands with an NSC */\n\t\tbuf[0] = command;\n\t\tgsm_control_reply(gsm, CMD_NSC, buf, 1);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_control_response\t-\tprocess a response to our control\n *\t@gsm: our GSM mux\n *\t@command: the command (response) EA\n *\t@data: data beyond the command/length EA\n *\t@clen: length\n *\n *\tProcess a response to an outstanding command. We only allow a single\n *\tcontrol message in flight so this is fairly easy. All the clean up\n *\tis done by the caller, we just update the fields, flag it as done\n *\tand return\n */\n\nstatic void gsm_control_response(struct gsm_mux *gsm, unsigned int command,\n\t\t\t\t\t\tconst u8 *data, int clen)\n{\n\tstruct gsm_control *ctrl;\n\tstruct gsm_dlci *dlci;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\n\tctrl = gsm->pending_cmd;\n\tdlci = gsm->dlci[0];\n\tcommand |= 1;\n\t/* Does the reply match our command */\n\tif (ctrl != NULL && (command == ctrl->cmd || command == CMD_NSC)) {\n\t\t/* Our command was replied to, kill the retry timer */\n\t\tdel_timer(&gsm->t2_timer);\n\t\tgsm->pending_cmd = NULL;\n\t\t/* Rejected by the other end */\n\t\tif (command == CMD_NSC)\n\t\t\tctrl->error = -EOPNOTSUPP;\n\t\tctrl->done = 1;\n\t\twake_up(&gsm->event);\n\t/* Or did we receive the PN response to our PN command */\n\t} else if (command == CMD_PN) {\n\t\tgsm_control_negotiation(gsm, 0, data, clen);\n\t/* Or did we receive the TEST response to our TEST command */\n\t} else if (command == CMD_TEST && clen == 1 && *data == gsm->ka_num) {\n\t\tgsm->ka_retries = -1; /* trigger new keep-alive message */\n\t\tif (dlci && !dlci->dead)\n\t\t\tmod_timer(&gsm->ka_timer, jiffies + gsm->keep_alive * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n/**\n * gsm_control_keep_alive\t-\tcheck timeout or start keep-alive\n * @t: timer contained in our gsm object\n *\n * Called off the keep-alive timer expiry signaling that our link\n * partner is not responding anymore. Link will be closed.\n * This is also called to startup our timer.\n */\n\nstatic void gsm_control_keep_alive(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, ka_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tif (gsm->ka_num && gsm->ka_retries == 0) {\n\t\t/* Keep-alive expired -> close the link */\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_debug(\"%s keep-alive timed out\\n\", __func__);\n\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\tif (gsm->dlci[0])\n\t\t\tgsm_dlci_begin_close(gsm->dlci[0]);\n\t\treturn;\n\t} else if (gsm->keep_alive && gsm->dlci[0] && !gsm->dlci[0]->dead) {\n\t\tif (gsm->ka_retries > 0) {\n\t\t\t/* T2 expired for keep-alive -> resend */\n\t\t\tgsm->ka_retries--;\n\t\t} else {\n\t\t\t/* Start keep-alive timer */\n\t\t\tgsm->ka_num++;\n\t\t\tif (!gsm->ka_num)\n\t\t\t\tgsm->ka_num++;\n\t\t\tgsm->ka_retries = (signed int)gsm->n2;\n\t\t}\n\t\tgsm_control_command(gsm, CMD_TEST, &gsm->ka_num,\n\t\t\t\t    sizeof(gsm->ka_num));\n\t\tmod_timer(&gsm->ka_timer,\n\t\t\t  jiffies + gsm->t2 * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n/**\n *\tgsm_control_transmit\t-\tsend control packet\n *\t@gsm: gsm mux\n *\t@ctrl: frame to send\n *\n *\tSend out a pending control command (called under control lock)\n */\n\nstatic void gsm_control_transmit(struct gsm_mux *gsm, struct gsm_control *ctrl)\n{\n\tgsm_control_command(gsm, ctrl->cmd, ctrl->data, ctrl->len);\n}\n\n/**\n *\tgsm_control_retransmit\t-\tretransmit a control frame\n *\t@t: timer contained in our gsm object\n *\n *\tCalled off the T2 timer expiry in order to retransmit control frames\n *\tthat have been lost in the system somewhere. The control_lock protects\n *\tus from colliding with another sender or a receive completion event.\n *\tIn that situation the timer may still occur in a small window but\n *\tgsm->pending_cmd will be NULL and we just let the timer expire.\n */\n\nstatic void gsm_control_retransmit(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, t2_timer);\n\tstruct gsm_control *ctrl;\n\tunsigned long flags;\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tctrl = gsm->pending_cmd;\n\tif (ctrl) {\n\t\tif (gsm->cretries == 0 || !gsm->dlci[0] || gsm->dlci[0]->dead) {\n\t\t\tgsm->pending_cmd = NULL;\n\t\t\tctrl->error = -ETIMEDOUT;\n\t\t\tctrl->done = 1;\n\t\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\t\twake_up(&gsm->event);\n\t\t\treturn;\n\t\t}\n\t\tgsm->cretries--;\n\t\tgsm_control_transmit(gsm, ctrl);\n\t\tmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n/**\n *\tgsm_control_send\t-\tsend a control frame on DLCI 0\n *\t@gsm: the GSM channel\n *\t@command: command  to send including CR bit\n *\t@data: bytes of data (must be kmalloced)\n *\t@clen: length of the block to send\n *\n *\tQueue and dispatch a control command. Only one command can be\n *\tactive at a time. In theory more can be outstanding but the matching\n *\tgets really complicated so for now stick to one outstanding.\n */\n\nstatic struct gsm_control *gsm_control_send(struct gsm_mux *gsm,\n\t\tunsigned int command, u8 *data, int clen)\n{\n\tstruct gsm_control *ctrl = kzalloc(sizeof(struct gsm_control),\n\t\t\t\t\t\tGFP_ATOMIC);\n\tunsigned long flags;\n\tif (ctrl == NULL)\n\t\treturn NULL;\nretry:\n\twait_event(gsm->event, gsm->pending_cmd == NULL);\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tif (gsm->pending_cmd != NULL) {\n\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\tgoto retry;\n\t}\n\tctrl->cmd = command;\n\tctrl->data = data;\n\tctrl->len = clen;\n\tgsm->pending_cmd = ctrl;\n\n\t/* If DLCI0 is in ADM mode skip retries, it won't respond */\n\tif (gsm->dlci[0]->mode == DLCI_MODE_ADM)\n\t\tgsm->cretries = 0;\n\telse\n\t\tgsm->cretries = gsm->n2;\n\n\tmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\n\tgsm_control_transmit(gsm, ctrl);\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\treturn ctrl;\n}\n\n/**\n *\tgsm_control_wait\t-\twait for a control to finish\n *\t@gsm: GSM mux\n *\t@control: control we are waiting on\n *\n *\tWaits for the control to complete or time out. Frees any used\n *\tresources and returns 0 for success, or an error if the remote\n *\trejected or ignored the request.\n */\n\nstatic int gsm_control_wait(struct gsm_mux *gsm, struct gsm_control *control)\n{\n\tint err;\n\twait_event(gsm->event, control->done == 1);\n\terr = control->error;\n\tkfree(control);\n\treturn err;\n}\n\n\n/*\n *\tDLCI level handling: Needs krefs\n */\n\n/*\n *\tState transitions and timers\n */\n\n/**\n *\tgsm_dlci_close\t\t-\ta DLCI has closed\n *\t@dlci: DLCI that closed\n *\n *\tPerform processing when moving a DLCI into closed state. If there\n *\tis an attached tty this is hung up\n */\n\nstatic void gsm_dlci_close(struct gsm_dlci *dlci)\n{\n\tdel_timer(&dlci->t1);\n\tif (debug & DBG_ERRORS)\n\t\tpr_debug(\"DLCI %d goes closed.\\n\", dlci->addr);\n\tdlci->state = DLCI_CLOSED;\n\t/* Prevent us from sending data before the link is up again */\n\tdlci->constipated = true;\n\tif (dlci->addr != 0) {\n\t\ttty_port_tty_hangup(&dlci->port, false);\n\t\tgsm_dlci_clear_queues(dlci->gsm, dlci);\n\t\t/* Ensure that gsmtty_open() can return. */\n\t\ttty_port_set_initialized(&dlci->port, false);\n\t\twake_up_interruptible(&dlci->port.open_wait);\n\t} else {\n\t\tdel_timer(&dlci->gsm->ka_timer);\n\t\tdlci->gsm->dead = true;\n\t}\n\t/* A DLCI 0 close is a MUX termination so we need to kick that\n\t   back to userspace somehow */\n\tgsm_dlci_data_kick(dlci);\n\twake_up_all(&dlci->gsm->event);\n}\n\n/**\n *\tgsm_dlci_open\t\t-\ta DLCI has opened\n *\t@dlci: DLCI that opened\n *\n *\tPerform processing when moving a DLCI into open state.\n */\n\nstatic void gsm_dlci_open(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\t/* Note that SABM UA .. SABM UA first UA lost can mean that we go\n\t   open -> open */\n\tdel_timer(&dlci->t1);\n\t/* This will let a tty open continue */\n\tdlci->state = DLCI_OPEN;\n\tdlci->constipated = false;\n\tif (debug & DBG_ERRORS)\n\t\tpr_debug(\"DLCI %d goes open.\\n\", dlci->addr);\n\t/* Send current modem state */\n\tif (dlci->addr) {\n\t\tgsm_modem_update(dlci, 0);\n\t} else {\n\t\t/* Start keep-alive control */\n\t\tgsm->ka_num = 0;\n\t\tgsm->ka_retries = -1;\n\t\tmod_timer(&gsm->ka_timer,\n\t\t\t  jiffies + gsm->keep_alive * HZ / 100);\n\t}\n\tgsm_dlci_data_kick(dlci);\n\twake_up(&dlci->gsm->event);\n}\n\n/**\n * gsm_dlci_negotiate\t-\tstart parameter negotiation\n * @dlci: DLCI to open\n *\n * Starts the parameter negotiation for the new DLCI. This needs to be done\n * before the DLCI initialized the channel via SABM.\n */\nstatic int gsm_dlci_negotiate(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tstruct gsm_dlci_param_bits params;\n\tint ret;\n\n\tret = gsm_encode_params(dlci, &params);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* We cannot asynchronous wait for the command response with\n\t * gsm_command() and gsm_control_wait() at this point.\n\t */\n\tret = gsm_control_command(gsm, CMD_PN, (const u8 *)&params,\n\t\t\t\t  sizeof(params));\n\n\treturn ret;\n}\n\n/**\n *\tgsm_dlci_t1\t\t-\tT1 timer expiry\n *\t@t: timer contained in the DLCI that opened\n *\n *\tThe T1 timer handles retransmits of control frames (essentially of\n *\tSABM and DISC). We resend the command until the retry count runs out\n *\tin which case an opening port goes back to closed and a closing port\n *\tis simply put into closed state (any further frames from the other\n *\tend will get a DM response)\n *\n *\tSome control dlci can stay in ADM mode with other dlci working just\n *\tfine. In that case we can just keep the control dlci open after the\n *\tDLCI_OPENING retries time out.\n */\n\nstatic void gsm_dlci_t1(struct timer_list *t)\n{\n\tstruct gsm_dlci *dlci = from_timer(dlci, t, t1);\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\tswitch (dlci->state) {\n\tcase DLCI_CONFIGURE:\n\t\tif (dlci->retries && gsm_dlci_negotiate(dlci) == 0) {\n\t\t\tdlci->retries--;\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else {\n\t\t\tgsm_dlci_begin_close(dlci); /* prevent half open link */\n\t\t}\n\t\tbreak;\n\tcase DLCI_OPENING:\n\t\tif (dlci->retries) {\n\t\t\tdlci->retries--;\n\t\t\tgsm_command(dlci->gsm, dlci->addr, SABM|PF);\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else if (!dlci->addr && gsm->control == (DM | PF)) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"DLCI %d opening in ADM mode.\\n\",\n\t\t\t\t\tdlci->addr);\n\t\t\tdlci->mode = DLCI_MODE_ADM;\n\t\t\tgsm_dlci_open(dlci);\n\t\t} else {\n\t\t\tgsm_dlci_begin_close(dlci); /* prevent half open link */\n\t\t}\n\n\t\tbreak;\n\tcase DLCI_CLOSING:\n\t\tif (dlci->retries) {\n\t\t\tdlci->retries--;\n\t\t\tgsm_command(dlci->gsm, dlci->addr, DISC|PF);\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else\n\t\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, dlci->state);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_dlci_begin_open\t-\tstart channel open procedure\n *\t@dlci: DLCI to open\n *\n *\tCommence opening a DLCI from the Linux side. We issue SABM messages\n *\tto the modem which should then reply with a UA or ADM, at which point\n *\twe will move into open state. Opening is done asynchronously with retry\n *\trunning off timers and the responses.\n *\tParameter negotiation is performed before SABM if required.\n */\n\nstatic void gsm_dlci_begin_open(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci ? dlci->gsm : NULL;\n\tbool need_pn = false;\n\n\tif (!gsm)\n\t\treturn;\n\n\tif (dlci->addr != 0) {\n\t\tif (gsm->adaption != 1 || gsm->adaption != dlci->adaption)\n\t\t\tneed_pn = true;\n\t\tif (dlci->prio != (roundup(dlci->addr + 1, 8) - 1))\n\t\t\tneed_pn = true;\n\t\tif (gsm->ftype != dlci->ftype)\n\t\t\tneed_pn = true;\n\t}\n\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_WAITING_CONFIG:\n\tcase DLCI_CLOSING:\n\t\tdlci->retries = gsm->n2;\n\t\tif (!need_pn) {\n\t\t\tdlci->state = DLCI_OPENING;\n\t\t\tgsm_command(gsm, dlci->addr, SABM|PF);\n\t\t} else {\n\t\t\t/* Configure DLCI before setup */\n\t\t\tdlci->state = DLCI_CONFIGURE;\n\t\t\tif (gsm_dlci_negotiate(dlci) != 0) {\n\t\t\t\tgsm_dlci_close(dlci);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_dlci_set_opening\t-\tchange state to opening\n *\t@dlci: DLCI to open\n *\n *\tChange internal state to wait for DLCI open from initiator side.\n *\tWe set off timers and responses upon reception of an SABM.\n */\nstatic void gsm_dlci_set_opening(struct gsm_dlci *dlci)\n{\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_WAITING_CONFIG:\n\tcase DLCI_CLOSING:\n\t\tdlci->state = DLCI_OPENING;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * gsm_dlci_set_wait_config\t-\twait for channel configuration\n * @dlci: DLCI to configure\n *\n * Wait for a DLCI configuration from the application.\n */\nstatic void gsm_dlci_set_wait_config(struct gsm_dlci *dlci)\n{\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_CLOSING:\n\t\tdlci->state = DLCI_WAITING_CONFIG;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_dlci_begin_close\t-\tstart channel open procedure\n *\t@dlci: DLCI to open\n *\n *\tCommence closing a DLCI from the Linux side. We issue DISC messages\n *\tto the modem which should then reply with a UA, at which point we\n *\twill move into closed state. Closing is done asynchronously with retry\n *\toff timers. We may also receive a DM reply from the other end which\n *\tindicates the channel was already closed.\n */\n\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tif (dlci->state == DLCI_CLOSED || dlci->state == DLCI_CLOSING)\n\t\treturn;\n\tdlci->retries = gsm->n2;\n\tdlci->state = DLCI_CLOSING;\n\tgsm_command(dlci->gsm, dlci->addr, DISC|PF);\n\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\twake_up_interruptible(&gsm->event);\n}\n\n/**\n *\tgsm_dlci_data\t\t-\tdata arrived\n *\t@dlci: channel\n *\t@data: block of bytes received\n *\t@clen: length of received block\n *\n *\tA UI or UIH frame has arrived which contains data for a channel\n *\tother than the control channel. If the relevant virtual tty is\n *\topen we shovel the bits down it, if not we drop them.\n */\n\nstatic void gsm_dlci_data(struct gsm_dlci *dlci, const u8 *data, int clen)\n{\n\t/* krefs .. */\n\tstruct tty_port *port = &dlci->port;\n\tstruct tty_struct *tty;\n\tunsigned int modem = 0;\n\tint len;\n\n\tif (debug & DBG_TTY)\n\t\tpr_debug(\"%d bytes for tty\\n\", clen);\n\tswitch (dlci->adaption)  {\n\t/* Unsupported types */\n\tcase 4:\t\t/* Packetised interruptible data */\n\t\tbreak;\n\tcase 3:\t\t/* Packetised uininterruptible voice/data */\n\t\tbreak;\n\tcase 2:\t\t/* Asynchronous serial with line state in each frame */\n\t\tlen = gsm_read_ea_val(&modem, data, clen);\n\t\tif (len < 1)\n\t\t\treturn;\n\t\ttty = tty_port_tty_get(port);\n\t\tif (tty) {\n\t\t\tgsm_process_modem(tty, dlci, modem, len);\n\t\t\ttty_wakeup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\t/* Skip processed modem data */\n\t\tdata += len;\n\t\tclen -= len;\n\t\tfallthrough;\n\tcase 1:\t\t/* Line state will go via DLCI 0 controls only */\n\tdefault:\n\t\ttty_insert_flip_string(port, data, clen);\n\t\ttty_flip_buffer_push(port);\n\t}\n}\n\n/**\n *\tgsm_dlci_command\t-\tdata arrived on control channel\n *\t@dlci: channel\n *\t@data: block of bytes received\n *\t@len: length of received block\n *\n *\tA UI or UIH frame has arrived which contains data for DLCI 0 the\n *\tcontrol channel. This should contain a command EA followed by\n *\tcontrol data bytes. The command EA contains a command/response bit\n *\tand we divide up the work accordingly.\n */\n\nstatic void gsm_dlci_command(struct gsm_dlci *dlci, const u8 *data, int len)\n{\n\t/* See what command is involved */\n\tunsigned int command = 0;\n\tunsigned int clen = 0;\n\tunsigned int dlen;\n\n\t/* read the command */\n\tdlen = gsm_read_ea_val(&command, data, len);\n\tlen -= dlen;\n\tdata += dlen;\n\n\t/* read any control data */\n\tdlen = gsm_read_ea_val(&clen, data, len);\n\tlen -= dlen;\n\tdata += dlen;\n\n\t/* Malformed command? */\n\tif (clen > len)\n\t\treturn;\n\n\tif (command & 1)\n\t\tgsm_control_message(dlci->gsm, command, data, clen);\n\telse\n\t\tgsm_control_response(dlci->gsm, command, data, clen);\n}\n\n/**\n *\tgsm_kick_timer\t-\ttransmit if possible\n *\t@t: timer contained in our gsm object\n *\n *\tTransmit data from DLCIs if the queue is empty. We can't rely on\n *\ta tty wakeup except when we filled the pipe so we need to fire off\n *\tnew data ourselves in other cases.\n */\nstatic void gsm_kick_timer(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, kick_timer);\n\tunsigned long flags;\n\tint sent = 0;\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\t/* If we have nothing running then we need to fire up */\n\tif (gsm->tx_bytes < TX_THRESH_LO)\n\t\tsent = gsm_dlci_data_sweep(gsm);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\tif (sent && debug & DBG_DATA)\n\t\tpr_info(\"%s TX queue stalled\\n\", __func__);\n}\n\n/**\n * gsm_dlci_copy_config_values\t-\tcopy DLCI configuration\n * @dlci: source DLCI\n * @dc: configuration structure to fill\n */\nstatic void gsm_dlci_copy_config_values(struct gsm_dlci *dlci, struct gsm_dlci_config *dc)\n{\n\tmemset(dc, 0, sizeof(*dc));\n\tdc->channel = (u32)dlci->addr;\n\tdc->adaption = (u32)dlci->adaption;\n\tdc->mtu = (u32)dlci->mtu;\n\tdc->priority = (u32)dlci->prio;\n\tif (dlci->ftype == UIH)\n\t\tdc->i = 1;\n\telse\n\t\tdc->i = 2;\n\tdc->k = (u32)dlci->k;\n}\n\n/**\n * gsm_dlci_config\t-\tconfigure DLCI from configuration\n * @dlci: DLCI to configure\n * @dc: DLCI configuration\n * @open: open DLCI after configuration?\n */\nstatic int gsm_dlci_config(struct gsm_dlci *dlci, struct gsm_dlci_config *dc, int open)\n{\n\tstruct gsm_mux *gsm;\n\tbool need_restart = false;\n\tbool need_open = false;\n\tunsigned int i;\n\n\t/*\n\t * Check that userspace doesn't put stuff in here to prevent breakages\n\t * in the future.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(dc->reserved); i++)\n\t\tif (dc->reserved[i])\n\t\t\treturn -EINVAL;\n\n\tif (!dlci)\n\t\treturn -EINVAL;\n\tgsm = dlci->gsm;\n\n\t/* Stuff we don't support yet - I frame transport */\n\tif (dc->adaption != 1 && dc->adaption != 2)\n\t\treturn -EOPNOTSUPP;\n\tif (dc->mtu > MAX_MTU || dc->mtu < MIN_MTU || dc->mtu > gsm->mru)\n\t\treturn -EINVAL;\n\tif (dc->priority >= 64)\n\t\treturn -EINVAL;\n\tif (dc->i == 0 || dc->i > 2)  /* UIH and UI only */\n\t\treturn -EINVAL;\n\tif (dc->k > 7)\n\t\treturn -EINVAL;\n\n\t/*\n\t * See what is needed for reconfiguration\n\t */\n\t/* Framing fields */\n\tif (dc->adaption != dlci->adaption)\n\t\tneed_restart = true;\n\tif (dc->mtu != dlci->mtu)\n\t\tneed_restart = true;\n\tif (dc->i != dlci->ftype)\n\t\tneed_restart = true;\n\t/* Requires care */\n\tif (dc->priority != dlci->prio)\n\t\tneed_restart = true;\n\n\tif ((open && gsm->wait_config) || need_restart)\n\t\tneed_open = true;\n\tif (dlci->state == DLCI_WAITING_CONFIG) {\n\t\tneed_restart = false;\n\t\tneed_open = true;\n\t}\n\n\t/*\n\t * Close down what is needed, restart and initiate the new\n\t * configuration.\n\t */\n\tif (need_restart) {\n\t\tgsm_dlci_begin_close(dlci);\n\t\twait_event_interruptible(gsm->event, dlci->state == DLCI_CLOSED);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t}\n\t/*\n\t * Setup the new configuration values\n\t */\n\tdlci->adaption = (int)dc->adaption;\n\n\tif (dc->mtu)\n\t\tdlci->mtu = (unsigned int)dc->mtu;\n\telse\n\t\tdlci->mtu = gsm->mtu;\n\n\tif (dc->priority)\n\t\tdlci->prio = (u8)dc->priority;\n\telse\n\t\tdlci->prio = roundup(dlci->addr + 1, 8) - 1;\n\n\tif (dc->i == 1)\n\t\tdlci->ftype = UIH;\n\telse if (dc->i == 2)\n\t\tdlci->ftype = UI;\n\n\tif (dc->k)\n\t\tdlci->k = (u8)dc->k;\n\telse\n\t\tdlci->k = gsm->k;\n\n\tif (need_open) {\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(dlci);\n\t\telse\n\t\t\tgsm_dlci_set_opening(dlci);\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tAllocate/Free DLCI channels\n */\n\n/**\n *\tgsm_dlci_alloc\t\t-\tallocate a DLCI\n *\t@gsm: GSM mux\n *\t@addr: address of the DLCI\n *\n *\tAllocate and install a new DLCI object into the GSM mux.\n *\n *\tFIXME: review locking races\n */\n\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr)\n{\n\tstruct gsm_dlci *dlci = kzalloc(sizeof(struct gsm_dlci), GFP_ATOMIC);\n\tif (dlci == NULL)\n\t\treturn NULL;\n\tspin_lock_init(&dlci->lock);\n\tmutex_init(&dlci->mutex);\n\tif (kfifo_alloc(&dlci->fifo, TX_SIZE, GFP_KERNEL) < 0) {\n\t\tkfree(dlci);\n\t\treturn NULL;\n\t}\n\n\tskb_queue_head_init(&dlci->skb_list);\n\ttimer_setup(&dlci->t1, gsm_dlci_t1, 0);\n\ttty_port_init(&dlci->port);\n\tdlci->port.ops = &gsm_port_ops;\n\tdlci->gsm = gsm;\n\tdlci->addr = addr;\n\tdlci->adaption = gsm->adaption;\n\tdlci->mtu = gsm->mtu;\n\tif (addr == 0)\n\t\tdlci->prio = 0;\n\telse\n\t\tdlci->prio = roundup(addr + 1, 8) - 1;\n\tdlci->ftype = gsm->ftype;\n\tdlci->k = gsm->k;\n\tdlci->state = DLCI_CLOSED;\n\tif (addr) {\n\t\tdlci->data = gsm_dlci_data;\n\t\t/* Prevent us from sending data before the link is up */\n\t\tdlci->constipated = true;\n\t} else {\n\t\tdlci->data = gsm_dlci_command;\n\t}\n\tgsm->dlci[addr] = dlci;\n\treturn dlci;\n}\n\n/**\n *\tgsm_dlci_free\t\t-\tfree DLCI\n *\t@port: tty port for DLCI to free\n *\n *\tFree up a DLCI.\n *\n *\tCan sleep.\n */\nstatic void gsm_dlci_free(struct tty_port *port)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\n\ttimer_shutdown_sync(&dlci->t1);\n\tdlci->gsm->dlci[dlci->addr] = NULL;\n\tkfifo_free(&dlci->fifo);\n\twhile ((dlci->skb = skb_dequeue(&dlci->skb_list)))\n\t\tdev_kfree_skb(dlci->skb);\n\tkfree(dlci);\n}\n\nstatic inline void dlci_get(struct gsm_dlci *dlci)\n{\n\ttty_port_get(&dlci->port);\n}\n\nstatic inline void dlci_put(struct gsm_dlci *dlci)\n{\n\ttty_port_put(&dlci->port);\n}\n\nstatic void gsm_destroy_network(struct gsm_dlci *dlci);\n\n/**\n *\tgsm_dlci_release\t\t-\trelease DLCI\n *\t@dlci: DLCI to destroy\n *\n *\tRelease a DLCI. Actual free is deferred until either\n *\tmux is closed or tty is closed - whichever is last.\n *\n *\tCan sleep.\n */\nstatic void gsm_dlci_release(struct gsm_dlci *dlci)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(&dlci->port);\n\tif (tty) {\n\t\tmutex_lock(&dlci->mutex);\n\t\tgsm_destroy_network(dlci);\n\t\tmutex_unlock(&dlci->mutex);\n\n\t\t/* We cannot use tty_hangup() because in tty_kref_put() the tty\n\t\t * driver assumes that the hangup queue is free and reuses it to\n\t\t * queue release_one_tty() -> NULL pointer panic in\n\t\t * process_one_work().\n\t\t */\n\t\ttty_vhangup(tty);\n\n\t\ttty_port_tty_set(&dlci->port, NULL);\n\t\ttty_kref_put(tty);\n\t}\n\tdlci->state = DLCI_CLOSED;\n\tdlci_put(dlci);\n}\n\n/*\n *\tLAPBish link layer logic\n */\n\n/**\n *\tgsm_queue\t\t-\ta GSM frame is ready to process\n *\t@gsm: pointer to our gsm mux\n *\n *\tAt this point in time a frame has arrived and been demangled from\n *\tthe line encoding. All the differences between the encodings have\n *\tbeen handled below us and the frame is unpacked into the structures.\n *\tThe fcs holds the header FCS but any data FCS must be added here.\n */\n\nstatic void gsm_queue(struct gsm_mux *gsm)\n{\n\tstruct gsm_dlci *dlci;\n\tu8 cr;\n\tint address;\n\n\tif (gsm->fcs != GOOD_FCS) {\n\t\tgsm->bad_fcs++;\n\t\tif (debug & DBG_DATA)\n\t\t\tpr_debug(\"BAD FCS %02x\\n\", gsm->fcs);\n\t\treturn;\n\t}\n\taddress = gsm->address >> 1;\n\tif (address >= NUM_DLCI)\n\t\tgoto invalid;\n\n\tcr = gsm->address & 1;\t\t/* C/R bit */\n\tcr ^= gsm->initiator ? 0 : 1;\t/* Flip so 1 always means command */\n\n\tgsm_print_packet(\"<--\", address, cr, gsm->control, gsm->buf, gsm->len);\n\n\tdlci = gsm->dlci[address];\n\n\tswitch (gsm->control) {\n\tcase SABM|PF:\n\t\tif (cr == 1)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL)\n\t\t\tdlci = gsm_dlci_alloc(gsm, address);\n\t\tif (dlci == NULL)\n\t\t\treturn;\n\t\tif (dlci->dead)\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\telse {\n\t\t\tgsm_response(gsm, address, UA|PF);\n\t\t\tgsm_dlci_open(dlci);\n\t\t}\n\t\tbreak;\n\tcase DISC|PF:\n\t\tif (cr == 1)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL || dlci->state == DLCI_CLOSED) {\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\t\treturn;\n\t\t}\n\t\t/* Real close complete */\n\t\tgsm_response(gsm, address, UA|PF);\n\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tcase UA|PF:\n\t\tif (cr == 0 || dlci == NULL)\n\t\t\tbreak;\n\t\tswitch (dlci->state) {\n\t\tcase DLCI_CLOSING:\n\t\t\tgsm_dlci_close(dlci);\n\t\t\tbreak;\n\t\tcase DLCI_OPENING:\n\t\t\tgsm_dlci_open(dlci);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__,\n\t\t\t\t\tdlci->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DM:\t/* DM can be valid unsolicited */\n\tcase DM|PF:\n\t\tif (cr)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL)\n\t\t\treturn;\n\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tcase UI:\n\tcase UI|PF:\n\tcase UIH:\n\tcase UIH|PF:\n\t\tif (dlci == NULL || dlci->state != DLCI_OPEN) {\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\t\treturn;\n\t\t}\n\t\tdlci->data(dlci, gsm->buf, gsm->len);\n\t\tbreak;\n\tdefault:\n\t\tgoto invalid;\n\t}\n\treturn;\ninvalid:\n\tgsm->malformed++;\n\treturn;\n}\n\n\n/**\n *\tgsm0_receive\t-\tperform processing for non-transparency\n *\t@gsm: gsm data for this ldisc instance\n *\t@c: character\n *\n *\tReceive bytes in gsm mode 0\n */\n\nstatic void gsm0_receive(struct gsm_mux *gsm, unsigned char c)\n{\n\tunsigned int len;\n\n\tswitch (gsm->state) {\n\tcase GSM_SEARCH:\t/* SOF marker */\n\t\tif (c == GSM0_SOF) {\n\t\t\tgsm->state = GSM_ADDRESS;\n\t\t\tgsm->address = 0;\n\t\t\tgsm->len = 0;\n\t\t\tgsm->fcs = INIT_FCS;\n\t\t}\n\t\tbreak;\n\tcase GSM_ADDRESS:\t/* Address EA */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->address, c))\n\t\t\tgsm->state = GSM_CONTROL;\n\t\tbreak;\n\tcase GSM_CONTROL:\t/* Control Byte */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->control = c;\n\t\tgsm->state = GSM_LEN0;\n\t\tbreak;\n\tcase GSM_LEN0:\t\t/* Length EA */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->len, c)) {\n\t\t\tif (gsm->len > gsm->mru) {\n\t\t\t\tgsm->bad_size++;\n\t\t\t\tgsm->state = GSM_SEARCH;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgsm->count = 0;\n\t\t\tif (!gsm->len)\n\t\t\t\tgsm->state = GSM_FCS;\n\t\t\telse\n\t\t\t\tgsm->state = GSM_DATA;\n\t\t\tbreak;\n\t\t}\n\t\tgsm->state = GSM_LEN1;\n\t\tbreak;\n\tcase GSM_LEN1:\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tlen = c;\n\t\tgsm->len |= len << 7;\n\t\tif (gsm->len > gsm->mru) {\n\t\t\tgsm->bad_size++;\n\t\t\tgsm->state = GSM_SEARCH;\n\t\t\tbreak;\n\t\t}\n\t\tgsm->count = 0;\n\t\tif (!gsm->len)\n\t\t\tgsm->state = GSM_FCS;\n\t\telse\n\t\t\tgsm->state = GSM_DATA;\n\t\tbreak;\n\tcase GSM_DATA:\t\t/* Data */\n\t\tgsm->buf[gsm->count++] = c;\n\t\tif (gsm->count == gsm->len) {\n\t\t\t/* Calculate final FCS for UI frames over all data */\n\t\t\tif ((gsm->control & ~PF) != UIH) {\n\t\t\t\tgsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf,\n\t\t\t\t\t\t\t     gsm->count);\n\t\t\t}\n\t\t\tgsm->state = GSM_FCS;\n\t\t}\n\t\tbreak;\n\tcase GSM_FCS:\t\t/* FCS follows the packet */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->state = GSM_SSOF;\n\t\tbreak;\n\tcase GSM_SSOF:\n\t\tgsm->state = GSM_SEARCH;\n\t\tif (c == GSM0_SOF)\n\t\t\tgsm_queue(gsm);\n\t\telse\n\t\t\tgsm->bad_size++;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, gsm->state);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm1_receive\t-\tperform processing for non-transparency\n *\t@gsm: gsm data for this ldisc instance\n *\t@c: character\n *\n *\tReceive bytes in mode 1 (Advanced option)\n */\n\nstatic void gsm1_receive(struct gsm_mux *gsm, unsigned char c)\n{\n\t/* handle XON/XOFF */\n\tif ((c & ISO_IEC_646_MASK) == XON) {\n\t\tgsm->constipated = true;\n\t\treturn;\n\t} else if ((c & ISO_IEC_646_MASK) == XOFF) {\n\t\tgsm->constipated = false;\n\t\t/* Kick the link in case it is idling */\n\t\tgsmld_write_trigger(gsm);\n\t\treturn;\n\t}\n\tif (c == GSM1_SOF) {\n\t\t/* EOF is only valid in frame if we have got to the data state */\n\t\tif (gsm->state == GSM_DATA) {\n\t\t\tif (gsm->count < 1) {\n\t\t\t\t/* Missing FSC */\n\t\t\t\tgsm->malformed++;\n\t\t\t\tgsm->state = GSM_START;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Remove the FCS from data */\n\t\t\tgsm->count--;\n\t\t\tif ((gsm->control & ~PF) != UIH) {\n\t\t\t\t/* Calculate final FCS for UI frames over all\n\t\t\t\t * data but FCS\n\t\t\t\t */\n\t\t\t\tgsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf,\n\t\t\t\t\t\t\t     gsm->count);\n\t\t\t}\n\t\t\t/* Add the FCS itself to test against GOOD_FCS */\n\t\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, gsm->buf[gsm->count]);\n\t\t\tgsm->len = gsm->count;\n\t\t\tgsm_queue(gsm);\n\t\t\tgsm->state  = GSM_START;\n\t\t\treturn;\n\t\t}\n\t\t/* Any partial frame was a runt so go back to start */\n\t\tif (gsm->state != GSM_START) {\n\t\t\tif (gsm->state != GSM_SEARCH)\n\t\t\t\tgsm->malformed++;\n\t\t\tgsm->state = GSM_START;\n\t\t}\n\t\t/* A SOF in GSM_START means we are still reading idling or\n\t\t   framing bytes */\n\t\treturn;\n\t}\n\n\tif (c == GSM1_ESCAPE) {\n\t\tgsm->escape = true;\n\t\treturn;\n\t}\n\n\t/* Only an unescaped SOF gets us out of GSM search */\n\tif (gsm->state == GSM_SEARCH)\n\t\treturn;\n\n\tif (gsm->escape) {\n\t\tc ^= GSM1_ESCAPE_BITS;\n\t\tgsm->escape = false;\n\t}\n\tswitch (gsm->state) {\n\tcase GSM_START:\t\t/* First byte after SOF */\n\t\tgsm->address = 0;\n\t\tgsm->state = GSM_ADDRESS;\n\t\tgsm->fcs = INIT_FCS;\n\t\tfallthrough;\n\tcase GSM_ADDRESS:\t/* Address continuation */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->address, c))\n\t\t\tgsm->state = GSM_CONTROL;\n\t\tbreak;\n\tcase GSM_CONTROL:\t/* Control Byte */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->control = c;\n\t\tgsm->count = 0;\n\t\tgsm->state = GSM_DATA;\n\t\tbreak;\n\tcase GSM_DATA:\t\t/* Data */\n\t\tif (gsm->count > gsm->mru) {\t/* Allow one for the FCS */\n\t\t\tgsm->state = GSM_OVERRUN;\n\t\t\tgsm->bad_size++;\n\t\t} else\n\t\t\tgsm->buf[gsm->count++] = c;\n\t\tbreak;\n\tcase GSM_OVERRUN:\t/* Over-long - eg a dropped SOF */\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, gsm->state);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_error\t\t-\thandle tty error\n *\t@gsm: ldisc data\n *\n *\tHandle an error in the receipt of data for a frame. Currently we just\n *\tgo back to hunting for a SOF.\n *\n *\tFIXME: better diagnostics ?\n */\n\nstatic void gsm_error(struct gsm_mux *gsm)\n{\n\tgsm->state = GSM_SEARCH;\n\tgsm->io_error++;\n}\n\n/**\n *\tgsm_cleanup_mux\t\t-\tgeneric GSM protocol cleanup\n *\t@gsm: our mux\n *\t@disc: disconnect link?\n *\n *\tClean up the bits of the mux which are the same for all framing\n *\tprotocols. Remove the mux from the mux table, stop all the timers\n *\tand then shut down each device hanging up the channels as we go.\n */\n\nstatic void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\n\t/* Finish outstanding timers, making sure they are done */\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\n\t/* Finish writing to ldisc */\n\tflush_work(&gsm->tx_work);\n\n\t/* Free up any link layer users and finally the control channel */\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\t/* Now wipe the queues */\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}\n\n/**\n *\tgsm_activate_mux\t-\tgeneric GSM setup\n *\t@gsm: our mux\n *\n *\tSet up the bits of the mux which are the same for all framing\n *\tprotocols. Add the mux to the mux table so it can be opened and\n *\tfinally kick off connecting to DLCI 0 on the modem.\n */\n\nstatic int gsm_activate_mux(struct gsm_mux *gsm)\n{\n\tstruct gsm_dlci *dlci;\n\tint ret;\n\n\tdlci = gsm_dlci_alloc(gsm, 0);\n\tif (dlci == NULL)\n\t\treturn -ENOMEM;\n\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\tgsm->receive = gsm0_receive;\n\telse\n\t\tgsm->receive = gsm1_receive;\n\n\tret = gsm_register_devices(gsm_tty_driver, gsm->num);\n\tif (ret)\n\t\treturn ret;\n\n\tgsm->has_devices = true;\n\tgsm->dead = false;\t\t/* Tty opens are now permissible */\n\treturn 0;\n}\n\n/**\n *\tgsm_free_mux\t\t-\tfree up a mux\n *\t@gsm: mux to free\n *\n *\tDispose of allocated resources for a dead mux\n */\nstatic void gsm_free_mux(struct gsm_mux *gsm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_MUX; i++) {\n\t\tif (gsm == gsm_mux[i]) {\n\t\t\tgsm_mux[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_destroy(&gsm->mutex);\n\tkfree(gsm->txframe);\n\tkfree(gsm->buf);\n\tkfree(gsm);\n}\n\n/**\n *\tgsm_free_muxr\t\t-\tfree up a mux\n *\t@ref: kreference to the mux to free\n *\n *\tDispose of allocated resources for a dead mux\n */\nstatic void gsm_free_muxr(struct kref *ref)\n{\n\tstruct gsm_mux *gsm = container_of(ref, struct gsm_mux, ref);\n\tgsm_free_mux(gsm);\n}\n\nstatic inline void mux_get(struct gsm_mux *gsm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm_mux_lock, flags);\n\tkref_get(&gsm->ref);\n\tspin_unlock_irqrestore(&gsm_mux_lock, flags);\n}\n\nstatic inline void mux_put(struct gsm_mux *gsm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm_mux_lock, flags);\n\tkref_put(&gsm->ref, gsm_free_muxr);\n\tspin_unlock_irqrestore(&gsm_mux_lock, flags);\n}\n\nstatic inline unsigned int mux_num_to_base(struct gsm_mux *gsm)\n{\n\treturn gsm->num * NUM_DLCI;\n}\n\nstatic inline unsigned int mux_line_to_num(unsigned int line)\n{\n\treturn line / NUM_DLCI;\n}\n\n/**\n *\tgsm_alloc_mux\t\t-\tallocate a mux\n *\n *\tCreates a new mux ready for activation.\n */\n\nstatic struct gsm_mux *gsm_alloc_mux(void)\n{\n\tint i;\n\tstruct gsm_mux *gsm = kzalloc(sizeof(struct gsm_mux), GFP_KERNEL);\n\tif (gsm == NULL)\n\t\treturn NULL;\n\tgsm->buf = kmalloc(MAX_MRU + 1, GFP_KERNEL);\n\tif (gsm->buf == NULL) {\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\tgsm->txframe = kmalloc(2 * (MAX_MTU + PROT_OVERHEAD - 1), GFP_KERNEL);\n\tif (gsm->txframe == NULL) {\n\t\tkfree(gsm->buf);\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&gsm->lock);\n\tmutex_init(&gsm->mutex);\n\tkref_init(&gsm->ref);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n\ttimer_setup(&gsm->kick_timer, gsm_kick_timer, 0);\n\ttimer_setup(&gsm->t2_timer, gsm_control_retransmit, 0);\n\ttimer_setup(&gsm->ka_timer, gsm_control_keep_alive, 0);\n\tINIT_WORK(&gsm->tx_work, gsmld_write_task);\n\tinit_waitqueue_head(&gsm->event);\n\tspin_lock_init(&gsm->control_lock);\n\tspin_lock_init(&gsm->tx_lock);\n\n\tgsm->t1 = T1;\n\tgsm->t2 = T2;\n\tgsm->t3 = T3;\n\tgsm->n2 = N2;\n\tgsm->k = K;\n\tgsm->ftype = UIH;\n\tgsm->adaption = 1;\n\tgsm->encoding = GSM_ADV_OPT;\n\tgsm->mru = 64;\t/* Default to encoding 1 so these should be 64 */\n\tgsm->mtu = 64;\n\tgsm->dead = true;\t/* Avoid early tty opens */\n\tgsm->wait_config = false; /* Disabled */\n\tgsm->keep_alive = 0;\t/* Disabled */\n\n\t/* Store the instance to the mux array or abort if no space is\n\t * available.\n\t */\n\tspin_lock(&gsm_mux_lock);\n\tfor (i = 0; i < MAX_MUX; i++) {\n\t\tif (!gsm_mux[i]) {\n\t\t\tgsm_mux[i] = gsm;\n\t\t\tgsm->num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&gsm_mux_lock);\n\tif (i == MAX_MUX) {\n\t\tmutex_destroy(&gsm->mutex);\n\t\tkfree(gsm->txframe);\n\t\tkfree(gsm->buf);\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\n\treturn gsm;\n}\n\nstatic void gsm_copy_config_values(struct gsm_mux *gsm,\n\t\t\t\t   struct gsm_config *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->adaption = gsm->adaption;\n\tc->encapsulation = gsm->encoding;\n\tc->initiator = gsm->initiator;\n\tc->t1 = gsm->t1;\n\tc->t2 = gsm->t2;\n\tc->t3 = gsm->t3;\n\tc->n2 = gsm->n2;\n\tif (gsm->ftype == UIH)\n\t\tc->i = 1;\n\telse\n\t\tc->i = 2;\n\tpr_debug(\"Ftype %d i %d\\n\", gsm->ftype, c->i);\n\tc->mru = gsm->mru;\n\tc->mtu = gsm->mtu;\n\tc->k = gsm->k;\n}\n\nstatic int gsm_config(struct gsm_mux *gsm, struct gsm_config *c)\n{\n\tint ret = 0;\n\tint need_close = 0;\n\tint need_restart = 0;\n\n\t/* Stuff we don't support yet - UI or I frame transport */\n\tif (c->adaption != 1 && c->adaption != 2)\n\t\treturn -EOPNOTSUPP;\n\t/* Check the MRU/MTU range looks sane */\n\tif (c->mru < MIN_MTU || c->mtu < MIN_MTU)\n\t\treturn -EINVAL;\n\tif (c->mru > MAX_MRU || c->mtu > MAX_MTU)\n\t\treturn -EINVAL;\n\tif (c->t3 > MAX_T3)\n\t\treturn -EINVAL;\n\tif (c->n2 > 255)\n\t\treturn -EINVAL;\n\tif (c->encapsulation > 1)\t/* Basic, advanced, no I */\n\t\treturn -EINVAL;\n\tif (c->initiator > 1)\n\t\treturn -EINVAL;\n\tif (c->k > MAX_WINDOW_SIZE)\n\t\treturn -EINVAL;\n\tif (c->i == 0 || c->i > 2)\t/* UIH and UI only */\n\t\treturn -EINVAL;\n\t/*\n\t * See what is needed for reconfiguration\n\t */\n\n\t/* Timing fields */\n\tif (c->t1 != 0 && c->t1 != gsm->t1)\n\t\tneed_restart = 1;\n\tif (c->t2 != 0 && c->t2 != gsm->t2)\n\t\tneed_restart = 1;\n\tif (c->encapsulation != gsm->encoding)\n\t\tneed_restart = 1;\n\tif (c->adaption != gsm->adaption)\n\t\tneed_restart = 1;\n\t/* Requires care */\n\tif (c->initiator != gsm->initiator)\n\t\tneed_close = 1;\n\tif (c->mru != gsm->mru)\n\t\tneed_restart = 1;\n\tif (c->mtu != gsm->mtu)\n\t\tneed_restart = 1;\n\n\t/*\n\t * Close down what is needed, restart and initiate the new\n\t * configuration. On the first time there is no DLCI[0]\n\t * and closing or cleaning up is not necessary.\n\t */\n\tif (need_close || need_restart)\n\t\tgsm_cleanup_mux(gsm, true);\n\n\tgsm->initiator = c->initiator;\n\tgsm->mru = c->mru;\n\tgsm->mtu = c->mtu;\n\tgsm->encoding = c->encapsulation ? GSM_ADV_OPT : GSM_BASIC_OPT;\n\tgsm->adaption = c->adaption;\n\tgsm->n2 = c->n2;\n\n\tif (c->i == 1)\n\t\tgsm->ftype = UIH;\n\telse if (c->i == 2)\n\t\tgsm->ftype = UI;\n\n\tif (c->t1)\n\t\tgsm->t1 = c->t1;\n\tif (c->t2)\n\t\tgsm->t2 = c->t2;\n\tif (c->t3)\n\t\tgsm->t3 = c->t3;\n\tif (c->k)\n\t\tgsm->k = c->k;\n\n\t/*\n\t * FIXME: We need to separate activation/deactivation from adding\n\t * and removing from the mux array\n\t */\n\tif (gsm->dead) {\n\t\tret = gsm_activate_mux(gsm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(gsm->dlci[0]);\n\t}\n\treturn 0;\n}\n\nstatic void gsm_copy_config_ext_values(struct gsm_mux *gsm,\n\t\t\t\t       struct gsm_config_ext *ce)\n{\n\tmemset(ce, 0, sizeof(*ce));\n\tce->wait_config = gsm->wait_config ? 1 : 0;\n\tce->keep_alive = gsm->keep_alive;\n}\n\nstatic int gsm_config_ext(struct gsm_mux *gsm, struct gsm_config_ext *ce)\n{\n\tunsigned int i;\n\n\t/*\n\t * Check that userspace doesn't put stuff in here to prevent breakages\n\t * in the future.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(ce->reserved); i++)\n\t\tif (ce->reserved[i])\n\t\t\treturn -EINVAL;\n\n\t/*\n\t * Setup the new configuration values\n\t */\n\tgsm->wait_config = ce->wait_config ? true : false;\n\tgsm->keep_alive = ce->keep_alive;\n\n\treturn 0;\n}\n\n/**\n *\tgsmld_output\t\t-\twrite to link\n *\t@gsm: our mux\n *\t@data: bytes to output\n *\t@len: size\n *\n *\tWrite a block of data from the GSM mux to the data channel. This\n *\twill eventually be serialized from above but at the moment isn't.\n */\n\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len)\n{\n\tif (tty_write_room(gsm->tty) < len) {\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\n\t\treturn -ENOSPC;\n\t}\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, data, len);\n\treturn gsm->tty->ops->write(gsm->tty, data, len);\n}\n\n\n/**\n *\tgsmld_write_trigger\t-\tschedule ldisc write task\n *\t@gsm: our mux\n */\nstatic void gsmld_write_trigger(struct gsm_mux *gsm)\n{\n\tif (!gsm || !gsm->dlci[0] || gsm->dlci[0]->dead)\n\t\treturn;\n\tschedule_work(&gsm->tx_work);\n}\n\n\n/**\n *\tgsmld_write_task\t-\tldisc write task\n *\t@work: our tx write work\n *\n *\tWrites out data to the ldisc if possible. We are doing this here to\n *\tavoid dead-locking. This returns if no space or data is left for output.\n */\nstatic void gsmld_write_task(struct work_struct *work)\n{\n\tstruct gsm_mux *gsm = container_of(work, struct gsm_mux, tx_work);\n\tunsigned long flags;\n\tint i, ret;\n\n\t/* All outstanding control channel and control messages and one data\n\t * frame is sent.\n\t */\n\tret = -ENODEV;\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tif (gsm->tty)\n\t\tret = gsm_data_kick(gsm);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\tif (ret >= 0)\n\t\tfor (i = 0; i < NUM_DLCI; i++)\n\t\t\tif (gsm->dlci[i])\n\t\t\t\ttty_port_tty_wakeup(&gsm->dlci[i]->port);\n}\n\n/**\n *\tgsmld_attach_gsm\t-\tmode set up\n *\t@tty: our tty structure\n *\t@gsm: our mux\n *\n *\tSet up the MUX for basic mode and commence connecting to the\n *\tmodem. Currently called from the line discipline set up but\n *\twill need moving to an ioctl path.\n */\n\nstatic void gsmld_attach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\n{\n\tgsm->tty = tty_kref_get(tty);\n\t/* Turn off tty XON/XOFF handling to handle it explicitly. */\n\tgsm->old_c_iflag = tty->termios.c_iflag;\n\ttty->termios.c_iflag &= (IXON | IXOFF);\n}\n\n/**\n *\tgsmld_detach_gsm\t-\tstop doing 0710 mux\n *\t@tty: tty attached to the mux\n *\t@gsm: mux\n *\n *\tShutdown and then clean up the resources used by the line discipline\n */\n\nstatic void gsmld_detach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\n{\n\tWARN_ON(tty != gsm->tty);\n\t/* Restore tty XON/XOFF handling. */\n\tgsm->tty->termios.c_iflag = gsm->old_c_iflag;\n\ttty_kref_put(gsm->tty);\n\tgsm->tty = NULL;\n}\n\nstatic void gsmld_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      const char *fp, int count)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tchar flags = TTY_NORMAL;\n\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, cp, count);\n\n\tfor (; count; count--, cp++) {\n\t\tif (fp)\n\t\t\tflags = *fp++;\n\t\tswitch (flags) {\n\t\tcase TTY_NORMAL:\n\t\t\tif (gsm->receive)\n\t\t\t\tgsm->receive(gsm, *cp);\n\t\t\tbreak;\n\t\tcase TTY_OVERRUN:\n\t\tcase TTY_BREAK:\n\t\tcase TTY_PARITY:\n\t\tcase TTY_FRAME:\n\t\t\tgsm_error(gsm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"%s: unknown flag %d\\n\",\n\t\t\t       tty_name(tty), flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* FASYNC if needed ? */\n\t/* If clogged call tty_throttle(tty); */\n}\n\n/**\n *\tgsmld_flush_buffer\t-\tclean input queue\n *\t@tty:\tterminal device\n *\n *\tFlush the input buffer. Called when the line discipline is\n *\tbeing closed, when the tty layer wants the buffer flushed (eg\n *\tat hangup).\n */\n\nstatic void gsmld_flush_buffer(struct tty_struct *tty)\n{\n}\n\n/**\n *\tgsmld_close\t\t-\tclose the ldisc for this tty\n *\t@tty: device\n *\n *\tCalled from the terminal layer when this line discipline is\n *\tbeing shut down, either because of a close or becsuse of a\n *\tdiscipline change. The function will not be called while other\n *\tldisc methods are in progress.\n */\n\nstatic void gsmld_close(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\t/* The ldisc locks and closes the port before calling our close. This\n\t * means we have no way to do a proper disconnect. We will not bother\n\t * to do one.\n\t */\n\tgsm_cleanup_mux(gsm, false);\n\n\tgsmld_detach_gsm(tty, gsm);\n\n\tgsmld_flush_buffer(tty);\n\t/* Do other clean up here */\n\tmux_put(gsm);\n}\n\n/**\n *\tgsmld_open\t\t-\topen an ldisc\n *\t@tty: terminal to open\n *\n *\tCalled when this line discipline is being attached to the\n *\tterminal device. Can sleep. Called serialized so that no\n *\tother events will occur in parallel. No further open will occur\n *\tuntil a close.\n */\n\nstatic int gsmld_open(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EINVAL;\n\n\t/* Attach our ldisc data */\n\tgsm = gsm_alloc_mux();\n\tif (gsm == NULL)\n\t\treturn -ENOMEM;\n\n\ttty->disc_data = gsm;\n\ttty->receive_room = 65536;\n\n\t/* Attach the initial passive connection */\n\tgsmld_attach_gsm(tty, gsm);\n\n\t/* The mux will not be activated yet, we wait for correct\n\t * configuration first.\n\t */\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\tgsm->receive = gsm0_receive;\n\telse\n\t\tgsm->receive = gsm1_receive;\n\n\treturn 0;\n}\n\n/**\n *\tgsmld_write_wakeup\t-\tasynchronous I/O notifier\n *\t@tty: tty device\n *\n *\tRequired for the ptys, serial driver etc. since processes\n *\tthat attach themselves to the master and rely on ASYNC\n *\tIO must be woken up\n */\n\nstatic void gsmld_write_wakeup(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\t/* Queue poll */\n\tgsmld_write_trigger(gsm);\n}\n\n/**\n *\tgsmld_read\t\t-\tread function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\t@cookie: unused\n *\t@offset: unused\n *\n *\tPerform reads for the line discipline. We are guaranteed that the\n *\tline discipline will not be closed under us but we may get multiple\n *\tparallel readers and must handle this ourselves. We may also get\n *\ta hangup. Always called in user context, may sleep.\n *\n *\tThis code must be sure never to sleep through a hangup.\n */\n\nstatic ssize_t gsmld_read(struct tty_struct *tty, struct file *file,\n\t\t\t  unsigned char *buf, size_t nr,\n\t\t\t  void **cookie, unsigned long offset)\n{\n\treturn -EOPNOTSUPP;\n}\n\n/**\n *\tgsmld_write\t\t-\twrite function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tCalled when the owner of the device wants to send a frame\n *\titself (or some other control data). The data is transferred\n *\tas-is and must be properly framed and checksummed as appropriate\n *\tby userspace. Frames are either sent whole or not at all as this\n *\tavoids pain user side.\n */\n\nstatic ssize_t gsmld_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tunsigned long flags;\n\tint space;\n\tint ret;\n\n\tif (!gsm)\n\t\treturn -ENODEV;\n\n\tret = -ENOBUFS;\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tspace = tty_write_room(tty);\n\tif (space >= nr)\n\t\tret = tty->ops->write(tty, buf, nr);\n\telse\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\treturn ret;\n}\n\n/**\n *\tgsmld_poll\t\t-\tpoll method for N_GSM0710\n *\t@tty: terminal device\n *\t@file: file accessing it\n *\t@wait: poll table\n *\n *\tCalled when the line discipline is asked to poll() for data or\n *\tfor special events. This code is not serialized with respect to\n *\tother events save open/close.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\tCalled without the kernel lock held - fine\n */\n\nstatic __poll_t gsmld_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\n\tif (gsm->dead)\n\t\tmask |= EPOLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= EPOLLHUP;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= EPOLLHUP;\n\tif (!tty_is_writelocked(tty) && tty_write_room(tty) > 0)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\nstatic int gsmld_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tstruct gsm_config c;\n\tstruct gsm_config_ext ce;\n\tstruct gsm_dlci_config dc;\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tunsigned int base, addr;\n\tstruct gsm_dlci *dlci;\n\n\tswitch (cmd) {\n\tcase GSMIOC_GETCONF:\n\t\tgsm_copy_config_values(gsm, &c);\n\t\tif (copy_to_user((void __user *)arg, &c, sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF:\n\t\tif (copy_from_user(&c, (void __user *)arg, sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\treturn gsm_config(gsm, &c);\n\tcase GSMIOC_GETFIRST:\n\t\tbase = mux_num_to_base(gsm);\n\t\treturn put_user(base + 1, (__u32 __user *)arg);\n\tcase GSMIOC_GETCONF_EXT:\n\t\tgsm_copy_config_ext_values(gsm, &ce);\n\t\tif (copy_to_user((void __user *)arg, &ce, sizeof(ce)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_EXT:\n\t\tif (copy_from_user(&ce, (void __user *)arg, sizeof(ce)))\n\t\t\treturn -EFAULT;\n\t\treturn gsm_config_ext(gsm, &ce);\n\tcase GSMIOC_GETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel == 0 || dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\taddr = array_index_nospec(dc.channel, NUM_DLCI);\n\t\tdlci = gsm->dlci[addr];\n\t\tif (!dlci) {\n\t\t\tdlci = gsm_dlci_alloc(gsm, addr);\n\t\t\tif (!dlci)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tgsm_dlci_copy_config_values(dlci, &dc);\n\t\tif (copy_to_user((void __user *)arg, &dc, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel == 0 || dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\taddr = array_index_nospec(dc.channel, NUM_DLCI);\n\t\tdlci = gsm->dlci[addr];\n\t\tif (!dlci) {\n\t\t\tdlci = gsm_dlci_alloc(gsm, addr);\n\t\t\tif (!dlci)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn gsm_dlci_config(dlci, &dc, 0);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, cmd, arg);\n\t}\n}\n\n/*\n *\tNetwork interface\n *\n */\n\nstatic int gsm_mux_net_open(struct net_device *net)\n{\n\tpr_debug(\"%s called\\n\", __func__);\n\tnetif_start_queue(net);\n\treturn 0;\n}\n\nstatic int gsm_mux_net_close(struct net_device *net)\n{\n\tnetif_stop_queue(net);\n\treturn 0;\n}\n\nstatic void dlci_net_free(struct gsm_dlci *dlci)\n{\n\tif (!dlci->net) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tdlci->adaption = dlci->prev_adaption;\n\tdlci->data = dlci->prev_data;\n\tfree_netdev(dlci->net);\n\tdlci->net = NULL;\n}\nstatic void net_free(struct kref *ref)\n{\n\tstruct gsm_mux_net *mux_net;\n\tstruct gsm_dlci *dlci;\n\n\tmux_net = container_of(ref, struct gsm_mux_net, ref);\n\tdlci = mux_net->dlci;\n\n\tif (dlci->net) {\n\t\tunregister_netdev(dlci->net);\n\t\tdlci_net_free(dlci);\n\t}\n}\n\nstatic inline void muxnet_get(struct gsm_mux_net *mux_net)\n{\n\tkref_get(&mux_net->ref);\n}\n\nstatic inline void muxnet_put(struct gsm_mux_net *mux_net)\n{\n\tkref_put(&mux_net->ref, net_free);\n}\n\nstatic netdev_tx_t gsm_mux_net_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *net)\n{\n\tstruct gsm_mux_net *mux_net = netdev_priv(net);\n\tstruct gsm_dlci *dlci = mux_net->dlci;\n\tmuxnet_get(mux_net);\n\n\tskb_queue_head(&dlci->skb_list, skb);\n\tnet->stats.tx_packets++;\n\tnet->stats.tx_bytes += skb->len;\n\tgsm_dlci_data_kick(dlci);\n\t/* And tell the kernel when the last transmit started. */\n\tnetif_trans_update(net);\n\tmuxnet_put(mux_net);\n\treturn NETDEV_TX_OK;\n}\n\n/* called when a packet did not ack after watchdogtimeout */\nstatic void gsm_mux_net_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\t/* Tell syslog we are hosed. */\n\tdev_dbg(&net->dev, \"Tx timed out.\\n\");\n\n\t/* Update statistics */\n\tnet->stats.tx_errors++;\n}\n\nstatic void gsm_mux_rx_netchar(struct gsm_dlci *dlci,\n\t\t\t\tconst unsigned char *in_buf, int size)\n{\n\tstruct net_device *net = dlci->net;\n\tstruct sk_buff *skb;\n\tstruct gsm_mux_net *mux_net = netdev_priv(net);\n\tmuxnet_get(mux_net);\n\n\t/* Allocate an sk_buff */\n\tskb = dev_alloc_skb(size + NET_IP_ALIGN);\n\tif (!skb) {\n\t\t/* We got no receive buffer. */\n\t\tnet->stats.rx_dropped++;\n\t\tmuxnet_put(mux_net);\n\t\treturn;\n\t}\n\tskb_reserve(skb, NET_IP_ALIGN);\n\tskb_put_data(skb, in_buf, size);\n\n\tskb->dev = net;\n\tskb->protocol = htons(ETH_P_IP);\n\n\t/* Ship it off to the kernel */\n\tnetif_rx(skb);\n\n\t/* update out statistics */\n\tnet->stats.rx_packets++;\n\tnet->stats.rx_bytes += size;\n\tmuxnet_put(mux_net);\n\treturn;\n}\n\nstatic void gsm_mux_net_init(struct net_device *net)\n{\n\tstatic const struct net_device_ops gsm_netdev_ops = {\n\t\t.ndo_open\t\t= gsm_mux_net_open,\n\t\t.ndo_stop\t\t= gsm_mux_net_close,\n\t\t.ndo_start_xmit\t\t= gsm_mux_net_start_xmit,\n\t\t.ndo_tx_timeout\t\t= gsm_mux_net_tx_timeout,\n\t};\n\n\tnet->netdev_ops = &gsm_netdev_ops;\n\n\t/* fill in the other fields */\n\tnet->watchdog_timeo = GSM_NET_TX_TIMEOUT;\n\tnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tnet->type = ARPHRD_NONE;\n\tnet->tx_queue_len = 10;\n}\n\n\n/* caller holds the dlci mutex */\nstatic void gsm_destroy_network(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux_net *mux_net;\n\n\tpr_debug(\"destroy network interface\\n\");\n\tif (!dlci->net)\n\t\treturn;\n\tmux_net = netdev_priv(dlci->net);\n\tmuxnet_put(mux_net);\n}\n\n\n/* caller holds the dlci mutex */\nstatic int gsm_create_network(struct gsm_dlci *dlci, struct gsm_netconfig *nc)\n{\n\tchar *netname;\n\tint retval = 0;\n\tstruct net_device *net;\n\tstruct gsm_mux_net *mux_net;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Already in a non tty mode */\n\tif (dlci->adaption > 2)\n\t\treturn -EBUSY;\n\n\tif (nc->protocol != htons(ETH_P_IP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (nc->adaption != 3 && nc->adaption != 4)\n\t\treturn -EPROTONOSUPPORT;\n\n\tpr_debug(\"create network interface\\n\");\n\n\tnetname = \"gsm%d\";\n\tif (nc->if_name[0] != '\\0')\n\t\tnetname = nc->if_name;\n\tnet = alloc_netdev(sizeof(struct gsm_mux_net), netname,\n\t\t\t   NET_NAME_UNKNOWN, gsm_mux_net_init);\n\tif (!net) {\n\t\tpr_err(\"alloc_netdev failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tnet->mtu = dlci->mtu;\n\tnet->min_mtu = MIN_MTU;\n\tnet->max_mtu = dlci->mtu;\n\tmux_net = netdev_priv(net);\n\tmux_net->dlci = dlci;\n\tkref_init(&mux_net->ref);\n\tstrncpy(nc->if_name, net->name, IFNAMSIZ); /* return net name */\n\n\t/* reconfigure dlci for network */\n\tdlci->prev_adaption = dlci->adaption;\n\tdlci->prev_data = dlci->data;\n\tdlci->adaption = nc->adaption;\n\tdlci->data = gsm_mux_rx_netchar;\n\tdlci->net = net;\n\n\tpr_debug(\"register netdev\\n\");\n\tretval = register_netdev(net);\n\tif (retval) {\n\t\tpr_err(\"network register fail %d\\n\", retval);\n\t\tdlci_net_free(dlci);\n\t\treturn retval;\n\t}\n\treturn net->ifindex;\t/* return network index */\n}\n\n/* Line discipline for real tty */\nstatic struct tty_ldisc_ops tty_ldisc_packet = {\n\t.owner\t\t = THIS_MODULE,\n\t.num\t\t = N_GSM0710,\n\t.name            = \"n_gsm\",\n\t.open            = gsmld_open,\n\t.close           = gsmld_close,\n\t.flush_buffer    = gsmld_flush_buffer,\n\t.read            = gsmld_read,\n\t.write           = gsmld_write,\n\t.ioctl           = gsmld_ioctl,\n\t.poll            = gsmld_poll,\n\t.receive_buf     = gsmld_receive_buf,\n\t.write_wakeup    = gsmld_write_wakeup\n};\n\n/*\n *\tVirtual tty side\n */\n\n/**\n *\tgsm_modem_upd_via_data\t-\tsend modem bits via convergence layer\n *\t@dlci: channel\n *\t@brk: break signal\n *\n *\tSend an empty frame to signal mobile state changes and to transmit the\n *\tbreak signal for adaption 2.\n */\n\nstatic void gsm_modem_upd_via_data(struct gsm_dlci *dlci, u8 brk)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tunsigned long flags;\n\n\tif (dlci->state != DLCI_OPEN || dlci->adaption != 2)\n\t\treturn;\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tgsm_dlci_modem_output(gsm, dlci, brk);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n}\n\n/**\n *\tgsm_modem_upd_via_msc\t-\tsend modem bits via control frame\n *\t@dlci: channel\n *\t@brk: break signal\n */\n\nstatic int gsm_modem_upd_via_msc(struct gsm_dlci *dlci, u8 brk)\n{\n\tu8 modembits[3];\n\tstruct gsm_control *ctrl;\n\tint len = 2;\n\n\tif (dlci->gsm->encoding != GSM_BASIC_OPT)\n\t\treturn 0;\n\n\tmodembits[0] = (dlci->addr << 2) | 2 | EA;  /* DLCI, Valid, EA */\n\tif (!brk) {\n\t\tmodembits[1] = (gsm_encode_modem(dlci) << 1) | EA;\n\t} else {\n\t\tmodembits[1] = gsm_encode_modem(dlci) << 1;\n\t\tmodembits[2] = (brk << 4) | 2 | EA; /* Length, Break, EA */\n\t\tlen++;\n\t}\n\tctrl = gsm_control_send(dlci->gsm, CMD_MSC, modembits, len);\n\tif (ctrl == NULL)\n\t\treturn -ENOMEM;\n\treturn gsm_control_wait(dlci->gsm, ctrl);\n}\n\n/**\n *\tgsm_modem_update\t-\tsend modem status line state\n *\t@dlci: channel\n *\t@brk: break signal\n */\n\nstatic int gsm_modem_update(struct gsm_dlci *dlci, u8 brk)\n{\n\tif (dlci->adaption == 2) {\n\t\t/* Send convergence layer type 2 empty data frame. */\n\t\tgsm_modem_upd_via_data(dlci, brk);\n\t\treturn 0;\n\t} else if (dlci->gsm->encoding == GSM_BASIC_OPT) {\n\t\t/* Send as MSC control message. */\n\t\treturn gsm_modem_upd_via_msc(dlci, brk);\n\t}\n\n\t/* Modem status lines are not supported. */\n\treturn -EPROTONOSUPPORT;\n}\n\n/**\n * gsm_wait_modem_change - wait for modem status line change\n * @dlci: channel\n * @mask: modem status line bits\n *\n * The function returns if:\n * - any given modem status line bit changed\n * - the wait event function got interrupted (e.g. by a signal)\n * - the underlying DLCI was closed\n * - the underlying ldisc device was removed\n */\nstatic int gsm_wait_modem_change(struct gsm_dlci *dlci, u32 mask)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tu32 old = dlci->modem_rx;\n\tint ret;\n\n\tret = wait_event_interruptible(gsm->event, gsm->dead ||\n\t\t\t\t       dlci->state != DLCI_OPEN ||\n\t\t\t\t       (old ^ dlci->modem_rx) & mask);\n\tif (gsm->dead)\n\t\treturn -ENODEV;\n\tif (dlci->state != DLCI_OPEN)\n\t\treturn -EL2NSYNC;\n\treturn ret;\n}\n\nstatic bool gsm_carrier_raised(struct tty_port *port)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\t/* Not yet open so no carrier info */\n\tif (dlci->state != DLCI_OPEN)\n\t\treturn false;\n\tif (debug & DBG_CD_ON)\n\t\treturn true;\n\n\t/*\n\t * Basic mode with control channel in ADM mode may not respond\n\t * to CMD_MSC at all and modem_rx is empty.\n\t */\n\tif (gsm->encoding == GSM_BASIC_OPT &&\n\t    gsm->dlci[0]->mode == DLCI_MODE_ADM && !dlci->modem_rx)\n\t\treturn true;\n\n\treturn dlci->modem_rx & TIOCM_CD;\n}\n\nstatic void gsm_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\tunsigned int modem_tx = dlci->modem_tx;\n\tif (active)\n\t\tmodem_tx |= TIOCM_DTR | TIOCM_RTS;\n\telse\n\t\tmodem_tx &= ~(TIOCM_DTR | TIOCM_RTS);\n\tif (modem_tx != dlci->modem_tx) {\n\t\tdlci->modem_tx = modem_tx;\n\t\tgsm_modem_update(dlci, 0);\n\t}\n}\n\nstatic const struct tty_port_operations gsm_port_ops = {\n\t.carrier_raised = gsm_carrier_raised,\n\t.dtr_rts = gsm_dtr_rts,\n\t.destruct = gsm_dlci_free,\n};\n\nstatic int gsmtty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm;\n\tstruct gsm_dlci *dlci;\n\tunsigned int line = tty->index;\n\tunsigned int mux = mux_line_to_num(line);\n\tbool alloc = false;\n\tint ret;\n\n\tline = line & 0x3F;\n\n\tif (mux >= MAX_MUX)\n\t\treturn -ENXIO;\n\t/* FIXME: we need to lock gsm_mux for lifetimes of ttys eventually */\n\tif (gsm_mux[mux] == NULL)\n\t\treturn -EUNATCH;\n\tif (line == 0 || line > 61)\t/* 62/63 reserved */\n\t\treturn -ECHRNG;\n\tgsm = gsm_mux[mux];\n\tif (gsm->dead)\n\t\treturn -EL2HLT;\n\t/* If DLCI 0 is not yet fully open return an error.\n\tThis is ok from a locking\n\tperspective as we don't have to worry about this\n\tif DLCI0 is lost */\n\tmutex_lock(&gsm->mutex);\n\tif (gsm->dlci[0] && gsm->dlci[0]->state != DLCI_OPEN) {\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn -EL2NSYNC;\n\t}\n\tdlci = gsm->dlci[line];\n\tif (dlci == NULL) {\n\t\talloc = true;\n\t\tdlci = gsm_dlci_alloc(gsm, line);\n\t}\n\tif (dlci == NULL) {\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn -ENOMEM;\n\t}\n\tret = tty_port_install(&dlci->port, driver, tty);\n\tif (ret) {\n\t\tif (alloc)\n\t\t\tdlci_put(dlci);\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn ret;\n\t}\n\n\tdlci_get(dlci);\n\tdlci_get(gsm->dlci[0]);\n\tmux_get(gsm);\n\ttty->driver_data = dlci;\n\tmutex_unlock(&gsm->mutex);\n\n\treturn 0;\n}\n\nstatic int gsmtty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct tty_port *port = &dlci->port;\n\n\tport->count++;\n\ttty_port_tty_set(port, tty);\n\n\tdlci->modem_rx = 0;\n\t/* We could in theory open and close before we wait - eg if we get\n\t   a DM straight back. This is ok as that will have caused a hangup */\n\ttty_port_set_initialized(port, true);\n\t/* Start sending off SABM messages */\n\tif (!dlci->gsm->wait_config) {\n\t\t/* Start sending off SABM messages */\n\t\tif (dlci->gsm->initiator)\n\t\t\tgsm_dlci_begin_open(dlci);\n\t\telse\n\t\t\tgsm_dlci_set_opening(dlci);\n\t} else {\n\t\tgsm_dlci_set_wait_config(dlci);\n\t}\n\t/* And wait for virtual carrier */\n\treturn tty_port_block_til_ready(port, tty, filp);\n}\n\nstatic void gsmtty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\n\tif (dlci == NULL)\n\t\treturn;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tmutex_lock(&dlci->mutex);\n\tgsm_destroy_network(dlci);\n\tmutex_unlock(&dlci->mutex);\n\tif (tty_port_close_start(&dlci->port, tty, filp) == 0)\n\t\treturn;\n\tgsm_dlci_begin_close(dlci);\n\tif (tty_port_initialized(&dlci->port) && C_HUPCL(tty))\n\t\ttty_port_lower_dtr_rts(&dlci->port);\n\ttty_port_close_end(&dlci->port, tty);\n\ttty_port_tty_set(&dlci->port, NULL);\n\treturn;\n}\n\nstatic void gsmtty_hangup(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\ttty_port_hangup(&dlci->port);\n\tgsm_dlci_begin_close(dlci);\n}\n\nstatic int gsmtty_write(struct tty_struct *tty, const unsigned char *buf,\n\t\t\t\t\t\t\t\t    int len)\n{\n\tint sent;\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\t/* Stuff the bytes into the fifo queue */\n\tsent = kfifo_in_locked(&dlci->fifo, buf, len, &dlci->lock);\n\t/* Need to kick the channel */\n\tgsm_dlci_data_kick(dlci);\n\treturn sent;\n}\n\nstatic unsigned int gsmtty_write_room(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn 0;\n\treturn kfifo_avail(&dlci->fifo);\n}\n\nstatic unsigned int gsmtty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn 0;\n\treturn kfifo_len(&dlci->fifo);\n}\n\nstatic void gsmtty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tunsigned long flags;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\t/* Caution needed: If we implement reliable transport classes\n\t   then the data being transmitted can't simply be junked once\n\t   it has first hit the stack. Until then we can just blow it\n\t   away */\n\tspin_lock_irqsave(&dlci->lock, flags);\n\tkfifo_reset(&dlci->fifo);\n\tspin_unlock_irqrestore(&dlci->lock, flags);\n\t/* Need to unhook this DLCI from the transmit queue logic */\n}\n\nstatic void gsmtty_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\t/* The FIFO handles the queue so the kernel will do the right\n\t   thing waiting on chars_in_buffer before calling us. No work\n\t   to do here */\n}\n\nstatic int gsmtty_tiocmget(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\treturn dlci->modem_rx;\n}\n\nstatic int gsmtty_tiocmset(struct tty_struct *tty,\n\tunsigned int set, unsigned int clear)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tunsigned int modem_tx = dlci->modem_tx;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\tmodem_tx &= ~clear;\n\tmodem_tx |= set;\n\n\tif (modem_tx != dlci->modem_tx) {\n\t\tdlci->modem_tx = modem_tx;\n\t\treturn gsm_modem_update(dlci, 0);\n\t}\n\treturn 0;\n}\n\n\nstatic int gsmtty_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct gsm_netconfig nc;\n\tstruct gsm_dlci_config dc;\n\tint index;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\tswitch (cmd) {\n\tcase GSMIOC_ENABLE_NET:\n\t\tif (copy_from_user(&nc, (void __user *)arg, sizeof(nc)))\n\t\t\treturn -EFAULT;\n\t\tnc.if_name[IFNAMSIZ-1] = '\\0';\n\t\t/* return net interface index or error code */\n\t\tmutex_lock(&dlci->mutex);\n\t\tindex = gsm_create_network(dlci, &nc);\n\t\tmutex_unlock(&dlci->mutex);\n\t\tif (copy_to_user((void __user *)arg, &nc, sizeof(nc)))\n\t\t\treturn -EFAULT;\n\t\treturn index;\n\tcase GSMIOC_DISABLE_NET:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&dlci->mutex);\n\t\tgsm_destroy_network(dlci);\n\t\tmutex_unlock(&dlci->mutex);\n\t\treturn 0;\n\tcase GSMIOC_GETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel != dlci->addr)\n\t\t\treturn -EPERM;\n\t\tgsm_dlci_copy_config_values(dlci, &dc);\n\t\tif (copy_to_user((void __user *)arg, &dc, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\tif (dc.channel != 0 && dc.channel != dlci->addr)\n\t\t\treturn -EPERM;\n\t\treturn gsm_dlci_config(dlci, &dc, 1);\n\tcase TIOCMIWAIT:\n\t\treturn gsm_wait_modem_change(dlci, (u32)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic void gsmtty_set_termios(struct tty_struct *tty,\n\t\t\t       const struct ktermios *old)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\t/* For the moment its fixed. In actual fact the speed information\n\t   for the virtual channel can be propogated in both directions by\n\t   the RPN control message. This however rapidly gets nasty as we\n\t   then have to remap modem signals each way according to whether\n\t   our virtual cable is null modem etc .. */\n\ttty_termios_copy_hw(&tty->termios, old);\n}\n\nstatic void gsmtty_throttle(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tif (C_CRTSCTS(tty))\n\t\tdlci->modem_tx &= ~TIOCM_RTS;\n\tdlci->throttled = true;\n\t/* Send an MSC with RTS cleared */\n\tgsm_modem_update(dlci, 0);\n}\n\nstatic void gsmtty_unthrottle(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tif (C_CRTSCTS(tty))\n\t\tdlci->modem_tx |= TIOCM_RTS;\n\tdlci->throttled = false;\n\t/* Send an MSC with RTS set */\n\tgsm_modem_update(dlci, 0);\n}\n\nstatic int gsmtty_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tint encode = 0;\t/* Off */\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\n\tif (state == -1)\t/* \"On indefinitely\" - we can't encode this\n\t\t\t\t    properly */\n\t\tencode = 0x0F;\n\telse if (state > 0) {\n\t\tencode = state / 200;\t/* mS to encoding */\n\t\tif (encode > 0x0F)\n\t\t\tencode = 0x0F;\t/* Best effort */\n\t}\n\treturn gsm_modem_update(dlci, encode);\n}\n\nstatic void gsmtty_cleanup(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\tdlci_put(dlci);\n\tdlci_put(gsm->dlci[0]);\n\tmux_put(gsm);\n}\n\n/* Virtual ttys for the demux */\nstatic const struct tty_operations gsmtty_ops = {\n\t.install\t\t= gsmtty_install,\n\t.open\t\t\t= gsmtty_open,\n\t.close\t\t\t= gsmtty_close,\n\t.write\t\t\t= gsmtty_write,\n\t.write_room\t\t= gsmtty_write_room,\n\t.chars_in_buffer\t= gsmtty_chars_in_buffer,\n\t.flush_buffer\t\t= gsmtty_flush_buffer,\n\t.ioctl\t\t\t= gsmtty_ioctl,\n\t.throttle\t\t= gsmtty_throttle,\n\t.unthrottle\t\t= gsmtty_unthrottle,\n\t.set_termios\t\t= gsmtty_set_termios,\n\t.hangup\t\t\t= gsmtty_hangup,\n\t.wait_until_sent\t= gsmtty_wait_until_sent,\n\t.tiocmget\t\t= gsmtty_tiocmget,\n\t.tiocmset\t\t= gsmtty_tiocmset,\n\t.break_ctl\t\t= gsmtty_break_ctl,\n\t.cleanup\t\t= gsmtty_cleanup,\n};\n\n\n\nstatic int __init gsm_init(void)\n{\n\t/* Fill in our line protocol discipline, and register it */\n\tint status = tty_register_ldisc(&tty_ldisc_packet);\n\tif (status != 0) {\n\t\tpr_err(\"n_gsm: can't register line discipline (err = %d)\\n\",\n\t\t\t\t\t\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tgsm_tty_driver = tty_alloc_driver(GSM_TTY_MINORS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK);\n\tif (IS_ERR(gsm_tty_driver)) {\n\t\tpr_err(\"gsm_init: tty allocation failed.\\n\");\n\t\tstatus = PTR_ERR(gsm_tty_driver);\n\t\tgoto err_unreg_ldisc;\n\t}\n\tgsm_tty_driver->driver_name\t= \"gsmtty\";\n\tgsm_tty_driver->name\t\t= \"gsmtty\";\n\tgsm_tty_driver->major\t\t= 0;\t/* Dynamic */\n\tgsm_tty_driver->minor_start\t= 0;\n\tgsm_tty_driver->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tgsm_tty_driver->subtype\t= SERIAL_TYPE_NORMAL;\n\tgsm_tty_driver->init_termios\t= tty_std_termios;\n\t/* Fixme */\n\tgsm_tty_driver->init_termios.c_lflag &= ~ECHO;\n\ttty_set_operations(gsm_tty_driver, &gsmtty_ops);\n\n\tif (tty_register_driver(gsm_tty_driver)) {\n\t\tpr_err(\"gsm_init: tty registration failed.\\n\");\n\t\tstatus = -EBUSY;\n\t\tgoto err_put_driver;\n\t}\n\tpr_debug(\"gsm_init: loaded as %d,%d.\\n\",\n\t\t\tgsm_tty_driver->major, gsm_tty_driver->minor_start);\n\treturn 0;\nerr_put_driver:\n\ttty_driver_kref_put(gsm_tty_driver);\nerr_unreg_ldisc:\n\ttty_unregister_ldisc(&tty_ldisc_packet);\n\treturn status;\n}\n\nstatic void __exit gsm_exit(void)\n{\n\ttty_unregister_ldisc(&tty_ldisc_packet);\n\ttty_unregister_driver(gsm_tty_driver);\n\ttty_driver_kref_put(gsm_tty_driver);\n}\n\nmodule_init(gsm_init);\nmodule_exit(gsm_exit);\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_GSM0710);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * n_gsm.c GSM 0710 tty multiplexor\n * Copyright (c) 2009/10 Intel Corporation\n *\n *\t* THIS IS A DEVELOPMENT SNAPSHOT IT IS NOT A FINAL RELEASE *\n *\n * Outgoing path:\n * tty -> DLCI fifo -> scheduler -> GSM MUX data queue    ---o-> ldisc\n * control message               -> GSM MUX control queue --\u00b4\n *\n * Incoming path:\n * ldisc -> gsm_queue() -o--> tty\n *                        `-> gsm_control_response()\n *\n * TO DO:\n *\tMostly done:\tioctls for setting modes/timing\n *\tPartly done:\thooks so you can pull off frames to non tty devs\n *\tRestart DLCI 0 when it closes ?\n *\tImprove the tx engine\n *\tResolve tx side locking by adding a queue_head and routing\n *\t\tall control traffic via it\n *\tGeneral tidy/document\n *\tReview the locking/move to refcounts more (mux now moved to an\n *\t\talloc/free model ready)\n *\tUse newest tty open/close port helpers and install hooks\n *\tWhat to do about power functions ?\n *\tTermios setting and negotiation\n *\tDo we need a 'which mux are you' ioctl to correlate mux and tty sets\n *\n */\n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/bitfield.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/math.h>\n#include <linux/nospec.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/tty_flip.h>\n#include <linux/tty_driver.h>\n#include <linux/serial.h>\n#include <linux/kfifo.h>\n#include <linux/skbuff.h>\n#include <net/arp.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/gsmmux.h>\n#include \"tty.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0600);\n\n/* Module debug bits */\n#define DBG_DUMP\tBIT(0) /* Data transmission dump. */\n#define DBG_CD_ON\tBIT(1) /* Always assume CD line on. */\n#define DBG_DATA\tBIT(2) /* Data transmission details. */\n#define DBG_ERRORS\tBIT(3) /* Details for fail conditions. */\n#define DBG_TTY\t\tBIT(4) /* Transmission statistics for DLCI TTYs. */\n#define DBG_PAYLOAD\tBIT(5) /* Limits DBG_DUMP to payload frames. */\n\n/* Defaults: these are from the specification */\n\n#define T1\t10\t\t/* 100mS */\n#define T2\t34\t\t/* 333mS */\n#define T3\t10\t\t/* 10s */\n#define N2\t3\t\t/* Retry 3 times */\n#define K\t2\t\t/* outstanding I frames */\n\n#define MAX_T3 255\t\t/* In seconds. */\n#define MAX_WINDOW_SIZE 7\t/* Limit of K in error recovery mode. */\n\n/* Use long timers for testing at low speed with debug on */\n#ifdef DEBUG_TIMING\n#define T1\t100\n#define T2\t200\n#endif\n\n/*\n * Semi-arbitrary buffer size limits. 0710 is normally run with 32-64 byte\n * limits so this is plenty\n */\n#define MAX_MRU 1500\n#define MAX_MTU 1500\n#define MIN_MTU (PROT_OVERHEAD + 1)\n/* SOF, ADDR, CTRL, LEN1, LEN2, ..., FCS, EOF */\n#define PROT_OVERHEAD 7\n#define\tGSM_NET_TX_TIMEOUT (HZ*10)\n\n/*\n *\tstruct gsm_mux_net\t-\tnetwork interface\n *\n *\tCreated when net interface is initialized.\n */\nstruct gsm_mux_net {\n\tstruct kref ref;\n\tstruct gsm_dlci *dlci;\n};\n\n/*\n *\tEach block of data we have queued to go out is in the form of\n *\ta gsm_msg which holds everything we need in a link layer independent\n *\tformat\n */\n\nstruct gsm_msg {\n\tstruct list_head list;\n\tu8 addr;\t\t/* DLCI address + flags */\n\tu8 ctrl;\t\t/* Control byte + flags */\n\tunsigned int len;\t/* Length of data block (can be zero) */\n\tunsigned char *data;\t/* Points into buffer but not at the start */\n\tunsigned char buffer[];\n};\n\nenum gsm_dlci_state {\n\tDLCI_CLOSED,\n\tDLCI_WAITING_CONFIG,\t/* Waiting for DLCI configuration from user */\n\tDLCI_CONFIGURE,\t\t/* Sending PN (for adaption > 1) */\n\tDLCI_OPENING,\t\t/* Sending SABM not seen UA */\n\tDLCI_OPEN,\t\t/* SABM/UA complete */\n\tDLCI_CLOSING,\t\t/* Sending DISC not seen UA/DM */\n};\n\nenum gsm_dlci_mode {\n\tDLCI_MODE_ABM,\t\t/* Normal Asynchronous Balanced Mode */\n\tDLCI_MODE_ADM,\t\t/* Asynchronous Disconnected Mode */\n};\n\n/*\n *\tEach active data link has a gsm_dlci structure associated which ties\n *\tthe link layer to an optional tty (if the tty side is open). To avoid\n *\tcomplexity right now these are only ever freed up when the mux is\n *\tshut down.\n *\n *\tAt the moment we don't free DLCI objects until the mux is torn down\n *\tthis avoid object life time issues but might be worth review later.\n */\n\nstruct gsm_dlci {\n\tstruct gsm_mux *gsm;\n\tint addr;\n\tenum gsm_dlci_state state;\n\tstruct mutex mutex;\n\n\t/* Link layer */\n\tenum gsm_dlci_mode mode;\n\tspinlock_t lock;\t/* Protects the internal state */\n\tstruct timer_list t1;\t/* Retransmit timer for SABM and UA */\n\tint retries;\n\t/* Uplink tty if active */\n\tstruct tty_port port;\t/* The tty bound to this DLCI if there is one */\n#define TX_SIZE\t\t4096    /* Must be power of 2. */\n\tstruct kfifo fifo;\t/* Queue fifo for the DLCI */\n\tint adaption;\t\t/* Adaption layer in use */\n\tint prev_adaption;\n\tu32 modem_rx;\t\t/* Our incoming virtual modem lines */\n\tu32 modem_tx;\t\t/* Our outgoing modem lines */\n\tunsigned int mtu;\n\tbool dead;\t\t/* Refuse re-open */\n\t/* Configuration */\n\tu8 prio;\t\t/* Priority */\n\tu8 ftype;\t\t/* Frame type */\n\tu8 k;\t\t\t/* Window size */\n\t/* Flow control */\n\tbool throttled;\t\t/* Private copy of throttle state */\n\tbool constipated;\t/* Throttle status for outgoing */\n\t/* Packetised I/O */\n\tstruct sk_buff *skb;\t/* Frame being sent */\n\tstruct sk_buff_head skb_list;\t/* Queued frames */\n\t/* Data handling callback */\n\tvoid (*data)(struct gsm_dlci *dlci, const u8 *data, int len);\n\tvoid (*prev_data)(struct gsm_dlci *dlci, const u8 *data, int len);\n\tstruct net_device *net; /* network interface, if created */\n};\n\n/*\n * Parameter bits used for parameter negotiation according to 3GPP 27.010\n * chapter 5.4.6.3.1.\n */\n\nstruct gsm_dlci_param_bits {\n\tu8 d_bits;\n\tu8 i_cl_bits;\n\tu8 p_bits;\n\tu8 t_bits;\n\t__le16 n_bits;\n\tu8 na_bits;\n\tu8 k_bits;\n};\n\nstatic_assert(sizeof(struct gsm_dlci_param_bits) == 8);\n\n#define PN_D_FIELD_DLCI\t\tGENMASK(5, 0)\n#define PN_I_CL_FIELD_FTYPE\tGENMASK(3, 0)\n#define PN_I_CL_FIELD_ADAPTION\tGENMASK(7, 4)\n#define PN_P_FIELD_PRIO\t\tGENMASK(5, 0)\n#define PN_T_FIELD_T1\t\tGENMASK(7, 0)\n#define PN_N_FIELD_N1\t\tGENMASK(15, 0)\n#define PN_NA_FIELD_N2\t\tGENMASK(7, 0)\n#define PN_K_FIELD_K\t\tGENMASK(2, 0)\n\n/* Total number of supported devices */\n#define GSM_TTY_MINORS\t\t256\n\n/* DLCI 0, 62/63 are special or reserved see gsmtty_open */\n\n#define NUM_DLCI\t\t64\n\n/*\n *\tDLCI 0 is used to pass control blocks out of band of the data\n *\tflow (and with a higher link priority). One command can be outstanding\n *\tat a time and we use this structure to manage them. They are created\n *\tand destroyed by the user context, and updated by the receive paths\n *\tand timers\n */\n\nstruct gsm_control {\n\tu8 cmd;\t\t/* Command we are issuing */\n\tu8 *data;\t/* Data for the command in case we retransmit */\n\tint len;\t/* Length of block for retransmission */\n\tint done;\t/* Done flag */\n\tint error;\t/* Error if any */\n};\n\nenum gsm_encoding {\n\tGSM_BASIC_OPT,\n\tGSM_ADV_OPT,\n};\n\nenum gsm_mux_state {\n\tGSM_SEARCH,\n\tGSM_START,\n\tGSM_ADDRESS,\n\tGSM_CONTROL,\n\tGSM_LEN,\n\tGSM_DATA,\n\tGSM_FCS,\n\tGSM_OVERRUN,\n\tGSM_LEN0,\n\tGSM_LEN1,\n\tGSM_SSOF,\n};\n\n/*\n *\tEach GSM mux we have is represented by this structure. If we are\n *\toperating as an ldisc then we use this structure as our ldisc\n *\tstate. We need to sort out lifetimes and locking with respect\n *\tto the gsm mux array. For now we don't free DLCI objects that\n *\thave been instantiated until the mux itself is terminated.\n *\n *\tTo consider further: tty open versus mux shutdown.\n */\n\nstruct gsm_mux {\n\tstruct tty_struct *tty;\t\t/* The tty our ldisc is bound to */\n\tspinlock_t lock;\n\tstruct mutex mutex;\n\tunsigned int num;\n\tstruct kref ref;\n\n\t/* Events on the GSM channel */\n\twait_queue_head_t event;\n\n\t/* ldisc send work */\n\tstruct work_struct tx_work;\n\n\t/* Bits for GSM mode decoding */\n\n\t/* Framing Layer */\n\tunsigned char *buf;\n\tenum gsm_mux_state state;\n\tunsigned int len;\n\tunsigned int address;\n\tunsigned int count;\n\tbool escape;\n\tenum gsm_encoding encoding;\n\tu8 control;\n\tu8 fcs;\n\tu8 *txframe;\t\t\t/* TX framing buffer */\n\n\t/* Method for the receiver side */\n\tvoid (*receive)(struct gsm_mux *gsm, u8 ch);\n\n\t/* Link Layer */\n\tunsigned int mru;\n\tunsigned int mtu;\n\tint initiator;\t\t\t/* Did we initiate connection */\n\tbool dead;\t\t\t/* Has the mux been shut down */\n\tstruct gsm_dlci *dlci[NUM_DLCI];\n\tint old_c_iflag;\t\t/* termios c_iflag value before attach */\n\tbool constipated;\t\t/* Asked by remote to shut up */\n\tbool has_devices;\t\t/* Devices were registered */\n\n\tspinlock_t tx_lock;\n\tunsigned int tx_bytes;\t\t/* TX data outstanding */\n#define TX_THRESH_HI\t\t8192\n#define TX_THRESH_LO\t\t2048\n\tstruct list_head tx_ctrl_list;\t/* Pending control packets */\n\tstruct list_head tx_data_list;\t/* Pending data packets */\n\n\t/* Control messages */\n\tstruct timer_list kick_timer;\t/* Kick TX queuing on timeout */\n\tstruct timer_list t2_timer;\t/* Retransmit timer for commands */\n\tint cretries;\t\t\t/* Command retry counter */\n\tstruct gsm_control *pending_cmd;/* Our current pending command */\n\tspinlock_t control_lock;\t/* Protects the pending command */\n\n\t/* Keep-alive */\n\tstruct timer_list ka_timer;\t/* Keep-alive response timer */\n\tu8 ka_num;\t\t\t/* Keep-alive match pattern */\n\tsigned int ka_retries;\t\t/* Keep-alive retry counter, -1 if not yet initialized */\n\n\t/* Configuration */\n\tint adaption;\t\t/* 1 or 2 supported */\n\tu8 ftype;\t\t/* UI or UIH */\n\tint t1, t2;\t\t/* Timers in 1/100th of a sec */\n\tunsigned int t3;\t/* Power wake-up timer in seconds. */\n\tint n2;\t\t\t/* Retry count */\n\tu8 k;\t\t\t/* Window size */\n\tbool wait_config;\t/* Wait for configuration by ioctl before DLCI open */\n\tu32 keep_alive;\t\t/* Control channel keep-alive in 10ms */\n\n\t/* Statistics (not currently exposed) */\n\tunsigned long bad_fcs;\n\tunsigned long malformed;\n\tunsigned long io_error;\n\tunsigned long bad_size;\n\tunsigned long unsupported;\n};\n\n\n/*\n *\tMux objects - needed so that we can translate a tty index into the\n *\trelevant mux and DLCI.\n */\n\n#define MAX_MUX\t\t4\t\t\t/* 256 minors */\nstatic struct gsm_mux *gsm_mux[MAX_MUX];\t/* GSM muxes */\nstatic DEFINE_SPINLOCK(gsm_mux_lock);\n\nstatic struct tty_driver *gsm_tty_driver;\n\n/*\n *\tThis section of the driver logic implements the GSM encodings\n *\tboth the basic and the 'advanced'. Reliable transport is not\n *\tsupported.\n */\n\n#define CR\t\t\t0x02\n#define EA\t\t\t0x01\n#define\tPF\t\t\t0x10\n\n/* I is special: the rest are ..*/\n#define RR\t\t\t0x01\n#define UI\t\t\t0x03\n#define RNR\t\t\t0x05\n#define REJ\t\t\t0x09\n#define DM\t\t\t0x0F\n#define SABM\t\t\t0x2F\n#define DISC\t\t\t0x43\n#define UA\t\t\t0x63\n#define\tUIH\t\t\t0xEF\n\n/* Channel commands */\n#define CMD_NSC\t\t\t0x09\n#define CMD_TEST\t\t0x11\n#define CMD_PSC\t\t\t0x21\n#define CMD_RLS\t\t\t0x29\n#define CMD_FCOFF\t\t0x31\n#define CMD_PN\t\t\t0x41\n#define CMD_RPN\t\t\t0x49\n#define CMD_FCON\t\t0x51\n#define CMD_CLD\t\t\t0x61\n#define CMD_SNC\t\t\t0x69\n#define CMD_MSC\t\t\t0x71\n\n/* Virtual modem bits */\n#define MDM_FC\t\t\t0x01\n#define MDM_RTC\t\t\t0x02\n#define MDM_RTR\t\t\t0x04\n#define MDM_IC\t\t\t0x20\n#define MDM_DV\t\t\t0x40\n\n#define GSM0_SOF\t\t0xF9\n#define GSM1_SOF\t\t0x7E\n#define GSM1_ESCAPE\t\t0x7D\n#define GSM1_ESCAPE_BITS\t0x20\n#define XON\t\t\t0x11\n#define XOFF\t\t\t0x13\n#define ISO_IEC_646_MASK\t0x7F\n\nstatic const struct tty_port_operations gsm_port_ops;\n\n/*\n *\tCRC table for GSM 0710\n */\n\nstatic const u8 gsm_fcs8[256] = {\n\t0x00, 0x91, 0xE3, 0x72, 0x07, 0x96, 0xE4, 0x75,\n\t0x0E, 0x9F, 0xED, 0x7C, 0x09, 0x98, 0xEA, 0x7B,\n\t0x1C, 0x8D, 0xFF, 0x6E, 0x1B, 0x8A, 0xF8, 0x69,\n\t0x12, 0x83, 0xF1, 0x60, 0x15, 0x84, 0xF6, 0x67,\n\t0x38, 0xA9, 0xDB, 0x4A, 0x3F, 0xAE, 0xDC, 0x4D,\n\t0x36, 0xA7, 0xD5, 0x44, 0x31, 0xA0, 0xD2, 0x43,\n\t0x24, 0xB5, 0xC7, 0x56, 0x23, 0xB2, 0xC0, 0x51,\n\t0x2A, 0xBB, 0xC9, 0x58, 0x2D, 0xBC, 0xCE, 0x5F,\n\t0x70, 0xE1, 0x93, 0x02, 0x77, 0xE6, 0x94, 0x05,\n\t0x7E, 0xEF, 0x9D, 0x0C, 0x79, 0xE8, 0x9A, 0x0B,\n\t0x6C, 0xFD, 0x8F, 0x1E, 0x6B, 0xFA, 0x88, 0x19,\n\t0x62, 0xF3, 0x81, 0x10, 0x65, 0xF4, 0x86, 0x17,\n\t0x48, 0xD9, 0xAB, 0x3A, 0x4F, 0xDE, 0xAC, 0x3D,\n\t0x46, 0xD7, 0xA5, 0x34, 0x41, 0xD0, 0xA2, 0x33,\n\t0x54, 0xC5, 0xB7, 0x26, 0x53, 0xC2, 0xB0, 0x21,\n\t0x5A, 0xCB, 0xB9, 0x28, 0x5D, 0xCC, 0xBE, 0x2F,\n\t0xE0, 0x71, 0x03, 0x92, 0xE7, 0x76, 0x04, 0x95,\n\t0xEE, 0x7F, 0x0D, 0x9C, 0xE9, 0x78, 0x0A, 0x9B,\n\t0xFC, 0x6D, 0x1F, 0x8E, 0xFB, 0x6A, 0x18, 0x89,\n\t0xF2, 0x63, 0x11, 0x80, 0xF5, 0x64, 0x16, 0x87,\n\t0xD8, 0x49, 0x3B, 0xAA, 0xDF, 0x4E, 0x3C, 0xAD,\n\t0xD6, 0x47, 0x35, 0xA4, 0xD1, 0x40, 0x32, 0xA3,\n\t0xC4, 0x55, 0x27, 0xB6, 0xC3, 0x52, 0x20, 0xB1,\n\t0xCA, 0x5B, 0x29, 0xB8, 0xCD, 0x5C, 0x2E, 0xBF,\n\t0x90, 0x01, 0x73, 0xE2, 0x97, 0x06, 0x74, 0xE5,\n\t0x9E, 0x0F, 0x7D, 0xEC, 0x99, 0x08, 0x7A, 0xEB,\n\t0x8C, 0x1D, 0x6F, 0xFE, 0x8B, 0x1A, 0x68, 0xF9,\n\t0x82, 0x13, 0x61, 0xF0, 0x85, 0x14, 0x66, 0xF7,\n\t0xA8, 0x39, 0x4B, 0xDA, 0xAF, 0x3E, 0x4C, 0xDD,\n\t0xA6, 0x37, 0x45, 0xD4, 0xA1, 0x30, 0x42, 0xD3,\n\t0xB4, 0x25, 0x57, 0xC6, 0xB3, 0x22, 0x50, 0xC1,\n\t0xBA, 0x2B, 0x59, 0xC8, 0xBD, 0x2C, 0x5E, 0xCF\n};\n\n#define INIT_FCS\t0xFF\n#define GOOD_FCS\t0xCF\n\nstatic void gsm_dlci_close(struct gsm_dlci *dlci);\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len);\nstatic int gsm_modem_update(struct gsm_dlci *dlci, u8 brk);\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\n\t\t\t\t\t\t\t\tu8 ctrl);\nstatic int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg);\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr);\nstatic void gsmld_write_trigger(struct gsm_mux *gsm);\nstatic void gsmld_write_task(struct work_struct *work);\n\n/**\n *\tgsm_fcs_add\t-\tupdate FCS\n *\t@fcs: Current FCS\n *\t@c: Next data\n *\n *\tUpdate the FCS to include c. Uses the algorithm in the specification\n *\tnotes.\n */\n\nstatic inline u8 gsm_fcs_add(u8 fcs, u8 c)\n{\n\treturn gsm_fcs8[fcs ^ c];\n}\n\n/**\n *\tgsm_fcs_add_block\t-\tupdate FCS for a block\n *\t@fcs: Current FCS\n *\t@c: buffer of data\n *\t@len: length of buffer\n *\n *\tUpdate the FCS to include c. Uses the algorithm in the specification\n *\tnotes.\n */\n\nstatic inline u8 gsm_fcs_add_block(u8 fcs, u8 *c, int len)\n{\n\twhile (len--)\n\t\tfcs = gsm_fcs8[fcs ^ *c++];\n\treturn fcs;\n}\n\n/**\n *\tgsm_read_ea\t\t-\tread a byte into an EA\n *\t@val: variable holding value\n *\t@c: byte going into the EA\n *\n *\tProcesses one byte of an EA. Updates the passed variable\n *\tand returns 1 if the EA is now completely read\n */\n\nstatic int gsm_read_ea(unsigned int *val, u8 c)\n{\n\t/* Add the next 7 bits into the value */\n\t*val <<= 7;\n\t*val |= c >> 1;\n\t/* Was this the last byte of the EA 1 = yes*/\n\treturn c & EA;\n}\n\n/**\n *\tgsm_read_ea_val\t-\tread a value until EA\n *\t@val: variable holding value\n *\t@data: buffer of data\n *\t@dlen: length of data\n *\n *\tProcesses an EA value. Updates the passed variable and\n *\treturns the processed data length.\n */\nstatic unsigned int gsm_read_ea_val(unsigned int *val, const u8 *data, int dlen)\n{\n\tunsigned int len = 0;\n\n\tfor (; dlen > 0; dlen--) {\n\t\tlen++;\n\t\tif (gsm_read_ea(val, *data++))\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\n/**\n *\tgsm_encode_modem\t-\tencode modem data bits\n *\t@dlci: DLCI to encode from\n *\n *\tReturns the correct GSM encoded modem status bits (6 bit field) for\n *\tthe current status of the DLCI and attached tty object\n */\n\nstatic u8 gsm_encode_modem(const struct gsm_dlci *dlci)\n{\n\tu8 modembits = 0;\n\t/* FC is true flow control not modem bits */\n\tif (dlci->throttled)\n\t\tmodembits |= MDM_FC;\n\tif (dlci->modem_tx & TIOCM_DTR)\n\t\tmodembits |= MDM_RTC;\n\tif (dlci->modem_tx & TIOCM_RTS)\n\t\tmodembits |= MDM_RTR;\n\tif (dlci->modem_tx & TIOCM_RI)\n\t\tmodembits |= MDM_IC;\n\tif (dlci->modem_tx & TIOCM_CD || dlci->gsm->initiator)\n\t\tmodembits |= MDM_DV;\n\t/* special mappings for passive side to operate as UE */\n\tif (dlci->modem_tx & TIOCM_OUT1)\n\t\tmodembits |= MDM_IC;\n\tif (dlci->modem_tx & TIOCM_OUT2)\n\t\tmodembits |= MDM_DV;\n\treturn modembits;\n}\n\nstatic void gsm_hex_dump_bytes(const char *fname, const u8 *data,\n\t\t\t       unsigned long len)\n{\n\tchar *prefix;\n\n\tif (!fname) {\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1, data, len,\n\t\t\t       true);\n\t\treturn;\n\t}\n\n\tprefix = kasprintf(GFP_ATOMIC, \"%s: \", fname);\n\tif (!prefix)\n\t\treturn;\n\tprint_hex_dump(KERN_INFO, prefix, DUMP_PREFIX_OFFSET, 16, 1, data, len,\n\t\t       true);\n\tkfree(prefix);\n}\n\n/**\n * gsm_encode_params\t-\tencode DLCI parameters\n * @dlci: DLCI to encode from\n * @params: buffer to fill with the encoded parameters\n *\n * Encodes the parameters according to GSM 07.10 section 5.4.6.3.1\n * table 3.\n */\nstatic int gsm_encode_params(const struct gsm_dlci *dlci,\n\t\t\t     struct gsm_dlci_param_bits *params)\n{\n\tconst struct gsm_mux *gsm = dlci->gsm;\n\tunsigned int i, cl;\n\n\tswitch (dlci->ftype) {\n\tcase UIH:\n\t\ti = 0; /* UIH */\n\t\tbreak;\n\tcase UI:\n\t\ti = 1; /* UI */\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unsupported frame type %d\\n\", dlci->ftype);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tcl = 0; /* convergence layer type 1 */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits. */\n\t\tcl = 1; /* convergence layer type 2 */\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unsupported adaption %d\\n\", dlci->adaption);\n\t\treturn -EINVAL;\n\t}\n\n\tparams->d_bits = FIELD_PREP(PN_D_FIELD_DLCI, dlci->addr);\n\t/* UIH, convergence layer type 1 */\n\tparams->i_cl_bits = FIELD_PREP(PN_I_CL_FIELD_FTYPE, i) |\n\t\t\t    FIELD_PREP(PN_I_CL_FIELD_ADAPTION, cl);\n\tparams->p_bits = FIELD_PREP(PN_P_FIELD_PRIO, dlci->prio);\n\tparams->t_bits = FIELD_PREP(PN_T_FIELD_T1, gsm->t1);\n\tparams->n_bits = cpu_to_le16(FIELD_PREP(PN_N_FIELD_N1, dlci->mtu));\n\tparams->na_bits = FIELD_PREP(PN_NA_FIELD_N2, gsm->n2);\n\tparams->k_bits = FIELD_PREP(PN_K_FIELD_K, dlci->k);\n\n\treturn 0;\n}\n\n/**\n *\tgsm_register_devices\t-\tregister all tty devices for a given mux index\n *\n *\t@driver: the tty driver that describes the tty devices\n *\t@index:  the mux number is used to calculate the minor numbers of the\n *\t         ttys for this mux and may differ from the position in the\n *\t         mux array.\n */\nstatic int gsm_register_devices(struct tty_driver *driver, unsigned int index)\n{\n\tstruct device *dev;\n\tint i;\n\tunsigned int base;\n\n\tif (!driver || index >= MAX_MUX)\n\t\treturn -EINVAL;\n\n\tbase = index * NUM_DLCI; /* first minor for this index */\n\tfor (i = 1; i < NUM_DLCI; i++) {\n\t\t/* Don't register device 0 - this is the control channel\n\t\t * and not a usable tty interface\n\t\t */\n\t\tdev = tty_register_device(gsm_tty_driver, base + i, NULL);\n\t\tif (IS_ERR(dev)) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s failed to register device minor %u\",\n\t\t\t\t\t__func__, base + i);\n\t\t\tfor (i--; i >= 1; i--)\n\t\t\t\ttty_unregister_device(gsm_tty_driver, base + i);\n\t\t\treturn PTR_ERR(dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tgsm_unregister_devices\t-\tunregister all tty devices for a given mux index\n *\n *\t@driver: the tty driver that describes the tty devices\n *\t@index:  the mux number is used to calculate the minor numbers of the\n *\t         ttys for this mux and may differ from the position in the\n *\t         mux array.\n */\nstatic void gsm_unregister_devices(struct tty_driver *driver,\n\t\t\t\t   unsigned int index)\n{\n\tint i;\n\tunsigned int base;\n\n\tif (!driver || index >= MAX_MUX)\n\t\treturn;\n\n\tbase = index * NUM_DLCI; /* first minor for this index */\n\tfor (i = 1; i < NUM_DLCI; i++) {\n\t\t/* Don't unregister device 0 - this is the control\n\t\t * channel and not a usable tty interface\n\t\t */\n\t\ttty_unregister_device(gsm_tty_driver, base + i);\n\t}\n}\n\n/**\n *\tgsm_print_packet\t-\tdisplay a frame for debug\n *\t@hdr: header to print before decode\n *\t@addr: address EA from the frame\n *\t@cr: C/R bit seen as initiator\n *\t@control: control including PF bit\n *\t@data: following data bytes\n *\t@dlen: length of data\n *\n *\tDisplays a packet in human readable format for debugging purposes. The\n *\tstyle is based on amateur radio LAP-B dump display.\n */\n\nstatic void gsm_print_packet(const char *hdr, int addr, int cr,\n\t\t\t\t\tu8 control, const u8 *data, int dlen)\n{\n\tif (!(debug & DBG_DUMP))\n\t\treturn;\n\t/* Only show user payload frames if debug & DBG_PAYLOAD */\n\tif (!(debug & DBG_PAYLOAD) && addr != 0)\n\t\tif ((control & ~PF) == UI || (control & ~PF) == UIH)\n\t\t\treturn;\n\n\tpr_info(\"%s %d) %c: \", hdr, addr, \"RC\"[cr]);\n\n\tswitch (control & ~PF) {\n\tcase SABM:\n\t\tpr_cont(\"SABM\");\n\t\tbreak;\n\tcase UA:\n\t\tpr_cont(\"UA\");\n\t\tbreak;\n\tcase DISC:\n\t\tpr_cont(\"DISC\");\n\t\tbreak;\n\tcase DM:\n\t\tpr_cont(\"DM\");\n\t\tbreak;\n\tcase UI:\n\t\tpr_cont(\"UI\");\n\t\tbreak;\n\tcase UIH:\n\t\tpr_cont(\"UIH\");\n\t\tbreak;\n\tdefault:\n\t\tif (!(control & 0x01)) {\n\t\t\tpr_cont(\"I N(S)%d N(R)%d\",\n\t\t\t\t(control & 0x0E) >> 1, (control & 0xE0) >> 5);\n\t\t} else switch (control & 0x0F) {\n\t\t\tcase RR:\n\t\t\t\tpr_cont(\"RR(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tcase RNR:\n\t\t\t\tpr_cont(\"RNR(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tcase REJ:\n\t\t\t\tpr_cont(\"REJ(%d)\", (control & 0xE0) >> 5);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_cont(\"[%02X]\", control);\n\t\t}\n\t}\n\n\tif (control & PF)\n\t\tpr_cont(\"(P)\");\n\telse\n\t\tpr_cont(\"(F)\");\n\n\tgsm_hex_dump_bytes(NULL, data, dlen);\n}\n\n\n/*\n *\tLink level transmission side\n */\n\n/**\n *\tgsm_stuff_frame\t-\tbytestuff a packet\n *\t@input: input buffer\n *\t@output: output buffer\n *\t@len: length of input\n *\n *\tExpand a buffer by bytestuffing it. The worst case size change\n *\tis doubling and the caller is responsible for handing out\n *\tsuitable sized buffers.\n */\n\nstatic int gsm_stuff_frame(const u8 *input, u8 *output, int len)\n{\n\tint olen = 0;\n\twhile (len--) {\n\t\tif (*input == GSM1_SOF || *input == GSM1_ESCAPE\n\t\t    || (*input & ISO_IEC_646_MASK) == XON\n\t\t    || (*input & ISO_IEC_646_MASK) == XOFF) {\n\t\t\t*output++ = GSM1_ESCAPE;\n\t\t\t*output++ = *input++ ^ GSM1_ESCAPE_BITS;\n\t\t\tolen++;\n\t\t} else\n\t\t\t*output++ = *input++;\n\t\tolen++;\n\t}\n\treturn olen;\n}\n\n/**\n *\tgsm_send\t-\tsend a control frame\n *\t@gsm: our GSM mux\n *\t@addr: address for control frame\n *\t@cr: command/response bit seen as initiator\n *\t@control:  control byte including PF bit\n *\n *\tFormat up and transmit a control frame. These should be transmitted\n *\tahead of data when they are needed.\n */\nstatic int gsm_send(struct gsm_mux *gsm, int addr, int cr, int control)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint ocr;\n\tunsigned long flags;\n\n\tmsg = gsm_data_alloc(gsm, addr, 0, control);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t/* toggle C/R coding if not initiator */\n\tocr = cr ^ (gsm->initiator ? 0 : 1);\n\n\tmsg->data -= 3;\n\tdp = msg->data;\n\t*dp++ = (addr << 2) | (ocr << 1) | EA;\n\t*dp++ = control;\n\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\t*dp++ = EA; /* Length of data = 0 */\n\n\t*dp = 0xFF - gsm_fcs_add_block(INIT_FCS, msg->data, dp - msg->data);\n\tmsg->len = (dp - msg->data) + 1;\n\n\tgsm_print_packet(\"Q->\", addr, cr, control, NULL, 0);\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tlist_add_tail(&msg->list, &gsm->tx_ctrl_list);\n\tgsm->tx_bytes += msg->len;\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\tgsmld_write_trigger(gsm);\n\n\treturn 0;\n}\n\n/**\n *\tgsm_dlci_clear_queues\t-\tremove outstanding data for a DLCI\n *\t@gsm: mux\n *\t@dlci: clear for this DLCI\n *\n *\tClears the data queues for a given DLCI.\n */\nstatic void gsm_dlci_clear_queues(struct gsm_mux *gsm, struct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg, *nmsg;\n\tint addr = dlci->addr;\n\tunsigned long flags;\n\n\t/* Clear DLCI write fifo first */\n\tspin_lock_irqsave(&dlci->lock, flags);\n\tkfifo_reset(&dlci->fifo);\n\tspin_unlock_irqrestore(&dlci->lock, flags);\n\n\t/* Clear data packets in MUX write queue */\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_data_list, list) {\n\t\tif (msg->addr != addr)\n\t\t\tcontinue;\n\t\tgsm->tx_bytes -= msg->len;\n\t\tlist_del(&msg->list);\n\t\tkfree(msg);\n\t}\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n}\n\n/**\n *\tgsm_response\t-\tsend a control response\n *\t@gsm: our GSM mux\n *\t@addr: address for control frame\n *\t@control:  control byte including PF bit\n *\n *\tFormat up and transmit a link level response frame.\n */\n\nstatic inline void gsm_response(struct gsm_mux *gsm, int addr, int control)\n{\n\tgsm_send(gsm, addr, 0, control);\n}\n\n/**\n *\tgsm_command\t-\tsend a control command\n *\t@gsm: our GSM mux\n *\t@addr: address for control frame\n *\t@control:  control byte including PF bit\n *\n *\tFormat up and transmit a link level command frame.\n */\n\nstatic inline void gsm_command(struct gsm_mux *gsm, int addr, int control)\n{\n\tgsm_send(gsm, addr, 1, control);\n}\n\n/* Data transmission */\n\n#define HDR_LEN\t\t6\t/* ADDR CTRL [LEN.2] DATA FCS */\n\n/**\n *\tgsm_data_alloc\t\t-\tallocate data frame\n *\t@gsm: GSM mux\n *\t@addr: DLCI address\n *\t@len: length excluding header and FCS\n *\t@ctrl: control byte\n *\n *\tAllocate a new data buffer for sending frames with data. Space is left\n *\tat the front for header bytes but that is treated as an implementation\n *\tdetail and not for the high level code to use\n */\n\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\n\t\t\t\t\t\t\t\tu8 ctrl)\n{\n\tstruct gsm_msg *m = kmalloc(sizeof(struct gsm_msg) + len + HDR_LEN,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\tif (m == NULL)\n\t\treturn NULL;\n\tm->data = m->buffer + HDR_LEN - 1;\t/* Allow for FCS */\n\tm->len = len;\n\tm->addr = addr;\n\tm->ctrl = ctrl;\n\tINIT_LIST_HEAD(&m->list);\n\treturn m;\n}\n\n/**\n *\tgsm_send_packet\t-\tsends a single packet\n *\t@gsm: GSM Mux\n *\t@msg: packet to send\n *\n *\tThe given packet is encoded and sent out. No memory is freed.\n *\tThe caller must hold the gsm tx lock.\n */\nstatic int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg)\n{\n\tint len, ret;\n\n\n\tif (gsm->encoding == GSM_BASIC_OPT) {\n\t\tgsm->txframe[0] = GSM0_SOF;\n\t\tmemcpy(gsm->txframe + 1, msg->data, msg->len);\n\t\tgsm->txframe[msg->len + 1] = GSM0_SOF;\n\t\tlen = msg->len + 2;\n\t} else {\n\t\tgsm->txframe[0] = GSM1_SOF;\n\t\tlen = gsm_stuff_frame(msg->data, gsm->txframe + 1, msg->len);\n\t\tgsm->txframe[len + 1] = GSM1_SOF;\n\t\tlen += 2;\n\t}\n\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, gsm->txframe, len);\n\tgsm_print_packet(\"-->\", msg->addr, gsm->initiator, msg->ctrl, msg->data,\n\t\t\t msg->len);\n\n\tret = gsmld_output(gsm, gsm->txframe, len);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/* FIXME: Can eliminate one SOF in many more cases */\n\tgsm->tx_bytes -= msg->len;\n\n\treturn 0;\n}\n\n/**\n *\tgsm_is_flow_ctrl_msg\t-\tchecks if flow control message\n *\t@msg: message to check\n *\n *\tReturns true if the given message is a flow control command of the\n *\tcontrol channel. False is returned in any other case.\n */\nstatic bool gsm_is_flow_ctrl_msg(struct gsm_msg *msg)\n{\n\tunsigned int cmd;\n\n\tif (msg->addr > 0)\n\t\treturn false;\n\n\tswitch (msg->ctrl & ~PF) {\n\tcase UI:\n\tcase UIH:\n\t\tcmd = 0;\n\t\tif (gsm_read_ea_val(&cmd, msg->data + 2, msg->len - 2) < 1)\n\t\t\tbreak;\n\t\tswitch (cmd & ~PF) {\n\t\tcase CMD_FCOFF:\n\t\tcase CMD_FCON:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n/**\n *\tgsm_data_kick\t-\tpoke the queue\n *\t@gsm: GSM Mux\n *\n *\tThe tty device has called us to indicate that room has appeared in\n *\tthe transmit queue. Ram more data into the pipe if we have any.\n *\tIf we have been flow-stopped by a CMD_FCOFF, then we can only\n *\tsend messages on DLCI0 until CMD_FCON. The caller must hold\n *\tthe gsm tx lock.\n */\nstatic int gsm_data_kick(struct gsm_mux *gsm)\n{\n\tstruct gsm_msg *msg, *nmsg;\n\tstruct gsm_dlci *dlci;\n\tint ret;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\n\n\t/* Serialize control messages and control channel messages first */\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_ctrl_list, list) {\n\t\tif (gsm->constipated && !gsm_is_flow_ctrl_msg(msg))\n\t\t\tcontinue;\n\t\tret = gsm_send_packet(gsm, msg);\n\t\tswitch (ret) {\n\t\tcase -ENOSPC:\n\t\t\treturn -ENOSPC;\n\t\tcase -ENODEV:\n\t\t\t/* ldisc not open */\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (ret >= 0) {\n\t\t\t\tlist_del(&msg->list);\n\t\t\t\tkfree(msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (gsm->constipated)\n\t\treturn -EAGAIN;\n\n\t/* Serialize other channels */\n\tif (list_empty(&gsm->tx_data_list))\n\t\treturn 0;\n\tlist_for_each_entry_safe(msg, nmsg, &gsm->tx_data_list, list) {\n\t\tdlci = gsm->dlci[msg->addr];\n\t\t/* Send only messages for DLCIs with valid state */\n\t\tif (dlci->state != DLCI_OPEN) {\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tret = gsm_send_packet(gsm, msg);\n\t\tswitch (ret) {\n\t\tcase -ENOSPC:\n\t\t\treturn -ENOSPC;\n\t\tcase -ENODEV:\n\t\t\t/* ldisc not open */\n\t\t\tgsm->tx_bytes -= msg->len;\n\t\t\tlist_del(&msg->list);\n\t\t\tkfree(msg);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (ret >= 0) {\n\t\t\t\tlist_del(&msg->list);\n\t\t\t\tkfree(msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/**\n *\t__gsm_data_queue\t\t-\tqueue a UI or UIH frame\n *\t@dlci: DLCI sending the data\n *\t@msg: message queued\n *\n *\tAdd data to the transmit queue and try and get stuff moving\n *\tout of the mux tty if not already doing so. The Caller must hold\n *\tthe gsm tx lock.\n */\n\nstatic void __gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tu8 *dp = msg->data;\n\tu8 *fcs = dp + msg->len;\n\n\t/* Fill in the header */\n\tif (gsm->encoding == GSM_BASIC_OPT) {\n\t\tif (msg->len < 128)\n\t\t\t*--dp = (msg->len << 1) | EA;\n\t\telse {\n\t\t\t*--dp = (msg->len >> 7);\t/* bits 7 - 15 */\n\t\t\t*--dp = (msg->len & 127) << 1;\t/* bits 0 - 6 */\n\t\t}\n\t}\n\n\t*--dp = msg->ctrl;\n\tif (gsm->initiator)\n\t\t*--dp = (msg->addr << 2) | CR | EA;\n\telse\n\t\t*--dp = (msg->addr << 2) | EA;\n\t*fcs = gsm_fcs_add_block(INIT_FCS, dp , msg->data - dp);\n\t/* Ugly protocol layering violation */\n\tif (msg->ctrl == UI || msg->ctrl == (UI|PF))\n\t\t*fcs = gsm_fcs_add_block(*fcs, msg->data, msg->len);\n\t*fcs = 0xFF - *fcs;\n\n\tgsm_print_packet(\"Q> \", msg->addr, gsm->initiator, msg->ctrl,\n\t\t\t\t\t\t\tmsg->data, msg->len);\n\n\t/* Move the header back and adjust the length, also allow for the FCS\n\t   now tacked on the end */\n\tmsg->len += (msg->data - dp) + 1;\n\tmsg->data = dp;\n\n\t/* Add to the actual output queue */\n\tswitch (msg->ctrl & ~PF) {\n\tcase UI:\n\tcase UIH:\n\t\tif (msg->addr > 0) {\n\t\t\tlist_add_tail(&msg->list, &gsm->tx_data_list);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tlist_add_tail(&msg->list, &gsm->tx_ctrl_list);\n\t\tbreak;\n\t}\n\tgsm->tx_bytes += msg->len;\n\n\tgsmld_write_trigger(gsm);\n\tmod_timer(&gsm->kick_timer, jiffies + 10 * gsm->t1 * HZ / 100);\n}\n\n/**\n *\tgsm_data_queue\t\t-\tqueue a UI or UIH frame\n *\t@dlci: DLCI sending the data\n *\t@msg: message queued\n *\n *\tAdd data to the transmit queue and try and get stuff moving\n *\tout of the mux tty if not already doing so. Take the\n *\tthe gsm tx lock and dlci lock.\n */\n\nstatic void gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\n\t__gsm_data_queue(dlci, msg);\n\tspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\n}\n\n/**\n *\tgsm_dlci_data_output\t-\ttry and push data out of a DLCI\n *\t@gsm: mux\n *\t@dlci: the DLCI to pull data from\n *\n *\tPull data from a DLCI and send it into the transmit queue if there\n *\tis data. Keep to the MRU of the mux. This path handles the usual tty\n *\tinterface which is a byte stream with optional modem data.\n *\n *\tCaller must hold the tx_lock of the mux.\n */\n\nstatic int gsm_dlci_data_output(struct gsm_mux *gsm, struct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint h, len, size;\n\n\t/* for modem bits without break data */\n\th = ((dlci->adaption == 1) ? 0 : 1);\n\n\tlen = kfifo_len(&dlci->fifo);\n\tif (len == 0)\n\t\treturn 0;\n\n\t/* MTU/MRU count only the data bits but watch adaption mode */\n\tif ((len + h) > dlci->mtu)\n\t\tlen = dlci->mtu - h;\n\n\tsize = len + h;\n\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tdp = msg->data;\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits.\n\t\t * Always one byte as we never send inline break data\n\t\t */\n\t\t*dp++ = (gsm_encode_modem(dlci) << 1) | EA;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported adaption %d\\n\", __func__,\n\t\t       dlci->adaption);\n\t\tbreak;\n\t}\n\n\tWARN_ON(len != kfifo_out_locked(&dlci->fifo, dp, len,\n\t\t&dlci->lock));\n\n\t/* Notify upper layer about available send space. */\n\ttty_port_tty_wakeup(&dlci->port);\n\n\t__gsm_data_queue(dlci, msg);\n\t/* Bytes of data we used up */\n\treturn size;\n}\n\n/**\n *\tgsm_dlci_data_output_framed  -\ttry and push data out of a DLCI\n *\t@gsm: mux\n *\t@dlci: the DLCI to pull data from\n *\n *\tPull data from a DLCI and send it into the transmit queue if there\n *\tis data. Keep to the MRU of the mux. This path handles framed data\n *\tqueued as skbuffs to the DLCI.\n *\n *\tCaller must hold the tx_lock of the mux.\n */\n\nstatic int gsm_dlci_data_output_framed(struct gsm_mux *gsm,\n\t\t\t\t\t\tstruct gsm_dlci *dlci)\n{\n\tstruct gsm_msg *msg;\n\tu8 *dp;\n\tint len, size;\n\tint last = 0, first = 0;\n\tint overhead = 0;\n\n\t/* One byte per frame is used for B/F flags */\n\tif (dlci->adaption == 4)\n\t\toverhead = 1;\n\n\t/* dlci->skb is locked by tx_lock */\n\tif (dlci->skb == NULL) {\n\t\tdlci->skb = skb_dequeue_tail(&dlci->skb_list);\n\t\tif (dlci->skb == NULL)\n\t\t\treturn 0;\n\t\tfirst = 1;\n\t}\n\tlen = dlci->skb->len + overhead;\n\n\t/* MTU/MRU count only the data bits */\n\tif (len > dlci->mtu) {\n\t\tif (dlci->adaption == 3) {\n\t\t\t/* Over long frame, bin it */\n\t\t\tdev_kfree_skb_any(dlci->skb);\n\t\t\tdlci->skb = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tlen = dlci->mtu;\n\t} else\n\t\tlast = 1;\n\n\tsize = len + overhead;\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (msg == NULL) {\n\t\tskb_queue_tail(&dlci->skb_list, dlci->skb);\n\t\tdlci->skb = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tdp = msg->data;\n\n\tif (dlci->adaption == 4) { /* Interruptible framed (Packetised Data) */\n\t\t/* Flag byte to carry the start/end info */\n\t\t*dp++ = last << 7 | first << 6 | 1;\t/* EA */\n\t\tlen--;\n\t}\n\tmemcpy(dp, dlci->skb->data, len);\n\tskb_pull(dlci->skb, len);\n\t__gsm_data_queue(dlci, msg);\n\tif (last) {\n\t\tdev_kfree_skb_any(dlci->skb);\n\t\tdlci->skb = NULL;\n\t}\n\treturn size;\n}\n\n/**\n *\tgsm_dlci_modem_output\t-\ttry and push modem status out of a DLCI\n *\t@gsm: mux\n *\t@dlci: the DLCI to pull modem status from\n *\t@brk: break signal\n *\n *\tPush an empty frame in to the transmit queue to update the modem status\n *\tbits and to transmit an optional break.\n *\n *\tCaller must hold the tx_lock of the mux.\n */\n\nstatic int gsm_dlci_modem_output(struct gsm_mux *gsm, struct gsm_dlci *dlci,\n\t\t\t\t u8 brk)\n{\n\tu8 *dp = NULL;\n\tstruct gsm_msg *msg;\n\tint size = 0;\n\n\t/* for modem bits without break data */\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits. */\n\t\tsize++;\n\t\tif (brk > 0)\n\t\t\tsize++;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unsupported adaption %d\\n\", __func__,\n\t\t       dlci->adaption);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = gsm_data_alloc(gsm, dlci->addr, size, dlci->ftype);\n\tif (!msg) {\n\t\tpr_err(\"%s: gsm_data_alloc error\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdp = msg->data;\n\tswitch (dlci->adaption) {\n\tcase 1: /* Unstructured */\n\t\tbreak;\n\tcase 2: /* Unstructured with modem bits. */\n\t\tif (brk == 0) {\n\t\t\t*dp++ = (gsm_encode_modem(dlci) << 1) | EA;\n\t\t} else {\n\t\t\t*dp++ = gsm_encode_modem(dlci) << 1;\n\t\t\t*dp++ = (brk << 4) | 2 | EA; /* Length, Break, EA */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Handled above */\n\t\tbreak;\n\t}\n\n\t__gsm_data_queue(dlci, msg);\n\treturn size;\n}\n\n/**\n *\tgsm_dlci_data_sweep\t\t-\tlook for data to send\n *\t@gsm: the GSM mux\n *\n *\tSweep the GSM mux channels in priority order looking for ones with\n *\tdata to send. We could do with optimising this scan a bit. We aim\n *\tto fill the queue totally or up to TX_THRESH_HI bytes. Once we hit\n *\tTX_THRESH_LO we get called again\n *\n *\tFIXME: We should round robin between groups and in theory you can\n *\trenegotiate DLCI priorities with optional stuff. Needs optimising.\n */\n\nstatic int gsm_dlci_data_sweep(struct gsm_mux *gsm)\n{\n\t/* Priority ordering: We should do priority with RR of the groups */\n\tint i, len, ret = 0;\n\tbool sent;\n\tstruct gsm_dlci *dlci;\n\n\twhile (gsm->tx_bytes < TX_THRESH_HI) {\n\t\tfor (sent = false, i = 1; i < NUM_DLCI; i++) {\n\t\t\tdlci = gsm->dlci[i];\n\t\t\t/* skip unused or blocked channel */\n\t\t\tif (!dlci || dlci->constipated)\n\t\t\t\tcontinue;\n\t\t\t/* skip channels with invalid state */\n\t\t\tif (dlci->state != DLCI_OPEN)\n\t\t\t\tcontinue;\n\t\t\t/* count the sent data per adaption */\n\t\t\tif (dlci->adaption < 3 && !dlci->net)\n\t\t\t\tlen = gsm_dlci_data_output(gsm, dlci);\n\t\t\telse\n\t\t\t\tlen = gsm_dlci_data_output_framed(gsm, dlci);\n\t\t\t/* on error exit */\n\t\t\tif (len < 0)\n\t\t\t\treturn ret;\n\t\t\tif (len > 0) {\n\t\t\t\tret++;\n\t\t\t\tsent = true;\n\t\t\t\t/* The lower DLCs can starve the higher DLCs! */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* try next */\n\t\t}\n\t\tif (!sent)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/**\n *\tgsm_dlci_data_kick\t-\ttransmit if possible\n *\t@dlci: DLCI to kick\n *\n *\tTransmit data from this DLCI if the queue is empty. We can't rely on\n *\ta tty wakeup except when we filled the pipe so we need to fire off\n *\tnew data ourselves in other cases.\n */\n\nstatic void gsm_dlci_data_kick(struct gsm_dlci *dlci)\n{\n\tunsigned long flags;\n\tint sweep;\n\n\tif (dlci->constipated)\n\t\treturn;\n\n\tspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\n\t/* If we have nothing running then we need to fire up */\n\tsweep = (dlci->gsm->tx_bytes < TX_THRESH_LO);\n\tif (dlci->gsm->tx_bytes == 0) {\n\t\tif (dlci->net)\n\t\t\tgsm_dlci_data_output_framed(dlci->gsm, dlci);\n\t\telse\n\t\t\tgsm_dlci_data_output(dlci->gsm, dlci);\n\t}\n\tif (sweep)\n\t\tgsm_dlci_data_sweep(dlci->gsm);\n\tspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\n}\n\n/*\n *\tControl message processing\n */\n\n\n/**\n * gsm_control_command\t-\tsend a command frame to a control\n * @gsm: gsm channel\n * @cmd: the command to use\n * @data: data to follow encoded info\n * @dlen: length of data\n *\n * Encode up and queue a UI/UIH frame containing our command.\n */\nstatic int gsm_control_command(struct gsm_mux *gsm, int cmd, const u8 *data,\n\t\t\t       int dlen)\n{\n\tstruct gsm_msg *msg;\n\n\tmsg = gsm_data_alloc(gsm, 0, dlen + 2, gsm->dlci[0]->ftype);\n\tif (msg == NULL)\n\t\treturn -ENOMEM;\n\n\tmsg->data[0] = (cmd << 1) | CR | EA;\t/* Set C/R */\n\tmsg->data[1] = (dlen << 1) | EA;\n\tmemcpy(msg->data + 2, data, dlen);\n\tgsm_data_queue(gsm->dlci[0], msg);\n\n\treturn 0;\n}\n\n/**\n *\tgsm_control_reply\t-\tsend a response frame to a control\n *\t@gsm: gsm channel\n *\t@cmd: the command to use\n *\t@data: data to follow encoded info\n *\t@dlen: length of data\n *\n *\tEncode up and queue a UI/UIH frame containing our response.\n */\n\nstatic void gsm_control_reply(struct gsm_mux *gsm, int cmd, const u8 *data,\n\t\t\t\t\tint dlen)\n{\n\tstruct gsm_msg *msg;\n\n\tmsg = gsm_data_alloc(gsm, 0, dlen + 2, gsm->dlci[0]->ftype);\n\tif (msg == NULL)\n\t\treturn;\n\tmsg->data[0] = (cmd & 0xFE) << 1 | EA;\t/* Clear C/R */\n\tmsg->data[1] = (dlen << 1) | EA;\n\tmemcpy(msg->data + 2, data, dlen);\n\tgsm_data_queue(gsm->dlci[0], msg);\n}\n\n/**\n *\tgsm_process_modem\t-\tprocess received modem status\n *\t@tty: virtual tty bound to the DLCI\n *\t@dlci: DLCI to affect\n *\t@modem: modem bits (full EA)\n *\t@slen: number of signal octets\n *\n *\tUsed when a modem control message or line state inline in adaption\n *\tlayer 2 is processed. Sort out the local modem state and throttles\n */\n\nstatic void gsm_process_modem(struct tty_struct *tty, struct gsm_dlci *dlci,\n\t\t\t\t\t\t\tu32 modem, int slen)\n{\n\tint  mlines = 0;\n\tu8 brk = 0;\n\tint fc;\n\n\t/* The modem status command can either contain one octet (V.24 signals)\n\t * or two octets (V.24 signals + break signals). This is specified in\n\t * section 5.4.6.3.7 of the 07.10 mux spec.\n\t */\n\n\tif (slen == 1)\n\t\tmodem = modem & 0x7f;\n\telse {\n\t\tbrk = modem & 0x7f;\n\t\tmodem = (modem >> 7) & 0x7f;\n\t}\n\n\t/* Flow control/ready to communicate */\n\tfc = (modem & MDM_FC) || !(modem & MDM_RTR);\n\tif (fc && !dlci->constipated) {\n\t\t/* Need to throttle our output on this device */\n\t\tdlci->constipated = true;\n\t} else if (!fc && dlci->constipated) {\n\t\tdlci->constipated = false;\n\t\tgsm_dlci_data_kick(dlci);\n\t}\n\n\t/* Map modem bits */\n\tif (modem & MDM_RTC)\n\t\tmlines |= TIOCM_DSR | TIOCM_DTR;\n\tif (modem & MDM_RTR)\n\t\tmlines |= TIOCM_RTS | TIOCM_CTS;\n\tif (modem & MDM_IC)\n\t\tmlines |= TIOCM_RI;\n\tif (modem & MDM_DV)\n\t\tmlines |= TIOCM_CD;\n\n\t/* Carrier drop -> hangup */\n\tif (tty) {\n\t\tif ((mlines & TIOCM_CD) == 0 && (dlci->modem_rx & TIOCM_CD))\n\t\t\tif (!C_CLOCAL(tty))\n\t\t\t\ttty_hangup(tty);\n\t}\n\tif (brk & 0x01)\n\t\ttty_insert_flip_char(&dlci->port, 0, TTY_BREAK);\n\tdlci->modem_rx = mlines;\n\twake_up_interruptible(&dlci->gsm->event);\n}\n\n/**\n * gsm_process_negotiation\t-\tprocess received parameters\n * @gsm: GSM channel\n * @addr: DLCI address\n * @cr: command/response\n * @params: encoded parameters from the parameter negotiation message\n *\n * Used when the response for our parameter negotiation command was\n * received.\n */\nstatic int gsm_process_negotiation(struct gsm_mux *gsm, unsigned int addr,\n\t\t\t\t   unsigned int cr,\n\t\t\t\t   const struct gsm_dlci_param_bits *params)\n{\n\tstruct gsm_dlci *dlci = gsm->dlci[addr];\n\tunsigned int ftype, i, adaption, prio, n1, k;\n\n\ti = FIELD_GET(PN_I_CL_FIELD_FTYPE, params->i_cl_bits);\n\tadaption = FIELD_GET(PN_I_CL_FIELD_ADAPTION, params->i_cl_bits) + 1;\n\tprio = FIELD_GET(PN_P_FIELD_PRIO, params->p_bits);\n\tn1 = FIELD_GET(PN_N_FIELD_N1, get_unaligned_le16(&params->n_bits));\n\tk = FIELD_GET(PN_K_FIELD_K, params->k_bits);\n\n\tif (n1 < MIN_MTU) {\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s N1 out of range in PN\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (i) {\n\tcase 0x00:\n\t\tftype = UIH;\n\t\tbreak;\n\tcase 0x01:\n\t\tftype = UI;\n\t\tbreak;\n\tcase 0x02: /* I frames are not supported */\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s unsupported I frame request in PN\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s i out of range in PN\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cr && gsm->initiator) {\n\t\tif (adaption != dlci->adaption) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid adaption %d in PN\\n\",\n\t\t\t\t\t__func__, adaption);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (prio != dlci->prio) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid priority %d in PN\",\n\t\t\t\t\t__func__, prio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n1 > gsm->mru || n1 > dlci->mtu) {\n\t\t\t/* We requested a frame size but the other party wants\n\t\t\t * to send larger frames. The standard allows only a\n\t\t\t * smaller response value than requested (5.4.6.3.1).\n\t\t\t */\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid N1 %d in PN\\n\", __func__,\n\t\t\t\t\tn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->mtu = n1;\n\t\tif (ftype != dlci->ftype) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid i %d in PN\\n\", __func__, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ftype != UI && ftype != UIH && k > dlci->k) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid k %d in PN\\n\", __func__, k);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->k = k;\n\t} else if (cr && !gsm->initiator) {\n\t\t/* Only convergence layer type 1 and 2 are supported. */\n\t\tif (adaption != 1 && adaption != 2) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"%s invalid adaption %d in PN\\n\",\n\t\t\t\t\t__func__, adaption);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdlci->adaption = adaption;\n\t\tif (n1 > gsm->mru) {\n\t\t\t/* Propose a smaller value */\n\t\t\tdlci->mtu = gsm->mru;\n\t\t} else if (n1 > MAX_MTU) {\n\t\t\t/* Propose a smaller value */\n\t\t\tdlci->mtu = MAX_MTU;\n\t\t} else {\n\t\t\tdlci->mtu = n1;\n\t\t}\n\t\tdlci->prio = prio;\n\t\tdlci->ftype = ftype;\n\t\tdlci->k = k;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n *\tgsm_control_modem\t-\tmodem status received\n *\t@gsm: GSM channel\n *\t@data: data following command\n *\t@clen: command length\n *\n *\tWe have received a modem status control message. This is used by\n *\tthe GSM mux protocol to pass virtual modem line status and optionally\n *\tto indicate break signals. Unpack it, convert to Linux representation\n *\tand if need be stuff a break message down the tty.\n */\n\nstatic void gsm_control_modem(struct gsm_mux *gsm, const u8 *data, int clen)\n{\n\tunsigned int addr = 0;\n\tunsigned int modem = 0;\n\tstruct gsm_dlci *dlci;\n\tint len = clen;\n\tint cl = clen;\n\tconst u8 *dp = data;\n\tstruct tty_struct *tty;\n\n\tlen = gsm_read_ea_val(&addr, data, cl);\n\tif (len < 1)\n\t\treturn;\n\n\taddr >>= 1;\n\t/* Closed port, or invalid ? */\n\tif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\n\t\treturn;\n\tdlci = gsm->dlci[addr];\n\n\t/* Must be at least one byte following the EA */\n\tif ((cl - len) < 1)\n\t\treturn;\n\n\tdp += len;\n\tcl -= len;\n\n\t/* get the modem status */\n\tlen = gsm_read_ea_val(&modem, dp, cl);\n\tif (len < 1)\n\t\treturn;\n\n\ttty = tty_port_tty_get(&dlci->port);\n\tgsm_process_modem(tty, dlci, modem, cl);\n\tif (tty) {\n\t\ttty_wakeup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\tgsm_control_reply(gsm, CMD_MSC, data, clen);\n}\n\n/**\n * gsm_control_negotiation\t-\tparameter negotiation received\n * @gsm: GSM channel\n * @cr: command/response flag\n * @data: data following command\n * @dlen: data length\n *\n * We have received a parameter negotiation message. This is used by\n * the GSM mux protocol to configure protocol parameters for a new DLCI.\n */\nstatic void gsm_control_negotiation(struct gsm_mux *gsm, unsigned int cr,\n\t\t\t\t    const u8 *data, unsigned int dlen)\n{\n\tunsigned int addr;\n\tstruct gsm_dlci_param_bits pn_reply;\n\tstruct gsm_dlci *dlci;\n\tstruct gsm_dlci_param_bits *params;\n\n\tif (dlen < sizeof(struct gsm_dlci_param_bits))\n\t\treturn;\n\n\t/* Invalid DLCI? */\n\tparams = (struct gsm_dlci_param_bits *)data;\n\taddr = FIELD_GET(PN_D_FIELD_DLCI, params->d_bits);\n\tif (addr == 0 || addr >= NUM_DLCI || !gsm->dlci[addr])\n\t\treturn;\n\tdlci = gsm->dlci[addr];\n\n\t/* Too late for parameter negotiation? */\n\tif ((!cr && dlci->state == DLCI_OPENING) || dlci->state == DLCI_OPEN)\n\t\treturn;\n\n\t/* Process the received parameters */\n\tif (gsm_process_negotiation(gsm, addr, cr, params) != 0) {\n\t\t/* Negotiation failed. Close the link. */\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN failed\\n\", __func__);\n\t\tgsm_dlci_close(dlci);\n\t\treturn;\n\t}\n\n\tif (cr) {\n\t\t/* Reply command with accepted parameters. */\n\t\tif (gsm_encode_params(dlci, &pn_reply) == 0)\n\t\t\tgsm_control_reply(gsm, CMD_PN, (const u8 *)&pn_reply,\n\t\t\t\t\t  sizeof(pn_reply));\n\t\telse if (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN invalid\\n\", __func__);\n\t} else if (dlci->state == DLCI_CONFIGURE) {\n\t\t/* Proceed with link setup by sending SABM before UA */\n\t\tdlci->state = DLCI_OPENING;\n\t\tgsm_command(gsm, dlci->addr, SABM|PF);\n\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t} else {\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_info(\"%s PN in invalid state\\n\", __func__);\n\t}\n}\n\n/**\n *\tgsm_control_rls\t\t-\tremote line status\n *\t@gsm: GSM channel\n *\t@data: data bytes\n *\t@clen: data length\n *\n *\tThe modem sends us a two byte message on the control channel whenever\n *\tit wishes to send us an error state from the virtual link. Stuff\n *\tthis into the uplink tty if present\n */\n\nstatic void gsm_control_rls(struct gsm_mux *gsm, const u8 *data, int clen)\n{\n\tstruct tty_port *port;\n\tunsigned int addr = 0;\n\tu8 bits;\n\tint len = clen;\n\tconst u8 *dp = data;\n\n\twhile (gsm_read_ea(&addr, *dp++) == 0) {\n\t\tlen--;\n\t\tif (len == 0)\n\t\t\treturn;\n\t}\n\t/* Must be at least one byte following ea */\n\tlen--;\n\tif (len <= 0)\n\t\treturn;\n\taddr >>= 1;\n\t/* Closed port, or invalid ? */\n\tif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\n\t\treturn;\n\t/* No error ? */\n\tbits = *dp;\n\tif ((bits & 1) == 0)\n\t\treturn;\n\n\tport = &gsm->dlci[addr]->port;\n\n\tif (bits & 2)\n\t\ttty_insert_flip_char(port, 0, TTY_OVERRUN);\n\tif (bits & 4)\n\t\ttty_insert_flip_char(port, 0, TTY_PARITY);\n\tif (bits & 8)\n\t\ttty_insert_flip_char(port, 0, TTY_FRAME);\n\n\ttty_flip_buffer_push(port);\n\n\tgsm_control_reply(gsm, CMD_RLS, data, clen);\n}\n\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci);\n\n/**\n *\tgsm_control_message\t-\tDLCI 0 control processing\n *\t@gsm: our GSM mux\n *\t@command:  the command EA\n *\t@data: data beyond the command/length EAs\n *\t@clen: length\n *\n *\tInput processor for control messages from the other end of the link.\n *\tProcesses the incoming request and queues a response frame or an\n *\tNSC response if not supported\n */\n\nstatic void gsm_control_message(struct gsm_mux *gsm, unsigned int command,\n\t\t\t\t\t\tconst u8 *data, int clen)\n{\n\tu8 buf[1];\n\n\tswitch (command) {\n\tcase CMD_CLD: {\n\t\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\t\t/* Modem wishes to close down */\n\t\tif (dlci) {\n\t\t\tdlci->dead = true;\n\t\t\tgsm->dead = true;\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase CMD_TEST:\n\t\t/* Modem wishes to test, reply with the data */\n\t\tgsm_control_reply(gsm, CMD_TEST, data, clen);\n\t\tbreak;\n\tcase CMD_FCON:\n\t\t/* Modem can accept data again */\n\t\tgsm->constipated = false;\n\t\tgsm_control_reply(gsm, CMD_FCON, NULL, 0);\n\t\t/* Kick the link in case it is idling */\n\t\tgsmld_write_trigger(gsm);\n\t\tbreak;\n\tcase CMD_FCOFF:\n\t\t/* Modem wants us to STFU */\n\t\tgsm->constipated = true;\n\t\tgsm_control_reply(gsm, CMD_FCOFF, NULL, 0);\n\t\tbreak;\n\tcase CMD_MSC:\n\t\t/* Out of band modem line change indicator for a DLCI */\n\t\tgsm_control_modem(gsm, data, clen);\n\t\tbreak;\n\tcase CMD_RLS:\n\t\t/* Out of band error reception for a DLCI */\n\t\tgsm_control_rls(gsm, data, clen);\n\t\tbreak;\n\tcase CMD_PSC:\n\t\t/* Modem wishes to enter power saving state */\n\t\tgsm_control_reply(gsm, CMD_PSC, NULL, 0);\n\t\tbreak;\n\t\t/* Optional commands */\n\tcase CMD_PN:\n\t\t/* Modem sends a parameter negotiation command */\n\t\tgsm_control_negotiation(gsm, 1, data, clen);\n\t\tbreak;\n\t\t/* Optional unsupported commands */\n\tcase CMD_RPN:\t/* Remote port negotiation */\n\tcase CMD_SNC:\t/* Service negotiation command */\n\tdefault:\n\t\t/* Reply to bad commands with an NSC */\n\t\tbuf[0] = command;\n\t\tgsm_control_reply(gsm, CMD_NSC, buf, 1);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_control_response\t-\tprocess a response to our control\n *\t@gsm: our GSM mux\n *\t@command: the command (response) EA\n *\t@data: data beyond the command/length EA\n *\t@clen: length\n *\n *\tProcess a response to an outstanding command. We only allow a single\n *\tcontrol message in flight so this is fairly easy. All the clean up\n *\tis done by the caller, we just update the fields, flag it as done\n *\tand return\n */\n\nstatic void gsm_control_response(struct gsm_mux *gsm, unsigned int command,\n\t\t\t\t\t\tconst u8 *data, int clen)\n{\n\tstruct gsm_control *ctrl;\n\tstruct gsm_dlci *dlci;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\n\tctrl = gsm->pending_cmd;\n\tdlci = gsm->dlci[0];\n\tcommand |= 1;\n\t/* Does the reply match our command */\n\tif (ctrl != NULL && (command == ctrl->cmd || command == CMD_NSC)) {\n\t\t/* Our command was replied to, kill the retry timer */\n\t\tdel_timer(&gsm->t2_timer);\n\t\tgsm->pending_cmd = NULL;\n\t\t/* Rejected by the other end */\n\t\tif (command == CMD_NSC)\n\t\t\tctrl->error = -EOPNOTSUPP;\n\t\tctrl->done = 1;\n\t\twake_up(&gsm->event);\n\t/* Or did we receive the PN response to our PN command */\n\t} else if (command == CMD_PN) {\n\t\tgsm_control_negotiation(gsm, 0, data, clen);\n\t/* Or did we receive the TEST response to our TEST command */\n\t} else if (command == CMD_TEST && clen == 1 && *data == gsm->ka_num) {\n\t\tgsm->ka_retries = -1; /* trigger new keep-alive message */\n\t\tif (dlci && !dlci->dead)\n\t\t\tmod_timer(&gsm->ka_timer, jiffies + gsm->keep_alive * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n/**\n * gsm_control_keep_alive\t-\tcheck timeout or start keep-alive\n * @t: timer contained in our gsm object\n *\n * Called off the keep-alive timer expiry signaling that our link\n * partner is not responding anymore. Link will be closed.\n * This is also called to startup our timer.\n */\n\nstatic void gsm_control_keep_alive(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, ka_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tif (gsm->ka_num && gsm->ka_retries == 0) {\n\t\t/* Keep-alive expired -> close the link */\n\t\tif (debug & DBG_ERRORS)\n\t\t\tpr_debug(\"%s keep-alive timed out\\n\", __func__);\n\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\tif (gsm->dlci[0])\n\t\t\tgsm_dlci_begin_close(gsm->dlci[0]);\n\t\treturn;\n\t} else if (gsm->keep_alive && gsm->dlci[0] && !gsm->dlci[0]->dead) {\n\t\tif (gsm->ka_retries > 0) {\n\t\t\t/* T2 expired for keep-alive -> resend */\n\t\t\tgsm->ka_retries--;\n\t\t} else {\n\t\t\t/* Start keep-alive timer */\n\t\t\tgsm->ka_num++;\n\t\t\tif (!gsm->ka_num)\n\t\t\t\tgsm->ka_num++;\n\t\t\tgsm->ka_retries = (signed int)gsm->n2;\n\t\t}\n\t\tgsm_control_command(gsm, CMD_TEST, &gsm->ka_num,\n\t\t\t\t    sizeof(gsm->ka_num));\n\t\tmod_timer(&gsm->ka_timer,\n\t\t\t  jiffies + gsm->t2 * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n/**\n *\tgsm_control_transmit\t-\tsend control packet\n *\t@gsm: gsm mux\n *\t@ctrl: frame to send\n *\n *\tSend out a pending control command (called under control lock)\n */\n\nstatic void gsm_control_transmit(struct gsm_mux *gsm, struct gsm_control *ctrl)\n{\n\tgsm_control_command(gsm, ctrl->cmd, ctrl->data, ctrl->len);\n}\n\n/**\n *\tgsm_control_retransmit\t-\tretransmit a control frame\n *\t@t: timer contained in our gsm object\n *\n *\tCalled off the T2 timer expiry in order to retransmit control frames\n *\tthat have been lost in the system somewhere. The control_lock protects\n *\tus from colliding with another sender or a receive completion event.\n *\tIn that situation the timer may still occur in a small window but\n *\tgsm->pending_cmd will be NULL and we just let the timer expire.\n */\n\nstatic void gsm_control_retransmit(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, t2_timer);\n\tstruct gsm_control *ctrl;\n\tunsigned long flags;\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tctrl = gsm->pending_cmd;\n\tif (ctrl) {\n\t\tif (gsm->cretries == 0 || !gsm->dlci[0] || gsm->dlci[0]->dead) {\n\t\t\tgsm->pending_cmd = NULL;\n\t\t\tctrl->error = -ETIMEDOUT;\n\t\t\tctrl->done = 1;\n\t\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\t\twake_up(&gsm->event);\n\t\t\treturn;\n\t\t}\n\t\tgsm->cretries--;\n\t\tgsm_control_transmit(gsm, ctrl);\n\t\tmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\n\t}\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n}\n\n/**\n *\tgsm_control_send\t-\tsend a control frame on DLCI 0\n *\t@gsm: the GSM channel\n *\t@command: command  to send including CR bit\n *\t@data: bytes of data (must be kmalloced)\n *\t@clen: length of the block to send\n *\n *\tQueue and dispatch a control command. Only one command can be\n *\tactive at a time. In theory more can be outstanding but the matching\n *\tgets really complicated so for now stick to one outstanding.\n */\n\nstatic struct gsm_control *gsm_control_send(struct gsm_mux *gsm,\n\t\tunsigned int command, u8 *data, int clen)\n{\n\tstruct gsm_control *ctrl = kzalloc(sizeof(struct gsm_control),\n\t\t\t\t\t\tGFP_ATOMIC);\n\tunsigned long flags;\n\tif (ctrl == NULL)\n\t\treturn NULL;\nretry:\n\twait_event(gsm->event, gsm->pending_cmd == NULL);\n\tspin_lock_irqsave(&gsm->control_lock, flags);\n\tif (gsm->pending_cmd != NULL) {\n\t\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\t\tgoto retry;\n\t}\n\tctrl->cmd = command;\n\tctrl->data = data;\n\tctrl->len = clen;\n\tgsm->pending_cmd = ctrl;\n\n\t/* If DLCI0 is in ADM mode skip retries, it won't respond */\n\tif (gsm->dlci[0]->mode == DLCI_MODE_ADM)\n\t\tgsm->cretries = 0;\n\telse\n\t\tgsm->cretries = gsm->n2;\n\n\tmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\n\tgsm_control_transmit(gsm, ctrl);\n\tspin_unlock_irqrestore(&gsm->control_lock, flags);\n\treturn ctrl;\n}\n\n/**\n *\tgsm_control_wait\t-\twait for a control to finish\n *\t@gsm: GSM mux\n *\t@control: control we are waiting on\n *\n *\tWaits for the control to complete or time out. Frees any used\n *\tresources and returns 0 for success, or an error if the remote\n *\trejected or ignored the request.\n */\n\nstatic int gsm_control_wait(struct gsm_mux *gsm, struct gsm_control *control)\n{\n\tint err;\n\twait_event(gsm->event, control->done == 1);\n\terr = control->error;\n\tkfree(control);\n\treturn err;\n}\n\n\n/*\n *\tDLCI level handling: Needs krefs\n */\n\n/*\n *\tState transitions and timers\n */\n\n/**\n *\tgsm_dlci_close\t\t-\ta DLCI has closed\n *\t@dlci: DLCI that closed\n *\n *\tPerform processing when moving a DLCI into closed state. If there\n *\tis an attached tty this is hung up\n */\n\nstatic void gsm_dlci_close(struct gsm_dlci *dlci)\n{\n\tdel_timer(&dlci->t1);\n\tif (debug & DBG_ERRORS)\n\t\tpr_debug(\"DLCI %d goes closed.\\n\", dlci->addr);\n\tdlci->state = DLCI_CLOSED;\n\t/* Prevent us from sending data before the link is up again */\n\tdlci->constipated = true;\n\tif (dlci->addr != 0) {\n\t\ttty_port_tty_hangup(&dlci->port, false);\n\t\tgsm_dlci_clear_queues(dlci->gsm, dlci);\n\t\t/* Ensure that gsmtty_open() can return. */\n\t\ttty_port_set_initialized(&dlci->port, false);\n\t\twake_up_interruptible(&dlci->port.open_wait);\n\t} else {\n\t\tdel_timer(&dlci->gsm->ka_timer);\n\t\tdlci->gsm->dead = true;\n\t}\n\t/* A DLCI 0 close is a MUX termination so we need to kick that\n\t   back to userspace somehow */\n\tgsm_dlci_data_kick(dlci);\n\twake_up_all(&dlci->gsm->event);\n}\n\n/**\n *\tgsm_dlci_open\t\t-\ta DLCI has opened\n *\t@dlci: DLCI that opened\n *\n *\tPerform processing when moving a DLCI into open state.\n */\n\nstatic void gsm_dlci_open(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\t/* Note that SABM UA .. SABM UA first UA lost can mean that we go\n\t   open -> open */\n\tdel_timer(&dlci->t1);\n\t/* This will let a tty open continue */\n\tdlci->state = DLCI_OPEN;\n\tdlci->constipated = false;\n\tif (debug & DBG_ERRORS)\n\t\tpr_debug(\"DLCI %d goes open.\\n\", dlci->addr);\n\t/* Send current modem state */\n\tif (dlci->addr) {\n\t\tgsm_modem_update(dlci, 0);\n\t} else {\n\t\t/* Start keep-alive control */\n\t\tgsm->ka_num = 0;\n\t\tgsm->ka_retries = -1;\n\t\tmod_timer(&gsm->ka_timer,\n\t\t\t  jiffies + gsm->keep_alive * HZ / 100);\n\t}\n\tgsm_dlci_data_kick(dlci);\n\twake_up(&dlci->gsm->event);\n}\n\n/**\n * gsm_dlci_negotiate\t-\tstart parameter negotiation\n * @dlci: DLCI to open\n *\n * Starts the parameter negotiation for the new DLCI. This needs to be done\n * before the DLCI initialized the channel via SABM.\n */\nstatic int gsm_dlci_negotiate(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tstruct gsm_dlci_param_bits params;\n\tint ret;\n\n\tret = gsm_encode_params(dlci, &params);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* We cannot asynchronous wait for the command response with\n\t * gsm_command() and gsm_control_wait() at this point.\n\t */\n\tret = gsm_control_command(gsm, CMD_PN, (const u8 *)&params,\n\t\t\t\t  sizeof(params));\n\n\treturn ret;\n}\n\n/**\n *\tgsm_dlci_t1\t\t-\tT1 timer expiry\n *\t@t: timer contained in the DLCI that opened\n *\n *\tThe T1 timer handles retransmits of control frames (essentially of\n *\tSABM and DISC). We resend the command until the retry count runs out\n *\tin which case an opening port goes back to closed and a closing port\n *\tis simply put into closed state (any further frames from the other\n *\tend will get a DM response)\n *\n *\tSome control dlci can stay in ADM mode with other dlci working just\n *\tfine. In that case we can just keep the control dlci open after the\n *\tDLCI_OPENING retries time out.\n */\n\nstatic void gsm_dlci_t1(struct timer_list *t)\n{\n\tstruct gsm_dlci *dlci = from_timer(dlci, t, t1);\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\tswitch (dlci->state) {\n\tcase DLCI_CONFIGURE:\n\t\tif (dlci->retries && gsm_dlci_negotiate(dlci) == 0) {\n\t\t\tdlci->retries--;\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else {\n\t\t\tgsm_dlci_begin_close(dlci); /* prevent half open link */\n\t\t}\n\t\tbreak;\n\tcase DLCI_OPENING:\n\t\tif (dlci->retries) {\n\t\t\tdlci->retries--;\n\t\t\tgsm_command(dlci->gsm, dlci->addr, SABM|PF);\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else if (!dlci->addr && gsm->control == (DM | PF)) {\n\t\t\tif (debug & DBG_ERRORS)\n\t\t\t\tpr_info(\"DLCI %d opening in ADM mode.\\n\",\n\t\t\t\t\tdlci->addr);\n\t\t\tdlci->mode = DLCI_MODE_ADM;\n\t\t\tgsm_dlci_open(dlci);\n\t\t} else {\n\t\t\tgsm_dlci_begin_close(dlci); /* prevent half open link */\n\t\t}\n\n\t\tbreak;\n\tcase DLCI_CLOSING:\n\t\tif (dlci->retries) {\n\t\t\tdlci->retries--;\n\t\t\tgsm_command(dlci->gsm, dlci->addr, DISC|PF);\n\t\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\t} else\n\t\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, dlci->state);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_dlci_begin_open\t-\tstart channel open procedure\n *\t@dlci: DLCI to open\n *\n *\tCommence opening a DLCI from the Linux side. We issue SABM messages\n *\tto the modem which should then reply with a UA or ADM, at which point\n *\twe will move into open state. Opening is done asynchronously with retry\n *\trunning off timers and the responses.\n *\tParameter negotiation is performed before SABM if required.\n */\n\nstatic void gsm_dlci_begin_open(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci ? dlci->gsm : NULL;\n\tbool need_pn = false;\n\n\tif (!gsm)\n\t\treturn;\n\n\tif (dlci->addr != 0) {\n\t\tif (gsm->adaption != 1 || gsm->adaption != dlci->adaption)\n\t\t\tneed_pn = true;\n\t\tif (dlci->prio != (roundup(dlci->addr + 1, 8) - 1))\n\t\t\tneed_pn = true;\n\t\tif (gsm->ftype != dlci->ftype)\n\t\t\tneed_pn = true;\n\t}\n\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_WAITING_CONFIG:\n\tcase DLCI_CLOSING:\n\t\tdlci->retries = gsm->n2;\n\t\tif (!need_pn) {\n\t\t\tdlci->state = DLCI_OPENING;\n\t\t\tgsm_command(gsm, dlci->addr, SABM|PF);\n\t\t} else {\n\t\t\t/* Configure DLCI before setup */\n\t\t\tdlci->state = DLCI_CONFIGURE;\n\t\t\tif (gsm_dlci_negotiate(dlci) != 0) {\n\t\t\t\tgsm_dlci_close(dlci);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_dlci_set_opening\t-\tchange state to opening\n *\t@dlci: DLCI to open\n *\n *\tChange internal state to wait for DLCI open from initiator side.\n *\tWe set off timers and responses upon reception of an SABM.\n */\nstatic void gsm_dlci_set_opening(struct gsm_dlci *dlci)\n{\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_WAITING_CONFIG:\n\tcase DLCI_CLOSING:\n\t\tdlci->state = DLCI_OPENING;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * gsm_dlci_set_wait_config\t-\twait for channel configuration\n * @dlci: DLCI to configure\n *\n * Wait for a DLCI configuration from the application.\n */\nstatic void gsm_dlci_set_wait_config(struct gsm_dlci *dlci)\n{\n\tswitch (dlci->state) {\n\tcase DLCI_CLOSED:\n\tcase DLCI_CLOSING:\n\t\tdlci->state = DLCI_WAITING_CONFIG;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_dlci_begin_close\t-\tstart channel open procedure\n *\t@dlci: DLCI to open\n *\n *\tCommence closing a DLCI from the Linux side. We issue DISC messages\n *\tto the modem which should then reply with a UA, at which point we\n *\twill move into closed state. Closing is done asynchronously with retry\n *\toff timers. We may also receive a DM reply from the other end which\n *\tindicates the channel was already closed.\n */\n\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tif (dlci->state == DLCI_CLOSED || dlci->state == DLCI_CLOSING)\n\t\treturn;\n\tdlci->retries = gsm->n2;\n\tdlci->state = DLCI_CLOSING;\n\tgsm_command(dlci->gsm, dlci->addr, DISC|PF);\n\tmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\n\twake_up_interruptible(&gsm->event);\n}\n\n/**\n *\tgsm_dlci_data\t\t-\tdata arrived\n *\t@dlci: channel\n *\t@data: block of bytes received\n *\t@clen: length of received block\n *\n *\tA UI or UIH frame has arrived which contains data for a channel\n *\tother than the control channel. If the relevant virtual tty is\n *\topen we shovel the bits down it, if not we drop them.\n */\n\nstatic void gsm_dlci_data(struct gsm_dlci *dlci, const u8 *data, int clen)\n{\n\t/* krefs .. */\n\tstruct tty_port *port = &dlci->port;\n\tstruct tty_struct *tty;\n\tunsigned int modem = 0;\n\tint len;\n\n\tif (debug & DBG_TTY)\n\t\tpr_debug(\"%d bytes for tty\\n\", clen);\n\tswitch (dlci->adaption)  {\n\t/* Unsupported types */\n\tcase 4:\t\t/* Packetised interruptible data */\n\t\tbreak;\n\tcase 3:\t\t/* Packetised uininterruptible voice/data */\n\t\tbreak;\n\tcase 2:\t\t/* Asynchronous serial with line state in each frame */\n\t\tlen = gsm_read_ea_val(&modem, data, clen);\n\t\tif (len < 1)\n\t\t\treturn;\n\t\ttty = tty_port_tty_get(port);\n\t\tif (tty) {\n\t\t\tgsm_process_modem(tty, dlci, modem, len);\n\t\t\ttty_wakeup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\t/* Skip processed modem data */\n\t\tdata += len;\n\t\tclen -= len;\n\t\tfallthrough;\n\tcase 1:\t\t/* Line state will go via DLCI 0 controls only */\n\tdefault:\n\t\ttty_insert_flip_string(port, data, clen);\n\t\ttty_flip_buffer_push(port);\n\t}\n}\n\n/**\n *\tgsm_dlci_command\t-\tdata arrived on control channel\n *\t@dlci: channel\n *\t@data: block of bytes received\n *\t@len: length of received block\n *\n *\tA UI or UIH frame has arrived which contains data for DLCI 0 the\n *\tcontrol channel. This should contain a command EA followed by\n *\tcontrol data bytes. The command EA contains a command/response bit\n *\tand we divide up the work accordingly.\n */\n\nstatic void gsm_dlci_command(struct gsm_dlci *dlci, const u8 *data, int len)\n{\n\t/* See what command is involved */\n\tunsigned int command = 0;\n\tunsigned int clen = 0;\n\tunsigned int dlen;\n\n\t/* read the command */\n\tdlen = gsm_read_ea_val(&command, data, len);\n\tlen -= dlen;\n\tdata += dlen;\n\n\t/* read any control data */\n\tdlen = gsm_read_ea_val(&clen, data, len);\n\tlen -= dlen;\n\tdata += dlen;\n\n\t/* Malformed command? */\n\tif (clen > len)\n\t\treturn;\n\n\tif (command & 1)\n\t\tgsm_control_message(dlci->gsm, command, data, clen);\n\telse\n\t\tgsm_control_response(dlci->gsm, command, data, clen);\n}\n\n/**\n *\tgsm_kick_timer\t-\ttransmit if possible\n *\t@t: timer contained in our gsm object\n *\n *\tTransmit data from DLCIs if the queue is empty. We can't rely on\n *\ta tty wakeup except when we filled the pipe so we need to fire off\n *\tnew data ourselves in other cases.\n */\nstatic void gsm_kick_timer(struct timer_list *t)\n{\n\tstruct gsm_mux *gsm = from_timer(gsm, t, kick_timer);\n\tunsigned long flags;\n\tint sent = 0;\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\t/* If we have nothing running then we need to fire up */\n\tif (gsm->tx_bytes < TX_THRESH_LO)\n\t\tsent = gsm_dlci_data_sweep(gsm);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\tif (sent && debug & DBG_DATA)\n\t\tpr_info(\"%s TX queue stalled\\n\", __func__);\n}\n\n/**\n * gsm_dlci_copy_config_values\t-\tcopy DLCI configuration\n * @dlci: source DLCI\n * @dc: configuration structure to fill\n */\nstatic void gsm_dlci_copy_config_values(struct gsm_dlci *dlci, struct gsm_dlci_config *dc)\n{\n\tmemset(dc, 0, sizeof(*dc));\n\tdc->channel = (u32)dlci->addr;\n\tdc->adaption = (u32)dlci->adaption;\n\tdc->mtu = (u32)dlci->mtu;\n\tdc->priority = (u32)dlci->prio;\n\tif (dlci->ftype == UIH)\n\t\tdc->i = 1;\n\telse\n\t\tdc->i = 2;\n\tdc->k = (u32)dlci->k;\n}\n\n/**\n * gsm_dlci_config\t-\tconfigure DLCI from configuration\n * @dlci: DLCI to configure\n * @dc: DLCI configuration\n * @open: open DLCI after configuration?\n */\nstatic int gsm_dlci_config(struct gsm_dlci *dlci, struct gsm_dlci_config *dc, int open)\n{\n\tstruct gsm_mux *gsm;\n\tbool need_restart = false;\n\tbool need_open = false;\n\tunsigned int i;\n\n\t/*\n\t * Check that userspace doesn't put stuff in here to prevent breakages\n\t * in the future.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(dc->reserved); i++)\n\t\tif (dc->reserved[i])\n\t\t\treturn -EINVAL;\n\n\tif (!dlci)\n\t\treturn -EINVAL;\n\tgsm = dlci->gsm;\n\n\t/* Stuff we don't support yet - I frame transport */\n\tif (dc->adaption != 1 && dc->adaption != 2)\n\t\treturn -EOPNOTSUPP;\n\tif (dc->mtu > MAX_MTU || dc->mtu < MIN_MTU || dc->mtu > gsm->mru)\n\t\treturn -EINVAL;\n\tif (dc->priority >= 64)\n\t\treturn -EINVAL;\n\tif (dc->i == 0 || dc->i > 2)  /* UIH and UI only */\n\t\treturn -EINVAL;\n\tif (dc->k > 7)\n\t\treturn -EINVAL;\n\n\t/*\n\t * See what is needed for reconfiguration\n\t */\n\t/* Framing fields */\n\tif (dc->adaption != dlci->adaption)\n\t\tneed_restart = true;\n\tif (dc->mtu != dlci->mtu)\n\t\tneed_restart = true;\n\tif (dc->i != dlci->ftype)\n\t\tneed_restart = true;\n\t/* Requires care */\n\tif (dc->priority != dlci->prio)\n\t\tneed_restart = true;\n\n\tif ((open && gsm->wait_config) || need_restart)\n\t\tneed_open = true;\n\tif (dlci->state == DLCI_WAITING_CONFIG) {\n\t\tneed_restart = false;\n\t\tneed_open = true;\n\t}\n\n\t/*\n\t * Close down what is needed, restart and initiate the new\n\t * configuration.\n\t */\n\tif (need_restart) {\n\t\tgsm_dlci_begin_close(dlci);\n\t\twait_event_interruptible(gsm->event, dlci->state == DLCI_CLOSED);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t}\n\t/*\n\t * Setup the new configuration values\n\t */\n\tdlci->adaption = (int)dc->adaption;\n\n\tif (dc->mtu)\n\t\tdlci->mtu = (unsigned int)dc->mtu;\n\telse\n\t\tdlci->mtu = gsm->mtu;\n\n\tif (dc->priority)\n\t\tdlci->prio = (u8)dc->priority;\n\telse\n\t\tdlci->prio = roundup(dlci->addr + 1, 8) - 1;\n\n\tif (dc->i == 1)\n\t\tdlci->ftype = UIH;\n\telse if (dc->i == 2)\n\t\tdlci->ftype = UI;\n\n\tif (dc->k)\n\t\tdlci->k = (u8)dc->k;\n\telse\n\t\tdlci->k = gsm->k;\n\n\tif (need_open) {\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(dlci);\n\t\telse\n\t\t\tgsm_dlci_set_opening(dlci);\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tAllocate/Free DLCI channels\n */\n\n/**\n *\tgsm_dlci_alloc\t\t-\tallocate a DLCI\n *\t@gsm: GSM mux\n *\t@addr: address of the DLCI\n *\n *\tAllocate and install a new DLCI object into the GSM mux.\n *\n *\tFIXME: review locking races\n */\n\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr)\n{\n\tstruct gsm_dlci *dlci = kzalloc(sizeof(struct gsm_dlci), GFP_ATOMIC);\n\tif (dlci == NULL)\n\t\treturn NULL;\n\tspin_lock_init(&dlci->lock);\n\tmutex_init(&dlci->mutex);\n\tif (kfifo_alloc(&dlci->fifo, TX_SIZE, GFP_KERNEL) < 0) {\n\t\tkfree(dlci);\n\t\treturn NULL;\n\t}\n\n\tskb_queue_head_init(&dlci->skb_list);\n\ttimer_setup(&dlci->t1, gsm_dlci_t1, 0);\n\ttty_port_init(&dlci->port);\n\tdlci->port.ops = &gsm_port_ops;\n\tdlci->gsm = gsm;\n\tdlci->addr = addr;\n\tdlci->adaption = gsm->adaption;\n\tdlci->mtu = gsm->mtu;\n\tif (addr == 0)\n\t\tdlci->prio = 0;\n\telse\n\t\tdlci->prio = roundup(addr + 1, 8) - 1;\n\tdlci->ftype = gsm->ftype;\n\tdlci->k = gsm->k;\n\tdlci->state = DLCI_CLOSED;\n\tif (addr) {\n\t\tdlci->data = gsm_dlci_data;\n\t\t/* Prevent us from sending data before the link is up */\n\t\tdlci->constipated = true;\n\t} else {\n\t\tdlci->data = gsm_dlci_command;\n\t}\n\tgsm->dlci[addr] = dlci;\n\treturn dlci;\n}\n\n/**\n *\tgsm_dlci_free\t\t-\tfree DLCI\n *\t@port: tty port for DLCI to free\n *\n *\tFree up a DLCI.\n *\n *\tCan sleep.\n */\nstatic void gsm_dlci_free(struct tty_port *port)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\n\ttimer_shutdown_sync(&dlci->t1);\n\tdlci->gsm->dlci[dlci->addr] = NULL;\n\tkfifo_free(&dlci->fifo);\n\twhile ((dlci->skb = skb_dequeue(&dlci->skb_list)))\n\t\tdev_kfree_skb(dlci->skb);\n\tkfree(dlci);\n}\n\nstatic inline void dlci_get(struct gsm_dlci *dlci)\n{\n\ttty_port_get(&dlci->port);\n}\n\nstatic inline void dlci_put(struct gsm_dlci *dlci)\n{\n\ttty_port_put(&dlci->port);\n}\n\nstatic void gsm_destroy_network(struct gsm_dlci *dlci);\n\n/**\n *\tgsm_dlci_release\t\t-\trelease DLCI\n *\t@dlci: DLCI to destroy\n *\n *\tRelease a DLCI. Actual free is deferred until either\n *\tmux is closed or tty is closed - whichever is last.\n *\n *\tCan sleep.\n */\nstatic void gsm_dlci_release(struct gsm_dlci *dlci)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(&dlci->port);\n\tif (tty) {\n\t\tmutex_lock(&dlci->mutex);\n\t\tgsm_destroy_network(dlci);\n\t\tmutex_unlock(&dlci->mutex);\n\n\t\t/* We cannot use tty_hangup() because in tty_kref_put() the tty\n\t\t * driver assumes that the hangup queue is free and reuses it to\n\t\t * queue release_one_tty() -> NULL pointer panic in\n\t\t * process_one_work().\n\t\t */\n\t\ttty_vhangup(tty);\n\n\t\ttty_port_tty_set(&dlci->port, NULL);\n\t\ttty_kref_put(tty);\n\t}\n\tdlci->state = DLCI_CLOSED;\n\tdlci_put(dlci);\n}\n\n/*\n *\tLAPBish link layer logic\n */\n\n/**\n *\tgsm_queue\t\t-\ta GSM frame is ready to process\n *\t@gsm: pointer to our gsm mux\n *\n *\tAt this point in time a frame has arrived and been demangled from\n *\tthe line encoding. All the differences between the encodings have\n *\tbeen handled below us and the frame is unpacked into the structures.\n *\tThe fcs holds the header FCS but any data FCS must be added here.\n */\n\nstatic void gsm_queue(struct gsm_mux *gsm)\n{\n\tstruct gsm_dlci *dlci;\n\tu8 cr;\n\tint address;\n\n\tif (gsm->fcs != GOOD_FCS) {\n\t\tgsm->bad_fcs++;\n\t\tif (debug & DBG_DATA)\n\t\t\tpr_debug(\"BAD FCS %02x\\n\", gsm->fcs);\n\t\treturn;\n\t}\n\taddress = gsm->address >> 1;\n\tif (address >= NUM_DLCI)\n\t\tgoto invalid;\n\n\tcr = gsm->address & 1;\t\t/* C/R bit */\n\tcr ^= gsm->initiator ? 0 : 1;\t/* Flip so 1 always means command */\n\n\tgsm_print_packet(\"<--\", address, cr, gsm->control, gsm->buf, gsm->len);\n\n\tdlci = gsm->dlci[address];\n\n\tswitch (gsm->control) {\n\tcase SABM|PF:\n\t\tif (cr == 1)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL)\n\t\t\tdlci = gsm_dlci_alloc(gsm, address);\n\t\tif (dlci == NULL)\n\t\t\treturn;\n\t\tif (dlci->dead)\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\telse {\n\t\t\tgsm_response(gsm, address, UA|PF);\n\t\t\tgsm_dlci_open(dlci);\n\t\t}\n\t\tbreak;\n\tcase DISC|PF:\n\t\tif (cr == 1)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL || dlci->state == DLCI_CLOSED) {\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\t\treturn;\n\t\t}\n\t\t/* Real close complete */\n\t\tgsm_response(gsm, address, UA|PF);\n\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tcase UA|PF:\n\t\tif (cr == 0 || dlci == NULL)\n\t\t\tbreak;\n\t\tswitch (dlci->state) {\n\t\tcase DLCI_CLOSING:\n\t\t\tgsm_dlci_close(dlci);\n\t\t\tbreak;\n\t\tcase DLCI_OPENING:\n\t\t\tgsm_dlci_open(dlci);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__,\n\t\t\t\t\tdlci->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DM:\t/* DM can be valid unsolicited */\n\tcase DM|PF:\n\t\tif (cr)\n\t\t\tgoto invalid;\n\t\tif (dlci == NULL)\n\t\t\treturn;\n\t\tgsm_dlci_close(dlci);\n\t\tbreak;\n\tcase UI:\n\tcase UI|PF:\n\tcase UIH:\n\tcase UIH|PF:\n\t\tif (dlci == NULL || dlci->state != DLCI_OPEN) {\n\t\t\tgsm_response(gsm, address, DM|PF);\n\t\t\treturn;\n\t\t}\n\t\tdlci->data(dlci, gsm->buf, gsm->len);\n\t\tbreak;\n\tdefault:\n\t\tgoto invalid;\n\t}\n\treturn;\ninvalid:\n\tgsm->malformed++;\n\treturn;\n}\n\n\n/**\n *\tgsm0_receive\t-\tperform processing for non-transparency\n *\t@gsm: gsm data for this ldisc instance\n *\t@c: character\n *\n *\tReceive bytes in gsm mode 0\n */\n\nstatic void gsm0_receive(struct gsm_mux *gsm, unsigned char c)\n{\n\tunsigned int len;\n\n\tswitch (gsm->state) {\n\tcase GSM_SEARCH:\t/* SOF marker */\n\t\tif (c == GSM0_SOF) {\n\t\t\tgsm->state = GSM_ADDRESS;\n\t\t\tgsm->address = 0;\n\t\t\tgsm->len = 0;\n\t\t\tgsm->fcs = INIT_FCS;\n\t\t}\n\t\tbreak;\n\tcase GSM_ADDRESS:\t/* Address EA */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->address, c))\n\t\t\tgsm->state = GSM_CONTROL;\n\t\tbreak;\n\tcase GSM_CONTROL:\t/* Control Byte */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->control = c;\n\t\tgsm->state = GSM_LEN0;\n\t\tbreak;\n\tcase GSM_LEN0:\t\t/* Length EA */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->len, c)) {\n\t\t\tif (gsm->len > gsm->mru) {\n\t\t\t\tgsm->bad_size++;\n\t\t\t\tgsm->state = GSM_SEARCH;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgsm->count = 0;\n\t\t\tif (!gsm->len)\n\t\t\t\tgsm->state = GSM_FCS;\n\t\t\telse\n\t\t\t\tgsm->state = GSM_DATA;\n\t\t\tbreak;\n\t\t}\n\t\tgsm->state = GSM_LEN1;\n\t\tbreak;\n\tcase GSM_LEN1:\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tlen = c;\n\t\tgsm->len |= len << 7;\n\t\tif (gsm->len > gsm->mru) {\n\t\t\tgsm->bad_size++;\n\t\t\tgsm->state = GSM_SEARCH;\n\t\t\tbreak;\n\t\t}\n\t\tgsm->count = 0;\n\t\tif (!gsm->len)\n\t\t\tgsm->state = GSM_FCS;\n\t\telse\n\t\t\tgsm->state = GSM_DATA;\n\t\tbreak;\n\tcase GSM_DATA:\t\t/* Data */\n\t\tgsm->buf[gsm->count++] = c;\n\t\tif (gsm->count == gsm->len) {\n\t\t\t/* Calculate final FCS for UI frames over all data */\n\t\t\tif ((gsm->control & ~PF) != UIH) {\n\t\t\t\tgsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf,\n\t\t\t\t\t\t\t     gsm->count);\n\t\t\t}\n\t\t\tgsm->state = GSM_FCS;\n\t\t}\n\t\tbreak;\n\tcase GSM_FCS:\t\t/* FCS follows the packet */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->state = GSM_SSOF;\n\t\tbreak;\n\tcase GSM_SSOF:\n\t\tgsm->state = GSM_SEARCH;\n\t\tif (c == GSM0_SOF)\n\t\t\tgsm_queue(gsm);\n\t\telse\n\t\t\tgsm->bad_size++;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, gsm->state);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm1_receive\t-\tperform processing for non-transparency\n *\t@gsm: gsm data for this ldisc instance\n *\t@c: character\n *\n *\tReceive bytes in mode 1 (Advanced option)\n */\n\nstatic void gsm1_receive(struct gsm_mux *gsm, unsigned char c)\n{\n\t/* handle XON/XOFF */\n\tif ((c & ISO_IEC_646_MASK) == XON) {\n\t\tgsm->constipated = true;\n\t\treturn;\n\t} else if ((c & ISO_IEC_646_MASK) == XOFF) {\n\t\tgsm->constipated = false;\n\t\t/* Kick the link in case it is idling */\n\t\tgsmld_write_trigger(gsm);\n\t\treturn;\n\t}\n\tif (c == GSM1_SOF) {\n\t\t/* EOF is only valid in frame if we have got to the data state */\n\t\tif (gsm->state == GSM_DATA) {\n\t\t\tif (gsm->count < 1) {\n\t\t\t\t/* Missing FSC */\n\t\t\t\tgsm->malformed++;\n\t\t\t\tgsm->state = GSM_START;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Remove the FCS from data */\n\t\t\tgsm->count--;\n\t\t\tif ((gsm->control & ~PF) != UIH) {\n\t\t\t\t/* Calculate final FCS for UI frames over all\n\t\t\t\t * data but FCS\n\t\t\t\t */\n\t\t\t\tgsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf,\n\t\t\t\t\t\t\t     gsm->count);\n\t\t\t}\n\t\t\t/* Add the FCS itself to test against GOOD_FCS */\n\t\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, gsm->buf[gsm->count]);\n\t\t\tgsm->len = gsm->count;\n\t\t\tgsm_queue(gsm);\n\t\t\tgsm->state  = GSM_START;\n\t\t\treturn;\n\t\t}\n\t\t/* Any partial frame was a runt so go back to start */\n\t\tif (gsm->state != GSM_START) {\n\t\t\tif (gsm->state != GSM_SEARCH)\n\t\t\t\tgsm->malformed++;\n\t\t\tgsm->state = GSM_START;\n\t\t}\n\t\t/* A SOF in GSM_START means we are still reading idling or\n\t\t   framing bytes */\n\t\treturn;\n\t}\n\n\tif (c == GSM1_ESCAPE) {\n\t\tgsm->escape = true;\n\t\treturn;\n\t}\n\n\t/* Only an unescaped SOF gets us out of GSM search */\n\tif (gsm->state == GSM_SEARCH)\n\t\treturn;\n\n\tif (gsm->escape) {\n\t\tc ^= GSM1_ESCAPE_BITS;\n\t\tgsm->escape = false;\n\t}\n\tswitch (gsm->state) {\n\tcase GSM_START:\t\t/* First byte after SOF */\n\t\tgsm->address = 0;\n\t\tgsm->state = GSM_ADDRESS;\n\t\tgsm->fcs = INIT_FCS;\n\t\tfallthrough;\n\tcase GSM_ADDRESS:\t/* Address continuation */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tif (gsm_read_ea(&gsm->address, c))\n\t\t\tgsm->state = GSM_CONTROL;\n\t\tbreak;\n\tcase GSM_CONTROL:\t/* Control Byte */\n\t\tgsm->fcs = gsm_fcs_add(gsm->fcs, c);\n\t\tgsm->control = c;\n\t\tgsm->count = 0;\n\t\tgsm->state = GSM_DATA;\n\t\tbreak;\n\tcase GSM_DATA:\t\t/* Data */\n\t\tif (gsm->count > gsm->mru) {\t/* Allow one for the FCS */\n\t\t\tgsm->state = GSM_OVERRUN;\n\t\t\tgsm->bad_size++;\n\t\t} else\n\t\t\tgsm->buf[gsm->count++] = c;\n\t\tbreak;\n\tcase GSM_OVERRUN:\t/* Over-long - eg a dropped SOF */\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unhandled state: %d\\n\", __func__, gsm->state);\n\t\tbreak;\n\t}\n}\n\n/**\n *\tgsm_error\t\t-\thandle tty error\n *\t@gsm: ldisc data\n *\n *\tHandle an error in the receipt of data for a frame. Currently we just\n *\tgo back to hunting for a SOF.\n *\n *\tFIXME: better diagnostics ?\n */\n\nstatic void gsm_error(struct gsm_mux *gsm)\n{\n\tgsm->state = GSM_SEARCH;\n\tgsm->io_error++;\n}\n\n/**\n *\tgsm_cleanup_mux\t\t-\tgeneric GSM protocol cleanup\n *\t@gsm: our mux\n *\t@disc: disconnect link?\n *\n *\tClean up the bits of the mux which are the same for all framing\n *\tprotocols. Remove the mux from the mux table, stop all the timers\n *\tand then shut down each device hanging up the channels as we go.\n */\n\nstatic void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci;\n\tstruct gsm_msg *txq, *ntxq;\n\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\n\tdlci = gsm->dlci[0];\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\n\t/* Finish outstanding timers, making sure they are done */\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\n\t/* Finish writing to ldisc */\n\tflush_work(&gsm->tx_work);\n\n\t/* Free up any link layer users and finally the control channel */\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\t/* Now wipe the queues */\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}\n\n/**\n *\tgsm_activate_mux\t-\tgeneric GSM setup\n *\t@gsm: our mux\n *\n *\tSet up the bits of the mux which are the same for all framing\n *\tprotocols. Add the mux to the mux table so it can be opened and\n *\tfinally kick off connecting to DLCI 0 on the modem.\n */\n\nstatic int gsm_activate_mux(struct gsm_mux *gsm)\n{\n\tstruct gsm_dlci *dlci;\n\tint ret;\n\n\tdlci = gsm_dlci_alloc(gsm, 0);\n\tif (dlci == NULL)\n\t\treturn -ENOMEM;\n\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\tgsm->receive = gsm0_receive;\n\telse\n\t\tgsm->receive = gsm1_receive;\n\n\tret = gsm_register_devices(gsm_tty_driver, gsm->num);\n\tif (ret)\n\t\treturn ret;\n\n\tgsm->has_devices = true;\n\tgsm->dead = false;\t\t/* Tty opens are now permissible */\n\treturn 0;\n}\n\n/**\n *\tgsm_free_mux\t\t-\tfree up a mux\n *\t@gsm: mux to free\n *\n *\tDispose of allocated resources for a dead mux\n */\nstatic void gsm_free_mux(struct gsm_mux *gsm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_MUX; i++) {\n\t\tif (gsm == gsm_mux[i]) {\n\t\t\tgsm_mux[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_destroy(&gsm->mutex);\n\tkfree(gsm->txframe);\n\tkfree(gsm->buf);\n\tkfree(gsm);\n}\n\n/**\n *\tgsm_free_muxr\t\t-\tfree up a mux\n *\t@ref: kreference to the mux to free\n *\n *\tDispose of allocated resources for a dead mux\n */\nstatic void gsm_free_muxr(struct kref *ref)\n{\n\tstruct gsm_mux *gsm = container_of(ref, struct gsm_mux, ref);\n\tgsm_free_mux(gsm);\n}\n\nstatic inline void mux_get(struct gsm_mux *gsm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm_mux_lock, flags);\n\tkref_get(&gsm->ref);\n\tspin_unlock_irqrestore(&gsm_mux_lock, flags);\n}\n\nstatic inline void mux_put(struct gsm_mux *gsm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsm_mux_lock, flags);\n\tkref_put(&gsm->ref, gsm_free_muxr);\n\tspin_unlock_irqrestore(&gsm_mux_lock, flags);\n}\n\nstatic inline unsigned int mux_num_to_base(struct gsm_mux *gsm)\n{\n\treturn gsm->num * NUM_DLCI;\n}\n\nstatic inline unsigned int mux_line_to_num(unsigned int line)\n{\n\treturn line / NUM_DLCI;\n}\n\n/**\n *\tgsm_alloc_mux\t\t-\tallocate a mux\n *\n *\tCreates a new mux ready for activation.\n */\n\nstatic struct gsm_mux *gsm_alloc_mux(void)\n{\n\tint i;\n\tstruct gsm_mux *gsm = kzalloc(sizeof(struct gsm_mux), GFP_KERNEL);\n\tif (gsm == NULL)\n\t\treturn NULL;\n\tgsm->buf = kmalloc(MAX_MRU + 1, GFP_KERNEL);\n\tif (gsm->buf == NULL) {\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\tgsm->txframe = kmalloc(2 * (MAX_MTU + PROT_OVERHEAD - 1), GFP_KERNEL);\n\tif (gsm->txframe == NULL) {\n\t\tkfree(gsm->buf);\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&gsm->lock);\n\tmutex_init(&gsm->mutex);\n\tkref_init(&gsm->ref);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n\ttimer_setup(&gsm->kick_timer, gsm_kick_timer, 0);\n\ttimer_setup(&gsm->t2_timer, gsm_control_retransmit, 0);\n\ttimer_setup(&gsm->ka_timer, gsm_control_keep_alive, 0);\n\tINIT_WORK(&gsm->tx_work, gsmld_write_task);\n\tinit_waitqueue_head(&gsm->event);\n\tspin_lock_init(&gsm->control_lock);\n\tspin_lock_init(&gsm->tx_lock);\n\n\tgsm->t1 = T1;\n\tgsm->t2 = T2;\n\tgsm->t3 = T3;\n\tgsm->n2 = N2;\n\tgsm->k = K;\n\tgsm->ftype = UIH;\n\tgsm->adaption = 1;\n\tgsm->encoding = GSM_ADV_OPT;\n\tgsm->mru = 64;\t/* Default to encoding 1 so these should be 64 */\n\tgsm->mtu = 64;\n\tgsm->dead = true;\t/* Avoid early tty opens */\n\tgsm->wait_config = false; /* Disabled */\n\tgsm->keep_alive = 0;\t/* Disabled */\n\n\t/* Store the instance to the mux array or abort if no space is\n\t * available.\n\t */\n\tspin_lock(&gsm_mux_lock);\n\tfor (i = 0; i < MAX_MUX; i++) {\n\t\tif (!gsm_mux[i]) {\n\t\t\tgsm_mux[i] = gsm;\n\t\t\tgsm->num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&gsm_mux_lock);\n\tif (i == MAX_MUX) {\n\t\tmutex_destroy(&gsm->mutex);\n\t\tkfree(gsm->txframe);\n\t\tkfree(gsm->buf);\n\t\tkfree(gsm);\n\t\treturn NULL;\n\t}\n\n\treturn gsm;\n}\n\nstatic void gsm_copy_config_values(struct gsm_mux *gsm,\n\t\t\t\t   struct gsm_config *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->adaption = gsm->adaption;\n\tc->encapsulation = gsm->encoding;\n\tc->initiator = gsm->initiator;\n\tc->t1 = gsm->t1;\n\tc->t2 = gsm->t2;\n\tc->t3 = gsm->t3;\n\tc->n2 = gsm->n2;\n\tif (gsm->ftype == UIH)\n\t\tc->i = 1;\n\telse\n\t\tc->i = 2;\n\tpr_debug(\"Ftype %d i %d\\n\", gsm->ftype, c->i);\n\tc->mru = gsm->mru;\n\tc->mtu = gsm->mtu;\n\tc->k = gsm->k;\n}\n\nstatic int gsm_config(struct gsm_mux *gsm, struct gsm_config *c)\n{\n\tint ret = 0;\n\tint need_close = 0;\n\tint need_restart = 0;\n\n\t/* Stuff we don't support yet - UI or I frame transport */\n\tif (c->adaption != 1 && c->adaption != 2)\n\t\treturn -EOPNOTSUPP;\n\t/* Check the MRU/MTU range looks sane */\n\tif (c->mru < MIN_MTU || c->mtu < MIN_MTU)\n\t\treturn -EINVAL;\n\tif (c->mru > MAX_MRU || c->mtu > MAX_MTU)\n\t\treturn -EINVAL;\n\tif (c->t3 > MAX_T3)\n\t\treturn -EINVAL;\n\tif (c->n2 > 255)\n\t\treturn -EINVAL;\n\tif (c->encapsulation > 1)\t/* Basic, advanced, no I */\n\t\treturn -EINVAL;\n\tif (c->initiator > 1)\n\t\treturn -EINVAL;\n\tif (c->k > MAX_WINDOW_SIZE)\n\t\treturn -EINVAL;\n\tif (c->i == 0 || c->i > 2)\t/* UIH and UI only */\n\t\treturn -EINVAL;\n\t/*\n\t * See what is needed for reconfiguration\n\t */\n\n\t/* Timing fields */\n\tif (c->t1 != 0 && c->t1 != gsm->t1)\n\t\tneed_restart = 1;\n\tif (c->t2 != 0 && c->t2 != gsm->t2)\n\t\tneed_restart = 1;\n\tif (c->encapsulation != gsm->encoding)\n\t\tneed_restart = 1;\n\tif (c->adaption != gsm->adaption)\n\t\tneed_restart = 1;\n\t/* Requires care */\n\tif (c->initiator != gsm->initiator)\n\t\tneed_close = 1;\n\tif (c->mru != gsm->mru)\n\t\tneed_restart = 1;\n\tif (c->mtu != gsm->mtu)\n\t\tneed_restart = 1;\n\n\t/*\n\t * Close down what is needed, restart and initiate the new\n\t * configuration. On the first time there is no DLCI[0]\n\t * and closing or cleaning up is not necessary.\n\t */\n\tif (need_close || need_restart)\n\t\tgsm_cleanup_mux(gsm, true);\n\n\tgsm->initiator = c->initiator;\n\tgsm->mru = c->mru;\n\tgsm->mtu = c->mtu;\n\tgsm->encoding = c->encapsulation ? GSM_ADV_OPT : GSM_BASIC_OPT;\n\tgsm->adaption = c->adaption;\n\tgsm->n2 = c->n2;\n\n\tif (c->i == 1)\n\t\tgsm->ftype = UIH;\n\telse if (c->i == 2)\n\t\tgsm->ftype = UI;\n\n\tif (c->t1)\n\t\tgsm->t1 = c->t1;\n\tif (c->t2)\n\t\tgsm->t2 = c->t2;\n\tif (c->t3)\n\t\tgsm->t3 = c->t3;\n\tif (c->k)\n\t\tgsm->k = c->k;\n\n\t/*\n\t * FIXME: We need to separate activation/deactivation from adding\n\t * and removing from the mux array\n\t */\n\tif (gsm->dead) {\n\t\tret = gsm_activate_mux(gsm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gsm->initiator)\n\t\t\tgsm_dlci_begin_open(gsm->dlci[0]);\n\t}\n\treturn 0;\n}\n\nstatic void gsm_copy_config_ext_values(struct gsm_mux *gsm,\n\t\t\t\t       struct gsm_config_ext *ce)\n{\n\tmemset(ce, 0, sizeof(*ce));\n\tce->wait_config = gsm->wait_config ? 1 : 0;\n\tce->keep_alive = gsm->keep_alive;\n}\n\nstatic int gsm_config_ext(struct gsm_mux *gsm, struct gsm_config_ext *ce)\n{\n\tunsigned int i;\n\n\t/*\n\t * Check that userspace doesn't put stuff in here to prevent breakages\n\t * in the future.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(ce->reserved); i++)\n\t\tif (ce->reserved[i])\n\t\t\treturn -EINVAL;\n\n\t/*\n\t * Setup the new configuration values\n\t */\n\tgsm->wait_config = ce->wait_config ? true : false;\n\tgsm->keep_alive = ce->keep_alive;\n\n\treturn 0;\n}\n\n/**\n *\tgsmld_output\t\t-\twrite to link\n *\t@gsm: our mux\n *\t@data: bytes to output\n *\t@len: size\n *\n *\tWrite a block of data from the GSM mux to the data channel. This\n *\twill eventually be serialized from above but at the moment isn't.\n */\n\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len)\n{\n\tif (tty_write_room(gsm->tty) < len) {\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\n\t\treturn -ENOSPC;\n\t}\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, data, len);\n\treturn gsm->tty->ops->write(gsm->tty, data, len);\n}\n\n\n/**\n *\tgsmld_write_trigger\t-\tschedule ldisc write task\n *\t@gsm: our mux\n */\nstatic void gsmld_write_trigger(struct gsm_mux *gsm)\n{\n\tif (!gsm || !gsm->dlci[0] || gsm->dlci[0]->dead)\n\t\treturn;\n\tschedule_work(&gsm->tx_work);\n}\n\n\n/**\n *\tgsmld_write_task\t-\tldisc write task\n *\t@work: our tx write work\n *\n *\tWrites out data to the ldisc if possible. We are doing this here to\n *\tavoid dead-locking. This returns if no space or data is left for output.\n */\nstatic void gsmld_write_task(struct work_struct *work)\n{\n\tstruct gsm_mux *gsm = container_of(work, struct gsm_mux, tx_work);\n\tunsigned long flags;\n\tint i, ret;\n\n\t/* All outstanding control channel and control messages and one data\n\t * frame is sent.\n\t */\n\tret = -ENODEV;\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tif (gsm->tty)\n\t\tret = gsm_data_kick(gsm);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\tif (ret >= 0)\n\t\tfor (i = 0; i < NUM_DLCI; i++)\n\t\t\tif (gsm->dlci[i])\n\t\t\t\ttty_port_tty_wakeup(&gsm->dlci[i]->port);\n}\n\n/**\n *\tgsmld_attach_gsm\t-\tmode set up\n *\t@tty: our tty structure\n *\t@gsm: our mux\n *\n *\tSet up the MUX for basic mode and commence connecting to the\n *\tmodem. Currently called from the line discipline set up but\n *\twill need moving to an ioctl path.\n */\n\nstatic void gsmld_attach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\n{\n\tgsm->tty = tty_kref_get(tty);\n\t/* Turn off tty XON/XOFF handling to handle it explicitly. */\n\tgsm->old_c_iflag = tty->termios.c_iflag;\n\ttty->termios.c_iflag &= (IXON | IXOFF);\n}\n\n/**\n *\tgsmld_detach_gsm\t-\tstop doing 0710 mux\n *\t@tty: tty attached to the mux\n *\t@gsm: mux\n *\n *\tShutdown and then clean up the resources used by the line discipline\n */\n\nstatic void gsmld_detach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\n{\n\tWARN_ON(tty != gsm->tty);\n\t/* Restore tty XON/XOFF handling. */\n\tgsm->tty->termios.c_iflag = gsm->old_c_iflag;\n\ttty_kref_put(gsm->tty);\n\tgsm->tty = NULL;\n}\n\nstatic void gsmld_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      const char *fp, int count)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tchar flags = TTY_NORMAL;\n\n\tif (debug & DBG_DATA)\n\t\tgsm_hex_dump_bytes(__func__, cp, count);\n\n\tfor (; count; count--, cp++) {\n\t\tif (fp)\n\t\t\tflags = *fp++;\n\t\tswitch (flags) {\n\t\tcase TTY_NORMAL:\n\t\t\tif (gsm->receive)\n\t\t\t\tgsm->receive(gsm, *cp);\n\t\t\tbreak;\n\t\tcase TTY_OVERRUN:\n\t\tcase TTY_BREAK:\n\t\tcase TTY_PARITY:\n\t\tcase TTY_FRAME:\n\t\t\tgsm_error(gsm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"%s: unknown flag %d\\n\",\n\t\t\t       tty_name(tty), flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* FASYNC if needed ? */\n\t/* If clogged call tty_throttle(tty); */\n}\n\n/**\n *\tgsmld_flush_buffer\t-\tclean input queue\n *\t@tty:\tterminal device\n *\n *\tFlush the input buffer. Called when the line discipline is\n *\tbeing closed, when the tty layer wants the buffer flushed (eg\n *\tat hangup).\n */\n\nstatic void gsmld_flush_buffer(struct tty_struct *tty)\n{\n}\n\n/**\n *\tgsmld_close\t\t-\tclose the ldisc for this tty\n *\t@tty: device\n *\n *\tCalled from the terminal layer when this line discipline is\n *\tbeing shut down, either because of a close or becsuse of a\n *\tdiscipline change. The function will not be called while other\n *\tldisc methods are in progress.\n */\n\nstatic void gsmld_close(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\t/* The ldisc locks and closes the port before calling our close. This\n\t * means we have no way to do a proper disconnect. We will not bother\n\t * to do one.\n\t */\n\tgsm_cleanup_mux(gsm, false);\n\n\tgsmld_detach_gsm(tty, gsm);\n\n\tgsmld_flush_buffer(tty);\n\t/* Do other clean up here */\n\tmux_put(gsm);\n}\n\n/**\n *\tgsmld_open\t\t-\topen an ldisc\n *\t@tty: terminal to open\n *\n *\tCalled when this line discipline is being attached to the\n *\tterminal device. Can sleep. Called serialized so that no\n *\tother events will occur in parallel. No further open will occur\n *\tuntil a close.\n */\n\nstatic int gsmld_open(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EINVAL;\n\n\t/* Attach our ldisc data */\n\tgsm = gsm_alloc_mux();\n\tif (gsm == NULL)\n\t\treturn -ENOMEM;\n\n\ttty->disc_data = gsm;\n\ttty->receive_room = 65536;\n\n\t/* Attach the initial passive connection */\n\tgsmld_attach_gsm(tty, gsm);\n\n\t/* The mux will not be activated yet, we wait for correct\n\t * configuration first.\n\t */\n\tif (gsm->encoding == GSM_BASIC_OPT)\n\t\tgsm->receive = gsm0_receive;\n\telse\n\t\tgsm->receive = gsm1_receive;\n\n\treturn 0;\n}\n\n/**\n *\tgsmld_write_wakeup\t-\tasynchronous I/O notifier\n *\t@tty: tty device\n *\n *\tRequired for the ptys, serial driver etc. since processes\n *\tthat attach themselves to the master and rely on ASYNC\n *\tIO must be woken up\n */\n\nstatic void gsmld_write_wakeup(struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\t/* Queue poll */\n\tgsmld_write_trigger(gsm);\n}\n\n/**\n *\tgsmld_read\t\t-\tread function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\t@cookie: unused\n *\t@offset: unused\n *\n *\tPerform reads for the line discipline. We are guaranteed that the\n *\tline discipline will not be closed under us but we may get multiple\n *\tparallel readers and must handle this ourselves. We may also get\n *\ta hangup. Always called in user context, may sleep.\n *\n *\tThis code must be sure never to sleep through a hangup.\n */\n\nstatic ssize_t gsmld_read(struct tty_struct *tty, struct file *file,\n\t\t\t  unsigned char *buf, size_t nr,\n\t\t\t  void **cookie, unsigned long offset)\n{\n\treturn -EOPNOTSUPP;\n}\n\n/**\n *\tgsmld_write\t\t-\twrite function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tCalled when the owner of the device wants to send a frame\n *\titself (or some other control data). The data is transferred\n *\tas-is and must be properly framed and checksummed as appropriate\n *\tby userspace. Frames are either sent whole or not at all as this\n *\tavoids pain user side.\n */\n\nstatic ssize_t gsmld_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tunsigned long flags;\n\tint space;\n\tint ret;\n\n\tif (!gsm)\n\t\treturn -ENODEV;\n\n\tret = -ENOBUFS;\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tspace = tty_write_room(tty);\n\tif (space >= nr)\n\t\tret = tty->ops->write(tty, buf, nr);\n\telse\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n\n\treturn ret;\n}\n\n/**\n *\tgsmld_poll\t\t-\tpoll method for N_GSM0710\n *\t@tty: terminal device\n *\t@file: file accessing it\n *\t@wait: poll table\n *\n *\tCalled when the line discipline is asked to poll() for data or\n *\tfor special events. This code is not serialized with respect to\n *\tother events save open/close.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\tCalled without the kernel lock held - fine\n */\n\nstatic __poll_t gsmld_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct gsm_mux *gsm = tty->disc_data;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\n\tif (gsm->dead)\n\t\tmask |= EPOLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= EPOLLHUP;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= EPOLLHUP;\n\tif (!tty_is_writelocked(tty) && tty_write_room(tty) > 0)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\nstatic int gsmld_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tstruct gsm_config c;\n\tstruct gsm_config_ext ce;\n\tstruct gsm_dlci_config dc;\n\tstruct gsm_mux *gsm = tty->disc_data;\n\tunsigned int base, addr;\n\tstruct gsm_dlci *dlci;\n\n\tswitch (cmd) {\n\tcase GSMIOC_GETCONF:\n\t\tgsm_copy_config_values(gsm, &c);\n\t\tif (copy_to_user((void __user *)arg, &c, sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF:\n\t\tif (copy_from_user(&c, (void __user *)arg, sizeof(c)))\n\t\t\treturn -EFAULT;\n\t\treturn gsm_config(gsm, &c);\n\tcase GSMIOC_GETFIRST:\n\t\tbase = mux_num_to_base(gsm);\n\t\treturn put_user(base + 1, (__u32 __user *)arg);\n\tcase GSMIOC_GETCONF_EXT:\n\t\tgsm_copy_config_ext_values(gsm, &ce);\n\t\tif (copy_to_user((void __user *)arg, &ce, sizeof(ce)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_EXT:\n\t\tif (copy_from_user(&ce, (void __user *)arg, sizeof(ce)))\n\t\t\treturn -EFAULT;\n\t\treturn gsm_config_ext(gsm, &ce);\n\tcase GSMIOC_GETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel == 0 || dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\taddr = array_index_nospec(dc.channel, NUM_DLCI);\n\t\tdlci = gsm->dlci[addr];\n\t\tif (!dlci) {\n\t\t\tdlci = gsm_dlci_alloc(gsm, addr);\n\t\t\tif (!dlci)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tgsm_dlci_copy_config_values(dlci, &dc);\n\t\tif (copy_to_user((void __user *)arg, &dc, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel == 0 || dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\taddr = array_index_nospec(dc.channel, NUM_DLCI);\n\t\tdlci = gsm->dlci[addr];\n\t\tif (!dlci) {\n\t\t\tdlci = gsm_dlci_alloc(gsm, addr);\n\t\t\tif (!dlci)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn gsm_dlci_config(dlci, &dc, 0);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, cmd, arg);\n\t}\n}\n\n/*\n *\tNetwork interface\n *\n */\n\nstatic int gsm_mux_net_open(struct net_device *net)\n{\n\tpr_debug(\"%s called\\n\", __func__);\n\tnetif_start_queue(net);\n\treturn 0;\n}\n\nstatic int gsm_mux_net_close(struct net_device *net)\n{\n\tnetif_stop_queue(net);\n\treturn 0;\n}\n\nstatic void dlci_net_free(struct gsm_dlci *dlci)\n{\n\tif (!dlci->net) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tdlci->adaption = dlci->prev_adaption;\n\tdlci->data = dlci->prev_data;\n\tfree_netdev(dlci->net);\n\tdlci->net = NULL;\n}\nstatic void net_free(struct kref *ref)\n{\n\tstruct gsm_mux_net *mux_net;\n\tstruct gsm_dlci *dlci;\n\n\tmux_net = container_of(ref, struct gsm_mux_net, ref);\n\tdlci = mux_net->dlci;\n\n\tif (dlci->net) {\n\t\tunregister_netdev(dlci->net);\n\t\tdlci_net_free(dlci);\n\t}\n}\n\nstatic inline void muxnet_get(struct gsm_mux_net *mux_net)\n{\n\tkref_get(&mux_net->ref);\n}\n\nstatic inline void muxnet_put(struct gsm_mux_net *mux_net)\n{\n\tkref_put(&mux_net->ref, net_free);\n}\n\nstatic netdev_tx_t gsm_mux_net_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *net)\n{\n\tstruct gsm_mux_net *mux_net = netdev_priv(net);\n\tstruct gsm_dlci *dlci = mux_net->dlci;\n\tmuxnet_get(mux_net);\n\n\tskb_queue_head(&dlci->skb_list, skb);\n\tnet->stats.tx_packets++;\n\tnet->stats.tx_bytes += skb->len;\n\tgsm_dlci_data_kick(dlci);\n\t/* And tell the kernel when the last transmit started. */\n\tnetif_trans_update(net);\n\tmuxnet_put(mux_net);\n\treturn NETDEV_TX_OK;\n}\n\n/* called when a packet did not ack after watchdogtimeout */\nstatic void gsm_mux_net_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\t/* Tell syslog we are hosed. */\n\tdev_dbg(&net->dev, \"Tx timed out.\\n\");\n\n\t/* Update statistics */\n\tnet->stats.tx_errors++;\n}\n\nstatic void gsm_mux_rx_netchar(struct gsm_dlci *dlci,\n\t\t\t\tconst unsigned char *in_buf, int size)\n{\n\tstruct net_device *net = dlci->net;\n\tstruct sk_buff *skb;\n\tstruct gsm_mux_net *mux_net = netdev_priv(net);\n\tmuxnet_get(mux_net);\n\n\t/* Allocate an sk_buff */\n\tskb = dev_alloc_skb(size + NET_IP_ALIGN);\n\tif (!skb) {\n\t\t/* We got no receive buffer. */\n\t\tnet->stats.rx_dropped++;\n\t\tmuxnet_put(mux_net);\n\t\treturn;\n\t}\n\tskb_reserve(skb, NET_IP_ALIGN);\n\tskb_put_data(skb, in_buf, size);\n\n\tskb->dev = net;\n\tskb->protocol = htons(ETH_P_IP);\n\n\t/* Ship it off to the kernel */\n\tnetif_rx(skb);\n\n\t/* update out statistics */\n\tnet->stats.rx_packets++;\n\tnet->stats.rx_bytes += size;\n\tmuxnet_put(mux_net);\n\treturn;\n}\n\nstatic void gsm_mux_net_init(struct net_device *net)\n{\n\tstatic const struct net_device_ops gsm_netdev_ops = {\n\t\t.ndo_open\t\t= gsm_mux_net_open,\n\t\t.ndo_stop\t\t= gsm_mux_net_close,\n\t\t.ndo_start_xmit\t\t= gsm_mux_net_start_xmit,\n\t\t.ndo_tx_timeout\t\t= gsm_mux_net_tx_timeout,\n\t};\n\n\tnet->netdev_ops = &gsm_netdev_ops;\n\n\t/* fill in the other fields */\n\tnet->watchdog_timeo = GSM_NET_TX_TIMEOUT;\n\tnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tnet->type = ARPHRD_NONE;\n\tnet->tx_queue_len = 10;\n}\n\n\n/* caller holds the dlci mutex */\nstatic void gsm_destroy_network(struct gsm_dlci *dlci)\n{\n\tstruct gsm_mux_net *mux_net;\n\n\tpr_debug(\"destroy network interface\\n\");\n\tif (!dlci->net)\n\t\treturn;\n\tmux_net = netdev_priv(dlci->net);\n\tmuxnet_put(mux_net);\n}\n\n\n/* caller holds the dlci mutex */\nstatic int gsm_create_network(struct gsm_dlci *dlci, struct gsm_netconfig *nc)\n{\n\tchar *netname;\n\tint retval = 0;\n\tstruct net_device *net;\n\tstruct gsm_mux_net *mux_net;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Already in a non tty mode */\n\tif (dlci->adaption > 2)\n\t\treturn -EBUSY;\n\n\tif (nc->protocol != htons(ETH_P_IP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (nc->adaption != 3 && nc->adaption != 4)\n\t\treturn -EPROTONOSUPPORT;\n\n\tpr_debug(\"create network interface\\n\");\n\n\tnetname = \"gsm%d\";\n\tif (nc->if_name[0] != '\\0')\n\t\tnetname = nc->if_name;\n\tnet = alloc_netdev(sizeof(struct gsm_mux_net), netname,\n\t\t\t   NET_NAME_UNKNOWN, gsm_mux_net_init);\n\tif (!net) {\n\t\tpr_err(\"alloc_netdev failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tnet->mtu = dlci->mtu;\n\tnet->min_mtu = MIN_MTU;\n\tnet->max_mtu = dlci->mtu;\n\tmux_net = netdev_priv(net);\n\tmux_net->dlci = dlci;\n\tkref_init(&mux_net->ref);\n\tstrncpy(nc->if_name, net->name, IFNAMSIZ); /* return net name */\n\n\t/* reconfigure dlci for network */\n\tdlci->prev_adaption = dlci->adaption;\n\tdlci->prev_data = dlci->data;\n\tdlci->adaption = nc->adaption;\n\tdlci->data = gsm_mux_rx_netchar;\n\tdlci->net = net;\n\n\tpr_debug(\"register netdev\\n\");\n\tretval = register_netdev(net);\n\tif (retval) {\n\t\tpr_err(\"network register fail %d\\n\", retval);\n\t\tdlci_net_free(dlci);\n\t\treturn retval;\n\t}\n\treturn net->ifindex;\t/* return network index */\n}\n\n/* Line discipline for real tty */\nstatic struct tty_ldisc_ops tty_ldisc_packet = {\n\t.owner\t\t = THIS_MODULE,\n\t.num\t\t = N_GSM0710,\n\t.name            = \"n_gsm\",\n\t.open            = gsmld_open,\n\t.close           = gsmld_close,\n\t.flush_buffer    = gsmld_flush_buffer,\n\t.read            = gsmld_read,\n\t.write           = gsmld_write,\n\t.ioctl           = gsmld_ioctl,\n\t.poll            = gsmld_poll,\n\t.receive_buf     = gsmld_receive_buf,\n\t.write_wakeup    = gsmld_write_wakeup\n};\n\n/*\n *\tVirtual tty side\n */\n\n/**\n *\tgsm_modem_upd_via_data\t-\tsend modem bits via convergence layer\n *\t@dlci: channel\n *\t@brk: break signal\n *\n *\tSend an empty frame to signal mobile state changes and to transmit the\n *\tbreak signal for adaption 2.\n */\n\nstatic void gsm_modem_upd_via_data(struct gsm_dlci *dlci, u8 brk)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tunsigned long flags;\n\n\tif (dlci->state != DLCI_OPEN || dlci->adaption != 2)\n\t\treturn;\n\n\tspin_lock_irqsave(&gsm->tx_lock, flags);\n\tgsm_dlci_modem_output(gsm, dlci, brk);\n\tspin_unlock_irqrestore(&gsm->tx_lock, flags);\n}\n\n/**\n *\tgsm_modem_upd_via_msc\t-\tsend modem bits via control frame\n *\t@dlci: channel\n *\t@brk: break signal\n */\n\nstatic int gsm_modem_upd_via_msc(struct gsm_dlci *dlci, u8 brk)\n{\n\tu8 modembits[3];\n\tstruct gsm_control *ctrl;\n\tint len = 2;\n\n\tif (dlci->gsm->encoding != GSM_BASIC_OPT)\n\t\treturn 0;\n\n\tmodembits[0] = (dlci->addr << 2) | 2 | EA;  /* DLCI, Valid, EA */\n\tif (!brk) {\n\t\tmodembits[1] = (gsm_encode_modem(dlci) << 1) | EA;\n\t} else {\n\t\tmodembits[1] = gsm_encode_modem(dlci) << 1;\n\t\tmodembits[2] = (brk << 4) | 2 | EA; /* Length, Break, EA */\n\t\tlen++;\n\t}\n\tctrl = gsm_control_send(dlci->gsm, CMD_MSC, modembits, len);\n\tif (ctrl == NULL)\n\t\treturn -ENOMEM;\n\treturn gsm_control_wait(dlci->gsm, ctrl);\n}\n\n/**\n *\tgsm_modem_update\t-\tsend modem status line state\n *\t@dlci: channel\n *\t@brk: break signal\n */\n\nstatic int gsm_modem_update(struct gsm_dlci *dlci, u8 brk)\n{\n\tif (dlci->adaption == 2) {\n\t\t/* Send convergence layer type 2 empty data frame. */\n\t\tgsm_modem_upd_via_data(dlci, brk);\n\t\treturn 0;\n\t} else if (dlci->gsm->encoding == GSM_BASIC_OPT) {\n\t\t/* Send as MSC control message. */\n\t\treturn gsm_modem_upd_via_msc(dlci, brk);\n\t}\n\n\t/* Modem status lines are not supported. */\n\treturn -EPROTONOSUPPORT;\n}\n\n/**\n * gsm_wait_modem_change - wait for modem status line change\n * @dlci: channel\n * @mask: modem status line bits\n *\n * The function returns if:\n * - any given modem status line bit changed\n * - the wait event function got interrupted (e.g. by a signal)\n * - the underlying DLCI was closed\n * - the underlying ldisc device was removed\n */\nstatic int gsm_wait_modem_change(struct gsm_dlci *dlci, u32 mask)\n{\n\tstruct gsm_mux *gsm = dlci->gsm;\n\tu32 old = dlci->modem_rx;\n\tint ret;\n\n\tret = wait_event_interruptible(gsm->event, gsm->dead ||\n\t\t\t\t       dlci->state != DLCI_OPEN ||\n\t\t\t\t       (old ^ dlci->modem_rx) & mask);\n\tif (gsm->dead)\n\t\treturn -ENODEV;\n\tif (dlci->state != DLCI_OPEN)\n\t\treturn -EL2NSYNC;\n\treturn ret;\n}\n\nstatic bool gsm_carrier_raised(struct tty_port *port)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\t/* Not yet open so no carrier info */\n\tif (dlci->state != DLCI_OPEN)\n\t\treturn false;\n\tif (debug & DBG_CD_ON)\n\t\treturn true;\n\n\t/*\n\t * Basic mode with control channel in ADM mode may not respond\n\t * to CMD_MSC at all and modem_rx is empty.\n\t */\n\tif (gsm->encoding == GSM_BASIC_OPT &&\n\t    gsm->dlci[0]->mode == DLCI_MODE_ADM && !dlci->modem_rx)\n\t\treturn true;\n\n\treturn dlci->modem_rx & TIOCM_CD;\n}\n\nstatic void gsm_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\n\tunsigned int modem_tx = dlci->modem_tx;\n\tif (active)\n\t\tmodem_tx |= TIOCM_DTR | TIOCM_RTS;\n\telse\n\t\tmodem_tx &= ~(TIOCM_DTR | TIOCM_RTS);\n\tif (modem_tx != dlci->modem_tx) {\n\t\tdlci->modem_tx = modem_tx;\n\t\tgsm_modem_update(dlci, 0);\n\t}\n}\n\nstatic const struct tty_port_operations gsm_port_ops = {\n\t.carrier_raised = gsm_carrier_raised,\n\t.dtr_rts = gsm_dtr_rts,\n\t.destruct = gsm_dlci_free,\n};\n\nstatic int gsmtty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct gsm_mux *gsm;\n\tstruct gsm_dlci *dlci;\n\tunsigned int line = tty->index;\n\tunsigned int mux = mux_line_to_num(line);\n\tbool alloc = false;\n\tint ret;\n\n\tline = line & 0x3F;\n\n\tif (mux >= MAX_MUX)\n\t\treturn -ENXIO;\n\t/* FIXME: we need to lock gsm_mux for lifetimes of ttys eventually */\n\tif (gsm_mux[mux] == NULL)\n\t\treturn -EUNATCH;\n\tif (line == 0 || line > 61)\t/* 62/63 reserved */\n\t\treturn -ECHRNG;\n\tgsm = gsm_mux[mux];\n\tif (gsm->dead)\n\t\treturn -EL2HLT;\n\t/* If DLCI 0 is not yet fully open return an error.\n\tThis is ok from a locking\n\tperspective as we don't have to worry about this\n\tif DLCI0 is lost */\n\tmutex_lock(&gsm->mutex);\n\tif (gsm->dlci[0] && gsm->dlci[0]->state != DLCI_OPEN) {\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn -EL2NSYNC;\n\t}\n\tdlci = gsm->dlci[line];\n\tif (dlci == NULL) {\n\t\talloc = true;\n\t\tdlci = gsm_dlci_alloc(gsm, line);\n\t}\n\tif (dlci == NULL) {\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn -ENOMEM;\n\t}\n\tret = tty_port_install(&dlci->port, driver, tty);\n\tif (ret) {\n\t\tif (alloc)\n\t\t\tdlci_put(dlci);\n\t\tmutex_unlock(&gsm->mutex);\n\t\treturn ret;\n\t}\n\n\tdlci_get(dlci);\n\tdlci_get(gsm->dlci[0]);\n\tmux_get(gsm);\n\ttty->driver_data = dlci;\n\tmutex_unlock(&gsm->mutex);\n\n\treturn 0;\n}\n\nstatic int gsmtty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct tty_port *port = &dlci->port;\n\n\tport->count++;\n\ttty_port_tty_set(port, tty);\n\n\tdlci->modem_rx = 0;\n\t/* We could in theory open and close before we wait - eg if we get\n\t   a DM straight back. This is ok as that will have caused a hangup */\n\ttty_port_set_initialized(port, true);\n\t/* Start sending off SABM messages */\n\tif (!dlci->gsm->wait_config) {\n\t\t/* Start sending off SABM messages */\n\t\tif (dlci->gsm->initiator)\n\t\t\tgsm_dlci_begin_open(dlci);\n\t\telse\n\t\t\tgsm_dlci_set_opening(dlci);\n\t} else {\n\t\tgsm_dlci_set_wait_config(dlci);\n\t}\n\t/* And wait for virtual carrier */\n\treturn tty_port_block_til_ready(port, tty, filp);\n}\n\nstatic void gsmtty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\n\tif (dlci == NULL)\n\t\treturn;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tmutex_lock(&dlci->mutex);\n\tgsm_destroy_network(dlci);\n\tmutex_unlock(&dlci->mutex);\n\tif (tty_port_close_start(&dlci->port, tty, filp) == 0)\n\t\treturn;\n\tgsm_dlci_begin_close(dlci);\n\tif (tty_port_initialized(&dlci->port) && C_HUPCL(tty))\n\t\ttty_port_lower_dtr_rts(&dlci->port);\n\ttty_port_close_end(&dlci->port, tty);\n\ttty_port_tty_set(&dlci->port, NULL);\n\treturn;\n}\n\nstatic void gsmtty_hangup(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\ttty_port_hangup(&dlci->port);\n\tgsm_dlci_begin_close(dlci);\n}\n\nstatic int gsmtty_write(struct tty_struct *tty, const unsigned char *buf,\n\t\t\t\t\t\t\t\t    int len)\n{\n\tint sent;\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\t/* Stuff the bytes into the fifo queue */\n\tsent = kfifo_in_locked(&dlci->fifo, buf, len, &dlci->lock);\n\t/* Need to kick the channel */\n\tgsm_dlci_data_kick(dlci);\n\treturn sent;\n}\n\nstatic unsigned int gsmtty_write_room(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn 0;\n\treturn kfifo_avail(&dlci->fifo);\n}\n\nstatic unsigned int gsmtty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn 0;\n\treturn kfifo_len(&dlci->fifo);\n}\n\nstatic void gsmtty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tunsigned long flags;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\t/* Caution needed: If we implement reliable transport classes\n\t   then the data being transmitted can't simply be junked once\n\t   it has first hit the stack. Until then we can just blow it\n\t   away */\n\tspin_lock_irqsave(&dlci->lock, flags);\n\tkfifo_reset(&dlci->fifo);\n\tspin_unlock_irqrestore(&dlci->lock, flags);\n\t/* Need to unhook this DLCI from the transmit queue logic */\n}\n\nstatic void gsmtty_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\t/* The FIFO handles the queue so the kernel will do the right\n\t   thing waiting on chars_in_buffer before calling us. No work\n\t   to do here */\n}\n\nstatic int gsmtty_tiocmget(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\treturn dlci->modem_rx;\n}\n\nstatic int gsmtty_tiocmset(struct tty_struct *tty,\n\tunsigned int set, unsigned int clear)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tunsigned int modem_tx = dlci->modem_tx;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\tmodem_tx &= ~clear;\n\tmodem_tx |= set;\n\n\tif (modem_tx != dlci->modem_tx) {\n\t\tdlci->modem_tx = modem_tx;\n\t\treturn gsm_modem_update(dlci, 0);\n\t}\n\treturn 0;\n}\n\n\nstatic int gsmtty_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct gsm_netconfig nc;\n\tstruct gsm_dlci_config dc;\n\tint index;\n\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\tswitch (cmd) {\n\tcase GSMIOC_ENABLE_NET:\n\t\tif (copy_from_user(&nc, (void __user *)arg, sizeof(nc)))\n\t\t\treturn -EFAULT;\n\t\tnc.if_name[IFNAMSIZ-1] = '\\0';\n\t\t/* return net interface index or error code */\n\t\tmutex_lock(&dlci->mutex);\n\t\tindex = gsm_create_network(dlci, &nc);\n\t\tmutex_unlock(&dlci->mutex);\n\t\tif (copy_to_user((void __user *)arg, &nc, sizeof(nc)))\n\t\t\treturn -EFAULT;\n\t\treturn index;\n\tcase GSMIOC_DISABLE_NET:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&dlci->mutex);\n\t\tgsm_destroy_network(dlci);\n\t\tmutex_unlock(&dlci->mutex);\n\t\treturn 0;\n\tcase GSMIOC_GETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel != dlci->addr)\n\t\t\treturn -EPERM;\n\t\tgsm_dlci_copy_config_values(dlci, &dc);\n\t\tif (copy_to_user((void __user *)arg, &dc, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase GSMIOC_SETCONF_DLCI:\n\t\tif (copy_from_user(&dc, (void __user *)arg, sizeof(dc)))\n\t\t\treturn -EFAULT;\n\t\tif (dc.channel >= NUM_DLCI)\n\t\t\treturn -EINVAL;\n\t\tif (dc.channel != 0 && dc.channel != dlci->addr)\n\t\t\treturn -EPERM;\n\t\treturn gsm_dlci_config(dlci, &dc, 1);\n\tcase TIOCMIWAIT:\n\t\treturn gsm_wait_modem_change(dlci, (u32)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic void gsmtty_set_termios(struct tty_struct *tty,\n\t\t\t       const struct ktermios *old)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\t/* For the moment its fixed. In actual fact the speed information\n\t   for the virtual channel can be propogated in both directions by\n\t   the RPN control message. This however rapidly gets nasty as we\n\t   then have to remap modem signals each way according to whether\n\t   our virtual cable is null modem etc .. */\n\ttty_termios_copy_hw(&tty->termios, old);\n}\n\nstatic void gsmtty_throttle(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tif (C_CRTSCTS(tty))\n\t\tdlci->modem_tx &= ~TIOCM_RTS;\n\tdlci->throttled = true;\n\t/* Send an MSC with RTS cleared */\n\tgsm_modem_update(dlci, 0);\n}\n\nstatic void gsmtty_unthrottle(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn;\n\tif (C_CRTSCTS(tty))\n\t\tdlci->modem_tx |= TIOCM_RTS;\n\tdlci->throttled = false;\n\t/* Send an MSC with RTS set */\n\tgsm_modem_update(dlci, 0);\n}\n\nstatic int gsmtty_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tint encode = 0;\t/* Off */\n\tif (dlci->state == DLCI_CLOSED)\n\t\treturn -EINVAL;\n\n\tif (state == -1)\t/* \"On indefinitely\" - we can't encode this\n\t\t\t\t    properly */\n\t\tencode = 0x0F;\n\telse if (state > 0) {\n\t\tencode = state / 200;\t/* mS to encoding */\n\t\tif (encode > 0x0F)\n\t\t\tencode = 0x0F;\t/* Best effort */\n\t}\n\treturn gsm_modem_update(dlci, encode);\n}\n\nstatic void gsmtty_cleanup(struct tty_struct *tty)\n{\n\tstruct gsm_dlci *dlci = tty->driver_data;\n\tstruct gsm_mux *gsm = dlci->gsm;\n\n\tdlci_put(dlci);\n\tdlci_put(gsm->dlci[0]);\n\tmux_put(gsm);\n}\n\n/* Virtual ttys for the demux */\nstatic const struct tty_operations gsmtty_ops = {\n\t.install\t\t= gsmtty_install,\n\t.open\t\t\t= gsmtty_open,\n\t.close\t\t\t= gsmtty_close,\n\t.write\t\t\t= gsmtty_write,\n\t.write_room\t\t= gsmtty_write_room,\n\t.chars_in_buffer\t= gsmtty_chars_in_buffer,\n\t.flush_buffer\t\t= gsmtty_flush_buffer,\n\t.ioctl\t\t\t= gsmtty_ioctl,\n\t.throttle\t\t= gsmtty_throttle,\n\t.unthrottle\t\t= gsmtty_unthrottle,\n\t.set_termios\t\t= gsmtty_set_termios,\n\t.hangup\t\t\t= gsmtty_hangup,\n\t.wait_until_sent\t= gsmtty_wait_until_sent,\n\t.tiocmget\t\t= gsmtty_tiocmget,\n\t.tiocmset\t\t= gsmtty_tiocmset,\n\t.break_ctl\t\t= gsmtty_break_ctl,\n\t.cleanup\t\t= gsmtty_cleanup,\n};\n\n\n\nstatic int __init gsm_init(void)\n{\n\t/* Fill in our line protocol discipline, and register it */\n\tint status = tty_register_ldisc(&tty_ldisc_packet);\n\tif (status != 0) {\n\t\tpr_err(\"n_gsm: can't register line discipline (err = %d)\\n\",\n\t\t\t\t\t\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tgsm_tty_driver = tty_alloc_driver(GSM_TTY_MINORS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK);\n\tif (IS_ERR(gsm_tty_driver)) {\n\t\tpr_err(\"gsm_init: tty allocation failed.\\n\");\n\t\tstatus = PTR_ERR(gsm_tty_driver);\n\t\tgoto err_unreg_ldisc;\n\t}\n\tgsm_tty_driver->driver_name\t= \"gsmtty\";\n\tgsm_tty_driver->name\t\t= \"gsmtty\";\n\tgsm_tty_driver->major\t\t= 0;\t/* Dynamic */\n\tgsm_tty_driver->minor_start\t= 0;\n\tgsm_tty_driver->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tgsm_tty_driver->subtype\t= SERIAL_TYPE_NORMAL;\n\tgsm_tty_driver->init_termios\t= tty_std_termios;\n\t/* Fixme */\n\tgsm_tty_driver->init_termios.c_lflag &= ~ECHO;\n\ttty_set_operations(gsm_tty_driver, &gsmtty_ops);\n\n\tif (tty_register_driver(gsm_tty_driver)) {\n\t\tpr_err(\"gsm_init: tty registration failed.\\n\");\n\t\tstatus = -EBUSY;\n\t\tgoto err_put_driver;\n\t}\n\tpr_debug(\"gsm_init: loaded as %d,%d.\\n\",\n\t\t\tgsm_tty_driver->major, gsm_tty_driver->minor_start);\n\treturn 0;\nerr_put_driver:\n\ttty_driver_kref_put(gsm_tty_driver);\nerr_unreg_ldisc:\n\ttty_unregister_ldisc(&tty_ldisc_packet);\n\treturn status;\n}\n\nstatic void __exit gsm_exit(void)\n{\n\ttty_unregister_ldisc(&tty_ldisc_packet);\n\ttty_unregister_driver(gsm_tty_driver);\n\ttty_driver_kref_put(gsm_tty_driver);\n}\n\nmodule_init(gsm_init);\nmodule_exit(gsm_exit);\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_GSM0710);\n"], "filenames": ["drivers/tty/n_gsm.c"], "buggy_code_start_loc": [3045], "buggy_code_end_loc": [3050], "fixing_code_start_loc": [3045], "fixing_code_end_loc": [3052], "type": "CWE-362", "message": "A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system.", "other": {"cve": {"id": "CVE-2023-6546", "sourceIdentifier": "secalert@redhat.com", "published": "2023-12-21T20:15:08.260", "lastModified": "2024-03-12T03:15:06.823", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system."}, {"lang": "es", "value": "Se encontr\u00f3 una condici\u00f3n de ejecuci\u00f3n en el multiplexor tty GSM 0710 en el kernel de Linux. Este problema ocurre cuando dos subprocesos ejecutan GSMIOC_SETCONF ioctl en el mismo descriptor de archivo tty con la disciplina de l\u00ednea gsm habilitada y puede provocar un problema de use after free en una estructura gsm_dlci al reiniciar gsm mux. Esto podr\u00eda permitir que un usuario local sin privilegios aumente sus privilegios en el sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.5", "matchCriteriaId": "98C491C7-598A-4D36-BA4F-3505A5727ED1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "0B3E6E4D-E24E-4630-B00C-8C9901C597B0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.5:rc2:*:*:*:*:*:*", "matchCriteriaId": "E4A01A71-0F09-4DB2-A02F-7EFFBE27C98D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.5:rc3:*:*:*:*:*:*", "matchCriteriaId": "F5608371-157A-4318-8A2E-4104C3467EA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.5:rc4:*:*:*:*:*:*", "matchCriteriaId": "2226A776-DF8C-49E0-A030-0A7853BB018A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.5:rc5:*:*:*:*:*:*", "matchCriteriaId": "6F15C659-DF06-455A-9765-0E6DE920F29A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.5:rc6:*:*:*:*:*:*", "matchCriteriaId": "5B1C14ED-ABC4-41D3-8D9C-D38C6A65B4DE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2024:0930", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2024:0937", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2024:1018", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2024:1019", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2024:1055", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2024:1250", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2024:1253", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/security/cve/CVE-2023-6546", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2255498", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/3c4f8333b582487a2d1e02171f1465531cde53e3", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://www.zerodayinitiative.com/advisories/ZDI-CAN-20527", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3c4f8333b582487a2d1e02171f1465531cde53e3"}}