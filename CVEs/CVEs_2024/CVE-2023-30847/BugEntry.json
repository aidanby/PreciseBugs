{"buggy_code": ["/*\n * Copyright (c) 2014,2015 DeNA Co., Ltd., Kazuho Oku, Masahiro Nagano\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include <fcntl.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include \"picohttpparser.h\"\n#include \"h2o.h\"\n#include \"h2o/http1.h\"\n#include \"h2o/httpclient.h\"\n\nstruct rp_generator_t {\n    h2o_generator_t super;\n    h2o_req_t *src_req;\n    h2o_httpclient_t *client;\n    struct {\n        h2o_iovec_t bufs[2]; /* first buf is the request line and headers, the second is the POST content */\n        int is_head;\n    } up_req;\n    h2o_buffer_t *last_content_before_send;\n    h2o_doublebuffer_t sending;\n    h2o_timer_t send_headers_timeout;\n    size_t body_bytes_read, body_bytes_sent;\n    struct {\n        int fds[2]; /* fd[0] set to -1 unless used */\n    } pipe_reader;\n    unsigned had_body_error : 1; /* set if an error happened while fetching the body so that we can propagate the error */\n    unsigned req_done : 1;\n    unsigned res_done : 1;\n    unsigned pipe_inflight : 1;\n    int *generator_disposed;\n};\n\nstatic h2o_httpclient_ctx_t *get_client_ctx(h2o_req_t *req)\n{\n    h2o_req_overrides_t *overrides = req->overrides;\n    if (overrides != NULL && overrides->client_ctx != NULL)\n        return overrides->client_ctx;\n    return &req->conn->ctx->proxy.client_ctx;\n}\n\nstatic h2o_iovec_t rewrite_location(h2o_mem_pool_t *pool, const char *location, size_t location_len, h2o_url_t *match,\n                                    const h2o_url_scheme_t *req_scheme, h2o_iovec_t req_authority, h2o_iovec_t req_basepath)\n{\n    h2o_url_t loc_parsed;\n\n    if (h2o_url_parse(location, location_len, &loc_parsed) != 0)\n        goto NoRewrite;\n    if (loc_parsed.scheme != &H2O_URL_SCHEME_HTTP)\n        goto NoRewrite;\n    if (!h2o_url_hosts_are_equal(&loc_parsed, match))\n        goto NoRewrite;\n    if (h2o_url_get_port(&loc_parsed) != h2o_url_get_port(match))\n        goto NoRewrite;\n    if (loc_parsed.path.len < match->path.len)\n        goto NoRewrite;\n    if (memcmp(loc_parsed.path.base, match->path.base, match->path.len) != 0)\n        goto NoRewrite;\n\n    return h2o_concat(pool, req_scheme->name, h2o_iovec_init(H2O_STRLIT(\"://\")), req_authority, req_basepath,\n                      h2o_iovec_init(loc_parsed.path.base + match->path.len, loc_parsed.path.len - match->path.len));\n\nNoRewrite:\n    return (h2o_iovec_t){NULL};\n}\n\nstatic h2o_iovec_t build_request_merge_headers(h2o_mem_pool_t *pool, h2o_iovec_t merged, h2o_iovec_t added, int seperator)\n{\n    if (added.len == 0)\n        return merged;\n    if (merged.len == 0)\n        return added;\n\n    size_t newlen = merged.len + 2 + added.len;\n    char *buf = h2o_mem_alloc_pool(pool, *buf, newlen);\n    memcpy(buf, merged.base, merged.len);\n    buf[merged.len] = seperator;\n    buf[merged.len + 1] = ' ';\n    memcpy(buf + merged.len + 2, added.base, added.len);\n    merged.base = buf;\n    merged.len = newlen;\n    return merged;\n}\n\n/*\n * A request without neither Content-Length or Transfer-Encoding header implies a zero-length request body (see 6th rule of RFC 7230\n * 3.3.3).\n * OTOH, section 3.3.3 states:\n *\n *   A user agent SHOULD send a Content-Length in a request message when\n *   no Transfer-Encoding is sent and the request method defines a meaning\n *   for an enclosed payload body.  For example, a Content-Length header\n *   field is normally sent in a POST request even when the value is 0\n *   (indicating an empty payload body).  A user agent SHOULD NOT send a\n *   Content-Length header field when the request message does not contain\n *   a payload body and the method semantics do not anticipate such a\n *   body.\n *\n * PUT and POST define a meaning for the payload body, let's emit a\n * Content-Length header if it doesn't exist already, since the server\n * might send a '411 Length Required' response.\n *\n * see also: ML thread starting at https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0580.html\n */\nstatic int req_requires_content_length(h2o_req_t *req)\n{\n    int is_put_or_post = (req->method.len >= 1 && req->method.base[0] == 'P' &&\n                          (h2o_memis(req->method.base, req->method.len, H2O_STRLIT(\"POST\")) ||\n                           h2o_memis(req->method.base, req->method.len, H2O_STRLIT(\"PUT\"))));\n\n    return is_put_or_post && h2o_find_header(&req->res.headers, H2O_TOKEN_TRANSFER_ENCODING, -1) == -1;\n}\n\nstatic h2o_iovec_t build_content_length(h2o_mem_pool_t *pool, size_t cl)\n{\n    h2o_iovec_t cl_buf;\n    cl_buf.base = h2o_mem_alloc_pool(pool, char, sizeof(H2O_SIZE_T_LONGEST_STR));\n    cl_buf.len = sprintf(cl_buf.base, \"%zu\", cl);\n    return cl_buf;\n}\n\nstatic void build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h2o_headers_t *headers,\n                          h2o_httpclient_properties_t *props, int keepalive, const char *upgrade_to, int use_proxy_protocol,\n                          int *reprocess_if_too_early, h2o_url_t *origin)\n{\n    size_t remote_addr_len = SIZE_MAX;\n    char remote_addr[NI_MAXHOST];\n    struct sockaddr_storage ss;\n    socklen_t sslen;\n    h2o_iovec_t xff_buf = {NULL}, via_buf = {NULL};\n    int preserve_x_forwarded_proto = req->conn->ctx->globalconf->proxy.preserve_x_forwarded_proto;\n    int emit_x_forwarded_headers = req->conn->ctx->globalconf->proxy.emit_x_forwarded_headers;\n    int emit_via_header = req->conn->ctx->globalconf->proxy.emit_via_header;\n\n    /* for x-f-f */\n    if ((sslen = req->conn->callbacks->get_peername(req->conn, (void *)&ss)) != 0)\n        remote_addr_len = h2o_socket_getnumerichost((void *)&ss, sslen, remote_addr);\n\n    if (props->proxy_protocol != NULL && use_proxy_protocol) {\n        props->proxy_protocol->base = h2o_mem_alloc_pool(&req->pool, char, H2O_PROXY_HEADER_MAX_LENGTH);\n        props->proxy_protocol->len = h2o_stringify_proxy_header(req->conn, props->proxy_protocol->base);\n    }\n\n    /* method */\n    *method = h2o_strdup(&req->pool, req->method.base, req->method.len);\n\n    /* url */\n    h2o_url_init(url, origin->scheme, req->authority, h2o_strdup(&req->pool, req->path.base, req->path.len));\n\n    if (props->connection_header != NULL) {\n        if (upgrade_to != NULL && upgrade_to != h2o_httpclient_upgrade_to_connect) {\n            *props->connection_header = h2o_iovec_init(H2O_STRLIT(\"upgrade\"));\n            h2o_add_header(&req->pool, headers, H2O_TOKEN_UPGRADE, NULL, upgrade_to, strlen(upgrade_to));\n        } else if (keepalive) {\n            *props->connection_header = h2o_iovec_init(H2O_STRLIT(\"keep-alive\"));\n        } else {\n            *props->connection_header = h2o_iovec_init(H2O_STRLIT(\"close\"));\n        }\n    }\n\n    /* setup CL or TE, if necessary; chunked encoding is used when the request body is stream and content-length is unknown */\n    if (!req->is_tunnel_req) {\n        if (req->proceed_req == NULL) {\n            if (req->entity.base != NULL || req_requires_content_length(req)) {\n                h2o_iovec_t cl_buf = build_content_length(&req->pool, req->entity.len);\n                h2o_add_header(&req->pool, headers, H2O_TOKEN_CONTENT_LENGTH, NULL, cl_buf.base, cl_buf.len);\n            }\n        } else {\n            if (req->content_length != SIZE_MAX) {\n                h2o_iovec_t cl_buf = build_content_length(&req->pool, req->content_length);\n                h2o_add_header(&req->pool, headers, H2O_TOKEN_CONTENT_LENGTH, NULL, cl_buf.base, cl_buf.len);\n            } else if (props->chunked != NULL) {\n                *props->chunked = 1;\n                h2o_add_header(&req->pool, headers, H2O_TOKEN_TRANSFER_ENCODING, NULL, H2O_STRLIT(\"chunked\"));\n            }\n        }\n    }\n\n    /* headers */\n    h2o_iovec_vector_t cookie_values = {NULL};\n    int found_early_data = 0;\n    if (H2O_LIKELY(req->headers.size != 0)) {\n        for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; h != h_end; ++h) {\n            if (h2o_iovec_is_token(h->name)) {\n                const h2o_token_t *token = (void *)h->name;\n                if (token->flags.proxy_should_drop_for_req)\n                    continue;\n                if (token == H2O_TOKEN_COOKIE) {\n                    h2o_vector_reserve(&req->pool, &cookie_values, cookie_values.size + 1);\n                    cookie_values.entries[cookie_values.size++] = h->value;\n                    continue;\n                } else if (token == H2O_TOKEN_VIA) {\n                    if (!emit_via_header) {\n                        goto AddHeader;\n                    }\n                    via_buf = build_request_merge_headers(&req->pool, via_buf, h->value, ',');\n                    continue;\n                } else if (token == H2O_TOKEN_X_FORWARDED_FOR) {\n                    if (!emit_x_forwarded_headers) {\n                        goto AddHeader;\n                    }\n                    xff_buf = build_request_merge_headers(&req->pool, xff_buf, h->value, ',');\n                    continue;\n                } else if (token == H2O_TOKEN_EARLY_DATA) {\n                    found_early_data = 1;\n                    goto AddHeader;\n                }\n            }\n            if (!preserve_x_forwarded_proto && h2o_lcstris(h->name->base, h->name->len, H2O_STRLIT(\"x-forwarded-proto\")))\n                continue;\n        AddHeader:\n            if (h2o_iovec_is_token(h->name)) {\n                const h2o_token_t *token = (void *)h->name;\n                h2o_add_header(&req->pool, headers, token, h->orig_name, h->value.base, h->value.len);\n            } else {\n                h2o_add_header_by_str(&req->pool, headers, h->name->base, h->name->len, 0, h->orig_name, h->value.base,\n                                      h->value.len);\n            }\n        }\n    }\n    if (found_early_data) {\n        *reprocess_if_too_early = 0;\n    } else if (*reprocess_if_too_early) {\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_EARLY_DATA, NULL, H2O_STRLIT(\"1\"));\n    }\n\n    if (cookie_values.size == 1) {\n        /* fast path */\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_COOKIE, NULL, cookie_values.entries[0].base, cookie_values.entries[0].len);\n    } else if (cookie_values.size > 1) {\n        /* merge the cookie headers; see HTTP/2 8.1.2.5 and HTTP/1 (RFC6265 5.4) */\n        h2o_iovec_t cookie_buf =\n            h2o_join_list(&req->pool, cookie_values.entries, cookie_values.size, h2o_iovec_init(H2O_STRLIT(\"; \")));\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_COOKIE, NULL, cookie_buf.base, cookie_buf.len);\n    }\n    if (emit_x_forwarded_headers) {\n        if (!preserve_x_forwarded_proto)\n            h2o_add_header_by_str(&req->pool, headers, H2O_STRLIT(\"x-forwarded-proto\"), 0, NULL, req->input.scheme->name.base,\n                                  req->input.scheme->name.len);\n        if (remote_addr_len != SIZE_MAX)\n            xff_buf = build_request_merge_headers(&req->pool, xff_buf, h2o_strdup(&req->pool, remote_addr, remote_addr_len), ',');\n        if (xff_buf.len != 0)\n            h2o_add_header(&req->pool, headers, H2O_TOKEN_X_FORWARDED_FOR, NULL, xff_buf.base, xff_buf.len);\n    }\n    if (emit_via_header) {\n        h2o_iovec_t added;\n        added.base = h2o_mem_alloc_pool(&req->pool, char, sizeof(\"1.1 \") - 1 + req->input.authority.len);\n        added.len = 0;\n\n        if (req->version < 0x200) {\n            added.base[added.len++] = '1';\n            added.base[added.len++] = '.';\n            added.base[added.len++] = '0' + (0x100 <= req->version && req->version <= 0x109 ? req->version - 0x100 : 0);\n        } else {\n            added.base[added.len++] = '0' + req->version / 0x100;\n        }\n        added.base[added.len++] = ' ';\n        memcpy(added.base + added.len, req->input.authority.base, req->input.authority.len);\n        added.len += req->input.authority.len;\n\n        via_buf = build_request_merge_headers(&req->pool, via_buf, added, ',');\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_VIA, NULL, via_buf.base, via_buf.len);\n    }\n\n    /* rewrite headers if necessary */\n    if (req->overrides != NULL && req->overrides->headers_cmds != NULL) {\n        h2o_headers_command_t *cmd;\n        for (cmd = req->overrides->headers_cmds; cmd->cmd != H2O_HEADERS_CMD_NULL; ++cmd)\n            h2o_rewrite_headers(&req->pool, headers, cmd);\n    }\n}\n\nstatic h2o_httpclient_t *detach_client(struct rp_generator_t *self)\n{\n    h2o_httpclient_t *client = self->client;\n    assert(client != NULL);\n    client->data = NULL;\n    self->client = NULL;\n    return client;\n}\n\nstatic void do_close(struct rp_generator_t *self)\n{\n    /**\n     * This can be called in the following three scenarios:\n     *   1. Downstream timeout before receiving header from upstream\n     *        dispose callback calls this function, but stop callback doesn't\n     *   2. Reprocess\n     *        stop callback calls this, but dispose callback does it later (after reprocessed request gets finished)\n     *   3. Others\n     *        Both of stop and dispose callbacks call this function in order\n     * Thus, to ensure to do closing things, both of dispose and stop callbacks call this function (reminder: that means that this\n     * function might get called multiple times).\n     */\n    if (self->client != NULL) {\n        h2o_httpclient_t *client = detach_client(self);\n        client->cancel(client);\n    }\n    h2o_timer_unlink(&self->send_headers_timeout);\n    if (self->pipe_reader.fds[0] != -1) {\n        close(self->pipe_reader.fds[0]);\n        close(self->pipe_reader.fds[1]);\n        self->pipe_reader.fds[0] = -1;\n    }\n}\n\nstatic void do_stop(h2o_generator_t *generator, h2o_req_t *req)\n{\n    struct rp_generator_t *self = (void *)generator;\n    do_close(self);\n}\n\nstatic void do_send(struct rp_generator_t *self)\n{\n    h2o_iovec_t vecs[1];\n    size_t veccnt;\n    h2o_send_state_t ststate;\n\n    vecs[0] = h2o_doublebuffer_prepare(&self->sending,\n                                       self->last_content_before_send != NULL ? &self->last_content_before_send : self->client->buf,\n                                       self->src_req->preferred_chunk_size);\n\n    if (self->last_content_before_send != NULL && vecs[0].len == self->sending.buf->size &&\n        self->last_content_before_send->size == 0) {\n        veccnt = vecs[0].len != 0 ? 1 : 0;\n        ststate = H2O_SEND_STATE_FINAL;\n    } else {\n        if (vecs[0].len == 0)\n            return;\n        veccnt = 1;\n        ststate = H2O_SEND_STATE_IN_PROGRESS;\n    }\n\n    if (self->had_body_error)\n        ststate = H2O_SEND_STATE_ERROR;\n\n    if (veccnt != 0)\n        self->body_bytes_sent += vecs[0].len;\n    h2o_send(self->src_req, vecs, veccnt, ststate);\n}\n\nstatic int from_pipe_read(h2o_sendvec_t *vec, void *dst, size_t len)\n{\n    struct rp_generator_t *self = (void *)vec->cb_arg[0];\n\n    while (len != 0) {\n        ssize_t ret;\n        while ((ret = read(self->pipe_reader.fds[0], dst, len)) == -1 && errno == EINTR)\n            ;\n        if (ret <= 0) {\n            assert(errno != EAGAIN);\n            return 0;\n        }\n        dst += ret;\n        len -= ret;\n        vec->len -= ret;\n    }\n\n    return 1;\n}\n\nstatic size_t from_pipe_send(h2o_sendvec_t *vec, int sockfd, size_t len)\n{\n#ifdef __linux__\n    struct rp_generator_t *self = (void *)vec->cb_arg[0];\n\n    ssize_t bytes_sent;\n    while ((bytes_sent = splice(self->pipe_reader.fds[0], NULL, sockfd, NULL, len, SPLICE_F_NONBLOCK)) == -1 && errno == EINTR)\n        ;\n    if (bytes_sent == -1 && errno == EAGAIN)\n        return 0;\n    if (bytes_sent <= 0)\n        return SIZE_MAX;\n\n    vec->len -= bytes_sent;\n\n    return bytes_sent;\n#else\n    h2o_fatal(\"%s:not implemented\", __FUNCTION__);\n#endif\n}\n\nstatic void do_send_from_pipe(struct rp_generator_t *self)\n{\n    h2o_send_state_t send_state = self->had_body_error ? H2O_SEND_STATE_ERROR\n                                  : self->res_done     ? H2O_SEND_STATE_FINAL\n                                                       : H2O_SEND_STATE_IN_PROGRESS;\n\n    if (self->body_bytes_read == self->body_bytes_sent) {\n        if (h2o_send_state_is_in_progress(send_state)) {\n            /* resume reading only when we know that the pipe (to which we read) has become empty */\n            self->client->update_window(self->client);\n        } else {\n            h2o_send(self->src_req, NULL, 0, send_state);\n        }\n        return;\n    }\n\n    static const h2o_sendvec_callbacks_t callbacks = {.read_ = from_pipe_read, .send_ = from_pipe_send};\n    h2o_sendvec_t vec = {.callbacks = &callbacks};\n    if ((vec.len = self->body_bytes_read - self->body_bytes_sent) > H2O_PULL_SENDVEC_MAX_SIZE)\n        vec.len = H2O_PULL_SENDVEC_MAX_SIZE;\n    vec.cb_arg[0] = (uint64_t)self;\n    vec.cb_arg[1] = 0; /* unused */\n\n    self->body_bytes_sent += vec.len;\n    self->pipe_inflight = 1;\n    h2o_sendvec(self->src_req, &vec, 1, send_state);\n}\n\nstatic void do_proceed(h2o_generator_t *generator, h2o_req_t *req)\n{\n    struct rp_generator_t *self = (void *)generator;\n\n    if (self->sending.inflight) {\n        h2o_doublebuffer_consume(&self->sending);\n    } else {\n        assert(self->pipe_reader.fds[0] != -1);\n        assert(self->pipe_inflight);\n        self->pipe_inflight = 0;\n    }\n\n    if (self->pipe_reader.fds[0] != -1 && self->sending.buf->size == 0) {\n        do_send_from_pipe(self);\n    } else {\n        do_send(self);\n        if (!(self->res_done || self->had_body_error))\n            self->client->update_window(self->client);\n    }\n}\n\nstatic void copy_stats(struct rp_generator_t *self)\n{\n    self->src_req->proxy_stats.timestamps = self->client->timings;\n    self->src_req->proxy_stats.bytes_written.total = self->client->bytes_written.total;\n    self->src_req->proxy_stats.bytes_written.header = self->client->bytes_written.header;\n    self->src_req->proxy_stats.bytes_written.body = self->client->bytes_written.body;\n    self->src_req->proxy_stats.bytes_read.total = self->client->bytes_read.total;\n    self->src_req->proxy_stats.bytes_read.header = self->client->bytes_read.header;\n    self->src_req->proxy_stats.bytes_read.body = self->client->bytes_read.body;\n}\n\nstatic void on_body_on_close(struct rp_generator_t *self, const char *errstr)\n{\n    copy_stats(self);\n\n    /* detach the content */\n    self->last_content_before_send = *self->client->buf;\n    h2o_buffer_init(self->client->buf, &h2o_socket_buffer_prototype);\n    if (errstr == h2o_httpclient_error_is_eos) {\n        self->res_done = 1;\n        if (self->req_done)\n            detach_client(self);\n    } else {\n        detach_client(self);\n        h2o_req_log_error(self->src_req, \"lib/core/proxy.c\", \"%s\", errstr);\n        self->had_body_error = 1;\n        if (self->src_req->proceed_req != NULL)\n            self->src_req->proceed_req(self->src_req, errstr);\n    }\n}\n\nstatic int on_body(h2o_httpclient_t *client, const char *errstr)\n{\n    int generator_disposed = 0;\n    struct rp_generator_t *self = client->data;\n\n    self->body_bytes_read = client->bytes_read.body;\n    h2o_timer_unlink(&self->send_headers_timeout);\n\n    if (errstr != NULL) {\n        /* Call `on_body_on_close`. This function might dispose `self`, in which case `generator_disposed` would be set to true. */\n        self->generator_disposed = &generator_disposed;\n        on_body_on_close(self, errstr);\n        if (!generator_disposed)\n            self->generator_disposed = NULL;\n    }\n    if (!generator_disposed && !self->sending.inflight)\n        do_send(self);\n\n    return 0;\n}\n\nstatic int on_body_piped(h2o_httpclient_t *client, const char *errstr)\n{\n    struct rp_generator_t *self = client->data;\n\n    self->body_bytes_read = client->bytes_read.body;\n    h2o_timer_unlink(&self->send_headers_timeout);\n\n    if (errstr != NULL)\n        on_body_on_close(self, errstr);\n    if (!self->sending.inflight && !self->pipe_inflight)\n        do_send_from_pipe(self);\n\n    return 0;\n}\n\nstatic char compress_hint_to_enum(const char *val, size_t len)\n{\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"on\"))) {\n        return H2O_COMPRESS_HINT_ENABLE;\n    }\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"off\"))) {\n        return H2O_COMPRESS_HINT_DISABLE;\n    }\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"gzip\"))) {\n        return H2O_COMPRESS_HINT_ENABLE_GZIP;\n    }\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"br\"))) {\n        return H2O_COMPRESS_HINT_ENABLE_BR;\n    }\n    return H2O_COMPRESS_HINT_AUTO;\n}\n\nstatic void on_send_headers_timeout(h2o_timer_t *entry)\n{\n    struct rp_generator_t *self = H2O_STRUCT_FROM_MEMBER(struct rp_generator_t, send_headers_timeout, entry);\n    h2o_doublebuffer_prepare_empty(&self->sending);\n    h2o_send(self->src_req, NULL, 0, H2O_SEND_STATE_IN_PROGRESS);\n}\n\nstatic h2o_httpclient_body_cb on_head(h2o_httpclient_t *client, const char *errstr, h2o_httpclient_on_head_t *args)\n{\n    struct rp_generator_t *self = client->data;\n    h2o_req_t *req = self->src_req;\n    size_t i;\n    int emit_missing_date_header = req->conn->ctx->globalconf->proxy.emit_missing_date_header;\n    int seen_date_header = 0;\n\n    copy_stats(self);\n\n    if (errstr != NULL && errstr != h2o_httpclient_error_is_eos) {\n        detach_client(self);\n        h2o_req_log_error(req, \"lib/core/proxy.c\", \"%s\", errstr);\n\n        if (errstr == h2o_httpclient_error_refused_stream) {\n            req->upstream_refused = 1;\n            static h2o_generator_t generator = {NULL, NULL};\n            h2o_start_response(req, &generator);\n            h2o_send(req, NULL, 0, H2O_SEND_STATE_ERROR);\n        } else {\n            h2o_send_error_502(req, \"Gateway Error\", errstr, 0);\n            if (self->src_req->proceed_req != NULL)\n                self->src_req->proceed_req(self->src_req, h2o_httpclient_error_refused_stream);\n        }\n\n        return NULL;\n    }\n\n    /* copy the response (note: all the headers must be copied; http1client discards the input once we return from this callback) */\n    req->res.status = args->status;\n    req->res.reason = h2o_strdup(&req->pool, args->msg.base, args->msg.len).base;\n    for (i = 0; i != args->num_headers; ++i) {\n        h2o_iovec_t value = args->headers[i].value;\n        if (h2o_iovec_is_token(args->headers[i].name)) {\n            const h2o_token_t *token = H2O_STRUCT_FROM_MEMBER(h2o_token_t, buf, args->headers[i].name);\n            if (token->flags.proxy_should_drop_for_res) {\n                if (token == H2O_TOKEN_CONNECTION && self->src_req->version < 0x200 && req->overrides != NULL &&\n                    req->overrides->forward_close_connection) {\n                    if (h2o_lcstris(args->headers[i].value.base, args->headers[i].value.len, H2O_STRLIT(\"close\")))\n                        self->src_req->http1_is_persistent = 0;\n                }\n                continue;\n            }\n            if (token == H2O_TOKEN_CONTENT_LENGTH) {\n                if (req->res.content_length != SIZE_MAX ||\n                    (req->res.content_length = h2o_strtosize(args->headers[i].value.base, args->headers[i].value.len)) ==\n                        SIZE_MAX) {\n                    detach_client(self);\n                    h2o_req_log_error(req, \"lib/core/proxy.c\", \"%s\", \"invalid response from upstream (malformed content-length)\");\n                    h2o_send_error_502(req, \"Gateway Error\", \"invalid response from upstream\", 0);\n                    if (self->src_req->proceed_req != NULL)\n                        self->src_req->proceed_req(self->src_req, h2o_httpclient_error_io);\n                    return NULL;\n                }\n                goto Skip;\n            } else if (token == H2O_TOKEN_LOCATION) {\n                if (req->res_is_delegated && (300 <= args->status && args->status <= 399) && args->status != 304) {\n                    detach_client(self);\n                    h2o_iovec_t method = h2o_get_redirect_method(req->method, args->status);\n                    h2o_send_redirect_internal(req, method, args->headers[i].value.base, args->headers[i].value.len, 1);\n                    return NULL;\n                }\n                if (req->overrides != NULL && req->overrides->location_rewrite.match != NULL) {\n                    h2o_iovec_t new_value =\n                        rewrite_location(&req->pool, value.base, value.len, req->overrides->location_rewrite.match,\n                                         req->input.scheme, req->input.authority, req->overrides->location_rewrite.path_prefix);\n                    if (new_value.base != NULL) {\n                        value = new_value;\n                        goto AddHeader;\n                    }\n                }\n            } else if (token == H2O_TOKEN_LINK) {\n                value = h2o_push_path_in_link_header(req, value.base, value.len);\n                if (!value.len)\n                    goto Skip;\n            } else if (token == H2O_TOKEN_SERVER) {\n                if (!req->conn->ctx->globalconf->proxy.preserve_server_header)\n                    goto Skip;\n            } else if (token == H2O_TOKEN_X_COMPRESS_HINT) {\n                req->compress_hint = compress_hint_to_enum(value.base, value.len);\n                goto Skip;\n            } else if (token == H2O_TOKEN_DATE) {\n                seen_date_header = 1;\n            }\n            if (args->header_requires_dup)\n                value = h2o_strdup(&req->pool, value.base, value.len);\n        AddHeader:\n            h2o_add_header(&req->pool, &req->res.headers, token, args->headers[i].orig_name, value.base, value.len);\n        Skip:;\n        } else {\n            h2o_iovec_t name = *args->headers[i].name;\n            if (args->header_requires_dup) {\n                name = h2o_strdup(&req->pool, name.base, name.len);\n                value = h2o_strdup(&req->pool, value.base, value.len);\n            }\n            h2o_add_header_by_str(&req->pool, &req->res.headers, name.base, name.len, 0, args->headers[i].orig_name, value.base,\n                                  value.len);\n        }\n    }\n\n    if (!seen_date_header && emit_missing_date_header)\n        h2o_resp_add_date_header(req);\n\n    if (req->upgrade.base != NULL && req->res.status == 101) {\n        assert(req->is_tunnel_req);\n        h2o_add_header(&req->pool, &req->res.headers, H2O_TOKEN_UPGRADE, NULL, req->upgrade.base, req->upgrade.len);\n    }\n\n    /* declare the start of the response */\n    h2o_start_response(req, &self->super);\n\n    if (errstr == h2o_httpclient_error_is_eos) {\n        self->res_done = 1;\n        if (self->req_done)\n            detach_client(self);\n        h2o_send(req, NULL, 0, H2O_SEND_STATE_FINAL);\n        return NULL; /* TODO this returning NULL causes keepalive to be disabled in http1client. is this what we intended? */\n    }\n\n    /* switch to using pipe reader, if the opportunity is provided */\n    if (args->pipe_reader != NULL) {\n#ifdef __linux__\n        if (pipe2(self->pipe_reader.fds, O_NONBLOCK | O_CLOEXEC) != 0) {\n            char errbuf[256];\n            h2o_fatal(\"pipe2(2) failed:%s\", h2o_strerror_r(errno, errbuf, sizeof(errbuf)));\n        }\n        args->pipe_reader->fd = self->pipe_reader.fds[1];\n        args->pipe_reader->on_body_piped = on_body_piped;\n#endif\n    }\n\n    /* if httpclient has no received body at this time, immediately send only headers using zero timeout */\n    h2o_timer_link(req->conn->ctx->loop, 0, &self->send_headers_timeout);\n\n    return on_body;\n}\n\nstatic int on_1xx(h2o_httpclient_t *client, int version, int status, h2o_iovec_t msg, h2o_header_t *headers, size_t num_headers)\n{\n    struct rp_generator_t *self = client->data;\n    size_t i;\n\n    for (i = 0; i != num_headers; ++i) {\n        if (headers[i].name == &H2O_TOKEN_LINK->buf)\n            h2o_push_path_in_link_header(self->src_req, headers[i].value.base, headers[i].value.len);\n    }\n\n    if (status != 101) {\n        self->src_req->res.status = status;\n        self->src_req->res.headers = (h2o_headers_t){headers, num_headers, num_headers};\n        h2o_send_informational(self->src_req);\n    }\n\n    return 0;\n}\n\nstatic void proceed_request(h2o_httpclient_t *client, const char *errstr)\n{\n    struct rp_generator_t *self = client->data;\n    if (self == NULL)\n        return;\n    if (errstr != NULL)\n        detach_client(self);\n    if (self->src_req->proceed_req != NULL)\n        self->src_req->proceed_req(self->src_req, errstr);\n}\n\nstatic int write_req(void *ctx, int is_end_stream)\n{\n    struct rp_generator_t *self = ctx;\n    h2o_httpclient_t *client = self->client;\n    h2o_iovec_t chunk = self->src_req->entity;\n\n    assert(chunk.len != 0 || is_end_stream);\n\n    if (client == NULL) {\n        return -1;\n    }\n\n    if (is_end_stream) {\n        self->src_req->write_req.cb = NULL;\n        self->req_done = 1;\n        if (self->res_done)\n            detach_client(self);\n    }\n\n    return client->write_req(client, chunk, is_end_stream);\n}\n\nstatic h2o_httpclient_head_cb on_connect(h2o_httpclient_t *client, const char *errstr, h2o_iovec_t *method, h2o_url_t *url,\n                                         const h2o_header_t **headers, size_t *num_headers, h2o_iovec_t *body,\n                                         h2o_httpclient_proceed_req_cb *proceed_req_cb, h2o_httpclient_properties_t *props,\n                                         h2o_url_t *origin)\n{\n    struct rp_generator_t *self = client->data;\n    h2o_req_t *req = self->src_req;\n    int use_proxy_protocol = 0, reprocess_if_too_early = 0;\n\n    copy_stats(self);\n\n    if (errstr != NULL) {\n        detach_client(self);\n        h2o_req_log_error(self->src_req, \"lib/core/proxy.c\", \"%s\", errstr);\n        h2o_send_error_502(self->src_req, \"Gateway Error\", errstr, 0);\n        return NULL;\n    }\n\n    assert(origin != NULL);\n\n    if (req->overrides != NULL) {\n        use_proxy_protocol = req->overrides->use_proxy_protocol;\n        req->overrides->location_rewrite.match = origin;\n        if (!req->overrides->proxy_preserve_host) {\n            req->scheme = origin->scheme;\n            req->authority = origin->authority;\n        }\n        h2o_iovec_t append = req->path;\n        if (origin->path.base[origin->path.len - 1] == '/' && append.base[0] == '/') {\n            append.base += 1;\n            append.len -= 1;\n        }\n        req->path = h2o_concat(&req->pool, origin->path, append);\n        req->path_normalized =\n            h2o_url_normalize_path(&req->pool, req->path.base, req->path.len, &req->query_at, &req->norm_indexes);\n    }\n\n    reprocess_if_too_early = h2o_conn_is_early_data(req->conn);\n    h2o_headers_t headers_vec = (h2o_headers_t){NULL};\n    build_request(req, method, url, &headers_vec, props,\n                  !use_proxy_protocol && h2o_socketpool_can_keepalive(client->connpool->socketpool), self->client->upgrade_to,\n                  use_proxy_protocol, &reprocess_if_too_early, origin);\n    *headers = headers_vec.entries;\n    *num_headers = headers_vec.size;\n\n    if (reprocess_if_too_early)\n        req->reprocess_if_too_early = 1;\n\n    *body = h2o_iovec_init(NULL, 0);\n    *proceed_req_cb = NULL;\n    self->req_done = 1;\n    if (self->src_req->entity.base != NULL) {\n        *body = self->src_req->entity;\n        if (self->src_req->proceed_req != NULL) {\n            *proceed_req_cb = proceed_request;\n            self->src_req->write_req.cb = write_req;\n            self->src_req->write_req.ctx = self;\n            self->req_done = 0;\n        }\n    }\n    self->client->informational_cb = on_1xx;\n\n    client->get_conn_properties(client, &req->proxy_stats.conn);\n\n    { /* indicate to httpclient if use of pipe is preferred */\n        h2o_conn_t *conn = self->src_req->conn;\n        switch (conn->ctx->globalconf->proxy.zerocopy) {\n        case H2O_PROXY_ZEROCOPY_ALWAYS:\n            props->prefer_pipe_reader = 1;\n            break;\n        case H2O_PROXY_ZEROCOPY_ENABLED:\n            if (conn->callbacks->can_zerocopy != NULL && conn->callbacks->can_zerocopy(conn))\n                props->prefer_pipe_reader = 1;\n            break;\n        default:\n            break;\n        }\n    }\n\n    return on_head;\n}\n\nstatic void on_generator_dispose(void *_self)\n{\n    struct rp_generator_t *self = _self;\n    do_close(self);\n\n    if (self->last_content_before_send != NULL) {\n        h2o_buffer_dispose(&self->last_content_before_send);\n    }\n    h2o_doublebuffer_dispose(&self->sending);\n    if (self->generator_disposed != NULL)\n        *self->generator_disposed = 1;\n}\n\nstatic struct rp_generator_t *proxy_send_prepare(h2o_req_t *req)\n{\n    struct rp_generator_t *self = h2o_mem_alloc_shared(&req->pool, sizeof(*self), on_generator_dispose);\n\n    self->super.proceed = do_proceed;\n    self->super.stop = do_stop;\n    self->src_req = req;\n    self->generator_disposed = NULL;\n    self->client = NULL; /* when connection establish timeouts, self->client remains unset by `h2o_httpclient_connect` */\n    self->had_body_error = 0;\n    self->up_req.is_head = h2o_memis(req->method.base, req->method.len, H2O_STRLIT(\"HEAD\"));\n    self->last_content_before_send = NULL;\n    h2o_doublebuffer_init(&self->sending, &h2o_socket_buffer_prototype);\n    memset(&req->proxy_stats, 0, sizeof(req->proxy_stats));\n    h2o_timer_init(&self->send_headers_timeout, on_send_headers_timeout);\n    self->body_bytes_read = 0;\n    self->body_bytes_sent = 0;\n    self->pipe_reader.fds[0] = -1;\n    self->pipe_inflight = 0;\n    self->req_done = 0;\n    self->res_done = 0;\n\n    return self;\n}\n\nvoid h2o__proxy_process_request(h2o_req_t *req)\n{\n    h2o_req_overrides_t *overrides = req->overrides;\n    h2o_httpclient_ctx_t *client_ctx = get_client_ctx(req);\n    h2o_url_t target_buf, *target = &target_buf;\n\n    h2o_httpclient_connection_pool_t *connpool = &req->conn->ctx->proxy.connpool;\n    if (overrides != NULL && overrides->connpool != NULL) {\n        connpool = overrides->connpool;\n        if (!overrides->proxy_preserve_host)\n            target = NULL;\n    }\n    if (target == &target_buf)\n        h2o_url_init(&target_buf, req->scheme, req->authority, h2o_iovec_init(H2O_STRLIT(\"/\")));\n\n    const char *upgrade_to = NULL;\n    if (req->is_tunnel_req) {\n        if (req->upgrade.base != NULL) {\n            /* upgrade requests (e.g. websocket) are either tunnelled or converted to a normal request (by omitting the Upgrade\n             * header field)  depending on the configuration */\n            if (client_ctx->tunnel_enabled)\n                upgrade_to = h2o_strdup(&req->pool, req->upgrade.base, req->upgrade.len).base;\n        } else {\n            /* CONNECT request; process as a CONNECT upgrade or reject */\n            if (client_ctx->tunnel_enabled) {\n                upgrade_to = h2o_httpclient_upgrade_to_connect;\n            } else {\n                h2o_send_error_405(req, \"Method Not Allowed\", \"refusing CONNECT\", H2O_SEND_ERROR_HTTP1_CLOSE_CONNECTION);\n                return;\n            }\n        }\n    }\n    struct rp_generator_t *self = proxy_send_prepare(req);\n\n    /*\n      When the PROXY protocol is being used (i.e. when overrides->use_proxy_protocol is set), the client needs to establish a new\n     connection even when there is a pooled connection to the peer, since the header (as defined in\n     https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt) needs to be sent at the beginning of the connection.\n\n     However, currently h2o_http1client_connect doesn't provide an interface to enforce estabilishing a new connection. In other\n     words, there is a chance that we would use a pool connection here.\n\n     OTOH, the probability of seeing such issue is rare; it would only happen if the same destination identified by its host:port is\n     accessed in both ways (i.e. in one path with use_proxy_protocol set and in the other path without).\n\n     So I leave this as it is for the time being.\n     */\n    h2o_httpclient_connect(&self->client, &req->pool, self, client_ctx, connpool, target, upgrade_to, on_connect);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2014,2015 DeNA Co., Ltd., Kazuho Oku, Masahiro Nagano\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include <fcntl.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include \"picohttpparser.h\"\n#include \"h2o.h\"\n#include \"h2o/http1.h\"\n#include \"h2o/httpclient.h\"\n\nstruct rp_generator_t {\n    h2o_generator_t super;\n    h2o_req_t *src_req;\n    h2o_httpclient_t *client;\n    struct {\n        h2o_iovec_t bufs[2]; /* first buf is the request line and headers, the second is the POST content */\n        int is_head;\n    } up_req;\n    h2o_buffer_t *last_content_before_send;\n    h2o_doublebuffer_t sending;\n    h2o_timer_t send_headers_timeout;\n    size_t body_bytes_read, body_bytes_sent;\n    struct {\n        int fds[2]; /* fd[0] set to -1 unless used */\n    } pipe_reader;\n    unsigned had_body_error : 1; /* set if an error happened while fetching the body so that we can propagate the error */\n    unsigned req_done : 1;\n    unsigned res_done : 1;\n    unsigned pipe_inflight : 1;\n    int *generator_disposed;\n};\n\nstatic h2o_httpclient_ctx_t *get_client_ctx(h2o_req_t *req)\n{\n    h2o_req_overrides_t *overrides = req->overrides;\n    if (overrides != NULL && overrides->client_ctx != NULL)\n        return overrides->client_ctx;\n    return &req->conn->ctx->proxy.client_ctx;\n}\n\nstatic h2o_iovec_t rewrite_location(h2o_mem_pool_t *pool, const char *location, size_t location_len, h2o_url_t *match,\n                                    const h2o_url_scheme_t *req_scheme, h2o_iovec_t req_authority, h2o_iovec_t req_basepath)\n{\n    h2o_url_t loc_parsed;\n\n    if (h2o_url_parse(location, location_len, &loc_parsed) != 0)\n        goto NoRewrite;\n    if (loc_parsed.scheme != &H2O_URL_SCHEME_HTTP)\n        goto NoRewrite;\n    if (!h2o_url_hosts_are_equal(&loc_parsed, match))\n        goto NoRewrite;\n    if (h2o_url_get_port(&loc_parsed) != h2o_url_get_port(match))\n        goto NoRewrite;\n    if (loc_parsed.path.len < match->path.len)\n        goto NoRewrite;\n    if (memcmp(loc_parsed.path.base, match->path.base, match->path.len) != 0)\n        goto NoRewrite;\n\n    return h2o_concat(pool, req_scheme->name, h2o_iovec_init(H2O_STRLIT(\"://\")), req_authority, req_basepath,\n                      h2o_iovec_init(loc_parsed.path.base + match->path.len, loc_parsed.path.len - match->path.len));\n\nNoRewrite:\n    return (h2o_iovec_t){NULL};\n}\n\nstatic h2o_iovec_t build_request_merge_headers(h2o_mem_pool_t *pool, h2o_iovec_t merged, h2o_iovec_t added, int seperator)\n{\n    if (added.len == 0)\n        return merged;\n    if (merged.len == 0)\n        return added;\n\n    size_t newlen = merged.len + 2 + added.len;\n    char *buf = h2o_mem_alloc_pool(pool, *buf, newlen);\n    memcpy(buf, merged.base, merged.len);\n    buf[merged.len] = seperator;\n    buf[merged.len + 1] = ' ';\n    memcpy(buf + merged.len + 2, added.base, added.len);\n    merged.base = buf;\n    merged.len = newlen;\n    return merged;\n}\n\n/*\n * A request without neither Content-Length or Transfer-Encoding header implies a zero-length request body (see 6th rule of RFC 7230\n * 3.3.3).\n * OTOH, section 3.3.3 states:\n *\n *   A user agent SHOULD send a Content-Length in a request message when\n *   no Transfer-Encoding is sent and the request method defines a meaning\n *   for an enclosed payload body.  For example, a Content-Length header\n *   field is normally sent in a POST request even when the value is 0\n *   (indicating an empty payload body).  A user agent SHOULD NOT send a\n *   Content-Length header field when the request message does not contain\n *   a payload body and the method semantics do not anticipate such a\n *   body.\n *\n * PUT and POST define a meaning for the payload body, let's emit a\n * Content-Length header if it doesn't exist already, since the server\n * might send a '411 Length Required' response.\n *\n * see also: ML thread starting at https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0580.html\n */\nstatic int req_requires_content_length(h2o_req_t *req)\n{\n    int is_put_or_post = (req->method.len >= 1 && req->method.base[0] == 'P' &&\n                          (h2o_memis(req->method.base, req->method.len, H2O_STRLIT(\"POST\")) ||\n                           h2o_memis(req->method.base, req->method.len, H2O_STRLIT(\"PUT\"))));\n\n    return is_put_or_post && h2o_find_header(&req->res.headers, H2O_TOKEN_TRANSFER_ENCODING, -1) == -1;\n}\n\nstatic h2o_iovec_t build_content_length(h2o_mem_pool_t *pool, size_t cl)\n{\n    h2o_iovec_t cl_buf;\n    cl_buf.base = h2o_mem_alloc_pool(pool, char, sizeof(H2O_SIZE_T_LONGEST_STR));\n    cl_buf.len = sprintf(cl_buf.base, \"%zu\", cl);\n    return cl_buf;\n}\n\nstatic void build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h2o_headers_t *headers,\n                          h2o_httpclient_properties_t *props, int keepalive, const char *upgrade_to, int use_proxy_protocol,\n                          int *reprocess_if_too_early, h2o_url_t *origin)\n{\n    size_t remote_addr_len = SIZE_MAX;\n    char remote_addr[NI_MAXHOST];\n    struct sockaddr_storage ss;\n    socklen_t sslen;\n    h2o_iovec_t xff_buf = {NULL}, via_buf = {NULL};\n    int preserve_x_forwarded_proto = req->conn->ctx->globalconf->proxy.preserve_x_forwarded_proto;\n    int emit_x_forwarded_headers = req->conn->ctx->globalconf->proxy.emit_x_forwarded_headers;\n    int emit_via_header = req->conn->ctx->globalconf->proxy.emit_via_header;\n\n    /* for x-f-f */\n    if ((sslen = req->conn->callbacks->get_peername(req->conn, (void *)&ss)) != 0)\n        remote_addr_len = h2o_socket_getnumerichost((void *)&ss, sslen, remote_addr);\n\n    if (props->proxy_protocol != NULL && use_proxy_protocol) {\n        props->proxy_protocol->base = h2o_mem_alloc_pool(&req->pool, char, H2O_PROXY_HEADER_MAX_LENGTH);\n        props->proxy_protocol->len = h2o_stringify_proxy_header(req->conn, props->proxy_protocol->base);\n    }\n\n    /* method */\n    *method = h2o_strdup(&req->pool, req->method.base, req->method.len);\n\n    /* url */\n    if (h2o_url_init(url, origin->scheme, req->authority, h2o_strdup(&req->pool, req->path.base, req->path.len)) != 0)\n        h2o_fatal(\"h2o_url_init failed\");\n\n    if (props->connection_header != NULL) {\n        if (upgrade_to != NULL && upgrade_to != h2o_httpclient_upgrade_to_connect) {\n            *props->connection_header = h2o_iovec_init(H2O_STRLIT(\"upgrade\"));\n            h2o_add_header(&req->pool, headers, H2O_TOKEN_UPGRADE, NULL, upgrade_to, strlen(upgrade_to));\n        } else if (keepalive) {\n            *props->connection_header = h2o_iovec_init(H2O_STRLIT(\"keep-alive\"));\n        } else {\n            *props->connection_header = h2o_iovec_init(H2O_STRLIT(\"close\"));\n        }\n    }\n\n    /* setup CL or TE, if necessary; chunked encoding is used when the request body is stream and content-length is unknown */\n    if (!req->is_tunnel_req) {\n        if (req->proceed_req == NULL) {\n            if (req->entity.base != NULL || req_requires_content_length(req)) {\n                h2o_iovec_t cl_buf = build_content_length(&req->pool, req->entity.len);\n                h2o_add_header(&req->pool, headers, H2O_TOKEN_CONTENT_LENGTH, NULL, cl_buf.base, cl_buf.len);\n            }\n        } else {\n            if (req->content_length != SIZE_MAX) {\n                h2o_iovec_t cl_buf = build_content_length(&req->pool, req->content_length);\n                h2o_add_header(&req->pool, headers, H2O_TOKEN_CONTENT_LENGTH, NULL, cl_buf.base, cl_buf.len);\n            } else if (props->chunked != NULL) {\n                *props->chunked = 1;\n                h2o_add_header(&req->pool, headers, H2O_TOKEN_TRANSFER_ENCODING, NULL, H2O_STRLIT(\"chunked\"));\n            }\n        }\n    }\n\n    /* headers */\n    h2o_iovec_vector_t cookie_values = {NULL};\n    int found_early_data = 0;\n    if (H2O_LIKELY(req->headers.size != 0)) {\n        for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; h != h_end; ++h) {\n            if (h2o_iovec_is_token(h->name)) {\n                const h2o_token_t *token = (void *)h->name;\n                if (token->flags.proxy_should_drop_for_req)\n                    continue;\n                if (token == H2O_TOKEN_COOKIE) {\n                    h2o_vector_reserve(&req->pool, &cookie_values, cookie_values.size + 1);\n                    cookie_values.entries[cookie_values.size++] = h->value;\n                    continue;\n                } else if (token == H2O_TOKEN_VIA) {\n                    if (!emit_via_header) {\n                        goto AddHeader;\n                    }\n                    via_buf = build_request_merge_headers(&req->pool, via_buf, h->value, ',');\n                    continue;\n                } else if (token == H2O_TOKEN_X_FORWARDED_FOR) {\n                    if (!emit_x_forwarded_headers) {\n                        goto AddHeader;\n                    }\n                    xff_buf = build_request_merge_headers(&req->pool, xff_buf, h->value, ',');\n                    continue;\n                } else if (token == H2O_TOKEN_EARLY_DATA) {\n                    found_early_data = 1;\n                    goto AddHeader;\n                }\n            }\n            if (!preserve_x_forwarded_proto && h2o_lcstris(h->name->base, h->name->len, H2O_STRLIT(\"x-forwarded-proto\")))\n                continue;\n        AddHeader:\n            if (h2o_iovec_is_token(h->name)) {\n                const h2o_token_t *token = (void *)h->name;\n                h2o_add_header(&req->pool, headers, token, h->orig_name, h->value.base, h->value.len);\n            } else {\n                h2o_add_header_by_str(&req->pool, headers, h->name->base, h->name->len, 0, h->orig_name, h->value.base,\n                                      h->value.len);\n            }\n        }\n    }\n    if (found_early_data) {\n        *reprocess_if_too_early = 0;\n    } else if (*reprocess_if_too_early) {\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_EARLY_DATA, NULL, H2O_STRLIT(\"1\"));\n    }\n\n    if (cookie_values.size == 1) {\n        /* fast path */\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_COOKIE, NULL, cookie_values.entries[0].base, cookie_values.entries[0].len);\n    } else if (cookie_values.size > 1) {\n        /* merge the cookie headers; see HTTP/2 8.1.2.5 and HTTP/1 (RFC6265 5.4) */\n        h2o_iovec_t cookie_buf =\n            h2o_join_list(&req->pool, cookie_values.entries, cookie_values.size, h2o_iovec_init(H2O_STRLIT(\"; \")));\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_COOKIE, NULL, cookie_buf.base, cookie_buf.len);\n    }\n    if (emit_x_forwarded_headers) {\n        if (!preserve_x_forwarded_proto)\n            h2o_add_header_by_str(&req->pool, headers, H2O_STRLIT(\"x-forwarded-proto\"), 0, NULL, req->input.scheme->name.base,\n                                  req->input.scheme->name.len);\n        if (remote_addr_len != SIZE_MAX)\n            xff_buf = build_request_merge_headers(&req->pool, xff_buf, h2o_strdup(&req->pool, remote_addr, remote_addr_len), ',');\n        if (xff_buf.len != 0)\n            h2o_add_header(&req->pool, headers, H2O_TOKEN_X_FORWARDED_FOR, NULL, xff_buf.base, xff_buf.len);\n    }\n    if (emit_via_header) {\n        h2o_iovec_t added;\n        added.base = h2o_mem_alloc_pool(&req->pool, char, sizeof(\"1.1 \") - 1 + req->input.authority.len);\n        added.len = 0;\n\n        if (req->version < 0x200) {\n            added.base[added.len++] = '1';\n            added.base[added.len++] = '.';\n            added.base[added.len++] = '0' + (0x100 <= req->version && req->version <= 0x109 ? req->version - 0x100 : 0);\n        } else {\n            added.base[added.len++] = '0' + req->version / 0x100;\n        }\n        added.base[added.len++] = ' ';\n        memcpy(added.base + added.len, req->input.authority.base, req->input.authority.len);\n        added.len += req->input.authority.len;\n\n        via_buf = build_request_merge_headers(&req->pool, via_buf, added, ',');\n        h2o_add_header(&req->pool, headers, H2O_TOKEN_VIA, NULL, via_buf.base, via_buf.len);\n    }\n\n    /* rewrite headers if necessary */\n    if (req->overrides != NULL && req->overrides->headers_cmds != NULL) {\n        h2o_headers_command_t *cmd;\n        for (cmd = req->overrides->headers_cmds; cmd->cmd != H2O_HEADERS_CMD_NULL; ++cmd)\n            h2o_rewrite_headers(&req->pool, headers, cmd);\n    }\n}\n\nstatic h2o_httpclient_t *detach_client(struct rp_generator_t *self)\n{\n    h2o_httpclient_t *client = self->client;\n    assert(client != NULL);\n    client->data = NULL;\n    self->client = NULL;\n    return client;\n}\n\nstatic void do_close(struct rp_generator_t *self)\n{\n    /**\n     * This can be called in the following three scenarios:\n     *   1. Downstream timeout before receiving header from upstream\n     *        dispose callback calls this function, but stop callback doesn't\n     *   2. Reprocess\n     *        stop callback calls this, but dispose callback does it later (after reprocessed request gets finished)\n     *   3. Others\n     *        Both of stop and dispose callbacks call this function in order\n     * Thus, to ensure to do closing things, both of dispose and stop callbacks call this function (reminder: that means that this\n     * function might get called multiple times).\n     */\n    if (self->client != NULL) {\n        h2o_httpclient_t *client = detach_client(self);\n        client->cancel(client);\n    }\n    h2o_timer_unlink(&self->send_headers_timeout);\n    if (self->pipe_reader.fds[0] != -1) {\n        close(self->pipe_reader.fds[0]);\n        close(self->pipe_reader.fds[1]);\n        self->pipe_reader.fds[0] = -1;\n    }\n}\n\nstatic void do_stop(h2o_generator_t *generator, h2o_req_t *req)\n{\n    struct rp_generator_t *self = (void *)generator;\n    do_close(self);\n}\n\nstatic void do_send(struct rp_generator_t *self)\n{\n    h2o_iovec_t vecs[1];\n    size_t veccnt;\n    h2o_send_state_t ststate;\n\n    vecs[0] = h2o_doublebuffer_prepare(&self->sending,\n                                       self->last_content_before_send != NULL ? &self->last_content_before_send : self->client->buf,\n                                       self->src_req->preferred_chunk_size);\n\n    if (self->last_content_before_send != NULL && vecs[0].len == self->sending.buf->size &&\n        self->last_content_before_send->size == 0) {\n        veccnt = vecs[0].len != 0 ? 1 : 0;\n        ststate = H2O_SEND_STATE_FINAL;\n    } else {\n        if (vecs[0].len == 0)\n            return;\n        veccnt = 1;\n        ststate = H2O_SEND_STATE_IN_PROGRESS;\n    }\n\n    if (self->had_body_error)\n        ststate = H2O_SEND_STATE_ERROR;\n\n    if (veccnt != 0)\n        self->body_bytes_sent += vecs[0].len;\n    h2o_send(self->src_req, vecs, veccnt, ststate);\n}\n\nstatic int from_pipe_read(h2o_sendvec_t *vec, void *dst, size_t len)\n{\n    struct rp_generator_t *self = (void *)vec->cb_arg[0];\n\n    while (len != 0) {\n        ssize_t ret;\n        while ((ret = read(self->pipe_reader.fds[0], dst, len)) == -1 && errno == EINTR)\n            ;\n        if (ret <= 0) {\n            assert(errno != EAGAIN);\n            return 0;\n        }\n        dst += ret;\n        len -= ret;\n        vec->len -= ret;\n    }\n\n    return 1;\n}\n\nstatic size_t from_pipe_send(h2o_sendvec_t *vec, int sockfd, size_t len)\n{\n#ifdef __linux__\n    struct rp_generator_t *self = (void *)vec->cb_arg[0];\n\n    ssize_t bytes_sent;\n    while ((bytes_sent = splice(self->pipe_reader.fds[0], NULL, sockfd, NULL, len, SPLICE_F_NONBLOCK)) == -1 && errno == EINTR)\n        ;\n    if (bytes_sent == -1 && errno == EAGAIN)\n        return 0;\n    if (bytes_sent <= 0)\n        return SIZE_MAX;\n\n    vec->len -= bytes_sent;\n\n    return bytes_sent;\n#else\n    h2o_fatal(\"%s:not implemented\", __FUNCTION__);\n#endif\n}\n\nstatic void do_send_from_pipe(struct rp_generator_t *self)\n{\n    h2o_send_state_t send_state = self->had_body_error ? H2O_SEND_STATE_ERROR\n                                  : self->res_done     ? H2O_SEND_STATE_FINAL\n                                                       : H2O_SEND_STATE_IN_PROGRESS;\n\n    if (self->body_bytes_read == self->body_bytes_sent) {\n        if (h2o_send_state_is_in_progress(send_state)) {\n            /* resume reading only when we know that the pipe (to which we read) has become empty */\n            self->client->update_window(self->client);\n        } else {\n            h2o_send(self->src_req, NULL, 0, send_state);\n        }\n        return;\n    }\n\n    static const h2o_sendvec_callbacks_t callbacks = {.read_ = from_pipe_read, .send_ = from_pipe_send};\n    h2o_sendvec_t vec = {.callbacks = &callbacks};\n    if ((vec.len = self->body_bytes_read - self->body_bytes_sent) > H2O_PULL_SENDVEC_MAX_SIZE)\n        vec.len = H2O_PULL_SENDVEC_MAX_SIZE;\n    vec.cb_arg[0] = (uint64_t)self;\n    vec.cb_arg[1] = 0; /* unused */\n\n    self->body_bytes_sent += vec.len;\n    self->pipe_inflight = 1;\n    h2o_sendvec(self->src_req, &vec, 1, send_state);\n}\n\nstatic void do_proceed(h2o_generator_t *generator, h2o_req_t *req)\n{\n    struct rp_generator_t *self = (void *)generator;\n\n    if (self->sending.inflight) {\n        h2o_doublebuffer_consume(&self->sending);\n    } else {\n        assert(self->pipe_reader.fds[0] != -1);\n        assert(self->pipe_inflight);\n        self->pipe_inflight = 0;\n    }\n\n    if (self->pipe_reader.fds[0] != -1 && self->sending.buf->size == 0) {\n        do_send_from_pipe(self);\n    } else {\n        do_send(self);\n        if (!(self->res_done || self->had_body_error))\n            self->client->update_window(self->client);\n    }\n}\n\nstatic void copy_stats(struct rp_generator_t *self)\n{\n    self->src_req->proxy_stats.timestamps = self->client->timings;\n    self->src_req->proxy_stats.bytes_written.total = self->client->bytes_written.total;\n    self->src_req->proxy_stats.bytes_written.header = self->client->bytes_written.header;\n    self->src_req->proxy_stats.bytes_written.body = self->client->bytes_written.body;\n    self->src_req->proxy_stats.bytes_read.total = self->client->bytes_read.total;\n    self->src_req->proxy_stats.bytes_read.header = self->client->bytes_read.header;\n    self->src_req->proxy_stats.bytes_read.body = self->client->bytes_read.body;\n}\n\nstatic void on_body_on_close(struct rp_generator_t *self, const char *errstr)\n{\n    copy_stats(self);\n\n    /* detach the content */\n    self->last_content_before_send = *self->client->buf;\n    h2o_buffer_init(self->client->buf, &h2o_socket_buffer_prototype);\n    if (errstr == h2o_httpclient_error_is_eos) {\n        self->res_done = 1;\n        if (self->req_done)\n            detach_client(self);\n    } else {\n        detach_client(self);\n        h2o_req_log_error(self->src_req, \"lib/core/proxy.c\", \"%s\", errstr);\n        self->had_body_error = 1;\n        if (self->src_req->proceed_req != NULL)\n            self->src_req->proceed_req(self->src_req, errstr);\n    }\n}\n\nstatic int on_body(h2o_httpclient_t *client, const char *errstr)\n{\n    int generator_disposed = 0;\n    struct rp_generator_t *self = client->data;\n\n    self->body_bytes_read = client->bytes_read.body;\n    h2o_timer_unlink(&self->send_headers_timeout);\n\n    if (errstr != NULL) {\n        /* Call `on_body_on_close`. This function might dispose `self`, in which case `generator_disposed` would be set to true. */\n        self->generator_disposed = &generator_disposed;\n        on_body_on_close(self, errstr);\n        if (!generator_disposed)\n            self->generator_disposed = NULL;\n    }\n    if (!generator_disposed && !self->sending.inflight)\n        do_send(self);\n\n    return 0;\n}\n\nstatic int on_body_piped(h2o_httpclient_t *client, const char *errstr)\n{\n    struct rp_generator_t *self = client->data;\n\n    self->body_bytes_read = client->bytes_read.body;\n    h2o_timer_unlink(&self->send_headers_timeout);\n\n    if (errstr != NULL)\n        on_body_on_close(self, errstr);\n    if (!self->sending.inflight && !self->pipe_inflight)\n        do_send_from_pipe(self);\n\n    return 0;\n}\n\nstatic char compress_hint_to_enum(const char *val, size_t len)\n{\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"on\"))) {\n        return H2O_COMPRESS_HINT_ENABLE;\n    }\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"off\"))) {\n        return H2O_COMPRESS_HINT_DISABLE;\n    }\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"gzip\"))) {\n        return H2O_COMPRESS_HINT_ENABLE_GZIP;\n    }\n    if (h2o_lcstris(val, len, H2O_STRLIT(\"br\"))) {\n        return H2O_COMPRESS_HINT_ENABLE_BR;\n    }\n    return H2O_COMPRESS_HINT_AUTO;\n}\n\nstatic void on_send_headers_timeout(h2o_timer_t *entry)\n{\n    struct rp_generator_t *self = H2O_STRUCT_FROM_MEMBER(struct rp_generator_t, send_headers_timeout, entry);\n    h2o_doublebuffer_prepare_empty(&self->sending);\n    h2o_send(self->src_req, NULL, 0, H2O_SEND_STATE_IN_PROGRESS);\n}\n\nstatic h2o_httpclient_body_cb on_head(h2o_httpclient_t *client, const char *errstr, h2o_httpclient_on_head_t *args)\n{\n    struct rp_generator_t *self = client->data;\n    h2o_req_t *req = self->src_req;\n    size_t i;\n    int emit_missing_date_header = req->conn->ctx->globalconf->proxy.emit_missing_date_header;\n    int seen_date_header = 0;\n\n    copy_stats(self);\n\n    if (errstr != NULL && errstr != h2o_httpclient_error_is_eos) {\n        detach_client(self);\n        h2o_req_log_error(req, \"lib/core/proxy.c\", \"%s\", errstr);\n\n        if (errstr == h2o_httpclient_error_refused_stream) {\n            req->upstream_refused = 1;\n            static h2o_generator_t generator = {NULL, NULL};\n            h2o_start_response(req, &generator);\n            h2o_send(req, NULL, 0, H2O_SEND_STATE_ERROR);\n        } else {\n            h2o_send_error_502(req, \"Gateway Error\", errstr, 0);\n            if (self->src_req->proceed_req != NULL)\n                self->src_req->proceed_req(self->src_req, h2o_httpclient_error_refused_stream);\n        }\n\n        return NULL;\n    }\n\n    /* copy the response (note: all the headers must be copied; http1client discards the input once we return from this callback) */\n    req->res.status = args->status;\n    req->res.reason = h2o_strdup(&req->pool, args->msg.base, args->msg.len).base;\n    for (i = 0; i != args->num_headers; ++i) {\n        h2o_iovec_t value = args->headers[i].value;\n        if (h2o_iovec_is_token(args->headers[i].name)) {\n            const h2o_token_t *token = H2O_STRUCT_FROM_MEMBER(h2o_token_t, buf, args->headers[i].name);\n            if (token->flags.proxy_should_drop_for_res) {\n                if (token == H2O_TOKEN_CONNECTION && self->src_req->version < 0x200 && req->overrides != NULL &&\n                    req->overrides->forward_close_connection) {\n                    if (h2o_lcstris(args->headers[i].value.base, args->headers[i].value.len, H2O_STRLIT(\"close\")))\n                        self->src_req->http1_is_persistent = 0;\n                }\n                continue;\n            }\n            if (token == H2O_TOKEN_CONTENT_LENGTH) {\n                if (req->res.content_length != SIZE_MAX ||\n                    (req->res.content_length = h2o_strtosize(args->headers[i].value.base, args->headers[i].value.len)) ==\n                        SIZE_MAX) {\n                    detach_client(self);\n                    h2o_req_log_error(req, \"lib/core/proxy.c\", \"%s\", \"invalid response from upstream (malformed content-length)\");\n                    h2o_send_error_502(req, \"Gateway Error\", \"invalid response from upstream\", 0);\n                    if (self->src_req->proceed_req != NULL)\n                        self->src_req->proceed_req(self->src_req, h2o_httpclient_error_io);\n                    return NULL;\n                }\n                goto Skip;\n            } else if (token == H2O_TOKEN_LOCATION) {\n                if (req->res_is_delegated && (300 <= args->status && args->status <= 399) && args->status != 304) {\n                    detach_client(self);\n                    h2o_iovec_t method = h2o_get_redirect_method(req->method, args->status);\n                    h2o_send_redirect_internal(req, method, args->headers[i].value.base, args->headers[i].value.len, 1);\n                    return NULL;\n                }\n                if (req->overrides != NULL && req->overrides->location_rewrite.match != NULL) {\n                    h2o_iovec_t new_value =\n                        rewrite_location(&req->pool, value.base, value.len, req->overrides->location_rewrite.match,\n                                         req->input.scheme, req->input.authority, req->overrides->location_rewrite.path_prefix);\n                    if (new_value.base != NULL) {\n                        value = new_value;\n                        goto AddHeader;\n                    }\n                }\n            } else if (token == H2O_TOKEN_LINK) {\n                value = h2o_push_path_in_link_header(req, value.base, value.len);\n                if (!value.len)\n                    goto Skip;\n            } else if (token == H2O_TOKEN_SERVER) {\n                if (!req->conn->ctx->globalconf->proxy.preserve_server_header)\n                    goto Skip;\n            } else if (token == H2O_TOKEN_X_COMPRESS_HINT) {\n                req->compress_hint = compress_hint_to_enum(value.base, value.len);\n                goto Skip;\n            } else if (token == H2O_TOKEN_DATE) {\n                seen_date_header = 1;\n            }\n            if (args->header_requires_dup)\n                value = h2o_strdup(&req->pool, value.base, value.len);\n        AddHeader:\n            h2o_add_header(&req->pool, &req->res.headers, token, args->headers[i].orig_name, value.base, value.len);\n        Skip:;\n        } else {\n            h2o_iovec_t name = *args->headers[i].name;\n            if (args->header_requires_dup) {\n                name = h2o_strdup(&req->pool, name.base, name.len);\n                value = h2o_strdup(&req->pool, value.base, value.len);\n            }\n            h2o_add_header_by_str(&req->pool, &req->res.headers, name.base, name.len, 0, args->headers[i].orig_name, value.base,\n                                  value.len);\n        }\n    }\n\n    if (!seen_date_header && emit_missing_date_header)\n        h2o_resp_add_date_header(req);\n\n    if (req->upgrade.base != NULL && req->res.status == 101) {\n        assert(req->is_tunnel_req);\n        h2o_add_header(&req->pool, &req->res.headers, H2O_TOKEN_UPGRADE, NULL, req->upgrade.base, req->upgrade.len);\n    }\n\n    /* declare the start of the response */\n    h2o_start_response(req, &self->super);\n\n    if (errstr == h2o_httpclient_error_is_eos) {\n        self->res_done = 1;\n        if (self->req_done)\n            detach_client(self);\n        h2o_send(req, NULL, 0, H2O_SEND_STATE_FINAL);\n        return NULL; /* TODO this returning NULL causes keepalive to be disabled in http1client. is this what we intended? */\n    }\n\n    /* switch to using pipe reader, if the opportunity is provided */\n    if (args->pipe_reader != NULL) {\n#ifdef __linux__\n        if (pipe2(self->pipe_reader.fds, O_NONBLOCK | O_CLOEXEC) != 0) {\n            char errbuf[256];\n            h2o_fatal(\"pipe2(2) failed:%s\", h2o_strerror_r(errno, errbuf, sizeof(errbuf)));\n        }\n        args->pipe_reader->fd = self->pipe_reader.fds[1];\n        args->pipe_reader->on_body_piped = on_body_piped;\n#endif\n    }\n\n    /* if httpclient has no received body at this time, immediately send only headers using zero timeout */\n    h2o_timer_link(req->conn->ctx->loop, 0, &self->send_headers_timeout);\n\n    return on_body;\n}\n\nstatic int on_1xx(h2o_httpclient_t *client, int version, int status, h2o_iovec_t msg, h2o_header_t *headers, size_t num_headers)\n{\n    struct rp_generator_t *self = client->data;\n    size_t i;\n\n    for (i = 0; i != num_headers; ++i) {\n        if (headers[i].name == &H2O_TOKEN_LINK->buf)\n            h2o_push_path_in_link_header(self->src_req, headers[i].value.base, headers[i].value.len);\n    }\n\n    if (status != 101) {\n        self->src_req->res.status = status;\n        self->src_req->res.headers = (h2o_headers_t){headers, num_headers, num_headers};\n        h2o_send_informational(self->src_req);\n    }\n\n    return 0;\n}\n\nstatic void proceed_request(h2o_httpclient_t *client, const char *errstr)\n{\n    struct rp_generator_t *self = client->data;\n    if (self == NULL)\n        return;\n    if (errstr != NULL)\n        detach_client(self);\n    if (self->src_req->proceed_req != NULL)\n        self->src_req->proceed_req(self->src_req, errstr);\n}\n\nstatic int write_req(void *ctx, int is_end_stream)\n{\n    struct rp_generator_t *self = ctx;\n    h2o_httpclient_t *client = self->client;\n    h2o_iovec_t chunk = self->src_req->entity;\n\n    assert(chunk.len != 0 || is_end_stream);\n\n    if (client == NULL) {\n        return -1;\n    }\n\n    if (is_end_stream) {\n        self->src_req->write_req.cb = NULL;\n        self->req_done = 1;\n        if (self->res_done)\n            detach_client(self);\n    }\n\n    return client->write_req(client, chunk, is_end_stream);\n}\n\nstatic h2o_httpclient_head_cb on_connect(h2o_httpclient_t *client, const char *errstr, h2o_iovec_t *method, h2o_url_t *url,\n                                         const h2o_header_t **headers, size_t *num_headers, h2o_iovec_t *body,\n                                         h2o_httpclient_proceed_req_cb *proceed_req_cb, h2o_httpclient_properties_t *props,\n                                         h2o_url_t *origin)\n{\n    struct rp_generator_t *self = client->data;\n    h2o_req_t *req = self->src_req;\n    int use_proxy_protocol = 0, reprocess_if_too_early = 0;\n\n    copy_stats(self);\n\n    if (errstr != NULL) {\n        detach_client(self);\n        h2o_req_log_error(self->src_req, \"lib/core/proxy.c\", \"%s\", errstr);\n        h2o_send_error_502(self->src_req, \"Gateway Error\", errstr, 0);\n        return NULL;\n    }\n\n    assert(origin != NULL);\n\n    if (req->overrides != NULL) {\n        use_proxy_protocol = req->overrides->use_proxy_protocol;\n        req->overrides->location_rewrite.match = origin;\n        if (!req->overrides->proxy_preserve_host) {\n            req->scheme = origin->scheme;\n            req->authority = origin->authority;\n        }\n        h2o_iovec_t append = req->path;\n        if (origin->path.base[origin->path.len - 1] == '/' && append.base[0] == '/') {\n            append.base += 1;\n            append.len -= 1;\n        }\n        req->path = h2o_concat(&req->pool, origin->path, append);\n        req->path_normalized =\n            h2o_url_normalize_path(&req->pool, req->path.base, req->path.len, &req->query_at, &req->norm_indexes);\n    }\n\n    reprocess_if_too_early = h2o_conn_is_early_data(req->conn);\n    h2o_headers_t headers_vec = (h2o_headers_t){NULL};\n    build_request(req, method, url, &headers_vec, props,\n                  !use_proxy_protocol && h2o_socketpool_can_keepalive(client->connpool->socketpool), self->client->upgrade_to,\n                  use_proxy_protocol, &reprocess_if_too_early, origin);\n    *headers = headers_vec.entries;\n    *num_headers = headers_vec.size;\n\n    if (reprocess_if_too_early)\n        req->reprocess_if_too_early = 1;\n\n    *body = h2o_iovec_init(NULL, 0);\n    *proceed_req_cb = NULL;\n    self->req_done = 1;\n    if (self->src_req->entity.base != NULL) {\n        *body = self->src_req->entity;\n        if (self->src_req->proceed_req != NULL) {\n            *proceed_req_cb = proceed_request;\n            self->src_req->write_req.cb = write_req;\n            self->src_req->write_req.ctx = self;\n            self->req_done = 0;\n        }\n    }\n    self->client->informational_cb = on_1xx;\n\n    client->get_conn_properties(client, &req->proxy_stats.conn);\n\n    { /* indicate to httpclient if use of pipe is preferred */\n        h2o_conn_t *conn = self->src_req->conn;\n        switch (conn->ctx->globalconf->proxy.zerocopy) {\n        case H2O_PROXY_ZEROCOPY_ALWAYS:\n            props->prefer_pipe_reader = 1;\n            break;\n        case H2O_PROXY_ZEROCOPY_ENABLED:\n            if (conn->callbacks->can_zerocopy != NULL && conn->callbacks->can_zerocopy(conn))\n                props->prefer_pipe_reader = 1;\n            break;\n        default:\n            break;\n        }\n    }\n\n    return on_head;\n}\n\nstatic void on_generator_dispose(void *_self)\n{\n    struct rp_generator_t *self = _self;\n    do_close(self);\n\n    if (self->last_content_before_send != NULL) {\n        h2o_buffer_dispose(&self->last_content_before_send);\n    }\n    h2o_doublebuffer_dispose(&self->sending);\n    if (self->generator_disposed != NULL)\n        *self->generator_disposed = 1;\n}\n\nstatic struct rp_generator_t *proxy_send_prepare(h2o_req_t *req)\n{\n    struct rp_generator_t *self = h2o_mem_alloc_shared(&req->pool, sizeof(*self), on_generator_dispose);\n\n    self->super.proceed = do_proceed;\n    self->super.stop = do_stop;\n    self->src_req = req;\n    self->generator_disposed = NULL;\n    self->client = NULL; /* when connection establish timeouts, self->client remains unset by `h2o_httpclient_connect` */\n    self->had_body_error = 0;\n    self->up_req.is_head = h2o_memis(req->method.base, req->method.len, H2O_STRLIT(\"HEAD\"));\n    self->last_content_before_send = NULL;\n    h2o_doublebuffer_init(&self->sending, &h2o_socket_buffer_prototype);\n    memset(&req->proxy_stats, 0, sizeof(req->proxy_stats));\n    h2o_timer_init(&self->send_headers_timeout, on_send_headers_timeout);\n    self->body_bytes_read = 0;\n    self->body_bytes_sent = 0;\n    self->pipe_reader.fds[0] = -1;\n    self->pipe_inflight = 0;\n    self->req_done = 0;\n    self->res_done = 0;\n\n    return self;\n}\n\nvoid h2o__proxy_process_request(h2o_req_t *req)\n{\n    h2o_req_overrides_t *overrides = req->overrides;\n    h2o_httpclient_ctx_t *client_ctx = get_client_ctx(req);\n    h2o_url_t target_buf, *target = &target_buf;\n\n    h2o_httpclient_connection_pool_t *connpool = &req->conn->ctx->proxy.connpool;\n    if (overrides != NULL && overrides->connpool != NULL) {\n        connpool = overrides->connpool;\n        if (!overrides->proxy_preserve_host)\n            target = NULL;\n    }\n    if (target == &target_buf && h2o_url_init(&target_buf, req->scheme, req->authority, h2o_iovec_init(H2O_STRLIT(\"/\"))) != 0) {\n        h2o_send_error_400(req, \"Invalid Request\", \"Invalid Request\", H2O_SEND_ERROR_HTTP1_CLOSE_CONNECTION);\n        return;\n    }\n\n    const char *upgrade_to = NULL;\n    if (req->is_tunnel_req) {\n        if (req->upgrade.base != NULL) {\n            /* upgrade requests (e.g. websocket) are either tunnelled or converted to a normal request (by omitting the Upgrade\n             * header field)  depending on the configuration */\n            if (client_ctx->tunnel_enabled)\n                upgrade_to = h2o_strdup(&req->pool, req->upgrade.base, req->upgrade.len).base;\n        } else {\n            /* CONNECT request; process as a CONNECT upgrade or reject */\n            if (client_ctx->tunnel_enabled) {\n                upgrade_to = h2o_httpclient_upgrade_to_connect;\n            } else {\n                h2o_send_error_405(req, \"Method Not Allowed\", \"refusing CONNECT\", H2O_SEND_ERROR_HTTP1_CLOSE_CONNECTION);\n                return;\n            }\n        }\n    }\n    struct rp_generator_t *self = proxy_send_prepare(req);\n\n    /*\n      When the PROXY protocol is being used (i.e. when overrides->use_proxy_protocol is set), the client needs to establish a new\n     connection even when there is a pooled connection to the peer, since the header (as defined in\n     https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt) needs to be sent at the beginning of the connection.\n\n     However, currently h2o_http1client_connect doesn't provide an interface to enforce estabilishing a new connection. In other\n     words, there is a chance that we would use a pool connection here.\n\n     OTOH, the probability of seeing such issue is rare; it would only happen if the same destination identified by its host:port is\n     accessed in both ways (i.e. in one path with use_proxy_protocol set and in the other path without).\n\n     So I leave this as it is for the time being.\n     */\n    h2o_httpclient_connect(&self->client, &req->pool, self, client_ctx, connpool, target, upgrade_to, on_connect);\n}\n"], "filenames": ["lib/core/proxy.c"], "buggy_code_start_loc": [168], "buggy_code_end_loc": [866], "fixing_code_start_loc": [168], "fixing_code_end_loc": [869], "type": "CWE-824", "message": "H2O is an HTTP server. In versions 2.3.0-beta2 and prior, when the reverse proxy handler tries to processes a certain type of invalid HTTP request, it tries to build an upstream URL by reading from uninitialized pointer. This behavior can lead to crashes or leak of information to back end HTTP servers. Pull request  number 3229 fixes the issue. The pull request has been merged to the `master` branch in commit f010336. Users should upgrade to commit f010336 or later.", "other": {"cve": {"id": "CVE-2023-30847", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-27T15:15:13.833", "lastModified": "2023-05-09T18:21:39.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "H2O is an HTTP server. In versions 2.3.0-beta2 and prior, when the reverse proxy handler tries to processes a certain type of invalid HTTP request, it tries to build an upstream URL by reading from uninitialized pointer. This behavior can lead to crashes or leak of information to back end HTTP servers. Pull request  number 3229 fixes the issue. The pull request has been merged to the `master` branch in commit f010336. Users should upgrade to commit f010336 or later."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dena:h2o:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.6", "matchCriteriaId": "3C540EDB-1F68-47E9-A457-B6BC1EB805D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dena:h2o:2.3.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "128D1D5E-4E71-4ABB-B580-F17E2B74B5F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dena:h2o:2.3.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "E69DE676-300A-4A95-A04D-7463CA372799"}]}]}], "references": [{"url": "https://github.com/h2o/h2o/commit/f010336bab162839df43d9e87570897466c97e33", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/h2o/h2o/pull/3229", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/h2o/h2o/security/advisories/GHSA-p5hj-phwj-hrvx", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/h2o/h2o/commit/f010336bab162839df43d9e87570897466c97e33"}}