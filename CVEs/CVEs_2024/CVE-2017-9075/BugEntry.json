{"buggy_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2002, 2004\n * Copyright (c) 2001 Nokia, Inc.\n * Copyright (c) 2001 La Monte H.P. Yarroll\n * Copyright (c) 2002-2003 Intel Corp.\n *\n * This file is part of the SCTP kernel implementation\n *\n * SCTP over IPv6.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *\t\t   ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    Le Yanqun\t\t    <yanqun.le@nokia.com>\n *    Hui Huang\t\t    <hui.huang@nokia.com>\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Sridhar Samudrala\t    <sri@us.ibm.com>\n *    Jon Grimm\t\t    <jgrimm@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *\n * Based on:\n *\tlinux/net/ipv6/tcp_ipv6.c\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/ipsec.h>\n#include <linux/slab.h>\n\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n\n#include <net/protocol.h>\n#include <net/ndisc.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/inet_common.h>\n#include <net/inet_ecn.h>\n#include <net/sctp/sctp.h>\n\n#include <linux/uaccess.h>\n\nstatic inline int sctp_v6_addr_match_len(union sctp_addr *s1,\n\t\t\t\t\t union sctp_addr *s2);\nstatic void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,\n\t\t\t      __be16 port);\nstatic int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2);\n\n/* Event handler for inet6 address addition/deletion events.\n * The sctp_local_addr_list needs to be protocted by a spin lock since\n * multiple notifiers (say IPv4 and IPv6) may be running at the same\n * time and thus corrupt the list.\n * The reader side is protected with RCU.\n */\nstatic int sctp_inet6addr_event(struct notifier_block *this, unsigned long ev,\n\t\t\t\tvoid *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct sctp_sockaddr_entry *addr = NULL;\n\tstruct sctp_sockaddr_entry *temp;\n\tstruct net *net = dev_net(ifa->idev->dev);\n\tint found = 0;\n\n\tswitch (ev) {\n\tcase NETDEV_UP:\n\t\taddr = kmalloc(sizeof(struct sctp_sockaddr_entry), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v6.sin6_family = AF_INET6;\n\t\t\taddr->a.v6.sin6_port = 0;\n\t\t\taddr->a.v6.sin6_addr = ifa->addr;\n\t\t\taddr->a.v6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\t\taddr->valid = 1;\n\t\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\t\tlist_add_tail_rcu(&addr->list, &net->sctp.local_addr_list);\n\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_NEW);\n\t\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\tlist_for_each_entry_safe(addr, temp,\n\t\t\t\t\t&net->sctp.local_addr_list, list) {\n\t\t\tif (addr->a.sa.sa_family == AF_INET6 &&\n\t\t\t\t\tipv6_addr_equal(&addr->a.v6.sin6_addr,\n\t\t\t\t\t\t&ifa->addr)) {\n\t\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_DEL);\n\t\t\t\tfound = 1;\n\t\t\t\taddr->valid = 0;\n\t\t\t\tlist_del_rcu(&addr->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\tif (found)\n\t\t\tkfree_rcu(addr, rcu);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sctp_inet6addr_notifier = {\n\t.notifier_call = sctp_inet6addr_event,\n};\n\n/* ICMP error handler. */\nstatic void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tstruct inet6_dev *idev;\n\tstruct sock *sk;\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *transport;\n\tstruct ipv6_pinfo *np;\n\t__u16 saveip, savesctp;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tidev = in6_dev_get(skb->dev);\n\n\t/* Fix up skb to look at the embedded net header. */\n\tsaveip\t = skb->network_header;\n\tsavesctp = skb->transport_header;\n\tskb_reset_network_header(skb);\n\tskb_set_transport_header(skb, offset);\n\tsk = sctp_err_lookup(net, AF_INET6, skb, sctp_hdr(skb), &asoc, &transport);\n\t/* Put back, the original pointers. */\n\tskb->network_header   = saveip;\n\tskb->transport_header = savesctp;\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, idev, ICMP6_MIB_INERRORS);\n\t\tgoto out;\n\t}\n\n\t/* Warning:  The sock lock is held.  Remember to call\n\t * sctp_err_finish!\n\t */\n\n\tswitch (type) {\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tif (ip6_sk_accept_pmtu(sk))\n\t\t\tsctp_icmp_frag_needed(sk, asoc, transport, ntohl(info));\n\t\tgoto out_unlock;\n\tcase ICMPV6_PARAMPROB:\n\t\tif (ICMPV6_UNK_NEXTHDR == code) {\n\t\t\tsctp_icmp_proto_unreachable(sk, asoc, transport);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tcase NDISC_REDIRECT:\n\t\tsctp_icmp_redirect(sk, transport, skb);\n\t\tgoto out_unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnp = inet6_sk(sk);\n\ticmpv6_err_convert(type, code, &err);\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else {  /* Only an error on timeout */\n\t\tsk->sk_err_soft = err;\n\t}\n\nout_unlock:\n\tsctp_err_finish(sk, transport);\nout:\n\tif (likely(idev != NULL))\n\t\tin6_dev_put(idev);\n}\n\nstatic int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n\tint res;\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6->saddr, &fl6->daddr);\n\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->ignore_df = 1;\n\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\trcu_read_lock();\n\tres = ip6_xmit(sk, skb, fl6, sk->sk_mark, rcu_dereference(np->opt),\n\t\t       np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}\n\n/* Returns the dst cache entry for the given source and destination ip\n * addresses.\n */\nstatic void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n\t\t\t    struct flowi *fl, struct sock *sk)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sctp_bind_addr *bp;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sctp_sockaddr_entry *laddr;\n\tunion sctp_addr *daddr = &t->ipaddr;\n\tunion sctp_addr dst_saddr;\n\tstruct in6_addr *final_p, final;\n\t__u8 matchlen = 0;\n\tsctp_scope_t scope;\n\n\tmemset(fl6, 0, sizeof(struct flowi6));\n\tfl6->daddr = daddr->v6.sin6_addr;\n\tfl6->fl6_dport = daddr->v6.sin6_port;\n\tfl6->flowi6_proto = IPPROTO_SCTP;\n\tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;\n\n\tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);\n\n\tif (asoc)\n\t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);\n\n\tif (saddr) {\n\t\tfl6->saddr = saddr->v6.sin6_addr;\n\t\tfl6->fl6_sport = saddr->v6.sin6_port;\n\n\t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);\n\t}\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (!asoc || saddr)\n\t\tgoto out;\n\n\tbp = &asoc->base.bind_addr;\n\tscope = sctp_scope(daddr);\n\t/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check\n\t * to see if we can use it.\n\t */\n\tif (!IS_ERR(dst)) {\n\t\t/* Walk through the bind address list and look for a bind\n\t\t * address that matches the source address of the returned dst.\n\t\t */\n\t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\t\tif (!laddr->valid || laddr->state == SCTP_ADDR_DEL ||\n\t\t\t    (laddr->state != SCTP_ADDR_SRC &&\n\t\t\t     !asoc->src_out_of_asoc_ok))\n\t\t\t\tcontinue;\n\n\t\t\t/* Do not compare against v4 addrs */\n\t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&\n\t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\t/* None of the bound addresses match the source address of the\n\t\t * dst. So release it.\n\t\t */\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\n\t/* Walk through the bind address list and try to get the\n\t * best source address for a given destination.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tstruct dst_entry *bdst;\n\t\t__u8 bmatchlen;\n\n\t\tif (!laddr->valid ||\n\t\t    laddr->state != SCTP_ADDR_SRC ||\n\t\t    laddr->a.sa.sa_family != AF_INET6 ||\n\t\t    scope > sctp_scope(&laddr->a))\n\t\t\tcontinue;\n\n\t\tfl6->saddr = laddr->a.v6.sin6_addr;\n\t\tfl6->fl6_sport = laddr->a.v6.sin6_port;\n\t\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\t\tbdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\n\t\tif (!IS_ERR(bdst) &&\n\t\t    ipv6_chk_addr(dev_net(bdst->dev),\n\t\t\t\t  &laddr->a.v6.sin6_addr, bdst->dev, 1)) {\n\t\t\tif (!IS_ERR_OR_NULL(dst))\n\t\t\t\tdst_release(dst);\n\t\t\tdst = bdst;\n\t\t\tbreak;\n\t\t}\n\n\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);\n\t\tif (matchlen > bmatchlen)\n\t\t\tcontinue;\n\n\t\tif (!IS_ERR_OR_NULL(dst))\n\t\t\tdst_release(dst);\n\t\tdst = bdst;\n\t\tmatchlen = bmatchlen;\n\t}\n\trcu_read_unlock();\n\nout:\n\tif (!IS_ERR_OR_NULL(dst)) {\n\t\tstruct rt6_info *rt;\n\n\t\trt = (struct rt6_info *)dst;\n\t\tt->dst = dst;\n\t\tt->dst_cookie = rt6_get_cookie(rt);\n\t\tpr_debug(\"rt6_dst:%pI6/%d rt6_src:%pI6\\n\",\n\t\t\t &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n\t\t\t &fl6->saddr);\n\t} else {\n\t\tt->dst = NULL;\n\n\t\tpr_debug(\"no route\\n\");\n\t}\n}\n\n/* Returns the number of consecutive initial bits that match in the 2 ipv6\n * addresses.\n */\nstatic inline int sctp_v6_addr_match_len(union sctp_addr *s1,\n\t\t\t\t\t union sctp_addr *s2)\n{\n\treturn ipv6_addr_diff(&s1->v6.sin6_addr, &s2->v6.sin6_addr);\n}\n\n/* Fills in the source address(saddr) based on the destination address(daddr)\n * and asoc's bind address list.\n */\nstatic void sctp_v6_get_saddr(struct sctp_sock *sk,\n\t\t\t      struct sctp_transport *t,\n\t\t\t      struct flowi *fl)\n{\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tunion sctp_addr *saddr = &t->saddr;\n\n\tpr_debug(\"%s: asoc:%p dst:%p\\n\", __func__, t->asoc, t->dst);\n\n\tif (t->dst) {\n\t\tsaddr->v6.sin6_family = AF_INET6;\n\t\tsaddr->v6.sin6_addr = fl6->saddr;\n\t}\n}\n\n/* Make a copy of all potential local addresses. */\nstatic void sctp_v6_copy_addrlist(struct list_head *addrlist,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct inet6_dev *in6_dev;\n\tstruct inet6_ifaddr *ifp;\n\tstruct sctp_sockaddr_entry *addr;\n\n\trcu_read_lock();\n\tif ((in6_dev = __in6_dev_get(dev)) == NULL) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tread_lock_bh(&in6_dev->lock);\n\tlist_for_each_entry(ifp, &in6_dev->addr_list, if_list) {\n\t\t/* Add the address to the local list.  */\n\t\taddr = kzalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v6.sin6_family = AF_INET6;\n\t\t\taddr->a.v6.sin6_port = 0;\n\t\t\taddr->a.v6.sin6_addr = ifp->addr;\n\t\t\taddr->a.v6.sin6_scope_id = dev->ifindex;\n\t\t\taddr->valid = 1;\n\t\t\tINIT_LIST_HEAD(&addr->list);\n\t\t\tlist_add_tail(&addr->list, addrlist);\n\t\t}\n\t}\n\n\tread_unlock_bh(&in6_dev->lock);\n\trcu_read_unlock();\n}\n\n/* Initialize a sockaddr_storage from in incoming skb. */\nstatic void sctp_v6_from_skb(union sctp_addr *addr, struct sk_buff *skb,\n\t\t\t     int is_saddr)\n{\n\t/* Always called on head skb, so this is safe */\n\tstruct sctphdr *sh = sctp_hdr(skb);\n\tstruct sockaddr_in6 *sa = &addr->v6;\n\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_flowinfo = 0; /* FIXME */\n\taddr->v6.sin6_scope_id = ((struct inet6_skb_parm *)skb->cb)->iif;\n\n\tif (is_saddr) {\n\t\tsa->sin6_port = sh->source;\n\t\tsa->sin6_addr = ipv6_hdr(skb)->saddr;\n\t} else {\n\t\tsa->sin6_port = sh->dest;\n\t\tsa->sin6_addr = ipv6_hdr(skb)->daddr;\n\t}\n}\n\n/* Initialize an sctp_addr from a socket. */\nstatic void sctp_v6_from_sk(union sctp_addr *addr, struct sock *sk)\n{\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = 0;\n\taddr->v6.sin6_addr = sk->sk_v6_rcv_saddr;\n}\n\n/* Initialize sk->sk_rcv_saddr from sctp_addr. */\nstatic void sctp_v6_to_sk_saddr(union sctp_addr *addr, struct sock *sk)\n{\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[0] = 0;\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[1] = 0;\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[2] = htonl(0x0000ffff);\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[3] =\n\t\t\taddr->v4.sin_addr.s_addr;\n\t} else {\n\t\tsk->sk_v6_rcv_saddr = addr->v6.sin6_addr;\n\t}\n}\n\n/* Initialize sk->sk_daddr from sctp_addr. */\nstatic void sctp_v6_to_sk_daddr(union sctp_addr *addr, struct sock *sk)\n{\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsk->sk_v6_daddr.s6_addr32[0] = 0;\n\t\tsk->sk_v6_daddr.s6_addr32[1] = 0;\n\t\tsk->sk_v6_daddr.s6_addr32[2] = htonl(0x0000ffff);\n\t\tsk->sk_v6_daddr.s6_addr32[3] = addr->v4.sin_addr.s_addr;\n\t} else {\n\t\tsk->sk_v6_daddr = addr->v6.sin6_addr;\n\t}\n}\n\n/* Initialize a sctp_addr from an address parameter. */\nstatic void sctp_v6_from_addr_param(union sctp_addr *addr,\n\t\t\t\t    union sctp_addr_param *param,\n\t\t\t\t    __be16 port, int iif)\n{\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_flowinfo = 0; /* BUG */\n\taddr->v6.sin6_addr = param->v6.addr;\n\taddr->v6.sin6_scope_id = iif;\n}\n\n/* Initialize an address parameter from a sctp_addr and return the length\n * of the address parameter.\n */\nstatic int sctp_v6_to_addr_param(const union sctp_addr *addr,\n\t\t\t\t union sctp_addr_param *param)\n{\n\tint length = sizeof(sctp_ipv6addr_param_t);\n\n\tparam->v6.param_hdr.type = SCTP_PARAM_IPV6_ADDRESS;\n\tparam->v6.param_hdr.length = htons(length);\n\tparam->v6.addr = addr->v6.sin6_addr;\n\n\treturn length;\n}\n\n/* Initialize a sctp_addr from struct in6_addr. */\nstatic void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,\n\t\t\t      __be16 port)\n{\n\taddr->sa.sa_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_addr = *saddr;\n}\n\n/* Compare addresses exactly.\n * v4-mapped-v6 is also in consideration.\n */\nstatic int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2)\n{\n\tif (addr1->sa.sa_family != addr2->sa.sa_family) {\n\t\tif (addr1->sa.sa_family == AF_INET &&\n\t\t    addr2->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr2->v6.sin6_addr)) {\n\t\t\tif (addr2->v6.sin6_port == addr1->v4.sin_port &&\n\t\t\t    addr2->v6.sin6_addr.s6_addr32[3] ==\n\t\t\t    addr1->v4.sin_addr.s_addr)\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (addr2->sa.sa_family == AF_INET &&\n\t\t    addr1->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr1->v6.sin6_addr)) {\n\t\t\tif (addr1->v6.sin6_port == addr2->v4.sin_port &&\n\t\t\t    addr1->v6.sin6_addr.s6_addr32[3] ==\n\t\t\t    addr2->v4.sin_addr.s_addr)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (addr1->v6.sin6_port != addr2->v6.sin6_port)\n\t\treturn 0;\n\tif (!ipv6_addr_equal(&addr1->v6.sin6_addr, &addr2->v6.sin6_addr))\n\t\treturn 0;\n\t/* If this is a linklocal address, compare the scope_id. */\n\tif (ipv6_addr_type(&addr1->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr1->v6.sin6_scope_id && addr2->v6.sin6_scope_id &&\n\t\t    (addr1->v6.sin6_scope_id != addr2->v6.sin6_scope_id)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/* Initialize addr struct to INADDR_ANY. */\nstatic void sctp_v6_inaddr_any(union sctp_addr *addr, __be16 port)\n{\n\tmemset(addr, 0x00, sizeof(union sctp_addr));\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n}\n\n/* Is this a wildcard address? */\nstatic int sctp_v6_is_any(const union sctp_addr *addr)\n{\n\treturn ipv6_addr_any(&addr->v6.sin6_addr);\n}\n\n/* Should this be available for binding?   */\nstatic int sctp_v6_available(union sctp_addr *addr, struct sctp_sock *sp)\n{\n\tint type;\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tconst struct in6_addr *in6 = (const struct in6_addr *)&addr->v6.sin6_addr;\n\n\ttype = ipv6_addr_type(in6);\n\tif (IPV6_ADDR_ANY == type)\n\t\treturn 1;\n\tif (type == IPV6_ADDR_MAPPED) {\n\t\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 0;\n\t\tsctp_v6_map_v4(addr);\n\t\treturn sctp_get_af_specific(AF_INET)->available(addr, sp);\n\t}\n\tif (!(type & IPV6_ADDR_UNICAST))\n\t\treturn 0;\n\n\treturn sp->inet.freebind || net->ipv6.sysctl.ip_nonlocal_bind ||\n\t\tipv6_chk_addr(net, in6, NULL, 0);\n}\n\n/* This function checks if the address is a valid address to be used for\n * SCTP.\n *\n * Output:\n * Return 0 - If the address is a non-unicast or an illegal address.\n * Return 1 - If the address is a unicast.\n */\nstatic int sctp_v6_addr_valid(union sctp_addr *addr,\n\t\t\t      struct sctp_sock *sp,\n\t\t\t      const struct sk_buff *skb)\n{\n\tint ret = ipv6_addr_type(&addr->v6.sin6_addr);\n\n\t/* Support v4-mapped-v6 address. */\n\tif (ret == IPV6_ADDR_MAPPED) {\n\t\t/* Note: This routine is used in input, so v4-mapped-v6\n\t\t * are disallowed here when there is no sctp_sock.\n\t\t */\n\t\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 0;\n\t\tsctp_v6_map_v4(addr);\n\t\treturn sctp_get_af_specific(AF_INET)->addr_valid(addr, sp, skb);\n\t}\n\n\t/* Is this a non-unicast address */\n\tif (!(ret & IPV6_ADDR_UNICAST))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* What is the scope of 'addr'?  */\nstatic sctp_scope_t sctp_v6_scope(union sctp_addr *addr)\n{\n\tint v6scope;\n\tsctp_scope_t retval;\n\n\t/* The IPv6 scope is really a set of bit fields.\n\t * See IFA_* in <net/if_inet6.h>.  Map to a generic SCTP scope.\n\t */\n\n\tv6scope = ipv6_addr_scope(&addr->v6.sin6_addr);\n\tswitch (v6scope) {\n\tcase IFA_HOST:\n\t\tretval = SCTP_SCOPE_LOOPBACK;\n\t\tbreak;\n\tcase IFA_LINK:\n\t\tretval = SCTP_SCOPE_LINK;\n\t\tbreak;\n\tcase IFA_SITE:\n\t\tretval = SCTP_SCOPE_PRIVATE;\n\t\tbreak;\n\tdefault:\n\t\tretval = SCTP_SCOPE_GLOBAL;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/* Create and initialize a new sk for the socket to be returned by accept(). */\nstatic struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\tstruct ipv6_txoptions *opt;\n\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\n\tsock_init_data(NULL, newsk);\n\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\topt = ipv6_dup_options(newsk, opt);\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n\n\t/* Initialize sk's sport, dport, rcv_saddr and daddr for getsockname()\n\t * and getpeername().\n\t */\n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\n\tsk_refcnt_debug_inc(newsk);\n\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\n\nout:\n\treturn newsk;\n}\n\n/* Format a sockaddr for return to user space. This makes sure the return is\n * AF_INET or AF_INET6 depending on the SCTP_I_WANT_MAPPED_V4_ADDR option.\n */\nstatic int sctp_v6_addr_to_user(struct sctp_sock *sp, union sctp_addr *addr)\n{\n\tif (sp->v4mapped) {\n\t\tif (addr->sa.sa_family == AF_INET)\n\t\t\tsctp_v4_map_v6(addr);\n\t} else {\n\t\tif (addr->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr->v6.sin6_addr))\n\t\t\tsctp_v6_map_v4(addr);\n\t}\n\n\tif (addr->sa.sa_family == AF_INET)\n\t\treturn sizeof(struct sockaddr_in);\n\treturn sizeof(struct sockaddr_in6);\n}\n\n/* Where did this skb come from?  */\nstatic int sctp_v6_skb_iif(const struct sk_buff *skb)\n{\n\treturn IP6CB(skb)->iif;\n}\n\n/* Was this packet marked by Explicit Congestion Notification? */\nstatic int sctp_v6_is_ce(const struct sk_buff *skb)\n{\n\treturn *((__u32 *)(ipv6_hdr(skb))) & htonl(1 << 20);\n}\n\n/* Dump the v6 addr to the seq file. */\nstatic void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)\n{\n\tseq_printf(seq, \"%pI6 \", &addr->v6.sin6_addr);\n}\n\nstatic void sctp_v6_ecn_capable(struct sock *sk)\n{\n\tinet6_sk(sk)->tclass |= INET_ECN_ECT_0;\n}\n\n/* Initialize a PF_INET msgname from a ulpevent. */\nstatic void sctp_inet6_event_msgname(struct sctp_ulpevent *event,\n\t\t\t\t     char *msgname, int *addrlen)\n{\n\tunion sctp_addr *addr;\n\tstruct sctp_association *asoc;\n\tunion sctp_addr *paddr;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tasoc = event->asoc;\n\tpaddr = &asoc->peer.primary_addr;\n\n\tif (paddr->sa.sa_family == AF_INET) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = htons(asoc->peer.port);\n\t\taddr->v4.sin_addr = paddr->v4.sin_addr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\tif (ipv6_addr_type(&paddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\taddr->v6.sin6_scope_id = paddr->v6.sin6_scope_id;\n\t\telse\n\t\t\taddr->v6.sin6_scope_id = 0;\n\t\taddr->v6.sin6_port = htons(asoc->peer.port);\n\t\taddr->v6.sin6_addr = paddr->v6.sin6_addr;\n\t}\n\n\t*addrlen = sctp_v6_addr_to_user(sctp_sk(asoc->base.sk), addr);\n}\n\n/* Initialize a msg_name from an inbound skb. */\nstatic void sctp_inet6_skb_msgname(struct sk_buff *skb, char *msgname,\n\t\t\t\t   int *addr_len)\n{\n\tunion sctp_addr *addr;\n\tstruct sctphdr *sh;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tsh = sctp_hdr(skb);\n\n\tif (ip_hdr(skb)->version == 4) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = sh->source;\n\t\taddr->v4.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\taddr->v6.sin6_port = sh->source;\n\t\taddr->v6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tif (ipv6_addr_type(&addr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL) {\n\t\t\taddr->v6.sin6_scope_id = sctp_v6_skb_iif(skb);\n\t\t}\n\t}\n\n\t*addr_len = sctp_v6_addr_to_user(sctp_sk(skb->sk), addr);\n}\n\n/* Do we support this AF? */\nstatic int sctp_inet6_af_supported(sa_family_t family, struct sctp_sock *sp)\n{\n\tswitch (family) {\n\tcase AF_INET6:\n\t\treturn 1;\n\t/* v4-mapped-v6 addresses */\n\tcase AF_INET:\n\t\tif (!__ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/* Address matching with wildcards allowed.  This extra level\n * of indirection lets us choose whether a PF_INET6 should\n * disallow any v4 addresses if we so choose.\n */\nstatic int sctp_inet6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t       const union sctp_addr *addr2,\n\t\t\t       struct sctp_sock *opt)\n{\n\tstruct sctp_af *af1, *af2;\n\tstruct sock *sk = sctp_opt2sk(opt);\n\n\taf1 = sctp_get_af_specific(addr1->sa.sa_family);\n\taf2 = sctp_get_af_specific(addr2->sa.sa_family);\n\n\tif (!af1 || !af2)\n\t\treturn 0;\n\n\t/* If the socket is IPv6 only, v4 addrs will not match */\n\tif (__ipv6_only_sock(sk) && af1 != af2)\n\t\treturn 0;\n\n\t/* Today, wildcard AF_INET/AF_INET6. */\n\tif (sctp_is_any(sk, addr1) || sctp_is_any(sk, addr2))\n\t\treturn 1;\n\n\tif (addr1->sa.sa_family != addr2->sa.sa_family)\n\t\treturn 0;\n\n\treturn af1->cmp_addr(addr1, addr2);\n}\n\n/* Verify that the provided sockaddr looks bindable.   Common verification,\n * has already been taken care of.\n */\nstatic int sctp_inet6_bind_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\tstruct sctp_af *af;\n\n\t/* ASSERT: address family has already been verified. */\n\tif (addr->sa.sa_family != AF_INET6)\n\t\taf = sctp_get_af_specific(addr->sa.sa_family);\n\telse {\n\t\tint type = ipv6_addr_type(&addr->v6.sin6_addr);\n\t\tstruct net_device *dev;\n\n\t\tif (type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tstruct net *net;\n\t\t\tif (!addr->v6.sin6_scope_id)\n\t\t\t\treturn 0;\n\t\t\tnet = sock_net(&opt->inet.sk);\n\t\t\trcu_read_lock();\n\t\t\tdev = dev_get_by_index_rcu(net, addr->v6.sin6_scope_id);\n\t\t\tif (!dev ||\n\t\t\t    !ipv6_chk_addr(net, &addr->v6.sin6_addr, dev, 0)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\taf = opt->pf->af;\n\t}\n\treturn af->available(addr, opt);\n}\n\n/* Verify that the provided sockaddr looks sendable.   Common verification,\n * has already been taken care of.\n */\nstatic int sctp_inet6_send_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\tstruct sctp_af *af = NULL;\n\n\t/* ASSERT: address family has already been verified. */\n\tif (addr->sa.sa_family != AF_INET6)\n\t\taf = sctp_get_af_specific(addr->sa.sa_family);\n\telse {\n\t\tint type = ipv6_addr_type(&addr->v6.sin6_addr);\n\t\tstruct net_device *dev;\n\n\t\tif (type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (!addr->v6.sin6_scope_id)\n\t\t\t\treturn 0;\n\t\t\trcu_read_lock();\n\t\t\tdev = dev_get_by_index_rcu(sock_net(&opt->inet.sk),\n\t\t\t\t\t\t   addr->v6.sin6_scope_id);\n\t\t\trcu_read_unlock();\n\t\t\tif (!dev)\n\t\t\t\treturn 0;\n\t\t}\n\t\taf = opt->pf->af;\n\t}\n\n\treturn af != NULL;\n}\n\n/* Fill in Supported Address Type information for INIT and INIT-ACK\n * chunks.   Note: In the future, we may want to look at sock options\n * to determine whether a PF_INET6 socket really wants to have IPV4\n * addresses.\n * Returns number of addresses supported.\n */\nstatic int sctp_inet6_supported_addrs(const struct sctp_sock *opt,\n\t\t\t\t      __be16 *types)\n{\n\ttypes[0] = SCTP_PARAM_IPV6_ADDRESS;\n\tif (!opt || !ipv6_only_sock(sctp_opt2sk(opt))) {\n\t\ttypes[1] = SCTP_PARAM_IPV4_ADDRESS;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\n/* Handle SCTP_I_WANT_MAPPED_V4_ADDR for getpeername() and getsockname() */\nstatic int sctp_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tint rc;\n\n\trc = inet6_getname(sock, uaddr, uaddr_len, peer);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\t*uaddr_len = sctp_v6_addr_to_user(sctp_sk(sock->sk),\n\t\t\t\t\t  (union sctp_addr *)uaddr);\n\n\treturn rc;\n}\n\nstatic const struct proto_ops inet6_seqpacket_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = sctp_getname,\n\t.poll\t\t   = sctp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = sctp_inet_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw sctpv6_seqpacket_protosw = {\n\t.type          = SOCK_SEQPACKET,\n\t.protocol      = IPPROTO_SCTP,\n\t.prot \t       = &sctpv6_prot,\n\t.ops           = &inet6_seqpacket_ops,\n\t.flags         = SCTP_PROTOSW_FLAG\n};\nstatic struct inet_protosw sctpv6_stream_protosw = {\n\t.type          = SOCK_STREAM,\n\t.protocol      = IPPROTO_SCTP,\n\t.prot \t       = &sctpv6_prot,\n\t.ops           = &inet6_seqpacket_ops,\n\t.flags         = SCTP_PROTOSW_FLAG,\n};\n\nstatic int sctp6_rcv(struct sk_buff *skb)\n{\n\treturn sctp_rcv(skb) ? -1 : 0;\n}\n\nstatic const struct inet6_protocol sctpv6_protocol = {\n\t.handler      = sctp6_rcv,\n\t.err_handler  = sctp_v6_err,\n\t.flags        = INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic struct sctp_af sctp_af_inet6 = {\n\t.sa_family\t   = AF_INET6,\n\t.sctp_xmit\t   = sctp_v6_xmit,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.get_dst\t   = sctp_v6_get_dst,\n\t.get_saddr\t   = sctp_v6_get_saddr,\n\t.copy_addrlist\t   = sctp_v6_copy_addrlist,\n\t.from_skb\t   = sctp_v6_from_skb,\n\t.from_sk\t   = sctp_v6_from_sk,\n\t.from_addr_param   = sctp_v6_from_addr_param,\n\t.to_addr_param\t   = sctp_v6_to_addr_param,\n\t.cmp_addr\t   = sctp_v6_cmp_addr,\n\t.scope\t\t   = sctp_v6_scope,\n\t.addr_valid\t   = sctp_v6_addr_valid,\n\t.inaddr_any\t   = sctp_v6_inaddr_any,\n\t.is_any\t\t   = sctp_v6_is_any,\n\t.available\t   = sctp_v6_available,\n\t.skb_iif\t   = sctp_v6_skb_iif,\n\t.is_ce\t\t   = sctp_v6_is_ce,\n\t.seq_dump_addr\t   = sctp_v6_seq_dump_addr,\n\t.ecn_capable\t   = sctp_v6_ecn_capable,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\nstatic struct sctp_pf sctp_pf_inet6 = {\n\t.event_msgname = sctp_inet6_event_msgname,\n\t.skb_msgname   = sctp_inet6_skb_msgname,\n\t.af_supported  = sctp_inet6_af_supported,\n\t.cmp_addr      = sctp_inet6_cmp_addr,\n\t.bind_verify   = sctp_inet6_bind_verify,\n\t.send_verify   = sctp_inet6_send_verify,\n\t.supported_addrs = sctp_inet6_supported_addrs,\n\t.create_accept_sk = sctp_v6_create_accept_sk,\n\t.addr_to_user  = sctp_v6_addr_to_user,\n\t.to_sk_saddr   = sctp_v6_to_sk_saddr,\n\t.to_sk_daddr   = sctp_v6_to_sk_daddr,\n\t.af            = &sctp_af_inet6,\n};\n\n/* Initialize IPv6 support and register with socket layer.  */\nvoid sctp_v6_pf_init(void)\n{\n\t/* Register the SCTP specific PF_INET6 functions. */\n\tsctp_register_pf(&sctp_pf_inet6, PF_INET6);\n\n\t/* Register the SCTP specific AF_INET6 functions. */\n\tsctp_register_af(&sctp_af_inet6);\n}\n\nvoid sctp_v6_pf_exit(void)\n{\n\tlist_del(&sctp_af_inet6.list);\n}\n\n/* Initialize IPv6 support and register with socket layer.  */\nint sctp_v6_protosw_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&sctpv6_prot, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Add SCTPv6(UDP and TCP style) to inetsw6 linked list. */\n\tinet6_register_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_register_protosw(&sctpv6_stream_protosw);\n\n\treturn 0;\n}\n\nvoid sctp_v6_protosw_exit(void)\n{\n\tinet6_unregister_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_unregister_protosw(&sctpv6_stream_protosw);\n\tproto_unregister(&sctpv6_prot);\n}\n\n\n/* Register with inet6 layer. */\nint sctp_v6_add_protocol(void)\n{\n\t/* Register notifier for inet6 address additions/deletions. */\n\tregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n\n\tif (inet6_add_protocol(&sctpv6_protocol, IPPROTO_SCTP) < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\n/* Unregister with inet6 layer. */\nvoid sctp_v6_del_protocol(void)\n{\n\tinet6_del_protocol(&sctpv6_protocol, IPPROTO_SCTP);\n\tunregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n}\n"], "fixing_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2002, 2004\n * Copyright (c) 2001 Nokia, Inc.\n * Copyright (c) 2001 La Monte H.P. Yarroll\n * Copyright (c) 2002-2003 Intel Corp.\n *\n * This file is part of the SCTP kernel implementation\n *\n * SCTP over IPv6.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *\t\t   ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    Le Yanqun\t\t    <yanqun.le@nokia.com>\n *    Hui Huang\t\t    <hui.huang@nokia.com>\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Sridhar Samudrala\t    <sri@us.ibm.com>\n *    Jon Grimm\t\t    <jgrimm@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *\n * Based on:\n *\tlinux/net/ipv6/tcp_ipv6.c\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/ipsec.h>\n#include <linux/slab.h>\n\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n\n#include <net/protocol.h>\n#include <net/ndisc.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/inet_common.h>\n#include <net/inet_ecn.h>\n#include <net/sctp/sctp.h>\n\n#include <linux/uaccess.h>\n\nstatic inline int sctp_v6_addr_match_len(union sctp_addr *s1,\n\t\t\t\t\t union sctp_addr *s2);\nstatic void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,\n\t\t\t      __be16 port);\nstatic int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2);\n\n/* Event handler for inet6 address addition/deletion events.\n * The sctp_local_addr_list needs to be protocted by a spin lock since\n * multiple notifiers (say IPv4 and IPv6) may be running at the same\n * time and thus corrupt the list.\n * The reader side is protected with RCU.\n */\nstatic int sctp_inet6addr_event(struct notifier_block *this, unsigned long ev,\n\t\t\t\tvoid *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct sctp_sockaddr_entry *addr = NULL;\n\tstruct sctp_sockaddr_entry *temp;\n\tstruct net *net = dev_net(ifa->idev->dev);\n\tint found = 0;\n\n\tswitch (ev) {\n\tcase NETDEV_UP:\n\t\taddr = kmalloc(sizeof(struct sctp_sockaddr_entry), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v6.sin6_family = AF_INET6;\n\t\t\taddr->a.v6.sin6_port = 0;\n\t\t\taddr->a.v6.sin6_addr = ifa->addr;\n\t\t\taddr->a.v6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\t\taddr->valid = 1;\n\t\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\t\tlist_add_tail_rcu(&addr->list, &net->sctp.local_addr_list);\n\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_NEW);\n\t\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\tlist_for_each_entry_safe(addr, temp,\n\t\t\t\t\t&net->sctp.local_addr_list, list) {\n\t\t\tif (addr->a.sa.sa_family == AF_INET6 &&\n\t\t\t\t\tipv6_addr_equal(&addr->a.v6.sin6_addr,\n\t\t\t\t\t\t&ifa->addr)) {\n\t\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_DEL);\n\t\t\t\tfound = 1;\n\t\t\t\taddr->valid = 0;\n\t\t\t\tlist_del_rcu(&addr->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\tif (found)\n\t\t\tkfree_rcu(addr, rcu);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sctp_inet6addr_notifier = {\n\t.notifier_call = sctp_inet6addr_event,\n};\n\n/* ICMP error handler. */\nstatic void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tstruct inet6_dev *idev;\n\tstruct sock *sk;\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *transport;\n\tstruct ipv6_pinfo *np;\n\t__u16 saveip, savesctp;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tidev = in6_dev_get(skb->dev);\n\n\t/* Fix up skb to look at the embedded net header. */\n\tsaveip\t = skb->network_header;\n\tsavesctp = skb->transport_header;\n\tskb_reset_network_header(skb);\n\tskb_set_transport_header(skb, offset);\n\tsk = sctp_err_lookup(net, AF_INET6, skb, sctp_hdr(skb), &asoc, &transport);\n\t/* Put back, the original pointers. */\n\tskb->network_header   = saveip;\n\tskb->transport_header = savesctp;\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, idev, ICMP6_MIB_INERRORS);\n\t\tgoto out;\n\t}\n\n\t/* Warning:  The sock lock is held.  Remember to call\n\t * sctp_err_finish!\n\t */\n\n\tswitch (type) {\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tif (ip6_sk_accept_pmtu(sk))\n\t\t\tsctp_icmp_frag_needed(sk, asoc, transport, ntohl(info));\n\t\tgoto out_unlock;\n\tcase ICMPV6_PARAMPROB:\n\t\tif (ICMPV6_UNK_NEXTHDR == code) {\n\t\t\tsctp_icmp_proto_unreachable(sk, asoc, transport);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tcase NDISC_REDIRECT:\n\t\tsctp_icmp_redirect(sk, transport, skb);\n\t\tgoto out_unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnp = inet6_sk(sk);\n\ticmpv6_err_convert(type, code, &err);\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else {  /* Only an error on timeout */\n\t\tsk->sk_err_soft = err;\n\t}\n\nout_unlock:\n\tsctp_err_finish(sk, transport);\nout:\n\tif (likely(idev != NULL))\n\t\tin6_dev_put(idev);\n}\n\nstatic int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n\tint res;\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6->saddr, &fl6->daddr);\n\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->ignore_df = 1;\n\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\trcu_read_lock();\n\tres = ip6_xmit(sk, skb, fl6, sk->sk_mark, rcu_dereference(np->opt),\n\t\t       np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}\n\n/* Returns the dst cache entry for the given source and destination ip\n * addresses.\n */\nstatic void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n\t\t\t    struct flowi *fl, struct sock *sk)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sctp_bind_addr *bp;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sctp_sockaddr_entry *laddr;\n\tunion sctp_addr *daddr = &t->ipaddr;\n\tunion sctp_addr dst_saddr;\n\tstruct in6_addr *final_p, final;\n\t__u8 matchlen = 0;\n\tsctp_scope_t scope;\n\n\tmemset(fl6, 0, sizeof(struct flowi6));\n\tfl6->daddr = daddr->v6.sin6_addr;\n\tfl6->fl6_dport = daddr->v6.sin6_port;\n\tfl6->flowi6_proto = IPPROTO_SCTP;\n\tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;\n\n\tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);\n\n\tif (asoc)\n\t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);\n\n\tif (saddr) {\n\t\tfl6->saddr = saddr->v6.sin6_addr;\n\t\tfl6->fl6_sport = saddr->v6.sin6_port;\n\n\t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);\n\t}\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (!asoc || saddr)\n\t\tgoto out;\n\n\tbp = &asoc->base.bind_addr;\n\tscope = sctp_scope(daddr);\n\t/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check\n\t * to see if we can use it.\n\t */\n\tif (!IS_ERR(dst)) {\n\t\t/* Walk through the bind address list and look for a bind\n\t\t * address that matches the source address of the returned dst.\n\t\t */\n\t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\t\tif (!laddr->valid || laddr->state == SCTP_ADDR_DEL ||\n\t\t\t    (laddr->state != SCTP_ADDR_SRC &&\n\t\t\t     !asoc->src_out_of_asoc_ok))\n\t\t\t\tcontinue;\n\n\t\t\t/* Do not compare against v4 addrs */\n\t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&\n\t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\t/* None of the bound addresses match the source address of the\n\t\t * dst. So release it.\n\t\t */\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\n\t/* Walk through the bind address list and try to get the\n\t * best source address for a given destination.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tstruct dst_entry *bdst;\n\t\t__u8 bmatchlen;\n\n\t\tif (!laddr->valid ||\n\t\t    laddr->state != SCTP_ADDR_SRC ||\n\t\t    laddr->a.sa.sa_family != AF_INET6 ||\n\t\t    scope > sctp_scope(&laddr->a))\n\t\t\tcontinue;\n\n\t\tfl6->saddr = laddr->a.v6.sin6_addr;\n\t\tfl6->fl6_sport = laddr->a.v6.sin6_port;\n\t\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\t\tbdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\n\t\tif (!IS_ERR(bdst) &&\n\t\t    ipv6_chk_addr(dev_net(bdst->dev),\n\t\t\t\t  &laddr->a.v6.sin6_addr, bdst->dev, 1)) {\n\t\t\tif (!IS_ERR_OR_NULL(dst))\n\t\t\t\tdst_release(dst);\n\t\t\tdst = bdst;\n\t\t\tbreak;\n\t\t}\n\n\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);\n\t\tif (matchlen > bmatchlen)\n\t\t\tcontinue;\n\n\t\tif (!IS_ERR_OR_NULL(dst))\n\t\t\tdst_release(dst);\n\t\tdst = bdst;\n\t\tmatchlen = bmatchlen;\n\t}\n\trcu_read_unlock();\n\nout:\n\tif (!IS_ERR_OR_NULL(dst)) {\n\t\tstruct rt6_info *rt;\n\n\t\trt = (struct rt6_info *)dst;\n\t\tt->dst = dst;\n\t\tt->dst_cookie = rt6_get_cookie(rt);\n\t\tpr_debug(\"rt6_dst:%pI6/%d rt6_src:%pI6\\n\",\n\t\t\t &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n\t\t\t &fl6->saddr);\n\t} else {\n\t\tt->dst = NULL;\n\n\t\tpr_debug(\"no route\\n\");\n\t}\n}\n\n/* Returns the number of consecutive initial bits that match in the 2 ipv6\n * addresses.\n */\nstatic inline int sctp_v6_addr_match_len(union sctp_addr *s1,\n\t\t\t\t\t union sctp_addr *s2)\n{\n\treturn ipv6_addr_diff(&s1->v6.sin6_addr, &s2->v6.sin6_addr);\n}\n\n/* Fills in the source address(saddr) based on the destination address(daddr)\n * and asoc's bind address list.\n */\nstatic void sctp_v6_get_saddr(struct sctp_sock *sk,\n\t\t\t      struct sctp_transport *t,\n\t\t\t      struct flowi *fl)\n{\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tunion sctp_addr *saddr = &t->saddr;\n\n\tpr_debug(\"%s: asoc:%p dst:%p\\n\", __func__, t->asoc, t->dst);\n\n\tif (t->dst) {\n\t\tsaddr->v6.sin6_family = AF_INET6;\n\t\tsaddr->v6.sin6_addr = fl6->saddr;\n\t}\n}\n\n/* Make a copy of all potential local addresses. */\nstatic void sctp_v6_copy_addrlist(struct list_head *addrlist,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct inet6_dev *in6_dev;\n\tstruct inet6_ifaddr *ifp;\n\tstruct sctp_sockaddr_entry *addr;\n\n\trcu_read_lock();\n\tif ((in6_dev = __in6_dev_get(dev)) == NULL) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tread_lock_bh(&in6_dev->lock);\n\tlist_for_each_entry(ifp, &in6_dev->addr_list, if_list) {\n\t\t/* Add the address to the local list.  */\n\t\taddr = kzalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v6.sin6_family = AF_INET6;\n\t\t\taddr->a.v6.sin6_port = 0;\n\t\t\taddr->a.v6.sin6_addr = ifp->addr;\n\t\t\taddr->a.v6.sin6_scope_id = dev->ifindex;\n\t\t\taddr->valid = 1;\n\t\t\tINIT_LIST_HEAD(&addr->list);\n\t\t\tlist_add_tail(&addr->list, addrlist);\n\t\t}\n\t}\n\n\tread_unlock_bh(&in6_dev->lock);\n\trcu_read_unlock();\n}\n\n/* Initialize a sockaddr_storage from in incoming skb. */\nstatic void sctp_v6_from_skb(union sctp_addr *addr, struct sk_buff *skb,\n\t\t\t     int is_saddr)\n{\n\t/* Always called on head skb, so this is safe */\n\tstruct sctphdr *sh = sctp_hdr(skb);\n\tstruct sockaddr_in6 *sa = &addr->v6;\n\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_flowinfo = 0; /* FIXME */\n\taddr->v6.sin6_scope_id = ((struct inet6_skb_parm *)skb->cb)->iif;\n\n\tif (is_saddr) {\n\t\tsa->sin6_port = sh->source;\n\t\tsa->sin6_addr = ipv6_hdr(skb)->saddr;\n\t} else {\n\t\tsa->sin6_port = sh->dest;\n\t\tsa->sin6_addr = ipv6_hdr(skb)->daddr;\n\t}\n}\n\n/* Initialize an sctp_addr from a socket. */\nstatic void sctp_v6_from_sk(union sctp_addr *addr, struct sock *sk)\n{\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = 0;\n\taddr->v6.sin6_addr = sk->sk_v6_rcv_saddr;\n}\n\n/* Initialize sk->sk_rcv_saddr from sctp_addr. */\nstatic void sctp_v6_to_sk_saddr(union sctp_addr *addr, struct sock *sk)\n{\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[0] = 0;\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[1] = 0;\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[2] = htonl(0x0000ffff);\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[3] =\n\t\t\taddr->v4.sin_addr.s_addr;\n\t} else {\n\t\tsk->sk_v6_rcv_saddr = addr->v6.sin6_addr;\n\t}\n}\n\n/* Initialize sk->sk_daddr from sctp_addr. */\nstatic void sctp_v6_to_sk_daddr(union sctp_addr *addr, struct sock *sk)\n{\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsk->sk_v6_daddr.s6_addr32[0] = 0;\n\t\tsk->sk_v6_daddr.s6_addr32[1] = 0;\n\t\tsk->sk_v6_daddr.s6_addr32[2] = htonl(0x0000ffff);\n\t\tsk->sk_v6_daddr.s6_addr32[3] = addr->v4.sin_addr.s_addr;\n\t} else {\n\t\tsk->sk_v6_daddr = addr->v6.sin6_addr;\n\t}\n}\n\n/* Initialize a sctp_addr from an address parameter. */\nstatic void sctp_v6_from_addr_param(union sctp_addr *addr,\n\t\t\t\t    union sctp_addr_param *param,\n\t\t\t\t    __be16 port, int iif)\n{\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_flowinfo = 0; /* BUG */\n\taddr->v6.sin6_addr = param->v6.addr;\n\taddr->v6.sin6_scope_id = iif;\n}\n\n/* Initialize an address parameter from a sctp_addr and return the length\n * of the address parameter.\n */\nstatic int sctp_v6_to_addr_param(const union sctp_addr *addr,\n\t\t\t\t union sctp_addr_param *param)\n{\n\tint length = sizeof(sctp_ipv6addr_param_t);\n\n\tparam->v6.param_hdr.type = SCTP_PARAM_IPV6_ADDRESS;\n\tparam->v6.param_hdr.length = htons(length);\n\tparam->v6.addr = addr->v6.sin6_addr;\n\n\treturn length;\n}\n\n/* Initialize a sctp_addr from struct in6_addr. */\nstatic void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,\n\t\t\t      __be16 port)\n{\n\taddr->sa.sa_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_addr = *saddr;\n}\n\n/* Compare addresses exactly.\n * v4-mapped-v6 is also in consideration.\n */\nstatic int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2)\n{\n\tif (addr1->sa.sa_family != addr2->sa.sa_family) {\n\t\tif (addr1->sa.sa_family == AF_INET &&\n\t\t    addr2->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr2->v6.sin6_addr)) {\n\t\t\tif (addr2->v6.sin6_port == addr1->v4.sin_port &&\n\t\t\t    addr2->v6.sin6_addr.s6_addr32[3] ==\n\t\t\t    addr1->v4.sin_addr.s_addr)\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (addr2->sa.sa_family == AF_INET &&\n\t\t    addr1->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr1->v6.sin6_addr)) {\n\t\t\tif (addr1->v6.sin6_port == addr2->v4.sin_port &&\n\t\t\t    addr1->v6.sin6_addr.s6_addr32[3] ==\n\t\t\t    addr2->v4.sin_addr.s_addr)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (addr1->v6.sin6_port != addr2->v6.sin6_port)\n\t\treturn 0;\n\tif (!ipv6_addr_equal(&addr1->v6.sin6_addr, &addr2->v6.sin6_addr))\n\t\treturn 0;\n\t/* If this is a linklocal address, compare the scope_id. */\n\tif (ipv6_addr_type(&addr1->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr1->v6.sin6_scope_id && addr2->v6.sin6_scope_id &&\n\t\t    (addr1->v6.sin6_scope_id != addr2->v6.sin6_scope_id)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/* Initialize addr struct to INADDR_ANY. */\nstatic void sctp_v6_inaddr_any(union sctp_addr *addr, __be16 port)\n{\n\tmemset(addr, 0x00, sizeof(union sctp_addr));\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n}\n\n/* Is this a wildcard address? */\nstatic int sctp_v6_is_any(const union sctp_addr *addr)\n{\n\treturn ipv6_addr_any(&addr->v6.sin6_addr);\n}\n\n/* Should this be available for binding?   */\nstatic int sctp_v6_available(union sctp_addr *addr, struct sctp_sock *sp)\n{\n\tint type;\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tconst struct in6_addr *in6 = (const struct in6_addr *)&addr->v6.sin6_addr;\n\n\ttype = ipv6_addr_type(in6);\n\tif (IPV6_ADDR_ANY == type)\n\t\treturn 1;\n\tif (type == IPV6_ADDR_MAPPED) {\n\t\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 0;\n\t\tsctp_v6_map_v4(addr);\n\t\treturn sctp_get_af_specific(AF_INET)->available(addr, sp);\n\t}\n\tif (!(type & IPV6_ADDR_UNICAST))\n\t\treturn 0;\n\n\treturn sp->inet.freebind || net->ipv6.sysctl.ip_nonlocal_bind ||\n\t\tipv6_chk_addr(net, in6, NULL, 0);\n}\n\n/* This function checks if the address is a valid address to be used for\n * SCTP.\n *\n * Output:\n * Return 0 - If the address is a non-unicast or an illegal address.\n * Return 1 - If the address is a unicast.\n */\nstatic int sctp_v6_addr_valid(union sctp_addr *addr,\n\t\t\t      struct sctp_sock *sp,\n\t\t\t      const struct sk_buff *skb)\n{\n\tint ret = ipv6_addr_type(&addr->v6.sin6_addr);\n\n\t/* Support v4-mapped-v6 address. */\n\tif (ret == IPV6_ADDR_MAPPED) {\n\t\t/* Note: This routine is used in input, so v4-mapped-v6\n\t\t * are disallowed here when there is no sctp_sock.\n\t\t */\n\t\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 0;\n\t\tsctp_v6_map_v4(addr);\n\t\treturn sctp_get_af_specific(AF_INET)->addr_valid(addr, sp, skb);\n\t}\n\n\t/* Is this a non-unicast address */\n\tif (!(ret & IPV6_ADDR_UNICAST))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* What is the scope of 'addr'?  */\nstatic sctp_scope_t sctp_v6_scope(union sctp_addr *addr)\n{\n\tint v6scope;\n\tsctp_scope_t retval;\n\n\t/* The IPv6 scope is really a set of bit fields.\n\t * See IFA_* in <net/if_inet6.h>.  Map to a generic SCTP scope.\n\t */\n\n\tv6scope = ipv6_addr_scope(&addr->v6.sin6_addr);\n\tswitch (v6scope) {\n\tcase IFA_HOST:\n\t\tretval = SCTP_SCOPE_LOOPBACK;\n\t\tbreak;\n\tcase IFA_LINK:\n\t\tretval = SCTP_SCOPE_LINK;\n\t\tbreak;\n\tcase IFA_SITE:\n\t\tretval = SCTP_SCOPE_PRIVATE;\n\t\tbreak;\n\tdefault:\n\t\tretval = SCTP_SCOPE_GLOBAL;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/* Create and initialize a new sk for the socket to be returned by accept(). */\nstatic struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\tstruct ipv6_txoptions *opt;\n\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\n\tsock_init_data(NULL, newsk);\n\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\topt = ipv6_dup_options(newsk, opt);\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n\n\t/* Initialize sk's sport, dport, rcv_saddr and daddr for getsockname()\n\t * and getpeername().\n\t */\n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\n\tsk_refcnt_debug_inc(newsk);\n\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\n\nout:\n\treturn newsk;\n}\n\n/* Format a sockaddr for return to user space. This makes sure the return is\n * AF_INET or AF_INET6 depending on the SCTP_I_WANT_MAPPED_V4_ADDR option.\n */\nstatic int sctp_v6_addr_to_user(struct sctp_sock *sp, union sctp_addr *addr)\n{\n\tif (sp->v4mapped) {\n\t\tif (addr->sa.sa_family == AF_INET)\n\t\t\tsctp_v4_map_v6(addr);\n\t} else {\n\t\tif (addr->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr->v6.sin6_addr))\n\t\t\tsctp_v6_map_v4(addr);\n\t}\n\n\tif (addr->sa.sa_family == AF_INET)\n\t\treturn sizeof(struct sockaddr_in);\n\treturn sizeof(struct sockaddr_in6);\n}\n\n/* Where did this skb come from?  */\nstatic int sctp_v6_skb_iif(const struct sk_buff *skb)\n{\n\treturn IP6CB(skb)->iif;\n}\n\n/* Was this packet marked by Explicit Congestion Notification? */\nstatic int sctp_v6_is_ce(const struct sk_buff *skb)\n{\n\treturn *((__u32 *)(ipv6_hdr(skb))) & htonl(1 << 20);\n}\n\n/* Dump the v6 addr to the seq file. */\nstatic void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)\n{\n\tseq_printf(seq, \"%pI6 \", &addr->v6.sin6_addr);\n}\n\nstatic void sctp_v6_ecn_capable(struct sock *sk)\n{\n\tinet6_sk(sk)->tclass |= INET_ECN_ECT_0;\n}\n\n/* Initialize a PF_INET msgname from a ulpevent. */\nstatic void sctp_inet6_event_msgname(struct sctp_ulpevent *event,\n\t\t\t\t     char *msgname, int *addrlen)\n{\n\tunion sctp_addr *addr;\n\tstruct sctp_association *asoc;\n\tunion sctp_addr *paddr;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tasoc = event->asoc;\n\tpaddr = &asoc->peer.primary_addr;\n\n\tif (paddr->sa.sa_family == AF_INET) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = htons(asoc->peer.port);\n\t\taddr->v4.sin_addr = paddr->v4.sin_addr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\tif (ipv6_addr_type(&paddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\taddr->v6.sin6_scope_id = paddr->v6.sin6_scope_id;\n\t\telse\n\t\t\taddr->v6.sin6_scope_id = 0;\n\t\taddr->v6.sin6_port = htons(asoc->peer.port);\n\t\taddr->v6.sin6_addr = paddr->v6.sin6_addr;\n\t}\n\n\t*addrlen = sctp_v6_addr_to_user(sctp_sk(asoc->base.sk), addr);\n}\n\n/* Initialize a msg_name from an inbound skb. */\nstatic void sctp_inet6_skb_msgname(struct sk_buff *skb, char *msgname,\n\t\t\t\t   int *addr_len)\n{\n\tunion sctp_addr *addr;\n\tstruct sctphdr *sh;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tsh = sctp_hdr(skb);\n\n\tif (ip_hdr(skb)->version == 4) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = sh->source;\n\t\taddr->v4.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\taddr->v6.sin6_port = sh->source;\n\t\taddr->v6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tif (ipv6_addr_type(&addr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL) {\n\t\t\taddr->v6.sin6_scope_id = sctp_v6_skb_iif(skb);\n\t\t}\n\t}\n\n\t*addr_len = sctp_v6_addr_to_user(sctp_sk(skb->sk), addr);\n}\n\n/* Do we support this AF? */\nstatic int sctp_inet6_af_supported(sa_family_t family, struct sctp_sock *sp)\n{\n\tswitch (family) {\n\tcase AF_INET6:\n\t\treturn 1;\n\t/* v4-mapped-v6 addresses */\n\tcase AF_INET:\n\t\tif (!__ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/* Address matching with wildcards allowed.  This extra level\n * of indirection lets us choose whether a PF_INET6 should\n * disallow any v4 addresses if we so choose.\n */\nstatic int sctp_inet6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t       const union sctp_addr *addr2,\n\t\t\t       struct sctp_sock *opt)\n{\n\tstruct sctp_af *af1, *af2;\n\tstruct sock *sk = sctp_opt2sk(opt);\n\n\taf1 = sctp_get_af_specific(addr1->sa.sa_family);\n\taf2 = sctp_get_af_specific(addr2->sa.sa_family);\n\n\tif (!af1 || !af2)\n\t\treturn 0;\n\n\t/* If the socket is IPv6 only, v4 addrs will not match */\n\tif (__ipv6_only_sock(sk) && af1 != af2)\n\t\treturn 0;\n\n\t/* Today, wildcard AF_INET/AF_INET6. */\n\tif (sctp_is_any(sk, addr1) || sctp_is_any(sk, addr2))\n\t\treturn 1;\n\n\tif (addr1->sa.sa_family != addr2->sa.sa_family)\n\t\treturn 0;\n\n\treturn af1->cmp_addr(addr1, addr2);\n}\n\n/* Verify that the provided sockaddr looks bindable.   Common verification,\n * has already been taken care of.\n */\nstatic int sctp_inet6_bind_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\tstruct sctp_af *af;\n\n\t/* ASSERT: address family has already been verified. */\n\tif (addr->sa.sa_family != AF_INET6)\n\t\taf = sctp_get_af_specific(addr->sa.sa_family);\n\telse {\n\t\tint type = ipv6_addr_type(&addr->v6.sin6_addr);\n\t\tstruct net_device *dev;\n\n\t\tif (type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tstruct net *net;\n\t\t\tif (!addr->v6.sin6_scope_id)\n\t\t\t\treturn 0;\n\t\t\tnet = sock_net(&opt->inet.sk);\n\t\t\trcu_read_lock();\n\t\t\tdev = dev_get_by_index_rcu(net, addr->v6.sin6_scope_id);\n\t\t\tif (!dev ||\n\t\t\t    !ipv6_chk_addr(net, &addr->v6.sin6_addr, dev, 0)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\taf = opt->pf->af;\n\t}\n\treturn af->available(addr, opt);\n}\n\n/* Verify that the provided sockaddr looks sendable.   Common verification,\n * has already been taken care of.\n */\nstatic int sctp_inet6_send_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\tstruct sctp_af *af = NULL;\n\n\t/* ASSERT: address family has already been verified. */\n\tif (addr->sa.sa_family != AF_INET6)\n\t\taf = sctp_get_af_specific(addr->sa.sa_family);\n\telse {\n\t\tint type = ipv6_addr_type(&addr->v6.sin6_addr);\n\t\tstruct net_device *dev;\n\n\t\tif (type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (!addr->v6.sin6_scope_id)\n\t\t\t\treturn 0;\n\t\t\trcu_read_lock();\n\t\t\tdev = dev_get_by_index_rcu(sock_net(&opt->inet.sk),\n\t\t\t\t\t\t   addr->v6.sin6_scope_id);\n\t\t\trcu_read_unlock();\n\t\t\tif (!dev)\n\t\t\t\treturn 0;\n\t\t}\n\t\taf = opt->pf->af;\n\t}\n\n\treturn af != NULL;\n}\n\n/* Fill in Supported Address Type information for INIT and INIT-ACK\n * chunks.   Note: In the future, we may want to look at sock options\n * to determine whether a PF_INET6 socket really wants to have IPV4\n * addresses.\n * Returns number of addresses supported.\n */\nstatic int sctp_inet6_supported_addrs(const struct sctp_sock *opt,\n\t\t\t\t      __be16 *types)\n{\n\ttypes[0] = SCTP_PARAM_IPV6_ADDRESS;\n\tif (!opt || !ipv6_only_sock(sctp_opt2sk(opt))) {\n\t\ttypes[1] = SCTP_PARAM_IPV4_ADDRESS;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\n/* Handle SCTP_I_WANT_MAPPED_V4_ADDR for getpeername() and getsockname() */\nstatic int sctp_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tint rc;\n\n\trc = inet6_getname(sock, uaddr, uaddr_len, peer);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\t*uaddr_len = sctp_v6_addr_to_user(sctp_sk(sock->sk),\n\t\t\t\t\t  (union sctp_addr *)uaddr);\n\n\treturn rc;\n}\n\nstatic const struct proto_ops inet6_seqpacket_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = sctp_getname,\n\t.poll\t\t   = sctp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = sctp_inet_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw sctpv6_seqpacket_protosw = {\n\t.type          = SOCK_SEQPACKET,\n\t.protocol      = IPPROTO_SCTP,\n\t.prot \t       = &sctpv6_prot,\n\t.ops           = &inet6_seqpacket_ops,\n\t.flags         = SCTP_PROTOSW_FLAG\n};\nstatic struct inet_protosw sctpv6_stream_protosw = {\n\t.type          = SOCK_STREAM,\n\t.protocol      = IPPROTO_SCTP,\n\t.prot \t       = &sctpv6_prot,\n\t.ops           = &inet6_seqpacket_ops,\n\t.flags         = SCTP_PROTOSW_FLAG,\n};\n\nstatic int sctp6_rcv(struct sk_buff *skb)\n{\n\treturn sctp_rcv(skb) ? -1 : 0;\n}\n\nstatic const struct inet6_protocol sctpv6_protocol = {\n\t.handler      = sctp6_rcv,\n\t.err_handler  = sctp_v6_err,\n\t.flags        = INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic struct sctp_af sctp_af_inet6 = {\n\t.sa_family\t   = AF_INET6,\n\t.sctp_xmit\t   = sctp_v6_xmit,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.get_dst\t   = sctp_v6_get_dst,\n\t.get_saddr\t   = sctp_v6_get_saddr,\n\t.copy_addrlist\t   = sctp_v6_copy_addrlist,\n\t.from_skb\t   = sctp_v6_from_skb,\n\t.from_sk\t   = sctp_v6_from_sk,\n\t.from_addr_param   = sctp_v6_from_addr_param,\n\t.to_addr_param\t   = sctp_v6_to_addr_param,\n\t.cmp_addr\t   = sctp_v6_cmp_addr,\n\t.scope\t\t   = sctp_v6_scope,\n\t.addr_valid\t   = sctp_v6_addr_valid,\n\t.inaddr_any\t   = sctp_v6_inaddr_any,\n\t.is_any\t\t   = sctp_v6_is_any,\n\t.available\t   = sctp_v6_available,\n\t.skb_iif\t   = sctp_v6_skb_iif,\n\t.is_ce\t\t   = sctp_v6_is_ce,\n\t.seq_dump_addr\t   = sctp_v6_seq_dump_addr,\n\t.ecn_capable\t   = sctp_v6_ecn_capable,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\nstatic struct sctp_pf sctp_pf_inet6 = {\n\t.event_msgname = sctp_inet6_event_msgname,\n\t.skb_msgname   = sctp_inet6_skb_msgname,\n\t.af_supported  = sctp_inet6_af_supported,\n\t.cmp_addr      = sctp_inet6_cmp_addr,\n\t.bind_verify   = sctp_inet6_bind_verify,\n\t.send_verify   = sctp_inet6_send_verify,\n\t.supported_addrs = sctp_inet6_supported_addrs,\n\t.create_accept_sk = sctp_v6_create_accept_sk,\n\t.addr_to_user  = sctp_v6_addr_to_user,\n\t.to_sk_saddr   = sctp_v6_to_sk_saddr,\n\t.to_sk_daddr   = sctp_v6_to_sk_daddr,\n\t.af            = &sctp_af_inet6,\n};\n\n/* Initialize IPv6 support and register with socket layer.  */\nvoid sctp_v6_pf_init(void)\n{\n\t/* Register the SCTP specific PF_INET6 functions. */\n\tsctp_register_pf(&sctp_pf_inet6, PF_INET6);\n\n\t/* Register the SCTP specific AF_INET6 functions. */\n\tsctp_register_af(&sctp_af_inet6);\n}\n\nvoid sctp_v6_pf_exit(void)\n{\n\tlist_del(&sctp_af_inet6.list);\n}\n\n/* Initialize IPv6 support and register with socket layer.  */\nint sctp_v6_protosw_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&sctpv6_prot, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Add SCTPv6(UDP and TCP style) to inetsw6 linked list. */\n\tinet6_register_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_register_protosw(&sctpv6_stream_protosw);\n\n\treturn 0;\n}\n\nvoid sctp_v6_protosw_exit(void)\n{\n\tinet6_unregister_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_unregister_protosw(&sctpv6_stream_protosw);\n\tproto_unregister(&sctpv6_prot);\n}\n\n\n/* Register with inet6 layer. */\nint sctp_v6_add_protocol(void)\n{\n\t/* Register notifier for inet6 address additions/deletions. */\n\tregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n\n\tif (inet6_add_protocol(&sctpv6_protocol, IPPROTO_SCTP) < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\n/* Unregister with inet6 layer. */\nvoid sctp_v6_del_protocol(void)\n{\n\tinet6_del_protocol(&sctpv6_protocol, IPPROTO_SCTP);\n\tunregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n}\n"], "filenames": ["net/sctp/ipv6.c"], "buggy_code_start_loc": [679], "buggy_code_end_loc": [679], "fixing_code_start_loc": [680], "fixing_code_end_loc": [683], "type": "NVD-CWE-noinfo", "message": "The sctp_v6_create_accept_sk function in net/sctp/ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890.", "other": {"cve": {"id": "CVE-2017-9075", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-19T07:29:00.260", "lastModified": "2023-02-24T18:39:18.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The sctp_v6_create_accept_sk function in net/sctp/ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890."}, {"lang": "es", "value": "La funci\u00f3n sctp_v6_create_accept_sk en net/sctp/ipv6.c en el kernel de Linux hasta la versi\u00f3n 4.11.1 gestiona de manera incorrecta la herencia, lo que permite que usuarios locales provoquen una denegaci\u00f3n de servicio (DoS) o, probablemente, causen otro impacto no especificado mediante llamadas de sistema manipuladas. Este problema est\u00e1 relacionado con CVE-2017-8890."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.89", "matchCriteriaId": "9A5C1F01-214B-4477-A3A1-F6DF10181D3C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.44", "matchCriteriaId": "8C1901E2-6C4D-488B-A7CE-F7E14A38418F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.56", "matchCriteriaId": "5837A5CA-266C-4BC5-B95F-1344AE42D24F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.42", "matchCriteriaId": "5EDD29F4-10F1-415A-877F-5586A004E320"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.71", "matchCriteriaId": "CF0C6096-CC39-4352-AFAF-5D7A7C5C2838"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.31", "matchCriteriaId": "001F55C3-810A-444F-AE18-F067A84F6B31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.11.4", "matchCriteriaId": "1A25FD29-5617-4236-AC9A-6D68DC220925"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8", "source": "cve@mitre.org", "tags": ["Vendor Advisory", "Patch"]}, {"url": "http://www.debian.org/security/2017/dsa-3886", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98597", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1854", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://patchwork.ozlabs.org/patch/763569/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-10-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8"}}