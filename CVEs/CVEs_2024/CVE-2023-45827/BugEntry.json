{"buggy_code": ["# Changelog\n\nAll notable changes to **dot-diver** will be documented here. Inspired by [keep a changelog](https://keepachangelog.com/en/1.0.0/)\n\n## Unreleased\n\n- Updated dependencies\n- Formatted code with new lint rules\n- Fixed testcase for new TypeScript behavior\n\n## [1.0.1](https://github.com/clickbar/dot-diver/tree/1.0.1) (2023-03-26)\n\n- Rerelease with content \ud83d\ude05\n\n## [1.0.0](https://github.com/clickbar/dot-diver/tree/1.0.0) (2023-03-26)\n\n- Initial Release \ud83c\udf89\n", "/* -------------------------------------------------------------------------- */\n/*                                Utility Types                               */\n/* -------------------------------------------------------------------------- */\n\n// check if a type is null or undefined\ntype IsNullableOrUndefineable<T> = null extends T ? true : undefined extends T ? true : false\n\n// Removes all possible index signatures from a type\ntype FilterIndexSignatureType<T> = string extends T\n  ? never\n  : number extends T\n  ? never\n  : symbol extends T\n  ? never\n  : T\n\n// Remove the index signature from a type\ntype RemoveIndexSignature<T> = {\n  [K in keyof T as FilterIndexSignatureType<K>]: T[K]\n}\n\n// check if a type has an index signature\ntype HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n  ? true\n  : symbol extends keyof T\n  ? true\n  : false\n\ntype GetValidIndexSignature<T> = Exclude<keyof T, symbol> extends infer K\n  ? K extends string | number\n    ? K\n    : never\n  : never\n\n// Keys have to be strings or number and can't contain a dot since we won't be able to differ between and key with a dot and a nested key\ntype RemoveInvalidDotPathKeys<T> = T extends symbol\n  ? never\n  : T extends number\n  ? T\n  : T extends string\n  ? T extends `${infer _K}.${infer _R}`\n    ? never\n    : T\n  : never\n\n// check if a type is an array\ntype IsArray<T> = T extends any[] ? true : false\n\n// check if a array is empty\ntype IsEmptyArray<T> = T extends [] ? true : false\n\n// Get the type of array element\ntype GetArrayElement<T> = T extends (infer U)[] ? U : never\n\n/**\n * check if a type is any\n * @link https://stackoverflow.com/a/49928360/1490091\n */\ntype IsAny<T> = 0 extends 1 & T ? true : false\n\n// check if a type is never\ntype IsNever<T> = [T] extends [never] ? true : false\n\n/**\n * check if a type is unknown\n * @link https://github.com/sindresorhus/type-fest\n */\ntype IsUnknown<T> = IsNever<T> extends true\n  ? false\n  : IsAny<T> extends true\n  ? false\n  : unknown extends T\n  ? true\n  : false\n\n// check if a type is a primitive\ntype IsPrimitive<T> = T extends string | number | boolean | bigint | symbol | undefined | null\n  ? true\n  : false\n\n// remove null and undefined from a type\ntype ExcludeNullUndefined<T> = Exclude<T, null | undefined>\n\n// check if a type is a tuple\ntype IsTuple<T> = T extends [any, ...any[]] ? true : false\n\n// get the length of a tuple\ntype TupleLength<T> = T extends { length: infer L } ? (L extends number ? L : never) : never\n\n// get the type of tuple element\ntype TupleElement<T, N> = N extends keyof T ? T[N] : never\n\n// get all numbers from 0 to L\ntype NumbersToZero<\n  IterationCarry extends unknown[],\n  DepthCarry extends unknown[],\n> = TupleLength<DepthCarry> extends 0\n  ? any\n  : TupleLength<IterationCarry> extends 0\n  ? never\n  :\n      | NumbersToZero<MinusOne<IterationCarry>, MinusOne<DepthCarry>>\n      | TupleLength<MinusOne<IterationCarry>>\n\n// remove readonly from members of a record\ntype Writeable<T> = {\n  -readonly [K in keyof T]: T[K]\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                 Math Types                                 */\n/* -------------------------------------------------------------------------- */\n// We use a tuple to carry our value\n\ntype MinusOne<N extends unknown[]> = N extends [...infer U, unknown] ? U : never\n\ntype BuildTuple<L extends number, T extends unknown[] = []> = T extends {\n  length: L\n}\n  ? T\n  : BuildTuple<L, [...T, unknown]>\n\n/* -------------------------------------------------------------------------- */\n/*                                 Path Types                                 */\n/* -------------------------------------------------------------------------- */\n\n// get all possible paths of a type\ntype GetRecordPaths<\n  T,\n  DepthCarry extends unknown[],\n  K extends keyof T = keyof T,\n> = K extends keyof T\n  ? RemoveInvalidDotPathKeys<K> | `${RemoveInvalidDotPathKeys<K>}.${Path<T[K], DepthCarry>}`\n  : never\n\n// get all possible paths of an array\ntype GetArrayPaths<T, DepthCarry extends unknown[]> = `${number}.${Path<\n  GetArrayElement<T>,\n  DepthCarry\n>}`\n\n// get all possible paths of a tuple\ntype GetTuplePaths<T extends unknown[], DepthCarry extends unknown[]> = NumbersToZero<\n  T,\n  DepthCarry\n> extends infer R\n  ? R extends number\n    ? R | `${R}.${Path<TupleElement<T, R>, DepthCarry>}`\n    : never\n  : never\n\ntype PathStep<T, Depth extends unknown[]> = IsAny<T> extends true\n  ? string\n  : IsUnknown<T> extends true\n  ? never\n  : IsPrimitive<T> extends true\n  ? never\n  : IsTuple<T> extends true\n  ? T extends unknown[]\n    ? GetTuplePaths<T, Depth>\n    : never\n  : IsArray<T> extends true\n  ? (IsEmptyArray<T> extends true ? never : number) | GetArrayPaths<T, Depth>\n  : HasIndexSignature<T> extends true\n  ? GetValidIndexSignature<T> | GetRecordPaths<RemoveIndexSignature<T>, Depth>\n  : GetRecordPaths<T, Depth>\n\n// Final path type\ntype Path<T, DepthCarry extends unknown[]> = TupleLength<DepthCarry> extends 0\n  ? IsPrimitive<T> extends true\n    ? never\n    : any\n  : T extends T\n  ? PathStep<Writeable<ExcludeNullUndefined<T>>, MinusOne<DepthCarry>>\n  : never\n\ntype PathEntry<T, Depth extends number = 10> = Path<T, BuildTuple<Depth>>\n\ntype PathValueStep<T, P, DepthCarry extends unknown[]> = IsAny<T> extends true\n  ? any\n  : IsUnknown<T> extends true\n  ? unknown\n  : IsNullableOrUndefineable<T> extends true\n  ? PathValue<ExcludeNullUndefined<T>, P, DepthCarry> | undefined\n  : IsTuple<T> extends true\n  ? P extends `${infer H}.${infer R}`\n    ? PathValue<TupleElement<T, H>, R, DepthCarry>\n    : TupleElement<T, P>\n  : IsArray<T> extends true\n  ? P extends `${infer _H}.${infer R}`\n    ? PathValue<GetArrayElement<T>, R, DepthCarry> | undefined\n    : GetArrayElement<T> | undefined\n  : P extends `${infer H}.${infer R}`\n  ? H extends keyof T\n    ? PathValue<T[H], R, DepthCarry> | (HasIndexSignature<T> extends true ? undefined : never)\n    : never\n  : P extends keyof T\n  ? T[P] | (HasIndexSignature<T> extends true ? undefined : never)\n  : never\n\n// nearly same function as PathValueEntry, but without constraints for P so it is easier to use in PathValueStep\ntype PathValue<T, P, DepthCarry extends unknown[]> = TupleLength<DepthCarry> extends 0\n  ? IsPrimitive<T> extends true\n    ? never\n    : unknown\n  : T extends T\n  ? PathValueStep<Writeable<T>, P, MinusOne<DepthCarry>>\n  : never\n\n// final path value type\ntype PathValueEntry<T, P extends PathEntry<T, Depth>, Depth extends number = 10> = PathValue<\n  T,\n  P,\n  BuildTuple<Depth>\n>\n\ntype SearchableObject = Record<never, never> | unknown[]\n\n/**\n * Retrives a value from an object by dot notation\n *\n * @param object - object to get value from\n * @param path - path to value\n *\n * @privateRemarks\n * The intersection between PathEntry<T, 10>  and string is necessary for TypeScript to successfully narrow down the type of P based on the user-provided path input.\n * Without the intersection, the path would just be of type PathEntry<T, 10> and PathValueEntry would be a union of all possible return types.\n * By using the intersection, TypeScript is forced to apply the PathEntry constraints and infer the type from the provided user input.\n */\n\nfunction getByPath<T extends SearchableObject, P extends PathEntry<T> & string>(\n  object: T,\n  path: P,\n): PathValueEntry<T, P> {\n  const pathArray = (path as string).split('.')\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n  return pathArray.reduce((accumulator: any, current) => accumulator?.[current], object)\n}\n\n/**\n * Sets a value in an object by dot notation\n * @param object - object to set value in\n * @param path - path to value\n * @param value - value to set\n *\n * @privateRemarks\n * The intersection between PathEntry<T, 10>  and string is necessary for TypeScript to successfully narrow down the type of P based on the user-provided path input.\n * Without the intersection, the path would just be of type PathEntry<T, 10> and PathValueEntry would be a union of all possible return types.\n * By using the intersection, TypeScript is forced to apply the PathEntry constraints and infer the type from the provided user input.\n */\nfunction setByPath<\n  T extends SearchableObject,\n  P extends PathEntry<T> & string,\n  V extends PathValueEntry<T, P>,\n>(object: T, path: P, value: V): void {\n  const pathArray = (path as string).split('.')\n  const lastKey = pathArray.pop()\n\n  if (lastKey === undefined) {\n    throw new Error('Path is empty')\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const objectToSet = pathArray.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n    (accumulator: any, current) => accumulator?.[current],\n    object,\n  )\n\n  if (objectToSet === undefined) {\n    throw new Error('Path is invalid')\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  objectToSet[lastKey] = value\n}\n\nexport type { PathEntry as Path, PathValueEntry as PathValue, SearchableObject }\n\nexport { getByPath, setByPath }\n", "import { expect, it } from 'vitest'\n\nimport { getByPath, setByPath } from '../src'\n\nimport type { Path, SearchableObject, PathValue } from '../src'\n\nit('can get simple member', () => {\n  const test = {\n    first: 'test',\n    second: ['secondTest'],\n    third: {\n      id: 2,\n      date: [],\n    },\n  }\n\n  expect(getByPath(test, 'first')).toBe('test')\n  expect(getByPath(test, 'second.0')).toBe('secondTest')\n  expect(getByPath(test, 'third.date')).toStrictEqual([])\n})\n\nit('can set simple member', () => {\n  const test = {\n    first: 'test',\n    second: ['secondTest'],\n    third: {\n      id: 2,\n      date: ['thirdTest'],\n    },\n  }\n\n  setByPath(test, 'first', 'testChanged')\n  setByPath(test, 'second.0', 'testChanged2')\n  setByPath(test, 'third.date', [])\n\n  expect(test.first).toBe('testChanged')\n  expect(test.second[0]).toBe('testChanged2')\n  expect(test.third.date).toStrictEqual([])\n})\n\n/* -------------------------------------------------------------------------- */\n/*                                Readme Tests                                */\n/* -------------------------------------------------------------------------- */\n\nit('Test readme introduction', () => {\n  const object = {\n    a: 'Hello world',\n  }\n\n  const result = getByPath(object, 'a') // result is 'Hello world'\n\n  expect(result).toBe('Hello world')\n})\n\nit('Test readme usage example: \ud83d\udd0e getByPath and \ud83d\udd0f setByPath', () => {\n  // Define a sample object with nested properties\n  const object = {\n    a: 'hello',\n    b: {\n      c: 42,\n      d: {\n        e: 'world',\n      },\n    },\n    f: [{ g: 'array-item-1' }, { g: 'array-item-2' }],\n  }\n\n  // Example 1: Get a value by path\n  const value1 = getByPath(object, 'a') // Output: 'hello'\n  expect(value1).toBe('hello')\n\n  const value2 = getByPath(object, 'b.c') // Output: 42\n  expect(value2).toBe(42)\n\n  const value3 = getByPath(object, 'b.d.e') // Output: 'world'\n  expect(value3).toBe('world')\n\n  const value4 = getByPath(object, 'f.0') // Output: { g: 'array-item-1' }\n  expect(value4).toStrictEqual({ g: 'array-item-1' })\n\n  const value5 = getByPath(object, 'f.1.g') // Output: 'array-item-2'\n  expect(value5).toBe('array-item-2')\n\n  // Example 2: Set a value by path\n  setByPath(object, 'a', 'new hello')\n  expect(object.a).toBe('new hello')\n\n  setByPath(object, 'b.c', 100)\n  expect(object.b.c).toBe(100)\n\n  setByPath(object, 'b.d.e', 'new world')\n  expect(object.b.d.e).toBe('new world')\n\n  setByPath(object, 'f.0', { g: 'new array-item-1' })\n  expect(object.f[0]).toStrictEqual({ g: 'new array-item-1' })\n\n  setByPath(object, 'f.1.g', 'new array-item-2')\n  expect(object.f[1].g).toBe('new array-item-2')\n})\n\nit('Test readme usage example: \u2699\ufe0f Customizing the Depth Limit', () => {\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  function getByPathDepth5<T extends SearchableObject, P extends Path<T, 5> & string>(\n    object: T,\n    path: P,\n  ): PathValue<T, P, 5> {\n    return getByPath(object, path) as PathValue<T, P, 5>\n  }\n\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  function setByPathDepth5<\n    T extends SearchableObject,\n    P extends Path<T, 5> & string,\n    V extends PathValue<T, P, 5>,\n  >(object: T, path: P, value: V): void {\n    setByPath(object, path, value as PathValue<T, P>)\n  }\n\n  // previous readme test still works\n  const object = {\n    a: 'hello',\n    b: {\n      c: 42,\n      d: {\n        e: 'world',\n      },\n    },\n    f: [{ g: 'array-item-1' }, { g: 'array-item-2' }],\n  }\n\n  // Example 1: Get a value by path\n  const value1 = getByPathDepth5(object, 'a') // Output: 'hello'\n  expect(value1).toBe('hello')\n\n  const value2 = getByPathDepth5(object, 'b.c') // Output: 42\n  expect(value2).toBe(42)\n\n  const value3 = getByPathDepth5(object, 'b.d.e') // Output: 'world'\n  expect(value3).toBe('world')\n\n  const value4 = getByPathDepth5(object, 'f.0') // Output: { g: 'array-item-1' }\n  expect(value4).toStrictEqual({ g: 'array-item-1' })\n\n  const value5 = getByPathDepth5(object, 'f.1.g') // Output: 'array-item-2'\n  expect(value5).toBe('array-item-2')\n\n  // Example 2: Set a value by path\n  setByPathDepth5(object, 'a', 'new hello')\n  expect(object.a).toBe('new hello')\n\n  setByPathDepth5(object, 'b.c', 100)\n  expect(object.b.c).toBe(100)\n\n  setByPathDepth5(object, 'b.d.e', 'new world')\n  expect(object.b.d.e).toBe('new world')\n\n  setByPathDepth5(object, 'f.0', { g: 'new array-item-1' })\n  expect(object.f[0]).toStrictEqual({ g: 'new array-item-1' })\n\n  setByPathDepth5(object, 'f.1.g', 'new array-item-2')\n  expect(object.f[1].g).toBe('new array-item-2')\n})\n"], "fixing_code": ["# Changelog\n\nAll notable changes to **dot-diver** will be documented here. Inspired by [keep a changelog](https://keepachangelog.com/en/1.0.0/)\n\n## Unreleased\n\n- Updated dependencies\n- Formatted code with new lint rules\n- Fixed testcase for new TypeScript behavior\n- Added guards against prototype pollution, thanks to @d3ng03 (<https://github.com/clickbar/dot-diver/security/advisories/GHSA-9w5f-mw3p-pj47>)\n\n## [1.0.1](https://github.com/clickbar/dot-diver/tree/1.0.1) (2023-03-26)\n\n- Rerelease with content \ud83d\ude05\n\n## [1.0.0](https://github.com/clickbar/dot-diver/tree/1.0.0) (2023-03-26)\n\n- Initial Release \ud83c\udf89\n", "/* -------------------------------------------------------------------------- */\n/*                                Utility Types                               */\n/* -------------------------------------------------------------------------- */\n\n// check if a type is null or undefined\ntype IsNullableOrUndefineable<T> = null extends T ? true : undefined extends T ? true : false\n\n// Removes all possible index signatures from a type\ntype FilterIndexSignatureType<T> = string extends T\n  ? never\n  : number extends T\n  ? never\n  : symbol extends T\n  ? never\n  : T\n\n// Remove the index signature from a type\ntype RemoveIndexSignature<T> = {\n  [K in keyof T as FilterIndexSignatureType<K>]: T[K]\n}\n\n// check if a type has an index signature\ntype HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n  ? true\n  : symbol extends keyof T\n  ? true\n  : false\n\ntype GetValidIndexSignature<T> = Exclude<keyof T, symbol> extends infer K\n  ? K extends string | number\n    ? K\n    : never\n  : never\n\n// Keys have to be strings or number and can't contain a dot since we won't be able to differ between and key with a dot and a nested key\ntype RemoveInvalidDotPathKeys<T> = T extends symbol\n  ? never\n  : T extends number\n  ? T\n  : T extends string\n  ? T extends `${infer _K}.${infer _R}`\n    ? never\n    : T\n  : never\n\n// check if a type is an array\ntype IsArray<T> = T extends any[] ? true : false\n\n// check if a array is empty\ntype IsEmptyArray<T> = T extends [] ? true : false\n\n// Get the type of array element\ntype GetArrayElement<T> = T extends (infer U)[] ? U : never\n\n/**\n * check if a type is any\n * @link https://stackoverflow.com/a/49928360/1490091\n */\ntype IsAny<T> = 0 extends 1 & T ? true : false\n\n// check if a type is never\ntype IsNever<T> = [T] extends [never] ? true : false\n\n/**\n * check if a type is unknown\n * @link https://github.com/sindresorhus/type-fest\n */\ntype IsUnknown<T> = IsNever<T> extends true\n  ? false\n  : IsAny<T> extends true\n  ? false\n  : unknown extends T\n  ? true\n  : false\n\n// check if a type is a primitive\ntype IsPrimitive<T> = T extends string | number | boolean | bigint | symbol | undefined | null\n  ? true\n  : false\n\n// remove null and undefined from a type\ntype ExcludeNullUndefined<T> = Exclude<T, null | undefined>\n\n// check if a type is a tuple\ntype IsTuple<T> = T extends [any, ...any[]] ? true : false\n\n// get the length of a tuple\ntype TupleLength<T> = T extends { length: infer L } ? (L extends number ? L : never) : never\n\n// get the type of tuple element\ntype TupleElement<T, N> = N extends keyof T ? T[N] : never\n\n// get all numbers from 0 to L\ntype NumbersToZero<\n  IterationCarry extends unknown[],\n  DepthCarry extends unknown[],\n> = TupleLength<DepthCarry> extends 0\n  ? any\n  : TupleLength<IterationCarry> extends 0\n  ? never\n  :\n      | NumbersToZero<MinusOne<IterationCarry>, MinusOne<DepthCarry>>\n      | TupleLength<MinusOne<IterationCarry>>\n\n// remove readonly from members of a record\ntype Writeable<T> = {\n  -readonly [K in keyof T]: T[K]\n}\n\n/* -------------------------------------------------------------------------- */\n/*                                 Math Types                                 */\n/* -------------------------------------------------------------------------- */\n// We use a tuple to carry our value\n\ntype MinusOne<N extends unknown[]> = N extends [...infer U, unknown] ? U : never\n\ntype BuildTuple<L extends number, T extends unknown[] = []> = T extends {\n  length: L\n}\n  ? T\n  : BuildTuple<L, [...T, unknown]>\n\n/* -------------------------------------------------------------------------- */\n/*                                 Path Types                                 */\n/* -------------------------------------------------------------------------- */\n\n// get all possible paths of a type\ntype GetRecordPaths<\n  T,\n  DepthCarry extends unknown[],\n  K extends keyof T = keyof T,\n> = K extends keyof T\n  ? RemoveInvalidDotPathKeys<K> | `${RemoveInvalidDotPathKeys<K>}.${Path<T[K], DepthCarry>}`\n  : never\n\n// get all possible paths of an array\ntype GetArrayPaths<T, DepthCarry extends unknown[]> = `${number}.${Path<\n  GetArrayElement<T>,\n  DepthCarry\n>}`\n\n// get all possible paths of a tuple\ntype GetTuplePaths<T extends unknown[], DepthCarry extends unknown[]> = NumbersToZero<\n  T,\n  DepthCarry\n> extends infer R\n  ? R extends number\n    ? R | `${R}.${Path<TupleElement<T, R>, DepthCarry>}`\n    : never\n  : never\n\ntype PathStep<T, Depth extends unknown[]> = IsAny<T> extends true\n  ? string\n  : IsUnknown<T> extends true\n  ? never\n  : IsPrimitive<T> extends true\n  ? never\n  : IsTuple<T> extends true\n  ? T extends unknown[]\n    ? GetTuplePaths<T, Depth>\n    : never\n  : IsArray<T> extends true\n  ? (IsEmptyArray<T> extends true ? never : number) | GetArrayPaths<T, Depth>\n  : HasIndexSignature<T> extends true\n  ? GetValidIndexSignature<T> | GetRecordPaths<RemoveIndexSignature<T>, Depth>\n  : GetRecordPaths<T, Depth>\n\n// Final path type\ntype Path<T, DepthCarry extends unknown[]> = TupleLength<DepthCarry> extends 0\n  ? IsPrimitive<T> extends true\n    ? never\n    : any\n  : T extends T\n  ? PathStep<Writeable<ExcludeNullUndefined<T>>, MinusOne<DepthCarry>>\n  : never\n\ntype PathEntry<T, Depth extends number = 10> = Path<T, BuildTuple<Depth>>\n\ntype PathValueStep<T, P, DepthCarry extends unknown[]> = IsAny<T> extends true\n  ? any\n  : IsUnknown<T> extends true\n  ? unknown\n  : IsNullableOrUndefineable<T> extends true\n  ? PathValue<ExcludeNullUndefined<T>, P, DepthCarry> | undefined\n  : IsTuple<T> extends true\n  ? P extends `${infer H}.${infer R}`\n    ? PathValue<TupleElement<T, H>, R, DepthCarry>\n    : TupleElement<T, P>\n  : IsArray<T> extends true\n  ? P extends `${infer _H}.${infer R}`\n    ? PathValue<GetArrayElement<T>, R, DepthCarry> | undefined\n    : GetArrayElement<T> | undefined\n  : P extends `${infer H}.${infer R}`\n  ? H extends keyof T\n    ? PathValue<T[H], R, DepthCarry> | (HasIndexSignature<T> extends true ? undefined : never)\n    : never\n  : P extends keyof T\n  ? T[P] | (HasIndexSignature<T> extends true ? undefined : never)\n  : never\n\n// nearly same function as PathValueEntry, but without constraints for P so it is easier to use in PathValueStep\ntype PathValue<T, P, DepthCarry extends unknown[]> = TupleLength<DepthCarry> extends 0\n  ? IsPrimitive<T> extends true\n    ? never\n    : unknown\n  : T extends T\n  ? PathValueStep<Writeable<T>, P, MinusOne<DepthCarry>>\n  : never\n\n// final path value type\ntype PathValueEntry<T, P extends PathEntry<T, Depth>, Depth extends number = 10> = PathValue<\n  T,\n  P,\n  BuildTuple<Depth>\n>\n\ntype SearchableObject = Record<never, never> | unknown[]\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * Retrieves a value from an object by dot notation. The value is received by optional chaining,\n * therefore this function returns undefined if an intermediate property is undefined.\n *\n * @param object - object to get value from\n * @param path - path to value\n *\n * @privateRemarks\n * The intersection between PathEntry<T, 10>  and string is necessary for TypeScript to successfully narrow down the type of P based on the user-provided path input.\n * Without the intersection, the path would just be of type PathEntry<T, 10> and PathValueEntry would be a union of all possible return types.\n * By using the intersection, TypeScript is forced to apply the PathEntry constraints and infer the type from the provided user input.\n */\n\nfunction getByPath<T extends SearchableObject, P extends PathEntry<T> & string>(\n  object: T,\n  path: P,\n): PathValueEntry<T, P> {\n  const pathArray = (path as string).split('.')\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return pathArray.reduce((current: any, pathPart) => {\n    if (typeof current !== 'object' || !hasOwnProperty.call(current, pathPart)) {\n      return undefined\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n    return current?.[pathPart]\n  }, object)\n}\n\n/**\n * Sets a value in an object by dot notation. If an intermediate property is undefined,\n * this function will throw an error.\n *\n * @param object - object to set value in\n * @param path - path to value\n * @param value - value to set\n *\n * @throws {Error} - if an intermediate property is undefined\n *\n * @privateRemarks\n * The intersection between PathEntry<T, 10>  and string is necessary for TypeScript to successfully narrow down the type of P based on the user-provided path input.\n * Without the intersection, the path would just be of type PathEntry<T, 10> and PathValueEntry would be a union of all possible return types.\n * By using the intersection, TypeScript is forced to apply the PathEntry constraints and infer the type from the provided user input.\n */\nfunction setByPath<\n  T extends SearchableObject,\n  P extends PathEntry<T> & string,\n  V extends PathValueEntry<T, P>,\n>(object: T, path: P, value: V): void {\n  const pathArray = (path as string).split('.')\n  const lastKey = pathArray.pop()\n\n  if (lastKey === undefined) {\n    throw new Error('Path is empty')\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parentObject = pathArray.reduce((current: any, pathPart) => {\n    if (typeof current !== 'object' || !hasOwnProperty.call(current, pathPart)) {\n      throw new Error(`Property ${pathPart} is undefined`)\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const next = current?.[pathPart]\n\n    if (next === undefined || next === null) {\n      throw new Error(`Property ${pathPart} is undefined`)\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return next\n  }, object)\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  parentObject[lastKey] = value\n}\n\nexport type { PathEntry as Path, PathValueEntry as PathValue, SearchableObject }\n\nexport { getByPath, setByPath }\n", "import { expect, it } from 'vitest'\n\nimport { getByPath, setByPath } from '../src'\n\nimport type { Path, SearchableObject, PathValue } from '../src'\n\nit('can get simple member', () => {\n  const test = {\n    first: 'test',\n    second: ['secondTest'],\n    third: {\n      id: 2,\n      date: [],\n    },\n  }\n\n  expect(getByPath(test, 'first')).toBe('test')\n  expect(getByPath(test, 'second.0')).toBe('secondTest')\n  expect(getByPath(test, 'third.date')).toStrictEqual([])\n})\n\nit('can set simple member', () => {\n  const test = {\n    first: 'test',\n    second: ['secondTest'],\n    third: {\n      id: 2,\n      date: ['thirdTest'],\n    },\n  }\n\n  setByPath(test, 'first', 'testChanged')\n  setByPath(test, 'second.0', 'testChanged2')\n  setByPath(test, 'third.date', [])\n\n  expect(test.first).toBe('testChanged')\n  expect(test.second[0]).toBe('testChanged2')\n  expect(test.third.date).toStrictEqual([])\n})\n\n/* -------------------------------------------------------------------------- */\n/*                                Readme Tests                                */\n/* -------------------------------------------------------------------------- */\n\nit('Test readme introduction', () => {\n  const object = {\n    a: 'Hello world',\n  }\n\n  const result = getByPath(object, 'a') // result is 'Hello world'\n\n  expect(result).toBe('Hello world')\n})\n\nit('Test readme usage example: \ud83d\udd0e getByPath and \ud83d\udd0f setByPath', () => {\n  // Define a sample object with nested properties\n  const object = {\n    a: 'hello',\n    b: {\n      c: 42,\n      d: {\n        e: 'world',\n      },\n    },\n    f: [{ g: 'array-item-1' }, { g: 'array-item-2' }],\n  }\n\n  // Example 1: Get a value by path\n  const value1 = getByPath(object, 'a') // Output: 'hello'\n  expect(value1).toBe('hello')\n\n  const value2 = getByPath(object, 'b.c') // Output: 42\n  expect(value2).toBe(42)\n\n  const value3 = getByPath(object, 'b.d.e') // Output: 'world'\n  expect(value3).toBe('world')\n\n  const value4 = getByPath(object, 'f.0') // Output: { g: 'array-item-1' }\n  expect(value4).toStrictEqual({ g: 'array-item-1' })\n\n  const value5 = getByPath(object, 'f.1.g') // Output: 'array-item-2'\n  expect(value5).toBe('array-item-2')\n\n  // Example 2: Set a value by path\n  setByPath(object, 'a', 'new hello')\n  expect(object.a).toBe('new hello')\n\n  setByPath(object, 'b.c', 100)\n  expect(object.b.c).toBe(100)\n\n  setByPath(object, 'b.d.e', 'new world')\n  expect(object.b.d.e).toBe('new world')\n\n  setByPath(object, 'f.0', { g: 'new array-item-1' })\n  expect(object.f[0]).toStrictEqual({ g: 'new array-item-1' })\n\n  setByPath(object, 'f.1.g', 'new array-item-2')\n  expect(object.f[1].g).toBe('new array-item-2')\n})\n\nit('Test readme usage example: \u2699\ufe0f Customizing the Depth Limit', () => {\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  function getByPathDepth5<T extends SearchableObject, P extends Path<T, 5> & string>(\n    object: T,\n    path: P,\n  ): PathValue<T, P, 5> {\n    return getByPath(object, path) as PathValue<T, P, 5>\n  }\n\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  function setByPathDepth5<\n    T extends SearchableObject,\n    P extends Path<T, 5> & string,\n    V extends PathValue<T, P, 5>,\n  >(object: T, path: P, value: V): void {\n    setByPath(object, path, value as PathValue<T, P>)\n  }\n\n  // previous readme test still works\n  const object = {\n    a: 'hello',\n    b: {\n      c: 42,\n      d: {\n        e: 'world',\n      },\n    },\n    f: [{ g: 'array-item-1' }, { g: 'array-item-2' }],\n  }\n\n  // Example 1: Get a value by path\n  const value1 = getByPathDepth5(object, 'a') // Output: 'hello'\n  expect(value1).toBe('hello')\n\n  const value2 = getByPathDepth5(object, 'b.c') // Output: 42\n  expect(value2).toBe(42)\n\n  const value3 = getByPathDepth5(object, 'b.d.e') // Output: 'world'\n  expect(value3).toBe('world')\n\n  const value4 = getByPathDepth5(object, 'f.0') // Output: { g: 'array-item-1' }\n  expect(value4).toStrictEqual({ g: 'array-item-1' })\n\n  const value5 = getByPathDepth5(object, 'f.1.g') // Output: 'array-item-2'\n  expect(value5).toBe('array-item-2')\n\n  // Example 2: Set a value by path\n  setByPathDepth5(object, 'a', 'new hello')\n  expect(object.a).toBe('new hello')\n\n  setByPathDepth5(object, 'b.c', 100)\n  expect(object.b.c).toBe(100)\n\n  setByPathDepth5(object, 'b.d.e', 'new world')\n  expect(object.b.d.e).toBe('new world')\n\n  setByPathDepth5(object, 'f.0', { g: 'new array-item-1' })\n  expect(object.f[0]).toStrictEqual({ g: 'new array-item-1' })\n\n  setByPathDepth5(object, 'f.1.g', 'new array-item-2')\n  expect(object.f[1].g).toBe('new array-item-2')\n})\n\nit('Test for prototype pollution', () => {\n  const object = {}\n\n  expect(() => {\n    // @ts-expect-error - this is not a valid path for the object\n    setByPath(object, '__proto__.polluted', true)\n  }).toThrowError('__proto__')\n\n  // @ts-expect-error - this is not a valid path for the object\n  expect(getByPath(object, '__proto__')).toBe(undefined)\n\n  expect(() => {\n    // @ts-expect-error - this is not a valid path for the object\n    setByPath(object, 'constructor.polluted', true)\n  }).toThrowError('constructor')\n\n  // @ts-expect-error - this is not a valid path for the object\n  expect(getByPath(object, 'constructor')).toBe(undefined)\n\n  // @ts-expect-error - this is should not be defined on the object\n  expect(object.polluted).toBe(undefined)\n\n  const object2 = { constructor: { prototype: { polluted: true } } }\n\n  expect(getByPath(object2, 'constructor.prototype.polluted')).toBe(true)\n\n  setByPath(object2, 'constructor.prototype.polluted', false)\n\n  expect(object2.constructor.prototype.polluted).toBe(false)\n\n  // eslint-disable-next-line @typescript-eslint/no-extraneous-class\n  const testClass = class TestClass {\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor, @typescript-eslint/no-empty-function\n    constructor() {}\n  }\n\n  const object3 = new testClass()\n\n  // @ts-expect-error - this is not a valid path for the object\n  expect(getByPath(object3, 'constructor.prototype')).toBe(undefined)\n\n  // @ts-expect-error - this is not a valid path for the object\n  expect(getByPath(object3, 'constructor')).toBe(undefined)\n\n  expect(() => {\n    // @ts-expect-error - this is not a valid path for the object\n    setByPath(object3, 'constructor.polluted', true)\n  }).toThrowError('constructor')\n\n  expect(() => {\n    // @ts-expect-error - this is not a valid path for the object\n    setByPath(object3, '__proto__.polluted', true)\n  }).toThrowError('__proto__')\n})\n"], "filenames": ["CHANGELOG.md", "src/index.ts", "test/index.test.ts"], "buggy_code_start_loc": [9, 220, 162], "buggy_code_end_loc": [9, 279, 162], "fixing_code_start_loc": [10, 221, 163], "fixing_code_end_loc": [11, 300, 218], "type": "CWE-1321", "message": "Dot diver is a lightweight, powerful, and dependency-free TypeScript utility library that provides types and functions to work with object paths in dot notation. In versions prior to 1.0.2 there is a Prototype Pollution vulnerability in the `setByPath` function which can leads to remote code execution (RCE). This issue has been addressed in commit `98daf567` which has been included in release 1.0.2. Users are advised to upgrade. There are no known workarounds to this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-45827", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-06T18:15:08.467", "lastModified": "2023-11-14T17:10:21.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dot diver is a lightweight, powerful, and dependency-free TypeScript utility library that provides types and functions to work with object paths in dot notation. In versions prior to 1.0.2 there is a Prototype Pollution vulnerability in the `setByPath` function which can leads to remote code execution (RCE). This issue has been addressed in commit `98daf567` which has been included in release 1.0.2. Users are advised to upgrade. There are no known workarounds to this vulnerability.\n"}, {"lang": "es", "value": "Dot diver es una librer\u00eda de utilidades TypeScript liviana, potente y sin dependencias que proporciona tipos y funciones para trabajar con rutas de objetos en notaci\u00f3n de puntos. En versiones anteriores a la 1.0.2 hay una vulnerabilidad de contaminaci\u00f3n de prototipo en la funci\u00f3n `setByPath` que puede conducir a la Ejecuci\u00f3n Remota de C\u00f3digo (RCE). Este problema se solucion\u00f3 en el commit `98daf567` que se incluy\u00f3 en la versi\u00f3n 1.0.2. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clickbar:dot-diver:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.0.2", "matchCriteriaId": "B282AFD1-80AC-4421-BAA9-C5B8951E3841"}]}]}], "references": [{"url": "https://github.com/clickbar/dot-diver/commit/98daf567390d816fd378ec998eefe2e97f293d5a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/clickbar/dot-diver/security/advisories/GHSA-9w5f-mw3p-pj47", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/clickbar/dot-diver/commit/98daf567390d816fd378ec998eefe2e97f293d5a"}}