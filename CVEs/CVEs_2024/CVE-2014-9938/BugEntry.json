{"buggy_code": ["# bash/zsh git prompt support\n#\n# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>\n# Distributed under the GNU General Public License, version 2.0.\n#\n# This script allows you to see repository status in your prompt.\n#\n# To enable:\n#\n#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).\n#    2) Add the following line to your .bashrc/.zshrc:\n#        source ~/.git-prompt.sh\n#    3a) Change your PS1 to call __git_ps1 as\n#        command-substitution:\n#        Bash: PS1='[\\u@\\h \\W$(__git_ps1 \" (%s)\")]\\$ '\n#        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 \" (%s)\")]\\$ '\n#        the optional argument will be used as format string.\n#    3b) Alternatively, for a slightly faster prompt, __git_ps1 can\n#        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh\n#        with two parameters, <pre> and <post>, which are strings\n#        you would put in $PS1 before and after the status string\n#        generated by the git-prompt machinery.  e.g.\n#        Bash: PROMPT_COMMAND='__git_ps1 \"\\u@\\h:\\w\" \"\\\\\\$ \"'\n#          will show username, at-sign, host, colon, cwd, then\n#          various status string, followed by dollar and SP, as\n#          your prompt.\n#        ZSH:  precmd () { __git_ps1 \"%n\" \":%~$ \" \"|%s\" }\n#          will show username, pipe, then various status string,\n#          followed by colon, cwd, dollar and SP, as your prompt.\n#        Optionally, you can supply a third argument with a printf\n#        format string to finetune the output of the branch status\n#\n# The repository status will be displayed only if you are currently in a\n# git repository. The %s token is the placeholder for the shown status.\n#\n# The prompt status always includes the current branch name.\n#\n# In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,\n# unstaged (*) and staged (+) changes will be shown next to the branch\n# name.  You can configure this per-repository with the\n# bash.showDirtyState variable, which defaults to true once\n# GIT_PS1_SHOWDIRTYSTATE is enabled.\n#\n# You can also see if currently something is stashed, by setting\n# GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,\n# then a '$' will be shown next to the branch name.\n#\n# If you would like to see if there're untracked files, then you can set\n# GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked\n# files, then a '%' will be shown next to the branch name.  You can\n# configure this per-repository with the bash.showUntrackedFiles\n# variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is\n# enabled.\n#\n# If you would like to see the difference between HEAD and its upstream,\n# set GIT_PS1_SHOWUPSTREAM=\"auto\".  A \"<\" indicates you are behind, \">\"\n# indicates you are ahead, \"<>\" indicates you have diverged and \"=\"\n# indicates that there is no difference. You can further control\n# behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list\n# of values:\n#\n#     verbose       show number of commits ahead/behind (+/-) upstream\n#     name          if verbose, then also show the upstream abbrev name\n#     legacy        don't use the '--count' option available in recent\n#                   versions of git-rev-list\n#     git           always compare HEAD to @{upstream}\n#     svn           always compare HEAD to your SVN upstream\n#\n# By default, __git_ps1 will compare HEAD to your SVN upstream if it can\n# find one, or @{upstream} otherwise.  Once you have set\n# GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by\n# setting the bash.showUpstream config variable.\n#\n# If you would like to see more information about the identity of\n# commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE\n# to one of these values:\n#\n#     contains      relative to newer annotated tag (v1.6.3.2~35)\n#     branch        relative to newer tag or branch (master~4)\n#     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)\n#     default       exactly matching tag\n#\n# If you would like a colored hint about the current dirty state, set\n# GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on\n# the colored output of \"git status -sb\" and are available only when\n# using __git_ps1 for PROMPT_COMMAND or precmd.\n\n# check whether printf supports -v\n__git_printf_supports_v=\nprintf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1\n\n# stores the divergence from upstream in $p\n# used by GIT_PS1_SHOWUPSTREAM\n__git_ps1_show_upstream ()\n{\n\tlocal key value\n\tlocal svn_remote svn_url_pattern count n\n\tlocal upstream=git legacy=\"\" verbose=\"\" name=\"\"\n\n\tsvn_remote=()\n\t# get some config options from git-config\n\tlocal output=\"$(git config -z --get-regexp '^(svn-remote\\..*\\.url|bash\\.showupstream)$' 2>/dev/null | tr '\\0\\n' '\\n ')\"\n\twhile read -r key value; do\n\t\tcase \"$key\" in\n\t\tbash.showupstream)\n\t\t\tGIT_PS1_SHOWUPSTREAM=\"$value\"\n\t\t\tif [[ -z \"${GIT_PS1_SHOWUPSTREAM}\" ]]; then\n\t\t\t\tp=\"\"\n\t\t\t\treturn\n\t\t\tfi\n\t\t\t;;\n\t\tsvn-remote.*.url)\n\t\t\tsvn_remote[$((${#svn_remote[@]} + 1))]=\"$value\"\n\t\t\tsvn_url_pattern=\"$svn_url_pattern\\\\|$value\"\n\t\t\tupstream=svn+git # default upstream is SVN if available, else git\n\t\t\t;;\n\t\tesac\n\tdone <<< \"$output\"\n\n\t# parse configuration values\n\tfor option in ${GIT_PS1_SHOWUPSTREAM}; do\n\t\tcase \"$option\" in\n\t\tgit|svn) upstream=\"$option\" ;;\n\t\tverbose) verbose=1 ;;\n\t\tlegacy)  legacy=1  ;;\n\t\tname)    name=1 ;;\n\t\tesac\n\tdone\n\n\t# Find our upstream\n\tcase \"$upstream\" in\n\tgit)    upstream=\"@{upstream}\" ;;\n\tsvn*)\n\t\t# get the upstream from the \"git-svn-id: ...\" in a commit message\n\t\t# (git-svn uses essentially the same procedure internally)\n\t\tlocal -a svn_upstream\n\t\tsvn_upstream=($(git log --first-parent -1 \\\n\t\t\t\t\t--grep=\"^git-svn-id: \\(${svn_url_pattern#??}\\)\" 2>/dev/null))\n\t\tif [[ 0 -ne ${#svn_upstream[@]} ]]; then\n\t\t\tsvn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}\n\t\t\tsvn_upstream=${svn_upstream%@*}\n\t\t\tlocal n_stop=\"${#svn_remote[@]}\"\n\t\t\tfor ((n=1; n <= n_stop; n++)); do\n\t\t\t\tsvn_upstream=${svn_upstream#${svn_remote[$n]}}\n\t\t\tdone\n\n\t\t\tif [[ -z \"$svn_upstream\" ]]; then\n\t\t\t\t# default branch name for checkouts with no layout:\n\t\t\t\tupstream=${GIT_SVN_ID:-git-svn}\n\t\t\telse\n\t\t\t\tupstream=${svn_upstream#/}\n\t\t\tfi\n\t\telif [[ \"svn+git\" = \"$upstream\" ]]; then\n\t\t\tupstream=\"@{upstream}\"\n\t\tfi\n\t\t;;\n\tesac\n\n\t# Find how many commits we are ahead/behind our upstream\n\tif [[ -z \"$legacy\" ]]; then\n\t\tcount=\"$(git rev-list --count --left-right \\\n\t\t\t\t\"$upstream\"...HEAD 2>/dev/null)\"\n\telse\n\t\t# produce equivalent output to --count for older versions of git\n\t\tlocal commits\n\t\tif commits=\"$(git rev-list --left-right \"$upstream\"...HEAD 2>/dev/null)\"\n\t\tthen\n\t\t\tlocal commit behind=0 ahead=0\n\t\t\tfor commit in $commits\n\t\t\tdo\n\t\t\t\tcase \"$commit\" in\n\t\t\t\t\"<\"*) ((behind++)) ;;\n\t\t\t\t*)    ((ahead++))  ;;\n\t\t\t\tesac\n\t\t\tdone\n\t\t\tcount=\"$behind\t$ahead\"\n\t\telse\n\t\t\tcount=\"\"\n\t\tfi\n\tfi\n\n\t# calculate the result\n\tif [[ -z \"$verbose\" ]]; then\n\t\tcase \"$count\" in\n\t\t\"\") # no upstream\n\t\t\tp=\"\" ;;\n\t\t\"0\t0\") # equal to upstream\n\t\t\tp=\"=\" ;;\n\t\t\"0\t\"*) # ahead of upstream\n\t\t\tp=\">\" ;;\n\t\t*\"\t0\") # behind upstream\n\t\t\tp=\"<\" ;;\n\t\t*)\t    # diverged from upstream\n\t\t\tp=\"<>\" ;;\n\t\tesac\n\telse\n\t\tcase \"$count\" in\n\t\t\"\") # no upstream\n\t\t\tp=\"\" ;;\n\t\t\"0\t0\") # equal to upstream\n\t\t\tp=\" u=\" ;;\n\t\t\"0\t\"*) # ahead of upstream\n\t\t\tp=\" u+${count#0\t}\" ;;\n\t\t*\"\t0\") # behind upstream\n\t\t\tp=\" u-${count%\t0}\" ;;\n\t\t*)\t    # diverged from upstream\n\t\t\tp=\" u+${count#*\t}-${count%\t*}\" ;;\n\t\tesac\n\t\tif [[ -n \"$count\" && -n \"$name\" ]]; then\n\t\t\tp=\"$p $(git rev-parse --abbrev-ref \"$upstream\" 2>/dev/null)\"\n\t\tfi\n\tfi\n\n}\n\n# Helper function that is meant to be called from __git_ps1.  It\n# injects color codes into the appropriate gitstring variables used\n# to build a gitstring.\n__git_ps1_colorize_gitstring ()\n{\n\tif [[ -n ${ZSH_VERSION-} ]]; then\n\t\tlocal c_red='%F{red}'\n\t\tlocal c_green='%F{green}'\n\t\tlocal c_lblue='%F{blue}'\n\t\tlocal c_clear='%f'\n\telse\n\t\t# Using \\[ and \\] around colors is necessary to prevent\n\t\t# issues with command line editing/browsing/completion!\n\t\tlocal c_red='\\[\\e[31m\\]'\n\t\tlocal c_green='\\[\\e[32m\\]'\n\t\tlocal c_lblue='\\[\\e[1;34m\\]'\n\t\tlocal c_clear='\\[\\e[0m\\]'\n\tfi\n\tlocal bad_color=$c_red\n\tlocal ok_color=$c_green\n\tlocal flags_color=\"$c_lblue\"\n\n\tlocal branch_color=\"\"\n\tif [ $detached = no ]; then\n\t\tbranch_color=\"$ok_color\"\n\telse\n\t\tbranch_color=\"$bad_color\"\n\tfi\n\tc=\"$branch_color$c\"\n\n\tz=\"$c_clear$z\"\n\tif [ \"$w\" = \"*\" ]; then\n\t\tw=\"$bad_color$w\"\n\tfi\n\tif [ -n \"$i\" ]; then\n\t\ti=\"$ok_color$i\"\n\tfi\n\tif [ -n \"$s\" ]; then\n\t\ts=\"$flags_color$s\"\n\tfi\n\tif [ -n \"$u\" ]; then\n\t\tu=\"$bad_color$u\"\n\tfi\n\tr=\"$c_clear$r\"\n}\n\n# __git_ps1 accepts 0 or 1 arguments (i.e., format string)\n# when called from PS1 using command substitution\n# in this mode it prints text to add to bash PS1 prompt (includes branch name)\n#\n# __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)\n# in that case it _sets_ PS1. The arguments are parts of a PS1 string.\n# when two arguments are given, the first is prepended and the second appended\n# to the state string when assigned to PS1.\n# The optional third parameter will be used as printf format string to further\n# customize the output of the git-status string.\n# In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true\n__git_ps1 ()\n{\n\tlocal pcmode=no\n\tlocal detached=no\n\tlocal ps1pc_start='\\u@\\h:\\w '\n\tlocal ps1pc_end='\\$ '\n\tlocal printf_format=' (%s)'\n\n\tcase \"$#\" in\n\t\t2|3)\tpcmode=yes\n\t\t\tps1pc_start=\"$1\"\n\t\t\tps1pc_end=\"$2\"\n\t\t\tprintf_format=\"${3:-$printf_format}\"\n\t\t;;\n\t\t0|1)\tprintf_format=\"${1:-$printf_format}\"\n\t\t;;\n\t\t*)\treturn\n\t\t;;\n\tesac\n\n\tlocal repo_info rev_parse_exit_code\n\trepo_info=\"$(git rev-parse --git-dir --is-inside-git-dir \\\n\t\t--is-bare-repository --is-inside-work-tree \\\n\t\t--short HEAD 2>/dev/null)\"\n\trev_parse_exit_code=\"$?\"\n\n\tif [ -z \"$repo_info\" ]; then\n\t\tif [ $pcmode = yes ]; then\n\t\t\t#In PC mode PS1 always needs to be set\n\t\t\tPS1=\"$ps1pc_start$ps1pc_end\"\n\t\tfi\n\t\treturn\n\tfi\n\n\tlocal short_sha\n\tif [ \"$rev_parse_exit_code\" = \"0\" ]; then\n\t\tshort_sha=\"${repo_info##*$'\\n'}\"\n\t\trepo_info=\"${repo_info%$'\\n'*}\"\n\tfi\n\tlocal inside_worktree=\"${repo_info##*$'\\n'}\"\n\trepo_info=\"${repo_info%$'\\n'*}\"\n\tlocal bare_repo=\"${repo_info##*$'\\n'}\"\n\trepo_info=\"${repo_info%$'\\n'*}\"\n\tlocal inside_gitdir=\"${repo_info##*$'\\n'}\"\n\tlocal g=\"${repo_info%$'\\n'*}\"\n\n\tlocal r=\"\"\n\tlocal b=\"\"\n\tlocal step=\"\"\n\tlocal total=\"\"\n\tif [ -d \"$g/rebase-merge\" ]; then\n\t\tread b 2>/dev/null <\"$g/rebase-merge/head-name\"\n\t\tread step 2>/dev/null <\"$g/rebase-merge/msgnum\"\n\t\tread total 2>/dev/null <\"$g/rebase-merge/end\"\n\t\tif [ -f \"$g/rebase-merge/interactive\" ]; then\n\t\t\tr=\"|REBASE-i\"\n\t\telse\n\t\t\tr=\"|REBASE-m\"\n\t\tfi\n\telse\n\t\tif [ -d \"$g/rebase-apply\" ]; then\n\t\t\tread step 2>/dev/null <\"$g/rebase-apply/next\"\n\t\t\tread total 2>/dev/null <\"$g/rebase-apply/last\"\n\t\t\tif [ -f \"$g/rebase-apply/rebasing\" ]; then\n\t\t\t\tread b 2>/dev/null <\"$g/rebase-apply/head-name\"\n\t\t\t\tr=\"|REBASE\"\n\t\t\telif [ -f \"$g/rebase-apply/applying\" ]; then\n\t\t\t\tr=\"|AM\"\n\t\t\telse\n\t\t\t\tr=\"|AM/REBASE\"\n\t\t\tfi\n\t\telif [ -f \"$g/MERGE_HEAD\" ]; then\n\t\t\tr=\"|MERGING\"\n\t\telif [ -f \"$g/CHERRY_PICK_HEAD\" ]; then\n\t\t\tr=\"|CHERRY-PICKING\"\n\t\telif [ -f \"$g/REVERT_HEAD\" ]; then\n\t\t\tr=\"|REVERTING\"\n\t\telif [ -f \"$g/BISECT_LOG\" ]; then\n\t\t\tr=\"|BISECTING\"\n\t\tfi\n\n\t\tif [ -n \"$b\" ]; then\n\t\t\t:\n\t\telif [ -h \"$g/HEAD\" ]; then\n\t\t\t# symlink symbolic ref\n\t\t\tb=\"$(git symbolic-ref HEAD 2>/dev/null)\"\n\t\telse\n\t\t\tlocal head=\"\"\n\t\t\tif ! read head 2>/dev/null <\"$g/HEAD\"; then\n\t\t\t\tif [ $pcmode = yes ]; then\n\t\t\t\t\tPS1=\"$ps1pc_start$ps1pc_end\"\n\t\t\t\tfi\n\t\t\t\treturn\n\t\t\tfi\n\t\t\t# is it a symbolic ref?\n\t\t\tb=\"${head#ref: }\"\n\t\t\tif [ \"$head\" = \"$b\" ]; then\n\t\t\t\tdetached=yes\n\t\t\t\tb=\"$(\n\t\t\t\tcase \"${GIT_PS1_DESCRIBE_STYLE-}\" in\n\t\t\t\t(contains)\n\t\t\t\t\tgit describe --contains HEAD ;;\n\t\t\t\t(branch)\n\t\t\t\t\tgit describe --contains --all HEAD ;;\n\t\t\t\t(describe)\n\t\t\t\t\tgit describe HEAD ;;\n\t\t\t\t(* | default)\n\t\t\t\t\tgit describe --tags --exact-match HEAD ;;\n\t\t\t\tesac 2>/dev/null)\" ||\n\n\t\t\t\tb=\"$short_sha...\"\n\t\t\t\tb=\"($b)\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tif [ -n \"$step\" ] && [ -n \"$total\" ]; then\n\t\tr=\"$r $step/$total\"\n\tfi\n\n\tlocal w=\"\"\n\tlocal i=\"\"\n\tlocal s=\"\"\n\tlocal u=\"\"\n\tlocal c=\"\"\n\tlocal p=\"\"\n\n\tif [ \"true\" = \"$inside_gitdir\" ]; then\n\t\tif [ \"true\" = \"$bare_repo\" ]; then\n\t\t\tc=\"BARE:\"\n\t\telse\n\t\t\tb=\"GIT_DIR!\"\n\t\tfi\n\telif [ \"true\" = \"$inside_worktree\" ]; then\n\t\tif [ -n \"${GIT_PS1_SHOWDIRTYSTATE-}\" ] &&\n\t\t   [ \"$(git config --bool bash.showDirtyState)\" != \"false\" ]\n\t\tthen\n\t\t\tgit diff --no-ext-diff --quiet --exit-code || w=\"*\"\n\t\t\tif [ -n \"$short_sha\" ]; then\n\t\t\t\tgit diff-index --cached --quiet HEAD -- || i=\"+\"\n\t\t\telse\n\t\t\t\ti=\"#\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -n \"${GIT_PS1_SHOWSTASHSTATE-}\" ] &&\n\t\t   [ -r \"$g/refs/stash\" ]; then\n\t\t\ts=\"$\"\n\t\tfi\n\n\t\tif [ -n \"${GIT_PS1_SHOWUNTRACKEDFILES-}\" ] &&\n\t\t   [ \"$(git config --bool bash.showUntrackedFiles)\" != \"false\" ] &&\n\t\t   git ls-files --others --exclude-standard --error-unmatch -- '*' >/dev/null 2>/dev/null\n\t\tthen\n\t\t\tu=\"%${ZSH_VERSION+%}\"\n\t\tfi\n\n\t\tif [ -n \"${GIT_PS1_SHOWUPSTREAM-}\" ]; then\n\t\t\t__git_ps1_show_upstream\n\t\tfi\n\tfi\n\n\tlocal z=\"${GIT_PS1_STATESEPARATOR-\" \"}\"\n\n\t# NO color option unless in PROMPT_COMMAND mode\n\tif [ $pcmode = yes ] && [ -n \"${GIT_PS1_SHOWCOLORHINTS-}\" ]; then\n\t\t__git_ps1_colorize_gitstring\n\tfi\n\n\tlocal f=\"$w$i$s$u\"\n\tlocal gitstring=\"$c${b##refs/heads/}${f:+$z$f}$r$p\"\n\n\tif [ $pcmode = yes ]; then\n\t\tif [ \"${__git_printf_supports_v-}\" != yes ]; then\n\t\t\tgitstring=$(printf -- \"$printf_format\" \"$gitstring\")\n\t\telse\n\t\t\tprintf -v gitstring -- \"$printf_format\" \"$gitstring\"\n\t\tfi\n\t\tPS1=\"$ps1pc_start$gitstring$ps1pc_end\"\n\telse\n\t\tprintf -- \"$printf_format\" \"$gitstring\"\n\tfi\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2012 SZEDER G\u00e1bor\n#\n\ntest_description='test git-specific bash prompt functions'\n\n. ./lib-bash.sh\n\n. \"$GIT_BUILD_DIR/contrib/completion/git-prompt.sh\"\n\nactual=\"$TRASH_DIRECTORY/actual\"\nc_red='\\\\[\\\\e[31m\\\\]'\nc_green='\\\\[\\\\e[32m\\\\]'\nc_lblue='\\\\[\\\\e[1;34m\\\\]'\nc_clear='\\\\[\\\\e[0m\\\\]'\n\ntest_expect_success 'setup for prompt tests' '\n\tgit init otherrepo &&\n\techo 1 >file &&\n\tgit add file &&\n\ttest_tick &&\n\tgit commit -m initial &&\n\tgit tag -a -m msg1 t1 &&\n\tgit checkout -b b1 &&\n\techo 2 >file &&\n\tgit commit -m \"second b1\" file &&\n\techo 3 >file &&\n\tgit commit -m \"third b1\" file &&\n\tgit tag -a -m msg2 t2 &&\n\tgit checkout -b b2 master &&\n\techo 0 >file &&\n\tgit commit -m \"second b2\" file &&\n\techo 00 >file &&\n\tgit commit -m \"another b2\" file &&\n\techo 000 >file &&\n\tgit commit -m \"yet another b2\" file &&\n\tgit checkout master\n'\n\ntest_expect_success 'prompt - branch name' '\n\tprintf \" (master)\" >expected &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success SYMLINKS 'prompt - branch name - symlink symref' '\n\tprintf \" (master)\" >expected &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_config core.preferSymlinkRefs true &&\n\tgit checkout master &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - unborn branch' '\n\tprintf \" (unborn)\" >expected &&\n\tgit checkout --orphan unborn &&\n\ttest_when_finished \"git checkout master\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\nrepo_with_newline='repo\nwith\nnewline'\n\nif mkdir \"$repo_with_newline\" 2>/dev/null\nthen\n\ttest_set_prereq FUNNYNAMES\nelse\n\tsay 'Your filesystem does not allow newlines in filenames.'\nfi\n\ntest_expect_success FUNNYNAMES 'prompt - with newline in path' '\n\tprintf \" (master)\" >expected &&\n\tgit init \"$repo_with_newline\" &&\n\ttest_when_finished \"rm -rf \\\"$repo_with_newline\\\"\" &&\n\tmkdir \"$repo_with_newline\"/subdir &&\n\t(\n\t\tcd \"$repo_with_newline/subdir\" &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - detached head' '\n\tprintf \" ((%s...))\" $(git log -1 --format=\"%h\" --abbrev=13 b1^) >expected &&\n\ttest_config core.abbrev 13 &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - contains' '\n\tprintf \" ((t2~1))\" >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_DESCRIBE_STYLE=contains &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - branch' '\n\tprintf \" ((b1~1))\" >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_DESCRIBE_STYLE=branch &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - describe' '\n\tprintf \" ((t1-1-g%s))\" $(git log -1 --format=\"%h\" b1^) >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_DESCRIBE_STYLE=describe &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - default' '\n\tprintf \" ((t2))\" >expected &&\n\tgit checkout --detach b1 &&\n\ttest_when_finished \"git checkout master\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\t(\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - deep inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\t(\n\t\tcd .git/refs/heads &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - inside bare repository' '\n\tprintf \" (BARE:master)\" >expected &&\n\tgit init --bare bare.git &&\n\ttest_when_finished \"rm -rf bare.git\" &&\n\t(\n\t\tcd bare.git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - interactive rebase' '\n\tprintf \" (b1|REBASE-i 2/3)\" >expected\n\twrite_script fake_editor.sh <<-\\EOF &&\n\t\techo \"exec echo\" >\"$1\"\n\t\techo \"edit $(git log -1 --format=\"%h\")\" >>\"$1\"\n\t\techo \"exec echo\" >>\"$1\"\n\tEOF\n\ttest_when_finished \"rm -f fake_editor.sh\" &&\n\ttest_set_editor \"$TRASH_DIRECTORY/fake_editor.sh\" &&\n\tgit checkout b1 &&\n\ttest_when_finished \"git checkout master\" &&\n\tgit rebase -i HEAD^ &&\n\ttest_when_finished \"git rebase --abort\"\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - rebase merge' '\n\tprintf \" (b2|REBASE-m 1/3)\" >expected &&\n\tgit checkout b2 &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_must_fail git rebase --merge b1 b2 &&\n\ttest_when_finished \"git rebase --abort\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - rebase' '\n\tprintf \" (b2|REBASE 1/3)\" >expected &&\n\tgit checkout b2 &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_must_fail git rebase b1 b2 &&\n\ttest_when_finished \"git rebase --abort\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - merge' '\n\tprintf \" (b1|MERGING)\" >expected &&\n\tgit checkout b1 &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_must_fail git merge b2 &&\n\ttest_when_finished \"git reset --hard\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - cherry-pick' '\n\tprintf \" (master|CHERRY-PICKING)\" >expected &&\n\ttest_must_fail git cherry-pick b1 &&\n\ttest_when_finished \"git reset --hard\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bisect' '\n\tprintf \" (master|BISECTING)\" >expected &&\n\tgit bisect start &&\n\ttest_when_finished \"git bisect reset\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - clean' '\n\tprintf \" (master)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - dirty worktree' '\n\tprintf \" (master *)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - dirty index' '\n\tprintf \" (master +)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - dirty index and worktree' '\n\tprintf \" (master *+)\" >expected &&\n\techo \"dirty index\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\techo \"dirty worktree\" >file &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - before root commit' '\n\tprintf \" (master #)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tcd otherrepo &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable unset with config disabled' '\n\tprintf \" (master)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState false &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWDIRTYSTATE &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable unset with config enabled' '\n\tprintf \" (master)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState true &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWDIRTYSTATE &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable set with config disabled' '\n\tprintf \" (master)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState false &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable set with config enabled' '\n\tprintf \" (master *)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState true &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - not shown inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - stash status indicator - no stash' '\n\tprintf \" (master)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - stash status indicator - stash' '\n\tprintf \" (master $)\" >expected &&\n\techo 2 >file &&\n\tgit stash &&\n\ttest_when_finished \"git stash drop\" &&\n\tgit pack-refs --all &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - stash status indicator - not shown inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\techo 2 >file &&\n\tgit stash &&\n\ttest_when_finished \"git stash drop\" &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - no untracked files' '\n\tprintf \" (master)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\tcd otherrepo &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - untracked files' '\n\tprintf \" (master %%)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable unset with config disabled' '\n\tprintf \" (master)\" >expected &&\n\ttest_config bash.showUntrackedFiles false &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWUNTRACKEDFILES &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable unset with config enabled' '\n\tprintf \" (master)\" >expected &&\n\ttest_config bash.showUntrackedFiles true &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWUNTRACKEDFILES &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable set with config disabled' '\n\tprintf \" (master)\" >expected &&\n\ttest_config bash.showUntrackedFiles false &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable set with config enabled' '\n\tprintf \" (master %%)\" >expected &&\n\ttest_config bash.showUntrackedFiles true &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - not shown inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - format string starting with dash' '\n\tprintf -- \"-master\" >expected &&\n\t__git_ps1 \"-%s\" >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - pc mode' '\n\tprintf \"BEFORE: (master):AFTER\" >expected &&\n\tprintf \"\" >expected_output &&\n\t(\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" >\"$actual\" &&\n\t\ttest_cmp expected_output \"$actual\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - branch name' '\n\tprintf \"BEFORE: (${c_green}master${c_clear}):AFTER\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" >\"$actual\"\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - detached head' '\n\tprintf \"BEFORE: (${c_red}(%s...)${c_clear}):AFTER\" $(git log -1 --format=\"%h\" b1^) >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - dirty worktree' '\n\tprintf \"BEFORE: (${c_green}master${c_clear} ${c_red}*${c_clear}):AFTER\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - dirty index' '\n\tprintf \"BEFORE: (${c_green}master${c_clear} ${c_green}+${c_clear}):AFTER\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - dirty index and worktree' '\n\tprintf \"BEFORE: (${c_green}master${c_clear} ${c_red}*${c_green}+${c_clear}):AFTER\" >expected &&\n\techo \"dirty index\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\techo \"dirty worktree\" >file &&\n\t(\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - before root commit' '\n\tprintf \"BEFORE: (${c_green}master${c_clear} ${c_green}#${c_clear}):AFTER\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\tcd otherrepo &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - inside .git directory' '\n\tprintf \"BEFORE: (${c_green}GIT_DIR!${c_clear}):AFTER\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\tcd .git &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - stash status indicator' '\n\tprintf \"BEFORE: (${c_green}master${c_clear} ${c_lblue}\\$${c_clear}):AFTER\" >expected &&\n\techo 2 >file &&\n\tgit stash &&\n\ttest_when_finished \"git stash drop\" &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - untracked files status indicator' '\n\tprintf \"BEFORE: (${c_green}master${c_clear} ${c_red}%%${c_clear}):AFTER\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - zsh color pc mode' '\n\tprintf \"BEFORE: (%%F{green}master%%f):AFTER\" >expected &&\n\t(\n\t\tZSH_VERSION=5.0.0 &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" >\"$actual\"\n\t\tprintf \"%s\" \"$PS1\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_done\n"], "fixing_code": ["# bash/zsh git prompt support\n#\n# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>\n# Distributed under the GNU General Public License, version 2.0.\n#\n# This script allows you to see repository status in your prompt.\n#\n# To enable:\n#\n#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).\n#    2) Add the following line to your .bashrc/.zshrc:\n#        source ~/.git-prompt.sh\n#    3a) Change your PS1 to call __git_ps1 as\n#        command-substitution:\n#        Bash: PS1='[\\u@\\h \\W$(__git_ps1 \" (%s)\")]\\$ '\n#        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 \" (%s)\")]\\$ '\n#        the optional argument will be used as format string.\n#    3b) Alternatively, for a slightly faster prompt, __git_ps1 can\n#        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh\n#        with two parameters, <pre> and <post>, which are strings\n#        you would put in $PS1 before and after the status string\n#        generated by the git-prompt machinery.  e.g.\n#        Bash: PROMPT_COMMAND='__git_ps1 \"\\u@\\h:\\w\" \"\\\\\\$ \"'\n#          will show username, at-sign, host, colon, cwd, then\n#          various status string, followed by dollar and SP, as\n#          your prompt.\n#        ZSH:  precmd () { __git_ps1 \"%n\" \":%~$ \" \"|%s\" }\n#          will show username, pipe, then various status string,\n#          followed by colon, cwd, dollar and SP, as your prompt.\n#        Optionally, you can supply a third argument with a printf\n#        format string to finetune the output of the branch status\n#\n# The repository status will be displayed only if you are currently in a\n# git repository. The %s token is the placeholder for the shown status.\n#\n# The prompt status always includes the current branch name.\n#\n# In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,\n# unstaged (*) and staged (+) changes will be shown next to the branch\n# name.  You can configure this per-repository with the\n# bash.showDirtyState variable, which defaults to true once\n# GIT_PS1_SHOWDIRTYSTATE is enabled.\n#\n# You can also see if currently something is stashed, by setting\n# GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,\n# then a '$' will be shown next to the branch name.\n#\n# If you would like to see if there're untracked files, then you can set\n# GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked\n# files, then a '%' will be shown next to the branch name.  You can\n# configure this per-repository with the bash.showUntrackedFiles\n# variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is\n# enabled.\n#\n# If you would like to see the difference between HEAD and its upstream,\n# set GIT_PS1_SHOWUPSTREAM=\"auto\".  A \"<\" indicates you are behind, \">\"\n# indicates you are ahead, \"<>\" indicates you have diverged and \"=\"\n# indicates that there is no difference. You can further control\n# behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list\n# of values:\n#\n#     verbose       show number of commits ahead/behind (+/-) upstream\n#     name          if verbose, then also show the upstream abbrev name\n#     legacy        don't use the '--count' option available in recent\n#                   versions of git-rev-list\n#     git           always compare HEAD to @{upstream}\n#     svn           always compare HEAD to your SVN upstream\n#\n# By default, __git_ps1 will compare HEAD to your SVN upstream if it can\n# find one, or @{upstream} otherwise.  Once you have set\n# GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by\n# setting the bash.showUpstream config variable.\n#\n# If you would like to see more information about the identity of\n# commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE\n# to one of these values:\n#\n#     contains      relative to newer annotated tag (v1.6.3.2~35)\n#     branch        relative to newer tag or branch (master~4)\n#     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)\n#     default       exactly matching tag\n#\n# If you would like a colored hint about the current dirty state, set\n# GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on\n# the colored output of \"git status -sb\" and are available only when\n# using __git_ps1 for PROMPT_COMMAND or precmd.\n\n# check whether printf supports -v\n__git_printf_supports_v=\nprintf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1\n\n# stores the divergence from upstream in $p\n# used by GIT_PS1_SHOWUPSTREAM\n__git_ps1_show_upstream ()\n{\n\tlocal key value\n\tlocal svn_remote svn_url_pattern count n\n\tlocal upstream=git legacy=\"\" verbose=\"\" name=\"\"\n\n\tsvn_remote=()\n\t# get some config options from git-config\n\tlocal output=\"$(git config -z --get-regexp '^(svn-remote\\..*\\.url|bash\\.showupstream)$' 2>/dev/null | tr '\\0\\n' '\\n ')\"\n\twhile read -r key value; do\n\t\tcase \"$key\" in\n\t\tbash.showupstream)\n\t\t\tGIT_PS1_SHOWUPSTREAM=\"$value\"\n\t\t\tif [[ -z \"${GIT_PS1_SHOWUPSTREAM}\" ]]; then\n\t\t\t\tp=\"\"\n\t\t\t\treturn\n\t\t\tfi\n\t\t\t;;\n\t\tsvn-remote.*.url)\n\t\t\tsvn_remote[$((${#svn_remote[@]} + 1))]=\"$value\"\n\t\t\tsvn_url_pattern=\"$svn_url_pattern\\\\|$value\"\n\t\t\tupstream=svn+git # default upstream is SVN if available, else git\n\t\t\t;;\n\t\tesac\n\tdone <<< \"$output\"\n\n\t# parse configuration values\n\tfor option in ${GIT_PS1_SHOWUPSTREAM}; do\n\t\tcase \"$option\" in\n\t\tgit|svn) upstream=\"$option\" ;;\n\t\tverbose) verbose=1 ;;\n\t\tlegacy)  legacy=1  ;;\n\t\tname)    name=1 ;;\n\t\tesac\n\tdone\n\n\t# Find our upstream\n\tcase \"$upstream\" in\n\tgit)    upstream=\"@{upstream}\" ;;\n\tsvn*)\n\t\t# get the upstream from the \"git-svn-id: ...\" in a commit message\n\t\t# (git-svn uses essentially the same procedure internally)\n\t\tlocal -a svn_upstream\n\t\tsvn_upstream=($(git log --first-parent -1 \\\n\t\t\t\t\t--grep=\"^git-svn-id: \\(${svn_url_pattern#??}\\)\" 2>/dev/null))\n\t\tif [[ 0 -ne ${#svn_upstream[@]} ]]; then\n\t\t\tsvn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}\n\t\t\tsvn_upstream=${svn_upstream%@*}\n\t\t\tlocal n_stop=\"${#svn_remote[@]}\"\n\t\t\tfor ((n=1; n <= n_stop; n++)); do\n\t\t\t\tsvn_upstream=${svn_upstream#${svn_remote[$n]}}\n\t\t\tdone\n\n\t\t\tif [[ -z \"$svn_upstream\" ]]; then\n\t\t\t\t# default branch name for checkouts with no layout:\n\t\t\t\tupstream=${GIT_SVN_ID:-git-svn}\n\t\t\telse\n\t\t\t\tupstream=${svn_upstream#/}\n\t\t\tfi\n\t\telif [[ \"svn+git\" = \"$upstream\" ]]; then\n\t\t\tupstream=\"@{upstream}\"\n\t\tfi\n\t\t;;\n\tesac\n\n\t# Find how many commits we are ahead/behind our upstream\n\tif [[ -z \"$legacy\" ]]; then\n\t\tcount=\"$(git rev-list --count --left-right \\\n\t\t\t\t\"$upstream\"...HEAD 2>/dev/null)\"\n\telse\n\t\t# produce equivalent output to --count for older versions of git\n\t\tlocal commits\n\t\tif commits=\"$(git rev-list --left-right \"$upstream\"...HEAD 2>/dev/null)\"\n\t\tthen\n\t\t\tlocal commit behind=0 ahead=0\n\t\t\tfor commit in $commits\n\t\t\tdo\n\t\t\t\tcase \"$commit\" in\n\t\t\t\t\"<\"*) ((behind++)) ;;\n\t\t\t\t*)    ((ahead++))  ;;\n\t\t\t\tesac\n\t\t\tdone\n\t\t\tcount=\"$behind\t$ahead\"\n\t\telse\n\t\t\tcount=\"\"\n\t\tfi\n\tfi\n\n\t# calculate the result\n\tif [[ -z \"$verbose\" ]]; then\n\t\tcase \"$count\" in\n\t\t\"\") # no upstream\n\t\t\tp=\"\" ;;\n\t\t\"0\t0\") # equal to upstream\n\t\t\tp=\"=\" ;;\n\t\t\"0\t\"*) # ahead of upstream\n\t\t\tp=\">\" ;;\n\t\t*\"\t0\") # behind upstream\n\t\t\tp=\"<\" ;;\n\t\t*)\t    # diverged from upstream\n\t\t\tp=\"<>\" ;;\n\t\tesac\n\telse\n\t\tcase \"$count\" in\n\t\t\"\") # no upstream\n\t\t\tp=\"\" ;;\n\t\t\"0\t0\") # equal to upstream\n\t\t\tp=\" u=\" ;;\n\t\t\"0\t\"*) # ahead of upstream\n\t\t\tp=\" u+${count#0\t}\" ;;\n\t\t*\"\t0\") # behind upstream\n\t\t\tp=\" u-${count%\t0}\" ;;\n\t\t*)\t    # diverged from upstream\n\t\t\tp=\" u+${count#*\t}-${count%\t*}\" ;;\n\t\tesac\n\t\tif [[ -n \"$count\" && -n \"$name\" ]]; then\n\t\t\t__git_ps1_upstream_name=$(git rev-parse \\\n\t\t\t\t--abbrev-ref \"$upstream\" 2>/dev/null)\n\t\t\tif [ $pcmode = yes ]; then\n\t\t\t\t# see the comments around the\n\t\t\t\t# __git_ps1_branch_name variable below\n\t\t\t\tp=\"$p \\${__git_ps1_upstream_name}\"\n\t\t\telse\n\t\t\t\tp=\"$p ${__git_ps1_upstream_name}\"\n\t\t\t\t# not needed anymore; keep user's\n\t\t\t\t# environment clean\n\t\t\t\tunset __git_ps1_upstream_name\n\t\t\tfi\n\t\tfi\n\tfi\n\n}\n\n# Helper function that is meant to be called from __git_ps1.  It\n# injects color codes into the appropriate gitstring variables used\n# to build a gitstring.\n__git_ps1_colorize_gitstring ()\n{\n\tif [[ -n ${ZSH_VERSION-} ]]; then\n\t\tlocal c_red='%F{red}'\n\t\tlocal c_green='%F{green}'\n\t\tlocal c_lblue='%F{blue}'\n\t\tlocal c_clear='%f'\n\telse\n\t\t# Using \\[ and \\] around colors is necessary to prevent\n\t\t# issues with command line editing/browsing/completion!\n\t\tlocal c_red='\\[\\e[31m\\]'\n\t\tlocal c_green='\\[\\e[32m\\]'\n\t\tlocal c_lblue='\\[\\e[1;34m\\]'\n\t\tlocal c_clear='\\[\\e[0m\\]'\n\tfi\n\tlocal bad_color=$c_red\n\tlocal ok_color=$c_green\n\tlocal flags_color=\"$c_lblue\"\n\n\tlocal branch_color=\"\"\n\tif [ $detached = no ]; then\n\t\tbranch_color=\"$ok_color\"\n\telse\n\t\tbranch_color=\"$bad_color\"\n\tfi\n\tc=\"$branch_color$c\"\n\n\tz=\"$c_clear$z\"\n\tif [ \"$w\" = \"*\" ]; then\n\t\tw=\"$bad_color$w\"\n\tfi\n\tif [ -n \"$i\" ]; then\n\t\ti=\"$ok_color$i\"\n\tfi\n\tif [ -n \"$s\" ]; then\n\t\ts=\"$flags_color$s\"\n\tfi\n\tif [ -n \"$u\" ]; then\n\t\tu=\"$bad_color$u\"\n\tfi\n\tr=\"$c_clear$r\"\n}\n\n# __git_ps1 accepts 0 or 1 arguments (i.e., format string)\n# when called from PS1 using command substitution\n# in this mode it prints text to add to bash PS1 prompt (includes branch name)\n#\n# __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)\n# in that case it _sets_ PS1. The arguments are parts of a PS1 string.\n# when two arguments are given, the first is prepended and the second appended\n# to the state string when assigned to PS1.\n# The optional third parameter will be used as printf format string to further\n# customize the output of the git-status string.\n# In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true\n__git_ps1 ()\n{\n\tlocal pcmode=no\n\tlocal detached=no\n\tlocal ps1pc_start='\\u@\\h:\\w '\n\tlocal ps1pc_end='\\$ '\n\tlocal printf_format=' (%s)'\n\n\tcase \"$#\" in\n\t\t2|3)\tpcmode=yes\n\t\t\tps1pc_start=\"$1\"\n\t\t\tps1pc_end=\"$2\"\n\t\t\tprintf_format=\"${3:-$printf_format}\"\n\t\t;;\n\t\t0|1)\tprintf_format=\"${1:-$printf_format}\"\n\t\t;;\n\t\t*)\treturn\n\t\t;;\n\tesac\n\n\tlocal repo_info rev_parse_exit_code\n\trepo_info=\"$(git rev-parse --git-dir --is-inside-git-dir \\\n\t\t--is-bare-repository --is-inside-work-tree \\\n\t\t--short HEAD 2>/dev/null)\"\n\trev_parse_exit_code=\"$?\"\n\n\tif [ -z \"$repo_info\" ]; then\n\t\tif [ $pcmode = yes ]; then\n\t\t\t#In PC mode PS1 always needs to be set\n\t\t\tPS1=\"$ps1pc_start$ps1pc_end\"\n\t\tfi\n\t\treturn\n\tfi\n\n\tlocal short_sha\n\tif [ \"$rev_parse_exit_code\" = \"0\" ]; then\n\t\tshort_sha=\"${repo_info##*$'\\n'}\"\n\t\trepo_info=\"${repo_info%$'\\n'*}\"\n\tfi\n\tlocal inside_worktree=\"${repo_info##*$'\\n'}\"\n\trepo_info=\"${repo_info%$'\\n'*}\"\n\tlocal bare_repo=\"${repo_info##*$'\\n'}\"\n\trepo_info=\"${repo_info%$'\\n'*}\"\n\tlocal inside_gitdir=\"${repo_info##*$'\\n'}\"\n\tlocal g=\"${repo_info%$'\\n'*}\"\n\n\tlocal r=\"\"\n\tlocal b=\"\"\n\tlocal step=\"\"\n\tlocal total=\"\"\n\tif [ -d \"$g/rebase-merge\" ]; then\n\t\tread b 2>/dev/null <\"$g/rebase-merge/head-name\"\n\t\tread step 2>/dev/null <\"$g/rebase-merge/msgnum\"\n\t\tread total 2>/dev/null <\"$g/rebase-merge/end\"\n\t\tif [ -f \"$g/rebase-merge/interactive\" ]; then\n\t\t\tr=\"|REBASE-i\"\n\t\telse\n\t\t\tr=\"|REBASE-m\"\n\t\tfi\n\telse\n\t\tif [ -d \"$g/rebase-apply\" ]; then\n\t\t\tread step 2>/dev/null <\"$g/rebase-apply/next\"\n\t\t\tread total 2>/dev/null <\"$g/rebase-apply/last\"\n\t\t\tif [ -f \"$g/rebase-apply/rebasing\" ]; then\n\t\t\t\tread b 2>/dev/null <\"$g/rebase-apply/head-name\"\n\t\t\t\tr=\"|REBASE\"\n\t\t\telif [ -f \"$g/rebase-apply/applying\" ]; then\n\t\t\t\tr=\"|AM\"\n\t\t\telse\n\t\t\t\tr=\"|AM/REBASE\"\n\t\t\tfi\n\t\telif [ -f \"$g/MERGE_HEAD\" ]; then\n\t\t\tr=\"|MERGING\"\n\t\telif [ -f \"$g/CHERRY_PICK_HEAD\" ]; then\n\t\t\tr=\"|CHERRY-PICKING\"\n\t\telif [ -f \"$g/REVERT_HEAD\" ]; then\n\t\t\tr=\"|REVERTING\"\n\t\telif [ -f \"$g/BISECT_LOG\" ]; then\n\t\t\tr=\"|BISECTING\"\n\t\tfi\n\n\t\tif [ -n \"$b\" ]; then\n\t\t\t:\n\t\telif [ -h \"$g/HEAD\" ]; then\n\t\t\t# symlink symbolic ref\n\t\t\tb=\"$(git symbolic-ref HEAD 2>/dev/null)\"\n\t\telse\n\t\t\tlocal head=\"\"\n\t\t\tif ! read head 2>/dev/null <\"$g/HEAD\"; then\n\t\t\t\tif [ $pcmode = yes ]; then\n\t\t\t\t\tPS1=\"$ps1pc_start$ps1pc_end\"\n\t\t\t\tfi\n\t\t\t\treturn\n\t\t\tfi\n\t\t\t# is it a symbolic ref?\n\t\t\tb=\"${head#ref: }\"\n\t\t\tif [ \"$head\" = \"$b\" ]; then\n\t\t\t\tdetached=yes\n\t\t\t\tb=\"$(\n\t\t\t\tcase \"${GIT_PS1_DESCRIBE_STYLE-}\" in\n\t\t\t\t(contains)\n\t\t\t\t\tgit describe --contains HEAD ;;\n\t\t\t\t(branch)\n\t\t\t\t\tgit describe --contains --all HEAD ;;\n\t\t\t\t(describe)\n\t\t\t\t\tgit describe HEAD ;;\n\t\t\t\t(* | default)\n\t\t\t\t\tgit describe --tags --exact-match HEAD ;;\n\t\t\t\tesac 2>/dev/null)\" ||\n\n\t\t\t\tb=\"$short_sha...\"\n\t\t\t\tb=\"($b)\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tif [ -n \"$step\" ] && [ -n \"$total\" ]; then\n\t\tr=\"$r $step/$total\"\n\tfi\n\n\tlocal w=\"\"\n\tlocal i=\"\"\n\tlocal s=\"\"\n\tlocal u=\"\"\n\tlocal c=\"\"\n\tlocal p=\"\"\n\n\tif [ \"true\" = \"$inside_gitdir\" ]; then\n\t\tif [ \"true\" = \"$bare_repo\" ]; then\n\t\t\tc=\"BARE:\"\n\t\telse\n\t\t\tb=\"GIT_DIR!\"\n\t\tfi\n\telif [ \"true\" = \"$inside_worktree\" ]; then\n\t\tif [ -n \"${GIT_PS1_SHOWDIRTYSTATE-}\" ] &&\n\t\t   [ \"$(git config --bool bash.showDirtyState)\" != \"false\" ]\n\t\tthen\n\t\t\tgit diff --no-ext-diff --quiet --exit-code || w=\"*\"\n\t\t\tif [ -n \"$short_sha\" ]; then\n\t\t\t\tgit diff-index --cached --quiet HEAD -- || i=\"+\"\n\t\t\telse\n\t\t\t\ti=\"#\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -n \"${GIT_PS1_SHOWSTASHSTATE-}\" ] &&\n\t\t   [ -r \"$g/refs/stash\" ]; then\n\t\t\ts=\"$\"\n\t\tfi\n\n\t\tif [ -n \"${GIT_PS1_SHOWUNTRACKEDFILES-}\" ] &&\n\t\t   [ \"$(git config --bool bash.showUntrackedFiles)\" != \"false\" ] &&\n\t\t   git ls-files --others --exclude-standard --error-unmatch -- '*' >/dev/null 2>/dev/null\n\t\tthen\n\t\t\tu=\"%${ZSH_VERSION+%}\"\n\t\tfi\n\n\t\tif [ -n \"${GIT_PS1_SHOWUPSTREAM-}\" ]; then\n\t\t\t__git_ps1_show_upstream\n\t\tfi\n\tfi\n\n\tlocal z=\"${GIT_PS1_STATESEPARATOR-\" \"}\"\n\n\t# NO color option unless in PROMPT_COMMAND mode\n\tif [ $pcmode = yes ] && [ -n \"${GIT_PS1_SHOWCOLORHINTS-}\" ]; then\n\t\t__git_ps1_colorize_gitstring\n\tfi\n\n\tb=${b##refs/heads/}\n\tif [ $pcmode = yes ]; then\n\t\t# In pcmode (and only pcmode) the contents of\n\t\t# $gitstring are subject to expansion by the shell.\n\t\t# Avoid putting the raw ref name in the prompt to\n\t\t# protect the user from arbitrary code execution via\n\t\t# specially crafted ref names (e.g., a ref named\n\t\t# '$(IFS=_;cmd=sudo_rm_-rf_/;$cmd)' would execute\n\t\t# 'sudo rm -rf /' when the prompt is drawn).  Instead,\n\t\t# put the ref name in a new global variable (in the\n\t\t# __git_ps1_* namespace to avoid colliding with the\n\t\t# user's environment) and reference that variable from\n\t\t# PS1.\n\t\t__git_ps1_branch_name=$b\n\t\t# note that the $ is escaped -- the variable will be\n\t\t# expanded later (when it's time to draw the prompt)\n\t\tb=\"\\${__git_ps1_branch_name}\"\n\tfi\n\n\tlocal f=\"$w$i$s$u\"\n\tlocal gitstring=\"$c$b${f:+$z$f}$r$p\"\n\n\tif [ $pcmode = yes ]; then\n\t\tif [ \"${__git_printf_supports_v-}\" != yes ]; then\n\t\t\tgitstring=$(printf -- \"$printf_format\" \"$gitstring\")\n\t\telse\n\t\t\tprintf -v gitstring -- \"$printf_format\" \"$gitstring\"\n\t\tfi\n\t\tPS1=\"$ps1pc_start$gitstring$ps1pc_end\"\n\telse\n\t\tprintf -- \"$printf_format\" \"$gitstring\"\n\tfi\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2012 SZEDER G\u00e1bor\n#\n\ntest_description='test git-specific bash prompt functions'\n\n. ./lib-bash.sh\n\n. \"$GIT_BUILD_DIR/contrib/completion/git-prompt.sh\"\n\nactual=\"$TRASH_DIRECTORY/actual\"\nc_red='\\\\[\\\\e[31m\\\\]'\nc_green='\\\\[\\\\e[32m\\\\]'\nc_lblue='\\\\[\\\\e[1;34m\\\\]'\nc_clear='\\\\[\\\\e[0m\\\\]'\n\ntest_expect_success 'setup for prompt tests' '\n\tgit init otherrepo &&\n\techo 1 >file &&\n\tgit add file &&\n\ttest_tick &&\n\tgit commit -m initial &&\n\tgit tag -a -m msg1 t1 &&\n\tgit checkout -b b1 &&\n\techo 2 >file &&\n\tgit commit -m \"second b1\" file &&\n\techo 3 >file &&\n\tgit commit -m \"third b1\" file &&\n\tgit tag -a -m msg2 t2 &&\n\tgit checkout -b b2 master &&\n\techo 0 >file &&\n\tgit commit -m \"second b2\" file &&\n\techo 00 >file &&\n\tgit commit -m \"another b2\" file &&\n\techo 000 >file &&\n\tgit commit -m \"yet another b2\" file &&\n\tgit checkout master\n'\n\ntest_expect_success 'prompt - branch name' '\n\tprintf \" (master)\" >expected &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success SYMLINKS 'prompt - branch name - symlink symref' '\n\tprintf \" (master)\" >expected &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_config core.preferSymlinkRefs true &&\n\tgit checkout master &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - unborn branch' '\n\tprintf \" (unborn)\" >expected &&\n\tgit checkout --orphan unborn &&\n\ttest_when_finished \"git checkout master\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\nrepo_with_newline='repo\nwith\nnewline'\n\nif mkdir \"$repo_with_newline\" 2>/dev/null\nthen\n\ttest_set_prereq FUNNYNAMES\nelse\n\tsay 'Your filesystem does not allow newlines in filenames.'\nfi\n\ntest_expect_success FUNNYNAMES 'prompt - with newline in path' '\n\tprintf \" (master)\" >expected &&\n\tgit init \"$repo_with_newline\" &&\n\ttest_when_finished \"rm -rf \\\"$repo_with_newline\\\"\" &&\n\tmkdir \"$repo_with_newline\"/subdir &&\n\t(\n\t\tcd \"$repo_with_newline/subdir\" &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - detached head' '\n\tprintf \" ((%s...))\" $(git log -1 --format=\"%h\" --abbrev=13 b1^) >expected &&\n\ttest_config core.abbrev 13 &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - contains' '\n\tprintf \" ((t2~1))\" >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_DESCRIBE_STYLE=contains &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - branch' '\n\tprintf \" ((b1~1))\" >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_DESCRIBE_STYLE=branch &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - describe' '\n\tprintf \" ((t1-1-g%s))\" $(git log -1 --format=\"%h\" b1^) >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_DESCRIBE_STYLE=describe &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - describe detached head - default' '\n\tprintf \" ((t2))\" >expected &&\n\tgit checkout --detach b1 &&\n\ttest_when_finished \"git checkout master\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\t(\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - deep inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\t(\n\t\tcd .git/refs/heads &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - inside bare repository' '\n\tprintf \" (BARE:master)\" >expected &&\n\tgit init --bare bare.git &&\n\ttest_when_finished \"rm -rf bare.git\" &&\n\t(\n\t\tcd bare.git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - interactive rebase' '\n\tprintf \" (b1|REBASE-i 2/3)\" >expected\n\twrite_script fake_editor.sh <<-\\EOF &&\n\t\techo \"exec echo\" >\"$1\"\n\t\techo \"edit $(git log -1 --format=\"%h\")\" >>\"$1\"\n\t\techo \"exec echo\" >>\"$1\"\n\tEOF\n\ttest_when_finished \"rm -f fake_editor.sh\" &&\n\ttest_set_editor \"$TRASH_DIRECTORY/fake_editor.sh\" &&\n\tgit checkout b1 &&\n\ttest_when_finished \"git checkout master\" &&\n\tgit rebase -i HEAD^ &&\n\ttest_when_finished \"git rebase --abort\"\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - rebase merge' '\n\tprintf \" (b2|REBASE-m 1/3)\" >expected &&\n\tgit checkout b2 &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_must_fail git rebase --merge b1 b2 &&\n\ttest_when_finished \"git rebase --abort\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - rebase' '\n\tprintf \" (b2|REBASE 1/3)\" >expected &&\n\tgit checkout b2 &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_must_fail git rebase b1 b2 &&\n\ttest_when_finished \"git rebase --abort\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - merge' '\n\tprintf \" (b1|MERGING)\" >expected &&\n\tgit checkout b1 &&\n\ttest_when_finished \"git checkout master\" &&\n\ttest_must_fail git merge b2 &&\n\ttest_when_finished \"git reset --hard\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - cherry-pick' '\n\tprintf \" (master|CHERRY-PICKING)\" >expected &&\n\ttest_must_fail git cherry-pick b1 &&\n\ttest_when_finished \"git reset --hard\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bisect' '\n\tprintf \" (master|BISECTING)\" >expected &&\n\tgit bisect start &&\n\ttest_when_finished \"git bisect reset\" &&\n\t__git_ps1 >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - clean' '\n\tprintf \" (master)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - dirty worktree' '\n\tprintf \" (master *)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - dirty index' '\n\tprintf \" (master +)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - dirty index and worktree' '\n\tprintf \" (master *+)\" >expected &&\n\techo \"dirty index\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\techo \"dirty worktree\" >file &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - before root commit' '\n\tprintf \" (master #)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tcd otherrepo &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable unset with config disabled' '\n\tprintf \" (master)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState false &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWDIRTYSTATE &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable unset with config enabled' '\n\tprintf \" (master)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState true &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWDIRTYSTATE &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable set with config disabled' '\n\tprintf \" (master)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState false &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - shell variable set with config enabled' '\n\tprintf \" (master *)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\ttest_config bash.showDirtyState true &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - dirty status indicator - not shown inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - stash status indicator - no stash' '\n\tprintf \" (master)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - stash status indicator - stash' '\n\tprintf \" (master $)\" >expected &&\n\techo 2 >file &&\n\tgit stash &&\n\ttest_when_finished \"git stash drop\" &&\n\tgit pack-refs --all &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - stash status indicator - not shown inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\techo 2 >file &&\n\tgit stash &&\n\ttest_when_finished \"git stash drop\" &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - no untracked files' '\n\tprintf \" (master)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\tcd otherrepo &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - untracked files' '\n\tprintf \" (master %%)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable unset with config disabled' '\n\tprintf \" (master)\" >expected &&\n\ttest_config bash.showUntrackedFiles false &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWUNTRACKEDFILES &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable unset with config enabled' '\n\tprintf \" (master)\" >expected &&\n\ttest_config bash.showUntrackedFiles true &&\n\t(\n\t\tsane_unset GIT_PS1_SHOWUNTRACKEDFILES &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable set with config disabled' '\n\tprintf \" (master)\" >expected &&\n\ttest_config bash.showUntrackedFiles false &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - shell variable set with config enabled' '\n\tprintf \" (master %%)\" >expected &&\n\ttest_config bash.showUntrackedFiles true &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - untracked files status indicator - not shown inside .git directory' '\n\tprintf \" (GIT_DIR!)\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\tcd .git &&\n\t\t__git_ps1 >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - format string starting with dash' '\n\tprintf -- \"-master\" >expected &&\n\t__git_ps1 \"-%s\" >\"$actual\" &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - pc mode' '\n\tprintf \"BEFORE: (\\${__git_ps1_branch_name}):AFTER\\\\nmaster\" >expected &&\n\tprintf \"\" >expected_output &&\n\t(\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" >\"$actual\" &&\n\t\ttest_cmp expected_output \"$actual\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - branch name' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear}):AFTER\\\\nmaster\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" >\"$actual\"\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - detached head' '\n\tprintf \"BEFORE: (${c_red}\\${__git_ps1_branch_name}${c_clear}):AFTER\\\\n(%s...)\" $(git log -1 --format=\"%h\" b1^) >expected &&\n\tgit checkout b1^ &&\n\ttest_when_finished \"git checkout master\" &&\n\t(\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - dirty worktree' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear} ${c_red}*${c_clear}):AFTER\\\\nmaster\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - dirty index' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear} ${c_green}+${c_clear}):AFTER\\\\nmaster\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - dirty index and worktree' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear} ${c_red}*${c_green}+${c_clear}):AFTER\\\\nmaster\" >expected &&\n\techo \"dirty index\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\tgit add -u &&\n\techo \"dirty worktree\" >file &&\n\t(\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - dirty status indicator - before root commit' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear} ${c_green}#${c_clear}):AFTER\\\\nmaster\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\tcd otherrepo &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - inside .git directory' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear}):AFTER\\\\nGIT_DIR!\" >expected &&\n\techo \"dirty\" >file &&\n\ttest_when_finished \"git reset --hard\" &&\n\t(\n\t\tGIT_PS1_SHOWDIRTYSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\tcd .git &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - stash status indicator' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear} ${c_lblue}\\$${c_clear}):AFTER\\\\nmaster\" >expected &&\n\techo 2 >file &&\n\tgit stash &&\n\ttest_when_finished \"git stash drop\" &&\n\t(\n\t\tGIT_PS1_SHOWSTASHSTATE=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - bash color pc mode - untracked files status indicator' '\n\tprintf \"BEFORE: (${c_green}\\${__git_ps1_branch_name}${c_clear} ${c_red}%%${c_clear}):AFTER\\\\nmaster\" >expected &&\n\t(\n\t\tGIT_PS1_SHOWUNTRACKEDFILES=y &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" &&\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_expect_success 'prompt - zsh color pc mode' '\n\tprintf \"BEFORE: (%%F{green}\\${__git_ps1_branch_name}%%f):AFTER\\\\nmaster\" >expected &&\n\t(\n\t\tZSH_VERSION=5.0.0 &&\n\t\tGIT_PS1_SHOWCOLORHINTS=y &&\n\t\t__git_ps1 \"BEFORE:\" \":AFTER\" >\"$actual\"\n\t\tprintf \"%s\\\\n%s\" \"$PS1\" \"${__git_ps1_branch_name}\" >\"$actual\"\n\t) &&\n\ttest_cmp expected \"$actual\"\n'\n\ntest_done\n"], "filenames": ["contrib/completion/git-prompt.sh", "t/t9903-bash-prompt.sh"], "buggy_code_start_loc": [210, 455], "buggy_code_end_loc": [443, 587], "fixing_code_start_loc": [210, 455], "fixing_code_end_loc": [473, 587], "type": "CWE-116", "message": "contrib/completion/git-prompt.sh in Git before 1.9.3 does not sanitize branch names in the PS1 variable, allowing a malicious repository to cause code execution.", "other": {"cve": {"id": "CVE-2014-9938", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-20T00:59:00.160", "lastModified": "2020-04-29T20:26:44.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "contrib/completion/git-prompt.sh in Git before 1.9.3 does not sanitize branch names in the PS1 variable, allowing a malicious repository to cause code execution."}, {"lang": "es", "value": "Contrib/completion/git-prompt.sh en Git en versiones anteriores a 1.9.3 no desinfecta nombres de sucursales en la variable PS1, permitiendo que un repositorio malicioso cause la ejecuci\u00f3n de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.3", "matchCriteriaId": "D67E3C48-DF06-493E-8611-16DE842FE68A"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2017:2004", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/git/git/commit/8976500cbbb13270398d3b3e07a17b8cc7bff43f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/njhartwell/pw3nage", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/8976500cbbb13270398d3b3e07a17b8cc7bff43f"}}