{"buggy_code": ["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst uuidv4 = require('uuid/v4');\nconst semver = require('semver');\n\nconst Utils = require('../../utils');\nconst deprecations = require('../../utils/deprecations');\nconst SqlString = require('../../sql-string');\nconst DataTypes = require('../../data-types');\nconst Model = require('../../model');\nconst Association = require('../../associations/base');\nconst BelongsTo = require('../../associations/belongs-to');\nconst BelongsToMany = require('../../associations/belongs-to-many');\nconst HasMany = require('../../associations/has-many');\nconst Op = require('../../operators');\nconst sequelizeError = require('../../errors');\nconst IndexHints = require('../../index-hints');\n\nconst QuoteHelper = require('./query-generator/helpers/quote');\n\n/**\n * Abstract Query Generator\n *\n * @private\n */\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');\n    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');\n\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n\n    // dialect name\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n  }\n\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  }\n\n  addSchema(param) {\n    if (!param._schema) return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || '.',\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `DESCRIBE ${table};`;\n  }\n\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n\n  /**\n   * Returns an insert into command\n   *\n   * @param {string} table\n   * @param {Object} valueHash       attribute value pairs\n   * @param {Object} modelAttributes\n   * @param {Object} [options]\n   *\n   * @private\n   */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const fields = [];\n    const values = [];\n    const bind = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n    let query;\n    let valueQuery = '';\n    let emptyQuery = '';\n    let outputFragment = '';\n    let identityWrapperRequired = false;\n    let tmpTable = '';         //tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        valueQuery += ' RETURNING *';\n        emptyQuery += ' RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in modelAttributes) {\n            const attribute = modelAttributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += `${this.quoteIdentifier(attribute.field)} ${attribute.type.toSql()}`;\n              outputColumns += `INSERTED.${this.quoteIdentifier(attribute.field)}`;\n            }\n          }\n\n          tmpTable = `declare @tmp table (${tmpColumns});`;\n          outputFragment = ` OUTPUT ${outputColumns} into @tmp`;\n          const selectFromTmp = ';select * from @tmp';\n\n          valueQuery += selectFromTmp;\n          emptyQuery += selectFromTmp;\n        }\n      }\n    }\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Not currently supported with bind parameters (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));\n          }\n        }\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable\n    };\n\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${replacements.onConflictDoNothing}${emptyQuery}`;\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Mostly for internal use, so we expect the user to know what he's doing!\n      // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n        const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;\n\n        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n        valueQuery = `${`CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter}` +\n        ' BEGIN '}${valueQuery} INTO response; EXCEPTION ${options.exception} END ${delimiter\n        } LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()`;\n      } else {\n        options.exception = 'WHEN unique_violation THEN NULL;';\n        valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF ${quotedTable} AS $body$ BEGIN RETURN QUERY ${valueQuery}; EXCEPTION ${options.exception} END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();`;\n      }\n    }\n\n    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n      valueQuery += ` ON DUPLICATE KEY ${options.onDuplicate}`;\n      emptyQuery += ` ON DUPLICATE KEY ${options.onDuplicate}`;\n    }\n\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {Object} fieldValueHashes\n   * @param {Object} options\n   * @param {Object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (\n          fieldMappedAttributes[key]\n          && fieldMappedAttributes[key].autoIncrement === true\n        ) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map(key => {\n        if (\n          this._dialect.supports.bulkDefault\n          && serials[key] === true\n        ) {\n          return fieldValueHash[key] || 'DEFAULT';\n        }\n\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });\n      });\n\n      tuples.push(`(${values.join(',')})`);\n    }\n\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;\n      } else { // mysql / maria\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';\n    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';\n    let returning = '';\n\n    if (this._dialect.supports.returnValues && Array.isArray(options.returning)) {\n      const fields = options.returning.map(field => this.quoteIdentifier(field)).join(',');\n      returning += ` RETURNING ${fields}`;\n    } else {\n      returning += this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : '';\n    }\n\n    return `INSERT${ignoreDuplicates} INTO ${this.quoteTable(tableName)} (${attributes}) VALUES ${tuples.join(',')}${onDuplicateKeyUpdate}${onConflictDoNothing}${returning};`;\n  }\n\n  /**\n   * Returns an update query\n   *\n   * @param {string} tableName\n   * @param {Object} attrValueHash\n   * @param {Object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {Object} options\n   * @param {Object} attributes\n   *\n   * @private\n   */\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = '';\n    let tmpTable = '';        // tmpTable declaration for trigger\n    let selectFromTmp = '';   // Select statement for trigger\n    let suffix = '';\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      if (this.dialect !== 'mssql') {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      }\n    }\n\n    if (this._dialect.supports.returnValues) {\n      if (this._dialect.supports.returnValues.output) {\n        // we always need this for mssql\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in attributes) {\n            const attribute = attributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += `${this.quoteIdentifier(attribute.field)} ${attribute.type.toSql()}`;\n              outputColumns += `INSERTED.${this.quoteIdentifier(attribute.field)}`;\n            }\n          }\n\n          tmpTable = `declare @tmp table (${tmpColumns}); `;\n          outputFragment = ` OUTPUT ${outputColumns} into @tmp`;\n          selectFromTmp = ';select * from @tmp';\n\n          suffix += selectFromTmp;\n        }\n      } else if (this._dialect.supports.returnValues && options.returning) {\n        // ensure that the return output is properly mapped to model fields.\n        options.mapToModel = true;\n        suffix += ' RETURNING *';\n      }\n    }\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n          modelAttributeMap[key].autoIncrement === true &&\n          !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an update query using arithmetic operator\n   *\n   * @param {string} operator      String with the arithmetic operator (e.g. '+' or '-')\n   * @param {string} tableName     Name of the table\n   * @param {Object} attrValueHash A hash with attribute-value-pairs\n   * @param {Object} where         A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {Object} options\n   * @param {Object} attributes\n   */\n  arithmeticQuery(operator, tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n\n    const values = [];\n    let outputFragment = '';\n    let returningFragment = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        options.mapToModel = true;\n        returningFragment = 'RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(`${this.quoteIdentifier(key)}=${this.quoteIdentifier(key)}${operator} ${this.escape(value)}`);\n    }\n\n    attributes = attributes || {};\n    for (const key in attributes) {\n      const value = attributes[key];\n      values.push(`${this.quoteIdentifier(key)}=${this.escape(value)}`);\n    }\n\n    return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where)} ${returningFragment}`.trim();\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\"|')/g, '');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = Utils.nameIndex(options, options.prefix);\n    }\n\n    options = Model._conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',\n      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',\n      `(${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})`,\n      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,\n      this._dialect.supports.index.where && options.where ? options.where : undefined\n    );\n\n    return _.compact(ind).join(' ');\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const fieldsSqlQuotedString = fieldsSql.join(', ');\n    const fieldsSqlString = fieldsSql.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');\n        }\n\n        if (this._dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY':\n        const references = options.references;\n        if (!references || !references.table || !references.field) {\n          throw new Error('references object with table and field must be specified');\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const referencesSnippet = `${this.quoteTable(references.table)} (${this.quoteIdentifier(references.field)})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n    return constraintSnippet;\n  }\n\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} DROP CONSTRAINT ${this.quoteIdentifiers(constraintName)}`;\n  }\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST'\n    ];\n\n    // default\n    connector = connector || '.';\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n\n          if (typeof item === 'function' && item.prototype instanceof Model) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              // get from previous association\n              item = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationForAlias(model, as);\n\n              // attempt to use the model name if the item is still null\n              if (!item) {\n                item = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            // only go down this path if we have preivous model and check only once\n            if (previousModel.associations !== undefined && previousModel.associations[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n              // convert the item attribute from its alias\n              item = previousModel.rawAttributes[item].field;\n            } else if (\n              item.includes('.')\n              && previousModel.rawAttributes !== undefined\n            ) {\n              const itemSplit = item.split('.');\n\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      }, this);\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n\n      // loop through everything past i and append to the sql\n      collection.slice(i).forEach(collectionItem => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {\n      force,\n      quoteIdentifiers: this.options.quoteIdentifiers\n    });\n  }\n\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes('.')) {\n      identifiers = identifiers.split('.');\n\n      const head = identifiers.slice(0, identifiers.length - 1).join('.');\n      const tail = identifiers[identifiers.length - 1];\n\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n\n    return this.quoteIdentifier(identifiers);\n  }\n\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param {string|Object}  param table string or object\n   * @param {string|boolean} alias alias name\n   *\n   * @returns {string}\n   */\n  quoteTable(param, alias) {\n    let table = '';\n\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (alias) {\n      table += ` AS ${this.quoteIdentifier(alias)}`;\n    }\n\n    return table;\n  }\n\n  /*\n    Escape a value (e.g. a string, number or date)\n    @private\n  */\n  escape(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.stringify) {\n          // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);\n\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n\n          if (field.type.escape === false) {\n            // The data-type already did the required escaping\n            return value;\n          }\n        }\n      }\n    }\n\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n\n  bindParam(bind) {\n    return value => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n\n  /*\n    Returns a bind parameter representation of a value (e.g. a string, number or date)\n    @private\n  */\n  format(value, field, options, bindParam) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n\n    return bindParam(value);\n  }\n\n  /*\n    Validate a value against a field specification\n    @private\n  */\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(\n            error.message,\n            'Validation error',\n            field.fieldName,\n            value,\n            null,\n            `${field.type.key} validator`\n          ));\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  isIdentifierQuoted(identifier) {\n    return QuoteHelper.isIdentifierQuoted(identifier);\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               column  The JSON column\n   * @param   {string|Array<string>} [path]  The path to extract (optional)\n   * @returns {string}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column)\n      ? column\n      : this.quoteIdentifier(column);\n\n    switch (this.dialect) {\n      case 'mysql':\n        /**\n         * Sub paths need to be quoted as ECMAScript identifiers\n         * https://bugs.mysql.com/bug.php?id=81896\n         */\n        paths = paths.map(subPath => Utils.addTicks(subPath, '\"'));\n        pathStr = this.escape(['$'].concat(paths).join('.'));\n        return `(${quotedColumn}->>${pathStr})`;\n\n      case 'mariadb':\n        pathStr = this.escape(['$'].concat(paths).join('.'));\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n\n      case 'sqlite':\n        pathStr = this.escape(['$']\n          .concat(paths)\n          .join('.')\n          .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (_, digit) => `[${digit}]`));\n        return `json_extract(${quotedColumn}, ${pathStr})`;\n\n      case 'postgres':\n        pathStr = this.escape(`{${paths.join(',')}}`);\n        return `(${quotedColumn}#>>${pathStr})`;\n\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);\n\n    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(joinQueries.attributes.main);\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(joinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(''));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = Object.assign({}, options.where);\n        let groupedLimitOrder,\n          whereKey,\n          include,\n          groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: Object.assign({\n                [Op.placeholder]: true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where[Op.placeholder] = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = `SELECT * FROM (${this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            where,\n            include,\n            model\n          },\n          model\n        ).replace(/;$/, '')  }) AS sub`; // Every derived table must have its own alias\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value\n              };\n            }\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value\n              };\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }).join(\n            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '\n          )\n        })`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          // Walk the main query to update all selects\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith('SELECT')) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(t => this.quote(t, model)).join(', ') : this.quote(options.group, model);\n      if (subQuery) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ` FOR ${lock}`;\n      } else if (lock === 'SHARE') {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += ' SKIP LOCKED';\n      }\n    }\n\n    return `${query};`;\n  }\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else {\n          deprecations.noRawAttributes();\n        }\n        attr = [attr[0], this.quoteIdentifier(attr[1])].join(' AS ');\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"')\n          ? this.quoteAttribute(attr, options.model)\n          : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n\n      return attr;\n    });\n  }\n\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapOptionFieldNames(include, include.model);\n\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (\n            attr[0] instanceof Utils.Literal ||\n            attr[0] instanceof Utils.Cast ||\n            attr[0] instanceof Utils.Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);\n\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val; // We trust the user to rename the field correctly\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n            'This means the attribute will not be added to the returned instance'\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, '')})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        return `${prefix} AS ${this.quoteIdentifier(`${includeAs.externalAs}.${attrAs}`, true)}`;\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    //through\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes\n    };\n  }\n\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ?\n      association.identifier :\n      association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ?\n      association.identifierField :\n      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ?\n      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n      association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = `${asLeft}->${asRight}`;\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        joinOn = `${this.quoteTable(parent.as || parent.model.name)}.${this.quoteIdentifier(attrLeft)}`;\n      } else {\n        joinOn = this.quoteIdentifier(`${asLeft.replace(/->/g, '.')}.${attrLeft}`);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    return {\n      join: include.required ? 'INNER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: []\n      }\n    };\n  }\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map(attr =>\n      `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)\n      } AS ${\n        this.quoteIdentifier(`${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`)}`\n    );\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n\n    const joinType = include.required ? 'INNER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      sourceJoinOn = `${this.quoteIdentifier(`${tableSource}.${attrSource}`)} = `;\n    } else {\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(attrSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n\n    if (this._dialect.supports.joinTableDependent) {\n      // Generate a wrapped join so that the through table join can be dependent on the target join\n      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n      if (throughWhere) {\n        joinBody += ` AND ${throughWhere}`;\n      }\n      joinBody += ')';\n      joinCondition = sourceJoinOn;\n    } else {\n      // Generate join SQL for left side of through\n      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;\n      joinCondition = targetJoinOn;\n      if (throughWhere) {\n        joinCondition += ` AND ${throughWhere}`;\n      }\n    }\n\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n\n  /*\n   * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n   * For a given include a query is generated that contains all the way from the subQuery\n   * table to the include table plus everything that's in required transitive closure of the\n   * given include.\n   */\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n\n    while ((parent = parent.parent)) { // eslint-disable-line\n      if (parent.parent && !parent.required) {\n        return; // only generate subQueryFilter if all the parents of this include are required\n      }\n\n      if (parent.subQueryFilter) {\n        // the include is already handled as this parent has the include on its required closure\n        // skip to prevent duplicate subQueryFilter\n        return;\n      }\n\n      nestedIncludes = [Object.assign({}, child, { include: nestedIncludes, attributes: [] })];\n      child = parent;\n    }\n\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = undefined;\n\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(' = ')),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === 'BelongsTo';\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(' = ');\n\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      '(',\n      query.replace(/;$/, ''),\n      ')',\n      'IS NOT NULL'\n    ].join(' '));\n  }\n\n  /*\n   * For a given include hierarchy creates a copy of it where only the required includes\n   * are preserved.\n   */\n  _getRequiredClosure(include) {\n    const copy = Object.assign({}, include, { attributes: [], include: [] });\n\n    if (Array.isArray(include.include)) {\n      copy.include = include.include\n        .filter(i => i.required)\n        .map(inc => this._getRequiredClosure(inc));\n    }\n\n    return copy;\n  }\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)\n          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          subQueryOrder.push(this.quote(order, model, '->'));\n        }\n\n        if (subQuery) {\n          // Handle case where sub-query renames attribute we want to order by,\n          // see https://github.com/sequelize/sequelize/issues/8739\n          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);\n          if (subQueryAttribute) {\n            order[0] = new Utils.Col(subQueryAttribute[1]);\n          }\n        }\n\n        mainQueryOrder.push(this.quote(order, model, '->'));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->');\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return { mainQueryOrder, subQueryOrder };\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    if (mainTableAs) {\n      fragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {Object} options An object with selectQuery options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    /* eslint-disable */\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        return value === 'NULL' ? `${key} IS NULL` : [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if (typeof value === 'boolean') {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n\n      return value === 'NULL' ? `${key} IS NULL` : [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${smth.args.map(arg => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        }\n        if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        }\n        return this.escape(arg);\n      }).join(', ')  })`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n      }\n      if (smth.col.startsWith('*')) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return '';\n  }\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      where === null ||\n      where === undefined ||\n      Utils.getComplexSize(where) === 0\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (typeof where === 'string') {\n      throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding[0] !== ' ') binding = ` ${binding} `;\n\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach(prop => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  }\n\n  whereItemQuery(key, value, options = {}) {\n    if (value === undefined) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n\n    if (typeof key === 'string' && key.includes('.') && options.model) {\n      const keyParts = key.split('.');\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field.field || keyParts[0], tmp, Object.assign({ field }, options));\n      }\n    }\n\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n\n    if (value === null) {\n      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (!value) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to Op.and if possible, else treat as literal/replacements\n    if (key === undefined && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n\n\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    // If multiple keys we combine the different logic conditions\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n\n    if (key === Op.placeholder) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n\n  // OR/AND/NOT grouping logic\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? 'NOT ' : '';\n\n    if (Array.isArray(value)) {\n      value = value.map(item => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter(item => item && item.length);\n\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    // Op.or: [] should return no data.\n    // Op.not of no restriction should also return no data\n    if ((key === Op.or || key === Op.not) && !value) {\n      return '0 = 1';\n    }\n\n    return value ? `${outerBinding}(${value})` : undefined;\n  }\n\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map(prop => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map(item => this.whereItemQuery(key, item, options));\n    }\n\n    value = value.filter(item => item && item.length);\n\n    return value.length ? `(${value.join(binding)})` : undefined;\n  }\n\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n\n    Utils.getOperators(value).forEach(op => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, Object.assign({}, options, { json: false })));\n    });\n\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n\n    if (path[path.length - 1].includes('::')) {\n      const tmp = path[path.length - 1].split('::');\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n\n    const pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach(op => {\n        const value = this._toJSONValue(item[op]);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n\n      return;\n    }\n\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n\n  _toJSONValue(value) {\n    return value;\n  }\n\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n\n    return new Utils.Literal(key);\n  }\n\n  _getJsonCast(value) {\n    if (typeof value === 'number') {\n      return 'double precision';\n    }\n    if (value instanceof Date) {\n      return 'timestamptz';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    return;\n  }\n\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === undefined) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split('.');\n\n      if (key.length > 2) {\n        key = [\n          // join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'),\n          key[key.length - 1]\n        ];\n      }\n\n      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    }\n\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join('.');\n      }\n\n      return [this.quoteTable(prefix), key].join('.');\n    }\n\n    return key;\n  }\n\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);\n        }\n\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n        }\n\n        return '';\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split('.');\n\n        if (value.length > 2) {\n          value = [\n            // join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'),\n            value[value.length - 1]\n          ];\n        }\n\n        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);\n      case Op.startsWith:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`${value}%`), comparator, options.prefix);\n      case Op.endsWith:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`%${value}`), comparator, options.prefix);\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`%${value}%`), comparator, options.prefix);\n    }\n\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (prepend === undefined) {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === 'number') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error('Support for literal replacements in the `where` object has been removed.');\n    }\n    if (smth === null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return '1=1';\n  }\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n\n  booleanValue(value) {\n    return value;\n  }\n}\n\nObject.assign(QueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(QueryGenerator.prototype, require('./query-generator/transaction'));\n\nmodule.exports = QueryGenerator;\n", "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst MySQLQueryGenerator = require('../mysql/query-generator');\nconst util = require('util');\n\nclass MariaDBQueryGenerator extends MySQLQueryGenerator {\n\n  createSchema(schema, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)}${charset}${collate};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n\n  showSchemasQuery(options) {\n    const skip =  options.skip && Array.isArray(options.skip) && options.skip.length > 0 ? options.skip : null;\n    return `SELECT SCHEMA_NAME as schema_name FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA'${skip ? skip.reduce( (sql, schemaName) => sql +=  `,${this.escape(schemaName)}`, '') : ''});`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\') AND TABLE_TYPE = \\'BASE TABLE\\'';\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(\n          condition =>\n            `json_unquote(json_extract(${this.quoteIdentifier(\n              condition.path[0])},'$.${_.tail(condition.path).join(\n              '.')}')) = '${condition.value}'`\n        );\n\n        return conditions.join(' and ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json dot notation\n          let path = smth.path;\n          let startWithDot = true;\n\n          // Convert .number. to [number].\n          path = path.replace(/\\.(\\d+)\\./g, '[$1].');\n          // Convert .number$ to [number]\n          path = path.replace(/\\.(\\d+)$/, '[$1]');\n\n          path = path.split('.');\n\n          let columnName = path.shift();\n          const match = columnName.match(/\\[\\d+\\]$/);\n          // If columnName ends with [\\d+]\n          if (match !== null) {\n            path.unshift(columnName.substr(match.index));\n            columnName = columnName.substr(0, match.index);\n            startWithDot = false;\n          }\n\n          str = `json_unquote(json_extract(${this.quoteIdentifier(\n            columnName)},'$${startWithDot ? '.' : ''}${path.join('.')}'))`;\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      const lowType = smth.type.toLowerCase();\n      if (lowType.includes('timestamp')) {\n        smth.type = 'datetime';\n      } else if (smth.json && lowType.includes('boolean')) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (lowType.includes('double precision') || lowType.includes('boolean') || lowType.includes('integer')) {\n        smth.type = 'decimal';\n      } else if (lowType.includes('text')) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n}\n\nmodule.exports = MariaDBQueryGenerator;\n", "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,'\n  + 'CONSTRAINT_NAME as constraintName,'\n  + 'CONSTRAINT_SCHEMA as constraintSchema,'\n  + 'CONSTRAINT_SCHEMA as constraintCatalog,'\n  + 'TABLE_NAME as tableName,'\n  + 'TABLE_SCHEMA as tableSchema,'\n  + 'TABLE_SCHEMA as tableCatalog,'\n  + 'COLUMN_NAME as columnName,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,'\n  + 'REFERENCED_TABLE_NAME as referencedTableName,'\n  + 'REFERENCED_COLUMN_NAME as referencedColumnName';\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = Object.assign({}, this.OperatorMap, {\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const database = this.quoteIdentifier(databaseName);\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `${`CREATE DATABASE IF NOT EXISTS ${database}${charset}${collate}`.trim()};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName).trim()};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const comment = options.comment && typeof options.comment === 'string' ? ` COMMENT ${this.escape(options.comment)}` : '';\n    const engine = options.engine;\n    const charset = options.charset ? ` DEFAULT CHARSET=${options.charset}` : '';\n    const collation = options.collate ? ` COLLATE ${options.collate}` : '';\n    const rowFormat = options.rowFormat ? ` ROW_FORMAT=${options.rowFormat}` : '';\n    const initialAutoIncrement = options.initialAutoIncrement ? ` AUTO_INCREMENT=${options.initialAutoIncrement}` : '';\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${table} (${attributesClause}) ENGINE=${engine}${comment}${charset}${collation}${initialAutoIncrement}${rowFormat};`;\n  }\n\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery() {\n    return 'SHOW TABLES;';\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `CHANGE ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.quoteIdentifier(condition.path[0])}->>'$.${_.tail(condition.path).join('.')}' = '${condition.value}'`\n        );\n\n        return conditions.join(' and ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json dot notation\n          let path = smth.path;\n          let startWithDot = true;\n\n          // Convert .number. to [number].\n          path = path.replace(/\\.(\\d+)\\./g, '[$1].');\n          // Convert .number$ to [number]\n          path = path.replace(/\\.(\\d+)$/, '[$1]');\n\n          path = path.split('.');\n\n          let columnName = path.shift();\n          const match = columnName.match(/\\[\\d+\\]$/);\n          // If columnName ends with [\\d+]\n          if (match !== null) {\n            path.unshift(columnName.substr(match.index));\n            columnName = columnName.substr(0, match.index);\n            startWithDot = false;\n          }\n\n          str = `${this.quoteIdentifier(columnName)}->>'$${startWithDot ? '.' : ''}${path.join('.')}'`;\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return `${key}=VALUES(${key})`;\n    }).join(', ');\n\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return `SHOW INDEX FROM ${this.quoteTable(tableName)}${(options || {}).database ? ` FROM \\`${options.database}\\`` : ''}`;\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    let sql = [\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`\n    ].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}' AND REFERENCED_TABLE_NAME IS NOT NULL;`;\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE`\n      + ` WHERE (REFERENCED_TABLE_NAME = ${quotedTableName}${table.schema\n        ? ` AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`\n        : ''} AND REFERENCED_COLUMN_NAME = ${quotedColumnName})`\n      + ` OR (TABLE_NAME = ${quotedTableName}${table.schema ?\n        ` AND TABLE_SCHEMA = ${quotedSchemaName}` : ''} AND COLUMN_NAME = ${quotedColumnName} AND REFERENCED_TABLE_NAME IS NOT NULL)`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)}\n      DROP FOREIGN KEY ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n", "'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n\n    const bind = [];\n    const bindParam = this.bindParam(bind);\n\n    const upsertOptions = _.defaults({ bindParam }, options);\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    const query = `${insert.query} ${update.query}`;\n\n    return { query, bind };\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n}\n\nmodule.exports = SQLiteQueryGenerator;\n", "'use strict';\n\nconst chai = require('chai'),\n  Sequelize = require('../../../index'),\n  Op = Sequelize.Op,\n  Promise = Sequelize.Promise,\n  moment = require('moment'),\n  expect = chai.expect,\n  Support = require('../support'),\n  DataTypes = require('../../../lib/data-types'),\n  current = Support.sequelize;\n\ndescribe(Support.getTestDialectTeaser('Model'), () => {\n  if (current.dialect.supports.JSON) {\n    describe('JSON', () => {\n      beforeEach(function() {\n        this.Event = this.sequelize.define('Event', {\n          data: {\n            type: DataTypes.JSON,\n            field: 'event_data',\n            index: true\n          },\n          json: DataTypes.JSON\n        });\n\n        return this.Event.sync({ force: true });\n      });\n\n      if (current.dialect.supports.lock) {\n        it('findOrCreate supports transactions, json and locks', function() {\n          return current.transaction().then(transaction => {\n            return this.Event.findOrCreate({\n              where: {\n                json: { some: { input: 'Hello' } }\n              },\n              defaults: {\n                json: { some: { input: 'Hello' }, input: [1, 2, 3] },\n                data: { some: { input: 'There' }, input: [4, 5, 6] }\n              },\n              transaction,\n              lock: transaction.LOCK.UPDATE,\n              logging: sql => {\n                if (sql.includes('SELECT') && !sql.includes('CREATE')) {\n                  expect(sql.includes('FOR UPDATE')).to.be.true;\n                }\n              }\n            }).then(() => {\n              return this.Event.count().then(count => {\n                expect(count).to.equal(0);\n                return transaction.commit().then(() => {\n                  return this.Event.count().then(count => {\n                    expect(count).to.equal(1);\n                  });\n                });\n              });\n            });\n          });\n        });\n      }\n\n      describe('create', () => {\n        it('should create an instance with JSON data', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return this.Event.findAll().then(events => {\n              const event = events[0];\n\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n            });\n          });\n        });\n      });\n\n      describe('update', () => {\n        it('should update with JSON column (dot notation)', function() {\n          return this.Event.bulkCreate([{\n            id: 1,\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }, {\n            id: 2,\n            data: {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Multiverse Scientist'\n            }\n          }]).then(() => this.Event.update({\n            'data': {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            }\n          }, {\n            where: {\n              'data.name.first': 'Rick'\n            }\n          })).then(() => this.Event.findByPk(2)).then(event => {\n            expect(event.get('data')).to.eql({\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            });\n          });\n        });\n\n        it('should update with JSON column (JSON notation)', function() {\n          return this.Event.bulkCreate([{\n            id: 1,\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }, {\n            id: 2,\n            data: {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Multiverse Scientist'\n            }\n          }]).then(() => this.Event.update({\n            'data': {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            }\n          }, {\n            where: {\n              data: {\n                name: {\n                  first: 'Rick'\n                }\n              }\n            }\n          })).then(() => this.Event.findByPk(2)).then(event => {\n            expect(event.get('data')).to.eql({\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            });\n          });\n        });\n\n        it('should update an instance with JSON data', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(event => {\n            return event.update({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: null\n              }\n            });\n          }).then(() => {\n            return this.Event.findAll().then(events => {\n              const event = events[0];\n\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: null\n              });\n            });\n          });\n        });\n      });\n\n      describe('find', () => {\n        it('should be possible to query a nested value', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  employment: 'Housewife'\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              });\n            });\n          });\n        });\n\n        it('should be possible to query dates with array operators', function() {\n          const now = moment().milliseconds(0).toDate();\n          const before = moment().milliseconds(0).subtract(1, 'day').toDate();\n          const after = moment().milliseconds(0).add(1, 'day').toDate();\n          return Promise.join(\n            this.Event.create({\n              json: {\n                user: 'Homer',\n                lastLogin: now\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  lastLogin: now\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                lastLogin: now.toISOString()\n              });\n            });\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  lastLogin: { [Op.between]: [before, after] }\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                lastLogin: now.toISOString()\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a boolean with array operators', function() {\n          return Promise.join(\n            this.Event.create({\n              json: {\n                user: 'Homer',\n                active: true\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  active: true\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                active: true\n              });\n            });\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  active: { [Op.in]: [true, false] }\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                active: true\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a nested integer value', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                age: 40\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                age: 37\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  age: {\n                    [Op.gt]: 38\n                  }\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                age: 40\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a nested null value', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: null\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  employment: null\n                }\n              }\n            }).then(events => {\n              expect(events.length).to.equal(1);\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: null\n              });\n            });\n          });\n        });\n\n        it('should be possible to query for nested fields with hyphens/dashes, #8718', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                status_report: {\n                  'red-indicator': {\n                    'level$$level': true\n                  }\n                },\n                employment: 'Nuclear Safety Inspector'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: null\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  status_report: {\n                    'red-indicator': {\n                      'level$$level': true\n                    }\n                  }\n                }\n              }\n            }).then(events => {\n              expect(events.length).to.equal(1);\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                status_report: {\n                  'red-indicator': {\n                    'level$$level': true\n                  }\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n            });\n          });\n        });\n\n        it('should be possible to query multiple nested values', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return Promise.join(\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Marge',\n                    last: 'Simpson'\n                  },\n                  employment: 'Housewife'\n                }\n              }),\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Bart',\n                    last: 'Simpson'\n                  },\n                  employment: 'None'\n                }\n              })\n            );\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  name: {\n                    last: 'Simpson'\n                  },\n                  employment: {\n                    [Op.ne]: 'None'\n                  }\n                }\n              },\n              order: [\n                ['id', 'ASC']\n              ]\n            }).then(events => {\n              expect(events.length).to.equal(2);\n\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n\n              expect(events[1].get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a nested value and order results', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return Promise.join(\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Marge',\n                    last: 'Simpson'\n                  },\n                  employment: 'Housewife'\n                }\n              }),\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Bart',\n                    last: 'Simpson'\n                  },\n                  employment: 'None'\n                }\n              })\n            );\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  name: {\n                    last: 'Simpson'\n                  }\n                }\n              },\n              order: [\n                ['data.name.first']\n              ]\n            }).then(events => {\n              expect(events.length).to.equal(3);\n\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Bart',\n                  last: 'Simpson'\n                },\n                employment: 'None'\n              });\n\n              expect(events[1].get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n\n              expect(events[2].get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              });\n            });\n          });\n        });\n      });\n\n      describe('destroy', () => {\n        it('should be possible to destroy with where', function() {\n          const conditionSearch = {\n            where: {\n              data: {\n                employment: 'Hacker'\n              }\n            }\n          };\n\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Elliot',\n                  last: 'Alderson'\n                },\n                employment: 'Hacker'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Christian',\n                  last: 'Slater'\n                },\n                employment: 'Hacker'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: ' Tyrell',\n                  last: 'Wellick'\n                },\n                employment: 'CTO'\n              }\n            })\n          ).then(() => {\n            return expect(this.Event.findAll(conditionSearch)).to.eventually.have.length(2);\n          }).then(() => {\n            return this.Event.destroy(conditionSearch);\n          }).then(() => {\n            return expect(this.Event.findAll(conditionSearch)).to.eventually.have.length(0);\n          });\n        });\n      });\n\n      describe('sql injection attacks', () => {\n        beforeEach(function() {\n          this.Model = this.sequelize.define('Model', {\n            data: DataTypes.JSON\n          });\n          return this.sequelize.sync({ force: true });\n        });\n\n        it('should properly escape the single quotes', function() {\n          return this.Model.create({\n            data: {\n              type: 'Point',\n              properties: {\n                exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n              }\n            }\n          });\n        });\n\n        it('should properly escape path keys', function() {\n          return this.Model.findAll({\n            raw: true,\n            attributes: ['id'],\n            where: {\n              data: {\n                \"a')) AS DECIMAL) = 1 DELETE YOLO INJECTIONS; -- \": 1\n              }\n            }\n          });\n        });\n\n        it('should properly escape the single quotes in array', function() {\n          return this.Model.create({\n            data: {\n              type: 'Point',\n              coordinates: [39.807222, \"'); DELETE YOLO INJECTIONS; --\"]\n            }\n          });\n        });\n\n        it('should be possible to find with properly escaped select query', function() {\n          return this.Model.create({\n            data: {\n              type: 'Point',\n              properties: {\n                exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n              }\n            }\n          }).then(() => {\n            return this.Model.findOne({\n              where: {\n                data: {\n                  type: 'Point',\n                  properties: {\n                    exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n                  }\n                }\n              }\n            });\n          }).then(result => {\n            expect(result.get('data')).to.deep.equal({\n              type: 'Point',\n              properties: {\n                exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n              }\n            });\n          });\n        });\n\n        it('should query an instance with JSONB data and order while trying to inject', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return Promise.join(\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Marge',\n                    last: 'Simpson'\n                  },\n                  employment: 'Housewife'\n                }\n              }),\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Bart',\n                    last: 'Simpson'\n                  },\n                  employment: 'None'\n                }\n              })\n            );\n          }).then(() => {\n            if (current.options.dialect === 'sqlite') {\n              return this.Event.findAll({\n                where: {\n                  data: {\n                    name: {\n                      last: 'Simpson'\n                    }\n                  }\n                },\n                order: [\n                  [\"data.name.first}'); INSERT INJECTION HERE! SELECT ('\"]\n                ]\n              }).then(events => {\n                expect(events).to.be.ok;\n                expect(events[0].get('data')).to.eql({\n                  name: {\n                    first: 'Homer',\n                    last: 'Simpson'\n                  },\n                  employment: 'Nuclear Safety Inspector'\n                });\n              });\n            }\n            if (current.options.dialect === 'postgres') {\n              return expect(this.Event.findAll({\n                where: {\n                  data: {\n                    name: {\n                      last: 'Simpson'\n                    }\n                  }\n                },\n                order: [\n                  [\"data.name.first}'); INSERT INJECTION HERE! SELECT ('\"]\n                ]\n              })).to.eventually.be.rejectedWith(Error);\n            }\n          });\n        });\n      });\n    });\n  }\n\n});\n", "'use strict';\n\nconst Support = require('../support'),\n  DataTypes = require('../../../lib/data-types'),\n  expect = require('chai').expect,\n  expectsql = Support.expectsql,\n  Sequelize = Support.Sequelize,\n  current = Support.sequelize,\n  sql = current.dialect.QueryGenerator;\n\n// Notice: [] will be replaced by dialect specific tick/quote character when there is not dialect specific expectation but only a default expectation\nif (current.dialect.supports.JSON) {\n  describe(Support.getTestDialectTeaser('SQL'), () => {\n    describe('JSON', () => {\n      describe('escape', () => {\n        it('plain string', () => {\n          expectsql(sql.escape('string', { type: new DataTypes.JSON() }), {\n            default: '\\'\"string\"\\'',\n            mariadb: '\\'\\\\\"string\\\\\"\\'',\n            mysql: '\\'\\\\\"string\\\\\"\\''\n          });\n        });\n\n        it('plain int', () => {\n          expectsql(sql.escape(0, { type: new DataTypes.JSON() }), {\n            default: '\\'0\\''\n          });\n          expectsql(sql.escape(123, { type: new DataTypes.JSON() }), {\n            default: '\\'123\\''\n          });\n        });\n\n        it('boolean', () => {\n          expectsql(sql.escape(true, { type: new DataTypes.JSON() }), {\n            default: '\\'true\\''\n          });\n          expectsql(sql.escape(false, { type: new DataTypes.JSON() }), {\n            default: '\\'false\\''\n          });\n        });\n\n        it('NULL', () => {\n          expectsql(sql.escape(null, { type: new DataTypes.JSON() }), {\n            default: 'NULL'\n          });\n        });\n\n        it('nested object', () => {\n          expectsql(sql.escape({ some: 'nested', more: { nested: true }, answer: 42 }, { type: new DataTypes.JSON() }), {\n            default: '\\'{\"some\":\"nested\",\"more\":{\"nested\":true},\"answer\":42}\\'',\n            mariadb: '\\'{\\\\\"some\\\\\":\\\\\"nested\\\\\",\\\\\"more\\\\\":{\\\\\"nested\\\\\":true},\\\\\"answer\\\\\":42}\\'',\n            mysql: '\\'{\\\\\"some\\\\\":\\\\\"nested\\\\\",\\\\\"more\\\\\":{\\\\\"nested\\\\\":true},\\\\\"answer\\\\\":42}\\''\n          });\n        });\n\n        if (current.dialect.supports.ARRAY) {\n          it('array of JSON', () => {\n            expectsql(sql.escape([\n              { some: 'nested', more: { nested: true }, answer: 42 },\n              43,\n              'joe'\n            ], { type: DataTypes.ARRAY(DataTypes.JSON) }), {\n              postgres: 'ARRAY[\\'{\"some\":\"nested\",\"more\":{\"nested\":true},\"answer\":42}\\',\\'43\\',\\'\"joe\"\\']::JSON[]'\n            });\n          });\n\n          if (current.dialect.supports.JSONB) {\n            it('array of JSONB', () => {\n              expectsql(sql.escape([\n                { some: 'nested', more: { nested: true }, answer: 42 },\n                43,\n                'joe'\n              ], { type: DataTypes.ARRAY(DataTypes.JSONB) }), {\n                postgres: 'ARRAY[\\'{\"some\":\"nested\",\"more\":{\"nested\":true},\"answer\":42}\\',\\'43\\',\\'\"joe\"\\']::JSONB[]'\n              });\n            });\n          }\n        }\n      });\n\n      describe('path extraction', () => {\n        it('condition object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ id: 1 })), {\n            postgres: '(\"id\"#>>\\'{}\\') = \\'1\\'',\n            sqlite: \"json_extract(`id`, '$') = '1'\",\n            mariadb: \"json_unquote(json_extract(`id`,'$.')) = '1'\",\n            mysql: \"`id`->>'$.' = '1'\"\n          });\n        });\n\n        it('nested condition object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ profile: { id: 1 } })), {\n            postgres: '(\"profile\"#>>\\'{id}\\') = \\'1\\'',\n            sqlite: \"json_extract(`profile`, '$.id') = '1'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = '1'\",\n            mysql: \"`profile`->>'$.id' = '1'\"\n          });\n        });\n\n        it('multiple condition object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ property: { value: 1 }, another: { value: 'string' } })), {\n            postgres: '(\"property\"#>>\\'{value}\\') = \\'1\\' AND (\"another\"#>>\\'{value}\\') = \\'string\\'',\n            sqlite: \"json_extract(`property`, '$.value') = '1' AND json_extract(`another`, '$.value') = 'string'\",\n            mariadb: \"json_unquote(json_extract(`property`,'$.value')) = '1' and json_unquote(json_extract(`another`,'$.value')) = 'string'\",\n            mysql: \"`property`->>'$.value' = '1' and `another`->>'$.value' = 'string'\"\n          });\n        });\n\n        it('property array object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ property: [[4, 6], [8]] })), {\n            postgres: '(\"property\"#>>\\'{0,0}\\') = \\'4\\' AND (\"property\"#>>\\'{0,1}\\') = \\'6\\' AND (\"property\"#>>\\'{1,0}\\') = \\'8\\'',\n            sqlite: \"json_extract(`property`, '$[0][0]') = '4' AND json_extract(`property`, '$[0][1]') = '6' AND json_extract(`property`, '$[1][0]') = '8'\",\n            mariadb: \"json_unquote(json_extract(`property`,'$.0.0')) = '4' and json_unquote(json_extract(`property`,'$.0.1')) = '6' and json_unquote(json_extract(`property`,'$.1.0')) = '8'\",\n            mysql: \"`property`->>'$.0.0' = '4' and `property`->>'$.0.1' = '6' and `property`->>'$.1.0' = '8'\"\n          });\n        });\n\n        it('dot notation', () => {\n          expectsql(sql.whereItemQuery(Sequelize.json('profile.id'), '1'), {\n            postgres: '(\"profile\"#>>\\'{id}\\') = \\'1\\'',\n            sqlite: \"json_extract(`profile`, '$.id') = '1'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = '1'\",\n            mysql: \"`profile`->>'$.id' = '1'\"\n          });\n        });\n\n        it('item dot notation array', () => {\n          expectsql(sql.whereItemQuery(Sequelize.json('profile.id.0.1'), '1'), {\n            postgres: '(\"profile\"#>>\\'{id,0,1}\\') = \\'1\\'',\n            sqlite: \"json_extract(`profile`, '$.id[0][1]') = '1'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id[0][1]')) = '1'\",\n            mysql: \"`profile`->>'$.id[0][1]' = '1'\"\n          });\n        });\n\n        it('column named \"json\"', () => {\n          expectsql(sql.whereItemQuery(Sequelize.json('json'), '{}'), {\n            postgres: '(\"json\"#>>\\'{}\\') = \\'{}\\'',\n            sqlite: \"json_extract(`json`, '$') = '{}'\",\n            mariadb: \"json_unquote(json_extract(`json`,'$.')) = '{}'\",\n            mysql: \"`json`->>'$.' = '{}'\"\n          });\n        });\n      });\n\n      describe('raw json query', () => {\n        if (current.dialect.name === 'postgres') {\n          it('#>> operator', () => {\n            expectsql(sql.whereItemQuery(Sequelize.json('(\"data\"#>>\\'{id}\\')'), 'id'), {\n              postgres: '(\"data\"#>>\\'{id}\\') = \\'id\\''\n            });\n          });\n        }\n\n        it('json function', () => {\n          expectsql(sql.handleSequelizeMethod(Sequelize.json('json(\\'{\"profile\":{\"name\":\"david\"}}\\')')), {\n            default: 'json(\\'{\"profile\":{\"name\":\"david\"}}\\')'\n          });\n        });\n\n        it('nested json functions', () => {\n          expectsql(sql.handleSequelizeMethod(Sequelize.json('json_extract(json_object(\\'{\"profile\":null}\\'), \"profile\")')), {\n            default: 'json_extract(json_object(\\'{\"profile\":null}\\'), \"profile\")'\n          });\n        });\n\n        it('escaped string argument', () => {\n          expectsql(sql.handleSequelizeMethod(Sequelize.json('json(\\'{\"quote\":{\"single\":\"\\'\\'\",\"double\":\"\"\"\"},\"parenthesis\":\"())(\"}\\')')), {\n            default: 'json(\\'{\"quote\":{\"single\":\"\\'\\'\",\"double\":\"\"\"\"},\"parenthesis\":\"())(\"}\\')'\n          });\n        });\n\n        it('unbalnced statement', () => {\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json())'))).to.throw();\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json_extract(json()'))).to.throw();\n        });\n\n        it('separator injection', () => {\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json(; DELETE YOLO INJECTIONS; -- )'))).to.throw();\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json(); DELETE YOLO INJECTIONS; -- '))).to.throw();\n        });\n      });\n    });\n  });\n}\n", "'use strict';\n\nconst Support = require('../support'),\n  DataTypes = require('../../../lib/data-types'),\n  QueryTypes = require('../../../lib/query-types'),\n  util = require('util'),\n  _ = require('lodash'),\n  expectsql = Support.expectsql,\n  current = Support.sequelize,\n  sql = current.dialect.QueryGenerator,\n  Op = Support.Sequelize.Op;\n\n// Notice: [] will be replaced by dialect specific tick/quote character when there is not dialect specific expectation but only a default expectation\n\ndescribe(Support.getTestDialectTeaser('SQL'), () => {\n  describe('whereQuery', () => {\n    const testsql = function(params, options, expectation) {\n      if (expectation === undefined) {\n        expectation = options;\n        options = undefined;\n      }\n\n      it(util.inspect(params, { depth: 10 }) + (options && `, ${util.inspect(options)}` || ''), () => {\n        const sqlOrError = _.attempt(sql.whereQuery.bind(sql), params, options);\n        return expectsql(sqlOrError, expectation);\n      });\n    };\n\n    testsql({}, {\n      default: ''\n    });\n    testsql([], {\n      default: ''\n    });\n    testsql({ id: undefined }, {\n      default: new Error('WHERE parameter \"id\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1 }, {\n      default: 'WHERE [id] = 1'\n    });\n    testsql({ id: 1, user: undefined }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1, user: undefined }, { type: QueryTypes.SELECT }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1, user: undefined }, { type: QueryTypes.BULKDELETE }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1, user: undefined }, { type: QueryTypes.BULKUPDATE }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1 }, { prefix: 'User' }, {\n      default: 'WHERE [User].[id] = 1'\n    });\n\n    it(\"{ id: 1 }, { prefix: current.literal(sql.quoteTable.call(current.dialect.QueryGenerator, {schema: 'yolo', tableName: 'User'})) }\", () => {\n      expectsql(sql.whereQuery({ id: 1 }, { prefix: current.literal(sql.quoteTable.call(current.dialect.QueryGenerator, { schema: 'yolo', tableName: 'User' })) }), {\n        default: 'WHERE [yolo.User].[id] = 1',\n        postgres: 'WHERE \"yolo\".\"User\".\"id\" = 1',\n        mariadb: 'WHERE `yolo`.`User`.`id` = 1',\n        mssql: 'WHERE [yolo].[User].[id] = 1'\n      });\n    });\n\n    testsql({\n      name: 'a project',\n      [Op.or]: [\n        { id: [1, 2, 3] },\n        { id: { [Op.gt]: 10 } }\n      ]\n    }, {\n      default: \"WHERE ([id] IN (1, 2, 3) OR [id] > 10) AND [name] = 'a project'\",\n      mssql: \"WHERE ([id] IN (1, 2, 3) OR [id] > 10) AND [name] = N'a project'\"\n    });\n\n    testsql({\n      name: 'a project',\n      id: {\n        [Op.or]: [\n          [1, 2, 3],\n          { [Op.gt]: 10 }\n        ]\n      }\n    }, {\n      default: \"WHERE [name] = 'a project' AND ([id] IN (1, 2, 3) OR [id] > 10)\",\n      mssql: \"WHERE [name] = N'a project' AND ([id] IN (1, 2, 3) OR [id] > 10)\"\n    });\n\n    testsql({\n      name: 'here is a null char: \\0'\n    }, {\n      default: \"WHERE [name] = 'here is a null char: \\\\0'\",\n      mssql: \"WHERE [name] = N'here is a null char: \\0'\",\n      sqlite: \"WHERE `name` = 'here is a null char: \\0'\"\n    });\n  });\n\n  describe('whereItemQuery', () => {\n    const testsql = function(key, value, options, expectation) {\n      if (expectation === undefined) {\n        expectation = options;\n        options = undefined;\n      }\n\n      it(`${String(key)}: ${util.inspect(value, { depth: 10 })}${options && `, ${util.inspect(options)}` || ''}`, () => {\n        return expectsql(sql.whereItemQuery(key, value, options), expectation);\n      });\n    };\n\n    testsql(undefined, 'lol=1', {\n      default: 'lol=1'\n    });\n\n    testsql('deleted', null, {\n      default: '`deleted` IS NULL',\n      postgres: '\"deleted\" IS NULL',\n      mssql: '[deleted] IS NULL'\n    });\n\n    describe('Op.in', () => {\n      testsql('equipment', {\n        [Op.in]: [1, 3]\n      }, {\n        default: '[equipment] IN (1, 3)'\n      });\n\n      testsql('equipment', {\n        [Op.in]: []\n      }, {\n        default: '[equipment] IN (NULL)'\n      });\n\n      testsql('muscles', {\n        [Op.in]: [2, 4]\n      }, {\n        default: '[muscles] IN (2, 4)'\n      });\n\n      testsql('equipment', {\n        [Op.in]: current.literal(\n          '(select order_id from product_orders where product_id = 3)'\n        )\n      }, {\n        default: '[equipment] IN (select order_id from product_orders where product_id = 3)'\n      });\n    });\n\n    describe('Buffer', () => {\n      testsql('field', Buffer.from('Sequelize'), {\n        postgres: '\"field\" = E\\'\\\\\\\\x53657175656c697a65\\'',\n        sqlite: \"`field` = X'53657175656c697a65'\",\n        mariadb: \"`field` = X'53657175656c697a65'\",\n        mysql: \"`field` = X'53657175656c697a65'\",\n        mssql: '[field] = 0x53657175656c697a65'\n      });\n    });\n\n    describe('Op.not', () => {\n      testsql('deleted', {\n        [Op.not]: true\n      }, {\n        default: '[deleted] IS NOT true',\n        mssql: '[deleted] IS NOT 1',\n        sqlite: '`deleted` IS NOT 1'\n      });\n\n      testsql('deleted', {\n        [Op.not]: null\n      }, {\n        default: '[deleted] IS NOT NULL'\n      });\n\n      testsql('muscles', {\n        [Op.not]: 3\n      }, {\n        default: '[muscles] != 3'\n      });\n    });\n\n    describe('Op.notIn', () => {\n      testsql('equipment', {\n        [Op.notIn]: []\n      }, {\n        default: ''\n      });\n\n      testsql('equipment', {\n        [Op.notIn]: [4, 19]\n      }, {\n        default: '[equipment] NOT IN (4, 19)'\n      });\n\n      testsql('equipment', {\n        [Op.notIn]: current.literal(\n          '(select order_id from product_orders where product_id = 3)'\n        )\n      }, {\n        default: '[equipment] NOT IN (select order_id from product_orders where product_id = 3)'\n      });\n    });\n\n    describe('Op.ne', () => {\n      testsql('email', {\n        [Op.ne]: 'jack.bauer@gmail.com'\n      }, {\n        default: \"[email] != 'jack.bauer@gmail.com'\",\n        mssql: \"[email] != N'jack.bauer@gmail.com'\"\n      });\n    });\n\n    describe('Op.and/Op.or/Op.not', () => {\n      describe('Op.or', () => {\n        testsql('email', {\n          [Op.or]: ['maker@mhansen.io', 'janzeh@gmail.com']\n        }, {\n          default: '([email] = \\'maker@mhansen.io\\' OR [email] = \\'janzeh@gmail.com\\')',\n          mssql: '([email] = N\\'maker@mhansen.io\\' OR [email] = N\\'janzeh@gmail.com\\')'\n        });\n\n        testsql('rank', {\n          [Op.or]: {\n            [Op.lt]: 100,\n            [Op.eq]: null\n          }\n        }, {\n          default: '([rank] < 100 OR [rank] IS NULL)'\n        });\n\n        testsql(Op.or, [\n          { email: 'maker@mhansen.io' },\n          { email: 'janzeh@gmail.com' }\n        ], {\n          default: '([email] = \\'maker@mhansen.io\\' OR [email] = \\'janzeh@gmail.com\\')',\n          mssql: '([email] = N\\'maker@mhansen.io\\' OR [email] = N\\'janzeh@gmail.com\\')'\n        });\n\n        testsql(Op.or, {\n          email: 'maker@mhansen.io',\n          name: 'Mick Hansen'\n        }, {\n          default: '([email] = \\'maker@mhansen.io\\' OR [name] = \\'Mick Hansen\\')',\n          mssql: '([email] = N\\'maker@mhansen.io\\' OR [name] = N\\'Mick Hansen\\')'\n        });\n\n        testsql(Op.or, {\n          equipment: [1, 3],\n          muscles: {\n            [Op.in]: [2, 4]\n          }\n        }, {\n          default: '([equipment] IN (1, 3) OR [muscles] IN (2, 4))'\n        });\n\n        testsql(Op.or, [\n          {\n            roleName: 'NEW'\n          }, {\n            roleName: 'CLIENT',\n            type: 'CLIENT'\n          }\n        ], {\n          default: \"([roleName] = 'NEW' OR ([roleName] = 'CLIENT' AND [type] = 'CLIENT'))\",\n          mssql: \"([roleName] = N'NEW' OR ([roleName] = N'CLIENT' AND [type] = N'CLIENT'))\"\n        });\n\n        it('sequelize.or({group_id: 1}, {user_id: 2})', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.or({ group_id: 1 }, { user_id: 2 })), {\n            default: '([group_id] = 1 OR [user_id] = 2)'\n          });\n        });\n\n        it(\"sequelize.or({group_id: 1}, {user_id: 2, role: 'admin'})\", function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.or({ group_id: 1 }, { user_id: 2, role: 'admin' })), {\n            default: \"([group_id] = 1 OR ([user_id] = 2 AND [role] = 'admin'))\",\n            mssql: \"([group_id] = 1 OR ([user_id] = 2 AND [role] = N'admin'))\"\n          });\n        });\n\n        testsql(Op.or, [], {\n          default: '0 = 1'\n        });\n\n        testsql(Op.or, {}, {\n          default: '0 = 1'\n        });\n\n        it('sequelize.or()', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.or()), {\n            default: '0 = 1'\n          });\n        });\n      });\n\n      describe('Op.and', () => {\n        testsql(Op.and, {\n          [Op.or]: {\n            group_id: 1,\n            user_id: 2\n          },\n          shared: 1\n        }, {\n          default: '(([group_id] = 1 OR [user_id] = 2) AND [shared] = 1)'\n        });\n\n        testsql(Op.and, [\n          {\n            name: {\n              [Op.like]: '%hello'\n            }\n          },\n          {\n            name: {\n              [Op.like]: 'hello%'\n            }\n          }\n        ], {\n          default: \"([name] LIKE '%hello' AND [name] LIKE 'hello%')\",\n          mssql: \"([name] LIKE N'%hello' AND [name] LIKE N'hello%')\"\n        });\n\n        testsql('rank', {\n          [Op.and]: {\n            [Op.ne]: 15,\n            [Op.between]: [10, 20]\n          }\n        }, {\n          default: '([rank] != 15 AND [rank] BETWEEN 10 AND 20)'\n        });\n\n        testsql('name', {\n          [Op.and]: [\n            { [Op.like]: '%someValue1%' },\n            { [Op.like]: '%someValue2%' }\n          ]\n        }, {\n          default: \"([name] LIKE '%someValue1%' AND [name] LIKE '%someValue2%')\",\n          mssql: \"([name] LIKE N'%someValue1%' AND [name] LIKE N'%someValue2%')\"\n        });\n\n        it('sequelize.and({shared: 1, sequelize.or({group_id: 1}, {user_id: 2}))', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.and({ shared: 1 }, this.sequelize.or({ group_id: 1 }, { user_id: 2 }))), {\n            default: '([shared] = 1 AND ([group_id] = 1 OR [user_id] = 2))'\n          });\n        });\n      });\n\n      describe('Op.not', () => {\n        testsql(Op.not, {\n          [Op.or]: {\n            group_id: 1,\n            user_id: 2\n          },\n          shared: 1\n        }, {\n          default: 'NOT (([group_id] = 1 OR [user_id] = 2) AND [shared] = 1)'\n        });\n\n        testsql(Op.not, [], {\n          default: '0 = 1'\n        });\n\n        testsql(Op.not, {}, {\n          default: '0 = 1'\n        });\n      });\n    });\n\n    describe('Op.col', () => {\n      testsql('userId', {\n        [Op.col]: 'user.id'\n      }, {\n        default: '[userId] = [user].[id]'\n      });\n\n      testsql('userId', {\n        [Op.eq]: {\n          [Op.col]: 'user.id'\n        }\n      }, {\n        default: '[userId] = [user].[id]'\n      });\n\n      testsql('userId', {\n        [Op.gt]: {\n          [Op.col]: 'user.id'\n        }\n      }, {\n        default: '[userId] > [user].[id]'\n      });\n\n      testsql(Op.or, [\n        { 'ownerId': { [Op.col]: 'user.id' } },\n        { 'ownerId': { [Op.col]: 'organization.id' } }\n      ], {\n        default: '([ownerId] = [user].[id] OR [ownerId] = [organization].[id])'\n      });\n\n      testsql('$organization.id$', {\n        [Op.col]: 'user.organizationId'\n      }, {\n        default: '[organization].[id] = [user].[organizationId]'\n      });\n\n      testsql('$offer.organization.id$', {\n        [Op.col]: 'offer.user.organizationId'\n      }, {\n        default: '[offer->organization].[id] = [offer->user].[organizationId]'\n      });\n    });\n\n    describe('Op.gt', () => {\n      testsql('rank', {\n        [Op.gt]: 2\n      }, {\n        default: '[rank] > 2'\n      });\n\n      testsql('created_at', {\n        [Op.lt]: {\n          [Op.col]: 'updated_at'\n        }\n      }, {\n        default: '[created_at] < [updated_at]'\n      });\n    });\n\n    describe('Op.like', () => {\n      testsql('username', {\n        [Op.like]: '%swagger'\n      }, {\n        default: \"[username] LIKE '%swagger'\",\n        mssql: \"[username] LIKE N'%swagger'\"\n      });\n    });\n\n    describe('Op.startsWith', () => {\n      testsql('username', {\n        [Op.startsWith]: 'swagger'\n      }, {\n        default: \"[username] LIKE 'swagger%'\",\n        mssql: \"[username] LIKE N'swagger%'\"\n      });\n    });\n\n    describe('Op.endsWith', () => {\n      testsql('username', {\n        [Op.endsWith]: 'swagger'\n      }, {\n        default: \"[username] LIKE '%swagger'\",\n        mssql: \"[username] LIKE N'%swagger'\"\n      });\n    });\n\n    describe('Op.substring', () => {\n      testsql('username', {\n        [Op.substring]: 'swagger'\n      }, {\n        default: \"[username] LIKE '%swagger%'\",\n        mssql: \"[username] LIKE N'%swagger%'\"\n      });\n    });\n\n    describe('Op.between', () => {\n      testsql('date', {\n        [Op.between]: ['2013-01-01', '2013-01-11']\n      }, {\n        default: \"[date] BETWEEN '2013-01-01' AND '2013-01-11'\",\n        mssql: \"[date] BETWEEN N'2013-01-01' AND N'2013-01-11'\"\n      });\n\n      testsql('date', {\n        [Op.between]: [new Date('2013-01-01'), new Date('2013-01-11')]\n      }, {\n        default: \"[date] BETWEEN '2013-01-01 00:00:00.000 +00:00' AND '2013-01-11 00:00:00.000 +00:00'\",\n        mysql: \"`date` BETWEEN '2013-01-01 00:00:00' AND '2013-01-11 00:00:00'\",\n        mariadb: \"`date` BETWEEN '2013-01-01 00:00:00.000' AND '2013-01-11 00:00:00.000'\"\n      });\n\n      testsql('date', {\n        [Op.between]: [1356998400000, 1357862400000]\n      }, {\n        model: {\n          rawAttributes: {\n            date: {\n              type: new DataTypes.DATE()\n            }\n          }\n        }\n      },\n      {\n        default: \"[date] BETWEEN '2013-01-01 00:00:00.000 +00:00' AND '2013-01-11 00:00:00.000 +00:00'\",\n        mssql: \"[date] BETWEEN N'2013-01-01 00:00:00.000 +00:00' AND N'2013-01-11 00:00:00.000 +00:00'\"\n      });\n\n      testsql('date', {\n        [Op.between]: ['2012-12-10', '2013-01-02'],\n        [Op.notBetween]: ['2013-01-04', '2013-01-20']\n      }, {\n        default: \"([date] BETWEEN '2012-12-10' AND '2013-01-02' AND [date] NOT BETWEEN '2013-01-04' AND '2013-01-20')\",\n        mssql: \"([date] BETWEEN N'2012-12-10' AND N'2013-01-02' AND [date] NOT BETWEEN N'2013-01-04' AND N'2013-01-20')\"\n      });\n    });\n\n    describe('Op.notBetween', () => {\n      testsql('date', {\n        [Op.notBetween]: ['2013-01-01', '2013-01-11']\n      }, {\n        default: \"[date] NOT BETWEEN '2013-01-01' AND '2013-01-11'\",\n        mssql: \"[date] NOT BETWEEN N'2013-01-01' AND N'2013-01-11'\"\n      });\n    });\n\n    if (current.dialect.supports.ARRAY) {\n      describe('ARRAY', () => {\n        describe('Op.contains', () => {\n          testsql('muscles', {\n            [Op.contains]: [2, 3]\n          }, {\n            postgres: '\"muscles\" @> ARRAY[2,3]'\n          });\n\n          testsql('muscles', {\n            [Op.contained]: [6, 8]\n          }, {\n            postgres: '\"muscles\" <@ ARRAY[6,8]'\n          });\n\n          testsql('muscles', {\n            [Op.contains]: [2, 5]\n          }, {\n            field: {\n              type: DataTypes.ARRAY(DataTypes.INTEGER)\n            }\n          }, {\n            postgres: '\"muscles\" @> ARRAY[2,5]::INTEGER[]'\n          });\n        });\n\n        describe('Op.overlap', () => {\n          testsql('muscles', {\n            [Op.overlap]: [3, 11]\n          }, {\n            postgres: '\"muscles\" && ARRAY[3,11]'\n          });\n        });\n\n        describe('Op.any', () => {\n          testsql('userId', {\n            [Op.any]: [4, 5, 6]\n          }, {\n            postgres: '\"userId\" = ANY (ARRAY[4,5,6])'\n          });\n\n          testsql('userId', {\n            [Op.any]: [2, 5]\n          }, {\n            field: {\n              type: DataTypes.ARRAY(DataTypes.INTEGER)\n            }\n          }, {\n            postgres: '\"userId\" = ANY (ARRAY[2,5]::INTEGER[])'\n          });\n\n          describe('Op.values', () => {\n            testsql('userId', {\n              [Op.any]: {\n                [Op.values]: [4, 5, 6]\n              }\n            }, {\n              postgres: '\"userId\" = ANY (VALUES (4), (5), (6))'\n            });\n\n            testsql('userId', {\n              [Op.any]: {\n                [Op.values]: [2, 5]\n              }\n            }, {\n              field: {\n                type: DataTypes.ARRAY(DataTypes.INTEGER)\n              }\n            }, {\n              postgres: '\"userId\" = ANY (VALUES (2), (5))'\n            });\n          });\n        });\n\n        describe('Op.all', () => {\n          testsql('userId', {\n            [Op.all]: [4, 5, 6]\n          }, {\n            postgres: '\"userId\" = ALL (ARRAY[4,5,6])'\n          });\n\n          testsql('userId', {\n            [Op.all]: [2, 5]\n          }, {\n            field: {\n              type: DataTypes.ARRAY(DataTypes.INTEGER)\n            }\n          }, {\n            postgres: '\"userId\" = ALL (ARRAY[2,5]::INTEGER[])'\n          });\n\n          describe('Op.values', () => {\n            testsql('userId', {\n              [Op.all]: {\n                [Op.values]: [4, 5, 6]\n              }\n            }, {\n              postgres: '\"userId\" = ALL (VALUES (4), (5), (6))'\n            });\n\n            testsql('userId', {\n              [Op.all]: {\n                [Op.values]: [2, 5]\n              }\n            }, {\n              field: {\n                type: DataTypes.ARRAY(DataTypes.INTEGER)\n              }\n            }, {\n              postgres: '\"userId\" = ALL (VALUES (2), (5))'\n            });\n          });\n        });\n\n        describe('Op.like', () => {\n          testsql('userId', {\n            [Op.like]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" LIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.iLike]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" ILIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notLike]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT LIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notILike]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT ILIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.like]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" LIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.iLike]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" ILIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notLike]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT LIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notILike]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT ILIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n        });\n      });\n    }\n\n    if (current.dialect.supports.RANGE) {\n      describe('RANGE', () => {\n\n        testsql('range', {\n          [Op.contains]: new Date(Date.UTC(2000, 1, 1))\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"range\\\" @> '2000-02-01 00:00:00.000 +00:00'::timestamptz\"\n        });\n\n        testsql('range', {\n          [Op.contains]: [new Date(Date.UTC(2000, 1, 1)), new Date(Date.UTC(2000, 2, 1))]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"range\\\" @> '[\\\"2000-02-01 00:00:00.000 +00:00\\\",\\\"2000-03-01 00:00:00.000 +00:00\\\")'\"\n        });\n\n        testsql('range', {\n          [Op.contained]: [new Date(Date.UTC(2000, 1, 1)), new Date(Date.UTC(2000, 2, 1))]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"range\\\" <@ '[\\\"2000-02-01 00:00:00.000 +00:00\\\",\\\"2000-03-01 00:00:00.000 +00:00\\\")'\"\n        });\n\n        testsql('unboundedRange', {\n          [Op.contains]: [new Date(Date.UTC(2000, 1, 1)), null]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"unboundedRange\\\" @> '[\\\"2000-02-01 00:00:00.000 +00:00\\\",)'\"\n        });\n\n        testsql('unboundedRange', {\n          [Op.contains]: [-Infinity, Infinity]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"unboundedRange\\\" @> '[-infinity,infinity)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.overlap]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" && '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.adjacent]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" -|- '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.strictLeft]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" << '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.strictRight]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" >> '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.noExtendRight]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" &< '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.noExtendLeft]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" &> '[1,4)'\"\n        });\n\n      });\n    }\n\n    if (current.dialect.supports.JSON) {\n      describe('JSON', () => {\n        it('sequelize.json(\"profile.id\"), sequelize.cast(2, \\'text\\')\")', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.json('profile.id', this.sequelize.cast('12346-78912', 'text'))), {\n            postgres: \"(\\\"profile\\\"#>>'{id}') = CAST('12346-78912' AS TEXT)\",\n            sqlite: \"json_extract(`profile`, '$.id') = CAST('12346-78912' AS TEXT)\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = CAST('12346-78912' AS CHAR)\",\n            mysql: \"`profile`->>'$.id' = CAST('12346-78912' AS CHAR)\"\n          });\n        });\n\n        it('sequelize.json({profile: {id: \"12346-78912\", name: \"test\"}})', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.json({ profile: { id: '12346-78912', name: 'test' } })), {\n            postgres: \"(\\\"profile\\\"#>>'{id}') = '12346-78912' AND (\\\"profile\\\"#>>'{name}') = 'test'\",\n            sqlite: \"json_extract(`profile`, '$.id') = '12346-78912' AND json_extract(`profile`, '$.name') = 'test'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = '12346-78912' and json_unquote(json_extract(`profile`,'$.name')) = 'test'\",\n            mysql: \"`profile`->>'$.id' = '12346-78912' and `profile`->>'$.name' = 'test'\"\n          });\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: 'value'\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          },\n          prefix: 'User'\n        }, {\n          mariadb: \"json_unquote(json_extract(`User`.`data`,'$.nested.attribute')) = 'value'\",\n          mysql: \"(`User`.`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') = 'value'\",\n          postgres: \"(\\\"User\\\".\\\"data\\\"#>>'{nested,attribute}') = 'value'\",\n          sqlite: \"json_extract(`User`.`data`, '$.nested.attribute') = 'value'\"\n        });\n\n        testsql('data', {\n          nested: {\n            [Op.in]: [1, 2]\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested')) AS DECIMAL) IN (1, 2)\",\n          mysql: \"CAST((`data`->>'$.\\\\\\\"nested\\\\\\\"') AS DECIMAL) IN (1, 2)\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested}') AS DOUBLE PRECISION) IN (1, 2)\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested') AS DOUBLE PRECISION) IN (1, 2)\"\n        });\n\n        testsql('data', {\n          nested: {\n            [Op.between]: [1, 2]\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested')) AS DECIMAL) BETWEEN 1 AND 2\",\n          mysql: \"CAST((`data`->>'$.\\\\\\\"nested\\\\\\\"') AS DECIMAL) BETWEEN 1 AND 2\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested}') AS DOUBLE PRECISION) BETWEEN 1 AND 2\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested') AS DOUBLE PRECISION) BETWEEN 1 AND 2\"\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: 'value',\n            prop: {\n              [Op.ne]: 'None'\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          },\n          prefix: current.literal(sql.quoteTable.call(current.dialect.QueryGenerator, { tableName: 'User' }))\n        }, {\n          mariadb: \"(json_unquote(json_extract(`User`.`data`,'$.nested.attribute')) = 'value' AND json_unquote(json_extract(`User`.`data`,'$.nested.prop')) != 'None')\",\n          mysql: \"((`User`.`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') = 'value' AND (`User`.`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"prop\\\\\\\"') != 'None')\",\n          postgres: \"((\\\"User\\\".\\\"data\\\"#>>'{nested,attribute}') = 'value' AND (\\\"User\\\".\\\"data\\\"#>>'{nested,prop}') != 'None')\",\n          sqlite: \"(json_extract(`User`.`data`, '$.nested.attribute') = 'value' AND json_extract(`User`.`data`, '$.nested.prop') != 'None')\"\n        });\n\n        testsql('data', {\n          name: {\n            last: 'Simpson'\n          },\n          employment: {\n            [Op.ne]: 'None'\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          },\n          prefix: 'User'\n        }, {\n          mariadb: \"(json_unquote(json_extract(`User`.`data`,'$.name.last')) = 'Simpson' AND json_unquote(json_extract(`User`.`data`,'$.employment')) != 'None')\",\n          mysql: \"((`User`.`data`->>'$.\\\\\\\"name\\\\\\\".\\\\\\\"last\\\\\\\"') = 'Simpson' AND (`User`.`data`->>'$.\\\\\\\"employment\\\\\\\"') != 'None')\",\n          postgres: \"((\\\"User\\\".\\\"data\\\"#>>'{name,last}') = 'Simpson' AND (\\\"User\\\".\\\"data\\\"#>>'{employment}') != 'None')\",\n          sqlite: \"(json_extract(`User`.`data`, '$.name.last') = 'Simpson' AND json_extract(`User`.`data`, '$.employment') != 'None')\"\n        });\n\n        testsql('data', {\n          price: 5,\n          name: 'Product'\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"(CAST(json_unquote(json_extract(`data`,'$.price')) AS DECIMAL) = 5 AND json_unquote(json_extract(`data`,'$.name')) = 'Product')\",\n          mysql: \"(CAST((`data`->>'$.\\\\\\\"price\\\\\\\"') AS DECIMAL) = 5 AND (`data`->>'$.\\\\\\\"name\\\\\\\"') = 'Product')\",\n          postgres: \"(CAST((\\\"data\\\"#>>'{price}') AS DOUBLE PRECISION) = 5 AND (\\\"data\\\"#>>'{name}') = 'Product')\",\n          sqlite: \"(CAST(json_extract(`data`, '$.price') AS DOUBLE PRECISION) = 5 AND json_extract(`data`, '$.name') = 'Product')\"\n        });\n\n        testsql('data.nested.attribute', 'value', {\n          model: {\n            rawAttributes: {\n              data: {\n                type: new DataTypes.JSONB()\n              }\n            }\n          }\n        }, {\n          mariadb: \"json_unquote(json_extract(`data`,'$.nested.attribute')) = 'value'\",\n          mysql: \"(`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') = 'value'\",\n          postgres: \"(\\\"data\\\"#>>'{nested,attribute}') = 'value'\",\n          sqlite: \"json_extract(`data`, '$.nested.attribute') = 'value'\"\n        });\n\n        testsql('data.nested.attribute', 4, {\n          model: {\n            rawAttributes: {\n              data: {\n                type: new DataTypes.JSON()\n              }\n            }\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) = 4\",\n          mysql: \"CAST((`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') AS DECIMAL) = 4\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS DOUBLE PRECISION) = 4\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested.attribute') AS DOUBLE PRECISION) = 4\"\n        });\n\n        testsql('data.nested.attribute', {\n          [Op.in]: [3, 7]\n        }, {\n          model: {\n            rawAttributes: {\n              data: {\n                type: new DataTypes.JSONB()\n              }\n            }\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) IN (3, 7)\",\n          mysql: \"CAST((`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') AS DECIMAL) IN (3, 7)\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS DOUBLE PRECISION) IN (3, 7)\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested.attribute') AS DOUBLE PRECISION) IN (3, 7)\"\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: {\n              [Op.gt]: 2\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) > 2\",\n          mysql: \"CAST((`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') AS DECIMAL) > 2\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS DOUBLE PRECISION) > 2\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested.attribute') AS DOUBLE PRECISION) > 2\"\n        });\n\n        testsql('data', {\n          nested: {\n            'attribute::integer': {\n              [Op.gt]: 2\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) > 2\",\n          mysql: \"CAST((`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') AS DECIMAL) > 2\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS INTEGER) > 2\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested.attribute') AS INTEGER) > 2\"\n        });\n\n        const dt = new Date();\n        testsql('data', {\n          nested: {\n            attribute: {\n              [Op.gt]: dt\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: `CAST(json_unquote(json_extract(\\`data\\`,'$.nested.attribute')) AS DATETIME) > ${sql.escape(dt)}`,\n          mysql: `CAST((\\`data\\`->>'$.\\\\\"nested\\\\\".\\\\\"attribute\\\\\"') AS DATETIME) > ${sql.escape(dt)}`,\n          postgres: `CAST((\"data\"#>>'{nested,attribute}') AS TIMESTAMPTZ) > ${sql.escape(dt)}`,\n          sqlite: `json_extract(\\`data\\`, '$.nested.attribute') > ${sql.escape(dt.toISOString())}`\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: true\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"json_unquote(json_extract(`data`,'$.nested.attribute')) = 'true'\",\n          mysql: \"(`data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') = 'true'\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS BOOLEAN) = true\",\n          sqlite: \"CAST(json_extract(`data`, '$.nested.attribute') AS BOOLEAN) = 1\"\n        });\n\n        testsql('metaData.nested.attribute', 'value', {\n          model: {\n            rawAttributes: {\n              metaData: {\n                field: 'meta_data',\n                fieldName: 'metaData',\n                type: new DataTypes.JSONB()\n              }\n            }\n          }\n        }, {\n          mariadb: \"json_unquote(json_extract(`meta_data`,'$.nested.attribute')) = 'value'\",\n          mysql: \"(`meta_data`->>'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"') = 'value'\",\n          postgres: \"(\\\"meta_data\\\"#>>'{nested,attribute}') = 'value'\",\n          sqlite: \"json_extract(`meta_data`, '$.nested.attribute') = 'value'\"\n        });\n      });\n    }\n\n    if (current.dialect.supports.JSONB) {\n      describe('JSONB', () => {\n        testsql('data', {\n          [Op.contains]: {\n            company: 'Magnafone'\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          default: '[data] @> \\'{\"company\":\"Magnafone\"}\\''\n        });\n      });\n    }\n\n    if (current.dialect.supports.REGEXP) {\n      describe('Op.regexp', () => {\n        testsql('username', {\n          [Op.regexp]: '^sw.*r$'\n        }, {\n          mariadb: \"`username` REGEXP '^sw.*r$'\",\n          mysql: \"`username` REGEXP '^sw.*r$'\",\n          postgres: '\"username\" ~ \\'^sw.*r$\\''\n        });\n      });\n\n      describe('Op.regexp', () => {\n        testsql('newline', {\n          [Op.regexp]: '^new\\nline$'\n        }, {\n          mariadb: \"`newline` REGEXP '^new\\\\nline$'\",\n          mysql: \"`newline` REGEXP '^new\\\\nline$'\",\n          postgres: '\"newline\" ~ \\'^new\\nline$\\''\n        });\n      });\n\n      describe('Op.notRegexp', () => {\n        testsql('username', {\n          [Op.notRegexp]: '^sw.*r$'\n        }, {\n          mariadb: \"`username` NOT REGEXP '^sw.*r$'\",\n          mysql: \"`username` NOT REGEXP '^sw.*r$'\",\n          postgres: '\"username\" !~ \\'^sw.*r$\\''\n        });\n      });\n\n      describe('Op.notRegexp', () => {\n        testsql('newline', {\n          [Op.notRegexp]: '^new\\nline$'\n        }, {\n          mariadb: \"`newline` NOT REGEXP '^new\\\\nline$'\",\n          mysql: \"`newline` NOT REGEXP '^new\\\\nline$'\",\n          postgres: '\"newline\" !~ \\'^new\\nline$\\''\n        });\n      });\n\n      if (current.dialect.name === 'postgres') {\n        describe('Op.iRegexp', () => {\n          testsql('username', {\n            [Op.iRegexp]: '^sw.*r$'\n          }, {\n            postgres: '\"username\" ~* \\'^sw.*r$\\''\n          });\n        });\n\n        describe('Op.iRegexp', () => {\n          testsql('newline', {\n            [Op.iRegexp]: '^new\\nline$'\n          }, {\n            postgres: '\"newline\" ~* \\'^new\\nline$\\''\n          });\n        });\n\n        describe('Op.notIRegexp', () => {\n          testsql('username', {\n            [Op.notIRegexp]: '^sw.*r$'\n          }, {\n            postgres: '\"username\" !~* \\'^sw.*r$\\''\n          });\n        });\n\n        describe('Op.notIRegexp', () => {\n          testsql('newline', {\n            [Op.notIRegexp]: '^new\\nline$'\n          }, {\n            postgres: '\"newline\" !~* \\'^new\\nline$\\''\n          });\n        });\n      }\n    }\n\n    describe('fn', () => {\n      it('{name: this.sequelize.fn(\\'LOWER\\', \\'DERP\\')}', function() {\n        expectsql(sql.whereQuery({ name: this.sequelize.fn('LOWER', 'DERP') }), {\n          default: \"WHERE [name] = LOWER('DERP')\",\n          mssql: \"WHERE [name] = LOWER(N'DERP')\"\n        });\n      });\n    });\n  });\n\n  describe('getWhereConditions', () => {\n    const testsql = function(value, expectation) {\n      const User = current.define('user', {});\n\n      it(util.inspect(value, { depth: 10 }), () => {\n        return expectsql(sql.getWhereConditions(value, User.tableName, User), expectation);\n      });\n    };\n\n    testsql(current.where(current.fn('lower', current.col('name')), null), {\n      default: 'lower([name]) IS NULL'\n    });\n\n    testsql(current.where(current.fn('SUM', current.col('hours')), '>', 0), {\n      default: 'SUM([hours]) > 0'\n    });\n\n    testsql(current.where(current.fn('SUM', current.col('hours')), Op.gt, 0), {\n      default: 'SUM([hours]) > 0'\n    });\n  });\n});\n"], "fixing_code": ["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst uuidv4 = require('uuid/v4');\nconst semver = require('semver');\n\nconst Utils = require('../../utils');\nconst deprecations = require('../../utils/deprecations');\nconst SqlString = require('../../sql-string');\nconst DataTypes = require('../../data-types');\nconst Model = require('../../model');\nconst Association = require('../../associations/base');\nconst BelongsTo = require('../../associations/belongs-to');\nconst BelongsToMany = require('../../associations/belongs-to-many');\nconst HasMany = require('../../associations/has-many');\nconst Op = require('../../operators');\nconst sequelizeError = require('../../errors');\nconst IndexHints = require('../../index-hints');\n\nconst QuoteHelper = require('./query-generator/helpers/quote');\n\n/**\n * Abstract Query Generator\n *\n * @private\n */\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');\n    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');\n\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n\n    // dialect name\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n  }\n\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  }\n\n  addSchema(param) {\n    if (!param._schema) return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || '.',\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `DESCRIBE ${table};`;\n  }\n\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n\n  /**\n   * Returns an insert into command\n   *\n   * @param {string} table\n   * @param {Object} valueHash       attribute value pairs\n   * @param {Object} modelAttributes\n   * @param {Object} [options]\n   *\n   * @private\n   */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const fields = [];\n    const values = [];\n    const bind = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n    let query;\n    let valueQuery = '';\n    let emptyQuery = '';\n    let outputFragment = '';\n    let identityWrapperRequired = false;\n    let tmpTable = '';         //tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        valueQuery += ' RETURNING *';\n        emptyQuery += ' RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in modelAttributes) {\n            const attribute = modelAttributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += `${this.quoteIdentifier(attribute.field)} ${attribute.type.toSql()}`;\n              outputColumns += `INSERTED.${this.quoteIdentifier(attribute.field)}`;\n            }\n          }\n\n          tmpTable = `declare @tmp table (${tmpColumns});`;\n          outputFragment = ` OUTPUT ${outputColumns} into @tmp`;\n          const selectFromTmp = ';select * from @tmp';\n\n          valueQuery += selectFromTmp;\n          emptyQuery += selectFromTmp;\n        }\n      }\n    }\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Not currently supported with bind parameters (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));\n          }\n        }\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable\n    };\n\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${replacements.onConflictDoNothing}${emptyQuery}`;\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Mostly for internal use, so we expect the user to know what he's doing!\n      // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n        const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;\n\n        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n        valueQuery = `${`CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter}` +\n        ' BEGIN '}${valueQuery} INTO response; EXCEPTION ${options.exception} END ${delimiter\n        } LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()`;\n      } else {\n        options.exception = 'WHEN unique_violation THEN NULL;';\n        valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF ${quotedTable} AS $body$ BEGIN RETURN QUERY ${valueQuery}; EXCEPTION ${options.exception} END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();`;\n      }\n    }\n\n    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n      valueQuery += ` ON DUPLICATE KEY ${options.onDuplicate}`;\n      emptyQuery += ` ON DUPLICATE KEY ${options.onDuplicate}`;\n    }\n\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {Object} fieldValueHashes\n   * @param {Object} options\n   * @param {Object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (\n          fieldMappedAttributes[key]\n          && fieldMappedAttributes[key].autoIncrement === true\n        ) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map(key => {\n        if (\n          this._dialect.supports.bulkDefault\n          && serials[key] === true\n        ) {\n          return fieldValueHash[key] || 'DEFAULT';\n        }\n\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });\n      });\n\n      tuples.push(`(${values.join(',')})`);\n    }\n\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;\n      } else { // mysql / maria\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';\n    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';\n    let returning = '';\n\n    if (this._dialect.supports.returnValues && Array.isArray(options.returning)) {\n      const fields = options.returning.map(field => this.quoteIdentifier(field)).join(',');\n      returning += ` RETURNING ${fields}`;\n    } else {\n      returning += this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : '';\n    }\n\n    return `INSERT${ignoreDuplicates} INTO ${this.quoteTable(tableName)} (${attributes}) VALUES ${tuples.join(',')}${onDuplicateKeyUpdate}${onConflictDoNothing}${returning};`;\n  }\n\n  /**\n   * Returns an update query\n   *\n   * @param {string} tableName\n   * @param {Object} attrValueHash\n   * @param {Object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {Object} options\n   * @param {Object} attributes\n   *\n   * @private\n   */\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = '';\n    let tmpTable = '';        // tmpTable declaration for trigger\n    let selectFromTmp = '';   // Select statement for trigger\n    let suffix = '';\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      if (this.dialect !== 'mssql') {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      }\n    }\n\n    if (this._dialect.supports.returnValues) {\n      if (this._dialect.supports.returnValues.output) {\n        // we always need this for mssql\n        outputFragment = ' OUTPUT INSERTED.*';\n\n        //To capture output rows when there is a trigger on MSSQL DB\n        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n          let tmpColumns = '';\n          let outputColumns = '';\n\n          for (const modelKey in attributes) {\n            const attribute = attributes[modelKey];\n            if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n              if (tmpColumns.length > 0) {\n                tmpColumns += ',';\n                outputColumns += ',';\n              }\n\n              tmpColumns += `${this.quoteIdentifier(attribute.field)} ${attribute.type.toSql()}`;\n              outputColumns += `INSERTED.${this.quoteIdentifier(attribute.field)}`;\n            }\n          }\n\n          tmpTable = `declare @tmp table (${tmpColumns}); `;\n          outputFragment = ` OUTPUT ${outputColumns} into @tmp`;\n          selectFromTmp = ';select * from @tmp';\n\n          suffix += selectFromTmp;\n        }\n      } else if (this._dialect.supports.returnValues && options.returning) {\n        // ensure that the return output is properly mapped to model fields.\n        options.mapToModel = true;\n        suffix += ' RETURNING *';\n      }\n    }\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n          modelAttributeMap[key].autoIncrement === true &&\n          !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an update query using arithmetic operator\n   *\n   * @param {string} operator      String with the arithmetic operator (e.g. '+' or '-')\n   * @param {string} tableName     Name of the table\n   * @param {Object} attrValueHash A hash with attribute-value-pairs\n   * @param {Object} where         A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {Object} options\n   * @param {Object} attributes\n   */\n  arithmeticQuery(operator, tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n\n    const values = [];\n    let outputFragment = '';\n    let returningFragment = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      if (this._dialect.supports.returnValues.returning) {\n        options.mapToModel = true;\n        returningFragment = 'RETURNING *';\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(`${this.quoteIdentifier(key)}=${this.quoteIdentifier(key)}${operator} ${this.escape(value)}`);\n    }\n\n    attributes = attributes || {};\n    for (const key in attributes) {\n      const value = attributes[key];\n      values.push(`${this.quoteIdentifier(key)}=${this.escape(value)}`);\n    }\n\n    return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where)} ${returningFragment}`.trim();\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\"|')/g, '');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = Utils.nameIndex(options, options.prefix);\n    }\n\n    options = Model._conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',\n      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',\n      `(${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})`,\n      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,\n      this._dialect.supports.index.where && options.where ? options.where : undefined\n    );\n\n    return _.compact(ind).join(' ');\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const fieldsSqlQuotedString = fieldsSql.join(', ');\n    const fieldsSqlString = fieldsSql.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');\n        }\n\n        if (this._dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY':\n        const references = options.references;\n        if (!references || !references.table || !references.field) {\n          throw new Error('references object with table and field must be specified');\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const referencesSnippet = `${this.quoteTable(references.table)} (${this.quoteIdentifier(references.field)})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n    return constraintSnippet;\n  }\n\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} DROP CONSTRAINT ${this.quoteIdentifiers(constraintName)}`;\n  }\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST'\n    ];\n\n    // default\n    connector = connector || '.';\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n\n          if (typeof item === 'function' && item.prototype instanceof Model) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              // get from previous association\n              item = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationForAlias(model, as);\n\n              // attempt to use the model name if the item is still null\n              if (!item) {\n                item = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            // only go down this path if we have preivous model and check only once\n            if (previousModel.associations !== undefined && previousModel.associations[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n              // convert the item attribute from its alias\n              item = previousModel.rawAttributes[item].field;\n            } else if (\n              item.includes('.')\n              && previousModel.rawAttributes !== undefined\n            ) {\n              const itemSplit = item.split('.');\n\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      }, this);\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n\n      // loop through everything past i and append to the sql\n      collection.slice(i).forEach(collectionItem => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {\n      force,\n      quoteIdentifiers: this.options.quoteIdentifiers\n    });\n  }\n\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes('.')) {\n      identifiers = identifiers.split('.');\n\n      const head = identifiers.slice(0, identifiers.length - 1).join('.');\n      const tail = identifiers[identifiers.length - 1];\n\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n\n    return this.quoteIdentifier(identifiers);\n  }\n\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param {string|Object}  param table string or object\n   * @param {string|boolean} alias alias name\n   *\n   * @returns {string}\n   */\n  quoteTable(param, alias) {\n    let table = '';\n\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (alias) {\n      table += ` AS ${this.quoteIdentifier(alias)}`;\n    }\n\n    return table;\n  }\n\n  /*\n    Escape a value (e.g. a string, number or date)\n    @private\n  */\n  escape(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.stringify) {\n          // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);\n\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n\n          if (field.type.escape === false) {\n            // The data-type already did the required escaping\n            return value;\n          }\n        }\n      }\n    }\n\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n\n  bindParam(bind) {\n    return value => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n\n  /*\n    Returns a bind parameter representation of a value (e.g. a string, number or date)\n    @private\n  */\n  format(value, field, options, bindParam) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n\n    return bindParam(value);\n  }\n\n  /*\n    Validate a value against a field specification\n    @private\n  */\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(\n            error.message,\n            'Validation error',\n            field.fieldName,\n            value,\n            null,\n            `${field.type.key} validator`\n          ));\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  isIdentifierQuoted(identifier) {\n    return QuoteHelper.isIdentifierQuoted(identifier);\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               column  The JSON column\n   * @param   {string|Array<string>} [path]  The path to extract (optional)\n   * @returns {string}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column)\n      ? column\n      : this.quoteIdentifier(column);\n\n    switch (this.dialect) {\n      case 'mysql':\n      case 'mariadb':\n      case 'sqlite':\n        /**\n         * Non digit sub paths need to be quoted as ECMAScript identifiers\n         * https://bugs.mysql.com/bug.php?id=81896\n         */\n        if (this.dialect === 'mysql') {\n          paths = paths.map(subPath => {\n            return /\\D/.test(subPath)\n              ? Utils.addTicks(subPath, '\"')\n              : subPath;\n          });\n        }\n\n        pathStr = this.escape(['$']\n          .concat(paths)\n          .join('.')\n          .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n        if (this.dialect === 'sqlite') {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n\n      case 'postgres':\n        pathStr = this.escape(`{${paths.join(',')}}`);\n        return `(${quotedColumn}#>>${pathStr})`;\n\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);\n\n    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(joinQueries.attributes.main);\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(joinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(''));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = Object.assign({}, options.where);\n        let groupedLimitOrder,\n          whereKey,\n          include,\n          groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: Object.assign({\n                [Op.placeholder]: true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where[Op.placeholder] = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = `SELECT * FROM (${this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            where,\n            include,\n            model\n          },\n          model\n        ).replace(/;$/, '')  }) AS sub`; // Every derived table must have its own alias\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value\n              };\n            }\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value\n              };\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }).join(\n            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '\n          )\n        })`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          // Walk the main query to update all selects\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith('SELECT')) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(t => this.quote(t, model)).join(', ') : this.quote(options.group, model);\n      if (subQuery) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ` FOR ${lock}`;\n      } else if (lock === 'SHARE') {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += ' SKIP LOCKED';\n      }\n    }\n\n    return `${query};`;\n  }\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else {\n          deprecations.noRawAttributes();\n        }\n        attr = [attr[0], this.quoteIdentifier(attr[1])].join(' AS ');\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"')\n          ? this.quoteAttribute(attr, options.model)\n          : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n\n      return attr;\n    });\n  }\n\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapOptionFieldNames(include, include.model);\n\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (\n            attr[0] instanceof Utils.Literal ||\n            attr[0] instanceof Utils.Cast ||\n            attr[0] instanceof Utils.Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);\n\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val; // We trust the user to rename the field correctly\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n            'This means the attribute will not be added to the returned instance'\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, '')})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        return `${prefix} AS ${this.quoteIdentifier(`${includeAs.externalAs}.${attrAs}`, true)}`;\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    //through\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes\n    };\n  }\n\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ?\n      association.identifier :\n      association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ?\n      association.identifierField :\n      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ?\n      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n      association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = `${asLeft}->${asRight}`;\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        joinOn = `${this.quoteTable(parent.as || parent.model.name)}.${this.quoteIdentifier(attrLeft)}`;\n      } else {\n        joinOn = this.quoteIdentifier(`${asLeft.replace(/->/g, '.')}.${attrLeft}`);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    return {\n      join: include.required ? 'INNER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: []\n      }\n    };\n  }\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map(attr =>\n      `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)\n      } AS ${\n        this.quoteIdentifier(`${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`)}`\n    );\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n\n    const joinType = include.required ? 'INNER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      sourceJoinOn = `${this.quoteIdentifier(`${tableSource}.${attrSource}`)} = `;\n    } else {\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(attrSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n\n    if (this._dialect.supports.joinTableDependent) {\n      // Generate a wrapped join so that the through table join can be dependent on the target join\n      joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n      if (throughWhere) {\n        joinBody += ` AND ${throughWhere}`;\n      }\n      joinBody += ')';\n      joinCondition = sourceJoinOn;\n    } else {\n      // Generate join SQL for left side of through\n      joinBody = `${this.quoteTable(throughTable, throughAs)} ON ${sourceJoinOn} ${joinType} ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)}`;\n      joinCondition = targetJoinOn;\n      if (throughWhere) {\n        joinCondition += ` AND ${throughWhere}`;\n      }\n    }\n\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n\n  /*\n   * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n   * For a given include a query is generated that contains all the way from the subQuery\n   * table to the include table plus everything that's in required transitive closure of the\n   * given include.\n   */\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n\n    while ((parent = parent.parent)) { // eslint-disable-line\n      if (parent.parent && !parent.required) {\n        return; // only generate subQueryFilter if all the parents of this include are required\n      }\n\n      if (parent.subQueryFilter) {\n        // the include is already handled as this parent has the include on its required closure\n        // skip to prevent duplicate subQueryFilter\n        return;\n      }\n\n      nestedIncludes = [Object.assign({}, child, { include: nestedIncludes, attributes: [] })];\n      child = parent;\n    }\n\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = undefined;\n\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(' = ')),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === 'BelongsTo';\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(' = ');\n\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      '(',\n      query.replace(/;$/, ''),\n      ')',\n      'IS NOT NULL'\n    ].join(' '));\n  }\n\n  /*\n   * For a given include hierarchy creates a copy of it where only the required includes\n   * are preserved.\n   */\n  _getRequiredClosure(include) {\n    const copy = Object.assign({}, include, { attributes: [], include: [] });\n\n    if (Array.isArray(include.include)) {\n      copy.include = include.include\n        .filter(i => i.required)\n        .map(inc => this._getRequiredClosure(inc));\n    }\n\n    return copy;\n  }\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)\n          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          subQueryOrder.push(this.quote(order, model, '->'));\n        }\n\n        if (subQuery) {\n          // Handle case where sub-query renames attribute we want to order by,\n          // see https://github.com/sequelize/sequelize/issues/8739\n          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);\n          if (subQueryAttribute) {\n            order[0] = new Utils.Col(subQueryAttribute[1]);\n          }\n        }\n\n        mainQueryOrder.push(this.quote(order, model, '->'));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->');\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return { mainQueryOrder, subQueryOrder };\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    if (mainTableAs) {\n      fragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {Object} options An object with selectQuery options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    /* eslint-disable */\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        return value === 'NULL' ? `${key} IS NULL` : [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if (typeof value === 'boolean') {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n\n      return value === 'NULL' ? `${key} IS NULL` : [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${smth.args.map(arg => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        }\n        if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        }\n        return this.escape(arg);\n      }).join(', ')  })`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n      }\n      if (smth.col.startsWith('*')) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return '';\n  }\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      where === null ||\n      where === undefined ||\n      Utils.getComplexSize(where) === 0\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (typeof where === 'string') {\n      throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding[0] !== ' ') binding = ` ${binding} `;\n\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach(prop => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  }\n\n  whereItemQuery(key, value, options = {}) {\n    if (value === undefined) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n\n    if (typeof key === 'string' && key.includes('.') && options.model) {\n      const keyParts = key.split('.');\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field.field || keyParts[0], tmp, Object.assign({ field }, options));\n      }\n    }\n\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n\n    if (value === null) {\n      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (!value) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to Op.and if possible, else treat as literal/replacements\n    if (key === undefined && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n\n\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    // If multiple keys we combine the different logic conditions\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n\n    if (key === Op.placeholder) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n\n  // OR/AND/NOT grouping logic\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? 'NOT ' : '';\n\n    if (Array.isArray(value)) {\n      value = value.map(item => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter(item => item && item.length);\n\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    // Op.or: [] should return no data.\n    // Op.not of no restriction should also return no data\n    if ((key === Op.or || key === Op.not) && !value) {\n      return '0 = 1';\n    }\n\n    return value ? `${outerBinding}(${value})` : undefined;\n  }\n\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map(prop => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map(item => this.whereItemQuery(key, item, options));\n    }\n\n    value = value.filter(item => item && item.length);\n\n    return value.length ? `(${value.join(binding)})` : undefined;\n  }\n\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n\n    Utils.getOperators(value).forEach(op => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, Object.assign({}, options, { json: false })));\n    });\n\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n\n    if (path[path.length - 1].includes('::')) {\n      const tmp = path[path.length - 1].split('::');\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n\n    const pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach(op => {\n        const value = this._toJSONValue(item[op]);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n\n      return;\n    }\n\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n\n  _toJSONValue(value) {\n    return value;\n  }\n\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n\n    return new Utils.Literal(key);\n  }\n\n  _getJsonCast(value) {\n    if (typeof value === 'number') {\n      return 'double precision';\n    }\n    if (value instanceof Date) {\n      return 'timestamptz';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    return;\n  }\n\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === undefined) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split('.');\n\n      if (key.length > 2) {\n        key = [\n          // join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'),\n          key[key.length - 1]\n        ];\n      }\n\n      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    }\n\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join('.');\n      }\n\n      return [this.quoteTable(prefix), key].join('.');\n    }\n\n    return key;\n  }\n\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);\n        }\n\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n        }\n\n        return '';\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split('.');\n\n        if (value.length > 2) {\n          value = [\n            // join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'),\n            value[value.length - 1]\n          ];\n        }\n\n        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);\n      case Op.startsWith:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`${value}%`), comparator, options.prefix);\n      case Op.endsWith:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`%${value}`), comparator, options.prefix);\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n        return this._joinKeyValue(key, this.escape(`%${value}%`), comparator, options.prefix);\n    }\n\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (prepend === undefined) {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === 'number') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error('Support for literal replacements in the `where` object has been removed.');\n    }\n    if (smth === null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return '1=1';\n  }\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n\n  booleanValue(value) {\n    return value;\n  }\n}\n\nObject.assign(QueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(QueryGenerator.prototype, require('./query-generator/transaction'));\n\nmodule.exports = QueryGenerator;\n", "'use strict';\n\nconst MySQLQueryGenerator = require('../mysql/query-generator');\n\nclass MariaDBQueryGenerator extends MySQLQueryGenerator {\n  createSchema(schema, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)}${charset}${collate};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n\n  showSchemasQuery(options) {\n    const skip =  options.skip && Array.isArray(options.skip) && options.skip.length > 0 ? options.skip : null;\n    return `SELECT SCHEMA_NAME as schema_name FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA'${skip ? skip.reduce( (sql, schemaName) => sql +=  `,${this.escape(schemaName)}`, '') : ''});`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\') AND TABLE_TYPE = \\'BASE TABLE\\'';\n  }\n}\n\nmodule.exports = MariaDBQueryGenerator;\n", "'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,'\n  + 'CONSTRAINT_NAME as constraintName,'\n  + 'CONSTRAINT_SCHEMA as constraintSchema,'\n  + 'CONSTRAINT_SCHEMA as constraintCatalog,'\n  + 'TABLE_NAME as tableName,'\n  + 'TABLE_SCHEMA as tableSchema,'\n  + 'TABLE_SCHEMA as tableCatalog,'\n  + 'COLUMN_NAME as columnName,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,'\n  + 'REFERENCED_TABLE_NAME as referencedTableName,'\n  + 'REFERENCED_COLUMN_NAME as referencedColumnName';\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = Object.assign({}, this.OperatorMap, {\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const database = this.quoteIdentifier(databaseName);\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `${`CREATE DATABASE IF NOT EXISTS ${database}${charset}${collate}`.trim()};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName).trim()};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const comment = options.comment && typeof options.comment === 'string' ? ` COMMENT ${this.escape(options.comment)}` : '';\n    const engine = options.engine;\n    const charset = options.charset ? ` DEFAULT CHARSET=${options.charset}` : '';\n    const collation = options.collate ? ` COLLATE ${options.collate}` : '';\n    const rowFormat = options.rowFormat ? ` ROW_FORMAT=${options.rowFormat}` : '';\n    const initialAutoIncrement = options.initialAutoIncrement ? ` AUTO_INCREMENT=${options.initialAutoIncrement}` : '';\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${table} (${attributesClause}) ENGINE=${engine}${comment}${charset}${collation}${initialAutoIncrement}${rowFormat};`;\n  }\n\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery() {\n    return 'SHOW TABLES;';\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `CHANGE ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return `${key}=VALUES(${key})`;\n    }).join(', ');\n\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return `SHOW INDEX FROM ${this.quoteTable(tableName)}${(options || {}).database ? ` FROM \\`${options.database}\\`` : ''}`;\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    let sql = [\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`\n    ].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}' AND REFERENCED_TABLE_NAME IS NOT NULL;`;\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE`\n      + ` WHERE (REFERENCED_TABLE_NAME = ${quotedTableName}${table.schema\n        ? ` AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`\n        : ''} AND REFERENCED_COLUMN_NAME = ${quotedColumnName})`\n      + ` OR (TABLE_NAME = ${quotedTableName}${table.schema ?\n        ` AND TABLE_SCHEMA = ${quotedSchemaName}` : ''} AND COLUMN_NAME = ${quotedColumnName} AND REFERENCED_TABLE_NAME IS NOT NULL)`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)}\n      DROP FOREIGN KEY ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n", "'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n\n    const bind = [];\n    const bindParam = this.bindParam(bind);\n\n    const upsertOptions = _.defaults({ bindParam }, options);\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    const query = `${insert.query} ${update.query}`;\n\n    return { query, bind };\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n}\n\nmodule.exports = SQLiteQueryGenerator;\n", "'use strict';\n\nconst chai = require('chai'),\n  Sequelize = require('../../../index'),\n  Op = Sequelize.Op,\n  Promise = Sequelize.Promise,\n  moment = require('moment'),\n  expect = chai.expect,\n  Support = require('../support'),\n  DataTypes = require('../../../lib/data-types'),\n  current = Support.sequelize;\n\ndescribe(Support.getTestDialectTeaser('Model'), () => {\n  if (current.dialect.supports.JSON) {\n    describe('JSON', () => {\n      beforeEach(function() {\n        this.Event = this.sequelize.define('Event', {\n          data: {\n            type: DataTypes.JSON,\n            field: 'event_data',\n            index: true\n          },\n          json: DataTypes.JSON\n        });\n\n        return this.Event.sync({ force: true });\n      });\n\n      if (current.dialect.supports.lock) {\n        it('findOrCreate supports transactions, json and locks', function() {\n          return current.transaction().then(transaction => {\n            return this.Event.findOrCreate({\n              where: {\n                json: { some: { input: 'Hello' } }\n              },\n              defaults: {\n                json: { some: { input: 'Hello' }, input: [1, 2, 3] },\n                data: { some: { input: 'There' }, input: [4, 5, 6] }\n              },\n              transaction,\n              lock: transaction.LOCK.UPDATE,\n              logging: sql => {\n                if (sql.includes('SELECT') && !sql.includes('CREATE')) {\n                  expect(sql.includes('FOR UPDATE')).to.be.true;\n                }\n              }\n            }).then(() => {\n              return this.Event.count().then(count => {\n                expect(count).to.equal(0);\n                return transaction.commit().then(() => {\n                  return this.Event.count().then(count => {\n                    expect(count).to.equal(1);\n                  });\n                });\n              });\n            });\n          });\n        });\n      }\n\n      describe('create', () => {\n        it('should create an instance with JSON data', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return this.Event.findAll().then(events => {\n              const event = events[0];\n\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n            });\n          });\n        });\n      });\n\n      describe('update', () => {\n        it('should update with JSON column (dot notation)', function() {\n          return this.Event.bulkCreate([{\n            id: 1,\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }, {\n            id: 2,\n            data: {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Multiverse Scientist'\n            }\n          }]).then(() => this.Event.update({\n            'data': {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            }\n          }, {\n            where: {\n              'data.name.first': 'Rick'\n            }\n          })).then(() => this.Event.findByPk(2)).then(event => {\n            expect(event.get('data')).to.eql({\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            });\n          });\n        });\n\n        it('should update with JSON column (JSON notation)', function() {\n          return this.Event.bulkCreate([{\n            id: 1,\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }, {\n            id: 2,\n            data: {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Multiverse Scientist'\n            }\n          }]).then(() => this.Event.update({\n            'data': {\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            }\n          }, {\n            where: {\n              data: {\n                name: {\n                  first: 'Rick'\n                }\n              }\n            }\n          })).then(() => this.Event.findByPk(2)).then(event => {\n            expect(event.get('data')).to.eql({\n              name: {\n                first: 'Rick',\n                last: 'Sanchez'\n              },\n              employment: 'Galactic Fed Prisioner'\n            });\n          });\n        });\n\n        it('should update an instance with JSON data', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(event => {\n            return event.update({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: null\n              }\n            });\n          }).then(() => {\n            return this.Event.findAll().then(events => {\n              const event = events[0];\n\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: null\n              });\n            });\n          });\n        });\n      });\n\n      describe('find', () => {\n        it('should be possible to query a nested value', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  employment: 'Housewife'\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              });\n            });\n          });\n        });\n\n        it('should be possible to query dates with array operators', function() {\n          const now = moment().milliseconds(0).toDate();\n          const before = moment().milliseconds(0).subtract(1, 'day').toDate();\n          const after = moment().milliseconds(0).add(1, 'day').toDate();\n          return Promise.join(\n            this.Event.create({\n              json: {\n                user: 'Homer',\n                lastLogin: now\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  lastLogin: now\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                lastLogin: now.toISOString()\n              });\n            });\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  lastLogin: { [Op.between]: [before, after] }\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                lastLogin: now.toISOString()\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a boolean with array operators', function() {\n          return Promise.join(\n            this.Event.create({\n              json: {\n                user: 'Homer',\n                active: true\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  active: true\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                active: true\n              });\n            });\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                json: {\n                  active: { [Op.in]: [true, false] }\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('json')).to.eql({\n                user: 'Homer',\n                active: true\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a nested integer value', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                age: 40\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                age: 37\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  age: {\n                    [Op.gt]: 38\n                  }\n                }\n              }\n            }).then(events => {\n              const event = events[0];\n\n              expect(events.length).to.equal(1);\n              expect(event.get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                age: 40\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a nested null value', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: null\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  employment: null\n                }\n              }\n            }).then(events => {\n              expect(events.length).to.equal(1);\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: null\n              });\n            });\n          });\n        });\n\n        it('should be possible to query for nested fields with hyphens/dashes, #8718', function() {\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                status_report: {\n                  'red-indicator': {\n                    'level$$level': true\n                  }\n                },\n                employment: 'Nuclear Safety Inspector'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: null\n              }\n            })\n          ).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  status_report: {\n                    'red-indicator': {\n                      'level$$level': true\n                    }\n                  }\n                }\n              }\n            }).then(events => {\n              expect(events.length).to.equal(1);\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                status_report: {\n                  'red-indicator': {\n                    'level$$level': true\n                  }\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n            });\n          });\n        });\n\n        it('should be possible to query multiple nested values', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return Promise.join(\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Marge',\n                    last: 'Simpson'\n                  },\n                  employment: 'Housewife'\n                }\n              }),\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Bart',\n                    last: 'Simpson'\n                  },\n                  employment: 'None'\n                }\n              })\n            );\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  name: {\n                    last: 'Simpson'\n                  },\n                  employment: {\n                    [Op.ne]: 'None'\n                  }\n                }\n              },\n              order: [\n                ['id', 'ASC']\n              ]\n            }).then(events => {\n              expect(events.length).to.equal(2);\n\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n\n              expect(events[1].get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              });\n            });\n          });\n        });\n\n        it('should be possible to query a nested value and order results', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return Promise.join(\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Marge',\n                    last: 'Simpson'\n                  },\n                  employment: 'Housewife'\n                }\n              }),\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Bart',\n                    last: 'Simpson'\n                  },\n                  employment: 'None'\n                }\n              })\n            );\n          }).then(() => {\n            return this.Event.findAll({\n              where: {\n                data: {\n                  name: {\n                    last: 'Simpson'\n                  }\n                }\n              },\n              order: [\n                ['data.name.first']\n              ]\n            }).then(events => {\n              expect(events.length).to.equal(3);\n\n              expect(events[0].get('data')).to.eql({\n                name: {\n                  first: 'Bart',\n                  last: 'Simpson'\n                },\n                employment: 'None'\n              });\n\n              expect(events[1].get('data')).to.eql({\n                name: {\n                  first: 'Homer',\n                  last: 'Simpson'\n                },\n                employment: 'Nuclear Safety Inspector'\n              });\n\n              expect(events[2].get('data')).to.eql({\n                name: {\n                  first: 'Marge',\n                  last: 'Simpson'\n                },\n                employment: 'Housewife'\n              });\n            });\n          });\n        });\n      });\n\n      describe('destroy', () => {\n        it('should be possible to destroy with where', function() {\n          const conditionSearch = {\n            where: {\n              data: {\n                employment: 'Hacker'\n              }\n            }\n          };\n\n          return Promise.join(\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Elliot',\n                  last: 'Alderson'\n                },\n                employment: 'Hacker'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: 'Christian',\n                  last: 'Slater'\n                },\n                employment: 'Hacker'\n              }\n            }),\n            this.Event.create({\n              data: {\n                name: {\n                  first: ' Tyrell',\n                  last: 'Wellick'\n                },\n                employment: 'CTO'\n              }\n            })\n          ).then(() => {\n            return expect(this.Event.findAll(conditionSearch)).to.eventually.have.length(2);\n          }).then(() => {\n            return this.Event.destroy(conditionSearch);\n          }).then(() => {\n            return expect(this.Event.findAll(conditionSearch)).to.eventually.have.length(0);\n          });\n        });\n      });\n\n      describe('sql injection attacks', () => {\n        beforeEach(function() {\n          this.Model = this.sequelize.define('Model', {\n            data: DataTypes.JSON\n          });\n          return this.sequelize.sync({ force: true });\n        });\n\n        it('should properly escape the single quotes', function() {\n          return this.Model.create({\n            data: {\n              type: 'Point',\n              properties: {\n                exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n              }\n            }\n          });\n        });\n\n        it('should properly escape path keys', function() {\n          return this.Model.findAll({\n            raw: true,\n            attributes: ['id'],\n            where: {\n              data: {\n                \"a')) AS DECIMAL) = 1 DELETE YOLO INJECTIONS; -- \": 1\n              }\n            }\n          });\n        });\n\n        it('should properly escape path keys with sequelize.json', function() {\n          return this.Model.findAll({\n            raw: true,\n            attributes: ['id'],\n            where: this.sequelize.json(\"data.id')) AS DECIMAL) = 1 DELETE YOLO INJECTIONS; -- \", '1')\n          });\n        });\n\n        it('should properly escape the single quotes in array', function() {\n          return this.Model.create({\n            data: {\n              type: 'Point',\n              coordinates: [39.807222, \"'); DELETE YOLO INJECTIONS; --\"]\n            }\n          });\n        });\n\n        it('should be possible to find with properly escaped select query', function() {\n          return this.Model.create({\n            data: {\n              type: 'Point',\n              properties: {\n                exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n              }\n            }\n          }).then(() => {\n            return this.Model.findOne({\n              where: {\n                data: {\n                  type: 'Point',\n                  properties: {\n                    exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n                  }\n                }\n              }\n            });\n          }).then(result => {\n            expect(result.get('data')).to.deep.equal({\n              type: 'Point',\n              properties: {\n                exploit: \"'); DELETE YOLO INJECTIONS; -- \"\n              }\n            });\n          });\n        });\n\n        it('should query an instance with JSONB data and order while trying to inject', function() {\n          return this.Event.create({\n            data: {\n              name: {\n                first: 'Homer',\n                last: 'Simpson'\n              },\n              employment: 'Nuclear Safety Inspector'\n            }\n          }).then(() => {\n            return Promise.join(\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Marge',\n                    last: 'Simpson'\n                  },\n                  employment: 'Housewife'\n                }\n              }),\n              this.Event.create({\n                data: {\n                  name: {\n                    first: 'Bart',\n                    last: 'Simpson'\n                  },\n                  employment: 'None'\n                }\n              })\n            );\n          }).then(() => {\n            if (current.options.dialect === 'sqlite') {\n              return this.Event.findAll({\n                where: {\n                  data: {\n                    name: {\n                      last: 'Simpson'\n                    }\n                  }\n                },\n                order: [\n                  [\"data.name.first}'); INSERT INJECTION HERE! SELECT ('\"]\n                ]\n              }).then(events => {\n                expect(events).to.be.ok;\n                expect(events[0].get('data')).to.eql({\n                  name: {\n                    first: 'Homer',\n                    last: 'Simpson'\n                  },\n                  employment: 'Nuclear Safety Inspector'\n                });\n              });\n            }\n            if (current.options.dialect === 'postgres') {\n              return expect(this.Event.findAll({\n                where: {\n                  data: {\n                    name: {\n                      last: 'Simpson'\n                    }\n                  }\n                },\n                order: [\n                  [\"data.name.first}'); INSERT INJECTION HERE! SELECT ('\"]\n                ]\n              })).to.eventually.be.rejectedWith(Error);\n            }\n          });\n        });\n      });\n    });\n  }\n\n});\n", "'use strict';\n\nconst Support = require('../support'),\n  DataTypes = require('../../../lib/data-types'),\n  expect = require('chai').expect,\n  expectsql = Support.expectsql,\n  Sequelize = Support.Sequelize,\n  current = Support.sequelize,\n  sql = current.dialect.QueryGenerator;\n\n// Notice: [] will be replaced by dialect specific tick/quote character when there is not dialect specific expectation but only a default expectation\nif (current.dialect.supports.JSON) {\n  describe(Support.getTestDialectTeaser('SQL'), () => {\n    describe('JSON', () => {\n      describe('escape', () => {\n        it('plain string', () => {\n          expectsql(sql.escape('string', { type: new DataTypes.JSON() }), {\n            default: '\\'\"string\"\\'',\n            mariadb: '\\'\\\\\"string\\\\\"\\'',\n            mysql: '\\'\\\\\"string\\\\\"\\''\n          });\n        });\n\n        it('plain int', () => {\n          expectsql(sql.escape(0, { type: new DataTypes.JSON() }), {\n            default: '\\'0\\''\n          });\n          expectsql(sql.escape(123, { type: new DataTypes.JSON() }), {\n            default: '\\'123\\''\n          });\n        });\n\n        it('boolean', () => {\n          expectsql(sql.escape(true, { type: new DataTypes.JSON() }), {\n            default: '\\'true\\''\n          });\n          expectsql(sql.escape(false, { type: new DataTypes.JSON() }), {\n            default: '\\'false\\''\n          });\n        });\n\n        it('NULL', () => {\n          expectsql(sql.escape(null, { type: new DataTypes.JSON() }), {\n            default: 'NULL'\n          });\n        });\n\n        it('nested object', () => {\n          expectsql(sql.escape({ some: 'nested', more: { nested: true }, answer: 42 }, { type: new DataTypes.JSON() }), {\n            default: '\\'{\"some\":\"nested\",\"more\":{\"nested\":true},\"answer\":42}\\'',\n            mariadb: '\\'{\\\\\"some\\\\\":\\\\\"nested\\\\\",\\\\\"more\\\\\":{\\\\\"nested\\\\\":true},\\\\\"answer\\\\\":42}\\'',\n            mysql: '\\'{\\\\\"some\\\\\":\\\\\"nested\\\\\",\\\\\"more\\\\\":{\\\\\"nested\\\\\":true},\\\\\"answer\\\\\":42}\\''\n          });\n        });\n\n        if (current.dialect.supports.ARRAY) {\n          it('array of JSON', () => {\n            expectsql(sql.escape([\n              { some: 'nested', more: { nested: true }, answer: 42 },\n              43,\n              'joe'\n            ], { type: DataTypes.ARRAY(DataTypes.JSON) }), {\n              postgres: 'ARRAY[\\'{\"some\":\"nested\",\"more\":{\"nested\":true},\"answer\":42}\\',\\'43\\',\\'\"joe\"\\']::JSON[]'\n            });\n          });\n\n          if (current.dialect.supports.JSONB) {\n            it('array of JSONB', () => {\n              expectsql(sql.escape([\n                { some: 'nested', more: { nested: true }, answer: 42 },\n                43,\n                'joe'\n              ], { type: DataTypes.ARRAY(DataTypes.JSONB) }), {\n                postgres: 'ARRAY[\\'{\"some\":\"nested\",\"more\":{\"nested\":true},\"answer\":42}\\',\\'43\\',\\'\"joe\"\\']::JSONB[]'\n              });\n            });\n          }\n        }\n      });\n\n      describe('path extraction', () => {\n        it('condition object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ id: 1 })), {\n            postgres: '(\"id\"#>>\\'{}\\') = \\'1\\'',\n            sqlite: \"json_extract(`id`,'$') = '1'\",\n            mariadb: \"json_unquote(json_extract(`id`,'$')) = '1'\",\n            mysql: \"json_unquote(json_extract(`id`,'$')) = '1'\"\n          });\n        });\n\n        it('nested condition object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ profile: { id: 1 } })), {\n            postgres: '(\"profile\"#>>\\'{id}\\') = \\'1\\'',\n            sqlite: \"json_extract(`profile`,'$.id') = '1'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = '1'\",\n            mysql: \"json_unquote(json_extract(`profile`,'$.\\\\\\\"id\\\\\\\"')) = '1'\"\n          });\n        });\n\n        it('multiple condition object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ property: { value: 1 }, another: { value: 'string' } })), {\n            postgres: '(\"property\"#>>\\'{value}\\') = \\'1\\' AND (\"another\"#>>\\'{value}\\') = \\'string\\'',\n            sqlite: \"json_extract(`property`,'$.value') = '1' AND json_extract(`another`,'$.value') = 'string'\",\n            mariadb: \"json_unquote(json_extract(`property`,'$.value')) = '1' AND json_unquote(json_extract(`another`,'$.value')) = 'string'\",\n            mysql: \"json_unquote(json_extract(`property`,'$.\\\\\\\"value\\\\\\\"')) = '1' AND json_unquote(json_extract(`another`,'$.\\\\\\\"value\\\\\\\"')) = 'string'\"\n          });\n        });\n\n        it('property array object', () => {\n          expectsql(sql.whereItemQuery(undefined, Sequelize.json({ property: [[4, 6], [8]] })), {\n            postgres: '(\"property\"#>>\\'{0,0}\\') = \\'4\\' AND (\"property\"#>>\\'{0,1}\\') = \\'6\\' AND (\"property\"#>>\\'{1,0}\\') = \\'8\\'',\n            sqlite: \"json_extract(`property`,'$[0][0]') = '4' AND json_extract(`property`,'$[0][1]') = '6' AND json_extract(`property`,'$[1][0]') = '8'\",\n            mariadb: \"json_unquote(json_extract(`property`,'$[0][0]')) = '4' AND json_unquote(json_extract(`property`,'$[0][1]')) = '6' AND json_unquote(json_extract(`property`,'$[1][0]')) = '8'\",\n            mysql: \"json_unquote(json_extract(`property`,'$[0][0]')) = '4' AND json_unquote(json_extract(`property`,'$[0][1]')) = '6' AND json_unquote(json_extract(`property`,'$[1][0]')) = '8'\"\n          });\n        });\n\n        it('dot notation', () => {\n          expectsql(sql.whereItemQuery(Sequelize.json('profile.id'), '1'), {\n            postgres: '(\"profile\"#>>\\'{id}\\') = \\'1\\'',\n            sqlite: \"json_extract(`profile`,'$.id') = '1'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = '1'\",\n            mysql: \"json_unquote(json_extract(`profile`,'$.\\\\\\\"id\\\\\\\"')) = '1'\"\n          });\n        });\n\n        it('item dot notation array', () => {\n          expectsql(sql.whereItemQuery(Sequelize.json('profile.id.0.1'), '1'), {\n            postgres: '(\"profile\"#>>\\'{id,0,1}\\') = \\'1\\'',\n            sqlite: \"json_extract(`profile`,'$.id[0][1]') = '1'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id[0][1]')) = '1'\",\n            mysql: \"json_unquote(json_extract(`profile`,'$.\\\\\\\"id\\\\\\\"[0][1]')) = '1'\"\n          });\n        });\n\n        it('column named \"json\"', () => {\n          expectsql(sql.whereItemQuery(Sequelize.json('json'), '{}'), {\n            postgres: '(\"json\"#>>\\'{}\\') = \\'{}\\'',\n            sqlite: \"json_extract(`json`,'$') = '{}'\",\n            mariadb: \"json_unquote(json_extract(`json`,'$')) = '{}'\",\n            mysql: \"json_unquote(json_extract(`json`,'$')) = '{}'\"\n          });\n        });\n      });\n\n      describe('raw json query', () => {\n        if (current.dialect.name === 'postgres') {\n          it('#>> operator', () => {\n            expectsql(sql.whereItemQuery(Sequelize.json('(\"data\"#>>\\'{id}\\')'), 'id'), {\n              postgres: '(\"data\"#>>\\'{id}\\') = \\'id\\''\n            });\n          });\n        }\n\n        it('json function', () => {\n          expectsql(sql.handleSequelizeMethod(Sequelize.json('json(\\'{\"profile\":{\"name\":\"david\"}}\\')')), {\n            default: 'json(\\'{\"profile\":{\"name\":\"david\"}}\\')'\n          });\n        });\n\n        it('nested json functions', () => {\n          expectsql(sql.handleSequelizeMethod(Sequelize.json('json_extract(json_object(\\'{\"profile\":null}\\'), \"profile\")')), {\n            default: 'json_extract(json_object(\\'{\"profile\":null}\\'), \"profile\")'\n          });\n        });\n\n        it('escaped string argument', () => {\n          expectsql(sql.handleSequelizeMethod(Sequelize.json('json(\\'{\"quote\":{\"single\":\"\\'\\'\",\"double\":\"\"\"\"},\"parenthesis\":\"())(\"}\\')')), {\n            default: 'json(\\'{\"quote\":{\"single\":\"\\'\\'\",\"double\":\"\"\"\"},\"parenthesis\":\"())(\"}\\')'\n          });\n        });\n\n        it('unbalnced statement', () => {\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json())'))).to.throw();\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json_extract(json()'))).to.throw();\n        });\n\n        it('separator injection', () => {\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json(; DELETE YOLO INJECTIONS; -- )'))).to.throw();\n          expect(() => sql.handleSequelizeMethod(Sequelize.json('json(); DELETE YOLO INJECTIONS; -- '))).to.throw();\n        });\n      });\n    });\n  });\n}\n", "'use strict';\n\nconst Support = require('../support'),\n  DataTypes = require('../../../lib/data-types'),\n  QueryTypes = require('../../../lib/query-types'),\n  util = require('util'),\n  _ = require('lodash'),\n  expectsql = Support.expectsql,\n  current = Support.sequelize,\n  sql = current.dialect.QueryGenerator,\n  Op = Support.Sequelize.Op;\n\n// Notice: [] will be replaced by dialect specific tick/quote character when there is not dialect specific expectation but only a default expectation\n\ndescribe(Support.getTestDialectTeaser('SQL'), () => {\n  describe('whereQuery', () => {\n    const testsql = function(params, options, expectation) {\n      if (expectation === undefined) {\n        expectation = options;\n        options = undefined;\n      }\n\n      it(util.inspect(params, { depth: 10 }) + (options && `, ${util.inspect(options)}` || ''), () => {\n        const sqlOrError = _.attempt(sql.whereQuery.bind(sql), params, options);\n        return expectsql(sqlOrError, expectation);\n      });\n    };\n\n    testsql({}, {\n      default: ''\n    });\n    testsql([], {\n      default: ''\n    });\n    testsql({ id: undefined }, {\n      default: new Error('WHERE parameter \"id\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1 }, {\n      default: 'WHERE [id] = 1'\n    });\n    testsql({ id: 1, user: undefined }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1, user: undefined }, { type: QueryTypes.SELECT }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1, user: undefined }, { type: QueryTypes.BULKDELETE }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1, user: undefined }, { type: QueryTypes.BULKUPDATE }, {\n      default: new Error('WHERE parameter \"user\" has invalid \"undefined\" value')\n    });\n    testsql({ id: 1 }, { prefix: 'User' }, {\n      default: 'WHERE [User].[id] = 1'\n    });\n\n    it(\"{ id: 1 }, { prefix: current.literal(sql.quoteTable.call(current.dialect.QueryGenerator, {schema: 'yolo', tableName: 'User'})) }\", () => {\n      expectsql(sql.whereQuery({ id: 1 }, { prefix: current.literal(sql.quoteTable.call(current.dialect.QueryGenerator, { schema: 'yolo', tableName: 'User' })) }), {\n        default: 'WHERE [yolo.User].[id] = 1',\n        postgres: 'WHERE \"yolo\".\"User\".\"id\" = 1',\n        mariadb: 'WHERE `yolo`.`User`.`id` = 1',\n        mssql: 'WHERE [yolo].[User].[id] = 1'\n      });\n    });\n\n    testsql({\n      name: 'a project',\n      [Op.or]: [\n        { id: [1, 2, 3] },\n        { id: { [Op.gt]: 10 } }\n      ]\n    }, {\n      default: \"WHERE ([id] IN (1, 2, 3) OR [id] > 10) AND [name] = 'a project'\",\n      mssql: \"WHERE ([id] IN (1, 2, 3) OR [id] > 10) AND [name] = N'a project'\"\n    });\n\n    testsql({\n      name: 'a project',\n      id: {\n        [Op.or]: [\n          [1, 2, 3],\n          { [Op.gt]: 10 }\n        ]\n      }\n    }, {\n      default: \"WHERE [name] = 'a project' AND ([id] IN (1, 2, 3) OR [id] > 10)\",\n      mssql: \"WHERE [name] = N'a project' AND ([id] IN (1, 2, 3) OR [id] > 10)\"\n    });\n\n    testsql({\n      name: 'here is a null char: \\0'\n    }, {\n      default: \"WHERE [name] = 'here is a null char: \\\\0'\",\n      mssql: \"WHERE [name] = N'here is a null char: \\0'\",\n      sqlite: \"WHERE `name` = 'here is a null char: \\0'\"\n    });\n  });\n\n  describe('whereItemQuery', () => {\n    const testsql = function(key, value, options, expectation) {\n      if (expectation === undefined) {\n        expectation = options;\n        options = undefined;\n      }\n\n      it(`${String(key)}: ${util.inspect(value, { depth: 10 })}${options && `, ${util.inspect(options)}` || ''}`, () => {\n        return expectsql(sql.whereItemQuery(key, value, options), expectation);\n      });\n    };\n\n    testsql(undefined, 'lol=1', {\n      default: 'lol=1'\n    });\n\n    testsql('deleted', null, {\n      default: '`deleted` IS NULL',\n      postgres: '\"deleted\" IS NULL',\n      mssql: '[deleted] IS NULL'\n    });\n\n    describe('Op.in', () => {\n      testsql('equipment', {\n        [Op.in]: [1, 3]\n      }, {\n        default: '[equipment] IN (1, 3)'\n      });\n\n      testsql('equipment', {\n        [Op.in]: []\n      }, {\n        default: '[equipment] IN (NULL)'\n      });\n\n      testsql('muscles', {\n        [Op.in]: [2, 4]\n      }, {\n        default: '[muscles] IN (2, 4)'\n      });\n\n      testsql('equipment', {\n        [Op.in]: current.literal(\n          '(select order_id from product_orders where product_id = 3)'\n        )\n      }, {\n        default: '[equipment] IN (select order_id from product_orders where product_id = 3)'\n      });\n    });\n\n    describe('Buffer', () => {\n      testsql('field', Buffer.from('Sequelize'), {\n        postgres: '\"field\" = E\\'\\\\\\\\x53657175656c697a65\\'',\n        sqlite: \"`field` = X'53657175656c697a65'\",\n        mariadb: \"`field` = X'53657175656c697a65'\",\n        mysql: \"`field` = X'53657175656c697a65'\",\n        mssql: '[field] = 0x53657175656c697a65'\n      });\n    });\n\n    describe('Op.not', () => {\n      testsql('deleted', {\n        [Op.not]: true\n      }, {\n        default: '[deleted] IS NOT true',\n        mssql: '[deleted] IS NOT 1',\n        sqlite: '`deleted` IS NOT 1'\n      });\n\n      testsql('deleted', {\n        [Op.not]: null\n      }, {\n        default: '[deleted] IS NOT NULL'\n      });\n\n      testsql('muscles', {\n        [Op.not]: 3\n      }, {\n        default: '[muscles] != 3'\n      });\n    });\n\n    describe('Op.notIn', () => {\n      testsql('equipment', {\n        [Op.notIn]: []\n      }, {\n        default: ''\n      });\n\n      testsql('equipment', {\n        [Op.notIn]: [4, 19]\n      }, {\n        default: '[equipment] NOT IN (4, 19)'\n      });\n\n      testsql('equipment', {\n        [Op.notIn]: current.literal(\n          '(select order_id from product_orders where product_id = 3)'\n        )\n      }, {\n        default: '[equipment] NOT IN (select order_id from product_orders where product_id = 3)'\n      });\n    });\n\n    describe('Op.ne', () => {\n      testsql('email', {\n        [Op.ne]: 'jack.bauer@gmail.com'\n      }, {\n        default: \"[email] != 'jack.bauer@gmail.com'\",\n        mssql: \"[email] != N'jack.bauer@gmail.com'\"\n      });\n    });\n\n    describe('Op.and/Op.or/Op.not', () => {\n      describe('Op.or', () => {\n        testsql('email', {\n          [Op.or]: ['maker@mhansen.io', 'janzeh@gmail.com']\n        }, {\n          default: '([email] = \\'maker@mhansen.io\\' OR [email] = \\'janzeh@gmail.com\\')',\n          mssql: '([email] = N\\'maker@mhansen.io\\' OR [email] = N\\'janzeh@gmail.com\\')'\n        });\n\n        testsql('rank', {\n          [Op.or]: {\n            [Op.lt]: 100,\n            [Op.eq]: null\n          }\n        }, {\n          default: '([rank] < 100 OR [rank] IS NULL)'\n        });\n\n        testsql(Op.or, [\n          { email: 'maker@mhansen.io' },\n          { email: 'janzeh@gmail.com' }\n        ], {\n          default: '([email] = \\'maker@mhansen.io\\' OR [email] = \\'janzeh@gmail.com\\')',\n          mssql: '([email] = N\\'maker@mhansen.io\\' OR [email] = N\\'janzeh@gmail.com\\')'\n        });\n\n        testsql(Op.or, {\n          email: 'maker@mhansen.io',\n          name: 'Mick Hansen'\n        }, {\n          default: '([email] = \\'maker@mhansen.io\\' OR [name] = \\'Mick Hansen\\')',\n          mssql: '([email] = N\\'maker@mhansen.io\\' OR [name] = N\\'Mick Hansen\\')'\n        });\n\n        testsql(Op.or, {\n          equipment: [1, 3],\n          muscles: {\n            [Op.in]: [2, 4]\n          }\n        }, {\n          default: '([equipment] IN (1, 3) OR [muscles] IN (2, 4))'\n        });\n\n        testsql(Op.or, [\n          {\n            roleName: 'NEW'\n          }, {\n            roleName: 'CLIENT',\n            type: 'CLIENT'\n          }\n        ], {\n          default: \"([roleName] = 'NEW' OR ([roleName] = 'CLIENT' AND [type] = 'CLIENT'))\",\n          mssql: \"([roleName] = N'NEW' OR ([roleName] = N'CLIENT' AND [type] = N'CLIENT'))\"\n        });\n\n        it('sequelize.or({group_id: 1}, {user_id: 2})', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.or({ group_id: 1 }, { user_id: 2 })), {\n            default: '([group_id] = 1 OR [user_id] = 2)'\n          });\n        });\n\n        it(\"sequelize.or({group_id: 1}, {user_id: 2, role: 'admin'})\", function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.or({ group_id: 1 }, { user_id: 2, role: 'admin' })), {\n            default: \"([group_id] = 1 OR ([user_id] = 2 AND [role] = 'admin'))\",\n            mssql: \"([group_id] = 1 OR ([user_id] = 2 AND [role] = N'admin'))\"\n          });\n        });\n\n        testsql(Op.or, [], {\n          default: '0 = 1'\n        });\n\n        testsql(Op.or, {}, {\n          default: '0 = 1'\n        });\n\n        it('sequelize.or()', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.or()), {\n            default: '0 = 1'\n          });\n        });\n      });\n\n      describe('Op.and', () => {\n        testsql(Op.and, {\n          [Op.or]: {\n            group_id: 1,\n            user_id: 2\n          },\n          shared: 1\n        }, {\n          default: '(([group_id] = 1 OR [user_id] = 2) AND [shared] = 1)'\n        });\n\n        testsql(Op.and, [\n          {\n            name: {\n              [Op.like]: '%hello'\n            }\n          },\n          {\n            name: {\n              [Op.like]: 'hello%'\n            }\n          }\n        ], {\n          default: \"([name] LIKE '%hello' AND [name] LIKE 'hello%')\",\n          mssql: \"([name] LIKE N'%hello' AND [name] LIKE N'hello%')\"\n        });\n\n        testsql('rank', {\n          [Op.and]: {\n            [Op.ne]: 15,\n            [Op.between]: [10, 20]\n          }\n        }, {\n          default: '([rank] != 15 AND [rank] BETWEEN 10 AND 20)'\n        });\n\n        testsql('name', {\n          [Op.and]: [\n            { [Op.like]: '%someValue1%' },\n            { [Op.like]: '%someValue2%' }\n          ]\n        }, {\n          default: \"([name] LIKE '%someValue1%' AND [name] LIKE '%someValue2%')\",\n          mssql: \"([name] LIKE N'%someValue1%' AND [name] LIKE N'%someValue2%')\"\n        });\n\n        it('sequelize.and({shared: 1, sequelize.or({group_id: 1}, {user_id: 2}))', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.and({ shared: 1 }, this.sequelize.or({ group_id: 1 }, { user_id: 2 }))), {\n            default: '([shared] = 1 AND ([group_id] = 1 OR [user_id] = 2))'\n          });\n        });\n      });\n\n      describe('Op.not', () => {\n        testsql(Op.not, {\n          [Op.or]: {\n            group_id: 1,\n            user_id: 2\n          },\n          shared: 1\n        }, {\n          default: 'NOT (([group_id] = 1 OR [user_id] = 2) AND [shared] = 1)'\n        });\n\n        testsql(Op.not, [], {\n          default: '0 = 1'\n        });\n\n        testsql(Op.not, {}, {\n          default: '0 = 1'\n        });\n      });\n    });\n\n    describe('Op.col', () => {\n      testsql('userId', {\n        [Op.col]: 'user.id'\n      }, {\n        default: '[userId] = [user].[id]'\n      });\n\n      testsql('userId', {\n        [Op.eq]: {\n          [Op.col]: 'user.id'\n        }\n      }, {\n        default: '[userId] = [user].[id]'\n      });\n\n      testsql('userId', {\n        [Op.gt]: {\n          [Op.col]: 'user.id'\n        }\n      }, {\n        default: '[userId] > [user].[id]'\n      });\n\n      testsql(Op.or, [\n        { 'ownerId': { [Op.col]: 'user.id' } },\n        { 'ownerId': { [Op.col]: 'organization.id' } }\n      ], {\n        default: '([ownerId] = [user].[id] OR [ownerId] = [organization].[id])'\n      });\n\n      testsql('$organization.id$', {\n        [Op.col]: 'user.organizationId'\n      }, {\n        default: '[organization].[id] = [user].[organizationId]'\n      });\n\n      testsql('$offer.organization.id$', {\n        [Op.col]: 'offer.user.organizationId'\n      }, {\n        default: '[offer->organization].[id] = [offer->user].[organizationId]'\n      });\n    });\n\n    describe('Op.gt', () => {\n      testsql('rank', {\n        [Op.gt]: 2\n      }, {\n        default: '[rank] > 2'\n      });\n\n      testsql('created_at', {\n        [Op.lt]: {\n          [Op.col]: 'updated_at'\n        }\n      }, {\n        default: '[created_at] < [updated_at]'\n      });\n    });\n\n    describe('Op.like', () => {\n      testsql('username', {\n        [Op.like]: '%swagger'\n      }, {\n        default: \"[username] LIKE '%swagger'\",\n        mssql: \"[username] LIKE N'%swagger'\"\n      });\n    });\n\n    describe('Op.startsWith', () => {\n      testsql('username', {\n        [Op.startsWith]: 'swagger'\n      }, {\n        default: \"[username] LIKE 'swagger%'\",\n        mssql: \"[username] LIKE N'swagger%'\"\n      });\n    });\n\n    describe('Op.endsWith', () => {\n      testsql('username', {\n        [Op.endsWith]: 'swagger'\n      }, {\n        default: \"[username] LIKE '%swagger'\",\n        mssql: \"[username] LIKE N'%swagger'\"\n      });\n    });\n\n    describe('Op.substring', () => {\n      testsql('username', {\n        [Op.substring]: 'swagger'\n      }, {\n        default: \"[username] LIKE '%swagger%'\",\n        mssql: \"[username] LIKE N'%swagger%'\"\n      });\n    });\n\n    describe('Op.between', () => {\n      testsql('date', {\n        [Op.between]: ['2013-01-01', '2013-01-11']\n      }, {\n        default: \"[date] BETWEEN '2013-01-01' AND '2013-01-11'\",\n        mssql: \"[date] BETWEEN N'2013-01-01' AND N'2013-01-11'\"\n      });\n\n      testsql('date', {\n        [Op.between]: [new Date('2013-01-01'), new Date('2013-01-11')]\n      }, {\n        default: \"[date] BETWEEN '2013-01-01 00:00:00.000 +00:00' AND '2013-01-11 00:00:00.000 +00:00'\",\n        mysql: \"`date` BETWEEN '2013-01-01 00:00:00' AND '2013-01-11 00:00:00'\",\n        mariadb: \"`date` BETWEEN '2013-01-01 00:00:00.000' AND '2013-01-11 00:00:00.000'\"\n      });\n\n      testsql('date', {\n        [Op.between]: [1356998400000, 1357862400000]\n      }, {\n        model: {\n          rawAttributes: {\n            date: {\n              type: new DataTypes.DATE()\n            }\n          }\n        }\n      },\n      {\n        default: \"[date] BETWEEN '2013-01-01 00:00:00.000 +00:00' AND '2013-01-11 00:00:00.000 +00:00'\",\n        mssql: \"[date] BETWEEN N'2013-01-01 00:00:00.000 +00:00' AND N'2013-01-11 00:00:00.000 +00:00'\"\n      });\n\n      testsql('date', {\n        [Op.between]: ['2012-12-10', '2013-01-02'],\n        [Op.notBetween]: ['2013-01-04', '2013-01-20']\n      }, {\n        default: \"([date] BETWEEN '2012-12-10' AND '2013-01-02' AND [date] NOT BETWEEN '2013-01-04' AND '2013-01-20')\",\n        mssql: \"([date] BETWEEN N'2012-12-10' AND N'2013-01-02' AND [date] NOT BETWEEN N'2013-01-04' AND N'2013-01-20')\"\n      });\n    });\n\n    describe('Op.notBetween', () => {\n      testsql('date', {\n        [Op.notBetween]: ['2013-01-01', '2013-01-11']\n      }, {\n        default: \"[date] NOT BETWEEN '2013-01-01' AND '2013-01-11'\",\n        mssql: \"[date] NOT BETWEEN N'2013-01-01' AND N'2013-01-11'\"\n      });\n    });\n\n    if (current.dialect.supports.ARRAY) {\n      describe('ARRAY', () => {\n        describe('Op.contains', () => {\n          testsql('muscles', {\n            [Op.contains]: [2, 3]\n          }, {\n            postgres: '\"muscles\" @> ARRAY[2,3]'\n          });\n\n          testsql('muscles', {\n            [Op.contained]: [6, 8]\n          }, {\n            postgres: '\"muscles\" <@ ARRAY[6,8]'\n          });\n\n          testsql('muscles', {\n            [Op.contains]: [2, 5]\n          }, {\n            field: {\n              type: DataTypes.ARRAY(DataTypes.INTEGER)\n            }\n          }, {\n            postgres: '\"muscles\" @> ARRAY[2,5]::INTEGER[]'\n          });\n        });\n\n        describe('Op.overlap', () => {\n          testsql('muscles', {\n            [Op.overlap]: [3, 11]\n          }, {\n            postgres: '\"muscles\" && ARRAY[3,11]'\n          });\n        });\n\n        describe('Op.any', () => {\n          testsql('userId', {\n            [Op.any]: [4, 5, 6]\n          }, {\n            postgres: '\"userId\" = ANY (ARRAY[4,5,6])'\n          });\n\n          testsql('userId', {\n            [Op.any]: [2, 5]\n          }, {\n            field: {\n              type: DataTypes.ARRAY(DataTypes.INTEGER)\n            }\n          }, {\n            postgres: '\"userId\" = ANY (ARRAY[2,5]::INTEGER[])'\n          });\n\n          describe('Op.values', () => {\n            testsql('userId', {\n              [Op.any]: {\n                [Op.values]: [4, 5, 6]\n              }\n            }, {\n              postgres: '\"userId\" = ANY (VALUES (4), (5), (6))'\n            });\n\n            testsql('userId', {\n              [Op.any]: {\n                [Op.values]: [2, 5]\n              }\n            }, {\n              field: {\n                type: DataTypes.ARRAY(DataTypes.INTEGER)\n              }\n            }, {\n              postgres: '\"userId\" = ANY (VALUES (2), (5))'\n            });\n          });\n        });\n\n        describe('Op.all', () => {\n          testsql('userId', {\n            [Op.all]: [4, 5, 6]\n          }, {\n            postgres: '\"userId\" = ALL (ARRAY[4,5,6])'\n          });\n\n          testsql('userId', {\n            [Op.all]: [2, 5]\n          }, {\n            field: {\n              type: DataTypes.ARRAY(DataTypes.INTEGER)\n            }\n          }, {\n            postgres: '\"userId\" = ALL (ARRAY[2,5]::INTEGER[])'\n          });\n\n          describe('Op.values', () => {\n            testsql('userId', {\n              [Op.all]: {\n                [Op.values]: [4, 5, 6]\n              }\n            }, {\n              postgres: '\"userId\" = ALL (VALUES (4), (5), (6))'\n            });\n\n            testsql('userId', {\n              [Op.all]: {\n                [Op.values]: [2, 5]\n              }\n            }, {\n              field: {\n                type: DataTypes.ARRAY(DataTypes.INTEGER)\n              }\n            }, {\n              postgres: '\"userId\" = ALL (VALUES (2), (5))'\n            });\n          });\n        });\n\n        describe('Op.like', () => {\n          testsql('userId', {\n            [Op.like]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" LIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.iLike]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" ILIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notLike]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT LIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notILike]: {\n              [Op.any]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT ILIKE ANY (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.like]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" LIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.iLike]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" ILIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notLike]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT LIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n\n          testsql('userId', {\n            [Op.notILike]: {\n              [Op.all]: ['foo', 'bar', 'baz']\n            }\n          }, {\n            postgres: \"\\\"userId\\\" NOT ILIKE ALL (ARRAY['foo','bar','baz'])\"\n          });\n        });\n      });\n    }\n\n    if (current.dialect.supports.RANGE) {\n      describe('RANGE', () => {\n\n        testsql('range', {\n          [Op.contains]: new Date(Date.UTC(2000, 1, 1))\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"range\\\" @> '2000-02-01 00:00:00.000 +00:00'::timestamptz\"\n        });\n\n        testsql('range', {\n          [Op.contains]: [new Date(Date.UTC(2000, 1, 1)), new Date(Date.UTC(2000, 2, 1))]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"range\\\" @> '[\\\"2000-02-01 00:00:00.000 +00:00\\\",\\\"2000-03-01 00:00:00.000 +00:00\\\")'\"\n        });\n\n        testsql('range', {\n          [Op.contained]: [new Date(Date.UTC(2000, 1, 1)), new Date(Date.UTC(2000, 2, 1))]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"range\\\" <@ '[\\\"2000-02-01 00:00:00.000 +00:00\\\",\\\"2000-03-01 00:00:00.000 +00:00\\\")'\"\n        });\n\n        testsql('unboundedRange', {\n          [Op.contains]: [new Date(Date.UTC(2000, 1, 1)), null]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"unboundedRange\\\" @> '[\\\"2000-02-01 00:00:00.000 +00:00\\\",)'\"\n        });\n\n        testsql('unboundedRange', {\n          [Op.contains]: [-Infinity, Infinity]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE(DataTypes.DATE)\n          },\n          prefix: 'Timeline'\n        }, {\n          postgres: \"\\\"Timeline\\\".\\\"unboundedRange\\\" @> '[-infinity,infinity)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.overlap]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" && '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.adjacent]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" -|- '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.strictLeft]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" << '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.strictRight]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" >> '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.noExtendRight]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" &< '[1,4)'\"\n        });\n\n        testsql('reservedSeats', {\n          [Op.noExtendLeft]: [1, 4]\n        }, {\n          field: {\n            type: new DataTypes.postgres.RANGE()\n          },\n          prefix: 'Room'\n        }, {\n          postgres: \"\\\"Room\\\".\\\"reservedSeats\\\" &> '[1,4)'\"\n        });\n\n      });\n    }\n\n    if (current.dialect.supports.JSON) {\n      describe('JSON', () => {\n        it('sequelize.json(\"profile.id\"), sequelize.cast(2, \\'text\\')\")', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.json('profile.id', this.sequelize.cast('12346-78912', 'text'))), {\n            postgres: \"(\\\"profile\\\"#>>'{id}') = CAST('12346-78912' AS TEXT)\",\n            sqlite: \"json_extract(`profile`,'$.id') = CAST('12346-78912' AS TEXT)\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = CAST('12346-78912' AS CHAR)\",\n            mysql: \"json_unquote(json_extract(`profile`,'$.\\\\\\\"id\\\\\\\"')) = CAST('12346-78912' AS CHAR)\"\n          });\n        });\n\n        it('sequelize.json({profile: {id: \"12346-78912\", name: \"test\"}})', function() {\n          expectsql(sql.whereItemQuery(undefined, this.sequelize.json({ profile: { id: '12346-78912', name: 'test' } })), {\n            postgres: \"(\\\"profile\\\"#>>'{id}') = '12346-78912' AND (\\\"profile\\\"#>>'{name}') = 'test'\",\n            sqlite: \"json_extract(`profile`,'$.id') = '12346-78912' AND json_extract(`profile`,'$.name') = 'test'\",\n            mariadb: \"json_unquote(json_extract(`profile`,'$.id')) = '12346-78912' AND json_unquote(json_extract(`profile`,'$.name')) = 'test'\",\n            mysql: \"json_unquote(json_extract(`profile`,'$.\\\\\\\"id\\\\\\\"')) = '12346-78912' AND json_unquote(json_extract(`profile`,'$.\\\\\\\"name\\\\\\\"')) = 'test'\"\n          });\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: 'value'\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          },\n          prefix: 'User'\n        }, {\n          mariadb: \"json_unquote(json_extract(`User`.`data`,'$.nested.attribute')) = 'value'\",\n          mysql: \"json_unquote(json_extract(`User`.`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) = 'value'\",\n          postgres: \"(\\\"User\\\".\\\"data\\\"#>>'{nested,attribute}') = 'value'\",\n          sqlite: \"json_extract(`User`.`data`,'$.nested.attribute') = 'value'\"\n        });\n\n        testsql('data', {\n          nested: {\n            [Op.in]: [1, 2]\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested')) AS DECIMAL) IN (1, 2)\",\n          mysql: \"CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\"')) AS DECIMAL) IN (1, 2)\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested}') AS DOUBLE PRECISION) IN (1, 2)\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested') AS DOUBLE PRECISION) IN (1, 2)\"\n        });\n\n        testsql('data', {\n          nested: {\n            [Op.between]: [1, 2]\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested')) AS DECIMAL) BETWEEN 1 AND 2\",\n          mysql: \"CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\"')) AS DECIMAL) BETWEEN 1 AND 2\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested}') AS DOUBLE PRECISION) BETWEEN 1 AND 2\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested') AS DOUBLE PRECISION) BETWEEN 1 AND 2\"\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: 'value',\n            prop: {\n              [Op.ne]: 'None'\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          },\n          prefix: current.literal(sql.quoteTable.call(current.dialect.QueryGenerator, { tableName: 'User' }))\n        }, {\n          mariadb: \"(json_unquote(json_extract(`User`.`data`,'$.nested.attribute')) = 'value' AND json_unquote(json_extract(`User`.`data`,'$.nested.prop')) != 'None')\",\n          mysql: \"(json_unquote(json_extract(`User`.`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) = 'value' AND json_unquote(json_extract(`User`.`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"prop\\\\\\\"')) != 'None')\",\n          postgres: \"((\\\"User\\\".\\\"data\\\"#>>'{nested,attribute}') = 'value' AND (\\\"User\\\".\\\"data\\\"#>>'{nested,prop}') != 'None')\",\n          sqlite: \"(json_extract(`User`.`data`,'$.nested.attribute') = 'value' AND json_extract(`User`.`data`,'$.nested.prop') != 'None')\"\n        });\n\n        testsql('data', {\n          name: {\n            last: 'Simpson'\n          },\n          employment: {\n            [Op.ne]: 'None'\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          },\n          prefix: 'User'\n        }, {\n          mariadb: \"(json_unquote(json_extract(`User`.`data`,'$.name.last')) = 'Simpson' AND json_unquote(json_extract(`User`.`data`,'$.employment')) != 'None')\",\n          mysql: \"(json_unquote(json_extract(`User`.`data`,'$.\\\\\\\"name\\\\\\\".\\\\\\\"last\\\\\\\"')) = 'Simpson' AND json_unquote(json_extract(`User`.`data`,'$.\\\\\\\"employment\\\\\\\"')) != 'None')\",\n          postgres: \"((\\\"User\\\".\\\"data\\\"#>>'{name,last}') = 'Simpson' AND (\\\"User\\\".\\\"data\\\"#>>'{employment}') != 'None')\",\n          sqlite: \"(json_extract(`User`.`data`,'$.name.last') = 'Simpson' AND json_extract(`User`.`data`,'$.employment') != 'None')\"\n        });\n\n        testsql('data', {\n          price: 5,\n          name: 'Product'\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"(CAST(json_unquote(json_extract(`data`,'$.price')) AS DECIMAL) = 5 AND json_unquote(json_extract(`data`,'$.name')) = 'Product')\",\n          mysql: \"(CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"price\\\\\\\"')) AS DECIMAL) = 5 AND json_unquote(json_extract(`data`,'$.\\\\\\\"name\\\\\\\"')) = 'Product')\",\n          postgres: \"(CAST((\\\"data\\\"#>>'{price}') AS DOUBLE PRECISION) = 5 AND (\\\"data\\\"#>>'{name}') = 'Product')\",\n          sqlite: \"(CAST(json_extract(`data`,'$.price') AS DOUBLE PRECISION) = 5 AND json_extract(`data`,'$.name') = 'Product')\"\n        });\n\n        testsql('data.nested.attribute', 'value', {\n          model: {\n            rawAttributes: {\n              data: {\n                type: new DataTypes.JSONB()\n              }\n            }\n          }\n        }, {\n          mariadb: \"json_unquote(json_extract(`data`,'$.nested.attribute')) = 'value'\",\n          mysql: \"json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) = 'value'\",\n          postgres: \"(\\\"data\\\"#>>'{nested,attribute}') = 'value'\",\n          sqlite: \"json_extract(`data`,'$.nested.attribute') = 'value'\"\n        });\n\n        testsql('data.nested.attribute', 4, {\n          model: {\n            rawAttributes: {\n              data: {\n                type: new DataTypes.JSON()\n              }\n            }\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) = 4\",\n          mysql: \"CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) AS DECIMAL) = 4\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS DOUBLE PRECISION) = 4\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested.attribute') AS DOUBLE PRECISION) = 4\"\n        });\n\n        testsql('data.nested.attribute', {\n          [Op.in]: [3, 7]\n        }, {\n          model: {\n            rawAttributes: {\n              data: {\n                type: new DataTypes.JSONB()\n              }\n            }\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) IN (3, 7)\",\n          mysql: \"CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) AS DECIMAL) IN (3, 7)\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS DOUBLE PRECISION) IN (3, 7)\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested.attribute') AS DOUBLE PRECISION) IN (3, 7)\"\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: {\n              [Op.gt]: 2\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) > 2\",\n          mysql: \"CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) AS DECIMAL) > 2\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS DOUBLE PRECISION) > 2\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested.attribute') AS DOUBLE PRECISION) > 2\"\n        });\n\n        testsql('data', {\n          nested: {\n            'attribute::integer': {\n              [Op.gt]: 2\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"CAST(json_unquote(json_extract(`data`,'$.nested.attribute')) AS DECIMAL) > 2\",\n          mysql: \"CAST(json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) AS DECIMAL) > 2\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS INTEGER) > 2\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested.attribute') AS INTEGER) > 2\"\n        });\n\n        const dt = new Date();\n        testsql('data', {\n          nested: {\n            attribute: {\n              [Op.gt]: dt\n            }\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: `CAST(json_unquote(json_extract(\\`data\\`,'$.nested.attribute')) AS DATETIME) > ${sql.escape(dt)}`,\n          mysql: `CAST(json_unquote(json_extract(\\`data\\`,'$.\\\\\"nested\\\\\".\\\\\"attribute\\\\\"')) AS DATETIME) > ${sql.escape(dt)}`,\n          postgres: `CAST((\"data\"#>>'{nested,attribute}') AS TIMESTAMPTZ) > ${sql.escape(dt)}`,\n          sqlite: `json_extract(\\`data\\`,'$.nested.attribute') > ${sql.escape(dt.toISOString())}`\n        });\n\n        testsql('data', {\n          nested: {\n            attribute: true\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          mariadb: \"json_unquote(json_extract(`data`,'$.nested.attribute')) = 'true'\",\n          mysql: \"json_unquote(json_extract(`data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) = 'true'\",\n          postgres: \"CAST((\\\"data\\\"#>>'{nested,attribute}') AS BOOLEAN) = true\",\n          sqlite: \"CAST(json_extract(`data`,'$.nested.attribute') AS BOOLEAN) = 1\"\n        });\n\n        testsql('metaData.nested.attribute', 'value', {\n          model: {\n            rawAttributes: {\n              metaData: {\n                field: 'meta_data',\n                fieldName: 'metaData',\n                type: new DataTypes.JSONB()\n              }\n            }\n          }\n        }, {\n          mariadb: \"json_unquote(json_extract(`meta_data`,'$.nested.attribute')) = 'value'\",\n          mysql: \"json_unquote(json_extract(`meta_data`,'$.\\\\\\\"nested\\\\\\\".\\\\\\\"attribute\\\\\\\"')) = 'value'\",\n          postgres: \"(\\\"meta_data\\\"#>>'{nested,attribute}') = 'value'\",\n          sqlite: \"json_extract(`meta_data`,'$.nested.attribute') = 'value'\"\n        });\n      });\n    }\n\n    if (current.dialect.supports.JSONB) {\n      describe('JSONB', () => {\n        testsql('data', {\n          [Op.contains]: {\n            company: 'Magnafone'\n          }\n        }, {\n          field: {\n            type: new DataTypes.JSONB()\n          }\n        }, {\n          default: '[data] @> \\'{\"company\":\"Magnafone\"}\\''\n        });\n      });\n    }\n\n    if (current.dialect.supports.REGEXP) {\n      describe('Op.regexp', () => {\n        testsql('username', {\n          [Op.regexp]: '^sw.*r$'\n        }, {\n          mariadb: \"`username` REGEXP '^sw.*r$'\",\n          mysql: \"`username` REGEXP '^sw.*r$'\",\n          postgres: '\"username\" ~ \\'^sw.*r$\\''\n        });\n      });\n\n      describe('Op.regexp', () => {\n        testsql('newline', {\n          [Op.regexp]: '^new\\nline$'\n        }, {\n          mariadb: \"`newline` REGEXP '^new\\\\nline$'\",\n          mysql: \"`newline` REGEXP '^new\\\\nline$'\",\n          postgres: '\"newline\" ~ \\'^new\\nline$\\''\n        });\n      });\n\n      describe('Op.notRegexp', () => {\n        testsql('username', {\n          [Op.notRegexp]: '^sw.*r$'\n        }, {\n          mariadb: \"`username` NOT REGEXP '^sw.*r$'\",\n          mysql: \"`username` NOT REGEXP '^sw.*r$'\",\n          postgres: '\"username\" !~ \\'^sw.*r$\\''\n        });\n      });\n\n      describe('Op.notRegexp', () => {\n        testsql('newline', {\n          [Op.notRegexp]: '^new\\nline$'\n        }, {\n          mariadb: \"`newline` NOT REGEXP '^new\\\\nline$'\",\n          mysql: \"`newline` NOT REGEXP '^new\\\\nline$'\",\n          postgres: '\"newline\" !~ \\'^new\\nline$\\''\n        });\n      });\n\n      if (current.dialect.name === 'postgres') {\n        describe('Op.iRegexp', () => {\n          testsql('username', {\n            [Op.iRegexp]: '^sw.*r$'\n          }, {\n            postgres: '\"username\" ~* \\'^sw.*r$\\''\n          });\n        });\n\n        describe('Op.iRegexp', () => {\n          testsql('newline', {\n            [Op.iRegexp]: '^new\\nline$'\n          }, {\n            postgres: '\"newline\" ~* \\'^new\\nline$\\''\n          });\n        });\n\n        describe('Op.notIRegexp', () => {\n          testsql('username', {\n            [Op.notIRegexp]: '^sw.*r$'\n          }, {\n            postgres: '\"username\" !~* \\'^sw.*r$\\''\n          });\n        });\n\n        describe('Op.notIRegexp', () => {\n          testsql('newline', {\n            [Op.notIRegexp]: '^new\\nline$'\n          }, {\n            postgres: '\"newline\" !~* \\'^new\\nline$\\''\n          });\n        });\n      }\n    }\n\n    describe('fn', () => {\n      it('{name: this.sequelize.fn(\\'LOWER\\', \\'DERP\\')}', function() {\n        expectsql(sql.whereQuery({ name: this.sequelize.fn('LOWER', 'DERP') }), {\n          default: \"WHERE [name] = LOWER('DERP')\",\n          mssql: \"WHERE [name] = LOWER(N'DERP')\"\n        });\n      });\n    });\n  });\n\n  describe('getWhereConditions', () => {\n    const testsql = function(value, expectation) {\n      const User = current.define('user', {});\n\n      it(util.inspect(value, { depth: 10 }), () => {\n        return expectsql(sql.getWhereConditions(value, User.tableName, User), expectation);\n      });\n    };\n\n    testsql(current.where(current.fn('lower', current.col('name')), null), {\n      default: 'lower([name]) IS NULL'\n    });\n\n    testsql(current.where(current.fn('SUM', current.col('hours')), '>', 0), {\n      default: 'SUM([hours]) > 0'\n    });\n\n    testsql(current.where(current.fn('SUM', current.col('hours')), Op.gt, 0), {\n      default: 'SUM([hours]) > 0'\n    });\n  });\n});\n"], "filenames": ["lib/dialects/abstract/query-generator.js", "lib/dialects/mariadb/query-generator.js", "lib/dialects/mysql/query-generator.js", "lib/dialects/sqlite/query-generator.js", "test/integration/model/json.test.js", "test/unit/sql/json.test.js", "test/unit/sql/where.test.js"], "buggy_code_start_loc": [1070, 3, 212, 4, 696, 85, 828], "buggy_code_end_loc": [1089, 102, 245, 180, 696, 142, 1070], "fixing_code_start_loc": [1071, 2, 212, 3, 697, 85, 828], "fixing_code_end_loc": [1095, 29, 228, 155, 705, 142, 1070], "type": "CWE-89", "message": "Sequelize, all versions prior to version 4.44.3 and 5.15.1, is vulnerable to SQL Injection due to sequelize.json() helper function not escaping values properly when formatting sub paths for JSON queries for MySQL, MariaDB and SQLite.", "other": {"cve": {"id": "CVE-2019-10752", "sourceIdentifier": "report@snyk.io", "published": "2019-10-17T19:15:10.420", "lastModified": "2019-10-21T13:10:32.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sequelize, all versions prior to version 4.44.3 and 5.15.1, is vulnerable to SQL Injection due to sequelize.json() helper function not escaping values properly when formatting sub paths for JSON queries for MySQL, MariaDB and SQLite."}, {"lang": "es", "value": "Sequelize, todas las versiones anteriores a la versi\u00f3n 4.44.3 y 5.15.1, es vulnerable a una inyecci\u00f3n SQL debido a que la funci\u00f3n auxiliar sequelize.json() no escapa los valores apropiadamente cuando se formatean subrutas para consultas JSON para MySQL, MariaDB y SQLite."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sequelizejs:sequelize:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.44.3", "matchCriteriaId": "1B0A6C82-59E2-459E-98B4-D9AD8C64D76C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sequelizejs:sequelize:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.15.1", "matchCriteriaId": "18BEA0CA-8A41-4126-A913-1B6F8C7D930A"}]}]}], "references": [{"url": "https://github.com/sequelize/sequelize/commit/9bd0bc111b6f502223edf7e902680f7cc2ed541e", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SEQUELIZE-459751", "source": "nvd@nist.gov", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sequelize/sequelize/commit/9bd0bc111b6f502223edf7e902680f7cc2ed541e"}}