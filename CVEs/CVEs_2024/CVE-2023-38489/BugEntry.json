{"buggy_code": ["<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Cms\\Auth\\Challenge;\nuse Kirby\\Cms\\Auth\\Status;\nuse Kirby\\Data\\Data;\nuse Kirby\\Exception\\Exception;\nuse Kirby\\Exception\\InvalidArgumentException;\nuse Kirby\\Exception\\LogicException;\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Exception\\PermissionException;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Http\\Idn;\nuse Kirby\\Http\\Request\\Auth\\BasicAuth;\nuse Kirby\\Session\\Session;\nuse Kirby\\Toolkit\\A;\nuse SensitiveParameter;\nuse Throwable;\n\n/**\n * Authentication layer\n *\n * @package   Kirby Cms\n * @author    Bastian Allgeier <bastian@getkirby.com>\n * @link      https://getkirby.com\n * @copyright Bastian Allgeier\n * @license   https://getkirby.com/license\n */\nclass Auth\n{\n\t/**\n\t * Available auth challenge classes\n\t * from the core and plugins\n\t *\n\t * @var array\n\t */\n\tpublic static $challenges = [];\n\n\t/**\n\t * Currently impersonated user\n\t *\n\t * @var \\Kirby\\Cms\\User|null\n\t */\n\tprotected $impersonate;\n\n\t/**\n\t * Kirby instance\n\t *\n\t * @var \\Kirby\\Cms\\App\n\t */\n\tprotected $kirby;\n\n\t/**\n\t * Cache of the auth status object\n\t *\n\t * @var \\Kirby\\Cms\\Auth\\Status\n\t */\n\tprotected $status;\n\n\t/**\n\t * Instance of the currently logged in user or\n\t * `false` if the user was not yet determined\n\t *\n\t * @var \\Kirby\\Cms\\User|null|false\n\t */\n\tprotected $user = false;\n\n\t/**\n\t * Exception that was thrown while\n\t * determining the current user\n\t *\n\t * @var \\Throwable\n\t */\n\tprotected $userException;\n\n\t/**\n\t * @param \\Kirby\\Cms\\App $kirby\n\t * @codeCoverageIgnore\n\t */\n\tpublic function __construct(App $kirby)\n\t{\n\t\t$this->kirby = $kirby;\n\t}\n\n\t/**\n\t * Creates an authentication challenge\n\t * (one-time auth code)\n\t * @since 3.5.0\n\t *\n\t * @param string $email\n\t * @param bool $long If `true`, a long session will be created\n\t * @param string $mode Either 'login' or 'password-reset'\n\t * @return \\Kirby\\Cms\\Auth\\Status\n\t *\n\t * @throws \\Kirby\\Exception\\LogicException If there is no suitable authentication challenge (only in debug mode)\n\t * @throws \\Kirby\\Exception\\NotFoundException If the user does not exist (only in debug mode)\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit is exceeded\n\t */\n\tpublic function createChallenge(string $email, bool $long = false, string $mode = 'login')\n\t{\n\t\t$email = Idn::decodeEmail($email);\n\n\t\t$session = $this->kirby->session([\n\t\t\t'createMode' => 'cookie',\n\t\t\t'long'       => $long === true\n\t\t]);\n\n\t\t$timeout = $this->kirby->option('auth.challenge.timeout', 10 * 60);\n\n\t\t// catch every exception to hide them from attackers\n\t\t// unless auth debugging is enabled\n\t\ttry {\n\t\t\t$this->checkRateLimit($email);\n\n\t\t\t// rate-limit the number of challenges for DoS/DDoS protection\n\t\t\t$this->track($email, false);\n\n\t\t\t// try to find the provided user\n\t\t\t$user = $this->kirby->users()->find($email);\n\t\t\tif ($user === null) {\n\t\t\t\t$this->kirby->trigger('user.login:failed', compact('email'));\n\n\t\t\t\tthrow new NotFoundException([\n\t\t\t\t\t'key'  => 'user.notFound',\n\t\t\t\t\t'data' => [\n\t\t\t\t\t\t'name' => $email\n\t\t\t\t\t]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// try to find an enabled challenge that is available for that user\n\t\t\t$challenge = null;\n\t\t\tforeach ($this->enabledChallenges() as $name) {\n\t\t\t\t$class = static::$challenges[$name] ?? null;\n\t\t\t\tif (\n\t\t\t\t\t$class &&\n\t\t\t\t\tclass_exists($class) === true &&\n\t\t\t\t\tis_subclass_of($class, Challenge::class) === true &&\n\t\t\t\t\t$class::isAvailable($user, $mode) === true\n\t\t\t\t) {\n\t\t\t\t\t$challenge = $name;\n\t\t\t\t\t$code = $class::create($user, compact('mode', 'timeout'));\n\n\t\t\t\t\t$session->set('kirby.challenge.type', $challenge);\n\n\t\t\t\t\tif ($code !== null) {\n\t\t\t\t\t\t$session->set('kirby.challenge.code', password_hash($code, PASSWORD_DEFAULT));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if no suitable challenge was found, `$challenge === null` at this point\n\t\t\tif ($challenge === null) {\n\t\t\t\tthrow new LogicException('Could not find a suitable authentication challenge');\n\t\t\t}\n\t\t} catch (Throwable $e) {\n\t\t\t// only throw the exception in auth debug mode\n\t\t\t$this->fail($e);\n\t\t}\n\n\t\t// always set the email and timeout, even if the challenge\n\t\t// won't be created; this avoids leaking whether the user exists\n\t\t$session->set('kirby.challenge.email', $email);\n\t\t$session->set('kirby.challenge.timeout', time() + $timeout);\n\n\t\t// sleep for a random amount of milliseconds\n\t\t// to make automated attacks harder and to\n\t\t// avoid leaking whether the user exists\n\t\tusleep(random_int(50000, 300000));\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\n\t\treturn $this->status($session, false);\n\t}\n\n\t/**\n\t * Returns the csrf token if it exists and if it is valid\n\t *\n\t * @return string|false\n\t */\n\tpublic function csrf()\n\t{\n\t\t// get the csrf from the header\n\t\t$fromHeader = $this->kirby->request()->csrf();\n\n\t\t// check for a predefined csrf or use the one from session\n\t\t$fromSession = $this->csrfFromSession();\n\n\t\t// compare both tokens\n\t\tif (hash_equals((string)$fromSession, (string)$fromHeader) !== true) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $fromSession;\n\t}\n\n\t/**\n\t * Returns either predefined csrf or the one from session\n\t * @since 3.6.0\n\t *\n\t * @return string\n\t */\n\tpublic function csrfFromSession(): string\n\t{\n\t\t$isDev    = $this->kirby->option('panel.dev', false) !== false;\n\t\t$fallback = $isDev ? 'dev' : $this->kirby->csrf();\n\t\treturn $this->kirby->option('api.csrf', $fallback);\n\t}\n\n\t/**\n\t * Returns the logged in user by checking\n\t * for a basic authentication header with\n\t * valid credentials\n\t *\n\t * @param \\Kirby\\Http\\Request\\Auth\\BasicAuth|null $auth\n\t * @return \\Kirby\\Cms\\User|null\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException if the authorization header is invalid\n\t * @throws \\Kirby\\Exception\\PermissionException if basic authentication is not allowed\n\t */\n\tpublic function currentUserFromBasicAuth(BasicAuth $auth = null)\n\t{\n\t\tif ($this->kirby->option('api.basicAuth', false) !== true) {\n\t\t\tthrow new PermissionException('Basic authentication is not activated');\n\t\t}\n\n\t\t// if logging in with password is disabled, basic auth cannot be possible either\n\t\t$loginMethods = $this->kirby->system()->loginMethods();\n\t\tif (isset($loginMethods['password']) !== true) {\n\t\t\tthrow new PermissionException('Login with password is not enabled');\n\t\t}\n\n\t\t// if any login method requires 2FA, basic auth without 2FA would be a weakness\n\t\tforeach ($loginMethods as $method) {\n\t\t\tif (isset($method['2fa']) === true && $method['2fa'] === true) {\n\t\t\t\tthrow new PermissionException('Basic authentication cannot be used with 2FA');\n\t\t\t}\n\t\t}\n\n\t\t$request = $this->kirby->request();\n\t\t$auth    = $auth ?? $request->auth();\n\n\t\tif (!$auth || $auth->type() !== 'basic') {\n\t\t\tthrow new InvalidArgumentException('Invalid authorization header');\n\t\t}\n\n\t\t// only allow basic auth when https is enabled or insecure requests permitted\n\t\tif ($request->ssl() === false && $this->kirby->option('api.allowInsecure', false) !== true) {\n\t\t\tthrow new PermissionException('Basic authentication is only allowed over HTTPS');\n\t\t}\n\n\t\treturn $this->validatePassword($auth->username(), $auth->password());\n\t}\n\n\t/**\n\t * Returns the currently impersonated user\n\t *\n\t * @return \\Kirby\\Cms\\User|null\n\t */\n\tpublic function currentUserFromImpersonation()\n\t{\n\t\treturn $this->impersonate;\n\t}\n\n\t/**\n\t * Returns the logged in user by checking\n\t * the current session and finding a valid\n\t * valid user id in there\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @return \\Kirby\\Cms\\User|null\n\t */\n\tpublic function currentUserFromSession($session = null)\n\t{\n\t\t$session = $this->session($session);\n\n\t\t$id = $session->data()->get('kirby.userId');\n\n\t\tif (is_string($id) !== true) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ($user = $this->kirby->users()->find($id)) {\n\t\t\t// in case the session needs to be updated, do it now\n\t\t\t// for better performance\n\t\t\t$session->commit();\n\t\t\treturn $user;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the list of enabled challenges in the\n\t * configured order\n\t * @since 3.5.1\n\t *\n\t * @return array\n\t */\n\tpublic function enabledChallenges(): array\n\t{\n\t\treturn A::wrap($this->kirby->option('auth.challenges', ['email']));\n\t}\n\n\t/**\n\t * Become any existing user or disable the current user\n\t *\n\t * @param string|null $who User ID or email address,\n\t *                         `null` to use the actual user again,\n\t *                         `'kirby'` for a virtual admin user or\n\t *                         `'nobody'` to disable the actual user\n\t * @return \\Kirby\\Cms\\User|null\n\t * @throws \\Kirby\\Exception\\NotFoundException if the given user cannot be found\n\t */\n\tpublic function impersonate(string|null $who = null)\n\t{\n\t\t// clear the status cache\n\t\t$this->status = null;\n\n\t\treturn $this->impersonate = match ($who) {\n\t\t\tnull     => null,\n\t\t\t'kirby'  => new User([\n\t\t\t\t'email' => 'kirby@getkirby.com',\n\t\t\t\t'id'    => 'kirby',\n\t\t\t\t'role'  => 'admin',\n\t\t\t]),\n\t\t\t'nobody' => new User([\n\t\t\t\t'email' => 'nobody@getkirby.com',\n\t\t\t\t'id'    => 'nobody',\n\t\t\t\t'role'  => 'nobody',\n\t\t\t]),\n\t\t\tdefault  => ($this->kirby->users()->find($who) ?? throw new NotFoundException('The user \"' . $who . '\" cannot be found'))\n\t\t};\n\t}\n\n\t/**\n\t * Returns the hashed ip of the visitor\n\t * which is used to track invalid logins\n\t *\n\t * @return string\n\t */\n\tpublic function ipHash(): string\n\t{\n\t\t$hash = hash('sha256', $this->kirby->visitor()->ip());\n\n\t\t// only use the first 50 chars to ensure privacy\n\t\treturn substr($hash, 0, 50);\n\t}\n\n\t/**\n\t * Check if logins are blocked for the current ip or email\n\t *\n\t * @param string $email\n\t * @return bool\n\t */\n\tpublic function isBlocked(string $email): bool\n\t{\n\t\t$ip     = $this->ipHash();\n\t\t$log    = $this->log();\n\t\t$trials = $this->kirby->option('auth.trials', 10);\n\n\t\tif ($entry = ($log['by-ip'][$ip] ?? null)) {\n\t\t\tif ($entry['trials'] >= $trials) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif ($this->kirby->users()->find($email)) {\n\t\t\tif ($entry = ($log['by-email'][$email] ?? null)) {\n\t\t\t\tif ($entry['trials'] >= $trials) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Login a user by email and password\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the email was invalid\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the password is not valid (via `$user->login()`)\n\t */\n\tpublic function login(\n\t\tstring $email,\n\t\t#[SensitiveParameter]\n\t\tstring $password,\n\t\tbool $long = false\n\t): User {\n\t\t// session options\n\t\t$options = [\n\t\t\t'createMode' => 'cookie',\n\t\t\t'long'       => $long === true\n\t\t];\n\n\t\t// validate the user and log in to the session\n\t\t$user = $this->validatePassword($email, $password);\n\t\t$user->loginPasswordless($options);\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Login a user by email, password and auth challenge\n\t * @since 3.5.0\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the email was invalid\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the password is not valid (via `$user->login()`)\n\t */\n\tpublic function login2fa(\n\t\tstring $email,\n\t\t#[SensitiveParameter]\n\t\tstring $password,\n\t\tbool $long = false\n\t): Status {\n\t\t$this->validatePassword($email, $password);\n\t\treturn $this->createChallenge($email, $long, '2fa');\n\t}\n\n\t/**\n\t * Sets a user object as the current user in the cache\n\t * @internal\n\t *\n\t * @param \\Kirby\\Cms\\User $user\n\t * @return void\n\t */\n\tpublic function setUser(User $user): void\n\t{\n\t\t// stop impersonating\n\t\t$this->impersonate = null;\n\n\t\t$this->user = $user;\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\t}\n\n\t/**\n\t * Returns the authentication status object\n\t * @since 3.5.1\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @param bool $allowImpersonation If set to false, only the actually\n\t *                                 logged in user will be returned\n\t * @return \\Kirby\\Cms\\Auth\\Status\n\t */\n\tpublic function status($session = null, bool $allowImpersonation = true)\n\t{\n\t\t// try to return from cache\n\t\tif ($this->status && $session === null && $allowImpersonation === true) {\n\t\t\treturn $this->status;\n\t\t}\n\n\t\t$sessionObj = $this->session($session);\n\n\t\t$props = ['kirby' => $this->kirby];\n\t\tif ($user = $this->user($sessionObj, $allowImpersonation)) {\n\t\t\t// a user is currently logged in\n\t\t\tif ($allowImpersonation === true && $this->impersonate !== null) {\n\t\t\t\t$props['status'] = 'impersonated';\n\t\t\t} else {\n\t\t\t\t$props['status'] = 'active';\n\t\t\t}\n\n\t\t\t$props['email'] = $user->email();\n\t\t} elseif ($email = $sessionObj->get('kirby.challenge.email')) {\n\t\t\t// a challenge is currently pending\n\t\t\t$props['status']            = 'pending';\n\t\t\t$props['email']             = $email;\n\t\t\t$props['challenge']         = $sessionObj->get('kirby.challenge.type');\n\t\t\t$props['challengeFallback'] = A::last($this->enabledChallenges());\n\t\t} else {\n\t\t\t// no active authentication\n\t\t\t$props['status'] = 'inactive';\n\t\t}\n\n\t\t$status = new Status($props);\n\n\t\t// only cache the default object\n\t\tif ($session === null && $allowImpersonation === true) {\n\t\t\t$this->status = $status;\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Ensures that the rate limit was not exceeded\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded\n\t */\n\tprotected function checkRateLimit(string $email): void\n\t{\n\t\t// check for blocked ips\n\t\tif ($this->isBlocked($email) === true) {\n\t\t\t$this->kirby->trigger('user.login:failed', compact('email'));\n\n\t\t\tthrow new PermissionException([\n\t\t\t\t'details'  => ['reason' => 'rate-limited'],\n\t\t\t\t'fallback' => 'Rate limit exceeded'\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * Validates the user credentials and returns the user object on success;\n\t * otherwise logs the failed attempt\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the email was invalid\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the password is not valid (via `$user->login()`)\n\t */\n\tpublic function validatePassword(\n\t\tstring $email,\n\t\t#[SensitiveParameter]\n\t\tstring $password\n\t): User {\n\t\t$email = Idn::decodeEmail($email);\n\n\t\ttry {\n\t\t\t$this->checkRateLimit($email);\n\n\t\t\t// validate the user and its password\n\t\t\tif ($user = $this->kirby->users()->find($email)) {\n\t\t\t\tif ($user->validatePassword($password) === true) {\n\t\t\t\t\treturn $user;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new NotFoundException([\n\t\t\t\t'key'  => 'user.notFound',\n\t\t\t\t'data' => [\n\t\t\t\t\t'name' => $email\n\t\t\t\t]\n\t\t\t]);\n\t\t} catch (Throwable $e) {\n\t\t\t$details = $e instanceof Exception ? $e->getDetails() : [];\n\n\t\t\t// log invalid login trial unless the rate limit is already active\n\t\t\tif (($details['reason'] ?? null) !== 'rate-limited') {\n\t\t\t\ttry {\n\t\t\t\t\t$this->track($email);\n\t\t\t\t} catch (Throwable $e) {\n\t\t\t\t\t// $e is overwritten with the exception\n\t\t\t\t\t// from the track method if there's one\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// sleep for a random amount of milliseconds\n\t\t\t// to make automated attacks harder\n\t\t\tusleep(random_int(10000, 2000000));\n\n\t\t\t// keep throwing the original error in debug mode,\n\t\t\t// otherwise hide it to avoid leaking security-relevant information\n\t\t\t$this->fail($e, new PermissionException(['key' => 'access.login']));\n\t\t}\n\t}\n\n\t/**\n\t * Returns the absolute path to the logins log\n\t *\n\t * @return string\n\t */\n\tpublic function logfile(): string\n\t{\n\t\treturn $this->kirby->root('accounts') . '/.logins';\n\t}\n\n\t/**\n\t * Read all tracked logins\n\t *\n\t * @return array\n\t */\n\tpublic function log(): array\n\t{\n\t\ttry {\n\t\t\t$log  = Data::read($this->logfile(), 'json');\n\t\t\t$read = true;\n\t\t} catch (Throwable) {\n\t\t\t$log  = [];\n\t\t\t$read = false;\n\t\t}\n\n\t\t// ensure that the category arrays are defined\n\t\t$log['by-ip']    = $log['by-ip'] ?? [];\n\t\t$log['by-email'] = $log['by-email'] ?? [];\n\n\t\t// remove all elements on the top level with different keys (old structure)\n\t\t$log = array_intersect_key($log, array_flip(['by-ip', 'by-email']));\n\n\t\t// remove entries that are no longer needed\n\t\t$originalLog = $log;\n\t\t$time = time() - $this->kirby->option('auth.timeout', 3600);\n\t\tforeach ($log as $category => $entries) {\n\t\t\t$log[$category] = array_filter(\n\t\t\t\t$entries,\n\t\t\t\tfn ($entry) => $entry['time'] > $time\n\t\t\t);\n\t\t}\n\n\t\t// write new log to the file system if it changed\n\t\tif ($read === false || $log !== $originalLog) {\n\t\t\tif (count($log['by-ip']) === 0 && count($log['by-email']) === 0) {\n\t\t\t\tF::remove($this->logfile());\n\t\t\t} else {\n\t\t\t\tData::write($this->logfile(), $log, 'json');\n\t\t\t}\n\t\t}\n\n\t\treturn $log;\n\t}\n\n\t/**\n\t * Logout the current user\n\t *\n\t * @return void\n\t */\n\tpublic function logout(): void\n\t{\n\t\t// stop impersonating;\n\t\t// ensures that we log out the actually logged in user\n\t\t$this->impersonate = null;\n\n\t\t// logout the current user if it exists\n\t\t$this->user()?->logout();\n\n\t\t// clear the pending challenge\n\t\t$session = $this->kirby->session();\n\t\t$session->remove('kirby.challenge.code');\n\t\t$session->remove('kirby.challenge.email');\n\t\t$session->remove('kirby.challenge.timeout');\n\t\t$session->remove('kirby.challenge.type');\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\t}\n\n\t/**\n\t * Clears the cached user data after logout\n\t * @internal\n\t *\n\t * @return void\n\t */\n\tpublic function flush(): void\n\t{\n\t\t$this->impersonate = null;\n\t\t$this->status = null;\n\t\t$this->user = null;\n\t}\n\n\t/**\n\t * Tracks a login\n\t *\n\t * @param string|null $email\n\t * @param bool $triggerHook If `false`, no user.login:failed hook is triggered\n\t * @return bool\n\t */\n\tpublic function track(string|null $email, bool $triggerHook = true): bool\n\t{\n\t\tif ($triggerHook === true) {\n\t\t\t$this->kirby->trigger('user.login:failed', compact('email'));\n\t\t}\n\n\t\t$ip   = $this->ipHash();\n\t\t$log  = $this->log();\n\t\t$time = time();\n\n\t\tif (isset($log['by-ip'][$ip]) === true) {\n\t\t\t$log['by-ip'][$ip] = [\n\t\t\t\t'time'   => $time,\n\t\t\t\t'trials' => ($log['by-ip'][$ip]['trials'] ?? 0) + 1\n\t\t\t];\n\t\t} else {\n\t\t\t$log['by-ip'][$ip] = [\n\t\t\t\t'time'   => $time,\n\t\t\t\t'trials' => 1\n\t\t\t];\n\t\t}\n\n\t\tif ($email !== null && $this->kirby->users()->find($email)) {\n\t\t\tif (isset($log['by-email'][$email]) === true) {\n\t\t\t\t$log['by-email'][$email] = [\n\t\t\t\t\t'time'   => $time,\n\t\t\t\t\t'trials' => ($log['by-email'][$email]['trials'] ?? 0) + 1\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$log['by-email'][$email] = [\n\t\t\t\t\t'time'   => $time,\n\t\t\t\t\t'trials' => 1\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn Data::write($this->logfile(), $log, 'json');\n\t}\n\n\t/**\n\t * Returns the current authentication type\n\t *\n\t * @param bool $allowImpersonation If set to false, 'impersonate' won't\n\t *                                 be returned as authentication type\n\t *                                 even if an impersonation is active\n\t * @return string\n\t */\n\tpublic function type(bool $allowImpersonation = true): string\n\t{\n\t\t$basicAuth = $this->kirby->option('api.basicAuth', false);\n\t\t$request   = $this->kirby->request();\n\n\t\tif (\n\t\t\t$basicAuth === true &&\n\n\t\t\t// only get the auth object if the option is enabled\n\t\t\t// to avoid triggering `$responder->usesAuth()` if\n\t\t\t// the option is disabled\n\t\t\t$request->auth() &&\n\t\t\t$request->auth()->type() === 'basic'\n\t\t) {\n\t\t\treturn 'basic';\n\t\t}\n\n\t\tif ($allowImpersonation === true && $this->impersonate !== null) {\n\t\t\treturn 'impersonate';\n\t\t}\n\n\t\treturn 'session';\n\t}\n\n\t/**\n\t * Validates the currently logged in user\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @param bool $allowImpersonation If set to false, only the actually\n\t *                                 logged in user will be returned\n\t * @return \\Kirby\\Cms\\User|null\n\t *\n\t * @throws \\Throwable If an authentication error occurred\n\t */\n\tpublic function user($session = null, bool $allowImpersonation = true)\n\t{\n\t\tif ($allowImpersonation === true && $this->impersonate !== null) {\n\t\t\treturn $this->impersonate;\n\t\t}\n\n\t\t// return from cache\n\t\tif ($this->user === null) {\n\t\t\t// throw the same Exception again if one was captured before\n\t\t\tif ($this->userException !== null) {\n\t\t\t\tthrow $this->userException;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif ($this->user !== false) {\n\t\t\treturn $this->user;\n\t\t}\n\n\t\ttry {\n\t\t\tif ($this->type() === 'basic') {\n\t\t\t\treturn $this->user = $this->currentUserFromBasicAuth();\n\t\t\t}\n\n\t\t\treturn $this->user = $this->currentUserFromSession($session);\n\t\t} catch (Throwable $e) {\n\t\t\t$this->user = null;\n\n\t\t\t// capture the Exception for future calls\n\t\t\t$this->userException = $e;\n\n\t\t\tthrow $e;\n\t\t}\n\t}\n\n\t/**\n\t * Verifies an authentication code that was\n\t * requested with the `createChallenge()` method;\n\t * if successful, the user is automatically logged in\n\t * @since 3.5.0\n\t *\n\t * @param string $code User-provided auth code to verify\n\t * @return \\Kirby\\Cms\\User User object of the logged-in user\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded, the challenge timed out, the code\n\t *                                              is incorrect or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the user from the challenge doesn't exist\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If no authentication challenge is active\n\t * @throws \\Kirby\\Exception\\LogicException If the authentication challenge is invalid\n\t */\n\tpublic function verifyChallenge(\n\t\t#[SensitiveParameter]\n\t\tstring $code\n\t) {\n\t\ttry {\n\t\t\t$session = $this->kirby->session();\n\n\t\t\t// time-limiting; check this early so that we can destroy the session no\n\t\t\t// matter if the user exists (avoids leaking user information to attackers)\n\t\t\t$timeout = $session->get('kirby.challenge.timeout');\n\t\t\tif ($timeout !== null && time() > $timeout) {\n\t\t\t\t// this challenge can never be completed,\n\t\t\t\t// so delete it immediately\n\t\t\t\t$this->logout();\n\n\t\t\t\tthrow new PermissionException([\n\t\t\t\t\t'details'  => ['challengeDestroyed' => true],\n\t\t\t\t\t'fallback' => 'Authentication challenge timeout'\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// check if we have an active challenge\n\t\t\t$email     = $session->get('kirby.challenge.email');\n\t\t\t$challenge = $session->get('kirby.challenge.type');\n\t\t\tif (is_string($email) !== true || is_string($challenge) !== true) {\n\t\t\t\t// if the challenge timed out on the previous request, the\n\t\t\t\t// challenge data was already deleted from the session, so we can\n\t\t\t\t// set `challengeDestroyed` to `true` in this response as well;\n\t\t\t\t// however we must only base this on the email, not the type\n\t\t\t\t// (otherwise \"faked\" challenges would be leaked)\n\t\t\t\t$challengeDestroyed = is_string($email) !== true;\n\n\t\t\t\tthrow new InvalidArgumentException([\n\t\t\t\t\t'details'  => compact('challengeDestroyed'),\n\t\t\t\t\t'fallback' => 'No authentication challenge is active'\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t$user = $this->kirby->users()->find($email);\n\t\t\tif ($user === null) {\n\t\t\t\tthrow new NotFoundException([\n\t\t\t\t\t'key'  => 'user.notFound',\n\t\t\t\t\t'data' => [\n\t\t\t\t\t\t'name' => $email\n\t\t\t\t\t]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// rate-limiting\n\t\t\t$this->checkRateLimit($email);\n\n\t\t\tif (\n\t\t\t\tisset(static::$challenges[$challenge]) === true &&\n\t\t\t\tclass_exists(static::$challenges[$challenge]) === true &&\n\t\t\t\tis_subclass_of(static::$challenges[$challenge], Challenge::class) === true\n\t\t\t) {\n\t\t\t\t$class = static::$challenges[$challenge];\n\t\t\t\tif ($class::verify($user, $code) === true) {\n\t\t\t\t\t$this->logout();\n\t\t\t\t\t$user->loginPasswordless();\n\n\t\t\t\t\t// clear the status cache\n\t\t\t\t\t$this->status = null;\n\n\t\t\t\t\treturn $user;\n\t\t\t\t}\n\n\t\t\t\tthrow new PermissionException(['key' => 'access.code']);\n\t\t\t}\n\n\t\t\tthrow new LogicException('Invalid authentication challenge: ' . $challenge);\n\t\t} catch (Throwable $e) {\n\t\t\t$details = $e instanceof \\Kirby\\Exception\\Exception ? $e->getDetails() : [];\n\n\t\t\tif (\n\t\t\t\tempty($email) === false &&\n\t\t\t\t($details['reason'] ?? null) !== 'rate-limited'\n\t\t\t) {\n\t\t\t\t$this->track($email);\n\t\t\t}\n\n\t\t\t// sleep for a random amount of milliseconds\n\t\t\t// to make automated attacks harder and to\n\t\t\t// avoid leaking whether the user exists\n\t\t\tusleep(random_int(10000, 2000000));\n\n\t\t\t// specifically copy over the marker for a destroyed challenge\n\t\t\t// even in production (used by the Panel to reset to the login form)\n\t\t\t$challengeDestroyed = $details['challengeDestroyed'] ?? false;\n\n\t\t\t$fallback = new PermissionException([\n\t\t\t\t'details' => compact('challengeDestroyed'),\n\t\t\t\t'key'     => 'access.code'\n\t\t\t]);\n\n\t\t\t// keep throwing the original error in debug mode,\n\t\t\t// otherwise hide it to avoid leaking security-relevant information\n\t\t\t$this->fail($e, $fallback);\n\t\t}\n\t}\n\n\t/**\n\t * Throws an exception only in debug mode, otherwise falls back\n\t * to a public error without sensitive information\n\t *\n\t * @throws \\Throwable Either the passed `$exception` or the `$fallback`\n\t *                    (no exception if debugging is disabled and no fallback was passed)\n\t */\n\tprotected function fail(Throwable $exception, Throwable $fallback = null): void\n\t{\n\t\t$debug = $this->kirby->option('auth.debug', 'log');\n\n\t\t// throw the original exception only in debug mode\n\t\tif ($debug === true) {\n\t\t\tthrow $exception;\n\t\t}\n\n\t\t// otherwise hide the real error and only print it to the error log\n\t\t// unless disabled by setting `auth.debug` to `false`\n\t\tif ($debug === 'log') {\n\t\t\terror_log($exception); // @codeCoverageIgnore\n\t\t}\n\n\t\t// only throw an error in production if requested by the calling method\n\t\tif ($fallback !== null) {\n\t\t\tthrow $fallback;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a session object from the passed options\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @return \\Kirby\\Session\\Session\n\t */\n\tprotected function session($session = null)\n\t{\n\t\t// use passed session options or session object if set\n\t\tif (is_array($session) === true) {\n\t\t\treturn $this->kirby->session($session);\n\t\t}\n\n\t\t// try session in header or cookie\n\t\tif ($session instanceof Session === false) {\n\t\t\treturn $this->kirby->session(['detect' => true]);\n\t\t}\n\n\t\treturn $session;\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Exception;\nuse Kirby\\Exception\\InvalidArgumentException;\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Panel\\User as Panel;\nuse Kirby\\Session\\Session;\nuse Kirby\\Toolkit\\Str;\nuse SensitiveParameter;\n\n/**\n * The `$user` object represents a\n * single Panel or frontend user.\n *\n * @package   Kirby Cms\n * @author    Bastian Allgeier <bastian@getkirby.com>\n * @link      https://getkirby.com\n * @copyright Bastian Allgeier\n * @license   https://getkirby.com/license\n */\nclass User extends ModelWithContent\n{\n\tuse HasFiles;\n\tuse HasMethods;\n\tuse HasSiblings;\n\tuse UserActions;\n\n\tpublic const CLASS_ALIAS = 'user';\n\n\t/**\n\t * @var UserBlueprint\n\t */\n\tprotected $blueprint;\n\n\t/**\n\t * @var array\n\t */\n\tprotected $credentials;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $email;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $hash;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $id;\n\n\t/**\n\t * @var array|null\n\t */\n\tprotected $inventory;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $language;\n\n\t/**\n\t * All registered user methods\n\t *\n\t * @var array\n\t */\n\tpublic static $methods = [];\n\n\t/**\n\t * Registry with all User models\n\t *\n\t * @var array\n\t */\n\tpublic static $models = [];\n\n\t/**\n\t * @var \\Kirby\\Cms\\Field\n\t */\n\tprotected $name;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $password;\n\n\t/**\n\t * The user role\n\t *\n\t * @var string\n\t */\n\tprotected $role;\n\n\t/**\n\t * Modified getter to also return fields\n\t * from the content\n\t *\n\t * @param string $method\n\t * @param array $arguments\n\t * @return mixed\n\t */\n\tpublic function __call(string $method, array $arguments = [])\n\t{\n\t\t// public property access\n\t\tif (isset($this->$method) === true) {\n\t\t\treturn $this->$method;\n\t\t}\n\n\t\t// user methods\n\t\tif ($this->hasMethod($method)) {\n\t\t\treturn $this->callMethod($method, $arguments);\n\t\t}\n\n\t\t// return site content otherwise\n\t\treturn $this->content()->get($method);\n\t}\n\n\t/**\n\t * Creates a new User object\n\t *\n\t * @param array $props\n\t */\n\tpublic function __construct(array $props)\n\t{\n\t\t// TODO: refactor later to avoid redundant prop setting\n\t\t$this->setProperty('id', $props['id'] ?? $this->createId(), true);\n\t\t$this->setProperties($props);\n\t}\n\n\t/**\n\t * Improved `var_dump` output\n\t *\n\t * @return array\n\t */\n\tpublic function __debugInfo(): array\n\t{\n\t\treturn array_merge($this->toArray(), [\n\t\t\t'avatar'  => $this->avatar(),\n\t\t\t'content' => $this->content(),\n\t\t\t'role'    => $this->role()\n\t\t]);\n\t}\n\n\t/**\n\t * Returns the url to the api endpoint\n\t *\n\t * @internal\n\t * @param bool $relative\n\t * @return string\n\t */\n\tpublic function apiUrl(bool $relative = false): string\n\t{\n\t\tif ($relative === true) {\n\t\t\treturn 'users/' . $this->id();\n\t\t}\n\n\t\treturn $this->kirby()->url('api') . '/users/' . $this->id();\n\t}\n\n\t/**\n\t * Returns the File object for the avatar or null\n\t *\n\t * @return \\Kirby\\Cms\\File|null\n\t */\n\tpublic function avatar()\n\t{\n\t\treturn $this->files()->template('avatar')->first();\n\t}\n\n\t/**\n\t * Returns the UserBlueprint object\n\t *\n\t * @return \\Kirby\\Cms\\Blueprint\n\t */\n\tpublic function blueprint()\n\t{\n\t\tif ($this->blueprint instanceof Blueprint) {\n\t\t\treturn $this->blueprint;\n\t\t}\n\n\t\ttry {\n\t\t\treturn $this->blueprint = UserBlueprint::factory('users/' . $this->role(), 'users/default', $this);\n\t\t} catch (Exception) {\n\t\t\treturn $this->blueprint = new UserBlueprint([\n\t\t\t\t'model' => $this,\n\t\t\t\t'name'  => 'default',\n\t\t\t\t'title' => 'Default',\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * Prepares the content for the write method\n\t *\n\t * @internal\n\t * @param array $data\n\t * @param string $languageCode|null Not used so far\n\t * @return array\n\t */\n\tpublic function contentFileData(array $data, string $languageCode = null): array\n\t{\n\t\t// remove stuff that has nothing to do in the text files\n\t\tunset(\n\t\t\t$data['email'],\n\t\t\t$data['language'],\n\t\t\t$data['name'],\n\t\t\t$data['password'],\n\t\t\t$data['role']\n\t\t);\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Filename for the content file\n\t *\n\t * @internal\n\t * @return string\n\t */\n\tpublic function contentFileName(): string\n\t{\n\t\treturn 'user';\n\t}\n\n\tprotected function credentials(): array\n\t{\n\t\treturn $this->credentials ??= $this->readCredentials();\n\t}\n\n\t/**\n\t * Returns the user email address\n\t *\n\t * @return string\n\t */\n\tpublic function email(): string|null\n\t{\n\t\treturn $this->email ??= $this->credentials()['email'] ?? null;\n\t}\n\n\t/**\n\t * Checks if the user exists\n\t *\n\t * @return bool\n\t */\n\tpublic function exists(): bool\n\t{\n\t\treturn is_file($this->contentFile('default')) === true;\n\t}\n\n\t/**\n\t * Constructs a User object and also\n\t * takes User models into account.\n\t *\n\t * @internal\n\t * @param mixed $props\n\t * @return static\n\t */\n\tpublic static function factory($props)\n\t{\n\t\tif (empty($props['model']) === false) {\n\t\t\treturn static::model($props['model'], $props);\n\t\t}\n\n\t\treturn new static($props);\n\t}\n\n\t/**\n\t * Hashes the user's password unless it is `null`,\n\t * which will leave it as `null`\n\t *\n\t * @internal\n\t */\n\tpublic static function hashPassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): string|null {\n\t\tif ($password !== null) {\n\t\t\t$password = password_hash($password, PASSWORD_DEFAULT);\n\t\t}\n\n\t\treturn $password;\n\t}\n\n\t/**\n\t * Returns the user id\n\t *\n\t * @return string\n\t */\n\tpublic function id(): string\n\t{\n\t\treturn $this->id;\n\t}\n\n\t/**\n\t * Returns the inventory of files\n\t * children and content files\n\t *\n\t * @return array\n\t */\n\tpublic function inventory(): array\n\t{\n\t\tif ($this->inventory !== null) {\n\t\t\treturn $this->inventory;\n\t\t}\n\n\t\t$kirby = $this->kirby();\n\n\t\treturn $this->inventory = Dir::inventory(\n\t\t\t$this->root(),\n\t\t\t$kirby->contentExtension(),\n\t\t\t$kirby->contentIgnore(),\n\t\t\t$kirby->multilang()\n\t\t);\n\t}\n\n\t/**\n\t * Compares the current object with the given user object\n\t *\n\t * @param \\Kirby\\Cms\\User|null $user\n\t * @return bool\n\t */\n\tpublic function is(User $user = null): bool\n\t{\n\t\tif ($user === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $this->id() === $user->id();\n\t}\n\n\t/**\n\t * Checks if this user has the admin role\n\t *\n\t * @return bool\n\t */\n\tpublic function isAdmin(): bool\n\t{\n\t\treturn $this->role()->id() === 'admin';\n\t}\n\n\t/**\n\t * Checks if the current user is the virtual\n\t * Kirby user\n\t *\n\t * @return bool\n\t */\n\tpublic function isKirby(): bool\n\t{\n\t\treturn $this->email() === 'kirby@getkirby.com';\n\t}\n\n\t/**\n\t * Checks if the current user is this user\n\t *\n\t * @return bool\n\t */\n\tpublic function isLoggedIn(): bool\n\t{\n\t\treturn $this->is($this->kirby()->user());\n\t}\n\n\t/**\n\t * Checks if the user is the last one\n\t * with the admin role\n\t *\n\t * @return bool\n\t */\n\tpublic function isLastAdmin(): bool\n\t{\n\t\treturn\n\t\t\t$this->role()->isAdmin() === true &&\n\t\t\t$this->kirby()->users()->filter('role', 'admin')->count() <= 1;\n\t}\n\n\t/**\n\t * Checks if the user is the last user\n\t *\n\t * @return bool\n\t */\n\tpublic function isLastUser(): bool\n\t{\n\t\treturn $this->kirby()->users()->count() === 1;\n\t}\n\n\t/**\n\t * Checks if the current user is the virtual\n\t * Nobody user\n\t *\n\t * @return bool\n\t */\n\tpublic function isNobody(): bool\n\t{\n\t\treturn $this->email() === 'nobody@getkirby.com';\n\t}\n\n\t/**\n\t * Returns the user language\n\t *\n\t * @return string\n\t */\n\tpublic function language(): string\n\t{\n\t\treturn $this->language ??= $this->credentials()['language'] ?? $this->kirby()->panelLanguage();\n\t}\n\n\t/**\n\t * Logs the user in\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session Session options or session object to set the user in\n\t */\n\tpublic function login(\n\t\t#[SensitiveParameter]\n\t\tstring $password,\n\t\t$session = null\n\t): bool {\n\t\t$this->validatePassword($password);\n\t\t$this->loginPasswordless($session);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Logs the user in without checking the password\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session Session options or session object to set the user in\n\t * @return void\n\t */\n\tpublic function loginPasswordless($session = null): void\n\t{\n\t\t$kirby = $this->kirby();\n\n\t\t$session = $this->sessionFromOptions($session);\n\n\t\t$kirby->trigger('user.login:before', ['user' => $this, 'session' => $session]);\n\n\t\t$session->regenerateToken(); // privilege change\n\t\t$session->data()->set('kirby.userId', $this->id());\n\t\t$this->kirby()->auth()->setUser($this);\n\n\t\t$kirby->trigger('user.login:after', ['user' => $this, 'session' => $session]);\n\t}\n\n\t/**\n\t * Logs the user out\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session Session options or session object to unset the user in\n\t * @return void\n\t */\n\tpublic function logout($session = null): void\n\t{\n\t\t$kirby   = $this->kirby();\n\t\t$session = $this->sessionFromOptions($session);\n\n\t\t$kirby->trigger('user.logout:before', ['user' => $this, 'session' => $session]);\n\n\t\t// remove the user from the session for future requests\n\t\t$session->data()->remove('kirby.userId');\n\n\t\t// clear the cached user object from the app state of the current request\n\t\t$this->kirby()->auth()->flush();\n\n\t\tif ($session->data()->get() === []) {\n\t\t\t// session is now empty, we might as well destroy it\n\t\t\t$session->destroy();\n\n\t\t\t$kirby->trigger('user.logout:after', ['user' => $this, 'session' => null]);\n\t\t} else {\n\t\t\t// privilege change\n\t\t\t$session->regenerateToken();\n\n\t\t\t$kirby->trigger('user.logout:after', ['user' => $this, 'session' => $session]);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the root to the media folder for the user\n\t *\n\t * @internal\n\t * @return string\n\t */\n\tpublic function mediaRoot(): string\n\t{\n\t\treturn $this->kirby()->root('media') . '/users/' . $this->id();\n\t}\n\n\t/**\n\t * Returns the media url for the user object\n\t *\n\t * @internal\n\t * @return string\n\t */\n\tpublic function mediaUrl(): string\n\t{\n\t\treturn $this->kirby()->url('media') . '/users/' . $this->id();\n\t}\n\n\t/**\n\t * Creates a user model if it has been registered\n\t *\n\t * @internal\n\t * @param string $name\n\t * @param array $props\n\t * @return \\Kirby\\Cms\\User\n\t */\n\tpublic static function model(string $name, array $props = [])\n\t{\n\t\tif ($class = (static::$models[$name] ?? null)) {\n\t\t\t$object = new $class($props);\n\n\t\t\tif ($object instanceof self) {\n\t\t\t\treturn $object;\n\t\t\t}\n\t\t}\n\n\t\treturn new static($props);\n\t}\n\n\t/**\n\t * Returns the last modification date of the user\n\t *\n\t * @param string $format\n\t * @param string|null $handler\n\t * @param string|null $languageCode\n\t * @return int|string\n\t */\n\tpublic function modified(string $format = 'U', string $handler = null, string $languageCode = null)\n\t{\n\t\t$modifiedContent = F::modified($this->contentFile($languageCode));\n\t\t$modifiedIndex   = F::modified($this->root() . '/index.php');\n\t\t$modifiedTotal   = max([$modifiedContent, $modifiedIndex]);\n\t\t$handler       ??= $this->kirby()->option('date.handler', 'date');\n\n\t\treturn Str::date($modifiedTotal, $format, $handler);\n\t}\n\n\t/**\n\t * Returns the user's name\n\t *\n\t * @return \\Kirby\\Cms\\Field\n\t */\n\tpublic function name()\n\t{\n\t\tif (is_string($this->name) === true) {\n\t\t\treturn new Field($this, 'name', $this->name);\n\t\t}\n\n\t\tif ($this->name !== null) {\n\t\t\treturn $this->name;\n\t\t}\n\n\t\treturn $this->name = new Field($this, 'name', $this->credentials()['name'] ?? null);\n\t}\n\n\t/**\n\t * Returns the user's name or,\n\t * if empty, the email address\n\t *\n\t * @return \\Kirby\\Cms\\Field\n\t */\n\tpublic function nameOrEmail()\n\t{\n\t\t$name = $this->name();\n\t\treturn $name->isNotEmpty() ? $name : new Field($this, 'email', $this->email());\n\t}\n\n\t/**\n\t * Create a dummy nobody\n\t *\n\t * @internal\n\t * @return static\n\t */\n\tpublic static function nobody()\n\t{\n\t\treturn new static([\n\t\t\t'email' => 'nobody@getkirby.com',\n\t\t\t'role'  => 'nobody'\n\t\t]);\n\t}\n\n\t/**\n\t * Returns the panel info object\n\t *\n\t * @return \\Kirby\\Panel\\User\n\t */\n\tpublic function panel()\n\t{\n\t\treturn new Panel($this);\n\t}\n\n\t/**\n\t * Returns the encrypted user password\n\t *\n\t * @return string|null\n\t */\n\tpublic function password(): string|null\n\t{\n\t\tif ($this->password !== null) {\n\t\t\treturn $this->password;\n\t\t}\n\n\t\treturn $this->password = $this->readPassword();\n\t}\n\n\t/**\n\t * @return \\Kirby\\Cms\\UserPermissions\n\t */\n\tpublic function permissions()\n\t{\n\t\treturn new UserPermissions($this);\n\t}\n\n\t/**\n\t * Returns the user role\n\t *\n\t * @return \\Kirby\\Cms\\Role\n\t */\n\tpublic function role()\n\t{\n\t\tif ($this->role instanceof Role) {\n\t\t\treturn $this->role;\n\t\t}\n\n\t\t$name = $this->role ?? $this->credentials()['role'] ?? 'visitor';\n\n\t\treturn $this->role = $this->kirby()->roles()->find($name) ?? Role::nobody();\n\t}\n\n\t/**\n\t * Returns all available roles\n\t * for this user, that can be selected\n\t * by the authenticated user\n\t *\n\t * @return \\Kirby\\Cms\\Roles\n\t */\n\tpublic function roles()\n\t{\n\t\t$kirby = $this->kirby();\n\t\t$roles = $kirby->roles();\n\n\t\t// a collection with just the one role of the user\n\t\t$myRole = $roles->filter('id', $this->role()->id());\n\n\t\t// if there's an authenticated user \u2026\n\t\t// admin users can select pretty much any role\n\t\tif ($kirby->user()?->isAdmin() === true) {\n\t\t\t// except if the user is the last admin\n\t\t\tif ($this->isLastAdmin() === true) {\n\t\t\t\t// in which case they have to stay admin\n\t\t\t\treturn $myRole;\n\t\t\t}\n\n\t\t\t// return all roles for mighty admins\n\t\t\treturn $roles;\n\t\t}\n\n\t\t// any other user can only keep their role\n\t\treturn $myRole;\n\t}\n\n\t/**\n\t * The absolute path to the user directory\n\t *\n\t * @return string\n\t */\n\tpublic function root(): string\n\t{\n\t\treturn $this->kirby()->root('accounts') . '/' . $this->id();\n\t}\n\n\t/**\n\t * Returns the UserRules class to\n\t * validate any important action.\n\t *\n\t * @return \\Kirby\\Cms\\UserRules\n\t */\n\tprotected function rules()\n\t{\n\t\treturn new UserRules();\n\t}\n\n\t/**\n\t * Sets the Blueprint object\n\t *\n\t * @param array|null $blueprint\n\t * @return $this\n\t */\n\tprotected function setBlueprint(array $blueprint = null)\n\t{\n\t\tif ($blueprint !== null) {\n\t\t\t$blueprint['model'] = $this;\n\t\t\t$this->blueprint = new UserBlueprint($blueprint);\n\t\t}\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user email\n\t *\n\t * @param string $email|null\n\t * @return $this\n\t */\n\tprotected function setEmail(string $email = null)\n\t{\n\t\tif ($email !== null) {\n\t\t\t$this->email = Str::lower(trim($email));\n\t\t}\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user id\n\t *\n\t * @param string $id|null\n\t * @return $this\n\t */\n\tprotected function setId(string $id = null)\n\t{\n\t\t$this->id = $id;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user language\n\t *\n\t * @param string $language|null\n\t * @return $this\n\t */\n\tprotected function setLanguage(string $language = null)\n\t{\n\t\t$this->language = $language !== null ? trim($language) : null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user name\n\t *\n\t * @param string $name|null\n\t * @return $this\n\t */\n\tprotected function setName(string $name = null)\n\t{\n\t\t$this->name = $name !== null ? trim(strip_tags($name)) : null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user's password hash\n\t *\n\t * @return $this\n\t */\n\tprotected function setPassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): static {\n\t\t$this->password = $password;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user role\n\t *\n\t * @param string $role|null\n\t * @return $this\n\t */\n\tprotected function setRole(string $role = null)\n\t{\n\t\t$this->role = $role !== null ? Str::lower(trim($role)) : null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Converts session options into a session object\n\t *\n\t * @param \\Kirby\\Session\\Session|array $session Session options or session object to unset the user in\n\t * @return \\Kirby\\Session\\Session\n\t */\n\tprotected function sessionFromOptions($session)\n\t{\n\t\t// use passed session options or session object if set\n\t\tif (is_array($session) === true) {\n\t\t\t$session = $this->kirby()->session($session);\n\t\t} elseif ($session instanceof Session === false) {\n\t\t\t$session = $this->kirby()->session(['detect' => true]);\n\t\t}\n\n\t\treturn $session;\n\t}\n\n\t/**\n\t * Returns the parent Users collection\n\t *\n\t * @return \\Kirby\\Cms\\Users\n\t */\n\tprotected function siblingsCollection()\n\t{\n\t\treturn $this->kirby()->users();\n\t}\n\n\t/**\n\t * Converts the most important user properties\n\t * to an array\n\t *\n\t * @return array\n\t */\n\tpublic function toArray(): array\n\t{\n\t\treturn [\n\t\t\t'avatar'   => $this->avatar() ? $this->avatar()->toArray() : null,\n\t\t\t'content'  => $this->content()->toArray(),\n\t\t\t'email'    => $this->email(),\n\t\t\t'id'       => $this->id(),\n\t\t\t'language' => $this->language(),\n\t\t\t'role'     => $this->role()->name(),\n\t\t\t'username' => $this->username()\n\t\t];\n\t}\n\n\t/**\n\t * String template builder\n\t *\n\t * @param string|null $template\n\t * @param array|null $data\n\t * @param string|null $fallback Fallback for tokens in the template that cannot be replaced\n\t *                              (`null` to keep the original token)\n\t * @return string\n\t */\n\tpublic function toString(string $template = null, array $data = [], string|null $fallback = '', string $handler = 'template'): string\n\t{\n\t\t$template ??= $this->email();\n\t\treturn parent::toString($template, $data, $fallback, $handler);\n\t}\n\n\t/**\n\t * Returns the username\n\t * which is the given name or the email\n\t * as a fallback\n\t *\n\t * @return string|null\n\t */\n\tpublic function username(): string|null\n\t{\n\t\treturn $this->name()->or($this->email())->value();\n\t}\n\n\t/**\n\t * Compares the given password with the stored one\n\t *\n\t * @throws \\Kirby\\Exception\\NotFoundException If the user has no password\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the entered password is not valid\n\t *                                                   or does not match the user password\n\t */\n\tpublic function validatePassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): bool {\n\t\tif (empty($this->password()) === true) {\n\t\t\tthrow new NotFoundException(['key' => 'user.password.undefined']);\n\t\t}\n\n\t\t// `UserRules` enforces a minimum length of 8 characters,\n\t\t// so everything below that is a typo\n\t\tif (Str::length($password) < 8) {\n\t\t\tthrow new InvalidArgumentException(['key' => 'user.password.invalid']);\n\t\t}\n\n\t\t// too long passwords can cause DoS attacks\n\t\tif (Str::length($password) > 1000) {\n\t\t\tthrow new InvalidArgumentException(['key' => 'user.password.excessive']);\n\t\t}\n\n\t\tif (password_verify($password, $this->password()) !== true) {\n\t\t\tthrow new InvalidArgumentException(['key' => 'user.password.wrong', 'httpCode' => 401]);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Closure;\nuse Kirby\\Data\\Data;\nuse Kirby\\Exception\\LogicException;\nuse Kirby\\Exception\\PermissionException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Form\\Form;\nuse Kirby\\Http\\Idn;\nuse Kirby\\Toolkit\\Str;\nuse SensitiveParameter;\nuse Throwable;\n\n/**\n * UserActions\n *\n * @package   Kirby Cms\n * @author    Bastian Allgeier <bastian@getkirby.com>\n * @link      https://getkirby.com\n * @copyright Bastian Allgeier\n * @license   https://getkirby.com/license\n */\ntrait UserActions\n{\n\t/**\n\t * Changes the user email address\n\t *\n\t * @param string $email\n\t * @return static\n\t */\n\tpublic function changeEmail(string $email)\n\t{\n\t\t$email = trim($email);\n\n\t\treturn $this->commit('changeEmail', ['user' => $this, 'email' => Idn::decodeEmail($email)], function ($user, $email) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'email' => $email\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'email' => $email\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the user language\n\t *\n\t * @param string $language\n\t * @return static\n\t */\n\tpublic function changeLanguage(string $language)\n\t{\n\t\treturn $this->commit('changeLanguage', ['user' => $this, 'language' => $language], function ($user, $language) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'language' => $language,\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'language' => $language\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the screen name of the user\n\t *\n\t * @param string $name\n\t * @return static\n\t */\n\tpublic function changeName(string $name)\n\t{\n\t\t$name = trim($name);\n\n\t\treturn $this->commit('changeName', ['user' => $this, 'name' => $name], function ($user, $name) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'name' => $name\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'name' => $name\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the user password\n\t */\n\tpublic function changePassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password\n\t): static {\n\t\treturn $this->commit('changePassword', ['user' => $this, 'password' => $password], function ($user, $password) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'password' => $password = User::hashPassword($password)\n\t\t\t]);\n\n\t\t\t$user->writePassword($password);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the user role\n\t *\n\t * @param string $role\n\t * @return static\n\t */\n\tpublic function changeRole(string $role)\n\t{\n\t\treturn $this->commit('changeRole', ['user' => $this, 'role' => $role], function ($user, $role) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'role' => $role,\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'role' => $role\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Commits a user action, by following these steps\n\t *\n\t * 1. checks the action rules\n\t * 2. sends the before hook\n\t * 3. commits the action\n\t * 4. sends the after hook\n\t * 5. returns the result\n\t *\n\t * @param string $action\n\t * @param array $arguments\n\t * @param \\Closure $callback\n\t * @return mixed\n\t * @throws \\Kirby\\Exception\\PermissionException\n\t */\n\tprotected function commit(string $action, array $arguments, Closure $callback)\n\t{\n\t\tif ($this->isKirby() === true) {\n\t\t\tthrow new PermissionException('The Kirby user cannot be changed');\n\t\t}\n\n\t\t$old            = $this->hardcopy();\n\t\t$kirby          = $this->kirby();\n\t\t$argumentValues = array_values($arguments);\n\n\t\t$this->rules()->$action(...$argumentValues);\n\t\t$kirby->trigger('user.' . $action . ':before', $arguments);\n\n\t\t$result = $callback(...$argumentValues);\n\n\t\tif ($action === 'create') {\n\t\t\t$argumentsAfter = ['user' => $result];\n\t\t} elseif ($action === 'delete') {\n\t\t\t$argumentsAfter = ['status' => $result, 'user' => $old];\n\t\t} else {\n\t\t\t$argumentsAfter = ['newUser' => $result, 'oldUser' => $old];\n\t\t}\n\t\t$kirby->trigger('user.' . $action . ':after', $argumentsAfter);\n\n\t\t$kirby->cache('pages')->flush();\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Creates a new User from the given props and returns a new User object\n\t *\n\t * @param array|null $props\n\t * @return static\n\t */\n\tpublic static function create(array $props = null)\n\t{\n\t\t$data = $props;\n\n\t\tif (isset($props['email']) === true) {\n\t\t\t$data['email'] = Idn::decodeEmail($props['email']);\n\t\t}\n\n\t\tif (isset($props['password']) === true) {\n\t\t\t$data['password'] = User::hashPassword($props['password']);\n\t\t}\n\n\t\t$props['role'] = $props['model'] = strtolower($props['role'] ?? 'default');\n\n\t\t$user = User::factory($data);\n\n\t\t// create a form for the user\n\t\t$form = Form::for($user, [\n\t\t\t'values' => $props['content'] ?? []\n\t\t]);\n\n\t\t// inject the content\n\t\t$user = $user->clone(['content' => $form->strings(true)]);\n\n\t\t// run the hook\n\t\treturn $user->commit('create', ['user' => $user, 'input' => $props], function ($user, $props) {\n\t\t\t$user->writeCredentials([\n\t\t\t\t'email'    => $user->email(),\n\t\t\t\t'language' => $user->language(),\n\t\t\t\t'name'     => $user->name()->value(),\n\t\t\t\t'role'     => $user->role()->id(),\n\t\t\t]);\n\n\t\t\t$user->writePassword($user->password());\n\n\t\t\t// always create users in the default language\n\t\t\tif ($user->kirby()->multilang() === true) {\n\t\t\t\t$languageCode = $user->kirby()->defaultLanguage()->code();\n\t\t\t} else {\n\t\t\t\t$languageCode = null;\n\t\t\t}\n\n\t\t\t// add the user to users collection\n\t\t\t$user->kirby()->users()->add($user);\n\n\t\t\t// write the user data\n\t\t\treturn $user->save($user->content()->toArray(), $languageCode);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a random user id\n\t *\n\t * @return string\n\t */\n\tpublic function createId(): string\n\t{\n\t\t$length = 8;\n\n\t\tdo {\n\t\t\ttry {\n\t\t\t\t$id = Str::random($length);\n\t\t\t\tif (UserRules::validId($this, $id) === true) {\n\t\t\t\t\treturn $id;\n\t\t\t\t}\n\n\t\t\t\t// we can't really test for a random match\n\t\t\t\t// @codeCoverageIgnoreStart\n\t\t\t} catch (Throwable) {\n\t\t\t\t$length++;\n\t\t\t}\n\t\t} while (true);\n\t\t// @codeCoverageIgnoreEnd\n\t}\n\n\t/**\n\t * Deletes the user\n\t *\n\t * @return bool\n\t * @throws \\Kirby\\Exception\\LogicException\n\t */\n\tpublic function delete(): bool\n\t{\n\t\treturn $this->commit('delete', ['user' => $this], function ($user) {\n\t\t\tif ($user->exists() === false) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// delete all public assets for this user\n\t\t\tDir::remove($user->mediaRoot());\n\n\t\t\t// delete the user directory\n\t\t\tif (Dir::remove($user->root()) !== true) {\n\t\t\t\tthrow new LogicException('The user directory for \"' . $user->email() . '\" could not be deleted');\n\t\t\t}\n\n\t\t\t// remove the user from users collection\n\t\t\t$user->kirby()->users()->remove($user);\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * Read the account information from disk\n\t *\n\t * @return array\n\t */\n\tprotected function readCredentials(): array\n\t{\n\t\t$path = $this->root() . '/index.php';\n\n\t\tif (is_file($path) === true) {\n\t\t\t$credentials = F::load($path, allowOutput: false);\n\n\t\t\treturn is_array($credentials) === false ? [] : $credentials;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t/**\n\t * Reads the user password from disk\n\t *\n\t * @return string|false\n\t */\n\tprotected function readPassword()\n\t{\n\t\treturn F::read($this->root() . '/.htpasswd');\n\t}\n\n\t/**\n\t * Updates the user data\n\t *\n\t * @param array|null $input\n\t * @param string|null $languageCode\n\t * @param bool $validate\n\t * @return static\n\t */\n\tpublic function update(array $input = null, string $languageCode = null, bool $validate = false)\n\t{\n\t\t$user = parent::update($input, $languageCode, $validate);\n\n\t\t// set auth user data only if the current user is this user\n\t\tif ($user->isLoggedIn() === true) {\n\t\t\t$this->kirby()->auth()->setUser($user);\n\t\t}\n\n\t\t// update the users collection\n\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\treturn $user;\n\t}\n\n\t/**\n\t * This always merges the existing credentials\n\t * with the given input.\n\t *\n\t * @param array $credentials\n\t * @return bool\n\t */\n\tprotected function updateCredentials(array $credentials): bool\n\t{\n\t\t// normalize the email address\n\t\tif (isset($credentials['email']) === true) {\n\t\t\t$credentials['email'] = Str::lower(trim($credentials['email']));\n\t\t}\n\n\t\treturn $this->writeCredentials(array_merge($this->credentials(), $credentials));\n\t}\n\n\t/**\n\t * Writes the account information to disk\n\t *\n\t * @param array $credentials\n\t * @return bool\n\t */\n\tprotected function writeCredentials(array $credentials): bool\n\t{\n\t\treturn Data::write($this->root() . '/index.php', $credentials);\n\t}\n\n\t/**\n\t * Writes the password to disk\n\t */\n\tprotected function writePassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): bool {\n\t\treturn F::write($this->root() . '/.htpasswd', $password);\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Exception\\PermissionException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Session\\AutoSession;\nuse Throwable;\n\n/**\n * @coversDefaultClass \\Kirby\\Cms\\Auth\n */\nclass AuthTest extends TestCase\n{\n\tprotected $app;\n\tprotected $auth;\n\tprotected $fixtures;\n\n\tpublic function setUp(): void\n\t{\n\t\t$this->app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index' => $this->fixtures = __DIR__ . '/fixtures/AuthTest'\n\t\t\t],\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth'     => true,\n\t\t\t\t\t'allowInsecure' => true\n\t\t\t\t],\n\t\t\t\t'auth' => [\n\t\t\t\t\t'debug' => false\n\t\t\t\t]\n\t\t\t],\n\t\t\t'users' => [\n\t\t\t\t[\n\t\t\t\t\t'email'    => 'marge@simpsons.com',\n\t\t\t\t\t'id'       => 'marge',\n\t\t\t\t\t'password' => password_hash('springfield123', PASSWORD_DEFAULT)\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'email'    => 'homer@simpsons.com',\n\t\t\t\t\t'id'       => 'homer',\n\t\t\t\t\t'password' => password_hash('springfield123', PASSWORD_DEFAULT)\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\t\tDir::make($this->fixtures . '/site/accounts');\n\n\t\t$this->auth = $this->app->auth();\n\t}\n\n\tpublic function tearDown(): void\n\t{\n\t\t$this->app->session()->destroy();\n\t\tDir::remove($this->fixtures);\n\t\tApp::destroy();\n\t}\n\n\t/**\n\t * @covers ::currentUserFromImpersonation\n\t * @covers ::impersonate\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testImpersonate()\n\t{\n\t\t$this->assertNull($this->auth->user());\n\n\t\t$user = $this->auth->impersonate('kirby');\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'kirby@getkirby.com',\n\t\t\t'status'    => 'impersonated'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame($user, $this->auth->user());\n\t\t$this->assertSame($user, $this->auth->currentUserFromImpersonation());\n\t\t$this->assertSame('kirby', $user->id());\n\t\t$this->assertSame('kirby@getkirby.com', $user->email());\n\t\t$this->assertSame('admin', $user->role()->name());\n\t\t$this->assertNull($this->auth->user(null, false));\n\n\t\t$user = $this->auth->impersonate('homer@simpsons.com');\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'homer@simpsons.com',\n\t\t\t'status'    => 'impersonated'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame('homer@simpsons.com', $user->email());\n\t\t$this->assertSame($user, $this->auth->user());\n\t\t$this->assertSame($user, $this->auth->currentUserFromImpersonation());\n\t\t$this->assertNull($this->auth->user(null, false));\n\n\t\t$this->assertNull($this->auth->impersonate(null));\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => null,\n\t\t\t'status'    => 'inactive'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertNull($this->auth->user());\n\t\t$this->assertNull($this->auth->currentUserFromImpersonation());\n\t\t$this->assertNull($this->auth->user(null, false));\n\n\t\t$this->auth->setUser($actual = $this->app->user('marge@simpsons.com'));\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'marge@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame('marge@simpsons.com', $this->auth->user()->email());\n\t\t$impersonated = $this->auth->impersonate('nobody');\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'nobody@getkirby.com',\n\t\t\t'status'    => 'impersonated'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame($impersonated, $this->auth->user());\n\t\t$this->assertSame($impersonated, $this->auth->currentUserFromImpersonation());\n\t\t$this->assertSame('nobody', $impersonated->id());\n\t\t$this->assertSame('nobody@getkirby.com', $impersonated->email());\n\t\t$this->assertSame('nobody', $impersonated->role()->name());\n\t\t$this->assertSame($actual, $this->auth->user(null, false));\n\n\t\t$this->auth->logout();\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => null,\n\t\t\t'status'    => 'inactive'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertNull($this->auth->impersonate());\n\t\t$this->assertNull($this->auth->user());\n\t\t$this->assertNull($this->auth->currentUserFromImpersonation());\n\t\t$this->assertNull($this->auth->user(null, false));\n\t}\n\n\t/**\n\t * @covers ::impersonate\n\t */\n\tpublic function testImpersonateInvalidUser()\n\t{\n\t\t$this->expectException(NotFoundException::class);\n\t\t$this->expectExceptionMessage('The user \"lisa@simpsons.com\" cannot be found');\n\n\t\t$this->auth->impersonate('lisa@simpsons.com');\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic1()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('testuser:testpass')\n\t\t\t]\n\t\t]);\n\n\t\t// existing basic auth should be preferred\n\t\t// over impersonation\n\t\t$app->auth()->impersonate('kirby');\n\n\t\t$this->assertSame('basic', $app->auth()->type());\n\n\t\t// auth object should have been accessed\n\t\t$this->assertTrue($app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic2()\n\t{\n\t\t// non-existing basic auth should\n\t\t// fall back to impersonation\n\t\t$this->auth->impersonate('kirby');\n\n\t\t$this->assertSame('impersonate', $this->auth->type());\n\n\t\t// auth object should have been accessed\n\t\t$this->assertTrue($this->app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic3()\n\t{\n\t\t// non-existing basic auth without\n\t\t// impersonation should fall back to session\n\t\t$this->assertSame('session', $this->auth->type());\n\n\t\t// auth object should have been accessed\n\t\t$this->assertTrue($this->app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic4()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth' => false\n\t\t\t\t]\n\t\t\t],\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('testuser:testpass')\n\t\t\t]\n\t\t]);\n\n\t\t// disabled option should fall back to session\n\t\t$this->assertSame('session', $app->auth()->type());\n\n\t\t// auth object should *not* have been accessed\n\t\t$this->assertFalse($app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeImpersonate()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth' => false\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$app->auth()->impersonate('kirby');\n\n\t\t$this->assertSame('impersonate', $app->auth()->type());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeSession()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth' => false\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$this->assertSame('session', $app->auth()->type());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserSession1()\n\t{\n\t\t$session = $this->app->session();\n\t\t$session->set('kirby.userId', 'marge');\n\n\t\t$user = $this->auth->user();\n\t\t$this->assertSame('marge@simpsons.com', $user->email());\n\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'marge@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\n\t\t// impersonation is not set\n\t\t$this->assertNull($this->auth->currentUserFromImpersonation());\n\n\t\t// value is cached\n\t\t$session->set('kirby.userId', 'homer');\n\t\t$user = $this->auth->user();\n\t\t$this->assertSame('marge@simpsons.com', $user->email());\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'marge@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserSession2()\n\t{\n\t\t$session = (new AutoSession($this->app->root('sessions')))->createManually();\n\t\t$session->set('kirby.userId', 'homer');\n\n\t\t$user = $this->auth->user($session);\n\t\t$this->assertSame('homer@simpsons.com', $user->email());\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'homer@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserBasicAuth()\n\t{\n\t\t$this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('homer@simpsons.com:springfield123')\n\t\t\t]\n\t\t]);\n\n\t\t$user = $this->auth->user();\n\t\t$this->assertSame('homer@simpsons.com', $user->email());\n\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'homer@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t}\n\n\t/**\n\t * @covers ::user\n\t */\n\tpublic function testUserBasicAuthInvalid1()\n\t{\n\t\t$this->expectException(PermissionException::class);\n\t\t$this->expectExceptionMessage('Invalid login');\n\n\t\t$this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('homer@simpsons.com:invalid')\n\t\t\t]\n\t\t]);\n\n\t\t$this->auth->user();\n\t}\n\n\t/**\n\t * @covers ::user\n\t */\n\tpublic function testUserBasicAuthInvalid2()\n\t{\n\t\t$this->expectException(PermissionException::class);\n\t\t$this->expectExceptionMessage('Invalid login');\n\n\t\t$this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('homer@simpsons.com:invalid')\n\t\t\t]\n\t\t]);\n\n\t\ttry {\n\t\t\t$this->auth->user();\n\t\t} catch (Throwable) {\n\t\t\t// tested above, this check is for the second call\n\t\t}\n\n\t\t$this->auth->user();\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Data\\Data;\nuse Kirby\\Filesystem\\Dir;\n\nclass UserActionsTest extends TestCase\n{\n\tprotected $app;\n\tprotected $tmp = __DIR__ . '/tmp';\n\n\tpublic function setUp(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t\tData::write($this->tmp . '/accounts/admin/index.php', [\n\t\t\t'email' => 'admin@domain.com',\n\t\t\t'role' => 'admin'\n\t\t]);\n\t\tData::write($this->tmp . '/accounts/editor/index.php', [\n\t\t\t'email' => 'editor@domain.com',\n\t\t\t'role' => 'editor'\n\t\t]);\n\n\t\t$this->app = new App([\n\t\t\t'roles' => [\n\t\t\t\t[\n\t\t\t\t\t'name' => 'admin'\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'name' => 'editor'\n\t\t\t\t]\n\t\t\t],\n\t\t\t'roots' => [\n\t\t\t\t'index'    => '/dev/null',\n\t\t\t\t'accounts' => $this->tmp . '/accounts',\n\t\t\t\t'sessions' => $this->tmp . '/sessions'\n\t\t\t],\n\t\t\t'user'  => 'admin@domain.com'\n\t\t]);\n\t}\n\n\tpublic function tearDown(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t}\n\n\tpublic function testChangeEmail()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeEmail('another@domain.com');\n\n\t\t$this->assertSame('another@domain.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('another@domain.com', $this->app->clone()->user($user->id())->email());\n\t}\n\n\tpublic function testChangeEmailWithUnicode()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\n\t\t// with Unicode email\n\t\t$user = $user->changeEmail('test@ex\u00e4mple.com');\n\t\t$this->assertSame('test@ex\u00e4mple.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('test@ex\u00e4mple.com', $this->app->clone()->user($user->id())->email());\n\n\t\t// with Punycode email\n\t\t$user = $user->changeEmail('test@xn--tst-qla.com');\n\t\t$this->assertSame('test@t\u00e4st.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('test@t\u00e4st.com', $this->app->clone()->user($user->id())->email());\n\t}\n\n\tpublic function testChangeEmailWithUppercase()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeEmail('ANOTHER@domain.com');\n\n\t\t$this->assertSame('another@domain.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('another@domain.com', $this->app->clone()->user($user->id())->email());\n\t}\n\n\tpublic function testChangeLanguage()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeLanguage('de');\n\n\t\t$this->assertSame('de', $user->language());\n\t}\n\n\tpublic function testChangeName()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeName('Edith Thor');\n\n\t\t$this->assertSame('Edith Thor', $user->name()->value());\n\t}\n\n\tpublic function testChangePassword()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changePassword('topsecret2018');\n\n\t\t$this->assertTrue($user->validatePassword('topsecret2018'));\n\t}\n\n\tpublic function testChangeRole()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeRole('editor');\n\n\t\t$this->assertInstanceOf(Role::class, $user->role());\n\t\t$this->assertSame('editor', $user->role()->name());\n\t}\n\n\tpublic function testCreateAdmin()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'admin',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\n\t\t$this->assertSame('new@domain.com', $user->email());\n\t\t$this->assertInstanceOf(Role::class, $user->role());\n\t\t$this->assertSame('admin', $user->role()->name());\n\t}\n\n\tpublic function testCreateUserWithUnicodeEmail()\n\t{\n\t\t// with Unicode email\n\t\t$user = User::create([\n\t\t\t'email' => 'test@ex\u00e4mple.com',\n\t\t\t'role'  => 'admin',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\t\t$this->assertSame('test@ex\u00e4mple.com', $user->email());\n\t\t$this->assertSame('admin', $user->role()->name());\n\n\t\t// with Punycode email\n\t\t$user = User::create([\n\t\t\t'email' => 'test@xn--tst-qla.com',\n\t\t\t'role'  => 'admin',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\t\t$this->assertSame('test@t\u00e4st.com', $user->email());\n\t\t$this->assertSame('admin', $user->role()->name());\n\t}\n\n\tpublic function testCreateEditor()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\n\t\t$this->assertSame('new@domain.com', $user->email());\n\t\t$this->assertInstanceOf(Role::class, $user->role());\n\t\t$this->assertSame('editor', $user->role()->name());\n\t}\n\n\tpublic function testCreateWithContent()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'content' => [\n\t\t\t\t'a' => 'Custom A'\n\t\t\t],\n\t\t]);\n\n\t\t$this->assertSame('Custom A', $user->a()->value());\n\t}\n\n\tpublic function testCreateWithDefaults()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'blueprint' => [\n\t\t\t\t'name' => 'editor',\n\t\t\t\t'fields' => [\n\t\t\t\t\t'a'  => [\n\t\t\t\t\t\t'type'    => 'text',\n\t\t\t\t\t\t'default' => 'A'\n\t\t\t\t\t],\n\t\t\t\t\t'b' => [\n\t\t\t\t\t\t'type'    => 'textarea',\n\t\t\t\t\t\t'default' => 'B'\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$this->assertSame('A', $user->a()->value());\n\t\t$this->assertSame('B', $user->b()->value());\n\t}\n\n\tpublic function testCreateWithDefaultsAndContent()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'content' => [\n\t\t\t\t'a' => 'Custom A'\n\t\t\t],\n\t\t\t'blueprint' => [\n\t\t\t\t'name' => 'editor',\n\t\t\t\t'fields' => [\n\t\t\t\t\t'a'  => [\n\t\t\t\t\t\t'type'    => 'text',\n\t\t\t\t\t\t'default' => 'A'\n\t\t\t\t\t],\n\t\t\t\t\t'b' => [\n\t\t\t\t\t\t'type'    => 'textarea',\n\t\t\t\t\t\t'default' => 'B'\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$this->assertSame('Custom A', $user->a()->value());\n\t\t$this->assertSame('B', $user->b()->value());\n\t}\n\n\tpublic function testCreateWithContentMultilang()\n\t{\n\t\t$this->app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'languages' => true\n\t\t\t],\n\t\t\t'languages' => [\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'en',\n\t\t\t\t\t'default' => true,\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'de',\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'content' => [\n\t\t\t\t'a' => 'a',\n\t\t\t\t'b' => 'b',\n\t\t\t],\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\n\t\t$this->assertSame('a', $user->a()->value());\n\t\t$this->assertSame('b', $user->b()->value());\n\t}\n\n\tpublic function testDelete()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user->save();\n\n\t\t$this->assertFileExists($user->root() . '/user.txt');\n\t\t$user->delete();\n\t\t$this->assertFileDoesNotExist($user->root() . '/user.txt');\n\t}\n\n\tpublic function testUpdate()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->update([\n\t\t\t'website' => $url = 'https://editor.com'\n\t\t]);\n\n\t\t$this->assertSame($url, $user->website()->value());\n\t}\n\n\tpublic function testUpdateWithAuthUser()\n\t{\n\t\t$user = $this->app->user('admin@domain.com');\n\t\t$user->loginPasswordless();\n\t\t$user->update([\n\t\t\t'website' => $url = 'https://getkirby.com'\n\t\t]);\n\t\t$this->assertSame($url, $this->app->user()->website()->value());\n\t\t$user->logout();\n\t}\n\n\tpublic function testChangeEmailHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeEmail:before' => function (User $user, $email) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('another@domain.com', $email);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeEmail:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('another@domain.com', $newUser->email());\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $oldUser->email());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeEmail('another@domain.com');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangeLanguageHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeLanguage:before' => function (User $user, $language) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('en', $user->language());\n\t\t\t\t\t$phpunit->assertSame('de', $language);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeLanguage:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('de', $newUser->language());\n\t\t\t\t\t$phpunit->assertSame('en', $oldUser->language());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeLanguage('de');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangeNameHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeName:before' => function (User $user, $name) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertNull($user->name()->value());\n\t\t\t\t\t$phpunit->assertSame('Edith Thor', $name);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeName:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('Edith Thor', $newUser->name()->value());\n\t\t\t\t\t$phpunit->assertNull($oldUser->name()->value());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeName('Edith Thor');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangePasswordHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changePassword:before' => function (User $user, $password) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertEmpty($user->password());\n\t\t\t\t\t$phpunit->assertSame('topsecret2018', $password);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changePassword:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertTrue($newUser->validatePassword('topsecret2018'));\n\t\t\t\t\t$phpunit->assertEmpty($oldUser->password());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changePassword('topsecret2018');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangeRoleHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeRole:before' => function (User $user, $role) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('editor', $user->role()->name());\n\t\t\t\t\t$phpunit->assertSame('admin', $role);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeRole:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('admin', $newUser->role()->name());\n\t\t\t\t\t$phpunit->assertSame('editor', $oldUser->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeRole('admin');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testCreateHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit= $this;\n\t\t$userInput = [\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'admin',\n\t\t\t'model' => 'admin',\n\t\t];\n\n\t\t$this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.create:before' => function (User $user, $input) use ($phpunit, $userInput, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('new@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('admin', $user->role()->name());\n\t\t\t\t\t$phpunit->assertSame($userInput, $input);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.create:after' => function (User $user) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('new@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('admin', $user->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\tUser::create($userInput);\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testDeleteHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.delete:before' => function (User $user) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('editor', $user->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.delete:after' => function ($status, User $user) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertTrue($status);\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('editor', $user->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->delete();\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testUpdateHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\t\t$input = [\n\t\t\t'website' => 'https://getkirby.com'\n\t\t];\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.update:before' => function (User $user, $values, $strings) use ($phpunit, $input, &$calls) {\n\t\t\t\t\t$phpunit->assertNull($user->website()->value());\n\t\t\t\t\t$phpunit->assertSame($input, $values);\n\t\t\t\t\t$phpunit->assertSame($input, $strings);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.update:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('https://getkirby.com', $newUser->website()->value());\n\t\t\t\t\t$phpunit->assertNull($oldUser->website()->value());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->update($input);\n\n\t\t$this->assertSame(2, $calls);\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nclass UserAuthTest extends TestCase\n{\n\tprotected $app;\n\tprotected $tmp = __DIR__ . '/tmp';\n\n\tpublic function setUp(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t\t$this->app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => '/dev/null',\n\t\t\t\t'accounts' => $this->tmp . '/accounts',\n\t\t\t\t'sessions' => $this->tmp . '/sessions'\n\t\t\t],\n\t\t\t'users' => [\n\t\t\t\t[\n\t\t\t\t\t'email' => 'test@getkirby.com',\n\t\t\t\t\t'role'  => 'admin'\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\t}\n\n\tpublic function tearDown(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t}\n\n\tpublic function testGlobalUserState()\n\t{\n\t\t$user = $this->app->user('test@getkirby.com');\n\n\t\t$this->assertNull($this->app->user());\n\t\t$user->loginPasswordless();\n\t\t$this->assertSame($user, $this->app->user());\n\t\t$user->logout();\n\t\t$this->assertNull($this->app->user());\n\t}\n\n\tpublic function testLoginLogoutHooks()\n\t{\n\t\t$phpunit = $this;\n\n\t\t$calls         = 0;\n\t\t$logoutSession = false;\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.login:before' => function ($user, $session) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\n\t\t\t\t\t$calls += 1;\n\t\t\t\t},\n\t\t\t\t'user.login:after' => function ($user, $session) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\n\t\t\t\t\t$calls += 2;\n\t\t\t\t},\n\t\t\t\t'user.logout:before' => function ($user, $session) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\n\t\t\t\t\t$calls += 4;\n\t\t\t\t},\n\t\t\t\t'user.logout:after' => function ($user, $session) use ($phpunit, &$calls, &$logoutSession) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\n\t\t\t\t\tif ($logoutSession === true) {\n\t\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\t\t\t\t\t\t$phpunit->assertSame('value', S::instance()->get('some'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$phpunit->assertNull($session);\n\t\t\t\t\t}\n\n\t\t\t\t\t$calls += 8;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t// without prepopulated session\n\t\t$user = $app->user('test@getkirby.com');\n\t\t$user->loginPasswordless();\n\t\t$user->logout();\n\n\t\t// with a session with another value\n\t\tS::instance()->set('some', 'value');\n\t\t$logoutSession = true;\n\t\t$user->loginPasswordless();\n\t\t$user->logout();\n\n\t\t// each hook needs to be called exactly twice\n\t\t$this->assertSame((1 + 2 + 4 + 8) * 2, $calls);\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Exception\\InvalidArgumentException;\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\n\nclass UserTestModel extends User\n{\n}\n\nclass UserTest extends TestCase\n{\n\tpublic function testAvatar()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'user@domain.com'\n\t\t]);\n\n\t\t$this->assertNull($user->avatar());\n\t}\n\n\tpublic function testDefaultSiblings()\n\t{\n\t\t$user = new User(['email' => 'user@domain.com']);\n\t\t$this->assertInstanceOf(Users::class, $user->siblings());\n\t}\n\n\tpublic function testContent()\n\t{\n\t\t$user = new User([\n\t\t\t'email'   => 'user@domain.com',\n\t\t\t'content' => $content = ['name' => 'Test']\n\t\t]);\n\n\t\t$this->assertSame($content, $user->content()->toArray());\n\t}\n\n\tpublic function testInvalidContent()\n\t{\n\t\t$this->expectException('TypeError');\n\n\t\t$user = new User(['email' => 'user@domain.com', 'content' => 'something']);\n\t}\n\n\tpublic function testDefaultContent()\n\t{\n\t\t$user = new User(['email' => 'user@domain.com']);\n\t\t$this->assertInstanceOf(Content::class, $user->content());\n\t}\n\n\tpublic function testEmail()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => $email = 'user@domain.com',\n\t\t]);\n\n\t\t$this->assertSame($email, $user->email());\n\t}\n\n\tpublic function testInvalidEmail()\n\t{\n\t\t$this->expectException('TypeError');\n\n\t\t$user = new User(['email' => []]);\n\t}\n\n\tpublic function testName()\n\t{\n\t\t$user = new User([\n\t\t\t'name' => $name = 'Homer Simpson',\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->name());\n\t\t$this->assertSame($name, $user->name()->value());\n\t}\n\n\tpublic function testNameSanitized()\n\t{\n\t\t$user = new User([\n\t\t\t'name' => '<strong>Homer</strong> Simpson',\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->name());\n\t\t$this->assertSame('Homer Simpson', $user->name()->value());\n\t}\n\n\tpublic function testNameOrEmail()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => $email = 'homer@simpsons.com',\n\t\t\t'name'  => $name = 'Homer Simpson',\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->nameOrEmail());\n\t\t$this->assertSame($name, $user->nameOrEmail()->value());\n\t\t$this->assertSame('name', $user->nameOrEmail()->key());\n\n\t\t$user = new User([\n\t\t\t'email' => $email = 'homer@simpsons.com',\n\t\t\t'name'  => ''\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->nameOrEmail());\n\t\t$this->assertSame($email, $user->nameOrEmail()->value());\n\t\t$this->assertSame('email', $user->nameOrEmail()->key());\n\t}\n\n\tpublic function testToString()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com'\n\t\t]);\n\n\t\t$this->assertSame('test@getkirby.com', $user->toString());\n\t}\n\n\tpublic function testToStringWithTemplate()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com'\n\t\t]);\n\n\t\t$this->assertSame('Email: test@getkirby.com', $user->toString('Email: {{ user.email }}'));\n\t}\n\n\tpublic function testModified()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => $index = __DIR__ . '/fixtures/UserPropsTest/modified',\n\t\t\t\t'accounts' => $index\n\t\t\t]\n\t\t]);\n\n\t\t// create a user file\n\t\tF::write($file = $index . '/test/index.php', '<?php return [];');\n\n\t\t$modified = filemtime($file);\n\t\t$user     = $app->user('test');\n\n\t\t$this->assertSame((string)$modified, $user->modified());\n\n\t\t// default date handler\n\t\t$format = 'd.m.Y';\n\t\t$this->assertSame(date($format, $modified), $user->modified($format));\n\n\t\t// custom date handler\n\t\t$format = '%d.%m.%Y';\n\t\t$this->assertSame(@strftime($format, $modified), $user->modified($format, 'strftime'));\n\n\t\tDir::remove($index);\n\t}\n\n\tpublic function testModifiedSpecifyingLanguage()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => $index = __DIR__ . '/fixtures/UserPropsTest/modified',\n\t\t\t\t'accounts' => $index\n\t\t\t],\n\t\t\t'languages' => [\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'en',\n\t\t\t\t\t'default' => true,\n\t\t\t\t\t'name'    => 'English'\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'de',\n\t\t\t\t\t'name'    => 'Deutsch'\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t// create a user file\n\t\tF::write($file = $index . '/test/index.php', '<?php return [];');\n\n\t\t// create the english page\n\t\tF::write($file = $index . '/test/user.en.txt', 'test');\n\t\ttouch($file, $modifiedEnContent = \\time() + 2);\n\n\t\t// create the german page\n\t\tF::write($file = $index . '/test/user.de.txt', 'test');\n\t\ttouch($file, $modifiedDeContent = \\time() + 5);\n\n\t\t$user = $app->user('test');\n\n\t\t$this->assertSame((string)$modifiedEnContent, $user->modified('U', null, 'en'));\n\t\t$this->assertSame((string)$modifiedDeContent, $user->modified('U', null, 'de'));\n\n\t\tDir::remove($index);\n\t}\n\n\tpublic function passwordProvider()\n\t{\n\t\treturn [\n\t\t\t[null, false],\n\t\t\t['', false],\n\t\t\t['short', false],\n\t\t\t[str_repeat('long', 300), false],\n\t\t\t['invalid-password', false],\n\t\t\t['correct-horse-battery-staple', true],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider passwordProvider\n\t */\n\tpublic function testValidatePassword($input, $valid)\n\t{\n\t\t$user = new User([\n\t\t\t'email'    => 'test@getkirby.com',\n\t\t\t'password' => User::hashPassword('correct-horse-battery-staple')\n\t\t]);\n\n\t\tif ($valid === false) {\n\t\t\t$this->expectException(InvalidArgumentException::class);\n\t\t\t$user->validatePassword($input);\n\t\t} else {\n\t\t\t$this->assertTrue($user->validatePassword($input));\n\t\t}\n\t}\n\n\tpublic function testValidatePasswordHttpCode()\n\t{\n\t\t$user = new User([\n\t\t\t'email'    => 'test@getkirby.com',\n\t\t\t'password' => User::hashPassword('correct-horse-battery-staple')\n\t\t]);\n\n\t\t$caught = 0;\n\n\t\ttry {\n\t\t\t$user->validatePassword('short');\n\t\t} catch (\\Kirby\\Exception\\InvalidArgumentException $e) {\n\t\t\t$this->assertSame(\n\t\t\t\t'Please enter a valid password. Passwords must be at least 8 characters long.',\n\t\t\t\t$e->getMessage()\n\t\t\t);\n\t\t\t$this->assertSame(400, $e->getHttpCode());\n\t\t\t$caught++;\n\t\t}\n\n\t\ttry {\n\t\t\t$user->validatePassword(str_repeat('long', 300));\n\t\t} catch (\\Kirby\\Exception\\InvalidArgumentException $e) {\n\t\t\t$this->assertSame(\n\t\t\t\t'Please enter a valid password. Passwords must not be longer than 1000 characters.',\n\t\t\t\t$e->getMessage()\n\t\t\t);\n\t\t\t$this->assertSame(400, $e->getHttpCode());\n\t\t\t$caught++;\n\t\t}\n\n\t\ttry {\n\t\t\t$user->validatePassword('longbutinvalid');\n\t\t} catch (\\Kirby\\Exception\\InvalidArgumentException $e) {\n\t\t\t$this->assertSame('Wrong password', $e->getMessage());\n\t\t\t$this->assertSame(401, $e->getHttpCode());\n\t\t\t$caught++;\n\t\t}\n\n\t\t$this->assertSame(3, $caught);\n\t}\n\n\tpublic function testValidateUndefinedPassword()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t]);\n\n\t\t$this->expectException(NotFoundException::class);\n\t\t$user->validatePassword('test');\n\t}\n\n\tpublic function testIsAdmin()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'role'  => 'admin'\n\t\t]);\n\n\t\t$this->assertTrue($user->isAdmin());\n\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'role'  => 'editor'\n\t\t]);\n\n\t\t$this->assertFalse($user->isAdmin());\n\t}\n\n\tpublic function testIsLoggedIn()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index' => '/dev/null'\n\t\t\t],\n\t\t\t'users' => [\n\t\t\t\t['email' => 'a@getkirby.com'],\n\t\t\t\t['email' => 'b@getkirby.com']\n\t\t\t],\n\t\t]);\n\n\t\t$a = $app->user('a@getkirby.com');\n\t\t$b = $app->user('b@getkirby.com');\n\n\t\t$this->assertFalse($a->isLoggedIn());\n\t\t$this->assertFalse($b->isLoggedIn());\n\n\t\t$app->impersonate('a@getkirby.com');\n\n\t\t$this->assertTrue($a->isLoggedIn());\n\t\t$this->assertFalse($b->isLoggedIn());\n\n\t\t$app->impersonate('b@getkirby.com');\n\n\t\t$this->assertFalse($a->isLoggedIn());\n\t\t$this->assertTrue($b->isLoggedIn());\n\t}\n\n\tpublic function testQuery()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'name'  => 'Test User'\n\t\t]);\n\n\t\t$this->assertSame('Test User', $user->query('user.name')->value());\n\t\t$this->assertSame('test@getkirby.com', $user->query('user.email'));\n\n\t\t// also test with `model` key\n\t\t$this->assertSame('Test User', $user->query('model.name')->value());\n\t\t$this->assertSame('test@getkirby.com', $user->query('model.email'));\n\t}\n\n\tpublic function testUserMethods()\n\t{\n\t\tUser::$methods = [\n\t\t\t'test' => function () {\n\t\t\t\treturn 'homer';\n\t\t\t}\n\t\t];\n\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'name'  => 'Test User'\n\t\t]);\n\n\t\t$this->assertSame('homer', $user->test());\n\n\t\tUser::$methods = [];\n\t}\n\n\tpublic function testUserModel()\n\t{\n\t\tUser::$models = [\n\t\t\t'dummy' => UserTestModel::class\n\t\t];\n\n\t\t$user = User::factory([\n\t\t\t'slug'  => 'test',\n\t\t\t'model' => 'dummy'\n\t\t]);\n\n\t\t$this->assertInstanceOf(UserTestModel::class, $user);\n\n\t\tUser::$models = [];\n\t}\n}\n"], "fixing_code": ["<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Cms\\Auth\\Challenge;\nuse Kirby\\Cms\\Auth\\Status;\nuse Kirby\\Data\\Data;\nuse Kirby\\Exception\\Exception;\nuse Kirby\\Exception\\InvalidArgumentException;\nuse Kirby\\Exception\\LogicException;\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Exception\\PermissionException;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Http\\Idn;\nuse Kirby\\Http\\Request\\Auth\\BasicAuth;\nuse Kirby\\Session\\Session;\nuse Kirby\\Toolkit\\A;\nuse SensitiveParameter;\nuse Throwable;\n\n/**\n * Authentication layer\n *\n * @package   Kirby Cms\n * @author    Bastian Allgeier <bastian@getkirby.com>\n * @link      https://getkirby.com\n * @copyright Bastian Allgeier\n * @license   https://getkirby.com/license\n */\nclass Auth\n{\n\t/**\n\t * Available auth challenge classes\n\t * from the core and plugins\n\t *\n\t * @var array\n\t */\n\tpublic static $challenges = [];\n\n\t/**\n\t * Currently impersonated user\n\t *\n\t * @var \\Kirby\\Cms\\User|null\n\t */\n\tprotected $impersonate;\n\n\t/**\n\t * Kirby instance\n\t *\n\t * @var \\Kirby\\Cms\\App\n\t */\n\tprotected $kirby;\n\n\t/**\n\t * Cache of the auth status object\n\t *\n\t * @var \\Kirby\\Cms\\Auth\\Status\n\t */\n\tprotected $status;\n\n\t/**\n\t * Instance of the currently logged in user or\n\t * `false` if the user was not yet determined\n\t *\n\t * @var \\Kirby\\Cms\\User|null|false\n\t */\n\tprotected $user = false;\n\n\t/**\n\t * Exception that was thrown while\n\t * determining the current user\n\t *\n\t * @var \\Throwable\n\t */\n\tprotected $userException;\n\n\t/**\n\t * @param \\Kirby\\Cms\\App $kirby\n\t * @codeCoverageIgnore\n\t */\n\tpublic function __construct(App $kirby)\n\t{\n\t\t$this->kirby = $kirby;\n\t}\n\n\t/**\n\t * Creates an authentication challenge\n\t * (one-time auth code)\n\t * @since 3.5.0\n\t *\n\t * @param string $email\n\t * @param bool $long If `true`, a long session will be created\n\t * @param string $mode Either 'login' or 'password-reset'\n\t * @return \\Kirby\\Cms\\Auth\\Status\n\t *\n\t * @throws \\Kirby\\Exception\\LogicException If there is no suitable authentication challenge (only in debug mode)\n\t * @throws \\Kirby\\Exception\\NotFoundException If the user does not exist (only in debug mode)\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit is exceeded\n\t */\n\tpublic function createChallenge(string $email, bool $long = false, string $mode = 'login')\n\t{\n\t\t$email = Idn::decodeEmail($email);\n\n\t\t$session = $this->kirby->session([\n\t\t\t'createMode' => 'cookie',\n\t\t\t'long'       => $long === true\n\t\t]);\n\n\t\t$timeout = $this->kirby->option('auth.challenge.timeout', 10 * 60);\n\n\t\t// catch every exception to hide them from attackers\n\t\t// unless auth debugging is enabled\n\t\ttry {\n\t\t\t$this->checkRateLimit($email);\n\n\t\t\t// rate-limit the number of challenges for DoS/DDoS protection\n\t\t\t$this->track($email, false);\n\n\t\t\t// try to find the provided user\n\t\t\t$user = $this->kirby->users()->find($email);\n\t\t\tif ($user === null) {\n\t\t\t\t$this->kirby->trigger('user.login:failed', compact('email'));\n\n\t\t\t\tthrow new NotFoundException([\n\t\t\t\t\t'key'  => 'user.notFound',\n\t\t\t\t\t'data' => [\n\t\t\t\t\t\t'name' => $email\n\t\t\t\t\t]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// try to find an enabled challenge that is available for that user\n\t\t\t$challenge = null;\n\t\t\tforeach ($this->enabledChallenges() as $name) {\n\t\t\t\t$class = static::$challenges[$name] ?? null;\n\t\t\t\tif (\n\t\t\t\t\t$class &&\n\t\t\t\t\tclass_exists($class) === true &&\n\t\t\t\t\tis_subclass_of($class, Challenge::class) === true &&\n\t\t\t\t\t$class::isAvailable($user, $mode) === true\n\t\t\t\t) {\n\t\t\t\t\t$challenge = $name;\n\t\t\t\t\t$code = $class::create($user, compact('mode', 'timeout'));\n\n\t\t\t\t\t$session->set('kirby.challenge.type', $challenge);\n\n\t\t\t\t\tif ($code !== null) {\n\t\t\t\t\t\t$session->set('kirby.challenge.code', password_hash($code, PASSWORD_DEFAULT));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if no suitable challenge was found, `$challenge === null` at this point\n\t\t\tif ($challenge === null) {\n\t\t\t\tthrow new LogicException('Could not find a suitable authentication challenge');\n\t\t\t}\n\t\t} catch (Throwable $e) {\n\t\t\t// only throw the exception in auth debug mode\n\t\t\t$this->fail($e);\n\t\t}\n\n\t\t// always set the email and timeout, even if the challenge\n\t\t// won't be created; this avoids leaking whether the user exists\n\t\t$session->set('kirby.challenge.email', $email);\n\t\t$session->set('kirby.challenge.timeout', time() + $timeout);\n\n\t\t// sleep for a random amount of milliseconds\n\t\t// to make automated attacks harder and to\n\t\t// avoid leaking whether the user exists\n\t\tusleep(random_int(50000, 300000));\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\n\t\treturn $this->status($session, false);\n\t}\n\n\t/**\n\t * Returns the csrf token if it exists and if it is valid\n\t *\n\t * @return string|false\n\t */\n\tpublic function csrf()\n\t{\n\t\t// get the csrf from the header\n\t\t$fromHeader = $this->kirby->request()->csrf();\n\n\t\t// check for a predefined csrf or use the one from session\n\t\t$fromSession = $this->csrfFromSession();\n\n\t\t// compare both tokens\n\t\tif (hash_equals((string)$fromSession, (string)$fromHeader) !== true) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $fromSession;\n\t}\n\n\t/**\n\t * Returns either predefined csrf or the one from session\n\t * @since 3.6.0\n\t *\n\t * @return string\n\t */\n\tpublic function csrfFromSession(): string\n\t{\n\t\t$isDev    = $this->kirby->option('panel.dev', false) !== false;\n\t\t$fallback = $isDev ? 'dev' : $this->kirby->csrf();\n\t\treturn $this->kirby->option('api.csrf', $fallback);\n\t}\n\n\t/**\n\t * Returns the logged in user by checking\n\t * for a basic authentication header with\n\t * valid credentials\n\t *\n\t * @param \\Kirby\\Http\\Request\\Auth\\BasicAuth|null $auth\n\t * @return \\Kirby\\Cms\\User|null\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException if the authorization header is invalid\n\t * @throws \\Kirby\\Exception\\PermissionException if basic authentication is not allowed\n\t */\n\tpublic function currentUserFromBasicAuth(BasicAuth $auth = null)\n\t{\n\t\tif ($this->kirby->option('api.basicAuth', false) !== true) {\n\t\t\tthrow new PermissionException('Basic authentication is not activated');\n\t\t}\n\n\t\t// if logging in with password is disabled, basic auth cannot be possible either\n\t\t$loginMethods = $this->kirby->system()->loginMethods();\n\t\tif (isset($loginMethods['password']) !== true) {\n\t\t\tthrow new PermissionException('Login with password is not enabled');\n\t\t}\n\n\t\t// if any login method requires 2FA, basic auth without 2FA would be a weakness\n\t\tforeach ($loginMethods as $method) {\n\t\t\tif (isset($method['2fa']) === true && $method['2fa'] === true) {\n\t\t\t\tthrow new PermissionException('Basic authentication cannot be used with 2FA');\n\t\t\t}\n\t\t}\n\n\t\t$request = $this->kirby->request();\n\t\t$auth    = $auth ?? $request->auth();\n\n\t\tif (!$auth || $auth->type() !== 'basic') {\n\t\t\tthrow new InvalidArgumentException('Invalid authorization header');\n\t\t}\n\n\t\t// only allow basic auth when https is enabled or insecure requests permitted\n\t\tif ($request->ssl() === false && $this->kirby->option('api.allowInsecure', false) !== true) {\n\t\t\tthrow new PermissionException('Basic authentication is only allowed over HTTPS');\n\t\t}\n\n\t\treturn $this->validatePassword($auth->username(), $auth->password());\n\t}\n\n\t/**\n\t * Returns the currently impersonated user\n\t *\n\t * @return \\Kirby\\Cms\\User|null\n\t */\n\tpublic function currentUserFromImpersonation()\n\t{\n\t\treturn $this->impersonate;\n\t}\n\n\t/**\n\t * Returns the logged in user by checking\n\t * the current session and finding a valid\n\t * valid user id in there\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @return \\Kirby\\Cms\\User|null\n\t */\n\tpublic function currentUserFromSession($session = null)\n\t{\n\t\t$session = $this->session($session);\n\n\t\t$id = $session->data()->get('kirby.userId');\n\n\t\t// if no user is logged in, return immediately\n\t\tif (is_string($id) !== true) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// a user is logged in, ensure it exists\n\t\t$user = $this->kirby->users()->find($id);\n\t\tif ($user === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ($passwordTimestamp = $user->passwordTimestamp()) {\n\t\t\t$loginTimestamp = $session->data()->get('kirby.loginTimestamp');\n\t\t\tif (is_int($loginTimestamp) !== true) {\n\t\t\t\t// session that was created before Kirby\n\t\t\t\t// 3.5.8.3, 3.6.6.3, 3.7.5.2, 3.8.4.1 or 3.9.6\n\t\t\t\t// or when the user didn't have a password set\n\t\t\t\t$user->logout();\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// invalidate the session if the password\n\t\t\t// changed since the login\n\t\t\tif ($loginTimestamp < $passwordTimestamp) {\n\t\t\t\t$user->logout();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// in case the session needs to be updated, do it now\n\t\t// for better performance\n\t\t$session->commit();\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Returns the list of enabled challenges in the\n\t * configured order\n\t * @since 3.5.1\n\t *\n\t * @return array\n\t */\n\tpublic function enabledChallenges(): array\n\t{\n\t\treturn A::wrap($this->kirby->option('auth.challenges', ['email']));\n\t}\n\n\t/**\n\t * Become any existing user or disable the current user\n\t *\n\t * @param string|null $who User ID or email address,\n\t *                         `null` to use the actual user again,\n\t *                         `'kirby'` for a virtual admin user or\n\t *                         `'nobody'` to disable the actual user\n\t * @return \\Kirby\\Cms\\User|null\n\t * @throws \\Kirby\\Exception\\NotFoundException if the given user cannot be found\n\t */\n\tpublic function impersonate(string|null $who = null)\n\t{\n\t\t// clear the status cache\n\t\t$this->status = null;\n\n\t\treturn $this->impersonate = match ($who) {\n\t\t\tnull     => null,\n\t\t\t'kirby'  => new User([\n\t\t\t\t'email' => 'kirby@getkirby.com',\n\t\t\t\t'id'    => 'kirby',\n\t\t\t\t'role'  => 'admin',\n\t\t\t]),\n\t\t\t'nobody' => new User([\n\t\t\t\t'email' => 'nobody@getkirby.com',\n\t\t\t\t'id'    => 'nobody',\n\t\t\t\t'role'  => 'nobody',\n\t\t\t]),\n\t\t\tdefault  => ($this->kirby->users()->find($who) ?? throw new NotFoundException('The user \"' . $who . '\" cannot be found'))\n\t\t};\n\t}\n\n\t/**\n\t * Returns the hashed ip of the visitor\n\t * which is used to track invalid logins\n\t *\n\t * @return string\n\t */\n\tpublic function ipHash(): string\n\t{\n\t\t$hash = hash('sha256', $this->kirby->visitor()->ip());\n\n\t\t// only use the first 50 chars to ensure privacy\n\t\treturn substr($hash, 0, 50);\n\t}\n\n\t/**\n\t * Check if logins are blocked for the current ip or email\n\t *\n\t * @param string $email\n\t * @return bool\n\t */\n\tpublic function isBlocked(string $email): bool\n\t{\n\t\t$ip     = $this->ipHash();\n\t\t$log    = $this->log();\n\t\t$trials = $this->kirby->option('auth.trials', 10);\n\n\t\tif ($entry = ($log['by-ip'][$ip] ?? null)) {\n\t\t\tif ($entry['trials'] >= $trials) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif ($this->kirby->users()->find($email)) {\n\t\t\tif ($entry = ($log['by-email'][$email] ?? null)) {\n\t\t\t\tif ($entry['trials'] >= $trials) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Login a user by email and password\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the email was invalid\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the password is not valid (via `$user->login()`)\n\t */\n\tpublic function login(\n\t\tstring $email,\n\t\t#[SensitiveParameter]\n\t\tstring $password,\n\t\tbool $long = false\n\t): User {\n\t\t// session options\n\t\t$options = [\n\t\t\t'createMode' => 'cookie',\n\t\t\t'long'       => $long === true\n\t\t];\n\n\t\t// validate the user and log in to the session\n\t\t$user = $this->validatePassword($email, $password);\n\t\t$user->loginPasswordless($options);\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Login a user by email, password and auth challenge\n\t * @since 3.5.0\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the email was invalid\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the password is not valid (via `$user->login()`)\n\t */\n\tpublic function login2fa(\n\t\tstring $email,\n\t\t#[SensitiveParameter]\n\t\tstring $password,\n\t\tbool $long = false\n\t): Status {\n\t\t$this->validatePassword($email, $password);\n\t\treturn $this->createChallenge($email, $long, '2fa');\n\t}\n\n\t/**\n\t * Sets a user object as the current user in the cache\n\t * @internal\n\t *\n\t * @param \\Kirby\\Cms\\User $user\n\t * @return void\n\t */\n\tpublic function setUser(User $user): void\n\t{\n\t\t// stop impersonating\n\t\t$this->impersonate = null;\n\n\t\t$this->user = $user;\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\t}\n\n\t/**\n\t * Returns the authentication status object\n\t * @since 3.5.1\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @param bool $allowImpersonation If set to false, only the actually\n\t *                                 logged in user will be returned\n\t * @return \\Kirby\\Cms\\Auth\\Status\n\t */\n\tpublic function status($session = null, bool $allowImpersonation = true)\n\t{\n\t\t// try to return from cache\n\t\tif ($this->status && $session === null && $allowImpersonation === true) {\n\t\t\treturn $this->status;\n\t\t}\n\n\t\t$sessionObj = $this->session($session);\n\n\t\t$props = ['kirby' => $this->kirby];\n\t\tif ($user = $this->user($sessionObj, $allowImpersonation)) {\n\t\t\t// a user is currently logged in\n\t\t\tif ($allowImpersonation === true && $this->impersonate !== null) {\n\t\t\t\t$props['status'] = 'impersonated';\n\t\t\t} else {\n\t\t\t\t$props['status'] = 'active';\n\t\t\t}\n\n\t\t\t$props['email'] = $user->email();\n\t\t} elseif ($email = $sessionObj->get('kirby.challenge.email')) {\n\t\t\t// a challenge is currently pending\n\t\t\t$props['status']            = 'pending';\n\t\t\t$props['email']             = $email;\n\t\t\t$props['challenge']         = $sessionObj->get('kirby.challenge.type');\n\t\t\t$props['challengeFallback'] = A::last($this->enabledChallenges());\n\t\t} else {\n\t\t\t// no active authentication\n\t\t\t$props['status'] = 'inactive';\n\t\t}\n\n\t\t$status = new Status($props);\n\n\t\t// only cache the default object\n\t\tif ($session === null && $allowImpersonation === true) {\n\t\t\t$this->status = $status;\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Ensures that the rate limit was not exceeded\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded\n\t */\n\tprotected function checkRateLimit(string $email): void\n\t{\n\t\t// check for blocked ips\n\t\tif ($this->isBlocked($email) === true) {\n\t\t\t$this->kirby->trigger('user.login:failed', compact('email'));\n\n\t\t\tthrow new PermissionException([\n\t\t\t\t'details'  => ['reason' => 'rate-limited'],\n\t\t\t\t'fallback' => 'Rate limit exceeded'\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * Validates the user credentials and returns the user object on success;\n\t * otherwise logs the failed attempt\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the email was invalid\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the password is not valid (via `$user->login()`)\n\t */\n\tpublic function validatePassword(\n\t\tstring $email,\n\t\t#[SensitiveParameter]\n\t\tstring $password\n\t): User {\n\t\t$email = Idn::decodeEmail($email);\n\n\t\ttry {\n\t\t\t$this->checkRateLimit($email);\n\n\t\t\t// validate the user and its password\n\t\t\tif ($user = $this->kirby->users()->find($email)) {\n\t\t\t\tif ($user->validatePassword($password) === true) {\n\t\t\t\t\treturn $user;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new NotFoundException([\n\t\t\t\t'key'  => 'user.notFound',\n\t\t\t\t'data' => [\n\t\t\t\t\t'name' => $email\n\t\t\t\t]\n\t\t\t]);\n\t\t} catch (Throwable $e) {\n\t\t\t$details = $e instanceof Exception ? $e->getDetails() : [];\n\n\t\t\t// log invalid login trial unless the rate limit is already active\n\t\t\tif (($details['reason'] ?? null) !== 'rate-limited') {\n\t\t\t\ttry {\n\t\t\t\t\t$this->track($email);\n\t\t\t\t} catch (Throwable $e) {\n\t\t\t\t\t// $e is overwritten with the exception\n\t\t\t\t\t// from the track method if there's one\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// sleep for a random amount of milliseconds\n\t\t\t// to make automated attacks harder\n\t\t\tusleep(random_int(10000, 2000000));\n\n\t\t\t// keep throwing the original error in debug mode,\n\t\t\t// otherwise hide it to avoid leaking security-relevant information\n\t\t\t$this->fail($e, new PermissionException(['key' => 'access.login']));\n\t\t}\n\t}\n\n\t/**\n\t * Returns the absolute path to the logins log\n\t *\n\t * @return string\n\t */\n\tpublic function logfile(): string\n\t{\n\t\treturn $this->kirby->root('accounts') . '/.logins';\n\t}\n\n\t/**\n\t * Read all tracked logins\n\t *\n\t * @return array\n\t */\n\tpublic function log(): array\n\t{\n\t\ttry {\n\t\t\t$log  = Data::read($this->logfile(), 'json');\n\t\t\t$read = true;\n\t\t} catch (Throwable) {\n\t\t\t$log  = [];\n\t\t\t$read = false;\n\t\t}\n\n\t\t// ensure that the category arrays are defined\n\t\t$log['by-ip']    = $log['by-ip'] ?? [];\n\t\t$log['by-email'] = $log['by-email'] ?? [];\n\n\t\t// remove all elements on the top level with different keys (old structure)\n\t\t$log = array_intersect_key($log, array_flip(['by-ip', 'by-email']));\n\n\t\t// remove entries that are no longer needed\n\t\t$originalLog = $log;\n\t\t$time = time() - $this->kirby->option('auth.timeout', 3600);\n\t\tforeach ($log as $category => $entries) {\n\t\t\t$log[$category] = array_filter(\n\t\t\t\t$entries,\n\t\t\t\tfn ($entry) => $entry['time'] > $time\n\t\t\t);\n\t\t}\n\n\t\t// write new log to the file system if it changed\n\t\tif ($read === false || $log !== $originalLog) {\n\t\t\tif (count($log['by-ip']) === 0 && count($log['by-email']) === 0) {\n\t\t\t\tF::remove($this->logfile());\n\t\t\t} else {\n\t\t\t\tData::write($this->logfile(), $log, 'json');\n\t\t\t}\n\t\t}\n\n\t\treturn $log;\n\t}\n\n\t/**\n\t * Logout the current user\n\t *\n\t * @return void\n\t */\n\tpublic function logout(): void\n\t{\n\t\t// stop impersonating;\n\t\t// ensures that we log out the actually logged in user\n\t\t$this->impersonate = null;\n\n\t\t// logout the current user if it exists\n\t\t$this->user()?->logout();\n\n\t\t// clear the pending challenge\n\t\t$session = $this->kirby->session();\n\t\t$session->remove('kirby.challenge.code');\n\t\t$session->remove('kirby.challenge.email');\n\t\t$session->remove('kirby.challenge.timeout');\n\t\t$session->remove('kirby.challenge.type');\n\n\t\t// clear the status cache\n\t\t$this->status = null;\n\t}\n\n\t/**\n\t * Clears the cached user data after logout\n\t * @internal\n\t *\n\t * @return void\n\t */\n\tpublic function flush(): void\n\t{\n\t\t$this->impersonate = null;\n\t\t$this->status = null;\n\t\t$this->user = null;\n\t}\n\n\t/**\n\t * Tracks a login\n\t *\n\t * @param string|null $email\n\t * @param bool $triggerHook If `false`, no user.login:failed hook is triggered\n\t * @return bool\n\t */\n\tpublic function track(string|null $email, bool $triggerHook = true): bool\n\t{\n\t\tif ($triggerHook === true) {\n\t\t\t$this->kirby->trigger('user.login:failed', compact('email'));\n\t\t}\n\n\t\t$ip   = $this->ipHash();\n\t\t$log  = $this->log();\n\t\t$time = time();\n\n\t\tif (isset($log['by-ip'][$ip]) === true) {\n\t\t\t$log['by-ip'][$ip] = [\n\t\t\t\t'time'   => $time,\n\t\t\t\t'trials' => ($log['by-ip'][$ip]['trials'] ?? 0) + 1\n\t\t\t];\n\t\t} else {\n\t\t\t$log['by-ip'][$ip] = [\n\t\t\t\t'time'   => $time,\n\t\t\t\t'trials' => 1\n\t\t\t];\n\t\t}\n\n\t\tif ($email !== null && $this->kirby->users()->find($email)) {\n\t\t\tif (isset($log['by-email'][$email]) === true) {\n\t\t\t\t$log['by-email'][$email] = [\n\t\t\t\t\t'time'   => $time,\n\t\t\t\t\t'trials' => ($log['by-email'][$email]['trials'] ?? 0) + 1\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\t$log['by-email'][$email] = [\n\t\t\t\t\t'time'   => $time,\n\t\t\t\t\t'trials' => 1\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn Data::write($this->logfile(), $log, 'json');\n\t}\n\n\t/**\n\t * Returns the current authentication type\n\t *\n\t * @param bool $allowImpersonation If set to false, 'impersonate' won't\n\t *                                 be returned as authentication type\n\t *                                 even if an impersonation is active\n\t * @return string\n\t */\n\tpublic function type(bool $allowImpersonation = true): string\n\t{\n\t\t$basicAuth = $this->kirby->option('api.basicAuth', false);\n\t\t$request   = $this->kirby->request();\n\n\t\tif (\n\t\t\t$basicAuth === true &&\n\n\t\t\t// only get the auth object if the option is enabled\n\t\t\t// to avoid triggering `$responder->usesAuth()` if\n\t\t\t// the option is disabled\n\t\t\t$request->auth() &&\n\t\t\t$request->auth()->type() === 'basic'\n\t\t) {\n\t\t\treturn 'basic';\n\t\t}\n\n\t\tif ($allowImpersonation === true && $this->impersonate !== null) {\n\t\t\treturn 'impersonate';\n\t\t}\n\n\t\treturn 'session';\n\t}\n\n\t/**\n\t * Validates the currently logged in user\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @param bool $allowImpersonation If set to false, only the actually\n\t *                                 logged in user will be returned\n\t * @return \\Kirby\\Cms\\User|null\n\t *\n\t * @throws \\Throwable If an authentication error occurred\n\t */\n\tpublic function user($session = null, bool $allowImpersonation = true)\n\t{\n\t\tif ($allowImpersonation === true && $this->impersonate !== null) {\n\t\t\treturn $this->impersonate;\n\t\t}\n\n\t\t// return from cache\n\t\tif ($this->user === null) {\n\t\t\t// throw the same Exception again if one was captured before\n\t\t\tif ($this->userException !== null) {\n\t\t\t\tthrow $this->userException;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif ($this->user !== false) {\n\t\t\treturn $this->user;\n\t\t}\n\n\t\ttry {\n\t\t\tif ($this->type() === 'basic') {\n\t\t\t\treturn $this->user = $this->currentUserFromBasicAuth();\n\t\t\t}\n\n\t\t\treturn $this->user = $this->currentUserFromSession($session);\n\t\t} catch (Throwable $e) {\n\t\t\t$this->user = null;\n\n\t\t\t// capture the Exception for future calls\n\t\t\t$this->userException = $e;\n\n\t\t\tthrow $e;\n\t\t}\n\t}\n\n\t/**\n\t * Verifies an authentication code that was\n\t * requested with the `createChallenge()` method;\n\t * if successful, the user is automatically logged in\n\t * @since 3.5.0\n\t *\n\t * @param string $code User-provided auth code to verify\n\t * @return \\Kirby\\Cms\\User User object of the logged-in user\n\t *\n\t * @throws \\Kirby\\Exception\\PermissionException If the rate limit was exceeded, the challenge timed out, the code\n\t *                                              is incorrect or if any other error occurred with debug mode off\n\t * @throws \\Kirby\\Exception\\NotFoundException If the user from the challenge doesn't exist\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If no authentication challenge is active\n\t * @throws \\Kirby\\Exception\\LogicException If the authentication challenge is invalid\n\t */\n\tpublic function verifyChallenge(\n\t\t#[SensitiveParameter]\n\t\tstring $code\n\t) {\n\t\ttry {\n\t\t\t$session = $this->kirby->session();\n\n\t\t\t// time-limiting; check this early so that we can destroy the session no\n\t\t\t// matter if the user exists (avoids leaking user information to attackers)\n\t\t\t$timeout = $session->get('kirby.challenge.timeout');\n\t\t\tif ($timeout !== null && time() > $timeout) {\n\t\t\t\t// this challenge can never be completed,\n\t\t\t\t// so delete it immediately\n\t\t\t\t$this->logout();\n\n\t\t\t\tthrow new PermissionException([\n\t\t\t\t\t'details'  => ['challengeDestroyed' => true],\n\t\t\t\t\t'fallback' => 'Authentication challenge timeout'\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// check if we have an active challenge\n\t\t\t$email     = $session->get('kirby.challenge.email');\n\t\t\t$challenge = $session->get('kirby.challenge.type');\n\t\t\tif (is_string($email) !== true || is_string($challenge) !== true) {\n\t\t\t\t// if the challenge timed out on the previous request, the\n\t\t\t\t// challenge data was already deleted from the session, so we can\n\t\t\t\t// set `challengeDestroyed` to `true` in this response as well;\n\t\t\t\t// however we must only base this on the email, not the type\n\t\t\t\t// (otherwise \"faked\" challenges would be leaked)\n\t\t\t\t$challengeDestroyed = is_string($email) !== true;\n\n\t\t\t\tthrow new InvalidArgumentException([\n\t\t\t\t\t'details'  => compact('challengeDestroyed'),\n\t\t\t\t\t'fallback' => 'No authentication challenge is active'\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t$user = $this->kirby->users()->find($email);\n\t\t\tif ($user === null) {\n\t\t\t\tthrow new NotFoundException([\n\t\t\t\t\t'key'  => 'user.notFound',\n\t\t\t\t\t'data' => [\n\t\t\t\t\t\t'name' => $email\n\t\t\t\t\t]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// rate-limiting\n\t\t\t$this->checkRateLimit($email);\n\n\t\t\tif (\n\t\t\t\tisset(static::$challenges[$challenge]) === true &&\n\t\t\t\tclass_exists(static::$challenges[$challenge]) === true &&\n\t\t\t\tis_subclass_of(static::$challenges[$challenge], Challenge::class) === true\n\t\t\t) {\n\t\t\t\t$class = static::$challenges[$challenge];\n\t\t\t\tif ($class::verify($user, $code) === true) {\n\t\t\t\t\t$this->logout();\n\t\t\t\t\t$user->loginPasswordless();\n\n\t\t\t\t\t// clear the status cache\n\t\t\t\t\t$this->status = null;\n\n\t\t\t\t\treturn $user;\n\t\t\t\t}\n\n\t\t\t\tthrow new PermissionException(['key' => 'access.code']);\n\t\t\t}\n\n\t\t\tthrow new LogicException('Invalid authentication challenge: ' . $challenge);\n\t\t} catch (Throwable $e) {\n\t\t\t$details = $e instanceof \\Kirby\\Exception\\Exception ? $e->getDetails() : [];\n\n\t\t\tif (\n\t\t\t\tempty($email) === false &&\n\t\t\t\t($details['reason'] ?? null) !== 'rate-limited'\n\t\t\t) {\n\t\t\t\t$this->track($email);\n\t\t\t}\n\n\t\t\t// sleep for a random amount of milliseconds\n\t\t\t// to make automated attacks harder and to\n\t\t\t// avoid leaking whether the user exists\n\t\t\tusleep(random_int(10000, 2000000));\n\n\t\t\t// specifically copy over the marker for a destroyed challenge\n\t\t\t// even in production (used by the Panel to reset to the login form)\n\t\t\t$challengeDestroyed = $details['challengeDestroyed'] ?? false;\n\n\t\t\t$fallback = new PermissionException([\n\t\t\t\t'details' => compact('challengeDestroyed'),\n\t\t\t\t'key'     => 'access.code'\n\t\t\t]);\n\n\t\t\t// keep throwing the original error in debug mode,\n\t\t\t// otherwise hide it to avoid leaking security-relevant information\n\t\t\t$this->fail($e, $fallback);\n\t\t}\n\t}\n\n\t/**\n\t * Throws an exception only in debug mode, otherwise falls back\n\t * to a public error without sensitive information\n\t *\n\t * @throws \\Throwable Either the passed `$exception` or the `$fallback`\n\t *                    (no exception if debugging is disabled and no fallback was passed)\n\t */\n\tprotected function fail(Throwable $exception, Throwable $fallback = null): void\n\t{\n\t\t$debug = $this->kirby->option('auth.debug', 'log');\n\n\t\t// throw the original exception only in debug mode\n\t\tif ($debug === true) {\n\t\t\tthrow $exception;\n\t\t}\n\n\t\t// otherwise hide the real error and only print it to the error log\n\t\t// unless disabled by setting `auth.debug` to `false`\n\t\tif ($debug === 'log') {\n\t\t\terror_log($exception); // @codeCoverageIgnore\n\t\t}\n\n\t\t// only throw an error in production if requested by the calling method\n\t\tif ($fallback !== null) {\n\t\t\tthrow $fallback;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a session object from the passed options\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session\n\t * @return \\Kirby\\Session\\Session\n\t */\n\tprotected function session($session = null)\n\t{\n\t\t// use passed session options or session object if set\n\t\tif (is_array($session) === true) {\n\t\t\treturn $this->kirby->session($session);\n\t\t}\n\n\t\t// try session in header or cookie\n\t\tif ($session instanceof Session === false) {\n\t\t\treturn $this->kirby->session(['detect' => true]);\n\t\t}\n\n\t\treturn $session;\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Exception;\nuse Kirby\\Exception\\InvalidArgumentException;\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Panel\\User as Panel;\nuse Kirby\\Session\\Session;\nuse Kirby\\Toolkit\\Str;\nuse SensitiveParameter;\n\n/**\n * The `$user` object represents a\n * single Panel or frontend user.\n *\n * @package   Kirby Cms\n * @author    Bastian Allgeier <bastian@getkirby.com>\n * @link      https://getkirby.com\n * @copyright Bastian Allgeier\n * @license   https://getkirby.com/license\n */\nclass User extends ModelWithContent\n{\n\tuse HasFiles;\n\tuse HasMethods;\n\tuse HasSiblings;\n\tuse UserActions;\n\n\tpublic const CLASS_ALIAS = 'user';\n\n\t/**\n\t * @var UserBlueprint\n\t */\n\tprotected $blueprint;\n\n\t/**\n\t * @var array\n\t */\n\tprotected $credentials;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $email;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $hash;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $id;\n\n\t/**\n\t * @var array|null\n\t */\n\tprotected $inventory;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $language;\n\n\t/**\n\t * All registered user methods\n\t *\n\t * @var array\n\t */\n\tpublic static $methods = [];\n\n\t/**\n\t * Registry with all User models\n\t *\n\t * @var array\n\t */\n\tpublic static $models = [];\n\n\t/**\n\t * @var \\Kirby\\Cms\\Field\n\t */\n\tprotected $name;\n\n\t/**\n\t * @var string\n\t */\n\tprotected $password;\n\n\t/**\n\t * The user role\n\t *\n\t * @var string\n\t */\n\tprotected $role;\n\n\t/**\n\t * Modified getter to also return fields\n\t * from the content\n\t *\n\t * @param string $method\n\t * @param array $arguments\n\t * @return mixed\n\t */\n\tpublic function __call(string $method, array $arguments = [])\n\t{\n\t\t// public property access\n\t\tif (isset($this->$method) === true) {\n\t\t\treturn $this->$method;\n\t\t}\n\n\t\t// user methods\n\t\tif ($this->hasMethod($method)) {\n\t\t\treturn $this->callMethod($method, $arguments);\n\t\t}\n\n\t\t// return site content otherwise\n\t\treturn $this->content()->get($method);\n\t}\n\n\t/**\n\t * Creates a new User object\n\t *\n\t * @param array $props\n\t */\n\tpublic function __construct(array $props)\n\t{\n\t\t// TODO: refactor later to avoid redundant prop setting\n\t\t$this->setProperty('id', $props['id'] ?? $this->createId(), true);\n\t\t$this->setProperties($props);\n\t}\n\n\t/**\n\t * Improved `var_dump` output\n\t *\n\t * @return array\n\t */\n\tpublic function __debugInfo(): array\n\t{\n\t\treturn array_merge($this->toArray(), [\n\t\t\t'avatar'  => $this->avatar(),\n\t\t\t'content' => $this->content(),\n\t\t\t'role'    => $this->role()\n\t\t]);\n\t}\n\n\t/**\n\t * Returns the url to the api endpoint\n\t *\n\t * @internal\n\t * @param bool $relative\n\t * @return string\n\t */\n\tpublic function apiUrl(bool $relative = false): string\n\t{\n\t\tif ($relative === true) {\n\t\t\treturn 'users/' . $this->id();\n\t\t}\n\n\t\treturn $this->kirby()->url('api') . '/users/' . $this->id();\n\t}\n\n\t/**\n\t * Returns the File object for the avatar or null\n\t *\n\t * @return \\Kirby\\Cms\\File|null\n\t */\n\tpublic function avatar()\n\t{\n\t\treturn $this->files()->template('avatar')->first();\n\t}\n\n\t/**\n\t * Returns the UserBlueprint object\n\t *\n\t * @return \\Kirby\\Cms\\Blueprint\n\t */\n\tpublic function blueprint()\n\t{\n\t\tif ($this->blueprint instanceof Blueprint) {\n\t\t\treturn $this->blueprint;\n\t\t}\n\n\t\ttry {\n\t\t\treturn $this->blueprint = UserBlueprint::factory('users/' . $this->role(), 'users/default', $this);\n\t\t} catch (Exception) {\n\t\t\treturn $this->blueprint = new UserBlueprint([\n\t\t\t\t'model' => $this,\n\t\t\t\t'name'  => 'default',\n\t\t\t\t'title' => 'Default',\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * Prepares the content for the write method\n\t *\n\t * @internal\n\t * @param array $data\n\t * @param string $languageCode|null Not used so far\n\t * @return array\n\t */\n\tpublic function contentFileData(array $data, string $languageCode = null): array\n\t{\n\t\t// remove stuff that has nothing to do in the text files\n\t\tunset(\n\t\t\t$data['email'],\n\t\t\t$data['language'],\n\t\t\t$data['name'],\n\t\t\t$data['password'],\n\t\t\t$data['role']\n\t\t);\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Filename for the content file\n\t *\n\t * @internal\n\t * @return string\n\t */\n\tpublic function contentFileName(): string\n\t{\n\t\treturn 'user';\n\t}\n\n\tprotected function credentials(): array\n\t{\n\t\treturn $this->credentials ??= $this->readCredentials();\n\t}\n\n\t/**\n\t * Returns the user email address\n\t *\n\t * @return string\n\t */\n\tpublic function email(): string|null\n\t{\n\t\treturn $this->email ??= $this->credentials()['email'] ?? null;\n\t}\n\n\t/**\n\t * Checks if the user exists\n\t *\n\t * @return bool\n\t */\n\tpublic function exists(): bool\n\t{\n\t\treturn is_file($this->contentFile('default')) === true;\n\t}\n\n\t/**\n\t * Constructs a User object and also\n\t * takes User models into account.\n\t *\n\t * @internal\n\t * @param mixed $props\n\t * @return static\n\t */\n\tpublic static function factory($props)\n\t{\n\t\tif (empty($props['model']) === false) {\n\t\t\treturn static::model($props['model'], $props);\n\t\t}\n\n\t\treturn new static($props);\n\t}\n\n\t/**\n\t * Hashes the user's password unless it is `null`,\n\t * which will leave it as `null`\n\t *\n\t * @internal\n\t */\n\tpublic static function hashPassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): string|null {\n\t\tif ($password !== null) {\n\t\t\t$password = password_hash($password, PASSWORD_DEFAULT);\n\t\t}\n\n\t\treturn $password;\n\t}\n\n\t/**\n\t * Returns the user id\n\t *\n\t * @return string\n\t */\n\tpublic function id(): string\n\t{\n\t\treturn $this->id;\n\t}\n\n\t/**\n\t * Returns the inventory of files\n\t * children and content files\n\t *\n\t * @return array\n\t */\n\tpublic function inventory(): array\n\t{\n\t\tif ($this->inventory !== null) {\n\t\t\treturn $this->inventory;\n\t\t}\n\n\t\t$kirby = $this->kirby();\n\n\t\treturn $this->inventory = Dir::inventory(\n\t\t\t$this->root(),\n\t\t\t$kirby->contentExtension(),\n\t\t\t$kirby->contentIgnore(),\n\t\t\t$kirby->multilang()\n\t\t);\n\t}\n\n\t/**\n\t * Compares the current object with the given user object\n\t *\n\t * @param \\Kirby\\Cms\\User|null $user\n\t * @return bool\n\t */\n\tpublic function is(User $user = null): bool\n\t{\n\t\tif ($user === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $this->id() === $user->id();\n\t}\n\n\t/**\n\t * Checks if this user has the admin role\n\t *\n\t * @return bool\n\t */\n\tpublic function isAdmin(): bool\n\t{\n\t\treturn $this->role()->id() === 'admin';\n\t}\n\n\t/**\n\t * Checks if the current user is the virtual\n\t * Kirby user\n\t *\n\t * @return bool\n\t */\n\tpublic function isKirby(): bool\n\t{\n\t\treturn $this->email() === 'kirby@getkirby.com';\n\t}\n\n\t/**\n\t * Checks if the current user is this user\n\t *\n\t * @return bool\n\t */\n\tpublic function isLoggedIn(): bool\n\t{\n\t\treturn $this->is($this->kirby()->user());\n\t}\n\n\t/**\n\t * Checks if the user is the last one\n\t * with the admin role\n\t *\n\t * @return bool\n\t */\n\tpublic function isLastAdmin(): bool\n\t{\n\t\treturn\n\t\t\t$this->role()->isAdmin() === true &&\n\t\t\t$this->kirby()->users()->filter('role', 'admin')->count() <= 1;\n\t}\n\n\t/**\n\t * Checks if the user is the last user\n\t *\n\t * @return bool\n\t */\n\tpublic function isLastUser(): bool\n\t{\n\t\treturn $this->kirby()->users()->count() === 1;\n\t}\n\n\t/**\n\t * Checks if the current user is the virtual\n\t * Nobody user\n\t *\n\t * @return bool\n\t */\n\tpublic function isNobody(): bool\n\t{\n\t\treturn $this->email() === 'nobody@getkirby.com';\n\t}\n\n\t/**\n\t * Returns the user language\n\t *\n\t * @return string\n\t */\n\tpublic function language(): string\n\t{\n\t\treturn $this->language ??= $this->credentials()['language'] ?? $this->kirby()->panelLanguage();\n\t}\n\n\t/**\n\t * Logs the user in\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session Session options or session object to set the user in\n\t */\n\tpublic function login(\n\t\t#[SensitiveParameter]\n\t\tstring $password,\n\t\t$session = null\n\t): bool {\n\t\t$this->validatePassword($password);\n\t\t$this->loginPasswordless($session);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Logs the user in without checking the password\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session Session options or session object to set the user in\n\t * @return void\n\t */\n\tpublic function loginPasswordless($session = null): void\n\t{\n\t\t$kirby = $this->kirby();\n\n\t\t$session = $this->sessionFromOptions($session);\n\n\t\t$kirby->trigger('user.login:before', ['user' => $this, 'session' => $session]);\n\n\t\t$session->regenerateToken(); // privilege change\n\t\t$session->data()->set('kirby.userId', $this->id());\n\t\tif ($this->passwordTimestamp() !== null) {\n\t\t\t$session->data()->set('kirby.loginTimestamp', time());\n\t\t}\n\t\t$this->kirby()->auth()->setUser($this);\n\n\t\t$kirby->trigger('user.login:after', ['user' => $this, 'session' => $session]);\n\t}\n\n\t/**\n\t * Logs the user out\n\t *\n\t * @param \\Kirby\\Session\\Session|array|null $session Session options or session object to unset the user in\n\t * @return void\n\t */\n\tpublic function logout($session = null): void\n\t{\n\t\t$kirby   = $this->kirby();\n\t\t$session = $this->sessionFromOptions($session);\n\n\t\t$kirby->trigger('user.logout:before', ['user' => $this, 'session' => $session]);\n\n\t\t// remove the user from the session for future requests\n\t\t$session->data()->remove('kirby.userId');\n\t\t$session->data()->remove('kirby.loginTimestamp');\n\n\t\t// clear the cached user object from the app state of the current request\n\t\t$this->kirby()->auth()->flush();\n\n\t\tif ($session->data()->get() === []) {\n\t\t\t// session is now empty, we might as well destroy it\n\t\t\t$session->destroy();\n\n\t\t\t$kirby->trigger('user.logout:after', ['user' => $this, 'session' => null]);\n\t\t} else {\n\t\t\t// privilege change\n\t\t\t$session->regenerateToken();\n\n\t\t\t$kirby->trigger('user.logout:after', ['user' => $this, 'session' => $session]);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the root to the media folder for the user\n\t *\n\t * @internal\n\t * @return string\n\t */\n\tpublic function mediaRoot(): string\n\t{\n\t\treturn $this->kirby()->root('media') . '/users/' . $this->id();\n\t}\n\n\t/**\n\t * Returns the media url for the user object\n\t *\n\t * @internal\n\t * @return string\n\t */\n\tpublic function mediaUrl(): string\n\t{\n\t\treturn $this->kirby()->url('media') . '/users/' . $this->id();\n\t}\n\n\t/**\n\t * Creates a user model if it has been registered\n\t *\n\t * @internal\n\t * @param string $name\n\t * @param array $props\n\t * @return \\Kirby\\Cms\\User\n\t */\n\tpublic static function model(string $name, array $props = [])\n\t{\n\t\tif ($class = (static::$models[$name] ?? null)) {\n\t\t\t$object = new $class($props);\n\n\t\t\tif ($object instanceof self) {\n\t\t\t\treturn $object;\n\t\t\t}\n\t\t}\n\n\t\treturn new static($props);\n\t}\n\n\t/**\n\t * Returns the last modification date of the user\n\t *\n\t * @param string $format\n\t * @param string|null $handler\n\t * @param string|null $languageCode\n\t * @return int|string\n\t */\n\tpublic function modified(string $format = 'U', string $handler = null, string $languageCode = null)\n\t{\n\t\t$modifiedContent = F::modified($this->contentFile($languageCode));\n\t\t$modifiedIndex   = F::modified($this->root() . '/index.php');\n\t\t$modifiedTotal   = max([$modifiedContent, $modifiedIndex]);\n\t\t$handler       ??= $this->kirby()->option('date.handler', 'date');\n\n\t\treturn Str::date($modifiedTotal, $format, $handler);\n\t}\n\n\t/**\n\t * Returns the user's name\n\t *\n\t * @return \\Kirby\\Cms\\Field\n\t */\n\tpublic function name()\n\t{\n\t\tif (is_string($this->name) === true) {\n\t\t\treturn new Field($this, 'name', $this->name);\n\t\t}\n\n\t\tif ($this->name !== null) {\n\t\t\treturn $this->name;\n\t\t}\n\n\t\treturn $this->name = new Field($this, 'name', $this->credentials()['name'] ?? null);\n\t}\n\n\t/**\n\t * Returns the user's name or,\n\t * if empty, the email address\n\t *\n\t * @return \\Kirby\\Cms\\Field\n\t */\n\tpublic function nameOrEmail()\n\t{\n\t\t$name = $this->name();\n\t\treturn $name->isNotEmpty() ? $name : new Field($this, 'email', $this->email());\n\t}\n\n\t/**\n\t * Create a dummy nobody\n\t *\n\t * @internal\n\t * @return static\n\t */\n\tpublic static function nobody()\n\t{\n\t\treturn new static([\n\t\t\t'email' => 'nobody@getkirby.com',\n\t\t\t'role'  => 'nobody'\n\t\t]);\n\t}\n\n\t/**\n\t * Returns the panel info object\n\t *\n\t * @return \\Kirby\\Panel\\User\n\t */\n\tpublic function panel()\n\t{\n\t\treturn new Panel($this);\n\t}\n\n\t/**\n\t * Returns the encrypted user password\n\t *\n\t * @return string|null\n\t */\n\tpublic function password(): string|null\n\t{\n\t\tif ($this->password !== null) {\n\t\t\treturn $this->password;\n\t\t}\n\n\t\treturn $this->password = $this->readPassword();\n\t}\n\n\t/**\n\t * Returns the timestamp when the password\n\t * was last changed\n\t */\n\tpublic function passwordTimestamp(): int|null\n\t{\n\t\t$file = $this->passwordFile();\n\n\t\t// ensure we have the latest information\n\t\t// to prevent cache attacks\n\t\tclearstatcache();\n\n\t\t// user does not have a password\n\t\tif (is_file($file) === false) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn filemtime($file);\n\t}\n\n\t/**\n\t * @return \\Kirby\\Cms\\UserPermissions\n\t */\n\tpublic function permissions()\n\t{\n\t\treturn new UserPermissions($this);\n\t}\n\n\t/**\n\t * Returns the user role\n\t *\n\t * @return \\Kirby\\Cms\\Role\n\t */\n\tpublic function role()\n\t{\n\t\tif ($this->role instanceof Role) {\n\t\t\treturn $this->role;\n\t\t}\n\n\t\t$name = $this->role ?? $this->credentials()['role'] ?? 'visitor';\n\n\t\treturn $this->role = $this->kirby()->roles()->find($name) ?? Role::nobody();\n\t}\n\n\t/**\n\t * Returns all available roles\n\t * for this user, that can be selected\n\t * by the authenticated user\n\t *\n\t * @return \\Kirby\\Cms\\Roles\n\t */\n\tpublic function roles()\n\t{\n\t\t$kirby = $this->kirby();\n\t\t$roles = $kirby->roles();\n\n\t\t// a collection with just the one role of the user\n\t\t$myRole = $roles->filter('id', $this->role()->id());\n\n\t\t// if there's an authenticated user \u2026\n\t\t// admin users can select pretty much any role\n\t\tif ($kirby->user()?->isAdmin() === true) {\n\t\t\t// except if the user is the last admin\n\t\t\tif ($this->isLastAdmin() === true) {\n\t\t\t\t// in which case they have to stay admin\n\t\t\t\treturn $myRole;\n\t\t\t}\n\n\t\t\t// return all roles for mighty admins\n\t\t\treturn $roles;\n\t\t}\n\n\t\t// any other user can only keep their role\n\t\treturn $myRole;\n\t}\n\n\t/**\n\t * The absolute path to the user directory\n\t *\n\t * @return string\n\t */\n\tpublic function root(): string\n\t{\n\t\treturn $this->kirby()->root('accounts') . '/' . $this->id();\n\t}\n\n\t/**\n\t * Returns the UserRules class to\n\t * validate any important action.\n\t *\n\t * @return \\Kirby\\Cms\\UserRules\n\t */\n\tprotected function rules()\n\t{\n\t\treturn new UserRules();\n\t}\n\n\t/**\n\t * Sets the Blueprint object\n\t *\n\t * @param array|null $blueprint\n\t * @return $this\n\t */\n\tprotected function setBlueprint(array $blueprint = null)\n\t{\n\t\tif ($blueprint !== null) {\n\t\t\t$blueprint['model'] = $this;\n\t\t\t$this->blueprint = new UserBlueprint($blueprint);\n\t\t}\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user email\n\t *\n\t * @param string $email|null\n\t * @return $this\n\t */\n\tprotected function setEmail(string $email = null)\n\t{\n\t\tif ($email !== null) {\n\t\t\t$this->email = Str::lower(trim($email));\n\t\t}\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user id\n\t *\n\t * @param string $id|null\n\t * @return $this\n\t */\n\tprotected function setId(string $id = null)\n\t{\n\t\t$this->id = $id;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user language\n\t *\n\t * @param string $language|null\n\t * @return $this\n\t */\n\tprotected function setLanguage(string $language = null)\n\t{\n\t\t$this->language = $language !== null ? trim($language) : null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user name\n\t *\n\t * @param string $name|null\n\t * @return $this\n\t */\n\tprotected function setName(string $name = null)\n\t{\n\t\t$this->name = $name !== null ? trim(strip_tags($name)) : null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user's password hash\n\t *\n\t * @return $this\n\t */\n\tprotected function setPassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): static {\n\t\t$this->password = $password;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Sets the user role\n\t *\n\t * @param string $role|null\n\t * @return $this\n\t */\n\tprotected function setRole(string $role = null)\n\t{\n\t\t$this->role = $role !== null ? Str::lower(trim($role)) : null;\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Converts session options into a session object\n\t *\n\t * @param \\Kirby\\Session\\Session|array $session Session options or session object to unset the user in\n\t * @return \\Kirby\\Session\\Session\n\t */\n\tprotected function sessionFromOptions($session)\n\t{\n\t\t// use passed session options or session object if set\n\t\tif (is_array($session) === true) {\n\t\t\t$session = $this->kirby()->session($session);\n\t\t} elseif ($session instanceof Session === false) {\n\t\t\t$session = $this->kirby()->session(['detect' => true]);\n\t\t}\n\n\t\treturn $session;\n\t}\n\n\t/**\n\t * Returns the parent Users collection\n\t *\n\t * @return \\Kirby\\Cms\\Users\n\t */\n\tprotected function siblingsCollection()\n\t{\n\t\treturn $this->kirby()->users();\n\t}\n\n\t/**\n\t * Converts the most important user properties\n\t * to an array\n\t *\n\t * @return array\n\t */\n\tpublic function toArray(): array\n\t{\n\t\treturn [\n\t\t\t'avatar'   => $this->avatar() ? $this->avatar()->toArray() : null,\n\t\t\t'content'  => $this->content()->toArray(),\n\t\t\t'email'    => $this->email(),\n\t\t\t'id'       => $this->id(),\n\t\t\t'language' => $this->language(),\n\t\t\t'role'     => $this->role()->name(),\n\t\t\t'username' => $this->username()\n\t\t];\n\t}\n\n\t/**\n\t * String template builder\n\t *\n\t * @param string|null $template\n\t * @param array|null $data\n\t * @param string|null $fallback Fallback for tokens in the template that cannot be replaced\n\t *                              (`null` to keep the original token)\n\t * @return string\n\t */\n\tpublic function toString(string $template = null, array $data = [], string|null $fallback = '', string $handler = 'template'): string\n\t{\n\t\t$template ??= $this->email();\n\t\treturn parent::toString($template, $data, $fallback, $handler);\n\t}\n\n\t/**\n\t * Returns the username\n\t * which is the given name or the email\n\t * as a fallback\n\t *\n\t * @return string|null\n\t */\n\tpublic function username(): string|null\n\t{\n\t\treturn $this->name()->or($this->email())->value();\n\t}\n\n\t/**\n\t * Compares the given password with the stored one\n\t *\n\t * @throws \\Kirby\\Exception\\NotFoundException If the user has no password\n\t * @throws \\Kirby\\Exception\\InvalidArgumentException If the entered password is not valid\n\t *                                                   or does not match the user password\n\t */\n\tpublic function validatePassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): bool {\n\t\tif (empty($this->password()) === true) {\n\t\t\tthrow new NotFoundException(['key' => 'user.password.undefined']);\n\t\t}\n\n\t\t// `UserRules` enforces a minimum length of 8 characters,\n\t\t// so everything below that is a typo\n\t\tif (Str::length($password) < 8) {\n\t\t\tthrow new InvalidArgumentException(['key' => 'user.password.invalid']);\n\t\t}\n\n\t\t// too long passwords can cause DoS attacks\n\t\tif (Str::length($password) > 1000) {\n\t\t\tthrow new InvalidArgumentException(['key' => 'user.password.excessive']);\n\t\t}\n\n\t\tif (password_verify($password, $this->password()) !== true) {\n\t\t\tthrow new InvalidArgumentException(['key' => 'user.password.wrong', 'httpCode' => 401]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the path to the password file\n\t */\n\tprotected function passwordFile(): string\n\t{\n\t\treturn $this->root() . '/.htpasswd';\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Closure;\nuse Kirby\\Data\\Data;\nuse Kirby\\Exception\\LogicException;\nuse Kirby\\Exception\\PermissionException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Form\\Form;\nuse Kirby\\Http\\Idn;\nuse Kirby\\Toolkit\\Str;\nuse SensitiveParameter;\nuse Throwable;\n\n/**\n * UserActions\n *\n * @package   Kirby Cms\n * @author    Bastian Allgeier <bastian@getkirby.com>\n * @link      https://getkirby.com\n * @copyright Bastian Allgeier\n * @license   https://getkirby.com/license\n */\ntrait UserActions\n{\n\t/**\n\t * Changes the user email address\n\t *\n\t * @param string $email\n\t * @return static\n\t */\n\tpublic function changeEmail(string $email)\n\t{\n\t\t$email = trim($email);\n\n\t\treturn $this->commit('changeEmail', ['user' => $this, 'email' => Idn::decodeEmail($email)], function ($user, $email) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'email' => $email\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'email' => $email\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the user language\n\t *\n\t * @param string $language\n\t * @return static\n\t */\n\tpublic function changeLanguage(string $language)\n\t{\n\t\treturn $this->commit('changeLanguage', ['user' => $this, 'language' => $language], function ($user, $language) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'language' => $language,\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'language' => $language\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the screen name of the user\n\t *\n\t * @param string $name\n\t * @return static\n\t */\n\tpublic function changeName(string $name)\n\t{\n\t\t$name = trim($name);\n\n\t\treturn $this->commit('changeName', ['user' => $this, 'name' => $name], function ($user, $name) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'name' => $name\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'name' => $name\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the user password\n\t */\n\tpublic function changePassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password\n\t): static {\n\t\treturn $this->commit('changePassword', ['user' => $this, 'password' => $password], function ($user, $password) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'password' => $password = User::hashPassword($password)\n\t\t\t]);\n\n\t\t\t$user->writePassword($password);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\t// keep the user logged in to the current browser\n\t\t\t// if they changed their own password\n\t\t\t// (regenerate the session token, update the login timestamp)\n\t\t\tif ($user->isLoggedIn() === true) {\n\t\t\t\t$user->loginPasswordless();\n\t\t\t}\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the user role\n\t *\n\t * @param string $role\n\t * @return static\n\t */\n\tpublic function changeRole(string $role)\n\t{\n\t\treturn $this->commit('changeRole', ['user' => $this, 'role' => $role], function ($user, $role) {\n\t\t\t$user = $user->clone([\n\t\t\t\t'role' => $role,\n\t\t\t]);\n\n\t\t\t$user->updateCredentials([\n\t\t\t\t'role' => $role\n\t\t\t]);\n\n\t\t\t// update the users collection\n\t\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\t\treturn $user;\n\t\t});\n\t}\n\n\t/**\n\t * Commits a user action, by following these steps\n\t *\n\t * 1. checks the action rules\n\t * 2. sends the before hook\n\t * 3. commits the action\n\t * 4. sends the after hook\n\t * 5. returns the result\n\t *\n\t * @param string $action\n\t * @param array $arguments\n\t * @param \\Closure $callback\n\t * @return mixed\n\t * @throws \\Kirby\\Exception\\PermissionException\n\t */\n\tprotected function commit(string $action, array $arguments, Closure $callback)\n\t{\n\t\tif ($this->isKirby() === true) {\n\t\t\tthrow new PermissionException('The Kirby user cannot be changed');\n\t\t}\n\n\t\t$old            = $this->hardcopy();\n\t\t$kirby          = $this->kirby();\n\t\t$argumentValues = array_values($arguments);\n\n\t\t$this->rules()->$action(...$argumentValues);\n\t\t$kirby->trigger('user.' . $action . ':before', $arguments);\n\n\t\t$result = $callback(...$argumentValues);\n\n\t\tif ($action === 'create') {\n\t\t\t$argumentsAfter = ['user' => $result];\n\t\t} elseif ($action === 'delete') {\n\t\t\t$argumentsAfter = ['status' => $result, 'user' => $old];\n\t\t} else {\n\t\t\t$argumentsAfter = ['newUser' => $result, 'oldUser' => $old];\n\t\t}\n\t\t$kirby->trigger('user.' . $action . ':after', $argumentsAfter);\n\n\t\t$kirby->cache('pages')->flush();\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Creates a new User from the given props and returns a new User object\n\t *\n\t * @param array|null $props\n\t * @return static\n\t */\n\tpublic static function create(array $props = null)\n\t{\n\t\t$data = $props;\n\n\t\tif (isset($props['email']) === true) {\n\t\t\t$data['email'] = Idn::decodeEmail($props['email']);\n\t\t}\n\n\t\tif (isset($props['password']) === true) {\n\t\t\t$data['password'] = User::hashPassword($props['password']);\n\t\t}\n\n\t\t$props['role'] = $props['model'] = strtolower($props['role'] ?? 'default');\n\n\t\t$user = User::factory($data);\n\n\t\t// create a form for the user\n\t\t$form = Form::for($user, [\n\t\t\t'values' => $props['content'] ?? []\n\t\t]);\n\n\t\t// inject the content\n\t\t$user = $user->clone(['content' => $form->strings(true)]);\n\n\t\t// run the hook\n\t\treturn $user->commit('create', ['user' => $user, 'input' => $props], function ($user, $props) {\n\t\t\t$user->writeCredentials([\n\t\t\t\t'email'    => $user->email(),\n\t\t\t\t'language' => $user->language(),\n\t\t\t\t'name'     => $user->name()->value(),\n\t\t\t\t'role'     => $user->role()->id(),\n\t\t\t]);\n\n\t\t\t$user->writePassword($user->password());\n\n\t\t\t// always create users in the default language\n\t\t\tif ($user->kirby()->multilang() === true) {\n\t\t\t\t$languageCode = $user->kirby()->defaultLanguage()->code();\n\t\t\t} else {\n\t\t\t\t$languageCode = null;\n\t\t\t}\n\n\t\t\t// add the user to users collection\n\t\t\t$user->kirby()->users()->add($user);\n\n\t\t\t// write the user data\n\t\t\treturn $user->save($user->content()->toArray(), $languageCode);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a random user id\n\t *\n\t * @return string\n\t */\n\tpublic function createId(): string\n\t{\n\t\t$length = 8;\n\n\t\tdo {\n\t\t\ttry {\n\t\t\t\t$id = Str::random($length);\n\t\t\t\tif (UserRules::validId($this, $id) === true) {\n\t\t\t\t\treturn $id;\n\t\t\t\t}\n\n\t\t\t\t// we can't really test for a random match\n\t\t\t\t// @codeCoverageIgnoreStart\n\t\t\t} catch (Throwable) {\n\t\t\t\t$length++;\n\t\t\t}\n\t\t} while (true);\n\t\t// @codeCoverageIgnoreEnd\n\t}\n\n\t/**\n\t * Deletes the user\n\t *\n\t * @return bool\n\t * @throws \\Kirby\\Exception\\LogicException\n\t */\n\tpublic function delete(): bool\n\t{\n\t\treturn $this->commit('delete', ['user' => $this], function ($user) {\n\t\t\tif ($user->exists() === false) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// delete all public assets for this user\n\t\t\tDir::remove($user->mediaRoot());\n\n\t\t\t// delete the user directory\n\t\t\tif (Dir::remove($user->root()) !== true) {\n\t\t\t\tthrow new LogicException('The user directory for \"' . $user->email() . '\" could not be deleted');\n\t\t\t}\n\n\t\t\t// remove the user from users collection\n\t\t\t$user->kirby()->users()->remove($user);\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * Read the account information from disk\n\t *\n\t * @return array\n\t */\n\tprotected function readCredentials(): array\n\t{\n\t\t$path = $this->root() . '/index.php';\n\n\t\tif (is_file($path) === true) {\n\t\t\t$credentials = F::load($path, allowOutput: false);\n\n\t\t\treturn is_array($credentials) === false ? [] : $credentials;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t/**\n\t * Reads the user password from disk\n\t *\n\t * @return string|false\n\t */\n\tprotected function readPassword()\n\t{\n\t\treturn F::read($this->passwordFile());\n\t}\n\n\t/**\n\t * Updates the user data\n\t *\n\t * @param array|null $input\n\t * @param string|null $languageCode\n\t * @param bool $validate\n\t * @return static\n\t */\n\tpublic function update(array $input = null, string $languageCode = null, bool $validate = false)\n\t{\n\t\t$user = parent::update($input, $languageCode, $validate);\n\n\t\t// set auth user data only if the current user is this user\n\t\tif ($user->isLoggedIn() === true) {\n\t\t\t$this->kirby()->auth()->setUser($user);\n\t\t}\n\n\t\t// update the users collection\n\t\t$user->kirby()->users()->set($user->id(), $user);\n\n\t\treturn $user;\n\t}\n\n\t/**\n\t * This always merges the existing credentials\n\t * with the given input.\n\t *\n\t * @param array $credentials\n\t * @return bool\n\t */\n\tprotected function updateCredentials(array $credentials): bool\n\t{\n\t\t// normalize the email address\n\t\tif (isset($credentials['email']) === true) {\n\t\t\t$credentials['email'] = Str::lower(trim($credentials['email']));\n\t\t}\n\n\t\treturn $this->writeCredentials(array_merge($this->credentials(), $credentials));\n\t}\n\n\t/**\n\t * Writes the account information to disk\n\t *\n\t * @param array $credentials\n\t * @return bool\n\t */\n\tprotected function writeCredentials(array $credentials): bool\n\t{\n\t\treturn Data::write($this->root() . '/index.php', $credentials);\n\t}\n\n\t/**\n\t * Writes the password to disk\n\t */\n\tprotected function writePassword(\n\t\t#[SensitiveParameter]\n\t\tstring $password = null\n\t): bool {\n\t\treturn F::write($this->passwordFile(), $password);\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Exception\\PermissionException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\nuse Kirby\\Session\\AutoSession;\nuse Throwable;\n\n/**\n * @coversDefaultClass \\Kirby\\Cms\\Auth\n */\nclass AuthTest extends TestCase\n{\n\tprotected $app;\n\tprotected $auth;\n\tprotected $tmp;\n\n\tpublic function setUp(): void\n\t{\n\t\t$this->app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index' => $this->tmp = __DIR__ . '/tmp'\n\t\t\t],\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth'     => true,\n\t\t\t\t\t'allowInsecure' => true\n\t\t\t\t],\n\t\t\t\t'auth' => [\n\t\t\t\t\t'debug' => false\n\t\t\t\t]\n\t\t\t],\n\t\t\t'users' => [\n\t\t\t\t[\n\t\t\t\t\t'email'    => 'marge@simpsons.com',\n\t\t\t\t\t'id'       => 'marge',\n\t\t\t\t\t'password' => password_hash('springfield123', PASSWORD_DEFAULT)\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'email'    => 'homer@simpsons.com',\n\t\t\t\t\t'id'       => 'homer',\n\t\t\t\t\t'password' => $hash = password_hash('springfield123', PASSWORD_DEFAULT)\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\t\tDir::make($this->tmp . '/site/accounts/homer');\n\t\tF::write($this->tmp . '/site/accounts/homer/.htpasswd', $hash);\n\t\ttouch($this->tmp . '/site/accounts/homer/.htpasswd', 1337000000);\n\n\t\t$this->auth = $this->app->auth();\n\t}\n\n\tpublic function tearDown(): void\n\t{\n\t\t$this->app->session()->destroy();\n\t\tDir::remove($this->tmp);\n\t\tApp::destroy();\n\t}\n\n\t/**\n\t * @covers ::currentUserFromImpersonation\n\t * @covers ::impersonate\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testImpersonate()\n\t{\n\t\t$this->assertNull($this->auth->user());\n\n\t\t$user = $this->auth->impersonate('kirby');\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'kirby@getkirby.com',\n\t\t\t'status'    => 'impersonated'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame($user, $this->auth->user());\n\t\t$this->assertSame($user, $this->auth->currentUserFromImpersonation());\n\t\t$this->assertSame('kirby', $user->id());\n\t\t$this->assertSame('kirby@getkirby.com', $user->email());\n\t\t$this->assertSame('admin', $user->role()->name());\n\t\t$this->assertNull($this->auth->user(null, false));\n\n\t\t$user = $this->auth->impersonate('homer@simpsons.com');\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'homer@simpsons.com',\n\t\t\t'status'    => 'impersonated'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame('homer@simpsons.com', $user->email());\n\t\t$this->assertSame($user, $this->auth->user());\n\t\t$this->assertSame($user, $this->auth->currentUserFromImpersonation());\n\t\t$this->assertNull($this->auth->user(null, false));\n\n\t\t$this->assertNull($this->auth->impersonate(null));\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => null,\n\t\t\t'status'    => 'inactive'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertNull($this->auth->user());\n\t\t$this->assertNull($this->auth->currentUserFromImpersonation());\n\t\t$this->assertNull($this->auth->user(null, false));\n\n\t\t$this->auth->setUser($actual = $this->app->user('marge@simpsons.com'));\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'marge@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame('marge@simpsons.com', $this->auth->user()->email());\n\t\t$impersonated = $this->auth->impersonate('nobody');\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'nobody@getkirby.com',\n\t\t\t'status'    => 'impersonated'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertSame($impersonated, $this->auth->user());\n\t\t$this->assertSame($impersonated, $this->auth->currentUserFromImpersonation());\n\t\t$this->assertSame('nobody', $impersonated->id());\n\t\t$this->assertSame('nobody@getkirby.com', $impersonated->email());\n\t\t$this->assertSame('nobody', $impersonated->role()->name());\n\t\t$this->assertSame($actual, $this->auth->user(null, false));\n\n\t\t$this->auth->logout();\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => null,\n\t\t\t'status'    => 'inactive'\n\t\t], $this->auth->status()->toArray());\n\t\t$this->assertNull($this->auth->impersonate());\n\t\t$this->assertNull($this->auth->user());\n\t\t$this->assertNull($this->auth->currentUserFromImpersonation());\n\t\t$this->assertNull($this->auth->user(null, false));\n\t}\n\n\t/**\n\t * @covers ::impersonate\n\t */\n\tpublic function testImpersonateInvalidUser()\n\t{\n\t\t$this->expectException(NotFoundException::class);\n\t\t$this->expectExceptionMessage('The user \"lisa@simpsons.com\" cannot be found');\n\n\t\t$this->auth->impersonate('lisa@simpsons.com');\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic1()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('testuser:testpass')\n\t\t\t]\n\t\t]);\n\n\t\t// existing basic auth should be preferred\n\t\t// over impersonation\n\t\t$app->auth()->impersonate('kirby');\n\n\t\t$this->assertSame('basic', $app->auth()->type());\n\n\t\t// auth object should have been accessed\n\t\t$this->assertTrue($app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic2()\n\t{\n\t\t// non-existing basic auth should\n\t\t// fall back to impersonation\n\t\t$this->auth->impersonate('kirby');\n\n\t\t$this->assertSame('impersonate', $this->auth->type());\n\n\t\t// auth object should have been accessed\n\t\t$this->assertTrue($this->app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic3()\n\t{\n\t\t// non-existing basic auth without\n\t\t// impersonation should fall back to session\n\t\t$this->assertSame('session', $this->auth->type());\n\n\t\t// auth object should have been accessed\n\t\t$this->assertTrue($this->app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeBasic4()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth' => false\n\t\t\t\t]\n\t\t\t],\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('testuser:testpass')\n\t\t\t]\n\t\t]);\n\n\t\t// disabled option should fall back to session\n\t\t$this->assertSame('session', $app->auth()->type());\n\n\t\t// auth object should *not* have been accessed\n\t\t$this->assertFalse($app->response()->usesAuth());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeImpersonate()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth' => false\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$app->auth()->impersonate('kirby');\n\n\t\t$this->assertSame('impersonate', $app->auth()->type());\n\t}\n\n\t/**\n\t * @covers ::type\n\t */\n\tpublic function testTypeSession()\n\t{\n\t\t$app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'api' => [\n\t\t\t\t\t'basicAuth' => false\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$this->assertSame('session', $app->auth()->type());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserSession()\n\t{\n\t\t$session = $this->app->session();\n\t\t$session->set('kirby.userId', 'marge');\n\n\t\t$user = $this->auth->user();\n\t\t$this->assertSame('marge@simpsons.com', $user->email());\n\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'marge@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\n\t\t// impersonation is not set\n\t\t$this->assertNull($this->auth->currentUserFromImpersonation());\n\n\t\t// value is cached\n\t\t$session->set('kirby.userId', 'homer');\n\t\t$user = $this->auth->user();\n\t\t$this->assertSame('marge@simpsons.com', $user->email());\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'marge@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserSessionManualSession()\n\t{\n\t\t$session = (new AutoSession($this->app->root('sessions')))->createManually();\n\t\t$session->set('kirby.userId', 'homer');\n\t\t$session->set('kirby.loginTimestamp', 1337000000);\n\n\t\t$user = $this->auth->user($session);\n\t\t$this->assertSame('homer@simpsons.com', $user->email());\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'homer@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserSessionOldTimestamp()\n\t{\n\t\t$session = $this->app->session();\n\t\t$session->set('kirby.userId', 'homer');\n\t\t$session->set('kirby.loginTimestamp', 1000000000);\n\n\t\t$this->assertNull($this->auth->user());\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => null,\n\t\t\t'status'    => 'inactive'\n\t\t], $this->auth->status()->toArray());\n\n\t\t// user should be logged out completely\n\t\t$this->assertSame([], $session->data()->get());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserSessionNoTimestamp()\n\t{\n\t\t$session = $this->app->session();\n\t\t$session->set('kirby.userId', 'homer');\n\n\t\t$this->assertNull($this->auth->user());\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => null,\n\t\t\t'status'    => 'inactive'\n\t\t], $this->auth->status()->toArray());\n\n\t\t// user should be logged out completely\n\t\t$this->assertSame([], $session->data()->get());\n\t}\n\n\t/**\n\t * @covers ::status\n\t * @covers ::user\n\t */\n\tpublic function testUserBasicAuth()\n\t{\n\t\t$this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('homer@simpsons.com:springfield123')\n\t\t\t]\n\t\t]);\n\n\t\t$user = $this->auth->user();\n\t\t$this->assertSame('homer@simpsons.com', $user->email());\n\n\t\t$this->assertSame([\n\t\t\t'challenge' => null,\n\t\t\t'email'     => 'homer@simpsons.com',\n\t\t\t'status'    => 'active'\n\t\t], $this->auth->status()->toArray());\n\t}\n\n\t/**\n\t * @covers ::user\n\t */\n\tpublic function testUserBasicAuthInvalid1()\n\t{\n\t\t$this->expectException(PermissionException::class);\n\t\t$this->expectExceptionMessage('Invalid login');\n\n\t\t$this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('homer@simpsons.com:invalid')\n\t\t\t]\n\t\t]);\n\n\t\t$this->auth->user();\n\t}\n\n\t/**\n\t * @covers ::user\n\t */\n\tpublic function testUserBasicAuthInvalid2()\n\t{\n\t\t$this->expectException(PermissionException::class);\n\t\t$this->expectExceptionMessage('Invalid login');\n\n\t\t$this->app->clone([\n\t\t\t'server' => [\n\t\t\t\t'HTTP_AUTHORIZATION' => 'Basic ' . base64_encode('homer@simpsons.com:invalid')\n\t\t\t]\n\t\t]);\n\n\t\ttry {\n\t\t\t$this->auth->user();\n\t\t} catch (Throwable) {\n\t\t\t// tested above, this check is for the second call\n\t\t}\n\n\t\t$this->auth->user();\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Data\\Data;\nuse Kirby\\Filesystem\\Dir;\n\nclass UserActionsTest extends TestCase\n{\n\tprotected $app;\n\tprotected $tmp = __DIR__ . '/tmp';\n\n\tpublic function setUp(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t\tData::write($this->tmp . '/accounts/admin/index.php', [\n\t\t\t'email' => 'admin@domain.com',\n\t\t\t'role' => 'admin'\n\t\t]);\n\t\tData::write($this->tmp . '/accounts/editor/index.php', [\n\t\t\t'email' => 'editor@domain.com',\n\t\t\t'role' => 'editor'\n\t\t]);\n\n\t\t$this->app = new App([\n\t\t\t'roles' => [\n\t\t\t\t[\n\t\t\t\t\t'name' => 'admin'\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'name' => 'editor'\n\t\t\t\t]\n\t\t\t],\n\t\t\t'roots' => [\n\t\t\t\t'index'    => '/dev/null',\n\t\t\t\t'accounts' => $this->tmp . '/accounts',\n\t\t\t\t'sessions' => $this->tmp . '/sessions'\n\t\t\t],\n\t\t\t'user'  => 'admin@domain.com'\n\t\t]);\n\t}\n\n\tpublic function tearDown(): void\n\t{\n\t\t$this->app->session()->destroy();\n\t\tDir::remove($this->tmp);\n\t}\n\n\tpublic function testChangeEmail()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeEmail('another@domain.com');\n\n\t\t$this->assertSame('another@domain.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('another@domain.com', $this->app->clone()->user($user->id())->email());\n\t}\n\n\tpublic function testChangeEmailWithUnicode()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\n\t\t// with Unicode email\n\t\t$user = $user->changeEmail('test@ex\u00e4mple.com');\n\t\t$this->assertSame('test@ex\u00e4mple.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('test@ex\u00e4mple.com', $this->app->clone()->user($user->id())->email());\n\n\t\t// with Punycode email\n\t\t$user = $user->changeEmail('test@xn--tst-qla.com');\n\t\t$this->assertSame('test@t\u00e4st.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('test@t\u00e4st.com', $this->app->clone()->user($user->id())->email());\n\t}\n\n\tpublic function testChangeEmailWithUppercase()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeEmail('ANOTHER@domain.com');\n\n\t\t$this->assertSame('another@domain.com', $user->email());\n\n\t\t// verify the value stored on disk\n\t\t$this->assertSame('another@domain.com', $this->app->clone()->user($user->id())->email());\n\t}\n\n\tpublic function testChangeLanguage()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeLanguage('de');\n\n\t\t$this->assertSame('de', $user->language());\n\t}\n\n\tpublic function testChangeName()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeName('Edith Thor');\n\n\t\t$this->assertSame('Edith Thor', $user->name()->value());\n\t}\n\n\tpublic function testChangePassword()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changePassword('topsecret2018');\n\n\t\t$this->assertTrue($user->validatePassword('topsecret2018'));\n\t}\n\n\tpublic function testChangeRole()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->changeRole('editor');\n\n\t\t$this->assertInstanceOf(Role::class, $user->role());\n\t\t$this->assertSame('editor', $user->role()->name());\n\t}\n\n\tpublic function testCreateAdmin()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'admin',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\n\t\t$this->assertSame('new@domain.com', $user->email());\n\t\t$this->assertInstanceOf(Role::class, $user->role());\n\t\t$this->assertSame('admin', $user->role()->name());\n\t}\n\n\tpublic function testCreateUserWithUnicodeEmail()\n\t{\n\t\t// with Unicode email\n\t\t$user = User::create([\n\t\t\t'email' => 'test@ex\u00e4mple.com',\n\t\t\t'role'  => 'admin',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\t\t$this->assertSame('test@ex\u00e4mple.com', $user->email());\n\t\t$this->assertSame('admin', $user->role()->name());\n\n\t\t// with Punycode email\n\t\t$user = User::create([\n\t\t\t'email' => 'test@xn--tst-qla.com',\n\t\t\t'role'  => 'admin',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\t\t$this->assertSame('test@t\u00e4st.com', $user->email());\n\t\t$this->assertSame('admin', $user->role()->name());\n\t}\n\n\tpublic function testCreateEditor()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\n\t\t$this->assertSame('new@domain.com', $user->email());\n\t\t$this->assertInstanceOf(Role::class, $user->role());\n\t\t$this->assertSame('editor', $user->role()->name());\n\t}\n\n\tpublic function testCreateWithContent()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'content' => [\n\t\t\t\t'a' => 'Custom A'\n\t\t\t],\n\t\t]);\n\n\t\t$this->assertSame('Custom A', $user->a()->value());\n\t}\n\n\tpublic function testCreateWithDefaults()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'blueprint' => [\n\t\t\t\t'name' => 'editor',\n\t\t\t\t'fields' => [\n\t\t\t\t\t'a'  => [\n\t\t\t\t\t\t'type'    => 'text',\n\t\t\t\t\t\t'default' => 'A'\n\t\t\t\t\t],\n\t\t\t\t\t'b' => [\n\t\t\t\t\t\t'type'    => 'textarea',\n\t\t\t\t\t\t'default' => 'B'\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$this->assertSame('A', $user->a()->value());\n\t\t$this->assertSame('B', $user->b()->value());\n\t}\n\n\tpublic function testCreateWithDefaultsAndContent()\n\t{\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'content' => [\n\t\t\t\t'a' => 'Custom A'\n\t\t\t],\n\t\t\t'blueprint' => [\n\t\t\t\t'name' => 'editor',\n\t\t\t\t'fields' => [\n\t\t\t\t\t'a'  => [\n\t\t\t\t\t\t'type'    => 'text',\n\t\t\t\t\t\t'default' => 'A'\n\t\t\t\t\t],\n\t\t\t\t\t'b' => [\n\t\t\t\t\t\t'type'    => 'textarea',\n\t\t\t\t\t\t'default' => 'B'\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$this->assertSame('Custom A', $user->a()->value());\n\t\t$this->assertSame('B', $user->b()->value());\n\t}\n\n\tpublic function testCreateWithContentMultilang()\n\t{\n\t\t$this->app = $this->app->clone([\n\t\t\t'options' => [\n\t\t\t\t'languages' => true\n\t\t\t],\n\t\t\t'languages' => [\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'en',\n\t\t\t\t\t'default' => true,\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'de',\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t$user = User::create([\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'editor',\n\t\t\t'content' => [\n\t\t\t\t'a' => 'a',\n\t\t\t\t'b' => 'b',\n\t\t\t],\n\t\t]);\n\n\t\t$this->assertTrue($user->exists());\n\n\t\t$this->assertSame('a', $user->a()->value());\n\t\t$this->assertSame('b', $user->b()->value());\n\t}\n\n\tpublic function testDelete()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user->save();\n\n\t\t$this->assertFileExists($user->root() . '/user.txt');\n\t\t$user->delete();\n\t\t$this->assertFileDoesNotExist($user->root() . '/user.txt');\n\t}\n\n\tpublic function testUpdate()\n\t{\n\t\t$user = $this->app->user('editor@domain.com');\n\t\t$user = $user->update([\n\t\t\t'website' => $url = 'https://editor.com'\n\t\t]);\n\n\t\t$this->assertSame($url, $user->website()->value());\n\t}\n\n\tpublic function testUpdateWithAuthUser()\n\t{\n\t\t$user = $this->app->user('admin@domain.com');\n\t\t$user->loginPasswordless();\n\t\t$user->update([\n\t\t\t'website' => $url = 'https://getkirby.com'\n\t\t]);\n\t\t$this->assertSame($url, $this->app->user()->website()->value());\n\t\t$user->logout();\n\t}\n\n\tpublic function testChangeEmailHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeEmail:before' => function (User $user, $email) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('another@domain.com', $email);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeEmail:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('another@domain.com', $newUser->email());\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $oldUser->email());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeEmail('another@domain.com');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangeLanguageHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeLanguage:before' => function (User $user, $language) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('en', $user->language());\n\t\t\t\t\t$phpunit->assertSame('de', $language);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeLanguage:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('de', $newUser->language());\n\t\t\t\t\t$phpunit->assertSame('en', $oldUser->language());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeLanguage('de');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangeNameHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeName:before' => function (User $user, $name) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertNull($user->name()->value());\n\t\t\t\t\t$phpunit->assertSame('Edith Thor', $name);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeName:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('Edith Thor', $newUser->name()->value());\n\t\t\t\t\t$phpunit->assertNull($oldUser->name()->value());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeName('Edith Thor');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testChangePasswordHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changePassword:before' => function (User $user, $password) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertEmpty($user->password());\n\t\t\t\t\t$phpunit->assertSame('topsecret2018', $password);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changePassword:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertTrue($newUser->validatePassword('topsecret2018'));\n\t\t\t\t\t$phpunit->assertEmpty($oldUser->password());\n\t\t\t\t\t$calls += 2;\n\t\t\t\t},\n\t\t\t\t'user.login:before' => function () use (&$calls) {\n\t\t\t\t\t$calls += 4;\n\t\t\t\t},\n\t\t\t\t'user.login:after' => function () use (&$calls) {\n\t\t\t\t\t$calls += 8;\n\t\t\t\t},\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changePassword('topsecret2018');\n\n\t\t$this->assertSame(3, $calls);\n\t}\n\n\tpublic function testChangePasswordHooksCurrentUser()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$this->app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changePassword:before' => function (User $user, $password) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertEmpty($user->password());\n\t\t\t\t\t$phpunit->assertSame('topsecret2018', $password);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changePassword:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertTrue($newUser->validatePassword('topsecret2018'));\n\t\t\t\t\t$phpunit->assertEmpty($oldUser->password());\n\t\t\t\t\t$calls += 2;\n\t\t\t\t},\n\t\t\t\t'user.login:before' => function () use (&$calls) {\n\t\t\t\t\t$calls += 4;\n\t\t\t\t},\n\t\t\t\t'user.login:after' => function () use (&$calls) {\n\t\t\t\t\t$calls += 8;\n\t\t\t\t},\n\t\t\t]\n\t\t]);\n\n\t\t$user = $this->app->user('admin@domain.com');\n\t\t$user->changePassword('topsecret2018');\n\n\t\t$this->assertSame(15, $calls);\n\t}\n\n\tpublic function testChangeRoleHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.changeRole:before' => function (User $user, $role) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('editor', $user->role()->name());\n\t\t\t\t\t$phpunit->assertSame('admin', $role);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.changeRole:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('admin', $newUser->role()->name());\n\t\t\t\t\t$phpunit->assertSame('editor', $oldUser->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->changeRole('admin');\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testCreateHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit= $this;\n\t\t$userInput = [\n\t\t\t'email' => 'new@domain.com',\n\t\t\t'role'  => 'admin',\n\t\t\t'model' => 'admin',\n\t\t];\n\n\t\t$this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.create:before' => function (User $user, $input) use ($phpunit, $userInput, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('new@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('admin', $user->role()->name());\n\t\t\t\t\t$phpunit->assertSame($userInput, $input);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.create:after' => function (User $user) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('new@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('admin', $user->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\tUser::create($userInput);\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testDeleteHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.delete:before' => function (User $user) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('editor', $user->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.delete:after' => function ($status, User $user) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertTrue($status);\n\t\t\t\t\t$phpunit->assertSame('editor@domain.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame('editor', $user->role()->name());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->delete();\n\n\t\t$this->assertSame(2, $calls);\n\t}\n\n\tpublic function testUpdateHooks()\n\t{\n\t\t$calls = 0;\n\t\t$phpunit = $this;\n\t\t$input = [\n\t\t\t'website' => 'https://getkirby.com'\n\t\t];\n\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.update:before' => function (User $user, $values, $strings) use ($phpunit, $input, &$calls) {\n\t\t\t\t\t$phpunit->assertNull($user->website()->value());\n\t\t\t\t\t$phpunit->assertSame($input, $values);\n\t\t\t\t\t$phpunit->assertSame($input, $strings);\n\t\t\t\t\t$calls++;\n\t\t\t\t},\n\t\t\t\t'user.update:after' => function (User $newUser, User $oldUser) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('https://getkirby.com', $newUser->website()->value());\n\t\t\t\t\t$phpunit->assertNull($oldUser->website()->value());\n\t\t\t\t\t$calls++;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t$user = $app->user('editor@domain.com');\n\t\t$user->update($input);\n\n\t\t$this->assertSame(2, $calls);\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Filesystem\\F;\n\nclass UserAuthTest extends TestCase\n{\n\tprotected $app;\n\tprotected $tmp = __DIR__ . '/tmp';\n\n\tpublic function setUp(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t\t$this->app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => '/dev/null',\n\t\t\t\t'accounts' => $this->tmp . '/accounts',\n\t\t\t\t'sessions' => $this->tmp . '/sessions'\n\t\t\t],\n\t\t\t'users' => [\n\t\t\t\t[\n\t\t\t\t\t'email' => 'test@getkirby.com',\n\t\t\t\t\t'id'    => 'testuser',\n\t\t\t\t\t'role'  => 'admin'\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\t}\n\n\tpublic function tearDown(): void\n\t{\n\t\tDir::remove($this->tmp);\n\t}\n\n\tpublic function testGlobalUserState()\n\t{\n\t\t$user = $this->app->user('test@getkirby.com');\n\n\t\t$this->assertNull($this->app->user());\n\t\t$user->loginPasswordless();\n\t\t$this->assertSame($user, $this->app->user());\n\t\t$user->logout();\n\t\t$this->assertNull($this->app->user());\n\t}\n\n\tpublic function testLoginLogoutHooks()\n\t{\n\t\t$phpunit = $this;\n\n\t\t$calls         = 0;\n\t\t$logoutSession = false;\n\t\t$app = $this->app->clone([\n\t\t\t'hooks' => [\n\t\t\t\t'user.login:before' => function ($user, $session) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\n\t\t\t\t\t$calls += 1;\n\t\t\t\t},\n\t\t\t\t'user.login:after' => function ($user, $session) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\n\t\t\t\t\t$calls += 2;\n\t\t\t\t},\n\t\t\t\t'user.logout:before' => function ($user, $session) use ($phpunit, &$calls) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\n\t\t\t\t\t$calls += 4;\n\t\t\t\t},\n\t\t\t\t'user.logout:after' => function ($user, $session) use ($phpunit, &$calls, &$logoutSession) {\n\t\t\t\t\t$phpunit->assertSame('test@getkirby.com', $user->email());\n\n\t\t\t\t\tif ($logoutSession === true) {\n\t\t\t\t\t\t$phpunit->assertSame($session, S::instance());\n\t\t\t\t\t\t$phpunit->assertSame('value', S::instance()->get('some'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$phpunit->assertNull($session);\n\t\t\t\t\t}\n\n\t\t\t\t\t$calls += 8;\n\t\t\t\t}\n\t\t\t]\n\t\t]);\n\n\t\t// without prepopulated session\n\t\t$user = $app->user('test@getkirby.com');\n\t\t$user->loginPasswordless();\n\t\t$user->logout();\n\n\t\t// with a session with another value\n\t\tS::instance()->set('some', 'value');\n\t\t$logoutSession = true;\n\t\t$user->loginPasswordless();\n\t\t$user->logout();\n\n\t\t// each hook needs to be called exactly twice\n\t\t$this->assertSame((1 + 2 + 4 + 8) * 2, $calls);\n\t}\n\n\tpublic function testSessionData()\n\t{\n\t\t$user    = $this->app->user('test@getkirby.com');\n\t\t$session = $this->app->session();\n\n\t\t$this->assertSame([], $session->data()->get());\n\t\t$user->loginPasswordless();\n\t\t$this->assertSame(['kirby.userId' => 'testuser'], $session->data()->get());\n\t\t$user->logout();\n\t\t$this->assertSame([], $session->data()->get());\n\t}\n\n\tpublic function testSessionDataWithPassword()\n\t{\n\t\tF::write($this->tmp . '/accounts/testuser/.htpasswd', 'a very secure hash');\n\n\t\t$user    = $this->app->user('test@getkirby.com');\n\t\t$session = $this->app->session();\n\n\t\t$this->assertSame([], $session->data()->get());\n\t\t$user->loginPasswordless();\n\t\t$this->assertSame(['kirby.userId' => 'testuser', 'kirby.loginTimestamp' => 1337000000], $session->data()->get());\n\t\t$user->logout();\n\t\t$this->assertSame([], $session->data()->get());\n\t}\n}\n", "<?php\n\nnamespace Kirby\\Cms;\n\nuse Kirby\\Exception\\InvalidArgumentException;\nuse Kirby\\Exception\\NotFoundException;\nuse Kirby\\Filesystem\\Dir;\nuse Kirby\\Filesystem\\F;\n\nclass UserTestModel extends User\n{\n}\n\nclass UserTest extends TestCase\n{\n\tpublic function testAvatar()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'user@domain.com'\n\t\t]);\n\n\t\t$this->assertNull($user->avatar());\n\t}\n\n\tpublic function testDefaultSiblings()\n\t{\n\t\t$user = new User(['email' => 'user@domain.com']);\n\t\t$this->assertInstanceOf(Users::class, $user->siblings());\n\t}\n\n\tpublic function testContent()\n\t{\n\t\t$user = new User([\n\t\t\t'email'   => 'user@domain.com',\n\t\t\t'content' => $content = ['name' => 'Test']\n\t\t]);\n\n\t\t$this->assertSame($content, $user->content()->toArray());\n\t}\n\n\tpublic function testInvalidContent()\n\t{\n\t\t$this->expectException('TypeError');\n\n\t\t$user = new User(['email' => 'user@domain.com', 'content' => 'something']);\n\t}\n\n\tpublic function testDefaultContent()\n\t{\n\t\t$user = new User(['email' => 'user@domain.com']);\n\t\t$this->assertInstanceOf(Content::class, $user->content());\n\t}\n\n\tpublic function testEmail()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => $email = 'user@domain.com',\n\t\t]);\n\n\t\t$this->assertSame($email, $user->email());\n\t}\n\n\tpublic function testInvalidEmail()\n\t{\n\t\t$this->expectException('TypeError');\n\n\t\t$user = new User(['email' => []]);\n\t}\n\n\tpublic function testName()\n\t{\n\t\t$user = new User([\n\t\t\t'name' => $name = 'Homer Simpson',\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->name());\n\t\t$this->assertSame($name, $user->name()->value());\n\t}\n\n\tpublic function testNameSanitized()\n\t{\n\t\t$user = new User([\n\t\t\t'name' => '<strong>Homer</strong> Simpson',\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->name());\n\t\t$this->assertSame('Homer Simpson', $user->name()->value());\n\t}\n\n\tpublic function testNameOrEmail()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => $email = 'homer@simpsons.com',\n\t\t\t'name'  => $name = 'Homer Simpson',\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->nameOrEmail());\n\t\t$this->assertSame($name, $user->nameOrEmail()->value());\n\t\t$this->assertSame('name', $user->nameOrEmail()->key());\n\n\t\t$user = new User([\n\t\t\t'email' => $email = 'homer@simpsons.com',\n\t\t\t'name'  => ''\n\t\t]);\n\n\t\t$this->assertInstanceOf(Field::class, $user->nameOrEmail());\n\t\t$this->assertSame($email, $user->nameOrEmail()->value());\n\t\t$this->assertSame('email', $user->nameOrEmail()->key());\n\t}\n\n\tpublic function testToString()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com'\n\t\t]);\n\n\t\t$this->assertSame('test@getkirby.com', $user->toString());\n\t}\n\n\tpublic function testToStringWithTemplate()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com'\n\t\t]);\n\n\t\t$this->assertSame('Email: test@getkirby.com', $user->toString('Email: {{ user.email }}'));\n\t}\n\n\tpublic function testModified()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => $index = __DIR__ . '/fixtures/UserPropsTest/modified',\n\t\t\t\t'accounts' => $index\n\t\t\t]\n\t\t]);\n\n\t\t// create a user file\n\t\tF::write($file = $index . '/test/index.php', '<?php return [];');\n\n\t\t$modified = filemtime($file);\n\t\t$user     = $app->user('test');\n\n\t\t$this->assertSame((string)$modified, $user->modified());\n\n\t\t// default date handler\n\t\t$format = 'd.m.Y';\n\t\t$this->assertSame(date($format, $modified), $user->modified($format));\n\n\t\t// custom date handler\n\t\t$format = '%d.%m.%Y';\n\t\t$this->assertSame(@strftime($format, $modified), $user->modified($format, 'strftime'));\n\n\t\tDir::remove($index);\n\t}\n\n\tpublic function testModifiedSpecifyingLanguage()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => $index = __DIR__ . '/fixtures/UserPropsTest/modified',\n\t\t\t\t'accounts' => $index\n\t\t\t],\n\t\t\t'languages' => [\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'en',\n\t\t\t\t\t'default' => true,\n\t\t\t\t\t'name'    => 'English'\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t'code'    => 'de',\n\t\t\t\t\t'name'    => 'Deutsch'\n\t\t\t\t]\n\t\t\t]\n\t\t]);\n\n\t\t// create a user file\n\t\tF::write($file = $index . '/test/index.php', '<?php return [];');\n\n\t\t// create the english page\n\t\tF::write($file = $index . '/test/user.en.txt', 'test');\n\t\ttouch($file, $modifiedEnContent = \\time() + 2);\n\n\t\t// create the german page\n\t\tF::write($file = $index . '/test/user.de.txt', 'test');\n\t\ttouch($file, $modifiedDeContent = \\time() + 5);\n\n\t\t$user = $app->user('test');\n\n\t\t$this->assertSame((string)$modifiedEnContent, $user->modified('U', null, 'en'));\n\t\t$this->assertSame((string)$modifiedDeContent, $user->modified('U', null, 'de'));\n\n\t\tDir::remove($index);\n\t}\n\n\tpublic function testPasswordTimestamp()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index'    => $this->tmp,\n\t\t\t\t'accounts' => $this->tmp\n\t\t\t]\n\t\t]);\n\n\t\t// create a user file\n\t\tF::write($this->tmp . '/test/index.php', '<?php return [];');\n\n\t\t$user = $app->user('test');\n\t\t$this->assertNull($user->passwordTimestamp());\n\n\t\t// create a password file\n\t\tF::write($this->tmp . '/test/.htpasswd', 'a very secure hash');\n\t\ttouch($this->tmp . '/test/.htpasswd', 1337000000);\n\n\t\t$this->assertSame(1337000000, $user->passwordTimestamp());\n\n\t\t// timestamp is not cached\n\t\ttouch($this->tmp . '/test/.htpasswd', 1338000000);\n\t\t$this->assertSame(1338000000, $user->passwordTimestamp());\n\t}\n\n\tpublic function passwordProvider()\n\t{\n\t\treturn [\n\t\t\t[null, false],\n\t\t\t['', false],\n\t\t\t['short', false],\n\t\t\t[str_repeat('long', 300), false],\n\t\t\t['invalid-password', false],\n\t\t\t['correct-horse-battery-staple', true],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider passwordProvider\n\t */\n\tpublic function testValidatePassword($input, $valid)\n\t{\n\t\t$user = new User([\n\t\t\t'email'    => 'test@getkirby.com',\n\t\t\t'password' => User::hashPassword('correct-horse-battery-staple')\n\t\t]);\n\n\t\tif ($valid === false) {\n\t\t\t$this->expectException(InvalidArgumentException::class);\n\t\t\t$user->validatePassword($input);\n\t\t} else {\n\t\t\t$this->assertTrue($user->validatePassword($input));\n\t\t}\n\t}\n\n\tpublic function testValidatePasswordHttpCode()\n\t{\n\t\t$user = new User([\n\t\t\t'email'    => 'test@getkirby.com',\n\t\t\t'password' => User::hashPassword('correct-horse-battery-staple')\n\t\t]);\n\n\t\t$caught = 0;\n\n\t\ttry {\n\t\t\t$user->validatePassword('short');\n\t\t} catch (\\Kirby\\Exception\\InvalidArgumentException $e) {\n\t\t\t$this->assertSame(\n\t\t\t\t'Please enter a valid password. Passwords must be at least 8 characters long.',\n\t\t\t\t$e->getMessage()\n\t\t\t);\n\t\t\t$this->assertSame(400, $e->getHttpCode());\n\t\t\t$caught++;\n\t\t}\n\n\t\ttry {\n\t\t\t$user->validatePassword(str_repeat('long', 300));\n\t\t} catch (\\Kirby\\Exception\\InvalidArgumentException $e) {\n\t\t\t$this->assertSame(\n\t\t\t\t'Please enter a valid password. Passwords must not be longer than 1000 characters.',\n\t\t\t\t$e->getMessage()\n\t\t\t);\n\t\t\t$this->assertSame(400, $e->getHttpCode());\n\t\t\t$caught++;\n\t\t}\n\n\t\ttry {\n\t\t\t$user->validatePassword('longbutinvalid');\n\t\t} catch (\\Kirby\\Exception\\InvalidArgumentException $e) {\n\t\t\t$this->assertSame('Wrong password', $e->getMessage());\n\t\t\t$this->assertSame(401, $e->getHttpCode());\n\t\t\t$caught++;\n\t\t}\n\n\t\t$this->assertSame(3, $caught);\n\t}\n\n\tpublic function testValidateUndefinedPassword()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t]);\n\n\t\t$this->expectException(NotFoundException::class);\n\t\t$user->validatePassword('test');\n\t}\n\n\tpublic function testIsAdmin()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'role'  => 'admin'\n\t\t]);\n\n\t\t$this->assertTrue($user->isAdmin());\n\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'role'  => 'editor'\n\t\t]);\n\n\t\t$this->assertFalse($user->isAdmin());\n\t}\n\n\tpublic function testIsLoggedIn()\n\t{\n\t\t$app = new App([\n\t\t\t'roots' => [\n\t\t\t\t'index' => '/dev/null'\n\t\t\t],\n\t\t\t'users' => [\n\t\t\t\t['email' => 'a@getkirby.com'],\n\t\t\t\t['email' => 'b@getkirby.com']\n\t\t\t],\n\t\t]);\n\n\t\t$a = $app->user('a@getkirby.com');\n\t\t$b = $app->user('b@getkirby.com');\n\n\t\t$this->assertFalse($a->isLoggedIn());\n\t\t$this->assertFalse($b->isLoggedIn());\n\n\t\t$app->impersonate('a@getkirby.com');\n\n\t\t$this->assertTrue($a->isLoggedIn());\n\t\t$this->assertFalse($b->isLoggedIn());\n\n\t\t$app->impersonate('b@getkirby.com');\n\n\t\t$this->assertFalse($a->isLoggedIn());\n\t\t$this->assertTrue($b->isLoggedIn());\n\t}\n\n\tpublic function testQuery()\n\t{\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'name'  => 'Test User'\n\t\t]);\n\n\t\t$this->assertSame('Test User', $user->query('user.name')->value());\n\t\t$this->assertSame('test@getkirby.com', $user->query('user.email'));\n\n\t\t// also test with `model` key\n\t\t$this->assertSame('Test User', $user->query('model.name')->value());\n\t\t$this->assertSame('test@getkirby.com', $user->query('model.email'));\n\t}\n\n\tpublic function testUserMethods()\n\t{\n\t\tUser::$methods = [\n\t\t\t'test' => function () {\n\t\t\t\treturn 'homer';\n\t\t\t}\n\t\t];\n\n\t\t$user = new User([\n\t\t\t'email' => 'test@getkirby.com',\n\t\t\t'name'  => 'Test User'\n\t\t]);\n\n\t\t$this->assertSame('homer', $user->test());\n\n\t\tUser::$methods = [];\n\t}\n\n\tpublic function testUserModel()\n\t{\n\t\tUser::$models = [\n\t\t\t'dummy' => UserTestModel::class\n\t\t];\n\n\t\t$user = User::factory([\n\t\t\t'slug'  => 'test',\n\t\t\t'model' => 'dummy'\n\t\t]);\n\n\t\t$this->assertInstanceOf(UserTestModel::class, $user);\n\n\t\tUser::$models = [];\n\t}\n}\n"], "filenames": ["src/Cms/Auth.php", "src/Cms/User.php", "src/Cms/UserActions.php", "tests/Cms/Auth/AuthTest.php", "tests/Cms/Users/UserActionsTest.php", "tests/Cms/Users/UserAuthTest.php", "tests/Cms/Users/UserTest.php"], "buggy_code_start_loc": [281, 443, 120, 7, 44, 3, 195], "buggy_code_end_loc": [294, 883, 388, 300, 402, 98, 195], "fixing_code_start_loc": [282, 444, 121, 8, 45, 4, 196], "fixing_code_end_loc": [315, 916, 395, 346, 441, 128, 222], "type": "CWE-613", "message": "Kirby is a content management system. A vulnerability in versions prior to 3.5.8.3, 3.6.6.3, 3.7.5.2, 3.8.4.1, and 3.9.6 affects all Kirby sites with user accounts (unless Kirby's API and Panel are disabled in the config). It can only be abused if a Kirby user is logged in on a device or browser that is shared with potentially untrusted users or if an attacker already maliciously used a previous password to log in to a Kirby site as the affected user.\n\nInsufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization. In the variation described in this advisory, it allows attackers to stay logged in to a Kirby site on another device even if the logged in user has since changed their password. Kirby did not invalidate user sessions that were created with a password that was since changed by the user or by a site admin. If a user changed their password to lock out an attacker who was already in possession of the previous password or of a login session on another device or browser, the attacker would not be reliably prevented from accessing the Kirby site as the affected user.\n\nThe problem has been patched in Kirby 3.5.8.3, 3.6.6.3, 3.7.5.2, 3.8.4.1, and 3.9.6. In all of the mentioned releases, the maintainers have updated the authentication implementation to keep track of the hashed password in each active session. If the password changed since the login, the session is invalidated. To enforce this fix even if the vulnerability was previously abused, all users are logged out from the Kirby site after updating to one of the patched releases.", "other": {"cve": {"id": "CVE-2023-38489", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-27T15:15:12.220", "lastModified": "2023-08-03T13:28:32.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Kirby is a content management system. A vulnerability in versions prior to 3.5.8.3, 3.6.6.3, 3.7.5.2, 3.8.4.1, and 3.9.6 affects all Kirby sites with user accounts (unless Kirby's API and Panel are disabled in the config). It can only be abused if a Kirby user is logged in on a device or browser that is shared with potentially untrusted users or if an attacker already maliciously used a previous password to log in to a Kirby site as the affected user.\n\nInsufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization. In the variation described in this advisory, it allows attackers to stay logged in to a Kirby site on another device even if the logged in user has since changed their password. Kirby did not invalidate user sessions that were created with a password that was since changed by the user or by a site admin. If a user changed their password to lock out an attacker who was already in possession of the previous password or of a login session on another device or browser, the attacker would not be reliably prevented from accessing the Kirby site as the affected user.\n\nThe problem has been patched in Kirby 3.5.8.3, 3.6.6.3, 3.7.5.2, 3.8.4.1, and 3.9.6. In all of the mentioned releases, the maintainers have updated the authentication implementation to keep track of the hashed password in each active session. If the password changed since the login, the session is invalidated. To enforce this fix even if the vulnerability was previously abused, all users are logged out from the Kirby site after updating to one of the patched releases."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:getkirby:kirby:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5.0", "versionEndExcluding": "3.5.8.3", "matchCriteriaId": "E4FCE332-95EB-4BAC-B5CF-D7D24DA38476"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getkirby:kirby:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.6.0", "versionEndExcluding": "3.6.6.3", "matchCriteriaId": "7AE383B6-2730-4760-B58C-F08D60C4C91B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getkirby:kirby:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.7.0", "versionEndExcluding": "3.7.5.2", "matchCriteriaId": "CF9A36C4-9169-48F3-B43A-F7CB3825A020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getkirby:kirby:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.8.0", "versionEndExcluding": "3.8.4.1", "matchCriteriaId": "C33BAD98-F500-4CE4-80A0-745A13DE9785"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getkirby:kirby:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.9.0", "versionEndExcluding": "3.9.6", "matchCriteriaId": "AC260646-C9E1-40A0-BB77-36A3E05FC76F"}]}]}], "references": [{"url": "https://github.com/getkirby/kirby/commit/7a0a2014c69fdb925ea02f30e7793bb50115e931", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/getkirby/kirby/releases/tag/3.5.8.3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/getkirby/kirby/releases/tag/3.6.6.3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/getkirby/kirby/releases/tag/3.7.5.2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/getkirby/kirby/releases/tag/3.8.4.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/getkirby/kirby/releases/tag/3.9.6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/getkirby/kirby/security/advisories/GHSA-5mvj-rvp8-rf45", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/getkirby/kirby/commit/7a0a2014c69fdb925ea02f30e7793bb50115e931"}}