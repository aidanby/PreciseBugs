{"buggy_code": ["/*\n * Copyright (C) 2016 Open Broadcast Systems Ltd.\n * Author        2016 Rostislav Pehlivanov <atomnuker@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/ffversion.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/opt.h\"\n#include \"dirac.h\"\n#include \"put_bits.h\"\n#include \"internal.h\"\n\n#include \"vc2enc_dwt.h\"\n#include \"diractab.h\"\n\n/* Quantizations above this usually zero coefficients and lower the quality */\n#define MAX_QUANT_INDEX 100\n\n#define COEF_LUT_TAB 2048\n\nenum VC2_QM {\n    VC2_QM_DEF = 0,\n    VC2_QM_COL,\n    VC2_QM_FLAT,\n\n    VC2_QM_NB\n};\n\ntypedef struct SubBand {\n    dwtcoef *buf;\n    ptrdiff_t stride;\n    int width;\n    int height;\n} SubBand;\n\ntypedef struct Plane {\n    SubBand band[MAX_DWT_LEVELS][4];\n    dwtcoef *coef_buf;\n    int width;\n    int height;\n    int dwt_width;\n    int dwt_height;\n    ptrdiff_t coef_stride;\n} Plane;\n\ntypedef struct SliceArgs {\n    PutBitContext pb;\n    void *ctx;\n    int x;\n    int y;\n    int quant_idx;\n    int bits_ceil;\n    int bytes;\n} SliceArgs;\n\ntypedef struct TransformArgs {\n    void *ctx;\n    Plane *plane;\n    void *idata;\n    ptrdiff_t istride;\n    int field;\n    VC2TransformContext t;\n} TransformArgs;\n\ntypedef struct VC2EncContext {\n    AVClass *av_class;\n    PutBitContext pb;\n    Plane plane[3];\n    AVCodecContext *avctx;\n    DiracVersionInfo ver;\n\n    SliceArgs *slice_args;\n    TransformArgs transform_args[3];\n\n    /* For conversion from unsigned pixel values to signed */\n    int diff_offset;\n    int bpp;\n\n    /* Picture number */\n    uint32_t picture_number;\n\n    /* Base video format */\n    int base_vf;\n    int level;\n    int profile;\n\n    /* Quantization matrix */\n    uint8_t quant[MAX_DWT_LEVELS][4];\n\n    /* Coefficient LUT */\n    uint32_t *coef_lut_val;\n    uint8_t  *coef_lut_len;\n\n    int num_x; /* #slices horizontally */\n    int num_y; /* #slices vertically */\n    int prefix_bytes;\n    int size_scaler;\n    int chroma_x_shift;\n    int chroma_y_shift;\n\n    /* Rate control stuff */\n    int slice_max_bytes;\n    int q_ceil;\n    int q_start;\n\n    /* Options */\n    double tolerance;\n    int wavelet_idx;\n    int wavelet_depth;\n    int strict_compliance;\n    int slice_height;\n    int slice_width;\n    int interlaced;\n    enum VC2_QM quant_matrix;\n\n    /* Parse code state */\n    uint32_t next_parse_offset;\n    enum DiracParseCodes last_parse_code;\n} VC2EncContext;\n\nstatic av_always_inline void put_padding(PutBitContext *pb, int bytes)\n{\n    int bits = bytes*8;\n    if (!bits)\n        return;\n    while (bits > 31) {\n        put_bits(pb, 31, 0);\n        bits -= 31;\n    }\n    if (bits)\n        put_bits(pb, bits, 0);\n}\n\nstatic av_always_inline void put_vc2_ue_uint(PutBitContext *pb, uint32_t val)\n{\n    int i;\n    int pbits = 0, bits = 0, topbit = 1, maxval = 1;\n\n    if (!val++) {\n        put_bits(pb, 1, 1);\n        return;\n    }\n\n    while (val > maxval) {\n        topbit <<= 1;\n        maxval <<= 1;\n        maxval |=  1;\n    }\n\n    bits = ff_log2(topbit);\n\n    for (i = 0; i < bits; i++) {\n        topbit >>= 1;\n        pbits <<= 2;\n        if (val & topbit)\n            pbits |= 0x1;\n    }\n\n    put_bits(pb, bits*2 + 1, (pbits << 1) | 1);\n}\n\nstatic av_always_inline int count_vc2_ue_uint(uint16_t val)\n{\n    int topbit = 1, maxval = 1;\n\n    if (!val++)\n        return 1;\n\n    while (val > maxval) {\n        topbit <<= 1;\n        maxval <<= 1;\n        maxval |=  1;\n    }\n\n    return ff_log2(topbit)*2 + 1;\n}\n\nstatic av_always_inline void get_vc2_ue_uint(uint16_t val, uint8_t *nbits,\n                                               uint32_t *eval)\n{\n    int i;\n    int pbits = 0, bits = 0, topbit = 1, maxval = 1;\n\n    if (!val++) {\n        *nbits = 1;\n        *eval = 1;\n        return;\n    }\n\n    while (val > maxval) {\n        topbit <<= 1;\n        maxval <<= 1;\n        maxval |=  1;\n    }\n\n    bits = ff_log2(topbit);\n\n    for (i = 0; i < bits; i++) {\n        topbit >>= 1;\n        pbits <<= 2;\n        if (val & topbit)\n            pbits |= 0x1;\n    }\n\n    *nbits = bits*2 + 1;\n    *eval = (pbits << 1) | 1;\n}\n\n/* VC-2 10.4 - parse_info() */\nstatic void encode_parse_info(VC2EncContext *s, enum DiracParseCodes pcode)\n{\n    uint32_t cur_pos, dist;\n\n    avpriv_align_put_bits(&s->pb);\n\n    cur_pos = put_bits_count(&s->pb) >> 3;\n\n    /* Magic string */\n    avpriv_put_string(&s->pb, \"BBCD\", 0);\n\n    /* Parse code */\n    put_bits(&s->pb, 8, pcode);\n\n    /* Next parse offset */\n    dist = cur_pos - s->next_parse_offset;\n    AV_WB32(s->pb.buf + s->next_parse_offset + 5, dist);\n    s->next_parse_offset = cur_pos;\n    put_bits32(&s->pb, pcode == DIRAC_PCODE_END_SEQ ? 13 : 0);\n\n    /* Last parse offset */\n    put_bits32(&s->pb, s->last_parse_code == DIRAC_PCODE_END_SEQ ? 13 : dist);\n\n    s->last_parse_code = pcode;\n}\n\n/* VC-2 11.1 - parse_parameters()\n * The level dictates what the decoder should expect in terms of resolution\n * and allows it to quickly reject whatever it can't support. Remember,\n * this codec kinda targets cheapo FPGAs without much memory. Unfortunately\n * it also limits us greatly in our choice of formats, hence the flag to disable\n * strict_compliance */\nstatic void encode_parse_params(VC2EncContext *s)\n{\n    put_vc2_ue_uint(&s->pb, s->ver.major); /* VC-2 demands this to be 2 */\n    put_vc2_ue_uint(&s->pb, s->ver.minor); /* ^^ and this to be 0       */\n    put_vc2_ue_uint(&s->pb, s->profile);   /* 3 to signal HQ profile    */\n    put_vc2_ue_uint(&s->pb, s->level);     /* 3 - 1080/720, 6 - 4K      */\n}\n\n/* VC-2 11.3 - frame_size() */\nstatic void encode_frame_size(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        AVCodecContext *avctx = s->avctx;\n        put_vc2_ue_uint(&s->pb, avctx->width);\n        put_vc2_ue_uint(&s->pb, avctx->height);\n    }\n}\n\n/* VC-2 11.3.3 - color_diff_sampling_format() */\nstatic void encode_sample_fmt(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        int idx;\n        if (s->chroma_x_shift == 1 && s->chroma_y_shift == 0)\n            idx = 1; /* 422 */\n        else if (s->chroma_x_shift == 1 && s->chroma_y_shift == 1)\n            idx = 2; /* 420 */\n        else\n            idx = 0; /* 444 */\n        put_vc2_ue_uint(&s->pb, idx);\n    }\n}\n\n/* VC-2 11.3.4 - scan_format() */\nstatic void encode_scan_format(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance)\n        put_vc2_ue_uint(&s->pb, s->interlaced);\n}\n\n/* VC-2 11.3.5 - frame_rate() */\nstatic void encode_frame_rate(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        AVCodecContext *avctx = s->avctx;\n        put_vc2_ue_uint(&s->pb, 0);\n        put_vc2_ue_uint(&s->pb, avctx->time_base.den);\n        put_vc2_ue_uint(&s->pb, avctx->time_base.num);\n    }\n}\n\n/* VC-2 11.3.6 - aspect_ratio() */\nstatic void encode_aspect_ratio(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        AVCodecContext *avctx = s->avctx;\n        put_vc2_ue_uint(&s->pb, 0);\n        put_vc2_ue_uint(&s->pb, avctx->sample_aspect_ratio.num);\n        put_vc2_ue_uint(&s->pb, avctx->sample_aspect_ratio.den);\n    }\n}\n\n/* VC-2 11.3.7 - clean_area() */\nstatic void encode_clean_area(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, 0);\n}\n\n/* VC-2 11.3.8 - signal_range() */\nstatic void encode_signal_range(VC2EncContext *s)\n{\n    int idx;\n    AVCodecContext *avctx = s->avctx;\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n    const int depth = fmt->comp[0].depth;\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n        idx = 1;\n        s->bpp = 1;\n        s->diff_offset = 128;\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n        idx = 2;\n        s->bpp = 1;\n        s->diff_offset = 128;\n    } else if (depth == 10) {\n        idx = 3;\n        s->bpp = 2;\n        s->diff_offset = 512;\n    } else {\n        idx = 4;\n        s->bpp = 2;\n        s->diff_offset = 2048;\n    }\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance)\n        put_vc2_ue_uint(&s->pb, idx);\n}\n\n/* VC-2 11.3.9 - color_spec() */\nstatic void encode_color_spec(VC2EncContext *s)\n{\n    AVCodecContext *avctx = s->avctx;\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        int val;\n        put_vc2_ue_uint(&s->pb, 0);\n\n        /* primaries */\n        put_bits(&s->pb, 1, 1);\n        if (avctx->color_primaries == AVCOL_PRI_BT470BG)\n            val = 2;\n        else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M)\n            val = 1;\n        else if (avctx->color_primaries == AVCOL_PRI_SMPTE240M)\n            val = 1;\n        else\n            val = 0;\n        put_vc2_ue_uint(&s->pb, val);\n\n        /* color matrix */\n        put_bits(&s->pb, 1, 1);\n        if (avctx->colorspace == AVCOL_SPC_RGB)\n            val = 3;\n        else if (avctx->colorspace == AVCOL_SPC_YCOCG)\n            val = 2;\n        else if (avctx->colorspace == AVCOL_SPC_BT470BG)\n            val = 1;\n        else\n            val = 0;\n        put_vc2_ue_uint(&s->pb, val);\n\n        /* transfer function */\n        put_bits(&s->pb, 1, 1);\n        if (avctx->color_trc == AVCOL_TRC_LINEAR)\n            val = 2;\n        else if (avctx->color_trc == AVCOL_TRC_BT1361_ECG)\n            val = 1;\n        else\n            val = 0;\n        put_vc2_ue_uint(&s->pb, val);\n    }\n}\n\n/* VC-2 11.3 - source_parameters() */\nstatic void encode_source_params(VC2EncContext *s)\n{\n    encode_frame_size(s);\n    encode_sample_fmt(s);\n    encode_scan_format(s);\n    encode_frame_rate(s);\n    encode_aspect_ratio(s);\n    encode_clean_area(s);\n    encode_signal_range(s);\n    encode_color_spec(s);\n}\n\n/* VC-2 11 - sequence_header() */\nstatic void encode_seq_header(VC2EncContext *s)\n{\n    avpriv_align_put_bits(&s->pb);\n    encode_parse_params(s);\n    put_vc2_ue_uint(&s->pb, s->base_vf);\n    encode_source_params(s);\n    put_vc2_ue_uint(&s->pb, s->interlaced); /* Frames or fields coding */\n}\n\n/* VC-2 12.1 - picture_header() */\nstatic void encode_picture_header(VC2EncContext *s)\n{\n    avpriv_align_put_bits(&s->pb);\n    put_bits32(&s->pb, s->picture_number++);\n}\n\n/* VC-2 12.3.4.1 - slice_parameters() */\nstatic void encode_slice_params(VC2EncContext *s)\n{\n    put_vc2_ue_uint(&s->pb, s->num_x);\n    put_vc2_ue_uint(&s->pb, s->num_y);\n    put_vc2_ue_uint(&s->pb, s->prefix_bytes);\n    put_vc2_ue_uint(&s->pb, s->size_scaler);\n}\n\n/* 1st idx = LL, second - vertical, third - horizontal, fourth - total */\nconst uint8_t vc2_qm_col_tab[][4] = {\n    {20,  9, 15,  4},\n    { 0,  6,  6,  4},\n    { 0,  3,  3,  5},\n    { 0,  3,  5,  1},\n    { 0, 11, 10, 11}\n};\n\nconst uint8_t vc2_qm_flat_tab[][4] = {\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0}\n};\n\nstatic void init_custom_qm(VC2EncContext *s)\n{\n    int level, orientation;\n\n    if (s->quant_matrix == VC2_QM_DEF) {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = 0; orientation < 4; orientation++) {\n                if (level <= 3)\n                    s->quant[level][orientation] = ff_dirac_default_qmat[s->wavelet_idx][level][orientation];\n                else\n                    s->quant[level][orientation] = vc2_qm_col_tab[level][orientation];\n            }\n        }\n    } else if (s->quant_matrix == VC2_QM_COL) {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = 0; orientation < 4; orientation++) {\n                s->quant[level][orientation] = vc2_qm_col_tab[level][orientation];\n            }\n        }\n    } else {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = 0; orientation < 4; orientation++) {\n                s->quant[level][orientation] = vc2_qm_flat_tab[level][orientation];\n            }\n        }\n    }\n}\n\n/* VC-2 12.3.4.2 - quant_matrix() */\nstatic void encode_quant_matrix(VC2EncContext *s)\n{\n    int level, custom_quant_matrix = 0;\n    if (s->wavelet_depth > 4 || s->quant_matrix != VC2_QM_DEF)\n        custom_quant_matrix = 1;\n    put_bits(&s->pb, 1, custom_quant_matrix);\n    if (custom_quant_matrix) {\n        init_custom_qm(s);\n        put_vc2_ue_uint(&s->pb, s->quant[0][0]);\n        for (level = 0; level < s->wavelet_depth; level++) {\n            put_vc2_ue_uint(&s->pb, s->quant[level][1]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][2]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][3]);\n        }\n    } else {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            s->quant[level][0] = ff_dirac_default_qmat[s->wavelet_idx][level][0];\n            s->quant[level][1] = ff_dirac_default_qmat[s->wavelet_idx][level][1];\n            s->quant[level][2] = ff_dirac_default_qmat[s->wavelet_idx][level][2];\n            s->quant[level][3] = ff_dirac_default_qmat[s->wavelet_idx][level][3];\n        }\n    }\n}\n\n/* VC-2 12.3 - transform_parameters() */\nstatic void encode_transform_params(VC2EncContext *s)\n{\n    put_vc2_ue_uint(&s->pb, s->wavelet_idx);\n    put_vc2_ue_uint(&s->pb, s->wavelet_depth);\n\n    encode_slice_params(s);\n    encode_quant_matrix(s);\n}\n\n/* VC-2 12.2 - wavelet_transform() */\nstatic void encode_wavelet_transform(VC2EncContext *s)\n{\n    encode_transform_params(s);\n    avpriv_align_put_bits(&s->pb);\n    /* Continued after DWT in encode_transform_data() */\n}\n\n/* VC-2 12 - picture_parse() */\nstatic void encode_picture_start(VC2EncContext *s)\n{\n    avpriv_align_put_bits(&s->pb);\n    encode_picture_header(s);\n    avpriv_align_put_bits(&s->pb);\n    encode_wavelet_transform(s);\n}\n\n#define QUANT(c)  \\\n    c <<= 2;      \\\n    c /= qfactor; \\\n\nstatic av_always_inline void coeff_quantize_get(qcoef coeff, int qfactor,\n                                                uint8_t *len, uint32_t *eval)\n{\n    QUANT(coeff)\n    get_vc2_ue_uint(abs(coeff), len, eval);\n    if (coeff) {\n        *eval = (*eval << 1) | (coeff < 0);\n        *len += 1;\n    }\n}\n\nstatic av_always_inline void coeff_quantize_encode(PutBitContext *pb, qcoef coeff,\n                                                   int qfactor)\n{\n    QUANT(coeff)\n    put_vc2_ue_uint(pb, abs(coeff));\n    if (coeff)\n        put_bits(pb, 1, coeff < 0);\n}\n\n/* VC-2 13.5.5.2 - slice_band() */\nstatic void encode_subband(VC2EncContext *s, PutBitContext *pb, int sx, int sy,\n                           SubBand *b, int quant)\n{\n    int x, y;\n\n    int left   = b->width  * (sx+0) / s->num_x;\n    int right  = b->width  * (sx+1) / s->num_x;\n    int top    = b->height * (sy+0) / s->num_y;\n    int bottom = b->height * (sy+1) / s->num_y;\n\n    int qfactor = ff_dirac_qscale_tab[quant];\n    uint8_t  *len_lut = &s->coef_lut_len[2*quant*COEF_LUT_TAB + COEF_LUT_TAB];\n    uint32_t *val_lut = &s->coef_lut_val[2*quant*COEF_LUT_TAB + COEF_LUT_TAB];\n\n    dwtcoef *coeff = b->buf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n        for (x = left; x < right; x++) {\n            if (coeff[x] >= -COEF_LUT_TAB && coeff[x] < COEF_LUT_TAB)\n                put_bits(pb, len_lut[coeff[x]], val_lut[coeff[x]]);\n            else\n                coeff_quantize_encode(pb, coeff[x], qfactor);\n        }\n        coeff += b->stride;\n    }\n}\n\nstatic int count_hq_slice(VC2EncContext *s, int slice_x,\n                          int slice_y, int quant_idx)\n{\n    int x, y, left, right, top, bottom, qfactor;\n    uint8_t quants[MAX_DWT_LEVELS][4];\n    int bits = 0, p, level, orientation;\n\n    bits += 8*s->prefix_bytes;\n    bits += 8; /* quant_idx */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n        for (orientation = !!level; orientation < 4; orientation++)\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n    for (p = 0; p < 3; p++) {\n        int bytes_start, bytes_len, pad_s, pad_c;\n        bytes_start = bits >> 3;\n        bits += 8;\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = !!level; orientation < 4; orientation++) {\n                dwtcoef *buf;\n                SubBand *b = &s->plane[p].band[level][orientation];\n\n                quant_idx = quants[level][orientation];\n                qfactor = ff_dirac_qscale_tab[quant_idx];\n\n                left   = b->width  * slice_x    / s->num_x;\n                right  = b->width  *(slice_x+1) / s->num_x;\n                top    = b->height * slice_y    / s->num_y;\n                bottom = b->height *(slice_y+1) / s->num_y;\n\n                buf = b->buf + top * b->stride;\n\n                for (y = top; y < bottom; y++) {\n                    for (x = left; x < right; x++) {\n                        qcoef coeff = (qcoef)buf[x];\n                        if (coeff >= -COEF_LUT_TAB && coeff < COEF_LUT_TAB) {\n                            bits += s->coef_lut_len[2*quant_idx*COEF_LUT_TAB + coeff + COEF_LUT_TAB];\n                        } else {\n                            QUANT(coeff)\n                            bits += count_vc2_ue_uint(abs(coeff));\n                            bits += !!coeff;\n                        }\n                    }\n                    buf += b->stride;\n                }\n            }\n        }\n        bits += FFALIGN(bits, 8) - bits;\n        bytes_len = (bits >> 3) - bytes_start - 1;\n        pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n        pad_c = (pad_s*s->size_scaler) - bytes_len;\n        bits += pad_c*8;\n    }\n\n    return bits;\n}\n\n/* Approaches the best possible quantizer asymptotically, its kinda exaustive\n * but we have a LUT to get the coefficient size in bits. Guaranteed to never\n * overshoot, which is apparently very important when streaming */\nstatic int rate_control(AVCodecContext *avctx, void *arg)\n{\n    SliceArgs *slice_dat = arg;\n    VC2EncContext *s = slice_dat->ctx;\n    const int sx = slice_dat->x;\n    const int sy = slice_dat->y;\n    int bits_last = INT_MAX, quant_buf[2] = {-1, -1};\n    int quant = s->q_start, range = s->q_start/3;\n    const int64_t top = slice_dat->bits_ceil;\n    const double percent = s->tolerance;\n    const double bottom = top - top*(percent/100.0f);\n    int bits = count_hq_slice(s, sx, sy, quant);\n    range -= range & 1; /* Make it an even number */\n    while ((bits > top) || (bits < bottom)) {\n        range *= bits > top ? +1 : -1;\n        quant = av_clip(quant + range, 0, s->q_ceil);\n        bits = count_hq_slice(s, sx, sy, quant);\n        range = av_clip(range/2, 1, s->q_ceil);\n        if (quant_buf[1] == quant) {\n            quant = bits_last < bits ? quant_buf[0] : quant;\n            bits  = bits_last < bits ? bits_last : bits;\n            break;\n        }\n        quant_buf[1] = quant_buf[0];\n        quant_buf[0] = quant;\n        bits_last = bits;\n    }\n    slice_dat->quant_idx = av_clip(quant, 0, s->q_ceil);\n    slice_dat->bytes = FFALIGN((bits >> 3), s->size_scaler) + 4 + s->prefix_bytes;\n\n    return 0;\n}\n\nstatic void calc_slice_sizes(VC2EncContext *s)\n{\n    int slice_x, slice_y;\n    SliceArgs *enc_args = s->slice_args;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n            SliceArgs *args = &enc_args[s->num_x*slice_y + slice_x];\n            args->ctx = s;\n            args->x = slice_x;\n            args->y = slice_y;\n            args->bits_ceil = s->slice_max_bytes << 3;\n        }\n    }\n\n    /* Determine quantization indices and bytes per slice */\n    s->avctx->execute(s->avctx, rate_control, enc_args, NULL, s->num_x*s->num_y,\n                      sizeof(SliceArgs));\n}\n\n/* VC-2 13.5.3 - hq_slice */\nstatic int encode_hq_slice(AVCodecContext *avctx, void *arg)\n{\n    SliceArgs *slice_dat = arg;\n    VC2EncContext *s = slice_dat->ctx;\n    PutBitContext *pb = &slice_dat->pb;\n    const int slice_x = slice_dat->x;\n    const int slice_y = slice_dat->y;\n    const int quant_idx = slice_dat->quant_idx;\n    const int slice_bytes_max = slice_dat->bytes;\n    uint8_t quants[MAX_DWT_LEVELS][4];\n    int p, level, orientation;\n\n    avpriv_align_put_bits(pb);\n    put_padding(pb, s->prefix_bytes);\n    put_bits(pb, 8, quant_idx);\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n    for (level = 0; level < s->wavelet_depth; level++)\n        for (orientation = !!level; orientation < 4; orientation++)\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n    /* Luma + 2 Chroma planes */\n    for (p = 0; p < 3; p++) {\n        int bytes_start, bytes_len, pad_s, pad_c;\n        bytes_start = put_bits_count(pb) >> 3;\n        put_bits(pb, 8, 0);\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = !!level; orientation < 4; orientation++) {\n                encode_subband(s, pb, slice_x, slice_y,\n                               &s->plane[p].band[level][orientation],\n                               quants[level][orientation]);\n            }\n        }\n        avpriv_align_put_bits(pb);\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n        if (p == 2) {\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n        } else {\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n        }\n        pb->buf[bytes_start] = pad_s;\n        put_padding(pb, pad_c);\n    }\n\n    return 0;\n}\n\n/* VC-2 13.5.1 - low_delay_transform_data() */\nstatic int encode_slices(VC2EncContext *s)\n{\n    uint8_t *buf;\n    int slice_x, slice_y, skip = 0;\n    SliceArgs *enc_args = s->slice_args;\n\n    avpriv_align_put_bits(&s->pb);\n    flush_put_bits(&s->pb);\n    buf = put_bits_ptr(&s->pb);\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n            SliceArgs *args = &enc_args[s->num_x*slice_y + slice_x];\n            init_put_bits(&args->pb, buf + skip, args->bytes);\n            s->q_start = (s->q_start + args->quant_idx)/2;\n            skip += args->bytes;\n        }\n    }\n\n    s->avctx->execute(s->avctx, encode_hq_slice, enc_args, NULL, s->num_x*s->num_y,\n                      sizeof(SliceArgs));\n\n    skip_put_bytes(&s->pb, skip);\n\n    return 0;\n}\n\n/*\n * Transform basics for a 3 level transform\n * |---------------------------------------------------------------------|\n * |  LL-0  | HL-0  |                 |                                  |\n * |--------|-------|      HL-1       |                                  |\n * |  LH-0  | HH-0  |                 |                                  |\n * |----------------|-----------------|              HL-2                |\n * |                |                 |                                  |\n * |     LH-1       |      HH-1       |                                  |\n * |                |                 |                                  |\n * |----------------------------------|----------------------------------|\n * |                                  |                                  |\n * |                                  |                                  |\n * |                                  |                                  |\n * |              LH-2                |              HH-2                |\n * |                                  |                                  |\n * |                                  |                                  |\n * |                                  |                                  |\n * |---------------------------------------------------------------------|\n *\n * DWT transforms are generally applied by splitting the image in two vertically\n * and applying a low pass transform on the left part and a corresponding high\n * pass transform on the right hand side. This is known as the horizontal filter\n * stage.\n * After that, the same operation is performed except the image is divided\n * horizontally, with the high pass on the lower and the low pass on the higher\n * side.\n * Therefore, you're left with 4 subdivisions - known as  low-low, low-high,\n * high-low and high-high. They're referred to as orientations in the decoder\n * and encoder.\n *\n * The LL (low-low) area contains the original image downsampled by the amount\n * of levels. The rest of the areas can be thought as the details needed\n * to restore the image perfectly to its original size.\n */\n\n\nstatic int dwt_plane(AVCodecContext *avctx, void *arg)\n{\n    TransformArgs *transform_dat = arg;\n    VC2EncContext *s = transform_dat->ctx;\n    const void *frame_data = transform_dat->idata;\n    const ptrdiff_t linesize = transform_dat->istride;\n    const int field = transform_dat->field;\n    const Plane *p = transform_dat->plane;\n    VC2TransformContext *t = &transform_dat->t;\n    dwtcoef *buf = p->coef_buf;\n    const int idx = s->wavelet_idx;\n    const int skip = 1 + s->interlaced;\n\n    int x, y, level, offset;\n    ptrdiff_t pix_stride = linesize >> (s->bpp - 1);\n\n    if (field == 1) {\n        offset = 0;\n        pix_stride <<= 1;\n    } else if (field == 2) {\n        offset = pix_stride;\n        pix_stride <<= 1;\n    } else {\n        offset = 0;\n    }\n\n    if (s->bpp == 1) {\n        const uint8_t *pix = (const uint8_t *)frame_data + offset;\n        for (y = 0; y < p->height*skip; y+=skip) {\n            for (x = 0; x < p->width; x++) {\n                buf[x] = pix[x] - s->diff_offset;\n            }\n            buf += p->coef_stride;\n            pix += pix_stride;\n        }\n    } else {\n        const uint16_t *pix = (const uint16_t *)frame_data + offset;\n        for (y = 0; y < p->height*skip; y+=skip) {\n            for (x = 0; x < p->width; x++) {\n                buf[x] = pix[x] - s->diff_offset;\n            }\n            buf += p->coef_stride;\n            pix += pix_stride;\n        }\n    }\n\n    memset(buf, 0, p->coef_stride * (p->dwt_height - p->height) * sizeof(dwtcoef));\n\n    for (level = s->wavelet_depth-1; level >= 0; level--) {\n        const SubBand *b = &p->band[level][0];\n        t->vc2_subband_dwt[idx](t, p->coef_buf, p->coef_stride,\n                                b->width, b->height);\n    }\n\n    return 0;\n}\n\nstatic void encode_frame(VC2EncContext *s, const AVFrame *frame,\n                         const char *aux_data, int field)\n{\n    int i;\n\n    /* Sequence header */\n    encode_parse_info(s, DIRAC_PCODE_SEQ_HEADER);\n    encode_seq_header(s);\n\n    /* Encoder version */\n    if (aux_data) {\n        encode_parse_info(s, DIRAC_PCODE_AUX);\n        avpriv_put_string(&s->pb, aux_data, 1);\n    }\n\n    /* Picture header */\n    encode_parse_info(s, DIRAC_PCODE_PICTURE_HQ);\n    encode_picture_start(s);\n\n    for (i = 0; i < 3; i++) {\n        s->transform_args[i].ctx   = s;\n        s->transform_args[i].field = field;\n        s->transform_args[i].plane = &s->plane[i];\n        s->transform_args[i].idata = frame->data[i];\n        s->transform_args[i].istride = frame->linesize[i];\n    }\n\n    /* Do a DWT transform */\n    s->avctx->execute(s->avctx, dwt_plane, s->transform_args, NULL, 3,\n                      sizeof(TransformArgs));\n\n    /* Calculate per-slice quantizers and sizes */\n    calc_slice_sizes(s);\n\n    /* Init planes and encode slices */\n    encode_slices(s);\n\n    /* End sequence */\n    encode_parse_info(s, DIRAC_PCODE_END_SEQ);\n}\n\nstatic av_cold int vc2_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n                                      const AVFrame *frame, int *got_packet_ptr)\n{\n    int ret;\n    int max_frame_bytes, sig_size = 256;\n    VC2EncContext *s = avctx->priv_data;\n    const char aux_data[] = \"FFmpeg version \"FFMPEG_VERSION;\n    const int aux_data_size = sizeof(aux_data);\n    const int header_size = 100 + aux_data_size;\n    int64_t r_bitrate = avctx->bit_rate >> (s->interlaced);\n\n    s->avctx = avctx;\n    s->size_scaler = 1;\n    s->prefix_bytes = 0;\n    s->last_parse_code = 0;\n    s->next_parse_offset = 0;\n\n    /* Rate control */\n    max_frame_bytes = (av_rescale(r_bitrate, s->avctx->time_base.num,\n                                  s->avctx->time_base.den) >> 3) - header_size;\n\n    /* Find an appropriate size scaler */\n    while (sig_size > 255) {\n        s->slice_max_bytes = FFALIGN(av_rescale(max_frame_bytes, 1,\n                                     s->num_x*s->num_y), s->size_scaler);\n        s->slice_max_bytes += 4 + s->prefix_bytes;\n        sig_size = s->slice_max_bytes/s->size_scaler; /* Signalled slize size */\n        s->size_scaler <<= 1;\n    }\n\n    ret = ff_alloc_packet2(avctx, avpkt, max_frame_bytes*2, 0);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n        return ret;\n    } else {\n        init_put_bits(&s->pb, avpkt->data, avpkt->size);\n    }\n\n    encode_frame(s, frame, aux_data, s->interlaced);\n    if (s->interlaced)\n        encode_frame(s, frame, NULL, 2);\n\n    flush_put_bits(&s->pb);\n    avpkt->size = put_bits_count(&s->pb) >> 3;\n\n    *got_packet_ptr = 1;\n\n    return 0;\n}\n\nstatic av_cold int vc2_encode_end(AVCodecContext *avctx)\n{\n    int i;\n    VC2EncContext *s = avctx->priv_data;\n\n    for (i = 0; i < 3; i++) {\n        ff_vc2enc_free_transforms(&s->transform_args[i].t);\n        av_freep(&s->plane[i].coef_buf);\n    }\n\n    av_freep(&s->slice_args);\n    av_freep(&s->coef_lut_len);\n    av_freep(&s->coef_lut_val);\n\n    return 0;\n}\n\n\nstatic av_cold int vc2_encode_init(AVCodecContext *avctx)\n{\n    Plane *p;\n    SubBand *b;\n    int i, j, level, o, shift;\n    VC2EncContext *s = avctx->priv_data;\n\n    s->picture_number = 0;\n\n    /* Total allowed quantization range */\n    s->q_ceil    = MAX_QUANT_INDEX;\n\n    s->ver.major = 2;\n    s->ver.minor = 0;\n    s->profile   = 3;\n    s->level     = 3;\n\n    s->base_vf   = -1;\n    s->strict_compliance = 1;\n\n    /* Mark unknown as progressive */\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n    if (avctx->pix_fmt == AV_PIX_FMT_YUV422P10) {\n        if (avctx->width == 1280 && avctx->height == 720) {\n            s->level = 3;\n            if (avctx->time_base.num == 1001 && avctx->time_base.den == 60000)\n                s->base_vf = 9;\n            if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                s->base_vf = 10;\n        } else if (avctx->width == 1920 && avctx->height == 1080) {\n            s->level = 3;\n            if (s->interlaced) {\n                if (avctx->time_base.num == 1001 && avctx->time_base.den == 30000)\n                    s->base_vf = 11;\n                if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                    s->base_vf = 12;\n            } else {\n                if (avctx->time_base.num == 1001 && avctx->time_base.den == 60000)\n                    s->base_vf = 13;\n                if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                    s->base_vf = 14;\n                if (avctx->time_base.num == 1001 && avctx->time_base.den == 24000)\n                    s->base_vf = 21;\n            }\n        } else if (avctx->width == 3840 && avctx->height == 2160) {\n            s->level = 6;\n            if (avctx->time_base.num == 1001 && avctx->time_base.den == 60000)\n                s->base_vf = 17;\n            if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                s->base_vf = 18;\n        }\n    }\n\n    if (s->interlaced && s->base_vf <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Interlacing not supported with non standard formats!\\n\");\n        return AVERROR_UNKNOWN;\n    }\n\n    if (s->interlaced)\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n        (s->slice_height & (s->slice_height - 1))) {\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n        return AVERROR_UNKNOWN;\n    }\n\n    if ((s->slice_width > avctx->width) ||\n        (s->slice_height > avctx->height)) {\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n        return AVERROR_UNKNOWN;\n    }\n\n    if (s->base_vf <= 0) {\n        if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n            s->strict_compliance = s->base_vf = 0;\n            av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\");\n        } else {\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n                   \"the specifications, please add a -strict -1 flag to use it\\n\");\n            return AVERROR_UNKNOWN;\n        }\n    } else {\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i\\n\", s->base_vf);\n    }\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n    /* Planes initialization */\n    for (i = 0; i < 3; i++) {\n        int w, h;\n        p = &s->plane[i];\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n        if (s->interlaced)\n            p->height >>= 1;\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n        if (!p->coef_buf)\n            goto alloc_fail;\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n            w = w >> 1;\n            h = h >> 1;\n            for (o = 0; o < 4; o++) {\n                b = &p->band[level][o];\n                b->width  = w;\n                b->height = h;\n                b->stride = p->coef_stride;\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n                b->buf = p->coef_buf + shift;\n            }\n        }\n\n        /* DWT init */\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n                                        s->plane[0].coef_stride,\n                                        s->plane[0].dwt_height))\n            goto alloc_fail;\n    }\n\n    /* Slices */\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n    s->slice_args = av_malloc(s->num_x*s->num_y*sizeof(SliceArgs));\n    if (!s->slice_args)\n        goto alloc_fail;\n\n    /* Lookup tables */\n    s->coef_lut_len = av_malloc(2*COEF_LUT_TAB*s->q_ceil*sizeof(*s->coef_lut_len));\n    if (!s->coef_lut_len)\n        goto alloc_fail;\n\n    s->coef_lut_val = av_malloc(2*COEF_LUT_TAB*s->q_ceil*sizeof(*s->coef_lut_val));\n    if (!s->coef_lut_val)\n        goto alloc_fail;\n\n    for (i = 0; i < s->q_ceil; i++) {\n        for (j = -COEF_LUT_TAB; j < COEF_LUT_TAB; j++) {\n            uint8_t  *len_lut = &s->coef_lut_len[2*i*COEF_LUT_TAB + COEF_LUT_TAB];\n            uint32_t *val_lut = &s->coef_lut_val[2*i*COEF_LUT_TAB + COEF_LUT_TAB];\n            coeff_quantize_get(j, ff_dirac_qscale_tab[i], &len_lut[j], &val_lut[j]);\n        }\n    }\n\n    return 0;\n\nalloc_fail:\n    vc2_encode_end(avctx);\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n    return AVERROR(ENOMEM);\n}\n\n#define VC2ENC_FLAGS (AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)\nstatic const AVOption vc2enc_options[] = {\n    {\"tolerance\",     \"Max undershoot in percent\", offsetof(VC2EncContext, tolerance), AV_OPT_TYPE_DOUBLE, {.dbl = 10.0f}, 0.0f, 45.0f, VC2ENC_FLAGS, \"tolerance\"},\n    {\"slice_width\",   \"Slice width\",  offsetof(VC2EncContext, slice_width), AV_OPT_TYPE_INT, {.i64 = 128}, 32, 1024, VC2ENC_FLAGS, \"slice_width\"},\n    {\"slice_height\",  \"Slice height\", offsetof(VC2EncContext, slice_height), AV_OPT_TYPE_INT, {.i64 = 64}, 8, 1024, VC2ENC_FLAGS, \"slice_height\"},\n    {\"wavelet_depth\", \"Transform depth\", offsetof(VC2EncContext, wavelet_depth), AV_OPT_TYPE_INT, {.i64 = 5}, 1, 5, VC2ENC_FLAGS, \"wavelet_depth\"},\n    {\"wavelet_type\",  \"Transform type\",  offsetof(VC2EncContext, wavelet_idx), AV_OPT_TYPE_INT, {.i64 = VC2_TRANSFORM_9_7}, 0, VC2_TRANSFORMS_NB, VC2ENC_FLAGS, \"wavelet_idx\"},\n        {\"9_7\",       \"Deslauriers-Dubuc (9,7)\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_TRANSFORM_9_7}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"wavelet_idx\"},\n        {\"5_3\",       \"LeGall (5,3)\",            0, AV_OPT_TYPE_CONST, {.i64 = VC2_TRANSFORM_5_3}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"wavelet_idx\"},\n    {\"qm\", \"Custom quantization matrix\", offsetof(VC2EncContext, quant_matrix), AV_OPT_TYPE_INT, {.i64 = VC2_QM_DEF}, 0, VC2_QM_NB, VC2ENC_FLAGS, \"quant_matrix\"},\n        {\"default\",   \"Default from the specifications\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_QM_DEF}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"quant_matrix\"},\n        {\"color\",     \"Prevents low bitrate discoloration\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_QM_COL}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"quant_matrix\"},\n        {\"flat\",      \"Optimize for PSNR\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_QM_FLAT}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"quant_matrix\"},\n    {NULL}\n};\n\nstatic const AVClass vc2enc_class = {\n    .class_name = \"SMPTE VC-2 encoder\",\n    .category = AV_CLASS_CATEGORY_ENCODER,\n    .option = vc2enc_options,\n    .item_name = av_default_item_name,\n    .version = LIBAVUTIL_VERSION_INT\n};\n\nstatic const AVCodecDefault vc2enc_defaults[] = {\n    { \"b\",              \"600000000\"   },\n    { NULL },\n};\n\nstatic const enum AVPixelFormat allowed_pix_fmts[] = {\n    AV_PIX_FMT_YUV420P,   AV_PIX_FMT_YUV422P,   AV_PIX_FMT_YUV444P,\n    AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10,\n    AV_PIX_FMT_YUV420P12, AV_PIX_FMT_YUV422P12, AV_PIX_FMT_YUV444P12,\n    AV_PIX_FMT_NONE\n};\n\nAVCodec ff_vc2_encoder = {\n    .name = \"vc2\",\n    .long_name = NULL_IF_CONFIG_SMALL(\"SMPTE VC-2\"),\n    .type = AVMEDIA_TYPE_VIDEO,\n    .id = AV_CODEC_ID_DIRAC,\n    .priv_data_size = sizeof(VC2EncContext),\n    .init = vc2_encode_init,\n    .close = vc2_encode_end,\n    .capabilities = AV_CODEC_CAP_SLICE_THREADS,\n    .encode2 = vc2_encode_frame,\n    .priv_class = &vc2enc_class,\n    .defaults = vc2enc_defaults,\n    .pix_fmts = allowed_pix_fmts\n};\n", "/*\n * Copyright (C) 2007 Marco Gerards <marco@gnu.org>\n * Copyright (C) 2016 Open Broadcast Systems Ltd.\n * Author        2016 Rostislav Pehlivanov <atomnuker@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/mem.h\"\n#include \"vc2enc_dwt.h\"\n\n/* Since the transforms spit out interleaved coefficients, this function\n * rearranges the coefficients into the more traditional subdivision,\n * making it easier to encode and perform another level. */\nstatic av_always_inline void deinterleave(dwtcoef *linell, ptrdiff_t stride,\n                                          int width, int height, dwtcoef *synthl)\n{\n    int x, y;\n    ptrdiff_t synthw = width << 1;\n    dwtcoef *linehl = linell + width;\n    dwtcoef *linelh = linell + height*stride;\n    dwtcoef *linehh = linelh + width;\n\n    /* Deinterleave the coefficients. */\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            linell[x] = synthl[(x << 1)];\n            linehl[x] = synthl[(x << 1) + 1];\n            linelh[x] = synthl[(x << 1) + synthw];\n            linehh[x] = synthl[(x << 1) + synthw + 1];\n        }\n        synthl += synthw << 1;\n        linell += stride;\n        linelh += stride;\n        linehl += stride;\n        linehh += stride;\n    }\n}\n\nstatic void vc2_subband_dwt_97(VC2TransformContext *t, dwtcoef *data,\n                               ptrdiff_t stride, int width, int height)\n{\n    int x, y;\n    dwtcoef *datal = data, *synth = t->buffer, *synthl = synth;\n    const ptrdiff_t synth_width  = width  << 1;\n    const ptrdiff_t synth_height = height << 1;\n\n    /*\n     * Shift in one bit that is used for additional precision and copy\n     * the data to the buffer.\n     */\n    for (y = 0; y < synth_height; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] = datal[x] << 1;\n        synthl += synth_width;\n        datal += stride;\n    }\n\n    /* Horizontal synthesis. */\n    synthl = synth;\n    for (y = 0; y < synth_height; y++) {\n        /* Lifting stage 2. */\n        synthl[1] -= (8*synthl[0] + 9*synthl[2] - synthl[4] + 8) >> 4;\n        for (x = 1; x < width - 2; x++)\n            synthl[2*x + 1] -= (9*synthl[2*x] + 9*synthl[2*x + 2] - synthl[2*x + 4] -\n                                synthl[2 * x - 2] + 8) >> 4;\n        synthl[synth_width - 1] -= (17*synthl[synth_width - 2] -\n                                    synthl[synth_width - 4] + 8) >> 4;\n        synthl[synth_width - 3] -= (8*synthl[synth_width - 2] +\n                                    9*synthl[synth_width - 4] -\n                                    synthl[synth_width - 6] + 8) >> 4;\n        /* Lifting stage 1. */\n        synthl[0] += (synthl[1] + synthl[1] + 2) >> 2;\n        for (x = 1; x < width - 1; x++)\n            synthl[2*x] += (synthl[2*x - 1] + synthl[2*x + 1] + 2) >> 2;\n\n        synthl[synth_width - 2] += (synthl[synth_width - 3] +\n                                    synthl[synth_width - 1] + 2) >> 2;\n        synthl += synth_width;\n    }\n\n    /* Vertical synthesis: Lifting stage 2. */\n    synthl = synth + synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] -= (8*synthl[x - synth_width] + 9*synthl[x + synth_width] -\n                      synthl[x + 3 * synth_width] + 8) >> 4;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 2; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x + synth_width] -= (9*synthl[x] +\n                                        9*synthl[x + 2 * synth_width] -\n                                        synthl[x - 2 * synth_width] -\n                                        synthl[x + 4 * synth_width] + 8) >> 4;\n        synthl += synth_width << 1;\n    }\n\n    synthl = synth + (synth_height - 1) * synth_width;\n    for (x = 0; x < synth_width; x++) {\n        synthl[x] -= (17*synthl[x - synth_width] -\n                      synthl[x - 3*synth_width] + 8) >> 4;\n                      synthl[x - 2*synth_width] -= (9*synthl[x - 3*synth_width] +\n                      8*synthl[x - 1*synth_width] - synthl[x - 5*synth_width] + 8) >> 4;\n    }\n\n    /* Vertical synthesis: Lifting stage 1. */\n    synthl = synth;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (synthl[x + synth_width] + synthl[x + synth_width] + 2) >> 2;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 1; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] += (synthl[x - synth_width] + synthl[x + synth_width] + 2) >> 2;\n        synthl += synth_width << 1;\n    }\n\n    synthl = synth + (synth_height - 2) * synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (synthl[x - synth_width] + synthl[x + synth_width] + 2) >> 2;\n\n    deinterleave(data, stride, width, height, synth);\n}\n\nstatic void vc2_subband_dwt_53(VC2TransformContext *t, dwtcoef *data,\n                               ptrdiff_t stride, int width, int height)\n{\n    int x, y;\n    dwtcoef *synth = t->buffer, *synthl = synth, *datal = data;\n    const ptrdiff_t synth_width  = width  << 1;\n    const ptrdiff_t synth_height = height << 1;\n\n    /*\n     * Shift in one bit that is used for additional precision and copy\n     * the data to the buffer.\n     */\n    for (y = 0; y < synth_height; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] = datal[x] << 1;\n        synthl += synth_width;\n        datal  += stride;\n    }\n\n    /* Horizontal synthesis. */\n    synthl = synth;\n    for (y = 0; y < synth_height; y++) {\n        /* Lifting stage 2. */\n        for (x = 0; x < width - 1; x++)\n            synthl[2 * x + 1] -= (synthl[2 * x] + synthl[2 * x + 2] + 1) >> 1;\n\n        synthl[synth_width - 1] -= (2*synthl[synth_width - 2] + 1) >> 1;\n\n        /* Lifting stage 1. */\n        synthl[0] += (2*synthl[1] + 2) >> 2;\n        for (x = 1; x < width - 1; x++)\n            synthl[2 * x] += (synthl[2 * x - 1] + synthl[2 * x + 1] + 2) >> 2;\n\n        synthl[synth_width - 2] += (synthl[synth_width - 3] + synthl[synth_width - 1] + 2) >> 2;\n\n        synthl += synth_width;\n    }\n\n    /* Vertical synthesis: Lifting stage 2. */\n    synthl = synth + synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] -= (synthl[x - synth_width] + synthl[x + synth_width] + 1) >> 1;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 1; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x + synth_width] -= (synthl[x] + synthl[x + synth_width * 2] + 1) >> 1;\n        synthl += (synth_width << 1);\n    }\n\n    synthl = synth + (synth_height - 1) * synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] -= (2*synthl[x - synth_width] + 1) >> 1;\n\n    /* Vertical synthesis: Lifting stage 1. */\n    synthl = synth;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (2*synthl[synth_width + x] + 2) >> 2;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 1; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] += (synthl[x + synth_width] + synthl[x - synth_width] + 2) >> 2;\n        synthl += (synth_width << 1);\n    }\n\n    synthl = synth + (synth_height - 2)*synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (synthl[x - synth_width] + synthl[x + synth_width] + 2) >> 2;\n\n\n    deinterleave(data, stride, width, height, synth);\n}\n\nav_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)\n{\n    s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n    s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n\n    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));\n    if (!s->buffer)\n        return 1;\n\n    return 0;\n}\n\nav_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}\n", "/*\n * Copyright (C) 2016 Open Broadcast Systems Ltd.\n * Author        2016 Rostislav Pehlivanov <atomnuker@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef AVCODEC_VC2ENC_DWT_H\n#define AVCODEC_VC2ENC_DWT_H\n\n#include <stddef.h>\n#include <stdint.h>\n\ntypedef int16_t dwtcoef;\ntypedef int32_t qcoef;   /* Quantization needs more precision */\n\n/* Only Deslauriers-Dubuc (9,7) and LeGall (5,3) supported! */\n\nenum VC2TransformType {\n    VC2_TRANSFORM_9_7    = 0,   /* Deslauriers-Dubuc (9,7)  */\n    VC2_TRANSFORM_5_3    = 1,   /* LeGall (5,3)             */\n    VC2_TRANSFORM_13_7   = 2,   /* Deslauriers-Dubuc (13,7) */\n    VC2_TRANSFORM_HAAR   = 3,   /* Haar without shift       */\n    VC2_TRANSFORM_HAAR_S = 4,   /* Haar with 1 shift/lvl    */\n    VC2_TRANSFORM_FIDEL  = 5,   /* Fidelity filter          */\n    VC2_TRANSFORM_9_7_I  = 6,   /* Daubechies (9,7)         */\n\n    VC2_TRANSFORMS_NB\n};\n\ntypedef struct VC2TransformContext {\n    dwtcoef *buffer;\n    void (*vc2_subband_dwt[VC2_TRANSFORMS_NB])(struct VC2TransformContext *t,\n                                               dwtcoef *data, ptrdiff_t stride,\n                                               int width, int height);\n} VC2TransformContext;\n\nint  ff_vc2enc_init_transforms(VC2TransformContext *t, int p_width, int p_height);\nvoid ff_vc2enc_free_transforms(VC2TransformContext *t);\n\n#endif /* AVCODEC_VC2ENC_DWT_H */\n"], "fixing_code": ["/*\n * Copyright (C) 2016 Open Broadcast Systems Ltd.\n * Author        2016 Rostislav Pehlivanov <atomnuker@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/ffversion.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/opt.h\"\n#include \"dirac.h\"\n#include \"put_bits.h\"\n#include \"internal.h\"\n\n#include \"vc2enc_dwt.h\"\n#include \"diractab.h\"\n\n/* Quantizations above this usually zero coefficients and lower the quality */\n#define MAX_QUANT_INDEX 100\n\n#define COEF_LUT_TAB 2048\n\nenum VC2_QM {\n    VC2_QM_DEF = 0,\n    VC2_QM_COL,\n    VC2_QM_FLAT,\n\n    VC2_QM_NB\n};\n\ntypedef struct SubBand {\n    dwtcoef *buf;\n    ptrdiff_t stride;\n    int width;\n    int height;\n} SubBand;\n\ntypedef struct Plane {\n    SubBand band[MAX_DWT_LEVELS][4];\n    dwtcoef *coef_buf;\n    int width;\n    int height;\n    int dwt_width;\n    int dwt_height;\n    ptrdiff_t coef_stride;\n} Plane;\n\ntypedef struct SliceArgs {\n    PutBitContext pb;\n    void *ctx;\n    int x;\n    int y;\n    int quant_idx;\n    int bits_ceil;\n    int bytes;\n} SliceArgs;\n\ntypedef struct TransformArgs {\n    void *ctx;\n    Plane *plane;\n    void *idata;\n    ptrdiff_t istride;\n    int field;\n    VC2TransformContext t;\n} TransformArgs;\n\ntypedef struct VC2EncContext {\n    AVClass *av_class;\n    PutBitContext pb;\n    Plane plane[3];\n    AVCodecContext *avctx;\n    DiracVersionInfo ver;\n\n    SliceArgs *slice_args;\n    TransformArgs transform_args[3];\n\n    /* For conversion from unsigned pixel values to signed */\n    int diff_offset;\n    int bpp;\n\n    /* Picture number */\n    uint32_t picture_number;\n\n    /* Base video format */\n    int base_vf;\n    int level;\n    int profile;\n\n    /* Quantization matrix */\n    uint8_t quant[MAX_DWT_LEVELS][4];\n\n    /* Coefficient LUT */\n    uint32_t *coef_lut_val;\n    uint8_t  *coef_lut_len;\n\n    int num_x; /* #slices horizontally */\n    int num_y; /* #slices vertically */\n    int prefix_bytes;\n    int size_scaler;\n    int chroma_x_shift;\n    int chroma_y_shift;\n\n    /* Rate control stuff */\n    int slice_max_bytes;\n    int q_ceil;\n    int q_start;\n\n    /* Options */\n    double tolerance;\n    int wavelet_idx;\n    int wavelet_depth;\n    int strict_compliance;\n    int slice_height;\n    int slice_width;\n    int interlaced;\n    enum VC2_QM quant_matrix;\n\n    /* Parse code state */\n    uint32_t next_parse_offset;\n    enum DiracParseCodes last_parse_code;\n} VC2EncContext;\n\nstatic av_always_inline void put_padding(PutBitContext *pb, int bytes)\n{\n    int bits = bytes*8;\n    if (!bits)\n        return;\n    while (bits > 31) {\n        put_bits(pb, 31, 0);\n        bits -= 31;\n    }\n    if (bits)\n        put_bits(pb, bits, 0);\n}\n\nstatic av_always_inline void put_vc2_ue_uint(PutBitContext *pb, uint32_t val)\n{\n    int i;\n    int pbits = 0, bits = 0, topbit = 1, maxval = 1;\n\n    if (!val++) {\n        put_bits(pb, 1, 1);\n        return;\n    }\n\n    while (val > maxval) {\n        topbit <<= 1;\n        maxval <<= 1;\n        maxval |=  1;\n    }\n\n    bits = ff_log2(topbit);\n\n    for (i = 0; i < bits; i++) {\n        topbit >>= 1;\n        pbits <<= 2;\n        if (val & topbit)\n            pbits |= 0x1;\n    }\n\n    put_bits(pb, bits*2 + 1, (pbits << 1) | 1);\n}\n\nstatic av_always_inline int count_vc2_ue_uint(uint16_t val)\n{\n    int topbit = 1, maxval = 1;\n\n    if (!val++)\n        return 1;\n\n    while (val > maxval) {\n        topbit <<= 1;\n        maxval <<= 1;\n        maxval |=  1;\n    }\n\n    return ff_log2(topbit)*2 + 1;\n}\n\nstatic av_always_inline void get_vc2_ue_uint(uint16_t val, uint8_t *nbits,\n                                               uint32_t *eval)\n{\n    int i;\n    int pbits = 0, bits = 0, topbit = 1, maxval = 1;\n\n    if (!val++) {\n        *nbits = 1;\n        *eval = 1;\n        return;\n    }\n\n    while (val > maxval) {\n        topbit <<= 1;\n        maxval <<= 1;\n        maxval |=  1;\n    }\n\n    bits = ff_log2(topbit);\n\n    for (i = 0; i < bits; i++) {\n        topbit >>= 1;\n        pbits <<= 2;\n        if (val & topbit)\n            pbits |= 0x1;\n    }\n\n    *nbits = bits*2 + 1;\n    *eval = (pbits << 1) | 1;\n}\n\n/* VC-2 10.4 - parse_info() */\nstatic void encode_parse_info(VC2EncContext *s, enum DiracParseCodes pcode)\n{\n    uint32_t cur_pos, dist;\n\n    avpriv_align_put_bits(&s->pb);\n\n    cur_pos = put_bits_count(&s->pb) >> 3;\n\n    /* Magic string */\n    avpriv_put_string(&s->pb, \"BBCD\", 0);\n\n    /* Parse code */\n    put_bits(&s->pb, 8, pcode);\n\n    /* Next parse offset */\n    dist = cur_pos - s->next_parse_offset;\n    AV_WB32(s->pb.buf + s->next_parse_offset + 5, dist);\n    s->next_parse_offset = cur_pos;\n    put_bits32(&s->pb, pcode == DIRAC_PCODE_END_SEQ ? 13 : 0);\n\n    /* Last parse offset */\n    put_bits32(&s->pb, s->last_parse_code == DIRAC_PCODE_END_SEQ ? 13 : dist);\n\n    s->last_parse_code = pcode;\n}\n\n/* VC-2 11.1 - parse_parameters()\n * The level dictates what the decoder should expect in terms of resolution\n * and allows it to quickly reject whatever it can't support. Remember,\n * this codec kinda targets cheapo FPGAs without much memory. Unfortunately\n * it also limits us greatly in our choice of formats, hence the flag to disable\n * strict_compliance */\nstatic void encode_parse_params(VC2EncContext *s)\n{\n    put_vc2_ue_uint(&s->pb, s->ver.major); /* VC-2 demands this to be 2 */\n    put_vc2_ue_uint(&s->pb, s->ver.minor); /* ^^ and this to be 0       */\n    put_vc2_ue_uint(&s->pb, s->profile);   /* 3 to signal HQ profile    */\n    put_vc2_ue_uint(&s->pb, s->level);     /* 3 - 1080/720, 6 - 4K      */\n}\n\n/* VC-2 11.3 - frame_size() */\nstatic void encode_frame_size(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        AVCodecContext *avctx = s->avctx;\n        put_vc2_ue_uint(&s->pb, avctx->width);\n        put_vc2_ue_uint(&s->pb, avctx->height);\n    }\n}\n\n/* VC-2 11.3.3 - color_diff_sampling_format() */\nstatic void encode_sample_fmt(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        int idx;\n        if (s->chroma_x_shift == 1 && s->chroma_y_shift == 0)\n            idx = 1; /* 422 */\n        else if (s->chroma_x_shift == 1 && s->chroma_y_shift == 1)\n            idx = 2; /* 420 */\n        else\n            idx = 0; /* 444 */\n        put_vc2_ue_uint(&s->pb, idx);\n    }\n}\n\n/* VC-2 11.3.4 - scan_format() */\nstatic void encode_scan_format(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance)\n        put_vc2_ue_uint(&s->pb, s->interlaced);\n}\n\n/* VC-2 11.3.5 - frame_rate() */\nstatic void encode_frame_rate(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        AVCodecContext *avctx = s->avctx;\n        put_vc2_ue_uint(&s->pb, 0);\n        put_vc2_ue_uint(&s->pb, avctx->time_base.den);\n        put_vc2_ue_uint(&s->pb, avctx->time_base.num);\n    }\n}\n\n/* VC-2 11.3.6 - aspect_ratio() */\nstatic void encode_aspect_ratio(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        AVCodecContext *avctx = s->avctx;\n        put_vc2_ue_uint(&s->pb, 0);\n        put_vc2_ue_uint(&s->pb, avctx->sample_aspect_ratio.num);\n        put_vc2_ue_uint(&s->pb, avctx->sample_aspect_ratio.den);\n    }\n}\n\n/* VC-2 11.3.7 - clean_area() */\nstatic void encode_clean_area(VC2EncContext *s)\n{\n    put_bits(&s->pb, 1, 0);\n}\n\n/* VC-2 11.3.8 - signal_range() */\nstatic void encode_signal_range(VC2EncContext *s)\n{\n    int idx;\n    AVCodecContext *avctx = s->avctx;\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n    const int depth = fmt->comp[0].depth;\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n        idx = 1;\n        s->bpp = 1;\n        s->diff_offset = 128;\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n        idx = 2;\n        s->bpp = 1;\n        s->diff_offset = 128;\n    } else if (depth == 10) {\n        idx = 3;\n        s->bpp = 2;\n        s->diff_offset = 512;\n    } else {\n        idx = 4;\n        s->bpp = 2;\n        s->diff_offset = 2048;\n    }\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance)\n        put_vc2_ue_uint(&s->pb, idx);\n}\n\n/* VC-2 11.3.9 - color_spec() */\nstatic void encode_color_spec(VC2EncContext *s)\n{\n    AVCodecContext *avctx = s->avctx;\n    put_bits(&s->pb, 1, !s->strict_compliance);\n    if (!s->strict_compliance) {\n        int val;\n        put_vc2_ue_uint(&s->pb, 0);\n\n        /* primaries */\n        put_bits(&s->pb, 1, 1);\n        if (avctx->color_primaries == AVCOL_PRI_BT470BG)\n            val = 2;\n        else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M)\n            val = 1;\n        else if (avctx->color_primaries == AVCOL_PRI_SMPTE240M)\n            val = 1;\n        else\n            val = 0;\n        put_vc2_ue_uint(&s->pb, val);\n\n        /* color matrix */\n        put_bits(&s->pb, 1, 1);\n        if (avctx->colorspace == AVCOL_SPC_RGB)\n            val = 3;\n        else if (avctx->colorspace == AVCOL_SPC_YCOCG)\n            val = 2;\n        else if (avctx->colorspace == AVCOL_SPC_BT470BG)\n            val = 1;\n        else\n            val = 0;\n        put_vc2_ue_uint(&s->pb, val);\n\n        /* transfer function */\n        put_bits(&s->pb, 1, 1);\n        if (avctx->color_trc == AVCOL_TRC_LINEAR)\n            val = 2;\n        else if (avctx->color_trc == AVCOL_TRC_BT1361_ECG)\n            val = 1;\n        else\n            val = 0;\n        put_vc2_ue_uint(&s->pb, val);\n    }\n}\n\n/* VC-2 11.3 - source_parameters() */\nstatic void encode_source_params(VC2EncContext *s)\n{\n    encode_frame_size(s);\n    encode_sample_fmt(s);\n    encode_scan_format(s);\n    encode_frame_rate(s);\n    encode_aspect_ratio(s);\n    encode_clean_area(s);\n    encode_signal_range(s);\n    encode_color_spec(s);\n}\n\n/* VC-2 11 - sequence_header() */\nstatic void encode_seq_header(VC2EncContext *s)\n{\n    avpriv_align_put_bits(&s->pb);\n    encode_parse_params(s);\n    put_vc2_ue_uint(&s->pb, s->base_vf);\n    encode_source_params(s);\n    put_vc2_ue_uint(&s->pb, s->interlaced); /* Frames or fields coding */\n}\n\n/* VC-2 12.1 - picture_header() */\nstatic void encode_picture_header(VC2EncContext *s)\n{\n    avpriv_align_put_bits(&s->pb);\n    put_bits32(&s->pb, s->picture_number++);\n}\n\n/* VC-2 12.3.4.1 - slice_parameters() */\nstatic void encode_slice_params(VC2EncContext *s)\n{\n    put_vc2_ue_uint(&s->pb, s->num_x);\n    put_vc2_ue_uint(&s->pb, s->num_y);\n    put_vc2_ue_uint(&s->pb, s->prefix_bytes);\n    put_vc2_ue_uint(&s->pb, s->size_scaler);\n}\n\n/* 1st idx = LL, second - vertical, third - horizontal, fourth - total */\nconst uint8_t vc2_qm_col_tab[][4] = {\n    {20,  9, 15,  4},\n    { 0,  6,  6,  4},\n    { 0,  3,  3,  5},\n    { 0,  3,  5,  1},\n    { 0, 11, 10, 11}\n};\n\nconst uint8_t vc2_qm_flat_tab[][4] = {\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0},\n    { 0,  0,  0,  0}\n};\n\nstatic void init_custom_qm(VC2EncContext *s)\n{\n    int level, orientation;\n\n    if (s->quant_matrix == VC2_QM_DEF) {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = 0; orientation < 4; orientation++) {\n                if (level <= 3)\n                    s->quant[level][orientation] = ff_dirac_default_qmat[s->wavelet_idx][level][orientation];\n                else\n                    s->quant[level][orientation] = vc2_qm_col_tab[level][orientation];\n            }\n        }\n    } else if (s->quant_matrix == VC2_QM_COL) {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = 0; orientation < 4; orientation++) {\n                s->quant[level][orientation] = vc2_qm_col_tab[level][orientation];\n            }\n        }\n    } else {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = 0; orientation < 4; orientation++) {\n                s->quant[level][orientation] = vc2_qm_flat_tab[level][orientation];\n            }\n        }\n    }\n}\n\n/* VC-2 12.3.4.2 - quant_matrix() */\nstatic void encode_quant_matrix(VC2EncContext *s)\n{\n    int level, custom_quant_matrix = 0;\n    if (s->wavelet_depth > 4 || s->quant_matrix != VC2_QM_DEF)\n        custom_quant_matrix = 1;\n    put_bits(&s->pb, 1, custom_quant_matrix);\n    if (custom_quant_matrix) {\n        init_custom_qm(s);\n        put_vc2_ue_uint(&s->pb, s->quant[0][0]);\n        for (level = 0; level < s->wavelet_depth; level++) {\n            put_vc2_ue_uint(&s->pb, s->quant[level][1]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][2]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][3]);\n        }\n    } else {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            s->quant[level][0] = ff_dirac_default_qmat[s->wavelet_idx][level][0];\n            s->quant[level][1] = ff_dirac_default_qmat[s->wavelet_idx][level][1];\n            s->quant[level][2] = ff_dirac_default_qmat[s->wavelet_idx][level][2];\n            s->quant[level][3] = ff_dirac_default_qmat[s->wavelet_idx][level][3];\n        }\n    }\n}\n\n/* VC-2 12.3 - transform_parameters() */\nstatic void encode_transform_params(VC2EncContext *s)\n{\n    put_vc2_ue_uint(&s->pb, s->wavelet_idx);\n    put_vc2_ue_uint(&s->pb, s->wavelet_depth);\n\n    encode_slice_params(s);\n    encode_quant_matrix(s);\n}\n\n/* VC-2 12.2 - wavelet_transform() */\nstatic void encode_wavelet_transform(VC2EncContext *s)\n{\n    encode_transform_params(s);\n    avpriv_align_put_bits(&s->pb);\n    /* Continued after DWT in encode_transform_data() */\n}\n\n/* VC-2 12 - picture_parse() */\nstatic void encode_picture_start(VC2EncContext *s)\n{\n    avpriv_align_put_bits(&s->pb);\n    encode_picture_header(s);\n    avpriv_align_put_bits(&s->pb);\n    encode_wavelet_transform(s);\n}\n\n#define QUANT(c)  \\\n    c <<= 2;      \\\n    c /= qfactor; \\\n\nstatic av_always_inline void coeff_quantize_get(qcoef coeff, int qfactor,\n                                                uint8_t *len, uint32_t *eval)\n{\n    QUANT(coeff)\n    get_vc2_ue_uint(abs(coeff), len, eval);\n    if (coeff) {\n        *eval = (*eval << 1) | (coeff < 0);\n        *len += 1;\n    }\n}\n\nstatic av_always_inline void coeff_quantize_encode(PutBitContext *pb, qcoef coeff,\n                                                   int qfactor)\n{\n    QUANT(coeff)\n    put_vc2_ue_uint(pb, abs(coeff));\n    if (coeff)\n        put_bits(pb, 1, coeff < 0);\n}\n\n/* VC-2 13.5.5.2 - slice_band() */\nstatic void encode_subband(VC2EncContext *s, PutBitContext *pb, int sx, int sy,\n                           SubBand *b, int quant)\n{\n    int x, y;\n\n    int left   = b->width  * (sx+0) / s->num_x;\n    int right  = b->width  * (sx+1) / s->num_x;\n    int top    = b->height * (sy+0) / s->num_y;\n    int bottom = b->height * (sy+1) / s->num_y;\n\n    int qfactor = ff_dirac_qscale_tab[quant];\n    uint8_t  *len_lut = &s->coef_lut_len[2*quant*COEF_LUT_TAB + COEF_LUT_TAB];\n    uint32_t *val_lut = &s->coef_lut_val[2*quant*COEF_LUT_TAB + COEF_LUT_TAB];\n\n    dwtcoef *coeff = b->buf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n        for (x = left; x < right; x++) {\n            if (coeff[x] >= -COEF_LUT_TAB && coeff[x] < COEF_LUT_TAB)\n                put_bits(pb, len_lut[coeff[x]], val_lut[coeff[x]]);\n            else\n                coeff_quantize_encode(pb, coeff[x], qfactor);\n        }\n        coeff += b->stride;\n    }\n}\n\nstatic int count_hq_slice(VC2EncContext *s, int slice_x,\n                          int slice_y, int quant_idx)\n{\n    int x, y, left, right, top, bottom, qfactor;\n    uint8_t quants[MAX_DWT_LEVELS][4];\n    int bits = 0, p, level, orientation;\n\n    bits += 8*s->prefix_bytes;\n    bits += 8; /* quant_idx */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n        for (orientation = !!level; orientation < 4; orientation++)\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n    for (p = 0; p < 3; p++) {\n        int bytes_start, bytes_len, pad_s, pad_c;\n        bytes_start = bits >> 3;\n        bits += 8;\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = !!level; orientation < 4; orientation++) {\n                dwtcoef *buf;\n                SubBand *b = &s->plane[p].band[level][orientation];\n\n                quant_idx = quants[level][orientation];\n                qfactor = ff_dirac_qscale_tab[quant_idx];\n\n                left   = b->width  * slice_x    / s->num_x;\n                right  = b->width  *(slice_x+1) / s->num_x;\n                top    = b->height * slice_y    / s->num_y;\n                bottom = b->height *(slice_y+1) / s->num_y;\n\n                buf = b->buf + top * b->stride;\n\n                for (y = top; y < bottom; y++) {\n                    for (x = left; x < right; x++) {\n                        qcoef coeff = (qcoef)buf[x];\n                        if (coeff >= -COEF_LUT_TAB && coeff < COEF_LUT_TAB) {\n                            bits += s->coef_lut_len[2*quant_idx*COEF_LUT_TAB + coeff + COEF_LUT_TAB];\n                        } else {\n                            QUANT(coeff)\n                            bits += count_vc2_ue_uint(abs(coeff));\n                            bits += !!coeff;\n                        }\n                    }\n                    buf += b->stride;\n                }\n            }\n        }\n        bits += FFALIGN(bits, 8) - bits;\n        bytes_len = (bits >> 3) - bytes_start - 1;\n        pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n        pad_c = (pad_s*s->size_scaler) - bytes_len;\n        bits += pad_c*8;\n    }\n\n    return bits;\n}\n\n/* Approaches the best possible quantizer asymptotically, its kinda exaustive\n * but we have a LUT to get the coefficient size in bits. Guaranteed to never\n * overshoot, which is apparently very important when streaming */\nstatic int rate_control(AVCodecContext *avctx, void *arg)\n{\n    SliceArgs *slice_dat = arg;\n    VC2EncContext *s = slice_dat->ctx;\n    const int sx = slice_dat->x;\n    const int sy = slice_dat->y;\n    int bits_last = INT_MAX, quant_buf[2] = {-1, -1};\n    int quant = s->q_start, range = s->q_start/3;\n    const int64_t top = slice_dat->bits_ceil;\n    const double percent = s->tolerance;\n    const double bottom = top - top*(percent/100.0f);\n    int bits = count_hq_slice(s, sx, sy, quant);\n    range -= range & 1; /* Make it an even number */\n    while ((bits > top) || (bits < bottom)) {\n        range *= bits > top ? +1 : -1;\n        quant = av_clip(quant + range, 0, s->q_ceil);\n        bits = count_hq_slice(s, sx, sy, quant);\n        range = av_clip(range/2, 1, s->q_ceil);\n        if (quant_buf[1] == quant) {\n            quant = bits_last < bits ? quant_buf[0] : quant;\n            bits  = bits_last < bits ? bits_last : bits;\n            break;\n        }\n        quant_buf[1] = quant_buf[0];\n        quant_buf[0] = quant;\n        bits_last = bits;\n    }\n    slice_dat->quant_idx = av_clip(quant, 0, s->q_ceil);\n    slice_dat->bytes = FFALIGN((bits >> 3), s->size_scaler) + 4 + s->prefix_bytes;\n\n    return 0;\n}\n\nstatic void calc_slice_sizes(VC2EncContext *s)\n{\n    int slice_x, slice_y;\n    SliceArgs *enc_args = s->slice_args;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n            SliceArgs *args = &enc_args[s->num_x*slice_y + slice_x];\n            args->ctx = s;\n            args->x = slice_x;\n            args->y = slice_y;\n            args->bits_ceil = s->slice_max_bytes << 3;\n        }\n    }\n\n    /* Determine quantization indices and bytes per slice */\n    s->avctx->execute(s->avctx, rate_control, enc_args, NULL, s->num_x*s->num_y,\n                      sizeof(SliceArgs));\n}\n\n/* VC-2 13.5.3 - hq_slice */\nstatic int encode_hq_slice(AVCodecContext *avctx, void *arg)\n{\n    SliceArgs *slice_dat = arg;\n    VC2EncContext *s = slice_dat->ctx;\n    PutBitContext *pb = &slice_dat->pb;\n    const int slice_x = slice_dat->x;\n    const int slice_y = slice_dat->y;\n    const int quant_idx = slice_dat->quant_idx;\n    const int slice_bytes_max = slice_dat->bytes;\n    uint8_t quants[MAX_DWT_LEVELS][4];\n    int p, level, orientation;\n\n    avpriv_align_put_bits(pb);\n    put_padding(pb, s->prefix_bytes);\n    put_bits(pb, 8, quant_idx);\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n    for (level = 0; level < s->wavelet_depth; level++)\n        for (orientation = !!level; orientation < 4; orientation++)\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n    /* Luma + 2 Chroma planes */\n    for (p = 0; p < 3; p++) {\n        int bytes_start, bytes_len, pad_s, pad_c;\n        bytes_start = put_bits_count(pb) >> 3;\n        put_bits(pb, 8, 0);\n        for (level = 0; level < s->wavelet_depth; level++) {\n            for (orientation = !!level; orientation < 4; orientation++) {\n                encode_subband(s, pb, slice_x, slice_y,\n                               &s->plane[p].band[level][orientation],\n                               quants[level][orientation]);\n            }\n        }\n        avpriv_align_put_bits(pb);\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n        if (p == 2) {\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n        } else {\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n        }\n        pb->buf[bytes_start] = pad_s;\n        put_padding(pb, pad_c);\n    }\n\n    return 0;\n}\n\n/* VC-2 13.5.1 - low_delay_transform_data() */\nstatic int encode_slices(VC2EncContext *s)\n{\n    uint8_t *buf;\n    int slice_x, slice_y, skip = 0;\n    SliceArgs *enc_args = s->slice_args;\n\n    avpriv_align_put_bits(&s->pb);\n    flush_put_bits(&s->pb);\n    buf = put_bits_ptr(&s->pb);\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n            SliceArgs *args = &enc_args[s->num_x*slice_y + slice_x];\n            init_put_bits(&args->pb, buf + skip, args->bytes);\n            s->q_start = (s->q_start + args->quant_idx)/2;\n            skip += args->bytes;\n        }\n    }\n\n    s->avctx->execute(s->avctx, encode_hq_slice, enc_args, NULL, s->num_x*s->num_y,\n                      sizeof(SliceArgs));\n\n    skip_put_bytes(&s->pb, skip);\n\n    return 0;\n}\n\n/*\n * Transform basics for a 3 level transform\n * |---------------------------------------------------------------------|\n * |  LL-0  | HL-0  |                 |                                  |\n * |--------|-------|      HL-1       |                                  |\n * |  LH-0  | HH-0  |                 |                                  |\n * |----------------|-----------------|              HL-2                |\n * |                |                 |                                  |\n * |     LH-1       |      HH-1       |                                  |\n * |                |                 |                                  |\n * |----------------------------------|----------------------------------|\n * |                                  |                                  |\n * |                                  |                                  |\n * |                                  |                                  |\n * |              LH-2                |              HH-2                |\n * |                                  |                                  |\n * |                                  |                                  |\n * |                                  |                                  |\n * |---------------------------------------------------------------------|\n *\n * DWT transforms are generally applied by splitting the image in two vertically\n * and applying a low pass transform on the left part and a corresponding high\n * pass transform on the right hand side. This is known as the horizontal filter\n * stage.\n * After that, the same operation is performed except the image is divided\n * horizontally, with the high pass on the lower and the low pass on the higher\n * side.\n * Therefore, you're left with 4 subdivisions - known as  low-low, low-high,\n * high-low and high-high. They're referred to as orientations in the decoder\n * and encoder.\n *\n * The LL (low-low) area contains the original image downsampled by the amount\n * of levels. The rest of the areas can be thought as the details needed\n * to restore the image perfectly to its original size.\n */\n\n\nstatic int dwt_plane(AVCodecContext *avctx, void *arg)\n{\n    TransformArgs *transform_dat = arg;\n    VC2EncContext *s = transform_dat->ctx;\n    const void *frame_data = transform_dat->idata;\n    const ptrdiff_t linesize = transform_dat->istride;\n    const int field = transform_dat->field;\n    const Plane *p = transform_dat->plane;\n    VC2TransformContext *t = &transform_dat->t;\n    dwtcoef *buf = p->coef_buf;\n    const int idx = s->wavelet_idx;\n    const int skip = 1 + s->interlaced;\n\n    int x, y, level, offset;\n    ptrdiff_t pix_stride = linesize >> (s->bpp - 1);\n\n    if (field == 1) {\n        offset = 0;\n        pix_stride <<= 1;\n    } else if (field == 2) {\n        offset = pix_stride;\n        pix_stride <<= 1;\n    } else {\n        offset = 0;\n    }\n\n    if (s->bpp == 1) {\n        const uint8_t *pix = (const uint8_t *)frame_data + offset;\n        for (y = 0; y < p->height*skip; y+=skip) {\n            for (x = 0; x < p->width; x++) {\n                buf[x] = pix[x] - s->diff_offset;\n            }\n            buf += p->coef_stride;\n            pix += pix_stride;\n        }\n    } else {\n        const uint16_t *pix = (const uint16_t *)frame_data + offset;\n        for (y = 0; y < p->height*skip; y+=skip) {\n            for (x = 0; x < p->width; x++) {\n                buf[x] = pix[x] - s->diff_offset;\n            }\n            buf += p->coef_stride;\n            pix += pix_stride;\n        }\n    }\n\n    memset(buf, 0, p->coef_stride * (p->dwt_height - p->height) * sizeof(dwtcoef));\n\n    for (level = s->wavelet_depth-1; level >= 0; level--) {\n        const SubBand *b = &p->band[level][0];\n        t->vc2_subband_dwt[idx](t, p->coef_buf, p->coef_stride,\n                                b->width, b->height);\n    }\n\n    return 0;\n}\n\nstatic void encode_frame(VC2EncContext *s, const AVFrame *frame,\n                         const char *aux_data, int field)\n{\n    int i;\n\n    /* Sequence header */\n    encode_parse_info(s, DIRAC_PCODE_SEQ_HEADER);\n    encode_seq_header(s);\n\n    /* Encoder version */\n    if (aux_data) {\n        encode_parse_info(s, DIRAC_PCODE_AUX);\n        avpriv_put_string(&s->pb, aux_data, 1);\n    }\n\n    /* Picture header */\n    encode_parse_info(s, DIRAC_PCODE_PICTURE_HQ);\n    encode_picture_start(s);\n\n    for (i = 0; i < 3; i++) {\n        s->transform_args[i].ctx   = s;\n        s->transform_args[i].field = field;\n        s->transform_args[i].plane = &s->plane[i];\n        s->transform_args[i].idata = frame->data[i];\n        s->transform_args[i].istride = frame->linesize[i];\n    }\n\n    /* Do a DWT transform */\n    s->avctx->execute(s->avctx, dwt_plane, s->transform_args, NULL, 3,\n                      sizeof(TransformArgs));\n\n    /* Calculate per-slice quantizers and sizes */\n    calc_slice_sizes(s);\n\n    /* Init planes and encode slices */\n    encode_slices(s);\n\n    /* End sequence */\n    encode_parse_info(s, DIRAC_PCODE_END_SEQ);\n}\n\nstatic av_cold int vc2_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n                                      const AVFrame *frame, int *got_packet_ptr)\n{\n    int ret;\n    int max_frame_bytes, sig_size = 256;\n    VC2EncContext *s = avctx->priv_data;\n    const char aux_data[] = \"FFmpeg version \"FFMPEG_VERSION;\n    const int aux_data_size = sizeof(aux_data);\n    const int header_size = 100 + aux_data_size;\n    int64_t r_bitrate = avctx->bit_rate >> (s->interlaced);\n\n    s->avctx = avctx;\n    s->size_scaler = 1;\n    s->prefix_bytes = 0;\n    s->last_parse_code = 0;\n    s->next_parse_offset = 0;\n\n    /* Rate control */\n    max_frame_bytes = (av_rescale(r_bitrate, s->avctx->time_base.num,\n                                  s->avctx->time_base.den) >> 3) - header_size;\n\n    /* Find an appropriate size scaler */\n    while (sig_size > 255) {\n        s->slice_max_bytes = FFALIGN(av_rescale(max_frame_bytes, 1,\n                                     s->num_x*s->num_y), s->size_scaler);\n        s->slice_max_bytes += 4 + s->prefix_bytes;\n        sig_size = s->slice_max_bytes/s->size_scaler; /* Signalled slize size */\n        s->size_scaler <<= 1;\n    }\n\n    ret = ff_alloc_packet2(avctx, avpkt, max_frame_bytes*2, 0);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n        return ret;\n    } else {\n        init_put_bits(&s->pb, avpkt->data, avpkt->size);\n    }\n\n    encode_frame(s, frame, aux_data, s->interlaced);\n    if (s->interlaced)\n        encode_frame(s, frame, NULL, 2);\n\n    flush_put_bits(&s->pb);\n    avpkt->size = put_bits_count(&s->pb) >> 3;\n\n    *got_packet_ptr = 1;\n\n    return 0;\n}\n\nstatic av_cold int vc2_encode_end(AVCodecContext *avctx)\n{\n    int i;\n    VC2EncContext *s = avctx->priv_data;\n\n    for (i = 0; i < 3; i++) {\n        ff_vc2enc_free_transforms(&s->transform_args[i].t);\n        av_freep(&s->plane[i].coef_buf);\n    }\n\n    av_freep(&s->slice_args);\n    av_freep(&s->coef_lut_len);\n    av_freep(&s->coef_lut_val);\n\n    return 0;\n}\n\n\nstatic av_cold int vc2_encode_init(AVCodecContext *avctx)\n{\n    Plane *p;\n    SubBand *b;\n    int i, j, level, o, shift;\n    VC2EncContext *s = avctx->priv_data;\n\n    s->picture_number = 0;\n\n    /* Total allowed quantization range */\n    s->q_ceil    = MAX_QUANT_INDEX;\n\n    s->ver.major = 2;\n    s->ver.minor = 0;\n    s->profile   = 3;\n    s->level     = 3;\n\n    s->base_vf   = -1;\n    s->strict_compliance = 1;\n\n    /* Mark unknown as progressive */\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n    if (avctx->pix_fmt == AV_PIX_FMT_YUV422P10) {\n        if (avctx->width == 1280 && avctx->height == 720) {\n            s->level = 3;\n            if (avctx->time_base.num == 1001 && avctx->time_base.den == 60000)\n                s->base_vf = 9;\n            if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                s->base_vf = 10;\n        } else if (avctx->width == 1920 && avctx->height == 1080) {\n            s->level = 3;\n            if (s->interlaced) {\n                if (avctx->time_base.num == 1001 && avctx->time_base.den == 30000)\n                    s->base_vf = 11;\n                if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                    s->base_vf = 12;\n            } else {\n                if (avctx->time_base.num == 1001 && avctx->time_base.den == 60000)\n                    s->base_vf = 13;\n                if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                    s->base_vf = 14;\n                if (avctx->time_base.num == 1001 && avctx->time_base.den == 24000)\n                    s->base_vf = 21;\n            }\n        } else if (avctx->width == 3840 && avctx->height == 2160) {\n            s->level = 6;\n            if (avctx->time_base.num == 1001 && avctx->time_base.den == 60000)\n                s->base_vf = 17;\n            if (avctx->time_base.num == 1 && avctx->time_base.den == 50)\n                s->base_vf = 18;\n        }\n    }\n\n    if (s->interlaced && s->base_vf <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Interlacing not supported with non standard formats!\\n\");\n        return AVERROR_UNKNOWN;\n    }\n\n    if (s->interlaced)\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n        (s->slice_height & (s->slice_height - 1))) {\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n        return AVERROR_UNKNOWN;\n    }\n\n    if ((s->slice_width > avctx->width) ||\n        (s->slice_height > avctx->height)) {\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n        return AVERROR_UNKNOWN;\n    }\n\n    if (s->base_vf <= 0) {\n        if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n            s->strict_compliance = s->base_vf = 0;\n            av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\");\n        } else {\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n                   \"the specifications, please add a -strict -1 flag to use it\\n\");\n            return AVERROR_UNKNOWN;\n        }\n    } else {\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i\\n\", s->base_vf);\n    }\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n    /* Planes initialization */\n    for (i = 0; i < 3; i++) {\n        int w, h;\n        p = &s->plane[i];\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n        if (s->interlaced)\n            p->height >>= 1;\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n        if (!p->coef_buf)\n            goto alloc_fail;\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n            w = w >> 1;\n            h = h >> 1;\n            for (o = 0; o < 4; o++) {\n                b = &p->band[level][o];\n                b->width  = w;\n                b->height = h;\n                b->stride = p->coef_stride;\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n                b->buf = p->coef_buf + shift;\n            }\n        }\n\n        /* DWT init */\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n                                      s->plane[i].coef_stride,\n                                      s->plane[i].dwt_height,\n                                      s->slice_width, s->slice_height))\n            goto alloc_fail;\n    }\n\n    /* Slices */\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n    s->slice_args = av_malloc(s->num_x*s->num_y*sizeof(SliceArgs));\n    if (!s->slice_args)\n        goto alloc_fail;\n\n    /* Lookup tables */\n    s->coef_lut_len = av_malloc(2*COEF_LUT_TAB*s->q_ceil*sizeof(*s->coef_lut_len));\n    if (!s->coef_lut_len)\n        goto alloc_fail;\n\n    s->coef_lut_val = av_malloc(2*COEF_LUT_TAB*s->q_ceil*sizeof(*s->coef_lut_val));\n    if (!s->coef_lut_val)\n        goto alloc_fail;\n\n    for (i = 0; i < s->q_ceil; i++) {\n        for (j = -COEF_LUT_TAB; j < COEF_LUT_TAB; j++) {\n            uint8_t  *len_lut = &s->coef_lut_len[2*i*COEF_LUT_TAB + COEF_LUT_TAB];\n            uint32_t *val_lut = &s->coef_lut_val[2*i*COEF_LUT_TAB + COEF_LUT_TAB];\n            coeff_quantize_get(j, ff_dirac_qscale_tab[i], &len_lut[j], &val_lut[j]);\n        }\n    }\n\n    return 0;\n\nalloc_fail:\n    vc2_encode_end(avctx);\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n    return AVERROR(ENOMEM);\n}\n\n#define VC2ENC_FLAGS (AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)\nstatic const AVOption vc2enc_options[] = {\n    {\"tolerance\",     \"Max undershoot in percent\", offsetof(VC2EncContext, tolerance), AV_OPT_TYPE_DOUBLE, {.dbl = 10.0f}, 0.0f, 45.0f, VC2ENC_FLAGS, \"tolerance\"},\n    {\"slice_width\",   \"Slice width\",  offsetof(VC2EncContext, slice_width), AV_OPT_TYPE_INT, {.i64 = 128}, 32, 1024, VC2ENC_FLAGS, \"slice_width\"},\n    {\"slice_height\",  \"Slice height\", offsetof(VC2EncContext, slice_height), AV_OPT_TYPE_INT, {.i64 = 64}, 8, 1024, VC2ENC_FLAGS, \"slice_height\"},\n    {\"wavelet_depth\", \"Transform depth\", offsetof(VC2EncContext, wavelet_depth), AV_OPT_TYPE_INT, {.i64 = 5}, 1, 5, VC2ENC_FLAGS, \"wavelet_depth\"},\n    {\"wavelet_type\",  \"Transform type\",  offsetof(VC2EncContext, wavelet_idx), AV_OPT_TYPE_INT, {.i64 = VC2_TRANSFORM_9_7}, 0, VC2_TRANSFORMS_NB, VC2ENC_FLAGS, \"wavelet_idx\"},\n        {\"9_7\",       \"Deslauriers-Dubuc (9,7)\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_TRANSFORM_9_7}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"wavelet_idx\"},\n        {\"5_3\",       \"LeGall (5,3)\",            0, AV_OPT_TYPE_CONST, {.i64 = VC2_TRANSFORM_5_3}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"wavelet_idx\"},\n    {\"qm\", \"Custom quantization matrix\", offsetof(VC2EncContext, quant_matrix), AV_OPT_TYPE_INT, {.i64 = VC2_QM_DEF}, 0, VC2_QM_NB, VC2ENC_FLAGS, \"quant_matrix\"},\n        {\"default\",   \"Default from the specifications\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_QM_DEF}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"quant_matrix\"},\n        {\"color\",     \"Prevents low bitrate discoloration\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_QM_COL}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"quant_matrix\"},\n        {\"flat\",      \"Optimize for PSNR\", 0, AV_OPT_TYPE_CONST, {.i64 = VC2_QM_FLAT}, INT_MIN, INT_MAX, VC2ENC_FLAGS, \"quant_matrix\"},\n    {NULL}\n};\n\nstatic const AVClass vc2enc_class = {\n    .class_name = \"SMPTE VC-2 encoder\",\n    .category = AV_CLASS_CATEGORY_ENCODER,\n    .option = vc2enc_options,\n    .item_name = av_default_item_name,\n    .version = LIBAVUTIL_VERSION_INT\n};\n\nstatic const AVCodecDefault vc2enc_defaults[] = {\n    { \"b\",              \"600000000\"   },\n    { NULL },\n};\n\nstatic const enum AVPixelFormat allowed_pix_fmts[] = {\n    AV_PIX_FMT_YUV420P,   AV_PIX_FMT_YUV422P,   AV_PIX_FMT_YUV444P,\n    AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10,\n    AV_PIX_FMT_YUV420P12, AV_PIX_FMT_YUV422P12, AV_PIX_FMT_YUV444P12,\n    AV_PIX_FMT_NONE\n};\n\nAVCodec ff_vc2_encoder = {\n    .name = \"vc2\",\n    .long_name = NULL_IF_CONFIG_SMALL(\"SMPTE VC-2\"),\n    .type = AVMEDIA_TYPE_VIDEO,\n    .id = AV_CODEC_ID_DIRAC,\n    .priv_data_size = sizeof(VC2EncContext),\n    .init = vc2_encode_init,\n    .close = vc2_encode_end,\n    .capabilities = AV_CODEC_CAP_SLICE_THREADS,\n    .encode2 = vc2_encode_frame,\n    .priv_class = &vc2enc_class,\n    .defaults = vc2enc_defaults,\n    .pix_fmts = allowed_pix_fmts\n};\n", "/*\n * Copyright (C) 2007 Marco Gerards <marco@gnu.org>\n * Copyright (C) 2016 Open Broadcast Systems Ltd.\n * Author        2016 Rostislav Pehlivanov <atomnuker@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/mem.h\"\n#include \"vc2enc_dwt.h\"\n\n/* Since the transforms spit out interleaved coefficients, this function\n * rearranges the coefficients into the more traditional subdivision,\n * making it easier to encode and perform another level. */\nstatic av_always_inline void deinterleave(dwtcoef *linell, ptrdiff_t stride,\n                                          int width, int height, dwtcoef *synthl)\n{\n    int x, y;\n    ptrdiff_t synthw = width << 1;\n    dwtcoef *linehl = linell + width;\n    dwtcoef *linelh = linell + height*stride;\n    dwtcoef *linehh = linelh + width;\n\n    /* Deinterleave the coefficients. */\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            linell[x] = synthl[(x << 1)];\n            linehl[x] = synthl[(x << 1) + 1];\n            linelh[x] = synthl[(x << 1) + synthw];\n            linehh[x] = synthl[(x << 1) + synthw + 1];\n        }\n        synthl += synthw << 1;\n        linell += stride;\n        linelh += stride;\n        linehl += stride;\n        linehh += stride;\n    }\n}\n\nstatic void vc2_subband_dwt_97(VC2TransformContext *t, dwtcoef *data,\n                               ptrdiff_t stride, int width, int height)\n{\n    int x, y;\n    dwtcoef *datal = data, *synth = t->buffer, *synthl = synth;\n    const ptrdiff_t synth_width  = width  << 1;\n    const ptrdiff_t synth_height = height << 1;\n\n    /*\n     * Shift in one bit that is used for additional precision and copy\n     * the data to the buffer.\n     */\n    for (y = 0; y < synth_height; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] = datal[x] << 1;\n        synthl += synth_width;\n        datal += stride;\n    }\n\n    /* Horizontal synthesis. */\n    synthl = synth;\n    for (y = 0; y < synth_height; y++) {\n        /* Lifting stage 2. */\n        synthl[1] -= (8*synthl[0] + 9*synthl[2] - synthl[4] + 8) >> 4;\n        for (x = 1; x < width - 2; x++)\n            synthl[2*x + 1] -= (9*synthl[2*x] + 9*synthl[2*x + 2] - synthl[2*x + 4] -\n                                synthl[2 * x - 2] + 8) >> 4;\n        synthl[synth_width - 1] -= (17*synthl[synth_width - 2] -\n                                    synthl[synth_width - 4] + 8) >> 4;\n        synthl[synth_width - 3] -= (8*synthl[synth_width - 2] +\n                                    9*synthl[synth_width - 4] -\n                                    synthl[synth_width - 6] + 8) >> 4;\n        /* Lifting stage 1. */\n        synthl[0] += (synthl[1] + synthl[1] + 2) >> 2;\n        for (x = 1; x < width - 1; x++)\n            synthl[2*x] += (synthl[2*x - 1] + synthl[2*x + 1] + 2) >> 2;\n\n        synthl[synth_width - 2] += (synthl[synth_width - 3] +\n                                    synthl[synth_width - 1] + 2) >> 2;\n        synthl += synth_width;\n    }\n\n    /* Vertical synthesis: Lifting stage 2. */\n    synthl = synth + synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] -= (8*synthl[x - synth_width] + 9*synthl[x + synth_width] -\n                      synthl[x + 3 * synth_width] + 8) >> 4;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 2; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x + synth_width] -= (9*synthl[x] +\n                                        9*synthl[x + 2 * synth_width] -\n                                        synthl[x - 2 * synth_width] -\n                                        synthl[x + 4 * synth_width] + 8) >> 4;\n        synthl += synth_width << 1;\n    }\n\n    synthl = synth + (synth_height - 1) * synth_width;\n    for (x = 0; x < synth_width; x++) {\n        synthl[x] -= (17*synthl[x - synth_width] -\n                      synthl[x - 3*synth_width] + 8) >> 4;\n                      synthl[x - 2*synth_width] -= (9*synthl[x - 3*synth_width] +\n                      8*synthl[x - 1*synth_width] - synthl[x - 5*synth_width] + 8) >> 4;\n    }\n\n    /* Vertical synthesis: Lifting stage 1. */\n    synthl = synth;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (synthl[x + synth_width] + synthl[x + synth_width] + 2) >> 2;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 1; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] += (synthl[x - synth_width] + synthl[x + synth_width] + 2) >> 2;\n        synthl += synth_width << 1;\n    }\n\n    synthl = synth + (synth_height - 2) * synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (synthl[x - synth_width] + synthl[x + synth_width] + 2) >> 2;\n\n    deinterleave(data, stride, width, height, synth);\n}\n\nstatic void vc2_subband_dwt_53(VC2TransformContext *t, dwtcoef *data,\n                               ptrdiff_t stride, int width, int height)\n{\n    int x, y;\n    dwtcoef *synth = t->buffer, *synthl = synth, *datal = data;\n    const ptrdiff_t synth_width  = width  << 1;\n    const ptrdiff_t synth_height = height << 1;\n\n    /*\n     * Shift in one bit that is used for additional precision and copy\n     * the data to the buffer.\n     */\n    for (y = 0; y < synth_height; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] = datal[x] << 1;\n        synthl += synth_width;\n        datal  += stride;\n    }\n\n    /* Horizontal synthesis. */\n    synthl = synth;\n    for (y = 0; y < synth_height; y++) {\n        /* Lifting stage 2. */\n        for (x = 0; x < width - 1; x++)\n            synthl[2 * x + 1] -= (synthl[2 * x] + synthl[2 * x + 2] + 1) >> 1;\n\n        synthl[synth_width - 1] -= (2*synthl[synth_width - 2] + 1) >> 1;\n\n        /* Lifting stage 1. */\n        synthl[0] += (2*synthl[1] + 2) >> 2;\n        for (x = 1; x < width - 1; x++)\n            synthl[2 * x] += (synthl[2 * x - 1] + synthl[2 * x + 1] + 2) >> 2;\n\n        synthl[synth_width - 2] += (synthl[synth_width - 3] + synthl[synth_width - 1] + 2) >> 2;\n\n        synthl += synth_width;\n    }\n\n    /* Vertical synthesis: Lifting stage 2. */\n    synthl = synth + synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] -= (synthl[x - synth_width] + synthl[x + synth_width] + 1) >> 1;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 1; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x + synth_width] -= (synthl[x] + synthl[x + synth_width * 2] + 1) >> 1;\n        synthl += (synth_width << 1);\n    }\n\n    synthl = synth + (synth_height - 1) * synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] -= (2*synthl[x - synth_width] + 1) >> 1;\n\n    /* Vertical synthesis: Lifting stage 1. */\n    synthl = synth;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (2*synthl[synth_width + x] + 2) >> 2;\n\n    synthl = synth + (synth_width << 1);\n    for (y = 1; y < height - 1; y++) {\n        for (x = 0; x < synth_width; x++)\n            synthl[x] += (synthl[x + synth_width] + synthl[x - synth_width] + 2) >> 2;\n        synthl += (synth_width << 1);\n    }\n\n    synthl = synth + (synth_height - 2)*synth_width;\n    for (x = 0; x < synth_width; x++)\n        synthl[x] += (synthl[x - synth_width] + synthl[x + synth_width] + 2) >> 2;\n\n\n    deinterleave(data, stride, width, height, synth);\n}\n\nav_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_stride,\n                                      int p_height, int slice_w, int slice_h)\n{\n    s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n    s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n\n    /* Pad by the slice size, only matters for non-Haar wavelets */\n    s->buffer = av_calloc((p_stride + slice_w)*(p_height + slice_h), sizeof(dwtcoef));\n    if (!s->buffer)\n        return 1;\n\n    s->padding = (slice_h >> 1)*p_stride + (slice_w >> 1);\n    s->buffer += s->padding;\n\n    return 0;\n}\n\nav_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_free(s->buffer - s->padding);\n    s->buffer = NULL;\n}\n", "/*\n * Copyright (C) 2016 Open Broadcast Systems Ltd.\n * Author        2016 Rostislav Pehlivanov <atomnuker@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef AVCODEC_VC2ENC_DWT_H\n#define AVCODEC_VC2ENC_DWT_H\n\n#include <stddef.h>\n#include <stdint.h>\n\ntypedef int16_t dwtcoef;\ntypedef int32_t qcoef;   /* Quantization needs more precision */\n\n/* Only Deslauriers-Dubuc (9,7) and LeGall (5,3) supported! */\n\nenum VC2TransformType {\n    VC2_TRANSFORM_9_7    = 0,   /* Deslauriers-Dubuc (9,7)  */\n    VC2_TRANSFORM_5_3    = 1,   /* LeGall (5,3)             */\n    VC2_TRANSFORM_13_7   = 2,   /* Deslauriers-Dubuc (13,7) */\n    VC2_TRANSFORM_HAAR   = 3,   /* Haar without shift       */\n    VC2_TRANSFORM_HAAR_S = 4,   /* Haar with 1 shift/lvl    */\n    VC2_TRANSFORM_FIDEL  = 5,   /* Fidelity filter          */\n    VC2_TRANSFORM_9_7_I  = 6,   /* Daubechies (9,7)         */\n\n    VC2_TRANSFORMS_NB\n};\n\ntypedef struct VC2TransformContext {\n    dwtcoef *buffer;\n    int padding;\n    void (*vc2_subband_dwt[VC2_TRANSFORMS_NB])(struct VC2TransformContext *t,\n                                               dwtcoef *data, ptrdiff_t stride,\n                                               int width, int height);\n} VC2TransformContext;\n\nint  ff_vc2enc_init_transforms(VC2TransformContext *t, int p_stride, int p_height,\n                               int slice_w, int slice_h);\nvoid ff_vc2enc_free_transforms(VC2TransformContext *t);\n\n#endif /* AVCODEC_VC2ENC_DWT_H */\n"], "filenames": ["libavcodec/vc2enc.c", "libavcodec/vc2enc_dwt.c", "libavcodec/vc2enc_dwt.h"], "buggy_code_start_loc": [1109, 214, 46], "buggy_code_end_loc": [1111, 230, 53], "fixing_code_start_loc": [1109, 214, 47], "fixing_code_end_loc": [1112, 236, 55], "type": "CWE-125", "message": "The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2enc_dwt.c.", "other": {"cve": {"id": "CVE-2017-16840", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-21T08:29:00.210", "lastModified": "2021-02-05T21:55:12.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2enc_dwt.c."}, {"lang": "es", "value": "El codificador VC-2 Video Compression en FFmpeg versi\u00f3n 3.0 y 3.4 permite que los atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) debido a un relleno incorrecto del b\u00fafer para wavelets que no son de Haar. Esto est\u00e1 relacionado con libavcodec/vc2enc.c y libavcodec/vc2enc_dwt.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C6E85AA0-559E-4EC5-AF61-100732EF0643"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "4BFDA7F5-FE3F-4D4A-AE46-43251194C127"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=a94cb36ab2ad99d3a1331c9f91831ef593d94f74", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/101924", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/94e538aebbc9f9c529e8b1f2eda860cfb8c473b1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4049", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/94e538aebbc9f9c529e8b1f2eda860cfb8c473b1"}}