{"buggy_code": ["// Copyright 2009 Indeed\npackage com.indeed.util.varexport;\n\n\nimport com.google.common.base.CharMatcher;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.escape.Escaper;\n\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * Variable exported by {@link com.indeed.util.varexport.VarExporter}.\n *\n * @see com.indeed.util.varexport.Export\n * @author jack@indeed.com (Jack Humphrey)\n */\npublic abstract class Variable<T> {\n\n    private static Set<Character> nameValueSpecialCharacters = ImmutableSet.of(':', '=');\n\n    private static Pattern INDEXABLE_SPLITTER = Pattern.compile(\"[^a-z0-9]+\");\n\n    private final String name;\n    private final String[] indexableNames;\n    private final String doc;\n    private final String namespace;\n    private final boolean expand;\n    private final Set<String> tags;\n\n    private static String[] buildIndexableName(final String name) {\n        if (name == null) {\n            return new String[0];\n        }\n        return INDEXABLE_SPLITTER.split(name.toLowerCase());\n    }\n\n    public Variable(String name, Set<String> tags, String doc, boolean expand, String namespace) {\n        this.name = name;\n        this.indexableNames = buildIndexableName(name);\n        this.tags = tags;\n        this.doc = doc;\n        this.expand = expand;\n        this.namespace = namespace;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String[] getIndexableNames() {\n        return indexableNames;\n    }\n\n    public String getDoc() {\n        return doc != null ? doc : \"\";\n    }\n\n    public Set<String> getTags() {\n        return tags;\n    }\n\n    public String getNamespace() { return namespace; }\n\n    /** @return epoch millis when value was last updated, null if value is current */\n    public Long getLastUpdated() {\n        return null;\n    }\n\n    public boolean isExpandable() {\n        return expand && canExpand();\n    }\n\n    public Map<?, ?> expand() {\n        if (!isExpandable()) {\n            throw new RuntimeException(name + \" is not expandable\");\n        }\n        return (Map<?, ?>) getValue();\n    }\n\n    public boolean hasDoc() {\n        return !Strings.isNullOrEmpty(getDoc());\n    }\n\n    /**\n     * @return True as long as the variable is \"live\" and should continue to be valid/usable\n     */\n    protected abstract boolean isLive();\n\n    protected abstract boolean canExpand();\n\n    public abstract T getValue();\n\n    public String getNamespaceAndName() {\n        if(Strings.isNullOrEmpty(namespace)) {\n            return name;\n        }\n\n        return namespace + \"-\" + name;\n    }\n\n    /**\n     * Write name and value (and optionally documentation) in {@link java.util.Properties} format.\n     * @param out writer\n     * @param includeDoc true if should be prefixed with documentation line\n     */\n    public void write(PrintWriter out, boolean includeDoc) {\n        // getValue() will update the timestamp (if relevant)\n        T localValue = getValue();\n        if (includeDoc) {\n            out.println();\n            Long lastUpdate = getLastUpdated();\n            if (hasDoc() || lastUpdate != null) {\n                out.print(\"# \");\n                if (hasDoc()) {\n                    out.print(makePropertiesSafe(getDoc(), null));\n                }\n                if (lastUpdate != null) {\n                    out.print(\" (last update: \" + lastUpdate + \")\");\n                }\n                out.println();\n            }\n        }\n        out.println(toString());\n    }\n\n    /**\n     * Write value (escaped for {@link java.util.Properties} format).\n     * @param out writer\n     */\n    public void writeValue(PrintWriter out) {\n        out.print(makePropertiesSafe(getValue(), nameValueSpecialCharacters));\n    }\n\n    public String getValueString() {\n        T value = getValue();\n        return \"\" + value;\n    }\n\n    public String getSafeValue() {\n        return makePropertiesSafe(getValue(), nameValueSpecialCharacters);\n    }\n\n    public String getSafeName() {\n        return makePropertiesSafe(name, nameValueSpecialCharacters);\n    }\n\n    public String toString() {\n        return getSafeName() + \"=\" + getSafeValue();\n    }\n\n    private static String makePropertiesSafe(Object in, Set<Character> toEscape) {\n        if (in == null) { return \"null\"; }\n        String str = in.toString();\n        StringBuilder result = null;\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            final boolean isAscii = CharMatcher.ascii().matches(c);\n            final boolean requiresEscape = !isAscii || (toEscape != null && toEscape.contains(c));\n            if (requiresEscape && result == null) {\n                result = new StringBuilder(str.length() * 2);\n                result.append(str, 0, i);\n            }\n            if (!isAscii) {\n                result.append(JavaSourceEscaper.escapeChar(c));\n            } else {\n                if (requiresEscape) {\n                    result.append('\\\\');\n                }\n                if (result != null) {\n                    result.append(c);\n                }\n            }\n        }\n        return result == null ? str : result.toString();\n    }\n\n    /** Escapes non-ASCII using \\\\unnnn format */\n    private static class JavaSourceEscaper extends Escaper {\n        // TODO: remove if guava ever adds SourceCodeEscapers\n        public String escape(String input) {\n            StringBuilder b = new StringBuilder();\n            for (int i = 0; i < input.length(); i++) {\n                char c = input.charAt(i);\n                if (!CharMatcher.ascii().matches(c)) {\n                    b.append(escapeChar(c));\n                } else {\n                    b.append(c);\n                }\n            }\n            return b.toString();\n        }\n\n        public static String escapeChar(char c) {\n            if (c < 0x10) {\n                return \"\\\\u000\" + Integer.toHexString(c);\n            } else if (c < 0x100) {\n                return \"\\\\u00\" + Integer.toHexString(c);\n            } else if (c < 0x1000) {\n                return \"\\\\u0\" + Integer.toHexString(c);\n            }\n            return \"\\\\u\" + Integer.toHexString(c);\n        }\n    }\n}\n", "// Copyright 2009 Indeed\npackage com.indeed.util.varexport.servlet;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.*;\nimport com.indeed.util.varexport.VarExporter;\nimport com.indeed.util.varexport.Variable;\nimport com.indeed.util.varexport.VariableHost;\nimport com.indeed.util.varexport.VariableVisitor;\nimport freemarker.template.Configuration;\nimport freemarker.template.DefaultObjectWrapper;\nimport freemarker.template.Template;\nimport org.apache.log4j.Logger;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\n/**\n * Servlet for displaying variables exported by {@link VarExporter}.\n * Will escape values for compatibility with loading into {@link Properties}.\n *\n * @author jack@indeed.com (Jack Humphrey)\n */\npublic class ViewExportedVariablesServlet extends HttpServlet {\n\n    private static final Logger log = Logger.getLogger(ViewExportedVariablesServlet.class);\n\n    private static final Joiner COMMA_JOINER = Joiner.on(',');\n\n    private Template varTextTemplate;\n    private Template varHtmlTemplate;\n    private Template browseNamespaceTemplate;\n\n    public enum DisplayType {\n        PLAINTEXT(\"text\", \"text/plain\"),\n        JSON(\"json\", \"application/json\"),\n        HTML(\"html\", \"text/html\");\n\n        private final String paramValue;\n        private final String mimeType;\n\n        DisplayType(final String paramValue, final String mimeType) {\n            this.paramValue = paramValue;\n            this.mimeType = mimeType;\n        }\n\n    }\n\n    @VisibleForTesting\n    protected void setVarTextTemplate(final Template varTextTemplate) {\n        this.varTextTemplate = varTextTemplate;\n    }\n\n    @VisibleForTesting\n    protected void setVarHtmlTemplate(final Template varHtmlTemplate) {\n        this.varHtmlTemplate = varHtmlTemplate;\n    }\n\n    @VisibleForTesting\n    protected void setBrowseNamespaceTemplate(final Template browseNamespaceTemplate) {\n        this.browseNamespaceTemplate = browseNamespaceTemplate;\n    }\n\n    @Override\n    public void init(final ServletConfig servletConfig) throws ServletException {\n        super.init(servletConfig);\n\n        final Configuration config = new Configuration();\n        config.setObjectWrapper(new DefaultObjectWrapper());\n        final String templateLoadPath = servletConfig.getInitParameter(\"templateLoadPath\");\n        if (templateLoadPath != null && new File(templateLoadPath).isDirectory()) {\n            try {\n                config.setDirectoryForTemplateLoading(new File(templateLoadPath));\n            } catch (IOException e) {\n                throw new ServletException(e);\n            }\n        } else {\n            final String contextLoadPath = servletConfig.getInitParameter(\"contextLoadPath\");\n            if (contextLoadPath != null) {\n                final ServletContext ctx = servletConfig.getServletContext();\n                config.setServletContextForTemplateLoading(ctx, contextLoadPath);\n            } else {\n                config.setClassForTemplateLoading(getClass(), \"/\");\n            }\n        }\n        try {\n            varTextTemplate = config.getTemplate(\"vars-text.ftl\");\n            varHtmlTemplate = config.getTemplate(\"vars-html.ftl\");\n            browseNamespaceTemplate = config.getTemplate(\"browsens.ftl\");\n        } catch (IOException e) {\n            throw new ServletException(\"Failed to load template\", e);\n        }\n    }\n\n    @Override\n    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        response.setCharacterEncoding(\"UTF-8\");\n\n        if (\"1\".equals(request.getParameter(\"browse\"))) {\n            showNamespaces(request.getRequestURI(), response);\n        } else {\n            final String[] vars = request.getParameterValues(\"v\");\n            final boolean doc = \"1\".equals(request.getParameter(\"doc\"));\n            final String fmtParam = request.getParameter(\"fmt\");\n            final DisplayType displayType;\n            if (\"html\".equals(fmtParam)) {\n                displayType = DisplayType.HTML;\n            } else if (\"json\".equals(fmtParam)) {\n                displayType = DisplayType.JSON;\n            } else {\n                displayType = DisplayType.PLAINTEXT;\n            }\n            showVariables(request.getRequestURI(), response, request.getParameter(\"ns\"), request.getParameter(\"tag\"), doc, displayType, vars);\n        }\n    }\n\n    private void showNamespaces(final String uri, final HttpServletResponse response) throws IOException {\n        final List<String> namespaces = VarExporter.getNamespaces();\n        namespaces.remove(null);\n        Collections.sort(namespaces);\n\n        final Map<String, String> parents = Maps.newHashMapWithExpectedSize(namespaces.size());\n        for (String namespace : namespaces) {\n            VarExporter parent = VarExporter.forNamespace(namespace).getParentNamespace();\n            if (parent == null) {\n                parents.put(namespace, \"none\");\n            } else {\n                parents.put(namespace, parent.getNamespace());\n            }\n        }\n\n        response.setContentType(\"text/html\");\n        final PrintWriter out = response.getWriter();\n        final Map<String, Object> root = new HashMap<String, Object>();\n        root.put(\"urlPath\", uri);\n        root.put(\"namespaces\", namespaces);\n        root.put(\"parents\", parents);\n        try {\n            browseNamespaceTemplate.process(root, out);\n        } catch (Exception e) {\n            throw new IOException(\"template failure\", e);\n        }\n        out.flush();\n        out.close();\n    }\n\n    /**\n     * @param uri The request URI.\n     * @param response The response we will stream the report to.\n     * @param namespace The namespace which we should be inspecting\n     * @param includeDoc True if we should include docs. False, otherwise.\n     * @param html True to display the report in HTML. False for PLAINTEXT.\n     * @param vars The variables that we want to view.\n     * @throws IOException If we cannot write to the response stream.\n     * @deprecated use version that takes DisplayType enum\n     */\n    @Deprecated\n    protected void showVariables(\n            final String uri,\n            final HttpServletResponse response,\n            final String namespace,\n            final boolean includeDoc,\n            final boolean html,\n            final String... vars\n    ) throws IOException {\n        final DisplayType displayType = html ? DisplayType.HTML : DisplayType.PLAINTEXT;\n        showVariables(uri, response, namespace, includeDoc, displayType, vars);\n    }\n\n    /**\n     * @param uri The request URI.\n     * @param response The response we will stream the report to.\n     * @param namespace The namespace which we should be inspecting\n     * @param includeDoc True if we should include docs. False, otherwise.\n     * @param displayType The type of display to produce.\n     * @param vars The variables that we want to view.\n     * @throws IOException If we cannot write to the response stream.\n     * @deprecated use version that takes tag\n     */\n    @Deprecated\n    protected void showVariables(\n            final String uri,\n            final HttpServletResponse response,\n            final String namespace,\n            final boolean includeDoc,\n            final DisplayType displayType,\n            final String... vars\n    ) throws IOException {\n        showVariables(uri, response, namespace, null, includeDoc, displayType, vars);\n    }\n\n    protected void showVariables(\n            final String uri,\n            final HttpServletResponse response,\n            final String namespace,\n            final String tag,\n            final boolean includeDoc,\n            final DisplayType displayType,\n            final String... vars\n    ) throws IOException {\n        final VariableHost exporter;\n        if (!Strings.isNullOrEmpty(tag)) {\n            exporter = VarExporter.withTag(tag);\n        } else if (!Strings.isNullOrEmpty(namespace)) {\n            final Optional<VarExporter> maybeExporter = VarExporter.forNamespaceIfExists(namespace);\n            if (!maybeExporter.isPresent()) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"The specified namespace not found\");\n                return;\n            }\n            exporter = maybeExporter.get();\n        } else {\n            exporter = VarExporter.global();\n        }\n\n        final PrintWriter out = response.getWriter();\n        response.setContentType(displayType.mimeType);\n        switch(displayType) {\n            case HTML:\n                showUsingTemplate(exporter, uri, namespace, includeDoc, varHtmlTemplate, true, out, vars);\n                break;\n            case PLAINTEXT:\n                showUsingTemplate(exporter, uri, namespace, includeDoc, varTextTemplate, false, out, vars);\n                break;\n            // TODO: support json -- exporter JSON is currently broken\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    private void showUsingTemplate(\n            final VariableHost exporter,\n            final String uri,\n            final String namespace,\n            final boolean includeDoc,\n            final Template template,\n            final boolean withIndex,\n            final PrintWriter out,\n            final String... vars\n    ) throws IOException {\n        final String name = (namespace == null ? \"Global\" : namespace);\n\n        final Map<String, Object> root = new HashMap<String, Object>();\n        final DateFormat df = SimpleDateFormat.getDateTimeInstance();\n        root.put(\"urlPath\", uri);\n        root.put(\"name\", name);\n        root.put(\"date\", df.format(new Date()));\n        root.put(\"includeDoc\", includeDoc);\n\n        final List<Variable> varList;\n        if (vars != null && vars.length == 1) {\n            final Variable v = exporter.getVariable(vars[0]);\n            if (v != null) {\n                varList = Lists.newArrayListWithExpectedSize(1);\n                addVariable(v, varList);\n            } else {\n                varList = ImmutableList.of();\n            }\n        } else {\n            varList = Lists.newArrayListWithExpectedSize(vars != null ? vars.length : 256);\n            if (vars == null || vars.length == 0) {\n                exporter.visitVariables(new VariableVisitor() {\n                    public void visit(Variable var) {\n                        addVariable(var, varList);\n                    }\n                });\n            } else {\n                for (String var : vars) {\n                    Variable v = exporter.getVariable(var);\n                    if (v != null) {\n                        addVariable(v, varList);\n                    }\n                }\n            }\n        }\n        root.put(\"vars\", varList);\n        if (withIndex) {\n            final String varsIndex = buildIndex(varList);\n            root.put(\"varsIndex\", varsIndex);\n        }\n\n        try {\n            template.process(root, out);\n        } catch (Exception e) {\n            throw new IOException(\"template failure\", e);\n        }\n    }\n\n    private String buildIndex(final List<Variable> varList) {\n        final SetMultimap<String, Integer> uniGram = buildNGramIndex(varList, 1);\n        final SetMultimap<String, Integer> biGram = buildNGramIndex(varList, 2);\n        final SetMultimap<String, Integer> triGram = buildNGramIndex(varList, 3);\n        final StringBuilder json = new StringBuilder();\n        json.append('{').append('\\n');\n        json.append(\"\\\"uniGram\\\":\").append('\\n');\n        appendTo(json, uniGram).append(',').append('\\n');\n        json.append(\"\\\"biGram\\\":\").append('\\n');\n        appendTo(json, biGram).append(',').append('\\n');;\n        json.append(\"\\\"triGram\\\":\").append('\\n');\n        appendTo(json, triGram);\n        json.append('}');\n        return json.toString();\n    }\n\n    private <K> StringBuilder appendTo(final StringBuilder json, final SetMultimap<K, Integer> map) {\n        json.append('{').append('\\n');\n        boolean isFirst = true;\n        for (final K key : map.keySet()) {\n            final Set<Integer> values = map.get(key);\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                json.append(',').append('\\n');\n            }\n            json.append('\"').append(key.toString()).append('\"').append(':');\n            json.append('[');\n            COMMA_JOINER.appendTo(json, values);\n            json.append(']');\n        }\n        json.append('\\n').append('}');\n        return json;\n    }\n\n    private SetMultimap<String, Integer> buildNGramIndex(final List<Variable> varList, final int n) {\n        final TreeMultimap<String, Integer> uniGram = TreeMultimap.create();\n        for (int index = 0; index < varList.size(); index++) {\n            final Variable var = varList.get(index);\n            final String[] indexableNames = var.getIndexableNames();\n            for (final String indexableName : indexableNames) {\n                for (int i = 0; i < indexableName.length() - n + 1; i++) {\n                    final String key = indexableName.substring(i, i + n);\n                    uniGram.put(key, index);\n                }\n            }\n        }\n        return uniGram;\n    }\n\n    private void addVariable(final Variable v, final List<Variable> out) {\n        try {\n            v.toString();\n            out.add(v);\n        } catch (Throwable t) {\n            // skip variables that cannot render due to an exception\n            log.warn(\"Cannot resolve variable \" + v.getName(), t);\n        }\n\n    }\n}\n", "package com.indeed.util.varexport.servlet;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport com.indeed.util.varexport.Export;\nimport com.indeed.util.varexport.ManagedVariable;\nimport com.indeed.util.varexport.VarExporter;\nimport freemarker.template.Configuration;\nimport freemarker.template.DefaultObjectWrapper;\nimport org.apache.log4j.BasicConfigurator;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport org.hamcrest.Matchers;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.List;\n\nimport static org.easymock.EasyMock.createMock;\nimport static org.easymock.EasyMock.expect;\nimport static org.easymock.EasyMock.expectLastCall;\nimport static org.easymock.EasyMock.replay;\nimport static org.easymock.EasyMock.verify;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertThat;\n\n/**\n * @author jack@indeed.com (Jack Humphrey)\n */\npublic class ViewExportedVariablesServletTest {\n\n    private ViewExportedVariablesServlet setupServlet() throws IOException {\n        final Configuration config = new Configuration();\n        config.setObjectWrapper(new DefaultObjectWrapper());\n        config.setClassForTemplateLoading(this.getClass(), \"/\");\n\n        final ViewExportedVariablesServlet servlet = new ViewExportedVariablesServlet();\n        servlet.setVarTextTemplate(config.getTemplate(\"vars-text.ftl\"));\n        servlet.setVarHtmlTemplate(config.getTemplate(\"vars-html.ftl\"));\n        servlet.setBrowseNamespaceTemplate(config.getTemplate(\"browsens.ftl\"));\n\n        return servlet;\n    }\n\n    private String getOutput(final ViewExportedVariablesServlet servlet, String namespace, String tag) throws IOException {\n        final StringWriter output = new StringWriter();\n        HttpServletResponse response = createMock(HttpServletResponse.class);\n        response.setContentType(\"text/plain\");\n        expectLastCall().once();\n        expect(response.getWriter()).andReturn(new PrintWriter(output)).once();\n\n        replay(response);\n        servlet.showVariables(\"\", response, namespace, tag, false, ViewExportedVariablesServlet.DisplayType.PLAINTEXT);\n\n        return output.toString();\n    }\n\n    private void assertLines(final String output, String... lines) {\n        String[] rawLines = output.split(\"\\n\");\n        List<String> actualLines = Lists.newArrayListWithCapacity(rawLines.length);\n        for (String rawLine : rawLines) {\n            rawLine = rawLine.trim();\n            if (!Strings.isNullOrEmpty(rawLine) &&\n                !rawLine.startsWith(\"#\") &&\n                !rawLine.startsWith(\"exporter-start-time=\")) {\n                actualLines.add(rawLine);\n            }\n        }\n        assertThat(actualLines, Matchers.containsInAnyOrder(lines));\n    }\n\n    public static class TagExamples {\n        @Export(name=\"ex1field\", doc=\"Example variable 1\", tags = { \"VEVST1\" })\n        public int ex1 = 1;\n\n        @Export(name=\"ex2field\", doc=\"Example variable 2\", tags = { \"VEVST2\" })\n        public int ex2 = 2;\n\n        @Export(name=\"ex3field\", doc=\"Example variable 3\", tags = { \"VEVST3\" })\n        public int ex3 = 3;\n\n        @Export(name=\"ex4field\", doc=\"Example variable 4\", tags = { \"VEVST2\" })\n        public String ex4 = \"four\";\n\n        @Export(name=\"ex1method\", tags = { \"VEVST3\" })\n        public int getEx1() { return ex1; }\n\n        @Export(name=\"ex2method\", tags = { \"VEVST1\" })\n        public int getEx2() { return ex2; }\n    }\n\n    @Test\n    public void testManagedVariables() throws IOException {\n        final ManagedVariable<String> var1 = ManagedVariable.<String>builder().setName(\"test1\").setValue(\"1\").build();\n        final ManagedVariable<String> var2 = ManagedVariable.<String>builder().setName(\"test2\").setValue(\"2\").build();\n        VarExporter.global().export(var1);\n        VarExporter.global().export(var2);\n        final ViewExportedVariablesServlet servlet = setupServlet();\n        assertLines(getOutput(servlet, \"\", \"\"), \"test1=1\", \"test2=2\");\n    }\n\n    @Test\n    public void testTags() throws IOException {\n        VarExporter.global().export(new TagExamples(), \"\");\n        final ViewExportedVariablesServlet servlet = setupServlet();\n        assertLines(getOutput(servlet, \"\", \"VEVST1\"), \"ex1field=1\", \"ex2method=2\");\n        assertLines(getOutput(servlet, \"\", \"VEVST2\"), \"ex2field=2\", \"ex4field=four\");\n        assertLines(getOutput(servlet, \"\", \"VEVST3\"), \"ex3field=3\", \"ex1method=1\");\n        assertLines(getOutput(servlet, \"\", \"nothing\"), \"null\");\n    }\n\n    @Test\n    public void notFoundIsServedOnMissingNamespace() throws IOException {\n        final String nonExistentNamespace = \"a-nonexistent-namespace\";\n\n        assertFalse(VarExporter.getNamespaces().contains(nonExistentNamespace));\n\n        final HttpServletResponse response = createMock(HttpServletResponse.class);\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, \"The specified namespace not found\");\n        replay(response);\n\n        setupServlet().showVariables(\"/private/v\", response, nonExistentNamespace, \"\", true, ViewExportedVariablesServlet.DisplayType.HTML);\n        verify(response);\n\n        assertFalse(VarExporter.getNamespaces().contains(nonExistentNamespace));\n    }\n\n    @Test\n    public void escapesHtmlInVariableNamesAndValues() throws IOException {\n        final StringWriter bodyWriter = new StringWriter();\n\n        final HttpServletResponse response = createMock(HttpServletResponse.class);\n        response.setContentType(\"text/html\");\n        expectLastCall().once();\n        expect(response.getWriter()).andReturn(new PrintWriter(bodyWriter)).once();\n        replay(response);\n\n        final String unescaped = \"<img src='https://goo.gl/1nzcxx'/>\";\n        VarExporter.global().export(\n                ManagedVariable\n                        .builder()\n                        .setName(unescaped)\n                        .setValue(unescaped)\n                        .build()\n        );\n\n        setupServlet()\n                .showVariables(\n                        \"/private/v\",\n                        response,\n                        \"\",\n                        \"\",\n                        false,\n                        ViewExportedVariablesServlet.DisplayType.HTML\n                        );\n\n        verify(response);\n\n        assertFalse(bodyWriter.toString().contains(unescaped));\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        VarExporter.resetGlobal();\n    }\n\n    @BeforeClass\n    public static void initClass() {\n        BasicConfigurator.configure();\n        Logger.getRootLogger().setLevel(Level.ERROR);\n        Logger.getLogger(\"com.indeed\").setLevel(Level.ERROR);\n    }\n}\n"], "fixing_code": ["// Copyright 2009 Indeed\npackage com.indeed.util.varexport;\n\n\nimport com.google.common.base.CharMatcher;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.escape.Escaper;\n\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * Variable exported by {@link com.indeed.util.varexport.VarExporter}.\n *\n * @see com.indeed.util.varexport.Export\n * @author jack@indeed.com (Jack Humphrey)\n */\npublic abstract class Variable<T> {\n\n    private static Set<Character> nameValueSpecialCharacters = ImmutableSet.of(':', '=');\n\n    private static Pattern INDEXABLE_SPLITTER = Pattern.compile(\"[^a-z0-9]+\");\n\n    private final String name;\n    private final String[] indexableNames;\n    private final String doc;\n    private final String namespace;\n    private final boolean expand;\n    private final Set<String> tags;\n\n    private static String[] buildIndexableName(final String name) {\n        if (name == null) {\n            return new String[0];\n        }\n        return INDEXABLE_SPLITTER.split(name.toLowerCase());\n    }\n\n    public Variable(String name, Set<String> tags, String doc, boolean expand, String namespace) {\n        this.name = name;\n        this.indexableNames = buildIndexableName(name);\n        this.tags = tags;\n        this.doc = doc;\n        this.expand = expand;\n        this.namespace = namespace;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @deprecated do not use this.\n     * Please implement your own tokenization of variable names, if needed.\n     */\n    @Deprecated\n    public String[] getIndexableNames() {\n        return indexableNames;\n    }\n\n    public String getDoc() {\n        return doc != null ? doc : \"\";\n    }\n\n    public Set<String> getTags() {\n        return tags;\n    }\n\n    public String getNamespace() { return namespace; }\n\n    /** @return epoch millis when value was last updated, null if value is current */\n    public Long getLastUpdated() {\n        return null;\n    }\n\n    public boolean isExpandable() {\n        return expand && canExpand();\n    }\n\n    public Map<?, ?> expand() {\n        if (!isExpandable()) {\n            throw new RuntimeException(name + \" is not expandable\");\n        }\n        return (Map<?, ?>) getValue();\n    }\n\n    public boolean hasDoc() {\n        return !Strings.isNullOrEmpty(getDoc());\n    }\n\n    /**\n     * @return True as long as the variable is \"live\" and should continue to be valid/usable\n     */\n    protected abstract boolean isLive();\n\n    protected abstract boolean canExpand();\n\n    public abstract T getValue();\n\n    public String getNamespaceAndName() {\n        if(Strings.isNullOrEmpty(namespace)) {\n            return name;\n        }\n\n        return namespace + \"-\" + name;\n    }\n\n    /**\n     * Write name and value (and optionally documentation) in {@link java.util.Properties} format.\n     * @param out writer\n     * @param includeDoc true if should be prefixed with documentation line\n     */\n    public void write(PrintWriter out, boolean includeDoc) {\n        // getValue() will update the timestamp (if relevant)\n        T localValue = getValue();\n        if (includeDoc) {\n            out.println();\n            Long lastUpdate = getLastUpdated();\n            if (hasDoc() || lastUpdate != null) {\n                out.print(\"# \");\n                if (hasDoc()) {\n                    out.print(makePropertiesSafe(getDoc(), null));\n                }\n                if (lastUpdate != null) {\n                    out.print(\" (last update: \" + lastUpdate + \")\");\n                }\n                out.println();\n            }\n        }\n        out.println(toString());\n    }\n\n    /**\n     * Write value (escaped for {@link java.util.Properties} format).\n     * @param out writer\n     */\n    public void writeValue(PrintWriter out) {\n        out.print(makePropertiesSafe(getValue(), nameValueSpecialCharacters));\n    }\n\n    public String getValueString() {\n        T value = getValue();\n        return \"\" + value;\n    }\n\n    public String getSafeValue() {\n        return makePropertiesSafe(getValue(), nameValueSpecialCharacters);\n    }\n\n    public String getSafeName() {\n        return makePropertiesSafe(name, nameValueSpecialCharacters);\n    }\n\n    public String toString() {\n        return getSafeName() + \"=\" + getSafeValue();\n    }\n\n    private static String makePropertiesSafe(Object in, Set<Character> toEscape) {\n        if (in == null) { return \"null\"; }\n        String str = in.toString();\n        StringBuilder result = null;\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            final boolean isAscii = CharMatcher.ascii().matches(c);\n            final boolean requiresEscape = !isAscii || (toEscape != null && toEscape.contains(c));\n            if (requiresEscape && result == null) {\n                result = new StringBuilder(str.length() * 2);\n                result.append(str, 0, i);\n            }\n            if (!isAscii) {\n                result.append(JavaSourceEscaper.escapeChar(c));\n            } else {\n                if (requiresEscape) {\n                    result.append('\\\\');\n                }\n                if (result != null) {\n                    result.append(c);\n                }\n            }\n        }\n        return result == null ? str : result.toString();\n    }\n\n    /** Escapes non-ASCII using \\\\unnnn format */\n    private static class JavaSourceEscaper extends Escaper {\n        // TODO: remove if guava ever adds SourceCodeEscapers\n        public String escape(String input) {\n            StringBuilder b = new StringBuilder();\n            for (int i = 0; i < input.length(); i++) {\n                char c = input.charAt(i);\n                if (!CharMatcher.ascii().matches(c)) {\n                    b.append(escapeChar(c));\n                } else {\n                    b.append(c);\n                }\n            }\n            return b.toString();\n        }\n\n        public static String escapeChar(char c) {\n            if (c < 0x10) {\n                return \"\\\\u000\" + Integer.toHexString(c);\n            } else if (c < 0x100) {\n                return \"\\\\u00\" + Integer.toHexString(c);\n            } else if (c < 0x1000) {\n                return \"\\\\u0\" + Integer.toHexString(c);\n            }\n            return \"\\\\u\" + Integer.toHexString(c);\n        }\n    }\n}\n", "// Copyright 2009 Indeed\npackage com.indeed.util.varexport.servlet;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.TreeMultimap;\nimport com.indeed.util.varexport.VarExporter;\nimport com.indeed.util.varexport.Variable;\nimport com.indeed.util.varexport.VariableHost;\nimport com.indeed.util.varexport.VariableVisitor;\nimport freemarker.template.Configuration;\nimport freemarker.template.DefaultObjectWrapper;\nimport freemarker.template.Template;\nimport org.apache.log4j.Logger;\n\nimport javax.annotation.Nullable;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\n/**\n * Servlet for displaying variables exported by {@link VarExporter}.\n * Will escape values for compatibility with loading into {@link Properties}.\n *\n * @author jack@indeed.com (Jack Humphrey)\n */\npublic class ViewExportedVariablesServlet extends HttpServlet {\n\n    private static final Logger log = Logger.getLogger(ViewExportedVariablesServlet.class);\n\n    private static final Joiner COMMA_JOINER = Joiner.on(',');\n\n    private Template varTextTemplate;\n    private Template varHtmlTemplate;\n    private Template browseNamespaceTemplate;\n\n    public enum DisplayType {\n        PLAINTEXT(\"text\", \"text/plain\"),\n        JSON(\"json\", \"application/json\"),\n        HTML(\"html\", \"text/html\");\n\n        private final String paramValue;\n        private final String mimeType;\n\n        DisplayType(final String paramValue, final String mimeType) {\n            this.paramValue = paramValue;\n            this.mimeType = mimeType;\n        }\n\n    }\n\n    @VisibleForTesting\n    protected void setVarTextTemplate(final Template varTextTemplate) {\n        this.varTextTemplate = varTextTemplate;\n    }\n\n    @VisibleForTesting\n    protected void setVarHtmlTemplate(final Template varHtmlTemplate) {\n        this.varHtmlTemplate = varHtmlTemplate;\n    }\n\n    @VisibleForTesting\n    protected void setBrowseNamespaceTemplate(final Template browseNamespaceTemplate) {\n        this.browseNamespaceTemplate = browseNamespaceTemplate;\n    }\n\n    @Override\n    public void init(final ServletConfig servletConfig) throws ServletException {\n        super.init(servletConfig);\n\n        final Configuration config = new Configuration();\n        config.setObjectWrapper(new DefaultObjectWrapper());\n        final String templateLoadPath = servletConfig.getInitParameter(\"templateLoadPath\");\n        if (templateLoadPath != null && new File(templateLoadPath).isDirectory()) {\n            try {\n                config.setDirectoryForTemplateLoading(new File(templateLoadPath));\n            } catch (IOException e) {\n                throw new ServletException(e);\n            }\n        } else {\n            final String contextLoadPath = servletConfig.getInitParameter(\"contextLoadPath\");\n            if (contextLoadPath != null) {\n                final ServletContext ctx = servletConfig.getServletContext();\n                config.setServletContextForTemplateLoading(ctx, contextLoadPath);\n            } else {\n                config.setClassForTemplateLoading(getClass(), \"/\");\n            }\n        }\n        try {\n            varTextTemplate = config.getTemplate(\"vars-text.ftl\");\n            varHtmlTemplate = config.getTemplate(\"vars-html.ftl\");\n            browseNamespaceTemplate = config.getTemplate(\"browsens.ftl\");\n        } catch (IOException e) {\n            throw new ServletException(\"Failed to load template\", e);\n        }\n    }\n\n    @Override\n    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        response.setCharacterEncoding(\"UTF-8\");\n\n        if (\"1\".equals(request.getParameter(\"browse\"))) {\n            showNamespaces(request.getRequestURI(), response);\n        } else {\n            final String[] vars = request.getParameterValues(\"v\");\n            final boolean doc = \"1\".equals(request.getParameter(\"doc\"));\n            final String fmtParam = request.getParameter(\"fmt\");\n            final DisplayType displayType;\n            if (\"html\".equals(fmtParam)) {\n                displayType = DisplayType.HTML;\n            } else if (\"json\".equals(fmtParam)) {\n                displayType = DisplayType.JSON;\n            } else {\n                displayType = DisplayType.PLAINTEXT;\n            }\n            showVariables(request.getRequestURI(), response, request.getParameter(\"ns\"), request.getParameter(\"tag\"), doc, displayType, vars);\n        }\n    }\n\n    private void showNamespaces(final String uri, final HttpServletResponse response) throws IOException {\n        final List<String> namespaces = VarExporter.getNamespaces();\n        namespaces.remove(null);\n        Collections.sort(namespaces);\n\n        final Map<String, String> parents = Maps.newHashMapWithExpectedSize(namespaces.size());\n        for (String namespace : namespaces) {\n            VarExporter parent = VarExporter.forNamespace(namespace).getParentNamespace();\n            if (parent == null) {\n                parents.put(namespace, \"none\");\n            } else {\n                parents.put(namespace, parent.getNamespace());\n            }\n        }\n\n        response.setContentType(\"text/html\");\n        final PrintWriter out = response.getWriter();\n        final Map<String, Object> root = new HashMap<String, Object>();\n        root.put(\"urlPath\", uri);\n        root.put(\"namespaces\", namespaces);\n        root.put(\"parents\", parents);\n        try {\n            browseNamespaceTemplate.process(root, out);\n        } catch (Exception e) {\n            throw new IOException(\"template failure\", e);\n        }\n        out.flush();\n        out.close();\n    }\n\n    /**\n     * @param uri The request URI.\n     * @param response The response we will stream the report to.\n     * @param namespace The namespace which we should be inspecting\n     * @param includeDoc True if we should include docs. False, otherwise.\n     * @param html True to display the report in HTML. False for PLAINTEXT.\n     * @param vars The variables that we want to view.\n     * @throws IOException If we cannot write to the response stream.\n     * @deprecated use version that takes DisplayType enum\n     */\n    @Deprecated\n    protected void showVariables(\n            final String uri,\n            final HttpServletResponse response,\n            final String namespace,\n            final boolean includeDoc,\n            final boolean html,\n            final String... vars\n    ) throws IOException {\n        final DisplayType displayType = html ? DisplayType.HTML : DisplayType.PLAINTEXT;\n        showVariables(uri, response, namespace, includeDoc, displayType, vars);\n    }\n\n    /**\n     * @param uri The request URI.\n     * @param response The response we will stream the report to.\n     * @param namespace The namespace which we should be inspecting\n     * @param includeDoc True if we should include docs. False, otherwise.\n     * @param displayType The type of display to produce.\n     * @param vars The variables that we want to view.\n     * @throws IOException If we cannot write to the response stream.\n     * @deprecated use version that takes tag\n     */\n    @Deprecated\n    protected void showVariables(\n            final String uri,\n            final HttpServletResponse response,\n            final String namespace,\n            final boolean includeDoc,\n            final DisplayType displayType,\n            final String... vars\n    ) throws IOException {\n        showVariables(uri, response, namespace, null, includeDoc, displayType, vars);\n    }\n\n    protected void showVariables(\n            final String uri,\n            final HttpServletResponse response,\n            final String namespace,\n            final String tag,\n            final boolean includeDoc,\n            final DisplayType displayType,\n            final String... vars\n    ) throws IOException {\n        final VariableHost exporter;\n        if (!Strings.isNullOrEmpty(tag)) {\n            exporter = VarExporter.withTag(tag);\n        } else if (!Strings.isNullOrEmpty(namespace)) {\n            final Optional<VarExporter> maybeExporter = VarExporter.forNamespaceIfExists(namespace);\n            if (!maybeExporter.isPresent()) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"The specified namespace not found\");\n                return;\n            }\n            exporter = maybeExporter.get();\n        } else {\n            exporter = VarExporter.global();\n        }\n\n        final PrintWriter out = response.getWriter();\n        response.setContentType(displayType.mimeType);\n        switch(displayType) {\n            case HTML:\n                showUsingTemplate(exporter, uri, namespace, includeDoc, varHtmlTemplate, true, out, vars);\n                break;\n            case PLAINTEXT:\n                showUsingTemplate(exporter, uri, namespace, includeDoc, varTextTemplate, false, out, vars);\n                break;\n            // TODO: support json -- exporter JSON is currently broken\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    private void showUsingTemplate(\n            final VariableHost exporter,\n            final String uri,\n            final String namespace,\n            final boolean includeDoc,\n            final Template template,\n            final boolean withIndex,\n            final PrintWriter out,\n            final String... vars\n    ) throws IOException {\n        final String name = (namespace == null ? \"Global\" : namespace);\n\n        final Map<String, Object> root = new HashMap<String, Object>();\n        final DateFormat df = SimpleDateFormat.getDateTimeInstance();\n        root.put(\"urlPath\", uri);\n        root.put(\"name\", name);\n        root.put(\"date\", df.format(new Date()));\n        root.put(\"includeDoc\", includeDoc);\n\n        final List<Variable> varList;\n        if (vars != null && vars.length == 1) {\n            final Variable v = exporter.getVariable(vars[0]);\n            if (v != null) {\n                varList = Lists.newArrayListWithExpectedSize(1);\n                addVariable(v, varList);\n            } else {\n                varList = ImmutableList.of();\n            }\n        } else {\n            varList = Lists.newArrayListWithExpectedSize(vars != null ? vars.length : 256);\n            if (vars == null || vars.length == 0) {\n                exporter.visitVariables(new VariableVisitor() {\n                    public void visit(Variable var) {\n                        addVariable(var, varList);\n                    }\n                });\n            } else {\n                for (String var : vars) {\n                    Variable v = exporter.getVariable(var);\n                    if (v != null) {\n                        addVariable(v, varList);\n                    }\n                }\n            }\n        }\n        root.put(\"vars\", varList);\n        if (withIndex) {\n            root.put(\"varsIndex\", alphanumericNGramIndexesJSON(varList));\n        }\n\n        try {\n            template.process(root, out);\n        } catch (Exception e) {\n            throw new IOException(\"template failure\", e);\n        }\n    }\n\n    private String alphanumericNGramIndexesJSON(final List<Variable> varList) {\n        // The JSON we build here is valid as we only use alphanumeric n-grams\n\n        final StringBuilder json = new StringBuilder();\n\n        json.append('{').append('\\n');\n\n        json.append(\"\\n\\\"uniGram\\\":\").append('\\n');\n        appendTo(json, buildAlphanumericNGramIndex(varList, 1)).append(',').append('\\n');\n\n        json.append(\"\\\"biGram\\\":\").append('\\n');\n        appendTo(json, buildAlphanumericNGramIndex(varList, 2)).append(',').append('\\n');;\n\n        json.append(\"\\\"triGram\\\":\").append('\\n');\n        appendTo(json, buildAlphanumericNGramIndex(varList, 3));\n\n        json.append('}');\n\n        return json.toString();\n    }\n\n    private <K> StringBuilder appendTo(final StringBuilder json, final SetMultimap<K, Integer> map) {\n        json.append('{').append('\\n');\n        boolean isFirst = true;\n        for (final K key : map.keySet()) {\n            final Set<Integer> values = map.get(key);\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                json.append(',').append('\\n');\n            }\n            json.append('\"').append(key.toString()).append('\"').append(':');\n            json.append('[');\n            COMMA_JOINER.appendTo(json, values);\n            json.append(']');\n        }\n        json.append('\\n').append('}');\n        return json;\n    }\n\n    @VisibleForTesting\n    static SetMultimap<String, Integer> buildAlphanumericNGramIndex(final List<Variable> varList, final int n) {\n        final TreeMultimap<String, Integer> nGramIndex = TreeMultimap.create();\n        IntStream\n                .range(0, varList.size())\n                .forEach(i ->\n                        alphanumericNGrams(varList.get(i).getName(), n)\n                                .forEach(ngram -> nGramIndex.put(ngram, i))\n                );\n        return nGramIndex;\n    }\n\n    private static final Pattern NON_ALPHANUMERIC = Pattern.compile(\"[^a-z0-9]+\");\n\n    @VisibleForTesting\n    static Stream<String> alphanumericNGrams(@Nullable final String in, final int n) {\n        if (in == null) {\n            return Stream.empty();\n        }\n        return NON_ALPHANUMERIC\n                .splitAsStream(in.toLowerCase(Locale.US))\n                .flatMap(alnumSubString ->\n                        IntStream\n                                .rangeClosed(0, alnumSubString.length() - n)\n                                .mapToObj(i -> alnumSubString.substring(i, i + n))\n                );\n    }\n\n    private void addVariable(final Variable v, final List<Variable> out) {\n        try {\n            v.toString();\n            out.add(v);\n        } catch (Throwable t) {\n            // skip variables that cannot render due to an exception\n            log.warn(\"Cannot resolve variable \" + v.getName(), t);\n        }\n\n    }\n}\n", "package com.indeed.util.varexport.servlet;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.TreeMultimap;\nimport com.indeed.util.varexport.Export;\nimport com.indeed.util.varexport.ManagedVariable;\nimport com.indeed.util.varexport.VarExporter;\nimport freemarker.template.Configuration;\nimport freemarker.template.DefaultObjectWrapper;\nimport org.apache.log4j.BasicConfigurator;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport org.hamcrest.Matchers;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static org.easymock.EasyMock.createMock;\nimport static org.easymock.EasyMock.expect;\nimport static org.easymock.EasyMock.expectLastCall;\nimport static org.easymock.EasyMock.replay;\nimport static org.easymock.EasyMock.verify;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertThat;\n\n/**\n * @author jack@indeed.com (Jack Humphrey)\n */\npublic class ViewExportedVariablesServletTest {\n\n    private ViewExportedVariablesServlet setupServlet() throws IOException {\n        final Configuration config = new Configuration();\n        config.setObjectWrapper(new DefaultObjectWrapper());\n        config.setClassForTemplateLoading(this.getClass(), \"/\");\n\n        final ViewExportedVariablesServlet servlet = new ViewExportedVariablesServlet();\n        servlet.setVarTextTemplate(config.getTemplate(\"vars-text.ftl\"));\n        servlet.setVarHtmlTemplate(config.getTemplate(\"vars-html.ftl\"));\n        servlet.setBrowseNamespaceTemplate(config.getTemplate(\"browsens.ftl\"));\n\n        return servlet;\n    }\n\n    private String getOutput(final ViewExportedVariablesServlet servlet, String namespace, String tag) throws IOException {\n        final StringWriter output = new StringWriter();\n        HttpServletResponse response = createMock(HttpServletResponse.class);\n        response.setContentType(\"text/plain\");\n        expectLastCall().once();\n        expect(response.getWriter()).andReturn(new PrintWriter(output)).once();\n\n        replay(response);\n        servlet.showVariables(\"\", response, namespace, tag, false, ViewExportedVariablesServlet.DisplayType.PLAINTEXT);\n\n        return output.toString();\n    }\n\n    private void assertLines(final String output, String... lines) {\n        String[] rawLines = output.split(\"\\n\");\n        List<String> actualLines = Lists.newArrayListWithCapacity(rawLines.length);\n        for (String rawLine : rawLines) {\n            rawLine = rawLine.trim();\n            if (!Strings.isNullOrEmpty(rawLine) &&\n                !rawLine.startsWith(\"#\") &&\n                !rawLine.startsWith(\"exporter-start-time=\")) {\n                actualLines.add(rawLine);\n            }\n        }\n        assertThat(actualLines, Matchers.containsInAnyOrder(lines));\n    }\n\n    public static class TagExamples {\n        @Export(name=\"ex1field\", doc=\"Example variable 1\", tags = { \"VEVST1\" })\n        public int ex1 = 1;\n\n        @Export(name=\"ex2field\", doc=\"Example variable 2\", tags = { \"VEVST2\" })\n        public int ex2 = 2;\n\n        @Export(name=\"ex3field\", doc=\"Example variable 3\", tags = { \"VEVST3\" })\n        public int ex3 = 3;\n\n        @Export(name=\"ex4field\", doc=\"Example variable 4\", tags = { \"VEVST2\" })\n        public String ex4 = \"four\";\n\n        @Export(name=\"ex1method\", tags = { \"VEVST3\" })\n        public int getEx1() { return ex1; }\n\n        @Export(name=\"ex2method\", tags = { \"VEVST1\" })\n        public int getEx2() { return ex2; }\n    }\n\n    @Test\n    public void testManagedVariables() throws IOException {\n        final ManagedVariable<String> var1 = ManagedVariable.<String>builder().setName(\"test1\").setValue(\"1\").build();\n        final ManagedVariable<String> var2 = ManagedVariable.<String>builder().setName(\"test2\").setValue(\"2\").build();\n        VarExporter.global().export(var1);\n        VarExporter.global().export(var2);\n        final ViewExportedVariablesServlet servlet = setupServlet();\n        assertLines(getOutput(servlet, \"\", \"\"), \"test1=1\", \"test2=2\");\n    }\n\n    @Test\n    public void testTags() throws IOException {\n        VarExporter.global().export(new TagExamples(), \"\");\n        final ViewExportedVariablesServlet servlet = setupServlet();\n        assertLines(getOutput(servlet, \"\", \"VEVST1\"), \"ex1field=1\", \"ex2method=2\");\n        assertLines(getOutput(servlet, \"\", \"VEVST2\"), \"ex2field=2\", \"ex4field=four\");\n        assertLines(getOutput(servlet, \"\", \"VEVST3\"), \"ex3field=3\", \"ex1method=1\");\n        assertLines(getOutput(servlet, \"\", \"nothing\"), \"null\");\n    }\n\n    @Test\n    public void notFoundIsServedOnMissingNamespace() throws IOException {\n        final String nonExistentNamespace = \"a-nonexistent-namespace\";\n\n        assertFalse(VarExporter.getNamespaces().contains(nonExistentNamespace));\n\n        final HttpServletResponse response = createMock(HttpServletResponse.class);\n        response.sendError(HttpServletResponse.SC_NOT_FOUND, \"The specified namespace not found\");\n        replay(response);\n\n        setupServlet().showVariables(\"/private/v\", response, nonExistentNamespace, \"\", true, ViewExportedVariablesServlet.DisplayType.HTML);\n        verify(response);\n\n        assertFalse(VarExporter.getNamespaces().contains(nonExistentNamespace));\n    }\n\n    @Test\n    public void escapesHtmlInVariableNamesAndValues() throws IOException {\n        final StringWriter bodyWriter = new StringWriter();\n\n        final HttpServletResponse response = createMock(HttpServletResponse.class);\n        response.setContentType(\"text/html\");\n        expectLastCall().once();\n        expect(response.getWriter()).andReturn(new PrintWriter(bodyWriter)).once();\n        replay(response);\n\n        final String unescaped = \"<img src='https://goo.gl/1nzcxx'/>\";\n        VarExporter.global().export(\n                ManagedVariable\n                        .builder()\n                        .setName(unescaped)\n                        .setValue(unescaped)\n                        .build()\n        );\n\n        setupServlet()\n                .showVariables(\n                        \"/private/v\",\n                        response,\n                        \"\",\n                        \"\",\n                        false,\n                        ViewExportedVariablesServlet.DisplayType.HTML\n                        );\n\n        verify(response);\n\n        assertFalse(bodyWriter.toString().contains(unescaped));\n    }\n\n    @Test\n    public void buildAlphaNumericNGramIndex() {\n        final TreeMultimap<String, Integer> expectedTriGramIndex = TreeMultimap.create();\n        expectedTriGramIndex.put(\"abc\", 0);\n        expectedTriGramIndex.put(\"bcd\", 0);\n        expectedTriGramIndex.put(\"bcd\", 1);\n        expectedTriGramIndex.put(\"zzz\", 2);\n\n        final SetMultimap<String, Integer> actualTriGramIndex = ViewExportedVariablesServlet.buildAlphanumericNGramIndex(\n                Arrays.asList(\n                        ManagedVariable.builder().setName(\"abcd\").build(),\n                        ManagedVariable.builder().setName(\"bcd\").build(),\n                        ManagedVariable.builder().setName(\"zzz\").build()\n                ),\n                3\n        );\n\n        assertEquals(expectedTriGramIndex, actualTriGramIndex);\n    }\n\n    @Test\n    public void alphanumericNGrams() {\n        assertEquals(0, ViewExportedVariablesServlet.alphanumericNGrams(null, 1).count());\n        assertEquals(0, ViewExportedVariablesServlet.alphanumericNGrams(\"zzz\", 42).count());\n\n        assertEquals(\n                Arrays.asList(\"m\", \"1\", \"3\", \"b\", \"i\", \"t\", \"r\", \"i\"),\n                ViewExportedVariablesServlet\n                        .alphanumericNGrams(\"m1-3-/bi<</tri\", 1)\n                        .collect(Collectors.toList())\n        );\n\n        assertEquals(\n                Arrays.asList(\"m1\", \"bi\", \"tr\", \"ri\"),\n                ViewExportedVariablesServlet\n                        .alphanumericNGrams(\"m1-3-/bi<</tri\", 2)\n                        .collect(Collectors.toList())\n        );\n\n        assertEquals(\n                Arrays.asList(\n                        \"m1x\",\n                        \"1x3\",\n                        \"x3d\",\n                        \"3dc\",\n                        \"dca\",\n                        \"cas\",\n                        \"ase\",\n                        \"tri\",\n                        \"tri\"\n                ),\n                ViewExportedVariablesServlet\n                        .alphanumericNGrams(\"m1x3dCaSe-1-/bi<</tri?tri\", 3)\n                        .collect(Collectors.toList())\n        );\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        VarExporter.resetGlobal();\n    }\n\n    @BeforeClass\n    public static void initClass() {\n        BasicConfigurator.configure();\n        Logger.getRootLogger().setLevel(Level.ERROR);\n        Logger.getLogger(\"com.indeed\").setLevel(Level.ERROR);\n    }\n}\n"], "filenames": ["varexport/src/main/java/com/indeed/util/varexport/Variable.java", "varexport/src/main/java/com/indeed/util/varexport/servlet/ViewExportedVariablesServlet.java", "varexport/src/test/java/com/indeed/util/varexport/servlet/ViewExportedVariablesServletTest.java"], "buggy_code_start_loc": [53, 7, 4], "buggy_code_end_loc": [53, 349, 166], "fixing_code_start_loc": [54, 7, 5], "fixing_code_end_loc": [59, 382, 229], "type": "CWE-79", "message": "A vulnerability classified as problematic has been found in Indeed Engineering util up to 1.0.33. Affected is the function visit/appendTo of the file varexport/src/main/java/com/indeed/util/varexport/servlet/ViewExportedVariablesServlet.java. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.0.34 is able to address this issue. The name of the patch is c0952a9db51a880e9544d9fac2a2218a6bfc9c63. It is recommended to upgrade the affected component. VDB-216882 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2020-36634", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T13:15:11.047", "lastModified": "2023-01-06T06:04:40.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in Indeed Engineering util up to 1.0.33. Affected is the function visit/appendTo of the file varexport/src/main/java/com/indeed/util/varexport/servlet/ViewExportedVariablesServlet.java. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 1.0.34 is able to address this issue. The name of the patch is c0952a9db51a880e9544d9fac2a2218a6bfc9c63. It is recommended to upgrade the affected component. VDB-216882 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:indeed:util:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.34", "matchCriteriaId": "35E21AEA-472C-4FB0-9AA0-F21179519BC4"}]}]}], "references": [{"url": "https://github.com/indeedeng/util/commit/c0952a9db51a880e9544d9fac2a2218a6bfc9c63", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/indeedeng/util/releases/tag/published%2F1.0.34", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216882", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216882", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/indeedeng/util/commit/c0952a9db51a880e9544d9fac2a2218a6bfc9c63"}}