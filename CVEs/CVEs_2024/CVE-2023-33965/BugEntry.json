{"buggy_code": ["// Copyright (c) 2016-present Cloud <cloud@txthinking.com>\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of version 3 of the GNU General Public\n// License as published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n// General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/txthinking/brook\"\n\t\"github.com/txthinking/brook/plugins/block\"\n\t\"github.com/txthinking/brook/plugins/pprof\"\n\t\"github.com/txthinking/brook/plugins/socks5dial\"\n\t\"github.com/txthinking/brook/plugins/thedns\"\n\t\"github.com/txthinking/brook/plugins/tproxy\"\n\t\"github.com/txthinking/runnergroup\"\n\t\"github.com/txthinking/socks5\"\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n\tg := runnergroup.New()\n\tapp := cli.NewApp()\n\tapp.Name = \"Brook\"\n\tapp.Version = \"20230122.Beta.20230214\"\n\tapp.Usage = \"A cross-platform network tool designed for developers\"\n\tapp.Authors = []*cli.Author{\n\t\t{\n\t\t\tName:  \"Cloud\",\n\t\t\tEmail: \"cloud@txthinking.com\",\n\t\t},\n\t}\n\tapp.Copyright = \"https://github.com/txthinking/brook\"\n\tapp.EnableBashCompletion = true\n\tapp.Flags = []cli.Flag{\n\t\t&cli.StringFlag{\n\t\t\tName:  \"pprof\",\n\t\t\tUsage: \"go http pprof listen addr, such as :6060\",\n\t\t},\n\t}\n\tapp.Before = func(c *cli.Context) error {\n\t\tif c.String(\"pprof\") != \"\" {\n\t\t\tp, err := pprof.NewPprof(c.String(\"pprof\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\tStart: func() error {\n\t\t\t\t\treturn p.ListenAndServe()\n\t\t\t\t},\n\t\t\t\tStop: func() error {\n\t\t\t\t\treturn p.Shutdown()\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n\tapp.Commands = []*cli.Command{\n\t\t&cli.Command{\n\t\t\tName:  \"server\",\n\t\t\tUsage: \"Run as brook server, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, requires your socks5 supports standard socks5 TCP and UDP, such as 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Username\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Password\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, password\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewServer(c.String(\"listen\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"toSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"toSocks5\"), c.String(\"toSocks5Username\"), c.String(\"toSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"client\",\n\t\t\tUsage: \"Run as brook client, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook client <-> $ brook server <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook server address, like: 1.2.3.4:9999\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook server password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"server\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewClient(c.String(\"socks5\"), ip, c.String(\"server\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.UDPOverTCP = c.Bool(\"udpovertcp\")\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tgo func() {\n\t\t\t\t\tsigs := make(chan os.Signal, 1)\n\t\t\t\t\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t\t\t\t\t<-sigs\n\t\t\t\t\tg.Done()\n\t\t\t\t}()\n\t\t\t\treturn g.Wait()\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wsserver\",\n\t\t\tUsage: \"Run as brook wsserver, both TCP and UDP, it will start a standard http server and websocket server\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: ':80'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"path\",\n\t\t\t\t\tUsage: \"URL path\",\n\t\t\t\t\tValue: \"/ws\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, requires your socks5 supports standard socks5 TCP and UDP, such as 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Username\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Password\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, password\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif c.String(\"toSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"toSocks5\"), c.String(\"toSocks5Username\"), c.String(\"toSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSServer(c.String(\"listen\"), c.String(\"password\"), \"\", c.String(\"path\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wsclient\",\n\t\t\tUsage: \"Run as brook wsclient, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook wsclient <-> $ brook wsserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"wsserver\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook wsserver address, like: ws://1.2.3.4:80, if no path then /ws will be used. Do not omit the port under any circumstances\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook wsserver password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"Specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"wsserver\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSClient(c.String(\"socks5\"), ip, c.String(\"wsserver\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\ts.ServerAddress = c.String(\"address\")\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wssserver\",\n\t\t\tUsage: \"Run as brook wssserver, both TCP and UDP, it will start a standard https server and websocket server\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domainaddress\",\n\t\t\t\t\tUsage: \"Such as: domain.com:443. If you choose to automatically issue certificates, the domain must have been resolved to the server IP and 80 port also will be used\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"cert\",\n\t\t\t\t\tUsage: \"The cert file absolute path for the domain, such as /path/to/cert.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"certkey\",\n\t\t\t\t\tUsage: \"The cert key file absolute path for the domain, such as /path/to/certkey.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"path\",\n\t\t\t\t\tUsage: \"URL path\",\n\t\t\t\t\tValue: \"/ws\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, requires your socks5 supports standard socks5 TCP and UDP, such as 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Username\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Password\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, password\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"domainaddress\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" && !filepath.IsAbs(c.String(\"cert\")) {\n\t\t\t\t\treturn errors.New(\"--cert must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" && !filepath.IsAbs(c.String(\"certkey\")) {\n\t\t\t\t\treturn errors.New(\"--certkey must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif c.String(\"toSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"toSocks5\"), c.String(\"toSocks5Username\"), c.String(\"toSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"domainaddress\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSServer(\":\"+p, c.String(\"password\"), h, c.String(\"path\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"cert\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.Cert = b\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"certkey\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.CertKey = b\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wssclient\",\n\t\t\tUsage: \"Run as brook wssclient, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook wssclient <-> $ brook wssserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"wssserver\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook wssserver address, like: wss://google.com:443, if no path then /ws will be used. Do not omit the port under any circumstances\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook wssserver password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"Specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"Client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"wssserver\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSClient(c.String(\"socks5\"), ip, c.String(\"wssserver\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\ts.ServerAddress = c.String(\"address\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\ts.TLSConfig.InsecureSkipVerify = true\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\troots := x509.NewCertPool()\n\t\t\t\t\tok := roots.AppendCertsFromPEM(b)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn errors.New(\"failed to parse root certificate\")\n\t\t\t\t\t}\n\t\t\t\t\ts.TLSConfig.RootCAs = roots\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"quicserver\",\n\t\t\tUsage: \"Run as brook quicserver, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domainaddress\",\n\t\t\t\t\tUsage: \"Such as: domain.com:443. If you choose to automatically issue certificates, the domain must have been resolved to the server IP and 80 port also will be used\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"cert\",\n\t\t\t\t\tUsage: \"The cert file absolute path for the domain, such as /path/to/cert.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"certkey\",\n\t\t\t\t\tUsage: \"The cert key file absolute path for the domain, such as /path/to/certkey.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"domainaddress\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" && !filepath.IsAbs(c.String(\"cert\")) {\n\t\t\t\t\treturn errors.New(\"--cert must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" && !filepath.IsAbs(c.String(\"certkey\")) {\n\t\t\t\t\treturn errors.New(\"--certkey must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"domainaddress\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewQUICServer(\":\"+p, c.String(\"password\"), h, c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.Int64(\"updateListInterval\"), c.StringSlice(\"blockGeoIP\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"cert\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.Cert = b\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"certkey\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.CertKey = b\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"quicclient\",\n\t\t\tUsage: \"Run as brook quicclient, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook quicclient <-> $ brook quicserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"quicserver\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook quicserver address, like: quic://google.com:443. Do not omit the port under any circumstances\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook quicserver password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"Specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"quicserver\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewQUICClient(c.String(\"socks5\"), ip, c.String(\"quicserver\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\ts.ServerAddress = c.String(\"address\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\troots := x509.NewCertPool()\n\t\t\t\t\tok := roots.AppendCertsFromPEM(b)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn errors.New(\"failed to parse root certificate\")\n\t\t\t\t\t}\n\t\t\t\t\ts.TLSConfig.RootCAs = roots\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"relayoverbrook\",\n\t\t\tUsage: \"Run as relay over brook, both TCP and UDP, this means access [from address] is equal to [to address], [src <-> from address <-> $ brook server/wsserver/wssserver/quicserver <-> to address]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"from\",\n\t\t\t\t\tAliases: []string{\"f\", \"l\"},\n\t\t\t\t\tUsage:   \"Listen address: like ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"to\",\n\t\t\t\t\tAliases: []string{\"t\"},\n\t\t\t\t\tUsage:   \"Address which relay to, like: 1.2.3.4:9999\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"brook server or brook wsserver or brook wssserver, like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://domain:443/ws, quic://domain.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"from\") == \"\" || c.String(\"to\") == \"\" || c.String(\"server\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tkind := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\tkind = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\tkind = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\tkind = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelayOverBrook(c.String(\"from\"), brook.LinkExtra(kind, c.String(\"server\"), \"\", c.String(\"password\"), v), c.String(\"to\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"dnsserveroverbrook\",\n\t\t\tUsage: \"Run as dns server over brook, both TCP and UDP, [src <-> $ brook dnserversoverbrook <-> $ brook server/wsserver/wssserver/quicserver <-> dns] or [src <-> $ brook dnsserveroverbrook <-> dnsForBypass]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: 127.0.0.1:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains NOT in list\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsForBypass\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains in bypass list\",\n\t\t\t\t\tValue: \"223.5.5.5:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableA\",\n\t\t\t\t\tUsage: \"Disable A query\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableAAAA\",\n\t\t\t\t\tUsage: \"Disable AAAA query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"brook server or brook wsserver or brook wssserver, like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://domain.com:443/ws, quic://domain.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"server\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassDomainList\") != \"\" && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--bypassDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"bypassDomainList\") != \"\" || c.Bool(\"disableA\") || c.Bool(\"disableAAAA\") {\n\t\t\t\t\tp, err := thedns.NewTheDNS(c.String(\"blockDomainList\"), c.String(\"bypassDomainList\"), c.String(\"dnsForBypass\"), c.Bool(\"disableA\"), c.Bool(\"disableAAAA\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tkind := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\tkind = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\tkind = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\tkind = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelayOverBrook(c.String(\"listen\"), brook.LinkExtra(kind, c.String(\"server\"), \"\", c.String(\"password\"), v), c.String(\"dns\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.IsDNS = true\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"tproxy\",\n\t\t\tUsage: \"Run as transparent proxy, both TCP and UDP, only works on Linux, [src <-> $ brook tproxy <-> $ brook server/wsserver/wssserver/quicserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, DO NOT contain IP, just like: ':1080'. No need to operate iptables by default!\",\n\t\t\t\t\tValue:   \":1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsListen\",\n\t\t\t\t\tUsage: \"Start a smart DNS server, like: ':53'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsForDefault\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains NOT in list\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsForBypass\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains in bypass list\",\n\t\t\t\t\tValue: \"223.5.5.5:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, Suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, Suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableA\",\n\t\t\t\t\tUsage: \"Disable A query\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableAAAA\",\n\t\t\t\t\tUsage: \"Disable AAAA query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"bypassGeoIP\",\n\t\t\t\t\tUsage: \"Bypass IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"enableIPv6\",\n\t\t\t\t\tUsage: \"Your local and server must support IPv6 both\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"doNotRunScripts\",\n\t\t\t\t\tUsage: \"This will not change iptables and others if you want to do by yourself\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"webListen\",\n\t\t\t\t\tUsage: \"Ignore all other parameters, run web UI, like: ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"brook server or brook wsserver or brook wssserver, like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://domain.com:443/ws, quic://domain.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"link\",\n\t\t\t\t\tUsage: \"brook link. This will ignore server, password, udpovertcp, address, insecure, withoutBrookProtocol, ca\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"webListen\") != \"\" {\n\t\t\t\t\tweb, err := fs.Sub(static, \"static\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tvar cmd *exec.Cmd\n\t\t\t\t\tlock := &sync.Mutex{}\n\t\t\t\t\tm := http.NewServeMux()\n\t\t\t\t\tm.Handle(\"/\", http.FileServer(http.FS(web)))\n\t\t\t\t\tm.HandleFunc(\"/start\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\ts, err := os.Executable()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tcmd = exec.Command(\"/bin/sh\", \"-c\", s+\" tproxy \"+r.FormValue(\"args\"))\n\t\t\t\t\t\tlog.Println(s + \" tproxy \" + r.FormValue(\"args\"))\n\t\t\t\t\t\tdone := make(chan byte)\n\t\t\t\t\t\tdefer close(done)\n\t\t\t\t\t\terrch := make(chan error)\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tout, _ := cmd.CombinedOutput()\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase <-done:\n\t\t\t\t\t\t\t\tlog.Println(string(out))\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\t\tcase <-done:\n\t\t\t\t\t\t\t\t\tlog.Println(string(out))\n\t\t\t\t\t\t\t\tcase errch <- errors.New(string(out)):\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\t\tcmd = nil\n\t\t\t\t\t\t\tlock.Unlock()\n\t\t\t\t\t\t}()\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase err := <-errch:\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tcase <-time.After(6 * time.Second):\n\t\t\t\t\t\t\tw.Write([]byte(\"connected\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/stop\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tif cmd == nil {\n\t\t\t\t\t\t\tw.Write([]byte(\"disconnected\"))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := cmd.Process.Signal(syscall.SIGTERM); err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Write([]byte(\"disconnected\"))\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/status\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tif cmd == nil {\n\t\t\t\t\t\t\tw.Write([]byte(\"disconnected\"))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Write([]byte(\"connected\"))\n\t\t\t\t\t})\n\t\t\t\t\ts := &http.Server{\n\t\t\t\t\t\tAddr:    c.String(\"webListen\"),\n\t\t\t\t\t\tHandler: m,\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\tif cmd != nil {\n\t\t\t\t\t\t\t\tcmd.Process.Signal(syscall.SIGTERM)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn s.Shutdown(context.Background())\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif c.String(\"listen\") == \"\" || (c.String(\"link\") == \"\" && (c.String(\"server\") == \"\" || c.String(\"password\") == \"\")) {\n\t\t\t\t\t_ = cli.ShowSubcommandHelp(c)\n\t\t\t\t\treturn errors.New(\"\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassDomainList\") != \"\" && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--bypassDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"bypassCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--bypassCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"bypassCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--bypassCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"bypassDomainList\") != \"\" || c.Bool(\"disableA\") || c.Bool(\"disableAAAA\") {\n\t\t\t\t\tp, err := thedns.NewTheDNS(c.String(\"blockDomainList\"), c.String(\"bypassDomainList\"), c.String(\"dnsForBypass\"), c.Bool(\"disableA\"), c.Bool(\"disableAAAA\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassCIDR4List\") != \"\" || c.String(\"bypassCIDR6List\") != \"\" || len(c.StringSlice(\"bypassGeoIP\")) != 0 {\n\t\t\t\t\tp, err := tproxy.NewTproxy(c.String(\"bypassCIDR4List\"), c.String(\"bypassCIDR6List\"), c.StringSlice(\"bypassGeoIP\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tkind := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\tkind = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\tkind = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\tkind = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\tlink := brook.LinkExtra(kind, c.String(\"server\"), \"\", c.String(\"password\"), v)\n\t\t\t\tif c.String(\"link\") != \"\" {\n\t\t\t\t\tlink = c.String(\"link\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewTproxy(c.String(\"listen\"), link, c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\tif !c.Bool(\"doNotRunScripts\") {\n\t\t\t\t\t\t\ts.ClearAutoScripts()\n\t\t\t\t\t\t\tif err := s.RunAutoScripts(); err != nil {\n\t\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\tif !c.Bool(\"doNotRunScripts\") {\n\t\t\t\t\t\t\tif err := s.ClearAutoScripts(); err != nil {\n\t\t\t\t\t\t\t\tlog.Println(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"dnsListen\") != \"\" {\n\t\t\t\t\ts, err := brook.NewRelayOverBrook(c.String(\"dnsListen\"), link, c.String(\"dnsForDefault\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.IsDNS = true\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"link\",\n\t\t\tUsage: \"Generate brook link\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Support brook server, brook wsserver, brook wssserver, socks5 server, brook quicserver. Like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://google.com:443/ws, socks5://1.2.3.4:1080, quic://google.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"username\",\n\t\t\t\t\tAliases: []string{\"u\"},\n\t\t\t\t\tUsage:   \"Username, when server is socks5 server\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"name\",\n\t\t\t\t\tUsage: \"Give this server a name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca for untrusted cert, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"server\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\ts = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\ts = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"socks5://\") {\n\t\t\t\t\ts = \"socks5\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\ts = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.String(\"name\") != \"\" {\n\t\t\t\t\tv.Set(\"name\", c.String(\"name\"))\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\tfmt.Println(brook.LinkExtra(s, c.String(\"server\"), c.String(\"username\"), c.String(\"password\"), v))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"connect\",\n\t\t\tUsage: \"Run as client and connect to brook link, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook connect <-> $ brook server/wsserver/wssserver/quicserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"link\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"brook link, you can get it via $ brook link\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"If you already have a socks5, such as 127.0.0.1:1081, and want [src <-> listen socks5 <-> $ brook connect <-> dialWithSocks5 <-> $ brook server/wsserver/wssserver <-> dst]\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"link\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\th = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\tif h == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tkind, _, _, _, _, err := brook.ParseLinkExtra(c.String(\"link\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif kind == \"socks5\" {\n\t\t\t\t\treturn errors.New(\"Looks like you want create socks5 from a socks5, you may want $ brook socks5tohttp?\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewBrookLink(c.String(\"link\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\terr = s.PrepareSocks5Server(c.String(\"socks5\"), h, c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(h, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"relay\",\n\t\t\tUsage: \"Run as standalone relay, both TCP and UDP, this means access [from address] is equal to access [to address], [src <-> from address <-> to address]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"from\",\n\t\t\t\t\tAliases: []string{\"f\", \"l\"},\n\t\t\t\t\tUsage:   \"Listen address: like ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"to\",\n\t\t\t\t\tAliases: []string{\"t\"},\n\t\t\t\t\tUsage:   \"Address which relay to, like: 1.2.3.4:9999\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"from\") == \"\" || c.String(\"to\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelay(c.String(\"from\"), c.String(\"to\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"dnsserver\",\n\t\t\tUsage: \"Run as standalone dns server, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: 127.0.0.1:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tUsage: \"DNS server which forward to\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableA\",\n\t\t\t\t\tUsage: \"Disable A query\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableAAAA\",\n\t\t\t\t\tUsage: \"Disable AAAA query\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.Bool(\"disableA\") || c.Bool(\"disableAAAA\") {\n\t\t\t\t\tp, err := thedns.NewTheDNS(c.String(\"blockDomainList\"), \"\", \"\", c.Bool(\"disableA\"), c.Bool(\"disableAAAA\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelay(c.String(\"listen\"), c.String(\"dns\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.IsDNS = true\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"socks5\",\n\t\t\tUsage: \"Run as standalone standard socks5 server, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Socks5 server listen address, like: :1080 or 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"username\",\n\t\t\t\t\tUsage: \"User name, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"password\",\n\t\t\t\t\tUsage: \"Password, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"limitUDP\",\n\t\t\t\t\tUsage: \"The server MAY use this information to limit access to the UDP association\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"Connection deadline time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"Connection deadline time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, _, err := net.SplitHostPort(c.String(\"listen\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use public IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewSocks5Server(c.String(\"listen\"), ip, c.String(\"username\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.Server.LimitUDP = c.Bool(\"limitUDP\")\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"socks5tohttp\",\n\t\t\tUsage: \"Convert socks5 to http proxy, [src <-> listen address(http proxy) <-> socks5 address <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"socks5\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Socks5 server address, like: 127.0.0.1:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5username\",\n\t\t\t\t\tUsage: \"Socks5 username, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5password\",\n\t\t\t\t\tUsage: \"Socks5 password, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"HTTP proxy which will be create: like: 127.0.0.1:8010\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"Connection tcp timeout (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"socks5\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewSocks5ToHTTP(c.String(\"listen\"), c.String(\"socks5\"), c.String(\"socks5username\"), c.String(\"socks5password\"), c.Int(\"tcpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"pac\",\n\t\t\tUsage: \"Run as PAC server or save PAC to file\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: 127.0.0.1:1980\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"proxy\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tValue:   \"SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT\",\n\t\t\t\t\tUsage:   \"Proxy, like: 'SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"bypassDomainList\",\n\t\t\t\t\tAliases: []string{\"b\"},\n\t\t\t\t\tUsage:   \"One domain per line, suffix match mode. http(s):// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Save PAC to file, this will ignore listen address\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" && c.String(\"file\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassDomainList\") != \"\" && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--bypassDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\ts := brook.NewPAC(c.String(\"listen\"), c.String(\"file\"), c.String(\"proxy\"), c.String(\"bypassDomainList\"))\n\t\t\t\tif c.String(\"file\") != \"\" {\n\t\t\t\t\treturn s.WriteToFile()\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"testsocks5\",\n\t\t\tUsage: \"Test UDP and TCP of socks5 server\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"socks5\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Like: 127.0.0.1:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"username\",\n\t\t\t\t\tAliases: []string{\"u\"},\n\t\t\t\t\tUsage:   \"Socks5 username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Socks5 password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t\tUsage: \"DNS server for connecting\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domain\",\n\t\t\t\t\tValue: \"http3.ooo\",\n\t\t\t\t\tUsage: \"Domain for query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"a\",\n\t\t\t\t\tValue: \"137.184.237.95\",\n\t\t\t\t\tUsage: \"The A record of domain\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tsocks5.Debug = true\n\t\t\t\treturn brook.Socks5Test(c.String(\"socks5\"), c.String(\"username\"), c.String(\"password\"), c.String(\"domain\"), c.String(\"a\"), c.String(\"dns\"))\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"testbrook\",\n\t\t\tUsage: \"Test UDP and TCP of brook server/wsserver/wssserver\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"link\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"brook link. Get it via $ brook link\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:11080\",\n\t\t\t\t\tUsage: \"Temporarily listening socks5\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t\tUsage: \"DNS server for connecting\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domain\",\n\t\t\t\t\tValue: \"http3.ooo\",\n\t\t\t\t\tUsage: \"Domain for query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"a\",\n\t\t\t\t\tValue: \"137.184.237.95\",\n\t\t\t\t\tUsage: \"The A record of domain\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"link\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tsocks5.Debug = true\n\t\t\t\tfmt.Println(\"Run brook connect to listen\", c.String(\"socks5\"))\n\t\t\t\tvar cmd *exec.Cmd\n\t\t\t\tvar err error\n\t\t\t\tgo func() {\n\t\t\t\t\tvar s string\n\t\t\t\t\ts, err = os.Executable()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcmd = exec.Command(s, \"connect\", \"--link\", c.String(\"link\"), \"--socks5\", c.String(\"socks5\"))\n\t\t\t\t\tb, _ := cmd.CombinedOutput()\n\t\t\t\t\terr = errors.New(string(b))\n\t\t\t\t}()\n\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\terr1 := brook.Socks5Test(c.String(\"socks5\"), \"\", \"\", c.String(\"domain\"), c.String(\"a\"), c.String(\"dns\"))\n\t\t\t\t_ = cmd.Process.Signal(syscall.SIGTERM)\n\t\t\t\treturn err1\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"echoserver\",\n\t\t\tUsage: \"Echo server, echo UDP and TCP address of routes\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: ':7777'\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewEchoServer(c.String(\"listen\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"echoclient\",\n\t\t\tUsage: \"Connect to echoserver, echo UDP and TCP address of routes\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Echo server address, such as 1.2.3.4:7777\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"times\",\n\t\t\t\t\tValue: 1,\n\t\t\t\t\tUsage: \"Times of interactions\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"server\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\treturn brook.EchoClient(c.String(\"server\"), c.Int(\"times\"))\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"completion\",\n\t\t\tUsage: \"Generate shell completions\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Write to file\",\n\t\t\t\t\tValue:   \"brook_autocomplete\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tl := c.App.VisibleCommands()\n\t\t\t\tif strings.Contains(os.Getenv(\"SHELL\"), \"zsh\") {\n\t\t\t\t\ts := `\n_cli_zsh_autocomplete() {\n  local -a opts\n  local cur\n  cur=${words[-1]}\n  if [[ \"$cur\" == \"-\"* ]]; then\n    opts=(\"${(@f)$(${words[@]:0:#words[@]-1} ${cur} --generate-bash-completion)}\")\n  else\n    opts=(\"${(@f)$(${words[@]:0:#words[@]-1} --generate-bash-completion)}\")\n  fi\n\n  if [[ \"${opts[1]}\" != \"\" ]]; then\n    _describe 'values' opts\n  else\n    _files\n  fi\n}\ncompdef _cli_zsh_autocomplete brook\n`\n\t\t\t\t\tfor _, v := range l {\n\t\t\t\t\t\ts += \"compdef _cli_zsh_autocomplete brook \" + v.Name + \"\\n\"\n\t\t\t\t\t}\n\t\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Println(\"Generated\")\n\t\t\t\t\tfmt.Println(\"\\t\" + c.String(\"file\"))\n\t\t\t\t\tfmt.Println(\"To enable auto-completion for the current shell session\")\n\t\t\t\t\tfmt.Println(\"\\t$ source \" + c.String(\"file\"))\n\t\t\t\t\tfmt.Println(\"To enable persistent auto-completion, add this line to your .zsh\")\n\t\t\t\t\tfmt.Println(\"\\t$ source /path/to/\" + c.String(\"file\"))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\ts := `#! /bin/bash\n_cli_bash_autocomplete() {\n  if [[ \"${COMP_WORDS[0]}\" != \"source\" ]]; then\n    local cur opts base\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    if [[ \"$cur\" == \"-\"* ]]; then\n      opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} ${cur} --generate-bash-completion )\n    else\n      opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )\n    fi\n    COMPREPLY=( $(compgen -W \"${opts}\" -- ${cur}) )\n    return 0\n  fi\n}\ncomplete -o bashdefault -o default -o nospace -F _cli_bash_autocomplete brook\n`\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\ts += \"complete -o bashdefault -o default -o nospace -F _cli_bash_autocomplete brook \" + v.Name + \"\\n\"\n\t\t\t\t}\n\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Generated:\")\n\t\t\t\tfmt.Println(\"\\t\" + c.String(\"file\"))\n\t\t\t\tfmt.Println(\"To enable auto-completion for the current shell session\")\n\t\t\t\tfmt.Println(\"\\t$ source \" + c.String(\"file\"))\n\t\t\t\tif runtime.GOOS == \"darwin\" {\n\t\t\t\t\tfmt.Println(\"To enable persistent auto-completion, add this line to your .bash_profile\")\n\t\t\t\t}\n\t\t\t\tif runtime.GOOS != \"darwin\" {\n\t\t\t\t\tfmt.Println(\"To enable persistent auto-completion, add this line to your .bashrc\")\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"\\t$ source /path/to/\" + c.String(\"file\"))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"mdpage\",\n\t\t\tUsage: \"Generate markdown page\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Write to file, default print to stdout\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\ts, err := c.App.ToMarkdown()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"file\") != \"\" {\n\t\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tfmt.Println(s)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"manpage\",\n\t\t\tUsage: \"Generate man.1 page\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Write to file, default print to stdout. You should put to /path/to/man/man1/brook.1 on linux or /usr/local/share/man/man1/brook.1 on macos\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\ts, err := c.App.ToManWithSection(1)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"file\") != \"\" {\n\t\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tfmt.Println(s)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}\n\tif os.Getenv(\"SOCKS5_DEBUG\") != \"\" {\n\t\tsocks5.Debug = true\n\t}\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tif len(g.Runners) == 0 {\n\t\treturn\n\t}\n\tgo func() {\n\t\tsigs := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t\t<-sigs\n\t\tg.Done()\n\t}()\n\tlog.Println(g.Wait())\n}\n", "<!DOCTYPE html>\n<html>\n    <head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" />\n        <title>Brook</title>\n        <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-96ENZWNBX1\"></script>\n        <script>\n            window.dataLayer = window.dataLayer || [];\n            function gtag() {\n                dataLayer.push(arguments);\n            }\n            gtag(\"js\", new Date());\n\n            gtag(\"config\", \"G-96ENZWNBX1\");\n        </script>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <link rel=\"stylesheet\" href=\"simple.min.css\" />\n        <script src=\"vue.global.prod.js\"></script>\n        <style>\n            input {\n                width: 100%;\n            }\n        </style>\n        <script>\n            window.addEventListener(\"DOMContentLoaded\", async (e) => {\n                var app = {\n                    data() {\n                        return {\n                            link: localStorage.getItem(\"link\") ?? \"\",\n                            listen: localStorage.getItem(\"listen\") ?? \":1080\",\n                            dnsListen: localStorage.getItem(\"dnsListen\") ?? \":5353\",\n                            dnsForDefault: localStorage.getItem(\"dnsForDefault\") ?? \"8.8.8.8:53\",\n                            dnsForBypass: localStorage.getItem(\"dnsForBypass\") ?? \"223.5.5.5:53\",\n                            bypassDomainList: localStorage.getItem(\"bypassDomainList\") ?? \"\",\n                            bypassCIDR4List: localStorage.getItem(\"bypassCIDR4List\") ?? \"\",\n                            bypassCIDR6List: localStorage.getItem(\"bypassCIDR6List\") ?? \"\",\n                            blockDomainList: localStorage.getItem(\"blockDomainList\") ?? \"\",\n                            enableIPv6: localStorage.getItem(\"enableIPv6\") ? true : false,\n                            status: \"disconnected\",\n                            ing: false,\n                        };\n                    },\n                    async created() {\n                        try {\n                            var r = await fetch(\"/status\");\n                            if (r.status != 200) {\n                                throw await r.text();\n                            }\n                            this.status = await r.text();\n                        } catch (e) {\n                            alert(`${e}`);\n                        }\n                    },\n                    methods: {\n                        async start() {\n                            try {\n                                this.ing = true;\n                                var s = \"\";\n                                if (this.link) {\n                                    s += ` --link '${this.link}'`;\n                                    localStorage.setItem(\"link\", this.link);\n                                } else {\n                                    localStorage.setItem(\"link\", \"\");\n                                }\n                                if (this.listen) {\n                                    s += ` --listen '${this.listen}'`;\n                                    localStorage.setItem(\"listen\", this.listen);\n                                } else {\n                                    localStorage.setItem(\"listen\", \"\");\n                                }\n                                if (this.dnsListen) {\n                                    s += ` --dnsListen '${this.dnsListen}'`;\n                                    localStorage.setItem(\"dnsListen\", this.dnsListen);\n                                } else {\n                                    localStorage.setItem(\"dnsListen\", \"\");\n                                }\n                                if (this.dnsForDefault) {\n                                    s += ` --dnsForDefault '${this.dnsForDefault}'`;\n                                    localStorage.setItem(\"dnsForDefault\", this.dnsForDefault);\n                                } else {\n                                    localStorage.setItem(\"dnsForDefault\", \"\");\n                                }\n                                if (this.dnsForBypass) {\n                                    s += ` --dnsForBypass '${this.dnsForBypass}'`;\n                                    localStorage.setItem(\"dnsForBypass\", this.dnsForBypass);\n                                } else {\n                                    localStorage.setItem(\"dnsForBypass\", \"\");\n                                }\n                                if (this.bypassDomainList) {\n                                    s += ` --bypassDomainList '${this.bypassDomainList}'`;\n                                    localStorage.setItem(\"bypassDomainList\", this.bypassDomainList);\n                                } else {\n                                    localStorage.setItem(\"bypassDomainList\", \"\");\n                                }\n                                if (this.bypassCIDR4List) {\n                                    s += ` --bypassCIDR4List '${this.bypassCIDR4List}'`;\n                                    localStorage.setItem(\"bypassCIDR4List\", this.bypassCIDR4List);\n                                } else {\n                                    localStorage.setItem(\"bypassCIDR4List\", \"\");\n                                }\n                                if (this.bypassCIDR6List) {\n                                    s += ` --bypassCIDR6List '${this.bypassCIDR6List}'`;\n                                    localStorage.setItem(\"bypassCIDR6List\", this.bypassCIDR6List);\n                                } else {\n                                    localStorage.setItem(\"bypassCIDR6List\", \"\");\n                                }\n                                if (this.blockDomainList) {\n                                    s += ` --blockDomainList '${this.blockDomainList}'`;\n                                    localStorage.setItem(\"blockDomainList\", this.blockDomainList);\n                                } else {\n                                    localStorage.setItem(\"blockDomainList\", \"\");\n                                }\n                                if (this.enableIPv6) {\n                                    s += ` --enableIPv6`;\n                                    localStorage.setItem(\"enableIPv6\", \"true\");\n                                } else {\n                                    localStorage.setItem(\"enableIPv6\", \"\");\n                                }\n                                var r = await fetch(`/start?args=${encodeURIComponent(s)}`);\n                                if (r.status != 200) {\n                                    throw await r.text();\n                                }\n                                this.status = await r.text();\n                                this.ing = false;\n                            } catch (e) {\n                                alert(`${e}`);\n                                this.ing = false;\n                            }\n                        },\n                        async stop() {\n                            try {\n                                this.ing = true;\n                                var r = await fetch(`/stop`);\n                                if (r.status != 200) {\n                                    throw await r.text();\n                                }\n                                this.status = await r.text();\n                                this.ing = false;\n                            } catch (e) {\n                                alert(`${e}`);\n                                this.ing = false;\n                            }\n                        },\n                    },\n                };\n                Vue.createApp(app).mount(\"body\");\n            });\n        </script>\n    </head>\n    <body>\n        <header>\n            <h1>Brook</h1>\n            <p>brook tproxy</p>\n        </header>\n        <main>\n            <p>\n                <label>--link brook link</label><br />\n                <input v-model=\"link\" placeholder=\"brook://...\" />\n            </p>\n            <p>\n                <label>--listen Listen address, DO NOT contain IP</label><br />\n                <input v-model=\"listen\" placeholder=\":1080\" />\n            </p>\n            <p>\n                <label>--dnsListen Start a smart DNS server</label><br />\n                <input v-model=\"dnsListen\" placeholder=\":5353\" />\n            </p>\n            <p>\n                <label>--dnsForDefault DNS server for resolving domains not in bypass list</label><br />\n                <input v-model=\"dnsForDefault\" placeholder=\"8.8.8.8:53\" />\n            </p>\n            <p>\n                <label>--dnsForBypass DNS server for resolving domains in bypass list</label><br />\n                <input v-model=\"dnsForBypass\" placeholder=\"223.5.5.5:53\" />\n            </p>\n            <p>\n                <label>--bypassDomainList Suffix match mode</label><br />\n                <input v-model=\"bypassDomainList\" placeholder=\"/path/to/local/file/example_domain.txt\" />\n            </p>\n            <p>\n                <label>--bypassCIDR4List</label><br />\n                <input v-model=\"bypassCIDR4List\" placeholder=\"/path/to/local/file/example_cidr4.txt\" />\n            </p>\n            <p>\n                <label>--bypassCIDR6List</label><br />\n                <input v-model=\"bypassCIDR6List\" placeholder=\"/path/to/local/file/example_cidr6.txt\" />\n            </p>\n            <p>\n                <label>--blockDomainList Suffix match mode</label><br />\n                <input v-model=\"blockDomainList\" placeholder=\"/path/to/local/file/example_domain.txt\" />\n            </p>\n            <p>\n                <label>--enableIPv6 Your local and server must support IPv6</label><br />\n                <input type=\"checkbox\" v-model=\"enableIPv6\" />\n            </p>\n            <p v-if=\"ing\"><button disabled>Waiting...</button></p>\n            <p v-if=\"!ing && status == 'disconnected'\"><button v-on:click=\"start\">Connect</button></p>\n            <p v-if=\"!ing && status =='connected'\"><button v-on:click=\"stop\">Disconnect</button></p>\n        </main>\n        <footer>\n            <p><a href=\"https://txthinking.com\">txthinking.com</a> | <a href=\"https://github.com/txthinking\">github.com/txthinking</a> | <a href=\"https://talks.txthinking.com\">blog</a> | <a href=\"https://youtube.com/txthinking\">youtube</a> | <a href=\"https://t.me/brookgroup\">telegram</a> | <a href=\"https://t.me/txthinking_news\">news</a></p>\n        </footer>\n    </body>\n</html>\n", "// Copyright (c) 2016-present Cloud <cloud@txthinking.com>\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of version 3 of the GNU General Public\n// License as published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n// General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npackage brook\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go\"\n\t\"github.com/txthinking/brook/limits\"\n\tcrypto1 \"github.com/txthinking/crypto\"\n\t\"github.com/txthinking/runnergroup\"\n\t\"github.com/txthinking/socks5\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\ntype QUICServer struct {\n\tPassword             []byte\n\tDomain               string\n\tAddr                 string\n\tTCPTimeout           int\n\tUDPTimeout           int\n\tCert                 []byte\n\tCertKey              []byte\n\tRunnerGroup          *runnergroup.RunnerGroup\n\tWithoutBrook         bool\n\tUDPServerConnFactory UDPServerConnFactory\n}\n\nfunc NewQUICServer(addr, password, domain string, tcpTimeout, udpTimeout int, blockDomainList, blockCIDR4List, blockCIDR6List string, updateListInterval int64, blockGeoIP []string, withoutbrook bool) (*QUICServer, error) {\n\tif err := limits.Raise(); err != nil {\n\t\tLog(&Error{\"when\": \"try to raise system limits\", \"warning\": err.Error()})\n\t}\n\tif runtime.GOOS == \"linux\" {\n\t\tc := exec.Command(\"sysctl\", \"-w\", \"net.core.rmem_max=2500000\")\n\t\tb, err := c.CombinedOutput()\n\t\tif err != nil {\n\t\t\tLog(&Error{\"when\": \"try to raise UDP Receive Buffer Size\", \"warning\": string(b)})\n\t\t}\n\t}\n\tif runtime.GOOS == \"darwin\" {\n\t\tc := exec.Command(\"sysctl\", \"-w\", \"kern.ipc.maxsockbuf=3014656\")\n\t\tb, err := c.CombinedOutput()\n\t\tif err != nil {\n\t\t\tLog(&Error{\"when\": \"try to raise UDP Receive Buffer Size\", \"warning\": string(b)})\n\t\t}\n\t}\n\tvar p []byte\n\tvar f UDPServerConnFactory\n\tif !withoutbrook {\n\t\tp = []byte(password)\n\t\tf = NewPacketServerConnFactory()\n\t}\n\tif withoutbrook {\n\t\tvar err error\n\t\tp, err = crypto1.SHA256Bytes([]byte(password))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tf = NewSimplePacketServerConnFactory()\n\t}\n\ts := &QUICServer{\n\t\tPassword:             p,\n\t\tDomain:               domain,\n\t\tAddr:                 addr,\n\t\tTCPTimeout:           tcpTimeout,\n\t\tUDPTimeout:           udpTimeout,\n\t\tUDPServerConnFactory: f,\n\t\tRunnerGroup:          runnergroup.New(),\n\t\tWithoutBrook:         withoutbrook,\n\t}\n\treturn s, nil\n}\n\nfunc (s *QUICServer) ListenAndServe() error {\n\tvar t *tls.Config\n\tif s.Cert == nil || s.CertKey == nil {\n\t\tm := autocert.Manager{\n\t\t\tCache:      autocert.DirCache(\".letsencrypt\"),\n\t\t\tPrompt:     autocert.AcceptTOS,\n\t\t\tHostPolicy: autocert.HostWhitelist(s.Domain),\n\t\t\tEmail:      \"cloud@txthinking.com\",\n\t\t}\n\t\tserver := &http.Server{Addr: \":80\", Handler: m.HTTPHandler(nil)}\n\t\ts.RunnerGroup.Add(&runnergroup.Runner{\n\t\t\tStart: func() error {\n\t\t\t\treturn server.ListenAndServe()\n\t\t\t},\n\t\t\tStop: func() error {\n\t\t\t\treturn server.Shutdown(context.Background())\n\t\t\t},\n\t\t})\n\t\tt = &tls.Config{GetCertificate: m.GetCertificate, ServerName: s.Domain, NextProtos: []string{\"h3\"}}\n\t}\n\tif s.Cert != nil && s.CertKey != nil {\n\t\tct, err := tls.X509KeyPair(s.Cert, s.CertKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt = &tls.Config{Certificates: []tls.Certificate{ct}, ServerName: s.Domain, NextProtos: []string{\"h3\"}}\n\t}\n\tl, err := quic.ListenAddr(s.Addr, t, &quic.Config{MaxIdleTimeout: time.Duration(s.UDPTimeout) * time.Second, EnableDatagrams: true})\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RunnerGroup.Add(&runnergroup.Runner{\n\t\tStart: func() error {\n\t\t\tfor {\n\t\t\t\tc, err := l.Accept(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tgo func(c quic.Connection) {\n\t\t\t\t\tdefer c.CloseWithError(0, \"defer\")\n\t\t\t\t\tfor {\n\t\t\t\t\t\tst, err := c.AcceptStream(context.Background())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgo func(c net.Conn) {\n\t\t\t\t\t\t\tdefer c.Close()\n\t\t\t\t\t\t\tvar ss Exchanger\n\t\t\t\t\t\t\tif !s.WithoutBrook {\n\t\t\t\t\t\t\t\tss, err = NewStreamServer(s.Password, c.RemoteAddr().String(), c, s.TCPTimeout, s.UDPTimeout)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif s.WithoutBrook {\n\t\t\t\t\t\t\t\tss, err = NewSimpleStreamServer(s.Password, c.RemoteAddr().String(), c, s.TCPTimeout, s.UDPTimeout)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"error\": err.Error()})\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefer ss.Clean()\n\t\t\t\t\t\t\tif err := s.TCPHandle(ss); err != nil {\n\t\t\t\t\t\t\t\tLog(&Error{\"from\": ss.Src(), \"dst\": ss.Dst(), \"error\": err.Error()})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}(&QUICConn{\n\t\t\t\t\t\t\tConn:   c,\n\t\t\t\t\t\t\tStream: st,\n\t\t\t\t\t\t\tLAddr: &net.TCPAddr{\n\t\t\t\t\t\t\t\tIP:   c.LocalAddr().(*net.UDPAddr).IP,\n\t\t\t\t\t\t\t\tPort: c.LocalAddr().(*net.UDPAddr).Port,\n\t\t\t\t\t\t\t\tZone: c.LocalAddr().(*net.UDPAddr).Zone,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRAddr: &net.TCPAddr{\n\t\t\t\t\t\t\t\tIP:   c.RemoteAddr().(*net.UDPAddr).IP,\n\t\t\t\t\t\t\t\tPort: c.RemoteAddr().(*net.UDPAddr).Port,\n\t\t\t\t\t\t\t\tZone: c.RemoteAddr().(*net.UDPAddr).Zone,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}(c)\n\t\t\t\tif c.ConnectionState().SupportsDatagrams {\n\t\t\t\t\tgo func(c quic.Connection) {\n\t\t\t\t\t\tdefer c.CloseWithError(0, \"defer\")\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tb, err := c.ReceiveMessage()\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconn, dstb, err := s.UDPServerConnFactory.Handle(c.RemoteAddr().(*net.UDPAddr), b, s.Password, func(b []byte) (int, error) {\n\t\t\t\t\t\t\t\tif len(b) > 1197 {\n\t\t\t\t\t\t\t\t\terr := errors.New(\"when write to client, quic max datagram size is 1197\")\n\t\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"error\": err.Error()})\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif err := c.SendMessage(b); err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn len(b), nil\n\t\t\t\t\t\t\t}, s.UDPTimeout)\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"error\": err.Error()})\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif conn == nil {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\t\tdefer conn.Close()\n\t\t\t\t\t\t\t\tvar ss Exchanger\n\t\t\t\t\t\t\t\tif !s.WithoutBrook {\n\t\t\t\t\t\t\t\t\tss, err = NewPacketServer(s.Password, c.RemoteAddr().String(), conn, s.UDPTimeout, dstb)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif s.WithoutBrook {\n\t\t\t\t\t\t\t\t\tss, err = NewSimplePacketServer(s.Password, c.RemoteAddr().String(), conn, s.UDPTimeout, dstb)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"dst\": socks5.ToAddress(dstb[0], dstb[1:len(dstb)-2], dstb[len(dstb)-2:]), \"error\": err.Error()})\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefer ss.Clean()\n\t\t\t\t\t\t\t\tif err := s.UDPHandle(ss); err != nil {\n\t\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"dst\": socks5.ToAddress(dstb[0], dstb[1:len(dstb)-2], dstb[len(dstb)-2:]), \"error\": err.Error()})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}()\n\t\t\t\t\t\t}\n\t\t\t\t\t}(c)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tStop: func() error {\n\t\t\treturn l.Close()\n\t\t},\n\t})\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, _ = quic.DialAddr(net.JoinHostPort(s.Domain, s.Addr[1:]), &tls.Config{NextProtos: []string{\"h3\"}}, nil)\n\t}()\n\treturn s.RunnerGroup.Wait()\n}\n\nfunc (s *QUICServer) TCPHandle(ss Exchanger) error {\n\trc, err := DialTCP(\"tcp\", \"\", ss.Dst())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rc.Close()\n\tif err := ss.Exchange(rc); err != nil {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (s *QUICServer) UDPHandle(ss Exchanger) error {\n\trc, err := NATDial(\"udp\", ss.Src(), ss.Dst(), ss.Dst())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rc.Close()\n\tif err := ss.Exchange(rc); err != nil {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (s *QUICServer) Shutdown() error {\n\treturn s.RunnerGroup.Done()\n}\n", "// Copyright (c) 2016-present Cloud <cloud@txthinking.com>\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of version 3 of the GNU General Public\n// License as published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n// General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npackage brook\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/txthinking/socks5\"\n\t\"github.com/txthinking/x\"\n\t\"golang.org/x/crypto/hkdf\"\n)\n\ntype StreamClient struct {\n\tServer  net.Conn\n\tcn      []byte\n\tca      cipher.AEAD\n\tsn      []byte\n\tsa      cipher.AEAD\n\tRB      []byte\n\tWB      []byte\n\tTimeout int\n\tnetwork string\n\tsrc     string\n\tdst     string\n}\n\nfunc NewStreamClient(network string, password []byte, src string, server net.Conn, timeout int, dst []byte) (Exchanger, error) {\n\tif timeout != 0 {\n\t\tif err := server.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif len(dst) > 2048-2-16-4-16 {\n\t\treturn nil, errors.New(\"dst too long\")\n\t}\n\tc := &StreamClient{network: network, Server: server, Timeout: timeout, src: src, dst: socks5.ToAddress(dst[0], dst[1:len(dst)-2], dst[len(dst)-2:])}\n\n\tc.cn = x.BP12.Get().([]byte)\n\tif _, err := io.ReadFull(rand.Reader, c.cn); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\treturn nil, err\n\t}\n\tck := x.BP32.Get().([]byte)\n\tif _, err := io.ReadFull(hkdf.New(sha256.New, password, c.cn, []byte{0x62, 0x72, 0x6f, 0x6f, 0x6b}), ck); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP32.Put(ck)\n\t\treturn nil, err\n\t}\n\tif _, err := c.Server.Write(c.cn); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP32.Put(ck)\n\t\treturn nil, err\n\t}\n\tcb, err := aes.NewCipher(ck)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP32.Put(ck)\n\t\treturn nil, err\n\t}\n\tx.BP32.Put(ck)\n\tc.ca, err = cipher.NewGCM(cb)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\treturn nil, err\n\t}\n\n\tc.WB = x.BP2048.Get().([]byte)\n\ti := time.Now().Unix()\n\tif c.network == \"tcp\" && i%2 != 0 {\n\t\ti += 1\n\t}\n\tif c.network == \"udp\" && i%2 != 1 {\n\t\ti += 1\n\t}\n\tbinary.BigEndian.PutUint32(c.WB[2+16:2+16+4], uint32(i))\n\tcopy(c.WB[2+16+4:2+16+4+len(dst)], dst)\n\tif err := c.WriteL(4 + len(dst)); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\treturn nil, err\n\t}\n\n\tc.sn = x.BP12.Get().([]byte)\n\tif _, err := io.ReadFull(c.Server, c.sn); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\treturn nil, err\n\t}\n\tsk := x.BP32.Get().([]byte)\n\tif _, err := io.ReadFull(hkdf.New(sha256.New, password, c.sn, []byte{0x62, 0x72, 0x6f, 0x6f, 0x6b}), sk); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\tx.BP32.Put(sk)\n\t\treturn nil, err\n\t}\n\tsb, err := aes.NewCipher(sk)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\tx.BP32.Put(sk)\n\t\treturn nil, err\n\t}\n\tx.BP32.Put(sk)\n\tc.sa, err = cipher.NewGCM(sb)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\treturn nil, err\n\t}\n\tif c.network == \"tcp\" {\n\t\tc.RB = x.BP2048.Get().([]byte)\n\t}\n\tif c.network == \"udp\" {\n\t\tx.BP2048.Put(c.WB)\n\t\tc.WB = x.BP65507.Get().([]byte)\n\t\tc.RB = x.BP65507.Get().([]byte)\n\t}\n\treturn ClientGate(c)\n}\n\nfunc (c *StreamClient) Exchange(local net.Conn) error {\n\tgo func() {\n\t\tfor {\n\t\t\tif c.Timeout != 0 {\n\t\t\t\tif err := c.Server.SetDeadline(time.Now().Add(time.Duration(c.Timeout) * time.Second)); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tl, err := c.ReadL()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif _, err := local.Write(c.RB[2+16 : 2+16+l]); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tfor {\n\t\tif c.Timeout != 0 {\n\t\t\tif err := local.SetDeadline(time.Now().Add(time.Duration(c.Timeout) * time.Second)); err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tl, err := local.Read(c.WB[2+16 : len(c.WB)-16])\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tif err := c.WriteL(l); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *StreamClient) WriteL(l int) error {\n\tbinary.BigEndian.PutUint16(c.WB[:2], uint16(l))\n\tc.ca.Seal(c.WB[:0], c.cn, c.WB[:2], nil)\n\tNextNonce(c.cn)\n\tc.ca.Seal(c.WB[:2+16], c.cn, c.WB[2+16:2+16+l], nil)\n\tif _, err := c.Server.Write(c.WB[:2+16+l+16]); err != nil {\n\t\treturn err\n\t}\n\tNextNonce(c.cn)\n\treturn nil\n}\n\nfunc (c *StreamClient) ReadL() (int, error) {\n\tif _, err := io.ReadFull(c.Server, c.RB[:2+16]); err != nil {\n\t\treturn 0, err\n\t}\n\tif _, err := c.sa.Open(c.RB[:0], c.sn, c.RB[:2+16], nil); err != nil {\n\t\treturn 0, err\n\t}\n\tl := int(binary.BigEndian.Uint16(c.RB[:2]))\n\tif _, err := io.ReadFull(c.Server, c.RB[2+16:2+16+l+16]); err != nil {\n\t\treturn 0, err\n\t}\n\tNextNonce(c.sn)\n\tif _, err := c.sa.Open(c.RB[:2+16], c.sn, c.RB[2+16:2+16+l+16], nil); err != nil {\n\t\treturn 0, err\n\t}\n\tNextNonce(c.sn)\n\treturn l, nil\n}\n\nfunc (c *StreamClient) Clean() {\n\tx.BP12.Put(c.cn)\n\tx.BP12.Put(c.sn)\n\tif c.network == \"tcp\" {\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP2048.Put(c.RB)\n\t}\n\tif c.network == \"udp\" {\n\t\tx.BP65507.Put(c.WB)\n\t\tx.BP65507.Put(c.RB)\n\t}\n}\n\nfunc (s *StreamClient) Network() string {\n\treturn s.network\n}\n\nfunc (s *StreamClient) Src() string {\n\treturn s.src\n}\n\nfunc (s *StreamClient) Dst() string {\n\treturn s.dst\n}\n"], "fixing_code": ["// Copyright (c) 2016-present Cloud <cloud@txthinking.com>\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of version 3 of the GNU General Public\n// License as published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n// General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/txthinking/brook\"\n\t\"github.com/txthinking/brook/plugins/block\"\n\t\"github.com/txthinking/brook/plugins/pprof\"\n\t\"github.com/txthinking/brook/plugins/socks5dial\"\n\t\"github.com/txthinking/brook/plugins/thedns\"\n\t\"github.com/txthinking/brook/plugins/tproxy\"\n\t\"github.com/txthinking/runnergroup\"\n\t\"github.com/txthinking/socks5\"\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n\tg := runnergroup.New()\n\tapp := cli.NewApp()\n\tapp.Name = \"Brook\"\n\tapp.Version = \"20230122.Beta.20230214\"\n\tapp.Usage = \"A cross-platform network tool designed for developers\"\n\tapp.Authors = []*cli.Author{\n\t\t{\n\t\t\tName:  \"Cloud\",\n\t\t\tEmail: \"cloud@txthinking.com\",\n\t\t},\n\t}\n\tapp.Copyright = \"https://github.com/txthinking/brook\"\n\tapp.EnableBashCompletion = true\n\tapp.Flags = []cli.Flag{\n\t\t&cli.StringFlag{\n\t\t\tName:  \"pprof\",\n\t\t\tUsage: \"go http pprof listen addr, such as :6060\",\n\t\t},\n\t}\n\tapp.Before = func(c *cli.Context) error {\n\t\tif c.String(\"pprof\") != \"\" {\n\t\t\tp, err := pprof.NewPprof(c.String(\"pprof\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\tStart: func() error {\n\t\t\t\t\treturn p.ListenAndServe()\n\t\t\t\t},\n\t\t\t\tStop: func() error {\n\t\t\t\t\treturn p.Shutdown()\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n\tapp.Commands = []*cli.Command{\n\t\t&cli.Command{\n\t\t\tName:  \"server\",\n\t\t\tUsage: \"Run as brook server, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, requires your socks5 supports standard socks5 TCP and UDP, such as 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Username\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Password\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, password\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewServer(c.String(\"listen\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"toSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"toSocks5\"), c.String(\"toSocks5Username\"), c.String(\"toSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"client\",\n\t\t\tUsage: \"Run as brook client, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook client <-> $ brook server <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook server address, like: 1.2.3.4:9999\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook server password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"server\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewClient(c.String(\"socks5\"), ip, c.String(\"server\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.UDPOverTCP = c.Bool(\"udpovertcp\")\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tgo func() {\n\t\t\t\t\tsigs := make(chan os.Signal, 1)\n\t\t\t\t\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t\t\t\t\t<-sigs\n\t\t\t\t\tg.Done()\n\t\t\t\t}()\n\t\t\t\treturn g.Wait()\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wsserver\",\n\t\t\tUsage: \"Run as brook wsserver, both TCP and UDP, it will start a standard http server and websocket server\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: ':80'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"path\",\n\t\t\t\t\tUsage: \"URL path\",\n\t\t\t\t\tValue: \"/ws\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, requires your socks5 supports standard socks5 TCP and UDP, such as 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Username\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Password\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, password\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif c.String(\"toSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"toSocks5\"), c.String(\"toSocks5Username\"), c.String(\"toSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSServer(c.String(\"listen\"), c.String(\"password\"), \"\", c.String(\"path\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wsclient\",\n\t\t\tUsage: \"Run as brook wsclient, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook wsclient <-> $ brook wsserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"wsserver\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook wsserver address, like: ws://1.2.3.4:80, if no path then /ws will be used. Do not omit the port under any circumstances\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook wsserver password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"Specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"wsserver\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSClient(c.String(\"socks5\"), ip, c.String(\"wsserver\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\ts.ServerAddress = c.String(\"address\")\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wssserver\",\n\t\t\tUsage: \"Run as brook wssserver, both TCP and UDP, it will start a standard https server and websocket server\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domainaddress\",\n\t\t\t\t\tUsage: \"Such as: domain.com:443. If you choose to automatically issue certificates, the domain must have been resolved to the server IP and 80 port also will be used\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"cert\",\n\t\t\t\t\tUsage: \"The cert file absolute path for the domain, such as /path/to/cert.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"certkey\",\n\t\t\t\t\tUsage: \"The cert key file absolute path for the domain, such as /path/to/certkey.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"path\",\n\t\t\t\t\tUsage: \"URL path\",\n\t\t\t\t\tValue: \"/ws\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, requires your socks5 supports standard socks5 TCP and UDP, such as 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Username\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"toSocks5Password\",\n\t\t\t\t\tUsage: \"Forward to socks5 server, password\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"domainaddress\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" && !filepath.IsAbs(c.String(\"cert\")) {\n\t\t\t\t\treturn errors.New(\"--cert must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" && !filepath.IsAbs(c.String(\"certkey\")) {\n\t\t\t\t\treturn errors.New(\"--certkey must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif c.String(\"toSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"toSocks5\"), c.String(\"toSocks5Username\"), c.String(\"toSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"domainaddress\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSServer(\":\"+p, c.String(\"password\"), h, c.String(\"path\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"cert\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.Cert = b\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"certkey\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.CertKey = b\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"wssclient\",\n\t\t\tUsage: \"Run as brook wssclient, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook wssclient <-> $ brook wssserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"wssserver\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook wssserver address, like: wss://google.com:443, if no path then /ws will be used. Do not omit the port under any circumstances\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook wssserver password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"Specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"Client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"wssserver\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewWSClient(c.String(\"socks5\"), ip, c.String(\"wssserver\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\ts.ServerAddress = c.String(\"address\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\ts.TLSConfig.InsecureSkipVerify = true\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\troots := x509.NewCertPool()\n\t\t\t\t\tok := roots.AppendCertsFromPEM(b)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn errors.New(\"failed to parse root certificate\")\n\t\t\t\t\t}\n\t\t\t\t\ts.TLSConfig.RootCAs = roots\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"quicserver\",\n\t\t\tUsage: \"Run as brook quicserver, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domainaddress\",\n\t\t\t\t\tUsage: \"Such as: domain.com:443. If you choose to automatically issue certificates, the domain must have been resolved to the server IP and 80 port also will be used\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Server password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"cert\",\n\t\t\t\t\tUsage: \"The cert file absolute path for the domain, such as /path/to/cert.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"certkey\",\n\t\t\t\t\tUsage: \"The cert key file absolute path for the domain, such as /path/to/certkey.pem. If cert or certkey is empty, a certificate will be issued automatically\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"blockGeoIP\",\n\t\t\t\t\tUsage: \"Block IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.Int64Flag{\n\t\t\t\t\tName:  \"updateListInterval\",\n\t\t\t\t\tUsage: \"Update list interval, second. default 0, only read one time on start\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"domainaddress\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"blockCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"blockCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--blockCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" && !filepath.IsAbs(c.String(\"cert\")) {\n\t\t\t\t\treturn errors.New(\"--cert must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" && !filepath.IsAbs(c.String(\"certkey\")) {\n\t\t\t\t\treturn errors.New(\"--certkey must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"blockCIDR4List\") != \"\" || c.String(\"blockCIDR6List\") != \"\" || len(c.StringSlice(\"blockGeoIP\")) != 0 {\n\t\t\t\t\tp, err := block.NewBlock(c.String(\"blockDomainList\"), c.String(\"blockCIDR4List\"), c.String(\"blockCIDR6List\"), c.StringSlice(\"blockGeoIP\"), c.Int(\"updateListInterval\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t\tif c.Int(\"updateListInterval\") != 0 {\n\t\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\t\tp.Update()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\t\tp.Stop()\n\t\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"domainaddress\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewQUICServer(\":\"+p, c.String(\"password\"), h, c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"cert\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"cert\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.Cert = b\n\t\t\t\t}\n\t\t\t\tif c.String(\"certkey\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"certkey\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.CertKey = b\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"quicclient\",\n\t\t\tUsage: \"Run as brook quicclient, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook quicclient <-> $ brook quicserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"quicserver\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Brook quicserver address, like: quic://google.com:443. Do not omit the port under any circumstances\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Brook quicserver password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"Specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"The data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" || c.String(\"quicserver\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewQUICClient(c.String(\"socks5\"), ip, c.String(\"quicserver\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"), c.Bool(\"withoutBrookProtocol\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\ts.ServerAddress = c.String(\"address\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\troots := x509.NewCertPool()\n\t\t\t\t\tok := roots.AppendCertsFromPEM(b)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn errors.New(\"failed to parse root certificate\")\n\t\t\t\t\t}\n\t\t\t\t\ts.TLSConfig.RootCAs = roots\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(ip, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"relayoverbrook\",\n\t\t\tUsage: \"Run as relay over brook, both TCP and UDP, this means access [from address] is equal to [to address], [src <-> from address <-> $ brook server/wsserver/wssserver/quicserver <-> to address]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"from\",\n\t\t\t\t\tAliases: []string{\"f\", \"l\"},\n\t\t\t\t\tUsage:   \"Listen address: like ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"to\",\n\t\t\t\t\tAliases: []string{\"t\"},\n\t\t\t\t\tUsage:   \"Address which relay to, like: 1.2.3.4:9999\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"brook server or brook wsserver or brook wssserver, like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://domain:443/ws, quic://domain.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"from\") == \"\" || c.String(\"to\") == \"\" || c.String(\"server\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tkind := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\tkind = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\tkind = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\tkind = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelayOverBrook(c.String(\"from\"), brook.LinkExtra(kind, c.String(\"server\"), \"\", c.String(\"password\"), v), c.String(\"to\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"dnsserveroverbrook\",\n\t\t\tUsage: \"Run as dns server over brook, both TCP and UDP, [src <-> $ brook dnserversoverbrook <-> $ brook server/wsserver/wssserver/quicserver <-> dns] or [src <-> $ brook dnsserveroverbrook <-> dnsForBypass]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: 127.0.0.1:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains NOT in list\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsForBypass\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains in bypass list\",\n\t\t\t\t\tValue: \"223.5.5.5:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableA\",\n\t\t\t\t\tUsage: \"Disable A query\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableAAAA\",\n\t\t\t\t\tUsage: \"Disable AAAA query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"brook server or brook wsserver or brook wssserver, like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://domain.com:443/ws, quic://domain.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"server\") == \"\" || c.String(\"password\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassDomainList\") != \"\" && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--bypassDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"bypassDomainList\") != \"\" || c.Bool(\"disableA\") || c.Bool(\"disableAAAA\") {\n\t\t\t\t\tp, err := thedns.NewTheDNS(c.String(\"blockDomainList\"), c.String(\"bypassDomainList\"), c.String(\"dnsForBypass\"), c.Bool(\"disableA\"), c.Bool(\"disableAAAA\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tkind := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\tkind = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\tkind = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\tkind = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelayOverBrook(c.String(\"listen\"), brook.LinkExtra(kind, c.String(\"server\"), \"\", c.String(\"password\"), v), c.String(\"dns\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.IsDNS = true\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"tproxy\",\n\t\t\tUsage: \"Run as transparent proxy, both TCP and UDP, only works on Linux, [src <-> $ brook tproxy <-> $ brook server/wsserver/wssserver/quicserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, DO NOT contain IP, just like: ':1080'. No need to operate iptables by default!\",\n\t\t\t\t\tValue:   \":1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsListen\",\n\t\t\t\t\tUsage: \"Start a smart DNS server, like: ':53'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsForDefault\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains NOT in list\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dnsForBypass\",\n\t\t\t\t\tUsage: \"DNS server for resolving domains in bypass list\",\n\t\t\t\t\tValue: \"223.5.5.5:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, Suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, Suffix match mode. https://, http:// or local file absolute path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableA\",\n\t\t\t\t\tUsage: \"Disable A query\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableAAAA\",\n\t\t\t\t\tUsage: \"Disable AAAA query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassCIDR4List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr4.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"bypassCIDR6List\",\n\t\t\t\t\tUsage: \"One CIDR per line, https://, http:// or local file absolute path, like: https://txthinking.github.io/bypass/example_cidr6.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringSliceFlag{\n\t\t\t\t\tName:  \"bypassGeoIP\",\n\t\t\t\t\tUsage: \"Bypass IP by Geo country code, such as US\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"enableIPv6\",\n\t\t\t\t\tUsage: \"deprecated\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"doNotRunScripts\",\n\t\t\t\t\tUsage: \"This will not change iptables and others if you want to do by yourself\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"webListen\",\n\t\t\t\t\tUsage: \"Ignore all other parameters, run web UI, like: ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"brook server or brook wsserver or brook wssserver, like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://domain.com:443/ws, quic://domain.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca instead of insecure, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"link\",\n\t\t\t\t\tUsage: \"brook link. This will ignore server, password, udpovertcp, address, insecure, withoutBrookProtocol, ca\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"Dial with your socks5 proxy, such as 127.0.0.1:1081\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"webListen\") != \"\" {\n\t\t\t\t\tweb, err := fs.Sub(static, \"static\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tvar cmd *exec.Cmd\n\t\t\t\t\tlock := &sync.Mutex{}\n\t\t\t\t\tm := http.NewServeMux()\n\t\t\t\t\tm.Handle(\"/\", http.FileServer(http.FS(web)))\n\t\t\t\t\tm.HandleFunc(\"/hasp\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\t_, err := os.Stat(\"/tmp/.brook.web.password\")\n\t\t\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\t\t\tw.Write([]byte(\"no\"))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Write([]byte(\"yes\"))\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/setp\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\t_, err := os.Stat(\"/tmp/.brook.web.password\")\n\t\t\t\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t\t\t\thttp.Error(w, \"file exsits\", 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = ioutil.WriteFile(\"/tmp/.brook.web.password\", []byte(r.FormValue(\"p\")), 0600)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/authp\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tb, err := ioutil.ReadFile(\"/tmp/.brook.web.password\")\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif string(b) != r.FormValue(\"p\") {\n\t\t\t\t\t\t\thttp.Error(w, \"web ui password wrong\", 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/start\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tb, err := ioutil.ReadFile(\"/root/.brook.web.password\")\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif string(b) != r.FormValue(\"p\") {\n\t\t\t\t\t\t\thttp.Error(w, \"web ui password wrong\", 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts, err := os.Executable()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tcmd = exec.Command(\"/bin/sh\", \"-c\", s+\" tproxy \"+r.FormValue(\"args\"))\n\t\t\t\t\t\tdone := make(chan byte)\n\t\t\t\t\t\tdefer close(done)\n\t\t\t\t\t\terrch := make(chan error)\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tout, _ := cmd.CombinedOutput()\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase <-done:\n\t\t\t\t\t\t\t\tlog.Println(string(out))\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\t\tcase <-done:\n\t\t\t\t\t\t\t\t\tlog.Println(string(out))\n\t\t\t\t\t\t\t\tcase errch <- errors.New(string(out)):\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\t\tcmd = nil\n\t\t\t\t\t\t\tlock.Unlock()\n\t\t\t\t\t\t}()\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase err := <-errch:\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tcase <-time.After(6 * time.Second):\n\t\t\t\t\t\t\tw.Write([]byte(\"connected\"))\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/stop\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tb, err := ioutil.ReadFile(\"/root/.brook.web.password\")\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif string(b) != r.FormValue(\"p\") {\n\t\t\t\t\t\t\thttp.Error(w, \"web ui password wrong\", 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tif cmd == nil {\n\t\t\t\t\t\t\tw.Write([]byte(\"disconnected\"))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := cmd.Process.Signal(syscall.SIGTERM); err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Write([]byte(\"disconnected\"))\n\t\t\t\t\t})\n\t\t\t\t\tm.HandleFunc(\"/status\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tb, err := ioutil.ReadFile(\"/tmp/.brook.web.password\")\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif string(b) != r.FormValue(\"p\") {\n\t\t\t\t\t\t\thttp.Error(w, \"web ui password wrong\", 500)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlock.Lock()\n\t\t\t\t\t\tdefer lock.Unlock()\n\t\t\t\t\t\tif cmd == nil {\n\t\t\t\t\t\t\tw.Write([]byte(\"disconnected\"))\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Write([]byte(\"connected\"))\n\t\t\t\t\t})\n\t\t\t\t\ts := &http.Server{\n\t\t\t\t\t\tAddr:    c.String(\"webListen\"),\n\t\t\t\t\t\tHandler: m,\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\tif cmd != nil {\n\t\t\t\t\t\t\t\tcmd.Process.Signal(syscall.SIGTERM)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn s.Shutdown(context.Background())\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif c.String(\"listen\") == \"\" || (c.String(\"link\") == \"\" && (c.String(\"server\") == \"\" || c.String(\"password\") == \"\")) {\n\t\t\t\t\t_ = cli.ShowSubcommandHelp(c)\n\t\t\t\t\treturn errors.New(\"\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassDomainList\") != \"\" && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--bypassDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassCIDR4List\") != \"\" && !strings.HasPrefix(c.String(\"bypassCIDR4List\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassCIDR4List\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassCIDR4List\")) {\n\t\t\t\t\treturn errors.New(\"--bypassCIDR4List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassCIDR6List\") != \"\" && !strings.HasPrefix(c.String(\"bypassCIDR6List\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassCIDR6List\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassCIDR6List\")) {\n\t\t\t\t\treturn errors.New(\"--bypassCIDR6List must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.String(\"bypassDomainList\") != \"\" || c.Bool(\"disableA\") || c.Bool(\"disableAAAA\") {\n\t\t\t\t\tp, err := thedns.NewTheDNS(c.String(\"blockDomainList\"), c.String(\"bypassDomainList\"), c.String(\"dnsForBypass\"), c.Bool(\"disableA\"), c.Bool(\"disableAAAA\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassCIDR4List\") != \"\" || c.String(\"bypassCIDR6List\") != \"\" || len(c.StringSlice(\"bypassGeoIP\")) != 0 {\n\t\t\t\t\tp, err := tproxy.NewTproxy(c.String(\"bypassCIDR4List\"), c.String(\"bypassCIDR6List\"), c.StringSlice(\"bypassGeoIP\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\tkind := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\tkind = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\tkind = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\tkind = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\tlink := brook.LinkExtra(kind, c.String(\"server\"), \"\", c.String(\"password\"), v)\n\t\t\t\tif c.String(\"link\") != \"\" {\n\t\t\t\t\tlink = c.String(\"link\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewTproxy(c.String(\"listen\"), link, c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\tif !c.Bool(\"doNotRunScripts\") {\n\t\t\t\t\t\t\ts.ClearAutoScripts()\n\t\t\t\t\t\t\tif err := s.RunAutoScripts(); err != nil {\n\t\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\tif !c.Bool(\"doNotRunScripts\") {\n\t\t\t\t\t\t\tif err := s.ClearAutoScripts(); err != nil {\n\t\t\t\t\t\t\t\tlog.Println(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"dnsListen\") != \"\" {\n\t\t\t\t\ts, err := brook.NewRelayOverBrook(c.String(\"dnsListen\"), link, c.String(\"dnsForDefault\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ts.IsDNS = true\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"link\",\n\t\t\tUsage: \"Generate brook link\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Support brook server, brook wsserver, brook wssserver, socks5 server, brook quicserver. Like: 1.2.3.4:9999, ws://1.2.3.4:9999, wss://google.com:443/ws, socks5://1.2.3.4:1080, quic://google.com:443\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"username\",\n\t\t\t\t\tAliases: []string{\"u\"},\n\t\t\t\t\tUsage:   \"Username, when server is socks5 server\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"name\",\n\t\t\t\t\tUsage: \"Give this server a name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"udpovertcp\",\n\t\t\t\t\tUsage: \"When server is brook server, UDP over TCP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"address\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, specify address instead of resolving addresses from host, such as 1.2.3.4:443\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"insecure\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, client do not verify the server's certificate chain and host name\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"withoutBrookProtocol\",\n\t\t\t\t\tUsage: \"When server is brook wsserver or brook wssserver or brook quicserver, the data will not be encrypted with brook protocol\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"ca\",\n\t\t\t\t\tUsage: \"When server is brook wssserver or brook quicserver, specify ca for untrusted cert, such as /path/to/ca.pem\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"server\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts := \"server\"\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"ws://\") {\n\t\t\t\t\ts = \"wsserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"wss://\") {\n\t\t\t\t\ts = \"wssserver\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"socks5://\") {\n\t\t\t\t\ts = \"socks5\"\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.String(\"server\"), \"quic://\") {\n\t\t\t\t\ts = \"quicserver\"\n\t\t\t\t}\n\t\t\t\tv := url.Values{}\n\t\t\t\tif c.String(\"name\") != \"\" {\n\t\t\t\t\tv.Set(\"name\", c.String(\"name\"))\n\t\t\t\t}\n\t\t\t\tif c.String(\"address\") != \"\" {\n\t\t\t\t\tv.Set(\"address\", c.String(\"address\"))\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"insecure\") {\n\t\t\t\t\tv.Set(\"insecure\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"withoutBrookProtocol\") {\n\t\t\t\t\tv.Set(\"withoutBrookProtocol\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.Bool(\"udpovertcp\") {\n\t\t\t\t\tv.Set(\"udpovertcp\", \"true\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"ca\") != \"\" {\n\t\t\t\t\tb, err := ioutil.ReadFile(c.String(\"ca\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tv.Set(\"ca\", string(b))\n\t\t\t\t}\n\t\t\t\tfmt.Println(brook.LinkExtra(s, c.String(\"server\"), c.String(\"username\"), c.String(\"password\"), v))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"connect\",\n\t\t\tUsage: \"Run as client and connect to brook link, both TCP and UDP, to start a socks5 proxy, [src <-> socks5 <-> $ brook connect <-> $ brook server/wsserver/wssserver/quicserver <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"link\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"brook link, you can get it via $ brook link\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:1080\",\n\t\t\t\t\tUsage: \"Where to listen for SOCKS5 connections\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"http\",\n\t\t\t\t\tUsage: \"Where to listen for HTTP proxy connections\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5\",\n\t\t\t\t\tUsage: \"If you already have a socks5, such as 127.0.0.1:1081, and want [src <-> listen socks5 <-> $ brook connect <-> dialWithSocks5 <-> $ brook server/wsserver/wssserver <-> dst]\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Username\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dialWithSocks5Password\",\n\t\t\t\t\tUsage: \"Optional\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"link\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, p, err := net.SplitHostPort(c.String(\"socks5\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\th = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\tif h == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use loopback IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tkind, _, _, _, _, err := brook.ParseLinkExtra(c.String(\"link\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif kind == \"socks5\" {\n\t\t\t\t\treturn errors.New(\"Looks like you want create socks5 from a socks5, you may want $ brook socks5tohttp?\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"dialWithSocks5\") != \"\" {\n\t\t\t\t\tp, err := socks5dial.NewSocks5Dial(c.String(\"dialWithSocks5\"), c.String(\"dialWithSocks5Username\"), c.String(\"dialWithSocks5Password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewBrookLink(c.String(\"link\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\terr = s.PrepareSocks5Server(c.String(\"socks5\"), h, c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif c.String(\"http\") != \"\" {\n\t\t\t\t\th, err := brook.NewSocks5ToHTTP(c.String(\"http\"), net.JoinHostPort(h, p), \"\", \"\", c.Int(\"tcpTimeout\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\t\treturn h.ListenAndServe()\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\t\treturn h.Shutdown()\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"relay\",\n\t\t\tUsage: \"Run as standalone relay, both TCP and UDP, this means access [from address] is equal to access [to address], [src <-> from address <-> to address]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"from\",\n\t\t\t\t\tAliases: []string{\"f\", \"l\"},\n\t\t\t\t\tUsage:   \"Listen address: like ':9999'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"to\",\n\t\t\t\t\tAliases: []string{\"t\"},\n\t\t\t\t\tUsage:   \"Address which relay to, like: 1.2.3.4:9999\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"from\") == \"\" || c.String(\"to\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelay(c.String(\"from\"), c.String(\"to\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"dnsserver\",\n\t\t\tUsage: \"Run as standalone dns server, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: 127.0.0.1:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tUsage: \"DNS server which forward to\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"blockDomainList\",\n\t\t\t\t\tUsage: \"One domain per line, suffix match mode. https://, http:// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableA\",\n\t\t\t\t\tUsage: \"Disable A query\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"disableAAAA\",\n\t\t\t\t\tUsage: \"Disable AAAA query\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" && !strings.HasPrefix(c.String(\"blockDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"blockDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"blockDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--blockDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\tif c.String(\"blockDomainList\") != \"\" || c.Bool(\"disableA\") || c.Bool(\"disableAAAA\") {\n\t\t\t\t\tp, err := thedns.NewTheDNS(c.String(\"blockDomainList\"), \"\", \"\", c.Bool(\"disableA\"), c.Bool(\"disableAAAA\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tp.TouchBrook()\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewRelay(c.String(\"listen\"), c.String(\"dns\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.IsDNS = true\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"socks5\",\n\t\t\tUsage: \"Run as standalone standard socks5 server, both TCP and UDP\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Socks5 server listen address, like: :1080 or 1.2.3.4:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5ServerIP\",\n\t\t\t\t\tUsage: \"Only if your socks5 server IP is different from listen IP\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"username\",\n\t\t\t\t\tUsage: \"User name, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"password\",\n\t\t\t\t\tUsage: \"Password, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.BoolFlag{\n\t\t\t\t\tName:  \"limitUDP\",\n\t\t\t\t\tUsage: \"The server MAY use this information to limit access to the UDP association\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"Connection deadline time (s)\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"udpTimeout\",\n\t\t\t\t\tValue: 60,\n\t\t\t\t\tUsage: \"Connection deadline time (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\th, _, err := net.SplitHostPort(c.String(\"listen\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif h == \"\" && c.String(\"socks5ServerIP\") == \"\" {\n\t\t\t\t\treturn errors.New(\"socks5 server requires a clear IP for UDP, only port is not enough. You may use public IP or lan IP or other, we can not decide for you\")\n\t\t\t\t}\n\t\t\t\tvar ip string\n\t\t\t\tif h != \"\" {\n\t\t\t\t\tip = h\n\t\t\t\t}\n\t\t\t\tif c.String(\"socks5ServerIP\") != \"\" {\n\t\t\t\t\tip = c.String(\"socks5ServerIP\")\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewSocks5Server(c.String(\"listen\"), ip, c.String(\"username\"), c.String(\"password\"), c.Int(\"tcpTimeout\"), c.Int(\"udpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\ts.Server.LimitUDP = c.Bool(\"limitUDP\")\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"socks5tohttp\",\n\t\t\tUsage: \"Convert socks5 to http proxy, [src <-> listen address(http proxy) <-> socks5 address <-> dst]\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"socks5\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Socks5 server address, like: 127.0.0.1:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5username\",\n\t\t\t\t\tUsage: \"Socks5 username, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5password\",\n\t\t\t\t\tUsage: \"Socks5 password, optional\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"HTTP proxy which will be create: like: 127.0.0.1:8010\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"tcpTimeout\",\n\t\t\t\t\tValue: 0,\n\t\t\t\t\tUsage: \"Connection tcp timeout (s)\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" || c.String(\"socks5\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewSocks5ToHTTP(c.String(\"listen\"), c.String(\"socks5\"), c.String(\"socks5username\"), c.String(\"socks5password\"), c.Int(\"tcpTimeout\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"pac\",\n\t\t\tUsage: \"Run as PAC server or save PAC to file\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: 127.0.0.1:1980\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"proxy\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tValue:   \"SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT\",\n\t\t\t\t\tUsage:   \"Proxy, like: 'SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT'\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"bypassDomainList\",\n\t\t\t\t\tAliases: []string{\"b\"},\n\t\t\t\t\tUsage:   \"One domain per line, suffix match mode. http(s):// or local absolute file path. Like: https://txthinking.github.io/bypass/example_domain.txt\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Save PAC to file, this will ignore listen address\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" && c.String(\"file\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tif c.String(\"bypassDomainList\") != \"\" && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"http://\") && !strings.HasPrefix(c.String(\"bypassDomainList\"), \"https://\") && !filepath.IsAbs(c.String(\"bypassDomainList\")) {\n\t\t\t\t\treturn errors.New(\"--bypassDomainList must be with absolute path\")\n\t\t\t\t}\n\t\t\t\ts := brook.NewPAC(c.String(\"listen\"), c.String(\"file\"), c.String(\"proxy\"), c.String(\"bypassDomainList\"))\n\t\t\t\tif c.String(\"file\") != \"\" {\n\t\t\t\t\treturn s.WriteToFile()\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"testsocks5\",\n\t\t\tUsage: \"Test UDP and TCP of socks5 server\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"socks5\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Like: 127.0.0.1:1080\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"username\",\n\t\t\t\t\tAliases: []string{\"u\"},\n\t\t\t\t\tUsage:   \"Socks5 username\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"password\",\n\t\t\t\t\tAliases: []string{\"p\"},\n\t\t\t\t\tUsage:   \"Socks5 password\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t\tUsage: \"DNS server for connecting\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domain\",\n\t\t\t\t\tValue: \"http3.ooo\",\n\t\t\t\t\tUsage: \"Domain for query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"a\",\n\t\t\t\t\tValue: \"137.184.237.95\",\n\t\t\t\t\tUsage: \"The A record of domain\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"socks5\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tsocks5.Debug = true\n\t\t\t\treturn brook.Socks5Test(c.String(\"socks5\"), c.String(\"username\"), c.String(\"password\"), c.String(\"domain\"), c.String(\"a\"), c.String(\"dns\"))\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"testbrook\",\n\t\t\tUsage: \"Test UDP and TCP of brook server/wsserver/wssserver\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"link\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"brook link. Get it via $ brook link\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"socks5\",\n\t\t\t\t\tValue: \"127.0.0.1:11080\",\n\t\t\t\t\tUsage: \"Temporarily listening socks5\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"dns\",\n\t\t\t\t\tValue: \"8.8.8.8:53\",\n\t\t\t\t\tUsage: \"DNS server for connecting\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"domain\",\n\t\t\t\t\tValue: \"http3.ooo\",\n\t\t\t\t\tUsage: \"Domain for query\",\n\t\t\t\t},\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:  \"a\",\n\t\t\t\t\tValue: \"137.184.237.95\",\n\t\t\t\t\tUsage: \"The A record of domain\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"link\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\tsocks5.Debug = true\n\t\t\t\tfmt.Println(\"Run brook connect to listen\", c.String(\"socks5\"))\n\t\t\t\tvar cmd *exec.Cmd\n\t\t\t\tvar err error\n\t\t\t\tgo func() {\n\t\t\t\t\tvar s string\n\t\t\t\t\ts, err = os.Executable()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcmd = exec.Command(s, \"connect\", \"--link\", c.String(\"link\"), \"--socks5\", c.String(\"socks5\"))\n\t\t\t\t\tb, _ := cmd.CombinedOutput()\n\t\t\t\t\terr = errors.New(string(b))\n\t\t\t\t}()\n\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\terr1 := brook.Socks5Test(c.String(\"socks5\"), \"\", \"\", c.String(\"domain\"), c.String(\"a\"), c.String(\"dns\"))\n\t\t\t\t_ = cmd.Process.Signal(syscall.SIGTERM)\n\t\t\t\treturn err1\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"echoserver\",\n\t\t\tUsage: \"Echo server, echo UDP and TCP address of routes\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"listen\",\n\t\t\t\t\tAliases: []string{\"l\"},\n\t\t\t\t\tUsage:   \"Listen address, like: ':7777'\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"listen\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\ts, err := brook.NewEchoServer(c.String(\"listen\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tg.Add(&runnergroup.Runner{\n\t\t\t\t\tStart: func() error {\n\t\t\t\t\t\treturn s.ListenAndServe()\n\t\t\t\t\t},\n\t\t\t\t\tStop: func() error {\n\t\t\t\t\t\treturn s.Shutdown()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"echoclient\",\n\t\t\tUsage: \"Connect to echoserver, echo UDP and TCP address of routes\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"server\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"Echo server address, such as 1.2.3.4:7777\",\n\t\t\t\t},\n\t\t\t\t&cli.IntFlag{\n\t\t\t\t\tName:  \"times\",\n\t\t\t\t\tValue: 1,\n\t\t\t\t\tUsage: \"Times of interactions\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"server\") == \"\" {\n\t\t\t\t\treturn cli.ShowSubcommandHelp(c)\n\t\t\t\t}\n\t\t\t\treturn brook.EchoClient(c.String(\"server\"), c.Int(\"times\"))\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"completion\",\n\t\t\tUsage: \"Generate shell completions\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Write to file\",\n\t\t\t\t\tValue:   \"brook_autocomplete\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tl := c.App.VisibleCommands()\n\t\t\t\tif strings.Contains(os.Getenv(\"SHELL\"), \"zsh\") {\n\t\t\t\t\ts := `\n_cli_zsh_autocomplete() {\n  local -a opts\n  local cur\n  cur=${words[-1]}\n  if [[ \"$cur\" == \"-\"* ]]; then\n    opts=(\"${(@f)$(${words[@]:0:#words[@]-1} ${cur} --generate-bash-completion)}\")\n  else\n    opts=(\"${(@f)$(${words[@]:0:#words[@]-1} --generate-bash-completion)}\")\n  fi\n\n  if [[ \"${opts[1]}\" != \"\" ]]; then\n    _describe 'values' opts\n  else\n    _files\n  fi\n}\ncompdef _cli_zsh_autocomplete brook\n`\n\t\t\t\t\tfor _, v := range l {\n\t\t\t\t\t\ts += \"compdef _cli_zsh_autocomplete brook \" + v.Name + \"\\n\"\n\t\t\t\t\t}\n\t\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Println(\"Generated\")\n\t\t\t\t\tfmt.Println(\"\\t\" + c.String(\"file\"))\n\t\t\t\t\tfmt.Println(\"To enable auto-completion for the current shell session\")\n\t\t\t\t\tfmt.Println(\"\\t$ source \" + c.String(\"file\"))\n\t\t\t\t\tfmt.Println(\"To enable persistent auto-completion, add this line to your .zsh\")\n\t\t\t\t\tfmt.Println(\"\\t$ source /path/to/\" + c.String(\"file\"))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\ts := `#! /bin/bash\n_cli_bash_autocomplete() {\n  if [[ \"${COMP_WORDS[0]}\" != \"source\" ]]; then\n    local cur opts base\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    if [[ \"$cur\" == \"-\"* ]]; then\n      opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} ${cur} --generate-bash-completion )\n    else\n      opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )\n    fi\n    COMPREPLY=( $(compgen -W \"${opts}\" -- ${cur}) )\n    return 0\n  fi\n}\ncomplete -o bashdefault -o default -o nospace -F _cli_bash_autocomplete brook\n`\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\ts += \"complete -o bashdefault -o default -o nospace -F _cli_bash_autocomplete brook \" + v.Name + \"\\n\"\n\t\t\t\t}\n\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Generated:\")\n\t\t\t\tfmt.Println(\"\\t\" + c.String(\"file\"))\n\t\t\t\tfmt.Println(\"To enable auto-completion for the current shell session\")\n\t\t\t\tfmt.Println(\"\\t$ source \" + c.String(\"file\"))\n\t\t\t\tif runtime.GOOS == \"darwin\" {\n\t\t\t\t\tfmt.Println(\"To enable persistent auto-completion, add this line to your .bash_profile\")\n\t\t\t\t}\n\t\t\t\tif runtime.GOOS != \"darwin\" {\n\t\t\t\t\tfmt.Println(\"To enable persistent auto-completion, add this line to your .bashrc\")\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"\\t$ source /path/to/\" + c.String(\"file\"))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"mdpage\",\n\t\t\tUsage: \"Generate markdown page\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Write to file, default print to stdout\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\ts, err := c.App.ToMarkdown()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"file\") != \"\" {\n\t\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tfmt.Println(s)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t&cli.Command{\n\t\t\tName:  \"manpage\",\n\t\t\tUsage: \"Generate man.1 page\",\n\t\t\tBashComplete: func(c *cli.Context) {\n\t\t\t\tl := c.Command.VisibleFlags()\n\t\t\t\tfor _, v := range l {\n\t\t\t\t\tfmt.Println(\"--\" + v.Names()[0])\n\t\t\t\t}\n\t\t\t},\n\t\t\tFlags: []cli.Flag{\n\t\t\t\t&cli.StringFlag{\n\t\t\t\t\tName:    \"file\",\n\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\tUsage:   \"Write to file, default print to stdout. You should put to /path/to/man/man1/brook.1 on linux or /usr/local/share/man/man1/brook.1 on macos\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\ts, err := c.App.ToManWithSection(1)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif c.String(\"file\") != \"\" {\n\t\t\t\t\tif err := os.WriteFile(c.String(\"file\"), []byte(s), 0644); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tfmt.Println(s)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}\n\tif os.Getenv(\"SOCKS5_DEBUG\") != \"\" {\n\t\tsocks5.Debug = true\n\t}\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tif len(g.Runners) == 0 {\n\t\treturn\n\t}\n\tgo func() {\n\t\tsigs := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t\t<-sigs\n\t\tg.Done()\n\t}()\n\tlog.Println(g.Wait())\n}\n", "<!DOCTYPE html>\n<html>\n    <head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" />\n        <title>Brook</title>\n        <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-96ENZWNBX1\"></script>\n        <script>\n            window.dataLayer = window.dataLayer || [];\n            function gtag() {\n                dataLayer.push(arguments);\n            }\n            gtag(\"js\", new Date());\n\n            gtag(\"config\", \"G-96ENZWNBX1\");\n        </script>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <link rel=\"stylesheet\" href=\"simple.min.css\" />\n        <script src=\"vue.global.prod.js\"></script>\n        <style>\n            input {\n                width: 100%;\n            }\n        </style>\n        <script>\n            window.addEventListener(\"DOMContentLoaded\", async (e) => {\n                var app = {\n                    data() {\n                        return {\n                            link: localStorage.getItem(\"link\") ?? \"\",\n                            listen: localStorage.getItem(\"listen\") ?? \":1080\",\n                            dnsListen: localStorage.getItem(\"dnsListen\") ?? \":5353\",\n                            dnsForDefault: localStorage.getItem(\"dnsForDefault\") ?? \"8.8.8.8:53\",\n                            dnsForBypass: localStorage.getItem(\"dnsForBypass\") ?? \"223.5.5.5:53\",\n                            bypassDomainList: localStorage.getItem(\"bypassDomainList\") ?? \"\",\n                            bypassCIDR4List: localStorage.getItem(\"bypassCIDR4List\") ?? \"\",\n                            bypassCIDR6List: localStorage.getItem(\"bypassCIDR6List\") ?? \"\",\n                            bypassGeoIP: localStorage.getItem(\"bypassGeoIP\") ?? \"\",\n                            blockDomainList: localStorage.getItem(\"blockDomainList\") ?? \"\",\n                            disableA: localStorage.getItem(\"disableA\") ? true : false,\n                            disableAAAA: localStorage.getItem(\"disableAAAA\") ? true : false,\n                            hasp: false,\n                            localhasp: false,\n                            p: \"\",\n                            status: \"disconnected\",\n                            ing: false,\n                        };\n                    },\n                    async created() {\n                        try {\n                            var r = await fetch(\"/hasp\");\n                            if (r.status != 200) {\n                                throw await r.text();\n                            }\n                            if((await r.text()) == \"yes\"){\n                                this.hasp = true;\n                            }\n                            if(!this.hasp){\n                                return;\n                            }\n                            if(localStorage.getItem(\"p\")){\n                                this.localhasp = true;\n                            }\n                            if(!this.localhasp){\n                                return;\n                            }\n                            var r = await fetch(`/status?p=${encodeURIComponent(localStorage.getItem('p'))}`);\n                            if (r.status != 200) {\n                                throw await r.text();\n                            }\n                            this.status = await r.text();\n                        } catch (e) {\n                            alert(`${e}`);\n                        }\n                    },\n                    methods: {\n                        async setp() {\n                            try {\n                                if (!this.p.trim()) {\n                                    return;\n                                }\n                                this.ing = true;\n                                var r = await fetch(`/setp?p=${encodeURIComponent(this.p.trim())}`);\n                                if (r.status != 200) {\n                                    throw await r.text();\n                                }\n                                location.reload();\n                                this.ing = false;\n                            } catch (e) {\n                                alert(`${e}`);\n                                this.ing = false;\n                            }\n                        },\n                        async authp() {\n                            try {\n                                if (!this.p.trim()) {\n                                    return;\n                                }\n                                this.ing = true;\n                                var r = await fetch(`/authp?p=${encodeURIComponent(this.p.trim())}`);\n                                if (r.status != 200) {\n                                    throw await r.text();\n                                }\n                                localStorage.setItem(\"p\", this.p.trim());\n                                location.reload();\n                                this.ing = false;\n                            } catch (e) {\n                                alert(`${e}`);\n                                this.ing = false;\n                            }\n                        },\n                        async start() {\n                            try {\n                                this.ing = true;\n                                var s = \"\";\n                                if (this.link) {\n                                    s += ` --link '${this.link}'`;\n                                    localStorage.setItem(\"link\", this.link);\n                                } else {\n                                    localStorage.setItem(\"link\", \"\");\n                                }\n                                if (this.listen) {\n                                    s += ` --listen '${this.listen}'`;\n                                    localStorage.setItem(\"listen\", this.listen);\n                                } else {\n                                    localStorage.setItem(\"listen\", \"\");\n                                }\n                                if (this.dnsListen) {\n                                    s += ` --dnsListen '${this.dnsListen}'`;\n                                    localStorage.setItem(\"dnsListen\", this.dnsListen);\n                                } else {\n                                    localStorage.setItem(\"dnsListen\", \"\");\n                                }\n                                if (this.dnsForDefault) {\n                                    s += ` --dnsForDefault '${this.dnsForDefault}'`;\n                                    localStorage.setItem(\"dnsForDefault\", this.dnsForDefault);\n                                } else {\n                                    localStorage.setItem(\"dnsForDefault\", \"\");\n                                }\n                                if (this.dnsForBypass) {\n                                    s += ` --dnsForBypass '${this.dnsForBypass}'`;\n                                    localStorage.setItem(\"dnsForBypass\", this.dnsForBypass);\n                                } else {\n                                    localStorage.setItem(\"dnsForBypass\", \"\");\n                                }\n                                if (this.bypassDomainList) {\n                                    s += ` --bypassDomainList '${this.bypassDomainList}'`;\n                                    localStorage.setItem(\"bypassDomainList\", this.bypassDomainList);\n                                } else {\n                                    localStorage.setItem(\"bypassDomainList\", \"\");\n                                }\n                                if (this.bypassCIDR4List) {\n                                    s += ` --bypassCIDR4List '${this.bypassCIDR4List}'`;\n                                    localStorage.setItem(\"bypassCIDR4List\", this.bypassCIDR4List);\n                                } else {\n                                    localStorage.setItem(\"bypassCIDR4List\", \"\");\n                                }\n                                if (this.bypassCIDR6List) {\n                                    s += ` --bypassCIDR6List '${this.bypassCIDR6List}'`;\n                                    localStorage.setItem(\"bypassCIDR6List\", this.bypassCIDR6List);\n                                } else {\n                                    localStorage.setItem(\"bypassCIDR6List\", \"\");\n                                }\n                                if (\n                                    this.bypassGeoIP &&\n                                    this.bypassGeoIP\n                                        .split(\",\")\n                                        .map((v) => v.trim())\n                                        .filter((v) => v).length\n                                ) {\n                                    this.bypassGeoIP\n                                        .split(\",\")\n                                        .map((v) => v.trim())\n                                        .filter((v) => v)\n                                        .forEach((v) => {\n                                            s += ` --bypassGeoIP '${v}'`;\n                                        });\n                                    localStorage.setItem(\"bypassGeoIP\", this.bypassGeoIP);\n                                } else {\n                                    localStorage.setItem(\"bypassGeoIP\", \"\");\n                                }\n                                if (this.blockDomainList) {\n                                    s += ` --blockDomainList '${this.blockDomainList}'`;\n                                    localStorage.setItem(\"blockDomainList\", this.blockDomainList);\n                                } else {\n                                    localStorage.setItem(\"blockDomainList\", \"\");\n                                }\n                                if (this.disableA) {\n                                    s += ` --disableA`;\n                                    localStorage.setItem(\"disableA\", \"true\");\n                                } else {\n                                    localStorage.setItem(\"disableA\", \"\");\n                                }\n                                if (this.disableAAAA) {\n                                    s += ` --disableAAAA`;\n                                    localStorage.setItem(\"disableAAAA\", \"true\");\n                                } else {\n                                    localStorage.setItem(\"disableAAAA\", \"\");\n                                }\n                                var r = await fetch(`/start?args=${encodeURIComponent(s)}&p=${encodeURIComponent(localStorage.getItem('p'))}`);\n                                if (r.status != 200) {\n                                    throw await r.text();\n                                }\n                                this.status = await r.text();\n                                this.ing = false;\n                            } catch (e) {\n                                alert(`${e}`);\n                                this.ing = false;\n                            }\n                        },\n                        async stop() {\n                            try {\n                                this.ing = true;\n                                var r = await fetch(`/stop?p=${encodeURIComponent(localStorage.getItem('p'))}`);\n                                if (r.status != 200) {\n                                    throw await r.text();\n                                }\n                                this.status = await r.text();\n                                this.ing = false;\n                            } catch (e) {\n                                alert(`${e}`);\n                                this.ing = false;\n                            }\n                        },\n                    },\n                };\n                Vue.createApp(app).mount(\"body\");\n            });\n        </script>\n    </head>\n    <body>\n        <header>\n            <h1>Brook</h1>\n            <p>brook tproxy</p>\n        </header>\n        <main v-if=\"hasp && localhasp\">\n            <p>\n                <label>--link brook link</label><br />\n                <input v-model=\"link\" placeholder=\"brook://...\" />\n            </p>\n            <p>\n                <label>--listen Listen address, DO NOT contain IP</label><br />\n                <input v-model=\"listen\" placeholder=\":1080\" />\n            </p>\n            <p>\n                <label>--dnsListen Start a smart DNS server</label><br />\n                <input v-model=\"dnsListen\" placeholder=\":5353\" />\n            </p>\n            <p>\n                <label>--dnsForDefault DNS server for resolving domains not in bypass list</label><br />\n                <input v-model=\"dnsForDefault\" placeholder=\"8.8.8.8:53\" />\n            </p>\n            <p>\n                <label>--dnsForBypass DNS server for resolving domains in bypass list</label><br />\n                <input v-model=\"dnsForBypass\" placeholder=\"223.5.5.5:53\" />\n            </p>\n            <p>\n                <label>--disableA Disable A query</label><br />\n                <input type=\"checkbox\" v-model=\"disableA\" />\n            </p>\n            <p>\n                <label>--disableAAAA Disable AAAA query</label><br />\n                <input type=\"checkbox\" v-model=\"disableAAAA\" />\n            </p>\n            <p>\n                <label>--bypassDomainList Suffix match mode</label><br />\n                <input v-model=\"bypassDomainList\" placeholder=\"/path/to/local/file/example_domain.txt\" />\n            </p>\n            <p>\n                <label>--bypassCIDR4List</label><br />\n                <input v-model=\"bypassCIDR4List\" placeholder=\"/path/to/local/file/example_cidr4.txt\" />\n            </p>\n            <p>\n                <label>--bypassCIDR6List</label><br />\n                <input v-model=\"bypassCIDR6List\" placeholder=\"/path/to/local/file/example_cidr6.txt\" />\n            </p>\n            <p>\n                <label>--bypassGeoIP Bypass IP by Geo country code, such as CN</label><br />\n                <input v-model=\"bypassGeoIP\" placeholder=\"ZZ,CN\" />\n            </p>\n            <p>\n                <label>--blockDomainList Suffix match mode</label><br />\n                <input v-model=\"blockDomainList\" placeholder=\"/path/to/local/file/example_domain.txt\" />\n            </p>\n            <p v-if=\"ing\"><button disabled>Waiting...</button></p>\n            <p v-if=\"!ing && status == 'disconnected'\"><button v-on:click=\"start\">Connect</button></p>\n            <p v-if=\"!ing && status =='connected'\"><button v-on:click=\"stop\">Disconnect</button></p>\n        </main>\n        <main v-if=\"!hasp\">\n            <p>\n                <label>Set password for web UI</label><br />\n                <input v-model=\"p\" />\n            </p>\n            <p v-if=\"ing\"><button disabled>Waiting...</button></p>\n            <p v-if=\"!ing\"><button v-on:click=\"setp\">Save</button></p>\n        </main>\n        <main v-if=\"hasp && !localhasp\">\n            <p>\n                <label>Auth web UI</label><br />\n                <input v-model=\"p\" />\n            </p>\n            <p v-if=\"ing\"><button disabled>Waiting...</button></p>\n            <p v-if=\"!ing\"><button v-on:click=\"authp\">Auth</button></p>\n        </main>\n        <footer>\n            <p><a href=\"https://txthinking.com\">txthinking.com</a> | <a href=\"https://github.com/txthinking\">github.com/txthinking</a> | <a href=\"https://talks.txthinking.com\">blog</a> | <a href=\"https://youtube.com/txthinking\">youtube</a> | <a href=\"https://t.me/brookgroup\">telegram</a> | <a href=\"https://t.me/txthinking_news\">news</a></p>\n        </footer>\n    </body>\n</html>\n", "// Copyright (c) 2016-present Cloud <cloud@txthinking.com>\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of version 3 of the GNU General Public\n// License as published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n// General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npackage brook\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go\"\n\t\"github.com/txthinking/brook/limits\"\n\tcrypto1 \"github.com/txthinking/crypto\"\n\t\"github.com/txthinking/runnergroup\"\n\t\"github.com/txthinking/socks5\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\ntype QUICServer struct {\n\tPassword             []byte\n\tDomain               string\n\tAddr                 string\n\tTCPTimeout           int\n\tUDPTimeout           int\n\tCert                 []byte\n\tCertKey              []byte\n\tRunnerGroup          *runnergroup.RunnerGroup\n\tWithoutBrook         bool\n\tUDPServerConnFactory UDPServerConnFactory\n}\n\nfunc NewQUICServer(addr, password, domain string, tcpTimeout, udpTimeout int, withoutbrook bool) (*QUICServer, error) {\n\tif err := limits.Raise(); err != nil {\n\t\tLog(&Error{\"when\": \"try to raise system limits\", \"warning\": err.Error()})\n\t}\n\tif runtime.GOOS == \"linux\" {\n\t\tc := exec.Command(\"sysctl\", \"-w\", \"net.core.rmem_max=2500000\")\n\t\tb, err := c.CombinedOutput()\n\t\tif err != nil {\n\t\t\tLog(&Error{\"when\": \"try to raise UDP Receive Buffer Size\", \"warning\": string(b)})\n\t\t}\n\t}\n\tif runtime.GOOS == \"darwin\" {\n\t\tc := exec.Command(\"sysctl\", \"-w\", \"kern.ipc.maxsockbuf=3014656\")\n\t\tb, err := c.CombinedOutput()\n\t\tif err != nil {\n\t\t\tLog(&Error{\"when\": \"try to raise UDP Receive Buffer Size\", \"warning\": string(b)})\n\t\t}\n\t}\n\tvar p []byte\n\tvar f UDPServerConnFactory\n\tif !withoutbrook {\n\t\tp = []byte(password)\n\t\tf = NewPacketServerConnFactory()\n\t}\n\tif withoutbrook {\n\t\tvar err error\n\t\tp, err = crypto1.SHA256Bytes([]byte(password))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tf = NewSimplePacketServerConnFactory()\n\t}\n\ts := &QUICServer{\n\t\tPassword:             p,\n\t\tDomain:               domain,\n\t\tAddr:                 addr,\n\t\tTCPTimeout:           tcpTimeout,\n\t\tUDPTimeout:           udpTimeout,\n\t\tUDPServerConnFactory: f,\n\t\tRunnerGroup:          runnergroup.New(),\n\t\tWithoutBrook:         withoutbrook,\n\t}\n\treturn s, nil\n}\n\nfunc (s *QUICServer) ListenAndServe() error {\n\tvar t *tls.Config\n\tif s.Cert == nil || s.CertKey == nil {\n\t\tm := autocert.Manager{\n\t\t\tCache:      autocert.DirCache(\".letsencrypt\"),\n\t\t\tPrompt:     autocert.AcceptTOS,\n\t\t\tHostPolicy: autocert.HostWhitelist(s.Domain),\n\t\t\tEmail:      \"cloud@txthinking.com\",\n\t\t}\n\t\tserver := &http.Server{Addr: \":80\", Handler: m.HTTPHandler(nil)}\n\t\ts.RunnerGroup.Add(&runnergroup.Runner{\n\t\t\tStart: func() error {\n\t\t\t\treturn server.ListenAndServe()\n\t\t\t},\n\t\t\tStop: func() error {\n\t\t\t\treturn server.Shutdown(context.Background())\n\t\t\t},\n\t\t})\n\t\tt = &tls.Config{GetCertificate: m.GetCertificate, ServerName: s.Domain, NextProtos: []string{\"h3\"}}\n\t}\n\tif s.Cert != nil && s.CertKey != nil {\n\t\tct, err := tls.X509KeyPair(s.Cert, s.CertKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt = &tls.Config{Certificates: []tls.Certificate{ct}, ServerName: s.Domain, NextProtos: []string{\"h3\"}}\n\t}\n\tl, err := quic.ListenAddr(s.Addr, t, &quic.Config{MaxIdleTimeout: time.Duration(s.UDPTimeout) * time.Second, EnableDatagrams: true})\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.RunnerGroup.Add(&runnergroup.Runner{\n\t\tStart: func() error {\n\t\t\tfor {\n\t\t\t\tc, err := l.Accept(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tgo func(c quic.Connection) {\n\t\t\t\t\tdefer c.CloseWithError(0, \"defer\")\n\t\t\t\t\tfor {\n\t\t\t\t\t\tst, err := c.AcceptStream(context.Background())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgo func(c net.Conn) {\n\t\t\t\t\t\t\tdefer c.Close()\n\t\t\t\t\t\t\tvar ss Exchanger\n\t\t\t\t\t\t\tif !s.WithoutBrook {\n\t\t\t\t\t\t\t\tss, err = NewStreamServer(s.Password, c.RemoteAddr().String(), c, s.TCPTimeout, s.UDPTimeout)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif s.WithoutBrook {\n\t\t\t\t\t\t\t\tss, err = NewSimpleStreamServer(s.Password, c.RemoteAddr().String(), c, s.TCPTimeout, s.UDPTimeout)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"error\": err.Error()})\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefer ss.Clean()\n\t\t\t\t\t\t\tif err := s.TCPHandle(ss); err != nil {\n\t\t\t\t\t\t\t\tLog(&Error{\"from\": ss.Src(), \"dst\": ss.Dst(), \"error\": err.Error()})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}(&QUICConn{\n\t\t\t\t\t\t\tConn:   c,\n\t\t\t\t\t\t\tStream: st,\n\t\t\t\t\t\t\tLAddr: &net.TCPAddr{\n\t\t\t\t\t\t\t\tIP:   c.LocalAddr().(*net.UDPAddr).IP,\n\t\t\t\t\t\t\t\tPort: c.LocalAddr().(*net.UDPAddr).Port,\n\t\t\t\t\t\t\t\tZone: c.LocalAddr().(*net.UDPAddr).Zone,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRAddr: &net.TCPAddr{\n\t\t\t\t\t\t\t\tIP:   c.RemoteAddr().(*net.UDPAddr).IP,\n\t\t\t\t\t\t\t\tPort: c.RemoteAddr().(*net.UDPAddr).Port,\n\t\t\t\t\t\t\t\tZone: c.RemoteAddr().(*net.UDPAddr).Zone,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}(c)\n\t\t\t\tif c.ConnectionState().SupportsDatagrams {\n\t\t\t\t\tgo func(c quic.Connection) {\n\t\t\t\t\t\tdefer c.CloseWithError(0, \"defer\")\n\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\tb, err := c.ReceiveMessage()\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconn, dstb, err := s.UDPServerConnFactory.Handle(c.RemoteAddr().(*net.UDPAddr), b, s.Password, func(b []byte) (int, error) {\n\t\t\t\t\t\t\t\tif len(b) > 1197 {\n\t\t\t\t\t\t\t\t\terr := errors.New(\"when write to client, quic max datagram size is 1197\")\n\t\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"error\": err.Error()})\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif err := c.SendMessage(b); err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn len(b), nil\n\t\t\t\t\t\t\t}, s.UDPTimeout)\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"error\": err.Error()})\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif conn == nil {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\t\tdefer conn.Close()\n\t\t\t\t\t\t\t\tvar ss Exchanger\n\t\t\t\t\t\t\t\tif !s.WithoutBrook {\n\t\t\t\t\t\t\t\t\tss, err = NewPacketServer(s.Password, c.RemoteAddr().String(), conn, s.UDPTimeout, dstb)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif s.WithoutBrook {\n\t\t\t\t\t\t\t\t\tss, err = NewSimplePacketServer(s.Password, c.RemoteAddr().String(), conn, s.UDPTimeout, dstb)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"dst\": socks5.ToAddress(dstb[0], dstb[1:len(dstb)-2], dstb[len(dstb)-2:]), \"error\": err.Error()})\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefer ss.Clean()\n\t\t\t\t\t\t\t\tif err := s.UDPHandle(ss); err != nil {\n\t\t\t\t\t\t\t\t\tLog(&Error{\"from\": c.RemoteAddr().String(), \"dst\": socks5.ToAddress(dstb[0], dstb[1:len(dstb)-2], dstb[len(dstb)-2:]), \"error\": err.Error()})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}()\n\t\t\t\t\t\t}\n\t\t\t\t\t}(c)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tStop: func() error {\n\t\t\treturn l.Close()\n\t\t},\n\t})\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, _ = quic.DialAddr(net.JoinHostPort(s.Domain, s.Addr[1:]), &tls.Config{NextProtos: []string{\"h3\"}}, nil)\n\t}()\n\treturn s.RunnerGroup.Wait()\n}\n\nfunc (s *QUICServer) TCPHandle(ss Exchanger) error {\n\trc, err := DialTCP(\"tcp\", \"\", ss.Dst())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rc.Close()\n\tif err := ss.Exchange(rc); err != nil {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (s *QUICServer) UDPHandle(ss Exchanger) error {\n\trc, err := NATDial(\"udp\", ss.Src(), ss.Dst(), ss.Dst())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rc.Close()\n\tif err := ss.Exchange(rc); err != nil {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (s *QUICServer) Shutdown() error {\n\treturn s.RunnerGroup.Done()\n}\n", "// Copyright (c) 2016-present Cloud <cloud@txthinking.com>\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of version 3 of the GNU General Public\n// License as published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n// General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npackage brook\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/txthinking/socks5\"\n\t\"github.com/txthinking/x\"\n\t\"golang.org/x/crypto/hkdf\"\n)\n\ntype StreamClient struct {\n\tServer  net.Conn\n\tcn      []byte\n\tca      cipher.AEAD\n\tsn      []byte\n\tsa      cipher.AEAD\n\tRB      []byte\n\tWB      []byte\n\tTimeout int\n\tnetwork string\n\tsrc     string\n\tdst     string\n}\n\nfunc NewStreamClient(network string, password []byte, src string, server net.Conn, timeout int, dst []byte) (Exchanger, error) {\n\tif timeout != 0 {\n\t\tif err := server.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif len(dst) > 2048-2-16-4-16 {\n\t\treturn nil, errors.New(\"dst too long\")\n\t}\n\tc := &StreamClient{network: network, Server: server, Timeout: timeout, src: src, dst: socks5.ToAddress(dst[0], dst[1:len(dst)-2], dst[len(dst)-2:])}\n\n\tc.cn = x.BP12.Get().([]byte)\n\tif _, err := io.ReadFull(rand.Reader, c.cn); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\treturn nil, err\n\t}\n\tck := x.BP32.Get().([]byte)\n\tif _, err := io.ReadFull(hkdf.New(sha256.New, password, c.cn, []byte{0x62, 0x72, 0x6f, 0x6f, 0x6b}), ck); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP32.Put(ck)\n\t\treturn nil, err\n\t}\n\tif _, err := c.Server.Write(c.cn); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP32.Put(ck)\n\t\treturn nil, err\n\t}\n\tcb, err := aes.NewCipher(ck)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP32.Put(ck)\n\t\treturn nil, err\n\t}\n\tx.BP32.Put(ck)\n\tc.ca, err = cipher.NewGCM(cb)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\treturn nil, err\n\t}\n\n\tc.WB = x.BP2048.Get().([]byte)\n\ti := time.Now().Unix()\n\tif c.network == \"tcp\" && i%2 != 0 {\n\t\ti += 1\n\t}\n\tif c.network == \"udp\" && i%2 != 1 {\n\t\ti += 1\n\t}\n\tbinary.BigEndian.PutUint32(c.WB[2+16:2+16+4], uint32(i))\n\tcopy(c.WB[2+16+4:2+16+4+len(dst)], dst)\n\tif err := c.Write(4 + len(dst)); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\treturn nil, err\n\t}\n\n\tc.sn = x.BP12.Get().([]byte)\n\tif _, err := io.ReadFull(c.Server, c.sn); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\treturn nil, err\n\t}\n\tsk := x.BP32.Get().([]byte)\n\tif _, err := io.ReadFull(hkdf.New(sha256.New, password, c.sn, []byte{0x62, 0x72, 0x6f, 0x6f, 0x6b}), sk); err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\tx.BP32.Put(sk)\n\t\treturn nil, err\n\t}\n\tsb, err := aes.NewCipher(sk)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\tx.BP32.Put(sk)\n\t\treturn nil, err\n\t}\n\tx.BP32.Put(sk)\n\tc.sa, err = cipher.NewGCM(sb)\n\tif err != nil {\n\t\tx.BP12.Put(c.cn)\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP12.Put(c.sn)\n\t\treturn nil, err\n\t}\n\tif c.network == \"tcp\" {\n\t\tc.RB = x.BP2048.Get().([]byte)\n\t}\n\tif c.network == \"udp\" {\n\t\tx.BP2048.Put(c.WB)\n\t\tc.WB = x.BP65507.Get().([]byte)\n\t\tc.RB = x.BP65507.Get().([]byte)\n\t}\n\treturn ClientGate(c)\n}\n\nfunc (c *StreamClient) Exchange(local net.Conn) error {\n\tgo func() {\n\t\tfor {\n\t\t\tif c.Timeout != 0 {\n\t\t\t\tif err := c.Server.SetDeadline(time.Now().Add(time.Duration(c.Timeout) * time.Second)); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tl, err := c.Read()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif _, err := local.Write(c.RB[2+16 : 2+16+l]); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\tfor {\n\t\tif c.Timeout != 0 {\n\t\t\tif err := local.SetDeadline(time.Now().Add(time.Duration(c.Timeout) * time.Second)); err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tl, err := local.Read(c.WB[2+16 : len(c.WB)-16])\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tif err := c.Write(l); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *StreamClient) Write(l int) error {\n\tbinary.BigEndian.PutUint16(c.WB[:2], uint16(l))\n\tc.ca.Seal(c.WB[:0], c.cn, c.WB[:2], nil)\n\tNextNonce(c.cn)\n\tc.ca.Seal(c.WB[:2+16], c.cn, c.WB[2+16:2+16+l], nil)\n\tif _, err := c.Server.Write(c.WB[:2+16+l+16]); err != nil {\n\t\treturn err\n\t}\n\tNextNonce(c.cn)\n\treturn nil\n}\n\nfunc (c *StreamClient) Read() (int, error) {\n\tif _, err := io.ReadFull(c.Server, c.RB[:2+16]); err != nil {\n\t\treturn 0, err\n\t}\n\tif _, err := c.sa.Open(c.RB[:0], c.sn, c.RB[:2+16], nil); err != nil {\n\t\treturn 0, err\n\t}\n\tl := int(binary.BigEndian.Uint16(c.RB[:2]))\n\tif _, err := io.ReadFull(c.Server, c.RB[2+16:2+16+l+16]); err != nil {\n\t\treturn 0, err\n\t}\n\tNextNonce(c.sn)\n\tif _, err := c.sa.Open(c.RB[:2+16], c.sn, c.RB[2+16:2+16+l+16], nil); err != nil {\n\t\treturn 0, err\n\t}\n\tNextNonce(c.sn)\n\treturn l, nil\n}\n\nfunc (c *StreamClient) Clean() {\n\tx.BP12.Put(c.cn)\n\tx.BP12.Put(c.sn)\n\tif c.network == \"tcp\" {\n\t\tx.BP2048.Put(c.WB)\n\t\tx.BP2048.Put(c.RB)\n\t}\n\tif c.network == \"udp\" {\n\t\tx.BP65507.Put(c.WB)\n\t\tx.BP65507.Put(c.RB)\n\t}\n}\n\nfunc (s *StreamClient) Network() string {\n\treturn s.network\n}\n\nfunc (s *StreamClient) Src() string {\n\treturn s.src\n}\n\nfunc (s *StreamClient) Dst() string {\n\treturn s.dst\n}\n"], "filenames": ["cli/brook/main.go", "cli/brook/static/index.html", "quicserver.go", "streamclient.go"], "buggy_code_start_loc": [978, 37, 48, 97], "buggy_code_end_loc": [1567, 199, 49, 192], "fixing_code_start_loc": [978, 38, 48, 97], "fixing_code_end_loc": [1633, 304, 49, 192], "type": "CWE-78", "message": "Brook is a cross-platform programmable network tool. The `tproxy` server is vulnerable to a drive-by command injection. An attacker may fool a victim into visiting a malicious web page which will trigger requests to the local `tproxy` service leading to remote code execution. A patch is available in version 20230606.", "other": {"cve": {"id": "CVE-2023-33965", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-01T15:15:09.213", "lastModified": "2023-06-09T13:31:46.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Brook is a cross-platform programmable network tool. The `tproxy` server is vulnerable to a drive-by command injection. An attacker may fool a victim into visiting a malicious web page which will trigger requests to the local `tproxy` service leading to remote code execution. A patch is available in version 20230606."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:txthinking:brook:*:*:*:*:*:*:*:*", "versionEndExcluding": "20230606", "matchCriteriaId": "A079F0BB-D10F-4DD8-AAEF-CA30E1201727"}]}]}], "references": [{"url": "https://github.com/txthinking/brook/commit/314d7070c37babf6c38a0fe1eada872bb74bf03e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/txthinking/brook/security/advisories/GHSA-vfrj-fv6p-3cpf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/txthinking/brook/commit/314d7070c37babf6c38a0fe1eada872bb74bf03e"}}