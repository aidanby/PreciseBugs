{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n// See ../ops/image_ops.cc for details.\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nstd::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      // 0: yellow\n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      // 1: blue\n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      // 2: red\n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      // 3: lime\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  // 4: purple\n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  // 5: olive\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    // 6: maroon\n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  // 7: navy blue\n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    // 8: aqua\n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    // 9: fuchsia\n\n  if (depth == 1) {\n    for (int64 i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}\n}  // namespace\n\ntemplate <class T>\nclass DrawBoundingBoxesOp : public OpKernel {\n public:\n  explicit DrawBoundingBoxesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64 depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    const int64 batch_size = images.dim_size(0);\n    const int64 height = images.dim_size(1);\n    const int64 width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64 i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(4);\n          for (int64 j = 0; j < 4; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64 b = 0; b < batch_size; ++b) {\n      const int64 num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<T, 3>();\n      for (int64 bb = 0; bb < num_boxes; ++bb) {\n        int64 color_index = bb % color_table.size();\n        const int64 min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0});\n        const int64 max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64 max_box_row_clamp =\n            std::min<int64>(max_box_row, height - 1);\n        const int64 min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0});\n        const int64 max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_CPU_KERNEL(T)                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxes\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      DrawBoundingBoxesOp<T>);                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxesV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      DrawBoundingBoxesOp<T>);\nTF_CALL_half(REGISTER_CPU_KERNEL);\nTF_CALL_float(REGISTER_CPU_KERNEL);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n// See ../ops/image_ops.cc for details.\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nstd::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      // 0: yellow\n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      // 1: blue\n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      // 2: red\n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      // 3: lime\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  // 4: purple\n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  // 5: olive\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    // 6: maroon\n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  // 7: navy blue\n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    // 8: aqua\n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    // 9: fuchsia\n\n  if (depth == 1) {\n    for (int64 i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}\n}  // namespace\n\ntemplate <class T>\nclass DrawBoundingBoxesOp : public OpKernel {\n public:\n  explicit DrawBoundingBoxesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64 depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    OP_REQUIRES(\n        context, boxes.dim_size(2) == 4,\n        errors::InvalidArgument(\n            \"The size of the third dimension of the box must be 4. Received: \",\n            boxes.dim_size(2)));\n\n    const int64 batch_size = images.dim_size(0);\n    const int64 height = images.dim_size(1);\n    const int64 width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64 i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(4);\n          for (int64 j = 0; j < 4; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64 b = 0; b < batch_size; ++b) {\n      const int64 num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<T, 3>();\n      for (int64 bb = 0; bb < num_boxes; ++bb) {\n        int64 color_index = bb % color_table.size();\n        const int64 min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0});\n        const int64 max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64 max_box_row_clamp =\n            std::min<int64>(max_box_row, height - 1);\n        const int64 min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0});\n        const int64 max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64 c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_CPU_KERNEL(T)                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxes\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      DrawBoundingBoxesOp<T>);                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxesV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      DrawBoundingBoxesOp<T>);\nTF_CALL_half(REGISTER_CPU_KERNEL);\nTF_CALL_float(REGISTER_CPU_KERNEL);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/image/draw_bounding_box_op.cc"], "buggy_code_start_loc": [74], "buggy_code_end_loc": [74], "fixing_code_start_loc": [75], "fixing_code_end_loc": [81], "type": "CWE-787", "message": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29571", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:13.877", "lastModified": "2021-07-26T16:10:48.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;La implementaci\u00f3n de \"tf.raw_ops.MaxPoolGradWithArgmax\" puede causar una lectura fuera de l\u00edmites de los datos asignados a la pila si el atacante suministra entradas especialmente dise\u00f1adas.&#xa0;La implementaci\u00f3n (https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) asume que el \u00faltimo elemento de la entrada \"boxes\" es 4, ya que por [la operaci\u00f3n] (https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2).&#xa0;Dado que esto no es comprobado, los atacantes que pasan valores inferiores a 4 pueden escribir fuera de l\u00edmites de los objetos asignados a la pila y causar corrupci\u00f3n de la memoria.&#xa0;Si la \u00faltima dimensi\u00f3n en \"boxes\" es menor que 4, accesos similares a\" tboxes (b, bb, 3) \"acceder\u00e1n a los datos fuera de l\u00edmites.&#xa0;Adem\u00e1s, durante una ejecuci\u00f3n del c\u00f3digo, tambi\u00e9n son escritos estos \u00edndices.&#xa0;La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/79865b542f9ffdc9caeb255631f7c56f1d4b6517", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-whr9-vfh2-7hm6", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/79865b542f9ffdc9caeb255631f7c56f1d4b6517"}}