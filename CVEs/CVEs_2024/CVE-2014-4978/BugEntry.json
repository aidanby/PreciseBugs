{"buggy_code": ["/*\n * * Copyright (C) 2006-2011 Anders Brander <anders@brander.dk>, \n * * Anders Kvist <akv@lnxbx.dk> and Klaus Post <klauspost@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n#include <stdlib.h> /* system() */\n#include <rawstudio.h>\n#include \"rs-filter.h\"\n\n#if 0 /* Change to 1 to enable performance info */\n#define filter_performance printf\n#define FILTER_SHOW_PERFORMANCE\n#else\n#define filter_performance(...) {}\n#endif\n\n/* How much time should a filter at least have taken to show performance number */\n#define FILTER_PERF_ELAPSED_MIN 0.001\n#define CHAIN_PERF_ELAPSED_MIN 0.001\n\nG_DEFINE_TYPE (RSFilter, rs_filter, G_TYPE_OBJECT)\n\nenum {\n  CHANGED_SIGNAL,\n  LAST_SIGNAL\n};\n\nstatic guint signals[LAST_SIGNAL] = { 0 };\n\nstatic void\ndispose(GObject *obj)\n{\n\tRSFilter *filter = RS_FILTER(obj);\n\n\tif (!filter->dispose_has_run)\n\t{\n\t\tfilter->dispose_has_run = TRUE;\n\t\tif (filter->previous)\n\t\t{\n\t\t\tfilter->previous->next_filters = g_slist_remove(filter->previous->next_filters, filter);\n\t\t\tg_object_unref(filter->previous);\n\t\t}\n\t}\n}\n\nstatic void\nrs_filter_class_init(RSFilterClass *klass)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_class_init(%p)\", klass);\n\tGObjectClass *object_class = G_OBJECT_CLASS(klass);\n\n\tsignals[CHANGED_SIGNAL] = g_signal_new (\"changed\",\n\t\tG_TYPE_FROM_CLASS (klass),\n\t\tG_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,\n\t\t0,\n\t\tNULL, \n\t\tNULL,                \n\t\tg_cclosure_marshal_VOID__INT,\n\t\tG_TYPE_NONE, 1, G_TYPE_INT);\n\n\tklass->get_image = NULL;\n\tklass->get_image8 = NULL;\n\tklass->get_size = NULL;\n\tklass->previous_changed = NULL;\n\n\tobject_class->dispose = dispose;\n}\n\nstatic void\nrs_filter_init(RSFilter *self)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_init(%p)\", self);\n\tself->previous = NULL;\n\tself->next_filters = NULL;\n\tself->enabled = TRUE;\n}\n\n/**\n * Return a new instance of a RSFilter\n * @param name The name of the filter\n * @param previous The previous filter or NULL\n * @return The newly instantiated RSFilter or NULL\n */\nRSFilter *\nrs_filter_new(const gchar *name, RSFilter *previous)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_new(%s, %s [%p])\", name, RS_FILTER_NAME(previous), previous);\n\tg_return_val_if_fail(name != NULL, NULL);\n\tg_return_val_if_fail((previous == NULL) || RS_IS_FILTER(previous), NULL);\n\n\tGType type = g_type_from_name(name);\n\tRSFilter *filter = NULL;\n\n\tif (g_type_is_a (type, RS_TYPE_FILTER))\n\t\tfilter = g_object_new(type, NULL);\n\n\tif (!RS_IS_FILTER(filter))\n\t\tg_warning(\"Could not instantiate filter of type \\\"%s\\\"\", name);\n\n\tif (previous)\n\t\trs_filter_set_previous(filter, previous);\n\n\treturn filter;\n}\n\n/**\n * Set the previous RSFilter in a RSFilter-chain\n * @param filter A RSFilter\n * @param previous A previous RSFilter\n */\nvoid\nrs_filter_set_previous(RSFilter *filter, RSFilter *previous)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_set_previous(%p, %p)\", filter, previous);\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tg_return_if_fail(RS_IS_FILTER(previous));\n\n\t/* We will only set the previous filter if it differs from current previous filter */\n\tif (filter->previous != previous)\n\t{\n\t\tif (filter->previous)\n\t\t{\n\t\t\t/* If we already got a previous filter, clean up */\n\t\t\tfilter->previous->next_filters = g_slist_remove(filter->previous->next_filters, filter);\n\t\t\tg_object_unref(filter->previous);\n\t\t}\n\t\tfilter->previous = g_object_ref(previous);\n\n\t\tprevious->next_filters = g_slist_append(previous->next_filters, filter);\n\t}\n}\n\n/**\n * Signal that a filter has changed, filters depending on this will be invoked\n * This should only be called from filter code\n * @param filter The changed filter\n * @param mask A mask indicating what changed\n */\nvoid\nrs_filter_changed(RSFilter *filter, RSFilterChangedMask mask)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_changed(%s [%p], %04x)\", RS_FILTER_NAME(filter), filter, mask);\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tgint i, n_next = g_slist_length(filter->next_filters);\n\n\tfor(i=0; i<n_next; i++)\n\t{\n\t\tRSFilter *next = RS_FILTER(g_slist_nth_data(filter->next_filters, i));\n\n\t\tg_assert(RS_IS_FILTER(next));\n\n\t\t/* Notify \"next\" filter or try \"next next\" filter */\n\t\tif (RS_FILTER_GET_CLASS(next)->previous_changed)\n\t\t\tRS_FILTER_GET_CLASS(next)->previous_changed(next, filter, mask);\n\t\telse\n\t\t\trs_filter_changed(next, mask);\n\t}\n\n\tg_signal_emit(G_OBJECT(filter), signals[CHANGED_SIGNAL], 0, mask);\n}\n\n/* Clamps ROI rectangle to image size */\n/* Returns a new rectangle, or NULL if ROI was within bounds*/\n\nstatic GdkRectangle* \nclamp_roi(const GdkRectangle *roi, RSFilter *filter, const RSFilterRequest *request)\n{\n\tRSFilterResponse *response = rs_filter_get_size(filter, request);\n\tgint w = rs_filter_response_get_width(response);\n\tgint h = rs_filter_response_get_height(response);\n\tg_object_unref(response);\n\n\tif ((roi->x >= 0) && (roi->y >=0) && (roi->x + roi->width <= w) && (roi->y + roi->height <= h))\n\t\treturn NULL;\n\n\tGdkRectangle* new_roi = g_new(GdkRectangle, 1);\n\tnew_roi->x = MAX(0, roi->x);\n\tnew_roi->y = MAX(0, roi->y);\n\tnew_roi->width = MIN(w - new_roi->x, roi->width);\n\tnew_roi->height = MAX(h - new_roi->y, roi->height);\n\treturn new_roi;\n}\n\n/**\n * Get the output image from a RSFilter\n * @param filter A RSFilter\n * @param param A RSFilterRequest defining parameters for a image request\n * @return A RS_IMAGE16, this must be unref'ed\n */\nRSFilterResponse *\nrs_filter_get_image(RSFilter *filter, const RSFilterRequest *request)\n{\n\tGdkRectangle* roi = NULL;\n\tRSFilterRequest *r = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tRS_DEBUG(FILTERS, \"rs_filter_get_image(%s [%p])\", RS_FILTER_NAME(filter), filter);\n\n\t/* This timer-hack will break badly when multithreaded! */\n\tstatic gfloat last_elapsed = 0.0;\n\tstatic gint count = -1;\n\tgfloat elapsed;\n\tstatic GTimer *gt = NULL;\n\n\tRSFilterResponse *response;\n\tRS_IMAGE16 *image;\n\n\tif (count == -1)\n\t\tgt = g_timer_new();\n\tcount++;\n\n\tif (filter->enabled && (roi = rs_filter_request_get_roi(request)))\n\t{\n\t\troi = clamp_roi(roi, filter, request);\n\t\tif (roi)\n\t\t{\n\t\t\tr = rs_filter_request_clone(request);\n\t\t\trs_filter_request_set_roi(r, roi);\n\t\t\trequest = r;\n\t\t}\n\t}\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_image && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_image(filter, request);\n\telse\n\t\tresponse = rs_filter_get_image(filter->previous, request);\n\n\tg_assert(RS_IS_FILTER_RESPONSE(response));\n\n\timage = rs_filter_response_get_image(response);\n\n\telapsed = g_timer_elapsed(gt, NULL) - last_elapsed;\n\n\tif (roi)\n\t\tg_free(roi);\n\tif (r)\n\t\tg_object_unref(r);\n\n#ifdef FILTER_SHOW_PERFORMANCE\n\tif ((elapsed > FILTER_PERF_ELAPSED_MIN) && (image != NULL)) \n\t{\n\t\tgint iw = image->w;\n\t\tgint ih = image->h;\n\t\tif (rs_filter_response_get_roi(response)) \n\t\t{\n\t\t\troi = rs_filter_response_get_roi(response);\n\t\t\tiw = roi->width;\n\t\t\tih = roi->height;\n\t\t}\n\t\tfilter_performance(\"%s took: \\033[32m%.0f\\033[0mms\", RS_FILTER_NAME(filter), elapsed*1000);\n\t\tif ((elapsed > 0.001) && (image != NULL))\n\t\t\tfilter_performance(\" [\\033[33m%.01f\\033[0mMpix/s]\", ((gfloat)(iw*ih))/elapsed/1000000.0);\n\t\tif (image)\n\t\t\tfilter_performance(\" [w: %d, h: %d, roi-w:%d, roi-h:%d, channels: %d, pixelsize: %d, rowstride: %d]\",\n\t\t\t\timage->w, image->h, iw, ih, image->channels, image->pixelsize, image->rowstride);\n\t\tfilter_performance(\"\\n\");\n\t}\n#endif\n\tg_assert(RS_IS_IMAGE16(image) || (image == NULL));\n\tlast_elapsed += elapsed;\n\n\tcount--;\n\tif (count == -1)\n\t{\n\t\tlast_elapsed = 0.0;\n\t\tif (g_timer_elapsed(gt,NULL) > CHAIN_PERF_ELAPSED_MIN)\n\t\t\tfilter_performance(\"Complete 16 bit chain took: \\033[32m%.0f\\033[0mms\\n\\n\", g_timer_elapsed(gt, NULL)*1000.0);\n\t\trs_filter_param_set_float(RS_FILTER_PARAM(response), \"16-bit-time\", g_timer_elapsed(gt, NULL));\n\t\tg_timer_destroy(gt);\n\t}\n\t\n\tif (image)\n\t\tg_object_unref(image);\n\n\treturn response;\n}\n\n\n/**\n * Get 8 bit output image from a RSFilter\n * @param filter A RSFilter\n * @param param A RSFilterRequest defining parameters for a image request\n * @return A RS_IMAGE16, this must be unref'ed\n */\nRSFilterResponse *\nrs_filter_get_image8(RSFilter *filter, const RSFilterRequest *request)\n{\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tRS_DEBUG(FILTERS, \"rs_filter_get_image8(%s [%p])\", RS_FILTER_NAME(filter), filter);\n\n\t/* This timer-hack will break badly when multithreaded! */\n\tstatic gfloat last_elapsed = 0.0;\n\tstatic gint count = -1;\n\tgfloat elapsed, temp;\n\tstatic GTimer *gt = NULL;\n\n\tRSFilterResponse *response = NULL;\n\tGdkPixbuf *image = NULL;\n\tGdkRectangle* roi = NULL;\n\tRSFilterRequest *r = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tif (count == -1)\n\t\tgt = g_timer_new();\n\tcount++;\n\n\tif (filter->enabled && (roi = rs_filter_request_get_roi(request)))\n\t{\n\t\troi = clamp_roi(roi, filter, request);\n\t\tif (roi)\n\t\t{\n\t\t\tr = rs_filter_request_clone(request);\n\t\t\trs_filter_request_set_roi(r, roi);\n\t\t\trequest = r;\n\t\t}\n\t}\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_image8 && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_image8(filter, request);\n\telse if (filter->previous)\n\t\tresponse = rs_filter_get_image8(filter->previous, request);\n\n\tg_assert(RS_IS_FILTER_RESPONSE(response));\n\n\timage = rs_filter_response_get_image8(response);\n\telapsed = g_timer_elapsed(gt, NULL) - last_elapsed;\n\n\t/* Subtract 16 bit time */\n\tif (rs_filter_param_get_float(RS_FILTER_PARAM(response), \"16-bit-time\", &temp))\n\t\telapsed -= temp;\n\n\tif (roi)\n\t\tg_free(roi);\n\tif (r)\n\t\tg_object_unref(r);\n\n#ifdef FILTER_SHOW_PERFORMANCE\n\tif ((elapsed > FILTER_PERF_ELAPSED_MIN) && (image != NULL)) {\n\t\tgint iw = gdk_pixbuf_get_width(image);\n\t\tgint ih = gdk_pixbuf_get_height(image);\n\t\tif (rs_filter_response_get_roi(response)) \n\t\t{\n\t\t\tGdkRectangle *roi = rs_filter_response_get_roi(response);\n\t\t\tiw = roi->width;\n\t\t\tih = roi->height;\n\t\t}\n\t\tfilter_performance(\"%s took: \\033[32m%.0f\\033[0mms\", RS_FILTER_NAME(filter), elapsed * 1000);\n\t\tfilter_performance(\" [\\033[33m%.01f\\033[0mMpix/s]\", ((gfloat)(iw * ih)) / elapsed / 1000000.0);\n\t\tfilter_performance(\"\\n\");\n\t}\n#endif\n\n\tlast_elapsed += elapsed;\n\n\tg_assert(GDK_IS_PIXBUF(image) || (image == NULL));\n\n\tcount--;\n\tif (count == -1)\n\t{\n\t\tlast_elapsed = 0.0;\n\t\trs_filter_param_get_float(RS_FILTER_PARAM(response), \"16-bit-time\", &last_elapsed);\n\t\tlast_elapsed = g_timer_elapsed(gt, NULL)-last_elapsed;\n\t\tif (last_elapsed > CHAIN_PERF_ELAPSED_MIN)\n\t\t\tfilter_performance(\"Complete 8 bit chain took: \\033[32m%.0f\\033[0mms\\n\\n\", last_elapsed*1000.0);\n\t\tg_timer_destroy(gt);\n\t\tlast_elapsed = 0.0;\n\t}\n\n\tif (image)\n\t\tg_object_unref(image);\n\n\treturn response;\n}\n\n/**\n * Get predicted size of a RSFilter\n * @param filter A RSFilter\n * @param request A RSFilterRequest defining parameters for the request\n */\nRSFilterResponse *\nrs_filter_get_size(RSFilter *filter, const RSFilterRequest *request)\n{\n\tRSFilterResponse *response = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_size && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_size(filter, request);\n\telse if (filter->previous)\n\t\tresponse = rs_filter_get_size(filter->previous, request);\n\n\treturn response;\n}\n\n/**\n * Get predicted size of a RSFilter\n * @param filter A RSFilter\n * @param request A RSFilterRequest defining parameters for the request\n * @param width A pointer to a gint where the width will be written or NULL\n * @param height A pointer to a gint where the height will be written or NULL\n * @return TRUE if width/height is known, FALSE otherwise\n */\ngboolean\nrs_filter_get_size_simple(RSFilter *filter, const RSFilterRequest *request, gint *width, gint *height)\n{\n\tgint w, h;\n\tRSFilterResponse *response;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), FALSE);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), FALSE);\n\n\tresponse = rs_filter_get_size(filter, request);\n\n\tif (!RS_IS_FILTER_RESPONSE(response))\n\t\treturn FALSE;\n\n\tw = rs_filter_response_get_width(response);\n\th = rs_filter_response_get_height(response);\n\tif (width)\n\t\t*width = w;\n\tif (height)\n\t\t*height = h;\n\n\tg_object_unref(response);\n\n\treturn ((w>0) && (h>0));\n}\n\n/**\n * Set a GObject property on zero or more filters above #filter recursively\n * @param filter A RSFilter\n * @param ... Pairs of property names and values followed by NULL\n */\nvoid\nrs_filter_set_recursive(RSFilter *filter, ...)\n{\n\tva_list ap;\n\tgchar *property_name;\n\tRSFilter *current_filter;\n\tGParamSpec *spec;\n\tRSFilter *first_seen_here = NULL;\n\tGTypeValueTable *table = NULL;\n\tGType type = 0;\n\tunion CValue {\n\t\tgint     v_int;\n\t\tglong    v_long;\n\t\tgint64   v_int64;\n\t\tgdouble  v_double;\n\t\tgpointer v_pointer;\n\t} value;\n\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tva_start(ap, filter);\n\n\t/* Loop through all properties */\n\twhile ((property_name = va_arg(ap, gchar *)))\n\t{\n\t\t/* We set table to NULL for every property to indicate that we (again)\n\t\t * have an \"unknown\" type */\n\t\ttable = NULL;\n\n\t\tcurrent_filter = filter;\n\t\t/* Iterate through all filters previous to filter */\n\t\tdo {\n\t\t\tif ((spec = g_object_class_find_property(G_OBJECT_GET_CLASS(current_filter), property_name)))\n\t\t\t\tif (spec->flags & G_PARAM_WRITABLE)\n\t\t\t\t{\n\t\t\t\t\t/* If we got no GTypeValueTable at this point, we aquire\n\t\t\t\t\t * one. We rely on all filters using the same type for all\n\t\t\t\t\t * properties equally named */\n\t\t\t\t\tif (!table)\n\t\t\t\t\t{\n\t\t\t\t\t\tfirst_seen_here = current_filter;\n\t\t\t\t\t\ttype = spec->value_type;\n\t\t\t\t\t\ttable = g_type_value_table_peek(type);\n\n\t\t\t\t\t\t/* If we have no valuetable, we're screwed, bail out */\n\t\t\t\t\t\tif (!table)\n\t\t\t\t\t\t\tg_error(\"No GTypeValueTable found for '%s'\", g_type_name(type));\n\n\t\t\t\t\t\tswitch (table->collect_format[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'i': value.v_int = va_arg(ap, gint); break;\n\t\t\t\t\t\t\tcase 'l': value.v_long = va_arg(ap, glong); break;\n\t\t\t\t\t\t\tcase 'd': value.v_double = va_arg(ap, gdouble); break;\n\t\t\t\t\t\t\tcase 'p': value.v_pointer = va_arg(ap, gpointer); break;\n\t\t\t\t\t\t\tdefault: g_error(\"Don't know how to collect for '%s'\", g_type_name(type)); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (table)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We try to catch cases where different filters use\n\t\t\t\t\t\t * the same property name for different types */\n\t\t\t\t\t\tif (type != spec->value_type)\n\t\t\t\t\t\t\tg_warning(\"Diverging types found for property '%s' (on filter '%s' and '%s')\",\n\t\t\t\t\t\t\t\tproperty_name,\n\t\t\t\t\t\t\t\tRS_FILTER_NAME(first_seen_here),\n\t\t\t\t\t\t\t\tRS_FILTER_NAME(current_filter));\n\n\t\t\t\t\t\tswitch (table->collect_format[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'i': g_object_set(current_filter, property_name, value.v_int, NULL); break;\n\t\t\t\t\t\t\tcase 'l': g_object_set(current_filter, property_name, value.v_long, NULL); break;\n\t\t\t\t\t\t\tcase 'd': g_object_set(current_filter, property_name, value.v_double, NULL); break;\n\t\t\t\t\t\t\tcase 'p': g_object_set(current_filter, property_name, value.v_pointer, NULL); break;\n\t\t\t\t\t\t\tdefault: break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t} while (RS_IS_FILTER(current_filter = current_filter->previous));\n\t\tif (!table)\n\t\t{\n//\t\t\tg_warning(\"Property: %s could not be found in filter chain. Skipping further properties\", property_name);\n\t\t\tva_end(ap);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tva_end(ap);\n}\n\n/**\n * Get a GObject property from a RSFilter chain recursively\n * @param filter A RSFilter\n * @param ... Pairs of property names and a return pointers followed by NULL\n */\nvoid\nrs_filter_get_recursive(RSFilter *filter, ...)\n{\n\tva_list ap;\n\tgchar *property_name;\n\tgpointer property_ret;\n\tRSFilter *current_filter;\n\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tva_start(ap, filter);\n\n\t/* Loop through all properties */\n\twhile ((property_name = va_arg(ap, gchar *)))\n\t{\n\t\tproperty_ret = va_arg(ap, gpointer);\n\n\t\tg_assert(property_ret != NULL);\n\n\t\tcurrent_filter = filter;\n\t\t/* Iterate through all filter previous to filter */\n\t\tdo {\n\t\t\tif (current_filter->enabled && g_object_class_find_property(G_OBJECT_GET_CLASS(current_filter), property_name))\n\t\t\t{\n\t\t\t\tg_object_get(current_filter, property_name, property_ret, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (RS_IS_FILTER(current_filter = current_filter->previous));\n\t}\n\n\tva_end(ap);\n}\n\n/**\n * Set enabled state of a RSFilter\n * @param filter A RSFilter\n * @param enabled TRUE to enable filter, FALSE to disable\n * @return Previous state\n */\ngboolean\nrs_filter_set_enabled(RSFilter *filter, gboolean enabled)\n{\n\tgboolean previous_state;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), FALSE);\n\n\tprevious_state = filter->enabled;\n\n\tif (filter->enabled != enabled)\n\t{\n\t\tfilter->enabled = enabled;\n\t\trs_filter_changed(filter, RS_FILTER_CHANGED_PIXELDATA);\n\t}\n\n\treturn previous_state;\n}\n\n/**\n * Get enabled state of a RSFilter\n * @param filter A RSFilter\n * @return TRUE if filter is enabled, FALSE if disabled\n */\ngboolean\nrs_filter_get_enabled(RSFilter *filter)\n{\n\tg_return_val_if_fail(RS_IS_FILTER(filter), FALSE);\n\n\treturn filter->enabled;\n}\n\n/**\n * Set a label for a RSFilter - only used for debugging\n * @param filter A RSFilter\n * @param label A new label for the RSFilter, this will NOT be copied\n */\nextern void\nrs_filter_set_label(RSFilter *filter, const gchar *label)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tfilter->label = label;\t\n}\n\n/**\n * Get the label for a RSFilter\n * @param filter A RSFilter\n * @return The label for the RSFilter or NULL\n */\nconst gchar *\nrs_filter_get_label(RSFilter *filter)\n{\n\tg_return_val_if_fail(RS_IS_FILTER(filter), \"\");\n\n\treturn filter->label;\n}\n\nstatic void\nrs_filter_graph_helper(GString *str, RSFilter *filter)\n{\n\tg_assert(str != NULL);\n\tg_assert(RS_IS_FILTER(filter));\n\n\tg_string_append_printf(str, \"\\\"%p\\\" [\\n\\tshape=\\\"Mrecord\\\"\\n\", filter);\n\t\n\tif (!g_str_equal(RS_FILTER_NAME(filter), \"RSCache\"))\n\t\tg_string_append_printf(str, \"\\tcolor=grey\\n\\tstyle=filled\\n\");\n\n\tif (filter->enabled)\n\t\tg_string_append_printf(str, \"\\tcolor=\\\"#66ba66\\\"\\n\");\n\telse\n\t\tg_string_append_printf(str, \"\\tcolor=grey\\n\");\n\t\t\n\tg_string_append_printf(str, \"\\tlabel=<<table cellborder=\\\"0\\\" border=\\\"0\\\">\\n\");\n\n\tGObjectClass *klass = G_OBJECT_GET_CLASS(filter);\n\tGParamSpec **specs;\n\tgint i;\n\tguint n_specs = 0;\n\n\t/* Filter name (and label) */\n\tg_string_append_printf(str, \"\\t\\t<tr>\\n\\t\\t\\t<td colspan=\\\"2\\\" bgcolor=\\\"black\\\"><font color=\\\"white\\\">%s\", RS_FILTER_NAME(filter));\n\tif (filter->label)\n\t\tg_string_append_printf(str, \" (%s)\", filter->label);\n\tg_string_append_printf(str, \"</font></td>\\n\\t\\t</tr>\\n\");\n\n\t/* Parameter and value list */\n\tspecs = g_object_class_list_properties(G_OBJECT_CLASS(klass), &n_specs);\n\tfor(i=0; i<n_specs; i++)\n\t{\n\t\tgboolean boolean = FALSE;\n\t\tgint integer = 0;\n\t\tgfloat loat = 0.0;\n\t\tgchar *ostr = NULL;\n\n\t\tg_string_append_printf(str, \"\\t\\t<tr>\\n\\t\\t\\t<td align=\\\"right\\\">%s:</td>\\n\\t\\t\\t<td align=\\\"left\\\">\", specs[i]->name);\n\t\t/* We have to use if/else here, because RS_TYPE_* does not resolve to a constant */\n\t\tif (G_PARAM_SPEC_VALUE_TYPE(specs[i]) == RS_TYPE_LENS)\n\t\t{\n\t\t\tRSLens *lens;\n\t\t\tgchar *identifier;\n\n\t\t\tg_object_get(filter, specs[i]->name, &lens, NULL);\n\t\t\tif (lens)\n\t\t\t{\n\t\t\t\tg_object_get(lens, \"identifier\", &identifier, NULL);\n\t\t\t\tg_object_unref(lens);\n\n\t\t\t\tg_string_append_printf(str, \"%s\", identifier);\n\n\t\t\t\tg_free(identifier);\n\t\t\t}\n\t\t\telse\n\t\t\t\tg_string_append_printf(str, \"n/a\");\n\t\t}\n\t\telse if (G_PARAM_SPEC_VALUE_TYPE(specs[i]) == RS_TYPE_ICC_PROFILE)\n\t\t{\n\t\t\tRSIccProfile *profile;\n\t\t\tgchar *profile_filename;\n\t\t\tgchar *profile_basename;\n\n\t\t\tg_object_get(filter, specs[i]->name, &profile, NULL);\n\t\t\tg_object_get(profile, \"filename\", &profile_filename, NULL);\n\t\t\tg_object_unref(profile);\n\t\t\tprofile_basename = g_path_get_basename (profile_filename);\n\t\t\tg_free(profile_filename);\n\n\t\t\tg_string_append_printf(str, \"%s\", profile_basename);\n\t\t\tg_free(profile_basename);\n\t\t}\n\t\telse\n\t\t\tswitch (G_PARAM_SPEC_VALUE_TYPE(specs[i]))\n\t\t\t{\n\t\t\t\tcase G_TYPE_BOOLEAN:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &boolean, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%s\", (boolean) ? \"TRUE\" : \"FALSE\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase G_TYPE_INT:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &integer, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%d\", integer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase G_TYPE_FLOAT:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &loat, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%.05f\", loat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase G_TYPE_STRING:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &ostr, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%s\", ostr);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_string_append_printf(str, \"n/a\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tg_string_append_printf(str, \"</td>\\n\\t\\t</tr>\\n\");\n\t}\n\n\tg_string_append_printf(str, \"\\t\\t</table>>\\n\\t];\\n\");\n\n\tgint n_next = g_slist_length(filter->next_filters);\n\n\tfor(i=0; i<n_next; i++)\n\t{\n\t\tRSFilter *next = RS_FILTER(g_slist_nth_data(filter->next_filters, i));\n\t\tRSFilterResponse *response = rs_filter_get_size(filter, RS_FILTER_REQUEST_QUICK);\n\n\t\t/* Edge - print dimensions along */\n\t\tg_string_append_printf(str, \"\\t\\\"%p\\\" -> \\\"%p\\\" [label=\\\" %dx%d\\\"];\\n\",\n\t\t\tfilter, next,\n\t\t\trs_filter_response_get_width(response), rs_filter_response_get_height(response));\n\t\tg_object_unref(response);\n\n\t\t/* Recursively call ourself for every \"next\" filter */\n\t\trs_filter_graph_helper(str, next);\n\t}\n}\n\n/**\n * Draw a nice graph of the filter chain\n * note: Requires graphviz\n * @param filter The top-most filter to graph\n */\nvoid\nrs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\n\tg_string_free(str, TRUE);\n}\n"], "fixing_code": ["/*\n * * Copyright (C) 2006-2011 Anders Brander <anders@brander.dk>, \n * * Anders Kvist <akv@lnxbx.dk> and Klaus Post <klauspost@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n#include <stdlib.h> /* system() */\n#include <rawstudio.h>\n#include \"rs-filter.h\"\n\n#if 0 /* Change to 1 to enable performance info */\n#define filter_performance printf\n#define FILTER_SHOW_PERFORMANCE\n#else\n#define filter_performance(...) {}\n#endif\n\n/* How much time should a filter at least have taken to show performance number */\n#define FILTER_PERF_ELAPSED_MIN 0.001\n#define CHAIN_PERF_ELAPSED_MIN 0.001\n\nG_DEFINE_TYPE (RSFilter, rs_filter, G_TYPE_OBJECT)\n\nenum {\n  CHANGED_SIGNAL,\n  LAST_SIGNAL\n};\n\nstatic guint signals[LAST_SIGNAL] = { 0 };\n\nstatic void\ndispose(GObject *obj)\n{\n\tRSFilter *filter = RS_FILTER(obj);\n\n\tif (!filter->dispose_has_run)\n\t{\n\t\tfilter->dispose_has_run = TRUE;\n\t\tif (filter->previous)\n\t\t{\n\t\t\tfilter->previous->next_filters = g_slist_remove(filter->previous->next_filters, filter);\n\t\t\tg_object_unref(filter->previous);\n\t\t}\n\t}\n}\n\nstatic void\nrs_filter_class_init(RSFilterClass *klass)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_class_init(%p)\", klass);\n\tGObjectClass *object_class = G_OBJECT_CLASS(klass);\n\n\tsignals[CHANGED_SIGNAL] = g_signal_new (\"changed\",\n\t\tG_TYPE_FROM_CLASS (klass),\n\t\tG_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,\n\t\t0,\n\t\tNULL, \n\t\tNULL,                \n\t\tg_cclosure_marshal_VOID__INT,\n\t\tG_TYPE_NONE, 1, G_TYPE_INT);\n\n\tklass->get_image = NULL;\n\tklass->get_image8 = NULL;\n\tklass->get_size = NULL;\n\tklass->previous_changed = NULL;\n\n\tobject_class->dispose = dispose;\n}\n\nstatic void\nrs_filter_init(RSFilter *self)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_init(%p)\", self);\n\tself->previous = NULL;\n\tself->next_filters = NULL;\n\tself->enabled = TRUE;\n}\n\n/**\n * Return a new instance of a RSFilter\n * @param name The name of the filter\n * @param previous The previous filter or NULL\n * @return The newly instantiated RSFilter or NULL\n */\nRSFilter *\nrs_filter_new(const gchar *name, RSFilter *previous)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_new(%s, %s [%p])\", name, RS_FILTER_NAME(previous), previous);\n\tg_return_val_if_fail(name != NULL, NULL);\n\tg_return_val_if_fail((previous == NULL) || RS_IS_FILTER(previous), NULL);\n\n\tGType type = g_type_from_name(name);\n\tRSFilter *filter = NULL;\n\n\tif (g_type_is_a (type, RS_TYPE_FILTER))\n\t\tfilter = g_object_new(type, NULL);\n\n\tif (!RS_IS_FILTER(filter))\n\t\tg_warning(\"Could not instantiate filter of type \\\"%s\\\"\", name);\n\n\tif (previous)\n\t\trs_filter_set_previous(filter, previous);\n\n\treturn filter;\n}\n\n/**\n * Set the previous RSFilter in a RSFilter-chain\n * @param filter A RSFilter\n * @param previous A previous RSFilter\n */\nvoid\nrs_filter_set_previous(RSFilter *filter, RSFilter *previous)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_set_previous(%p, %p)\", filter, previous);\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tg_return_if_fail(RS_IS_FILTER(previous));\n\n\t/* We will only set the previous filter if it differs from current previous filter */\n\tif (filter->previous != previous)\n\t{\n\t\tif (filter->previous)\n\t\t{\n\t\t\t/* If we already got a previous filter, clean up */\n\t\t\tfilter->previous->next_filters = g_slist_remove(filter->previous->next_filters, filter);\n\t\t\tg_object_unref(filter->previous);\n\t\t}\n\t\tfilter->previous = g_object_ref(previous);\n\n\t\tprevious->next_filters = g_slist_append(previous->next_filters, filter);\n\t}\n}\n\n/**\n * Signal that a filter has changed, filters depending on this will be invoked\n * This should only be called from filter code\n * @param filter The changed filter\n * @param mask A mask indicating what changed\n */\nvoid\nrs_filter_changed(RSFilter *filter, RSFilterChangedMask mask)\n{\n\tRS_DEBUG(FILTERS, \"rs_filter_changed(%s [%p], %04x)\", RS_FILTER_NAME(filter), filter, mask);\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tgint i, n_next = g_slist_length(filter->next_filters);\n\n\tfor(i=0; i<n_next; i++)\n\t{\n\t\tRSFilter *next = RS_FILTER(g_slist_nth_data(filter->next_filters, i));\n\n\t\tg_assert(RS_IS_FILTER(next));\n\n\t\t/* Notify \"next\" filter or try \"next next\" filter */\n\t\tif (RS_FILTER_GET_CLASS(next)->previous_changed)\n\t\t\tRS_FILTER_GET_CLASS(next)->previous_changed(next, filter, mask);\n\t\telse\n\t\t\trs_filter_changed(next, mask);\n\t}\n\n\tg_signal_emit(G_OBJECT(filter), signals[CHANGED_SIGNAL], 0, mask);\n}\n\n/* Clamps ROI rectangle to image size */\n/* Returns a new rectangle, or NULL if ROI was within bounds*/\n\nstatic GdkRectangle* \nclamp_roi(const GdkRectangle *roi, RSFilter *filter, const RSFilterRequest *request)\n{\n\tRSFilterResponse *response = rs_filter_get_size(filter, request);\n\tgint w = rs_filter_response_get_width(response);\n\tgint h = rs_filter_response_get_height(response);\n\tg_object_unref(response);\n\n\tif ((roi->x >= 0) && (roi->y >=0) && (roi->x + roi->width <= w) && (roi->y + roi->height <= h))\n\t\treturn NULL;\n\n\tGdkRectangle* new_roi = g_new(GdkRectangle, 1);\n\tnew_roi->x = MAX(0, roi->x);\n\tnew_roi->y = MAX(0, roi->y);\n\tnew_roi->width = MIN(w - new_roi->x, roi->width);\n\tnew_roi->height = MAX(h - new_roi->y, roi->height);\n\treturn new_roi;\n}\n\n/**\n * Get the output image from a RSFilter\n * @param filter A RSFilter\n * @param param A RSFilterRequest defining parameters for a image request\n * @return A RS_IMAGE16, this must be unref'ed\n */\nRSFilterResponse *\nrs_filter_get_image(RSFilter *filter, const RSFilterRequest *request)\n{\n\tGdkRectangle* roi = NULL;\n\tRSFilterRequest *r = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tRS_DEBUG(FILTERS, \"rs_filter_get_image(%s [%p])\", RS_FILTER_NAME(filter), filter);\n\n\t/* This timer-hack will break badly when multithreaded! */\n\tstatic gfloat last_elapsed = 0.0;\n\tstatic gint count = -1;\n\tgfloat elapsed;\n\tstatic GTimer *gt = NULL;\n\n\tRSFilterResponse *response;\n\tRS_IMAGE16 *image;\n\n\tif (count == -1)\n\t\tgt = g_timer_new();\n\tcount++;\n\n\tif (filter->enabled && (roi = rs_filter_request_get_roi(request)))\n\t{\n\t\troi = clamp_roi(roi, filter, request);\n\t\tif (roi)\n\t\t{\n\t\t\tr = rs_filter_request_clone(request);\n\t\t\trs_filter_request_set_roi(r, roi);\n\t\t\trequest = r;\n\t\t}\n\t}\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_image && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_image(filter, request);\n\telse\n\t\tresponse = rs_filter_get_image(filter->previous, request);\n\n\tg_assert(RS_IS_FILTER_RESPONSE(response));\n\n\timage = rs_filter_response_get_image(response);\n\n\telapsed = g_timer_elapsed(gt, NULL) - last_elapsed;\n\n\tif (roi)\n\t\tg_free(roi);\n\tif (r)\n\t\tg_object_unref(r);\n\n#ifdef FILTER_SHOW_PERFORMANCE\n\tif ((elapsed > FILTER_PERF_ELAPSED_MIN) && (image != NULL)) \n\t{\n\t\tgint iw = image->w;\n\t\tgint ih = image->h;\n\t\tif (rs_filter_response_get_roi(response)) \n\t\t{\n\t\t\troi = rs_filter_response_get_roi(response);\n\t\t\tiw = roi->width;\n\t\t\tih = roi->height;\n\t\t}\n\t\tfilter_performance(\"%s took: \\033[32m%.0f\\033[0mms\", RS_FILTER_NAME(filter), elapsed*1000);\n\t\tif ((elapsed > 0.001) && (image != NULL))\n\t\t\tfilter_performance(\" [\\033[33m%.01f\\033[0mMpix/s]\", ((gfloat)(iw*ih))/elapsed/1000000.0);\n\t\tif (image)\n\t\t\tfilter_performance(\" [w: %d, h: %d, roi-w:%d, roi-h:%d, channels: %d, pixelsize: %d, rowstride: %d]\",\n\t\t\t\timage->w, image->h, iw, ih, image->channels, image->pixelsize, image->rowstride);\n\t\tfilter_performance(\"\\n\");\n\t}\n#endif\n\tg_assert(RS_IS_IMAGE16(image) || (image == NULL));\n\tlast_elapsed += elapsed;\n\n\tcount--;\n\tif (count == -1)\n\t{\n\t\tlast_elapsed = 0.0;\n\t\tif (g_timer_elapsed(gt,NULL) > CHAIN_PERF_ELAPSED_MIN)\n\t\t\tfilter_performance(\"Complete 16 bit chain took: \\033[32m%.0f\\033[0mms\\n\\n\", g_timer_elapsed(gt, NULL)*1000.0);\n\t\trs_filter_param_set_float(RS_FILTER_PARAM(response), \"16-bit-time\", g_timer_elapsed(gt, NULL));\n\t\tg_timer_destroy(gt);\n\t}\n\t\n\tif (image)\n\t\tg_object_unref(image);\n\n\treturn response;\n}\n\n\n/**\n * Get 8 bit output image from a RSFilter\n * @param filter A RSFilter\n * @param param A RSFilterRequest defining parameters for a image request\n * @return A RS_IMAGE16, this must be unref'ed\n */\nRSFilterResponse *\nrs_filter_get_image8(RSFilter *filter, const RSFilterRequest *request)\n{\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tRS_DEBUG(FILTERS, \"rs_filter_get_image8(%s [%p])\", RS_FILTER_NAME(filter), filter);\n\n\t/* This timer-hack will break badly when multithreaded! */\n\tstatic gfloat last_elapsed = 0.0;\n\tstatic gint count = -1;\n\tgfloat elapsed, temp;\n\tstatic GTimer *gt = NULL;\n\n\tRSFilterResponse *response = NULL;\n\tGdkPixbuf *image = NULL;\n\tGdkRectangle* roi = NULL;\n\tRSFilterRequest *r = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tif (count == -1)\n\t\tgt = g_timer_new();\n\tcount++;\n\n\tif (filter->enabled && (roi = rs_filter_request_get_roi(request)))\n\t{\n\t\troi = clamp_roi(roi, filter, request);\n\t\tif (roi)\n\t\t{\n\t\t\tr = rs_filter_request_clone(request);\n\t\t\trs_filter_request_set_roi(r, roi);\n\t\t\trequest = r;\n\t\t}\n\t}\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_image8 && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_image8(filter, request);\n\telse if (filter->previous)\n\t\tresponse = rs_filter_get_image8(filter->previous, request);\n\n\tg_assert(RS_IS_FILTER_RESPONSE(response));\n\n\timage = rs_filter_response_get_image8(response);\n\telapsed = g_timer_elapsed(gt, NULL) - last_elapsed;\n\n\t/* Subtract 16 bit time */\n\tif (rs_filter_param_get_float(RS_FILTER_PARAM(response), \"16-bit-time\", &temp))\n\t\telapsed -= temp;\n\n\tif (roi)\n\t\tg_free(roi);\n\tif (r)\n\t\tg_object_unref(r);\n\n#ifdef FILTER_SHOW_PERFORMANCE\n\tif ((elapsed > FILTER_PERF_ELAPSED_MIN) && (image != NULL)) {\n\t\tgint iw = gdk_pixbuf_get_width(image);\n\t\tgint ih = gdk_pixbuf_get_height(image);\n\t\tif (rs_filter_response_get_roi(response)) \n\t\t{\n\t\t\tGdkRectangle *roi = rs_filter_response_get_roi(response);\n\t\t\tiw = roi->width;\n\t\t\tih = roi->height;\n\t\t}\n\t\tfilter_performance(\"%s took: \\033[32m%.0f\\033[0mms\", RS_FILTER_NAME(filter), elapsed * 1000);\n\t\tfilter_performance(\" [\\033[33m%.01f\\033[0mMpix/s]\", ((gfloat)(iw * ih)) / elapsed / 1000000.0);\n\t\tfilter_performance(\"\\n\");\n\t}\n#endif\n\n\tlast_elapsed += elapsed;\n\n\tg_assert(GDK_IS_PIXBUF(image) || (image == NULL));\n\n\tcount--;\n\tif (count == -1)\n\t{\n\t\tlast_elapsed = 0.0;\n\t\trs_filter_param_get_float(RS_FILTER_PARAM(response), \"16-bit-time\", &last_elapsed);\n\t\tlast_elapsed = g_timer_elapsed(gt, NULL)-last_elapsed;\n\t\tif (last_elapsed > CHAIN_PERF_ELAPSED_MIN)\n\t\t\tfilter_performance(\"Complete 8 bit chain took: \\033[32m%.0f\\033[0mms\\n\\n\", last_elapsed*1000.0);\n\t\tg_timer_destroy(gt);\n\t\tlast_elapsed = 0.0;\n\t}\n\n\tif (image)\n\t\tg_object_unref(image);\n\n\treturn response;\n}\n\n/**\n * Get predicted size of a RSFilter\n * @param filter A RSFilter\n * @param request A RSFilterRequest defining parameters for the request\n */\nRSFilterResponse *\nrs_filter_get_size(RSFilter *filter, const RSFilterRequest *request)\n{\n\tRSFilterResponse *response = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_size && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_size(filter, request);\n\telse if (filter->previous)\n\t\tresponse = rs_filter_get_size(filter->previous, request);\n\n\treturn response;\n}\n\n/**\n * Get predicted size of a RSFilter\n * @param filter A RSFilter\n * @param request A RSFilterRequest defining parameters for the request\n * @param width A pointer to a gint where the width will be written or NULL\n * @param height A pointer to a gint where the height will be written or NULL\n * @return TRUE if width/height is known, FALSE otherwise\n */\ngboolean\nrs_filter_get_size_simple(RSFilter *filter, const RSFilterRequest *request, gint *width, gint *height)\n{\n\tgint w, h;\n\tRSFilterResponse *response;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), FALSE);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), FALSE);\n\n\tresponse = rs_filter_get_size(filter, request);\n\n\tif (!RS_IS_FILTER_RESPONSE(response))\n\t\treturn FALSE;\n\n\tw = rs_filter_response_get_width(response);\n\th = rs_filter_response_get_height(response);\n\tif (width)\n\t\t*width = w;\n\tif (height)\n\t\t*height = h;\n\n\tg_object_unref(response);\n\n\treturn ((w>0) && (h>0));\n}\n\n/**\n * Set a GObject property on zero or more filters above #filter recursively\n * @param filter A RSFilter\n * @param ... Pairs of property names and values followed by NULL\n */\nvoid\nrs_filter_set_recursive(RSFilter *filter, ...)\n{\n\tva_list ap;\n\tgchar *property_name;\n\tRSFilter *current_filter;\n\tGParamSpec *spec;\n\tRSFilter *first_seen_here = NULL;\n\tGTypeValueTable *table = NULL;\n\tGType type = 0;\n\tunion CValue {\n\t\tgint     v_int;\n\t\tglong    v_long;\n\t\tgint64   v_int64;\n\t\tgdouble  v_double;\n\t\tgpointer v_pointer;\n\t} value;\n\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tva_start(ap, filter);\n\n\t/* Loop through all properties */\n\twhile ((property_name = va_arg(ap, gchar *)))\n\t{\n\t\t/* We set table to NULL for every property to indicate that we (again)\n\t\t * have an \"unknown\" type */\n\t\ttable = NULL;\n\n\t\tcurrent_filter = filter;\n\t\t/* Iterate through all filters previous to filter */\n\t\tdo {\n\t\t\tif ((spec = g_object_class_find_property(G_OBJECT_GET_CLASS(current_filter), property_name)))\n\t\t\t\tif (spec->flags & G_PARAM_WRITABLE)\n\t\t\t\t{\n\t\t\t\t\t/* If we got no GTypeValueTable at this point, we aquire\n\t\t\t\t\t * one. We rely on all filters using the same type for all\n\t\t\t\t\t * properties equally named */\n\t\t\t\t\tif (!table)\n\t\t\t\t\t{\n\t\t\t\t\t\tfirst_seen_here = current_filter;\n\t\t\t\t\t\ttype = spec->value_type;\n\t\t\t\t\t\ttable = g_type_value_table_peek(type);\n\n\t\t\t\t\t\t/* If we have no valuetable, we're screwed, bail out */\n\t\t\t\t\t\tif (!table)\n\t\t\t\t\t\t\tg_error(\"No GTypeValueTable found for '%s'\", g_type_name(type));\n\n\t\t\t\t\t\tswitch (table->collect_format[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'i': value.v_int = va_arg(ap, gint); break;\n\t\t\t\t\t\t\tcase 'l': value.v_long = va_arg(ap, glong); break;\n\t\t\t\t\t\t\tcase 'd': value.v_double = va_arg(ap, gdouble); break;\n\t\t\t\t\t\t\tcase 'p': value.v_pointer = va_arg(ap, gpointer); break;\n\t\t\t\t\t\t\tdefault: g_error(\"Don't know how to collect for '%s'\", g_type_name(type)); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (table)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We try to catch cases where different filters use\n\t\t\t\t\t\t * the same property name for different types */\n\t\t\t\t\t\tif (type != spec->value_type)\n\t\t\t\t\t\t\tg_warning(\"Diverging types found for property '%s' (on filter '%s' and '%s')\",\n\t\t\t\t\t\t\t\tproperty_name,\n\t\t\t\t\t\t\t\tRS_FILTER_NAME(first_seen_here),\n\t\t\t\t\t\t\t\tRS_FILTER_NAME(current_filter));\n\n\t\t\t\t\t\tswitch (table->collect_format[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'i': g_object_set(current_filter, property_name, value.v_int, NULL); break;\n\t\t\t\t\t\t\tcase 'l': g_object_set(current_filter, property_name, value.v_long, NULL); break;\n\t\t\t\t\t\t\tcase 'd': g_object_set(current_filter, property_name, value.v_double, NULL); break;\n\t\t\t\t\t\t\tcase 'p': g_object_set(current_filter, property_name, value.v_pointer, NULL); break;\n\t\t\t\t\t\t\tdefault: break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t} while (RS_IS_FILTER(current_filter = current_filter->previous));\n\t\tif (!table)\n\t\t{\n//\t\t\tg_warning(\"Property: %s could not be found in filter chain. Skipping further properties\", property_name);\n\t\t\tva_end(ap);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tva_end(ap);\n}\n\n/**\n * Get a GObject property from a RSFilter chain recursively\n * @param filter A RSFilter\n * @param ... Pairs of property names and a return pointers followed by NULL\n */\nvoid\nrs_filter_get_recursive(RSFilter *filter, ...)\n{\n\tva_list ap;\n\tgchar *property_name;\n\tgpointer property_ret;\n\tRSFilter *current_filter;\n\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tva_start(ap, filter);\n\n\t/* Loop through all properties */\n\twhile ((property_name = va_arg(ap, gchar *)))\n\t{\n\t\tproperty_ret = va_arg(ap, gpointer);\n\n\t\tg_assert(property_ret != NULL);\n\n\t\tcurrent_filter = filter;\n\t\t/* Iterate through all filter previous to filter */\n\t\tdo {\n\t\t\tif (current_filter->enabled && g_object_class_find_property(G_OBJECT_GET_CLASS(current_filter), property_name))\n\t\t\t{\n\t\t\t\tg_object_get(current_filter, property_name, property_ret, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (RS_IS_FILTER(current_filter = current_filter->previous));\n\t}\n\n\tva_end(ap);\n}\n\n/**\n * Set enabled state of a RSFilter\n * @param filter A RSFilter\n * @param enabled TRUE to enable filter, FALSE to disable\n * @return Previous state\n */\ngboolean\nrs_filter_set_enabled(RSFilter *filter, gboolean enabled)\n{\n\tgboolean previous_state;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), FALSE);\n\n\tprevious_state = filter->enabled;\n\n\tif (filter->enabled != enabled)\n\t{\n\t\tfilter->enabled = enabled;\n\t\trs_filter_changed(filter, RS_FILTER_CHANGED_PIXELDATA);\n\t}\n\n\treturn previous_state;\n}\n\n/**\n * Get enabled state of a RSFilter\n * @param filter A RSFilter\n * @return TRUE if filter is enabled, FALSE if disabled\n */\ngboolean\nrs_filter_get_enabled(RSFilter *filter)\n{\n\tg_return_val_if_fail(RS_IS_FILTER(filter), FALSE);\n\n\treturn filter->enabled;\n}\n\n/**\n * Set a label for a RSFilter - only used for debugging\n * @param filter A RSFilter\n * @param label A new label for the RSFilter, this will NOT be copied\n */\nextern void\nrs_filter_set_label(RSFilter *filter, const gchar *label)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tfilter->label = label;\t\n}\n\n/**\n * Get the label for a RSFilter\n * @param filter A RSFilter\n * @return The label for the RSFilter or NULL\n */\nconst gchar *\nrs_filter_get_label(RSFilter *filter)\n{\n\tg_return_val_if_fail(RS_IS_FILTER(filter), \"\");\n\n\treturn filter->label;\n}\n\nstatic void\nrs_filter_graph_helper(GString *str, RSFilter *filter)\n{\n\tg_assert(str != NULL);\n\tg_assert(RS_IS_FILTER(filter));\n\n\tg_string_append_printf(str, \"\\\"%p\\\" [\\n\\tshape=\\\"Mrecord\\\"\\n\", filter);\n\t\n\tif (!g_str_equal(RS_FILTER_NAME(filter), \"RSCache\"))\n\t\tg_string_append_printf(str, \"\\tcolor=grey\\n\\tstyle=filled\\n\");\n\n\tif (filter->enabled)\n\t\tg_string_append_printf(str, \"\\tcolor=\\\"#66ba66\\\"\\n\");\n\telse\n\t\tg_string_append_printf(str, \"\\tcolor=grey\\n\");\n\t\t\n\tg_string_append_printf(str, \"\\tlabel=<<table cellborder=\\\"0\\\" border=\\\"0\\\">\\n\");\n\n\tGObjectClass *klass = G_OBJECT_GET_CLASS(filter);\n\tGParamSpec **specs;\n\tgint i;\n\tguint n_specs = 0;\n\n\t/* Filter name (and label) */\n\tg_string_append_printf(str, \"\\t\\t<tr>\\n\\t\\t\\t<td colspan=\\\"2\\\" bgcolor=\\\"black\\\"><font color=\\\"white\\\">%s\", RS_FILTER_NAME(filter));\n\tif (filter->label)\n\t\tg_string_append_printf(str, \" (%s)\", filter->label);\n\tg_string_append_printf(str, \"</font></td>\\n\\t\\t</tr>\\n\");\n\n\t/* Parameter and value list */\n\tspecs = g_object_class_list_properties(G_OBJECT_CLASS(klass), &n_specs);\n\tfor(i=0; i<n_specs; i++)\n\t{\n\t\tgboolean boolean = FALSE;\n\t\tgint integer = 0;\n\t\tgfloat loat = 0.0;\n\t\tgchar *ostr = NULL;\n\n\t\tg_string_append_printf(str, \"\\t\\t<tr>\\n\\t\\t\\t<td align=\\\"right\\\">%s:</td>\\n\\t\\t\\t<td align=\\\"left\\\">\", specs[i]->name);\n\t\t/* We have to use if/else here, because RS_TYPE_* does not resolve to a constant */\n\t\tif (G_PARAM_SPEC_VALUE_TYPE(specs[i]) == RS_TYPE_LENS)\n\t\t{\n\t\t\tRSLens *lens;\n\t\t\tgchar *identifier;\n\n\t\t\tg_object_get(filter, specs[i]->name, &lens, NULL);\n\t\t\tif (lens)\n\t\t\t{\n\t\t\t\tg_object_get(lens, \"identifier\", &identifier, NULL);\n\t\t\t\tg_object_unref(lens);\n\n\t\t\t\tg_string_append_printf(str, \"%s\", identifier);\n\n\t\t\t\tg_free(identifier);\n\t\t\t}\n\t\t\telse\n\t\t\t\tg_string_append_printf(str, \"n/a\");\n\t\t}\n\t\telse if (G_PARAM_SPEC_VALUE_TYPE(specs[i]) == RS_TYPE_ICC_PROFILE)\n\t\t{\n\t\t\tRSIccProfile *profile;\n\t\t\tgchar *profile_filename;\n\t\t\tgchar *profile_basename;\n\n\t\t\tg_object_get(filter, specs[i]->name, &profile, NULL);\n\t\t\tg_object_get(profile, \"filename\", &profile_filename, NULL);\n\t\t\tg_object_unref(profile);\n\t\t\tprofile_basename = g_path_get_basename (profile_filename);\n\t\t\tg_free(profile_filename);\n\n\t\t\tg_string_append_printf(str, \"%s\", profile_basename);\n\t\t\tg_free(profile_basename);\n\t\t}\n\t\telse\n\t\t\tswitch (G_PARAM_SPEC_VALUE_TYPE(specs[i]))\n\t\t\t{\n\t\t\t\tcase G_TYPE_BOOLEAN:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &boolean, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%s\", (boolean) ? \"TRUE\" : \"FALSE\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase G_TYPE_INT:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &integer, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%d\", integer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase G_TYPE_FLOAT:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &loat, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%.05f\", loat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase G_TYPE_STRING:\n\t\t\t\t\tg_object_get(filter, specs[i]->name, &ostr, NULL);\n\t\t\t\t\tg_string_append_printf(str, \"%s\", ostr);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_string_append_printf(str, \"n/a\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tg_string_append_printf(str, \"</td>\\n\\t\\t</tr>\\n\");\n\t}\n\n\tg_string_append_printf(str, \"\\t\\t</table>>\\n\\t];\\n\");\n\n\tgint n_next = g_slist_length(filter->next_filters);\n\n\tfor(i=0; i<n_next; i++)\n\t{\n\t\tRSFilter *next = RS_FILTER(g_slist_nth_data(filter->next_filters, i));\n\t\tRSFilterResponse *response = rs_filter_get_size(filter, RS_FILTER_REQUEST_QUICK);\n\n\t\t/* Edge - print dimensions along */\n\t\tg_string_append_printf(str, \"\\t\\\"%p\\\" -> \\\"%p\\\" [label=\\\" %dx%d\\\"];\\n\",\n\t\t\tfilter, next,\n\t\t\trs_filter_response_get_width(response), rs_filter_response_get_height(response));\n\t\tg_object_unref(response);\n\n\t\t/* Recursively call ourself for every \"next\" filter */\n\t\trs_filter_graph_helper(str, next);\n\t}\n}\n\n/**\n * Draw a nice graph of the filter chain\n * note: Requires graphviz\n * @param filter The top-most filter to graph\n */\nvoid\nrs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tgchar *dot_filename;\n\tgchar *png_filename;\n\tgchar *command_line;\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\n\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());\n\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n\n\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n\n\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling dot failed\");\n\tg_free(command_line);\n\n\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_free(command_line);\n\n\tg_free(dot_filename);\n\tg_free(png_filename);\n\tg_string_free(str, TRUE);\n}\n"], "filenames": ["librawstudio/rs-filter.c"], "buggy_code_start_loc": [774], "buggy_code_end_loc": [787], "fixing_code_start_loc": [775], "fixing_code_end_loc": [802], "type": "CWE-59", "message": "The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.", "other": {"cve": {"id": "CVE-2014-4978", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-29T22:29:00.410", "lastModified": "2018-01-10T19:21:55.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph."}, {"lang": "es", "value": "La funci\u00f3n rs_filter_graph en librawstudio/rs-filter.c en rawstudio podr\u00eda permitir que usuarios locales trunquen archivos arbitrarios mediante un ataque de v\u00ednculo simb\u00f3lico en (1) /tmp/rs-filter-graph.png o (2) /tmp/rs-filter-graph."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rawstudio:rawstudio:2.0-1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A326850B-FFF7-457B-994F-825EC2DC5C62"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-July/162109.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/07/16/15", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68671", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=754899", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1120093", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/94633", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d"}}