{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n//\n// Freescale i.MX7ULP LPSPI driver\n//\n// Copyright 2016 Freescale Semiconductor, Inc.\n// Copyright 2018 NXP Semiconductors\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/dma-imx.h>\n#include <linux/platform_data/spi-imx.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/types.h>\n\n#define DRIVER_NAME \"fsl_lpspi\"\n\n#define FSL_LPSPI_RPM_TIMEOUT 50 /* 50ms */\n\n/* The maximum bytes that edma can transfer once.*/\n#define FSL_LPSPI_MAX_EDMA_BYTES  ((1 << 15) - 1)\n\n/* i.MX7ULP LPSPI registers */\n#define IMX7ULP_VERID\t0x0\n#define IMX7ULP_PARAM\t0x4\n#define IMX7ULP_CR\t0x10\n#define IMX7ULP_SR\t0x14\n#define IMX7ULP_IER\t0x18\n#define IMX7ULP_DER\t0x1c\n#define IMX7ULP_CFGR0\t0x20\n#define IMX7ULP_CFGR1\t0x24\n#define IMX7ULP_DMR0\t0x30\n#define IMX7ULP_DMR1\t0x34\n#define IMX7ULP_CCR\t0x40\n#define IMX7ULP_FCR\t0x58\n#define IMX7ULP_FSR\t0x5c\n#define IMX7ULP_TCR\t0x60\n#define IMX7ULP_TDR\t0x64\n#define IMX7ULP_RSR\t0x70\n#define IMX7ULP_RDR\t0x74\n\n/* General control register field define */\n#define CR_RRF\t\tBIT(9)\n#define CR_RTF\t\tBIT(8)\n#define CR_RST\t\tBIT(1)\n#define CR_MEN\t\tBIT(0)\n#define SR_MBF\t\tBIT(24)\n#define SR_TCF\t\tBIT(10)\n#define SR_FCF\t\tBIT(9)\n#define SR_RDF\t\tBIT(1)\n#define SR_TDF\t\tBIT(0)\n#define IER_TCIE\tBIT(10)\n#define IER_FCIE\tBIT(9)\n#define IER_RDIE\tBIT(1)\n#define IER_TDIE\tBIT(0)\n#define DER_RDDE\tBIT(1)\n#define DER_TDDE\tBIT(0)\n#define CFGR1_PCSCFG\tBIT(27)\n#define CFGR1_PINCFG\t(BIT(24)|BIT(25))\n#define CFGR1_PCSPOL\tBIT(8)\n#define CFGR1_NOSTALL\tBIT(3)\n#define CFGR1_MASTER\tBIT(0)\n#define FSR_TXCOUNT\t(0xFF)\n#define RSR_RXEMPTY\tBIT(1)\n#define TCR_CPOL\tBIT(31)\n#define TCR_CPHA\tBIT(30)\n#define TCR_CONT\tBIT(21)\n#define TCR_CONTC\tBIT(20)\n#define TCR_RXMSK\tBIT(19)\n#define TCR_TXMSK\tBIT(18)\n\nstatic int clkdivs[] = {1, 2, 4, 8, 16, 32, 64, 128};\n\nstruct lpspi_config {\n\tu8 bpw;\n\tu8 chip_select;\n\tu8 prescale;\n\tu16 mode;\n\tu32 speed_hz;\n};\n\nstruct fsl_lpspi_data {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned long base_phys;\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_per;\n\tbool is_slave;\n\tbool is_first_byte;\n\n\tvoid *rx_buf;\n\tconst void *tx_buf;\n\tvoid (*tx)(struct fsl_lpspi_data *);\n\tvoid (*rx)(struct fsl_lpspi_data *);\n\n\tu32 remain;\n\tu8 watermark;\n\tu8 txfifosize;\n\tu8 rxfifosize;\n\n\tstruct lpspi_config config;\n\tstruct completion xfer_done;\n\n\tbool slave_aborted;\n\n\t/* DMA */\n\tbool usedma;\n\tstruct completion dma_rx_completion;\n\tstruct completion dma_tx_completion;\n\n\tint chipselect[0];\n};\n\nstatic const struct of_device_id fsl_lpspi_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7ulp-spi\", },\n\t{ /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, fsl_lpspi_dt_ids);\n\n#define LPSPI_BUF_RX(type)\t\t\t\t\t\t\\\nstatic void fsl_lpspi_buf_rx_##type(struct fsl_lpspi_data *fsl_lpspi)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int val = readl(fsl_lpspi->base + IMX7ULP_RDR);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fsl_lpspi->rx_buf) {\t\t\t\t\t\\\n\t\t*(type *)fsl_lpspi->rx_buf = val;\t\t\t\\\n\t\tfsl_lpspi->rx_buf += sizeof(type);                      \\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define LPSPI_BUF_TX(type)\t\t\t\t\t\t\\\nstatic void fsl_lpspi_buf_tx_##type(struct fsl_lpspi_data *fsl_lpspi)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype val = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fsl_lpspi->tx_buf) {\t\t\t\t\t\\\n\t\tval = *(type *)fsl_lpspi->tx_buf;\t\t\t\\\n\t\tfsl_lpspi->tx_buf += sizeof(type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfsl_lpspi->remain -= sizeof(type);\t\t\t\t\\\n\twritel(val, fsl_lpspi->base + IMX7ULP_TDR);\t\t\t\\\n}\n\nLPSPI_BUF_RX(u8)\nLPSPI_BUF_TX(u8)\nLPSPI_BUF_RX(u16)\nLPSPI_BUF_TX(u16)\nLPSPI_BUF_RX(u32)\nLPSPI_BUF_TX(u32)\n\nstatic void fsl_lpspi_intctrl(struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t      unsigned int enable)\n{\n\twritel(enable, fsl_lpspi->base + IMX7ULP_IER);\n}\n\nstatic int fsl_lpspi_bytes_per_word(const int bpw)\n{\n\treturn DIV_ROUND_UP(bpw, BITS_PER_BYTE);\n}\n\nstatic bool fsl_lpspi_can_dma(struct spi_controller *controller,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *transfer)\n{\n\tunsigned int bytes_per_word;\n\n\tif (!controller->dma_rx)\n\t\treturn false;\n\n\tbytes_per_word = fsl_lpspi_bytes_per_word(transfer->bits_per_word);\n\n\tswitch (bytes_per_word)\n\t{\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int lpspi_prepare_xfer_hardware(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpspi_unprepare_xfer_hardware(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tpm_runtime_mark_last_busy(fsl_lpspi->dev);\n\tpm_runtime_put_autosuspend(fsl_lpspi->dev);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_prepare_message(struct spi_controller *controller,\n\t\t\t\t     struct spi_message *msg)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\t\tspi_controller_get_devdata(controller);\n\tstruct spi_device *spi = msg->spi;\n\tint gpio = fsl_lpspi->chipselect[spi->chip_select];\n\n\tif (gpio_is_valid(gpio))\n\t\tgpio_direction_output(gpio, spi->mode & SPI_CS_HIGH ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_write_tx_fifo(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu8 txfifo_cnt;\n\tu32 temp;\n\n\ttxfifo_cnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;\n\n\twhile (txfifo_cnt < fsl_lpspi->txfifosize) {\n\t\tif (!fsl_lpspi->remain)\n\t\t\tbreak;\n\t\tfsl_lpspi->tx(fsl_lpspi);\n\t\ttxfifo_cnt++;\n\t}\n\n\tif (txfifo_cnt < fsl_lpspi->txfifosize) {\n\t\tif (!fsl_lpspi->is_slave) {\n\t\t\ttemp = readl(fsl_lpspi->base + IMX7ULP_TCR);\n\t\t\ttemp &= ~TCR_CONTC;\n\t\t\twritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\n\t\t}\n\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_FCIE);\n\t} else\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_TDIE);\n}\n\nstatic void fsl_lpspi_read_rx_fifo(struct fsl_lpspi_data *fsl_lpspi)\n{\n\twhile (!(readl(fsl_lpspi->base + IMX7ULP_RSR) & RSR_RXEMPTY))\n\t\tfsl_lpspi->rx(fsl_lpspi);\n}\n\nstatic void fsl_lpspi_set_cmd(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp = 0;\n\n\ttemp |= fsl_lpspi->config.bpw - 1;\n\ttemp |= (fsl_lpspi->config.mode & 0x3) << 30;\n\tif (!fsl_lpspi->is_slave) {\n\t\ttemp |= fsl_lpspi->config.prescale << 27;\n\t\ttemp |= (fsl_lpspi->config.chip_select & 0x3) << 24;\n\n\t\t/*\n\t\t * Set TCR_CONT will keep SS asserted after current transfer.\n\t\t * For the first transfer, clear TCR_CONTC to assert SS.\n\t\t * For subsequent transfer, set TCR_CONTC to keep SS asserted.\n\t\t */\n\t\tif (!fsl_lpspi->usedma) {\n\t\t\ttemp |= TCR_CONT;\n\t\t\tif (fsl_lpspi->is_first_byte)\n\t\t\t\ttemp &= ~TCR_CONTC;\n\t\t\telse\n\t\t\t\ttemp |= TCR_CONTC;\n\t\t}\n\t}\n\twritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"TCR=0x%x\\n\", temp);\n}\n\nstatic void fsl_lpspi_set_watermark(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\n\tif (!fsl_lpspi->usedma)\n\t\ttemp = fsl_lpspi->watermark >> 1 |\n\t\t       (fsl_lpspi->watermark >> 1) << 16;\n\telse\n\t\ttemp = fsl_lpspi->watermark >> 1;\n\n\twritel(temp, fsl_lpspi->base + IMX7ULP_FCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"FCR=0x%x\\n\", temp);\n}\n\nstatic int fsl_lpspi_set_bitrate(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tstruct lpspi_config config = fsl_lpspi->config;\n\tunsigned int perclk_rate, scldiv;\n\tu8 prescale;\n\n\tperclk_rate = clk_get_rate(fsl_lpspi->clk_per);\n\n\tif (config.speed_hz > perclk_rate / 2) {\n\t\tdev_err(fsl_lpspi->dev,\n\t\t      \"per-clk should be at least two times of transfer speed\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (prescale = 0; prescale < 8; prescale++) {\n\t\tscldiv = perclk_rate /\n\t\t\t (clkdivs[prescale] * config.speed_hz) - 2;\n\t\tif (scldiv < 256) {\n\t\t\tfsl_lpspi->config.prescale = prescale;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prescale == 8 && scldiv >= 256)\n\t\treturn -EINVAL;\n\n\twritel(scldiv | (scldiv << 8) | ((scldiv >> 1) << 16),\n\t\t\t\t\tfsl_lpspi->base + IMX7ULP_CCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"perclk=%d, speed=%d, prescale=%d, scldiv=%d\\n\",\n\t\tperclk_rate, config.speed_hz, prescale, scldiv);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_dma_configure(struct spi_controller *controller)\n{\n\tint ret;\n\tenum dma_slave_buswidth buswidth;\n\tstruct dma_slave_config rx = {}, tx = {};\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tswitch (fsl_lpspi_bytes_per_word(fsl_lpspi->config.bpw)) {\n\tcase 4:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tcase 2:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase 1:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttx.direction = DMA_MEM_TO_DEV;\n\ttx.dst_addr = fsl_lpspi->base_phys + IMX7ULP_TDR;\n\ttx.dst_addr_width = buswidth;\n\ttx.dst_maxburst = 1;\n\tret = dmaengine_slave_config(controller->dma_tx, &tx);\n\tif (ret) {\n\t\tdev_err(fsl_lpspi->dev, \"TX dma configuration failed with %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trx.direction = DMA_DEV_TO_MEM;\n\trx.src_addr = fsl_lpspi->base_phys + IMX7ULP_RDR;\n\trx.src_addr_width = buswidth;\n\trx.src_maxburst = 1;\n\tret = dmaengine_slave_config(controller->dma_rx, &rx);\n\tif (ret) {\n\t\tdev_err(fsl_lpspi->dev, \"RX dma configuration failed with %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_config(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\tint ret;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tret = fsl_lpspi_set_bitrate(fsl_lpspi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfsl_lpspi_set_watermark(fsl_lpspi);\n\n\tif (!fsl_lpspi->is_slave)\n\t\ttemp = CFGR1_MASTER;\n\telse\n\t\ttemp = CFGR1_PINCFG;\n\tif (fsl_lpspi->config.mode & SPI_CS_HIGH)\n\t\ttemp |= CFGR1_PCSPOL;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CFGR1);\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_CR);\n\ttemp |= CR_RRF | CR_RTF | CR_MEN;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CR);\n\n\ttemp = 0;\n\tif (fsl_lpspi->usedma)\n\t\ttemp = DER_TDDE | DER_RDDE;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_DER);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_setup_transfer(struct spi_controller *controller,\n\t\t\t\t     struct spi_device *spi,\n\t\t\t\t     struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(spi->controller);\n\n\tif (t == NULL)\n\t\treturn -EINVAL;\n\n\tfsl_lpspi->config.mode = spi->mode;\n\tfsl_lpspi->config.bpw = t->bits_per_word;\n\tfsl_lpspi->config.speed_hz = t->speed_hz;\n\tfsl_lpspi->config.chip_select = spi->chip_select;\n\n\tif (!fsl_lpspi->config.speed_hz)\n\t\tfsl_lpspi->config.speed_hz = spi->max_speed_hz;\n\tif (!fsl_lpspi->config.bpw)\n\t\tfsl_lpspi->config.bpw = spi->bits_per_word;\n\n\t/* Initialize the functions for transfer */\n\tif (fsl_lpspi->config.bpw <= 8) {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u8;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u8;\n\t} else if (fsl_lpspi->config.bpw <= 16) {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u16;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u16;\n\t} else {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u32;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u32;\n\t}\n\n\tif (t->len <= fsl_lpspi->txfifosize)\n\t\tfsl_lpspi->watermark = t->len;\n\telse\n\t\tfsl_lpspi->watermark = fsl_lpspi->txfifosize;\n\n\tif (fsl_lpspi_can_dma(controller, spi, t))\n\t\tfsl_lpspi->usedma = 1;\n\telse\n\t\tfsl_lpspi->usedma = 0;\n\n\treturn fsl_lpspi_config(fsl_lpspi);\n}\n\nstatic int fsl_lpspi_slave_abort(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tfsl_lpspi->slave_aborted = true;\n\tif (!fsl_lpspi->usedma)\n\t\tcomplete(&fsl_lpspi->xfer_done);\n\telse {\n\t\tcomplete(&fsl_lpspi->dma_tx_completion);\n\t\tcomplete(&fsl_lpspi->dma_rx_completion);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_wait_for_completion(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tif (fsl_lpspi->is_slave) {\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->xfer_done) ||\n\t\t\tfsl_lpspi->slave_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev, \"interrupted\\n\");\n\t\t\treturn -EINTR;\n\t\t}\n\t} else {\n\t\tif (!wait_for_completion_timeout(&fsl_lpspi->xfer_done, HZ)) {\n\t\t\tdev_dbg(fsl_lpspi->dev, \"wait for completion timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_reset(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\n\tif (!fsl_lpspi->usedma) {\n\t\t/* Disable all interrupt */\n\t\tfsl_lpspi_intctrl(fsl_lpspi, 0);\n\t}\n\n\t/* W1C for all flags in SR */\n\ttemp = 0x3F << 8;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_SR);\n\n\t/* Clear FIFO and disable module */\n\ttemp = CR_RRF | CR_RTF;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CR);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_dma_rx_callback(void *cookie)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi = (struct fsl_lpspi_data *)cookie;\n\n\tcomplete(&fsl_lpspi->dma_rx_completion);\n}\n\nstatic void fsl_lpspi_dma_tx_callback(void *cookie)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi = (struct fsl_lpspi_data *)cookie;\n\n\tcomplete(&fsl_lpspi->dma_tx_completion);\n}\n\nstatic int fsl_lpspi_calculate_timeout(struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t\t       int size)\n{\n\tunsigned long timeout = 0;\n\n\t/* Time with actual data transfer and CS change delay related to HW */\n\ttimeout = (8 + 4) * size / fsl_lpspi->config.speed_hz;\n\n\t/* Add extra second for scheduler related activities */\n\ttimeout += 1;\n\n\t/* Double calculated timeout */\n\treturn msecs_to_jiffies(2 * timeout * MSEC_PER_SEC);\n}\n\nstatic int fsl_lpspi_dma_transfer(struct spi_controller *controller,\n\t\t\t\tstruct fsl_lpspi_data *fsl_lpspi,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct dma_async_tx_descriptor *desc_tx, *desc_rx;\n\tunsigned long transfer_timeout;\n\tunsigned long timeout;\n\tstruct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;\n\tint ret;\n\n\tret = fsl_lpspi_dma_configure(controller);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc_rx = dmaengine_prep_slave_sg(controller->dma_rx,\n\t\t\t\trx->sgl, rx->nents, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_rx)\n\t\treturn -EINVAL;\n\n\tdesc_rx->callback = fsl_lpspi_dma_rx_callback;\n\tdesc_rx->callback_param = (void *)fsl_lpspi;\n\tdmaengine_submit(desc_rx);\n\treinit_completion(&fsl_lpspi->dma_rx_completion);\n\tdma_async_issue_pending(controller->dma_rx);\n\n\tdesc_tx = dmaengine_prep_slave_sg(controller->dma_tx,\n\t\t\t\ttx->sgl, tx->nents, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_tx) {\n\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc_tx->callback = fsl_lpspi_dma_tx_callback;\n\tdesc_tx->callback_param = (void *)fsl_lpspi;\n\tdmaengine_submit(desc_tx);\n\treinit_completion(&fsl_lpspi->dma_tx_completion);\n\tdma_async_issue_pending(controller->dma_tx);\n\n\tfsl_lpspi->slave_aborted = false;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\ttransfer_timeout = fsl_lpspi_calculate_timeout(fsl_lpspi,\n\t\t\t\t\t\t\t       transfer->len);\n\n\t\t/* Wait eDMA to finish the data transfer.*/\n\t\ttimeout = wait_for_completion_timeout(&fsl_lpspi->dma_tx_completion,\n\t\t\t\t\t\t      transfer_timeout);\n\t\tif (!timeout) {\n\t\t\tdev_err(fsl_lpspi->dev, \"I/O Error in DMA TX\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\ttimeout = wait_for_completion_timeout(&fsl_lpspi->dma_rx_completion,\n\t\t\t\t\t\t      transfer_timeout);\n\t\tif (!timeout) {\n\t\t\tdev_err(fsl_lpspi->dev, \"I/O Error in DMA RX\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->dma_tx_completion) ||\n\t\t\tfsl_lpspi->slave_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev,\n\t\t\t\t\"I/O Error in DMA TX interrupted\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->dma_rx_completion) ||\n\t\t\tfsl_lpspi->slave_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev,\n\t\t\t\t\"I/O Error in DMA RX interrupted\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tfsl_lpspi_reset(fsl_lpspi);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_dma_exit(struct spi_controller *controller)\n{\n\tif (controller->dma_rx) {\n\t\tdma_release_channel(controller->dma_rx);\n\t\tcontroller->dma_rx = NULL;\n\t}\n\n\tif (controller->dma_tx) {\n\t\tdma_release_channel(controller->dma_tx);\n\t\tcontroller->dma_tx = NULL;\n\t}\n}\n\nstatic int fsl_lpspi_dma_init(struct device *dev,\n\t\t\t      struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t      struct spi_controller *controller)\n{\n\tint ret;\n\n\t/* Prepare for TX DMA: */\n\tcontroller->dma_tx = dma_request_slave_channel_reason(dev, \"tx\");\n\tif (IS_ERR(controller->dma_tx)) {\n\t\tret = PTR_ERR(controller->dma_tx);\n\t\tdev_dbg(dev, \"can't get the TX DMA channel, error %d!\\n\", ret);\n\t\tcontroller->dma_tx = NULL;\n\t\tgoto err;\n\t}\n\n\t/* Prepare for RX DMA: */\n\tcontroller->dma_rx = dma_request_slave_channel_reason(dev, \"rx\");\n\tif (IS_ERR(controller->dma_rx)) {\n\t\tret = PTR_ERR(controller->dma_rx);\n\t\tdev_dbg(dev, \"can't get the RX DMA channel, error %d\\n\", ret);\n\t\tcontroller->dma_rx = NULL;\n\t\tgoto err;\n\t}\n\n\tinit_completion(&fsl_lpspi->dma_rx_completion);\n\tinit_completion(&fsl_lpspi->dma_tx_completion);\n\tcontroller->can_dma = fsl_lpspi_can_dma;\n\tcontroller->max_dma_len = FSL_LPSPI_MAX_EDMA_BYTES;\n\n\treturn 0;\nerr:\n\tfsl_lpspi_dma_exit(controller);\n\treturn ret;\n}\n\nstatic int fsl_lpspi_pio_transfer(struct spi_controller *controller,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tfsl_lpspi->tx_buf = t->tx_buf;\n\tfsl_lpspi->rx_buf = t->rx_buf;\n\tfsl_lpspi->remain = t->len;\n\n\treinit_completion(&fsl_lpspi->xfer_done);\n\tfsl_lpspi->slave_aborted = false;\n\n\tfsl_lpspi_write_tx_fifo(fsl_lpspi);\n\n\tret = fsl_lpspi_wait_for_completion(controller);\n\tif (ret)\n\t\treturn ret;\n\n\tfsl_lpspi_reset(fsl_lpspi);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_transfer_one(struct spi_controller *controller,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tfsl_lpspi->is_first_byte = true;\n\tret = fsl_lpspi_setup_transfer(controller, spi, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsl_lpspi_set_cmd(fsl_lpspi);\n\tfsl_lpspi->is_first_byte = false;\n\n\tif (fsl_lpspi->usedma)\n\t\tret = fsl_lpspi_dma_transfer(controller, fsl_lpspi, t);\n\telse\n\t\tret = fsl_lpspi_pio_transfer(controller, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic irqreturn_t fsl_lpspi_isr(int irq, void *dev_id)\n{\n\tu32 temp_SR, temp_IER;\n\tstruct fsl_lpspi_data *fsl_lpspi = dev_id;\n\n\ttemp_IER = readl(fsl_lpspi->base + IMX7ULP_IER);\n\tfsl_lpspi_intctrl(fsl_lpspi, 0);\n\ttemp_SR = readl(fsl_lpspi->base + IMX7ULP_SR);\n\n\tfsl_lpspi_read_rx_fifo(fsl_lpspi);\n\n\tif ((temp_SR & SR_TDF) && (temp_IER & IER_TDIE)) {\n\t\tfsl_lpspi_write_tx_fifo(fsl_lpspi);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (temp_SR & SR_MBF ||\n\t    readl(fsl_lpspi->base + IMX7ULP_FSR) & FSR_TXCOUNT) {\n\t\twritel(SR_FCF, fsl_lpspi->base + IMX7ULP_SR);\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_FCIE);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (temp_SR & SR_FCF && (temp_IER & IER_FCIE)) {\n\t\twritel(SR_FCF, fsl_lpspi->base + IMX7ULP_SR);\n\t\t\tcomplete(&fsl_lpspi->xfer_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_lpspi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tint ret;\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\n\tret = clk_prepare_enable(fsl_lpspi->clk_per);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(fsl_lpspi->clk_ipg);\n\tif (ret) {\n\t\tclk_disable_unprepare(fsl_lpspi->clk_per);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\n\tclk_disable_unprepare(fsl_lpspi->clk_per);\n\tclk_disable_unprepare(fsl_lpspi->clk_ipg);\n\n\treturn 0;\n}\n#endif\n\nstatic int fsl_lpspi_init_rpm(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tstruct device *dev = fsl_lpspi->dev;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, FSL_LPSPI_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_master *lpspi_platform_info =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, irq;\n\tu32 temp;\n\tbool is_slave;\n\n\tis_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_slave)\n\t\tcontroller = spi_alloc_slave(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_master(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_slave = is_slave;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tfor (i = 0; i < controller->num_chipselect; i++) {\n\t\t\tint cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);\n\n\t\t\tif (!gpio_is_valid(cs_gpio) && lpspi_platform_info)\n\t\t\t\tcs_gpio = lpspi_platform_info->chipselect[i];\n\n\t\t\tfsl_lpspi->chipselect[i] = cs_gpio;\n\t\t\tif (!gpio_is_valid(cs_gpio))\n\t\t\t\tcontinue;\n\n\t\t\tret = devm_gpio_request(&pdev->dev,\n\t\t\t\t\t\tfsl_lpspi->chipselect[i],\n\t\t\t\t\t\tDRIVER_NAME);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"can't get cs gpios\\n\");\n\t\t\t\tgoto out_controller_put;\n\t\t\t}\n\t\t}\n\t\tcontroller->cs_gpios = fsl_lpspi->chipselect;\n\t\tcontroller->prepare_message = fsl_lpspi_prepare_message;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->slave_abort = fsl_lpspi_slave_abort;\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t/* enable the clock */\n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_controller_put;\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller error.\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\treturn 0;\n\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}\n\nstatic int fsl_lpspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *controller = platform_get_drvdata(pdev);\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tpm_runtime_disable(fsl_lpspi->dev);\n\n\tspi_master_put(controller);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsl_lpspi_suspend(struct device *dev)\n{\n\tint ret;\n\n\tpinctrl_pm_select_sleep_state(dev);\n\tret = pm_runtime_force_suspend(dev);\n\treturn ret;\n}\n\nstatic int fsl_lpspi_resume(struct device *dev)\n{\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Error in resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn 0;\n}\n#endif /* CONFIG_PM_SLEEP */\n\nstatic const struct dev_pm_ops fsl_lpspi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_lpspi_runtime_suspend,\n\t\t\t\tfsl_lpspi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(fsl_lpspi_suspend, fsl_lpspi_resume)\n};\n\nstatic struct platform_driver fsl_lpspi_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = fsl_lpspi_dt_ids,\n\t\t.pm = &fsl_lpspi_pm_ops,\n\t},\n\t.probe = fsl_lpspi_probe,\n\t.remove = fsl_lpspi_remove,\n};\nmodule_platform_driver(fsl_lpspi_driver);\n\nMODULE_DESCRIPTION(\"LPSPI Controller driver\");\nMODULE_AUTHOR(\"Gao Pan <pandy.gao@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n//\n// Freescale i.MX7ULP LPSPI driver\n//\n// Copyright 2016 Freescale Semiconductor, Inc.\n// Copyright 2018 NXP Semiconductors\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/dma-imx.h>\n#include <linux/platform_data/spi-imx.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi_bitbang.h>\n#include <linux/types.h>\n\n#define DRIVER_NAME \"fsl_lpspi\"\n\n#define FSL_LPSPI_RPM_TIMEOUT 50 /* 50ms */\n\n/* The maximum bytes that edma can transfer once.*/\n#define FSL_LPSPI_MAX_EDMA_BYTES  ((1 << 15) - 1)\n\n/* i.MX7ULP LPSPI registers */\n#define IMX7ULP_VERID\t0x0\n#define IMX7ULP_PARAM\t0x4\n#define IMX7ULP_CR\t0x10\n#define IMX7ULP_SR\t0x14\n#define IMX7ULP_IER\t0x18\n#define IMX7ULP_DER\t0x1c\n#define IMX7ULP_CFGR0\t0x20\n#define IMX7ULP_CFGR1\t0x24\n#define IMX7ULP_DMR0\t0x30\n#define IMX7ULP_DMR1\t0x34\n#define IMX7ULP_CCR\t0x40\n#define IMX7ULP_FCR\t0x58\n#define IMX7ULP_FSR\t0x5c\n#define IMX7ULP_TCR\t0x60\n#define IMX7ULP_TDR\t0x64\n#define IMX7ULP_RSR\t0x70\n#define IMX7ULP_RDR\t0x74\n\n/* General control register field define */\n#define CR_RRF\t\tBIT(9)\n#define CR_RTF\t\tBIT(8)\n#define CR_RST\t\tBIT(1)\n#define CR_MEN\t\tBIT(0)\n#define SR_MBF\t\tBIT(24)\n#define SR_TCF\t\tBIT(10)\n#define SR_FCF\t\tBIT(9)\n#define SR_RDF\t\tBIT(1)\n#define SR_TDF\t\tBIT(0)\n#define IER_TCIE\tBIT(10)\n#define IER_FCIE\tBIT(9)\n#define IER_RDIE\tBIT(1)\n#define IER_TDIE\tBIT(0)\n#define DER_RDDE\tBIT(1)\n#define DER_TDDE\tBIT(0)\n#define CFGR1_PCSCFG\tBIT(27)\n#define CFGR1_PINCFG\t(BIT(24)|BIT(25))\n#define CFGR1_PCSPOL\tBIT(8)\n#define CFGR1_NOSTALL\tBIT(3)\n#define CFGR1_MASTER\tBIT(0)\n#define FSR_TXCOUNT\t(0xFF)\n#define RSR_RXEMPTY\tBIT(1)\n#define TCR_CPOL\tBIT(31)\n#define TCR_CPHA\tBIT(30)\n#define TCR_CONT\tBIT(21)\n#define TCR_CONTC\tBIT(20)\n#define TCR_RXMSK\tBIT(19)\n#define TCR_TXMSK\tBIT(18)\n\nstatic int clkdivs[] = {1, 2, 4, 8, 16, 32, 64, 128};\n\nstruct lpspi_config {\n\tu8 bpw;\n\tu8 chip_select;\n\tu8 prescale;\n\tu16 mode;\n\tu32 speed_hz;\n};\n\nstruct fsl_lpspi_data {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned long base_phys;\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_per;\n\tbool is_slave;\n\tbool is_first_byte;\n\n\tvoid *rx_buf;\n\tconst void *tx_buf;\n\tvoid (*tx)(struct fsl_lpspi_data *);\n\tvoid (*rx)(struct fsl_lpspi_data *);\n\n\tu32 remain;\n\tu8 watermark;\n\tu8 txfifosize;\n\tu8 rxfifosize;\n\n\tstruct lpspi_config config;\n\tstruct completion xfer_done;\n\n\tbool slave_aborted;\n\n\t/* DMA */\n\tbool usedma;\n\tstruct completion dma_rx_completion;\n\tstruct completion dma_tx_completion;\n\n\tint chipselect[0];\n};\n\nstatic const struct of_device_id fsl_lpspi_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7ulp-spi\", },\n\t{ /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, fsl_lpspi_dt_ids);\n\n#define LPSPI_BUF_RX(type)\t\t\t\t\t\t\\\nstatic void fsl_lpspi_buf_rx_##type(struct fsl_lpspi_data *fsl_lpspi)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int val = readl(fsl_lpspi->base + IMX7ULP_RDR);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fsl_lpspi->rx_buf) {\t\t\t\t\t\\\n\t\t*(type *)fsl_lpspi->rx_buf = val;\t\t\t\\\n\t\tfsl_lpspi->rx_buf += sizeof(type);                      \\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define LPSPI_BUF_TX(type)\t\t\t\t\t\t\\\nstatic void fsl_lpspi_buf_tx_##type(struct fsl_lpspi_data *fsl_lpspi)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype val = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fsl_lpspi->tx_buf) {\t\t\t\t\t\\\n\t\tval = *(type *)fsl_lpspi->tx_buf;\t\t\t\\\n\t\tfsl_lpspi->tx_buf += sizeof(type);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfsl_lpspi->remain -= sizeof(type);\t\t\t\t\\\n\twritel(val, fsl_lpspi->base + IMX7ULP_TDR);\t\t\t\\\n}\n\nLPSPI_BUF_RX(u8)\nLPSPI_BUF_TX(u8)\nLPSPI_BUF_RX(u16)\nLPSPI_BUF_TX(u16)\nLPSPI_BUF_RX(u32)\nLPSPI_BUF_TX(u32)\n\nstatic void fsl_lpspi_intctrl(struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t      unsigned int enable)\n{\n\twritel(enable, fsl_lpspi->base + IMX7ULP_IER);\n}\n\nstatic int fsl_lpspi_bytes_per_word(const int bpw)\n{\n\treturn DIV_ROUND_UP(bpw, BITS_PER_BYTE);\n}\n\nstatic bool fsl_lpspi_can_dma(struct spi_controller *controller,\n\t\t\t      struct spi_device *spi,\n\t\t\t      struct spi_transfer *transfer)\n{\n\tunsigned int bytes_per_word;\n\n\tif (!controller->dma_rx)\n\t\treturn false;\n\n\tbytes_per_word = fsl_lpspi_bytes_per_word(transfer->bits_per_word);\n\n\tswitch (bytes_per_word)\n\t{\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int lpspi_prepare_xfer_hardware(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpspi_unprepare_xfer_hardware(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tpm_runtime_mark_last_busy(fsl_lpspi->dev);\n\tpm_runtime_put_autosuspend(fsl_lpspi->dev);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_prepare_message(struct spi_controller *controller,\n\t\t\t\t     struct spi_message *msg)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\t\tspi_controller_get_devdata(controller);\n\tstruct spi_device *spi = msg->spi;\n\tint gpio = fsl_lpspi->chipselect[spi->chip_select];\n\n\tif (gpio_is_valid(gpio))\n\t\tgpio_direction_output(gpio, spi->mode & SPI_CS_HIGH ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_write_tx_fifo(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu8 txfifo_cnt;\n\tu32 temp;\n\n\ttxfifo_cnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;\n\n\twhile (txfifo_cnt < fsl_lpspi->txfifosize) {\n\t\tif (!fsl_lpspi->remain)\n\t\t\tbreak;\n\t\tfsl_lpspi->tx(fsl_lpspi);\n\t\ttxfifo_cnt++;\n\t}\n\n\tif (txfifo_cnt < fsl_lpspi->txfifosize) {\n\t\tif (!fsl_lpspi->is_slave) {\n\t\t\ttemp = readl(fsl_lpspi->base + IMX7ULP_TCR);\n\t\t\ttemp &= ~TCR_CONTC;\n\t\t\twritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\n\t\t}\n\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_FCIE);\n\t} else\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_TDIE);\n}\n\nstatic void fsl_lpspi_read_rx_fifo(struct fsl_lpspi_data *fsl_lpspi)\n{\n\twhile (!(readl(fsl_lpspi->base + IMX7ULP_RSR) & RSR_RXEMPTY))\n\t\tfsl_lpspi->rx(fsl_lpspi);\n}\n\nstatic void fsl_lpspi_set_cmd(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp = 0;\n\n\ttemp |= fsl_lpspi->config.bpw - 1;\n\ttemp |= (fsl_lpspi->config.mode & 0x3) << 30;\n\tif (!fsl_lpspi->is_slave) {\n\t\ttemp |= fsl_lpspi->config.prescale << 27;\n\t\ttemp |= (fsl_lpspi->config.chip_select & 0x3) << 24;\n\n\t\t/*\n\t\t * Set TCR_CONT will keep SS asserted after current transfer.\n\t\t * For the first transfer, clear TCR_CONTC to assert SS.\n\t\t * For subsequent transfer, set TCR_CONTC to keep SS asserted.\n\t\t */\n\t\tif (!fsl_lpspi->usedma) {\n\t\t\ttemp |= TCR_CONT;\n\t\t\tif (fsl_lpspi->is_first_byte)\n\t\t\t\ttemp &= ~TCR_CONTC;\n\t\t\telse\n\t\t\t\ttemp |= TCR_CONTC;\n\t\t}\n\t}\n\twritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"TCR=0x%x\\n\", temp);\n}\n\nstatic void fsl_lpspi_set_watermark(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\n\tif (!fsl_lpspi->usedma)\n\t\ttemp = fsl_lpspi->watermark >> 1 |\n\t\t       (fsl_lpspi->watermark >> 1) << 16;\n\telse\n\t\ttemp = fsl_lpspi->watermark >> 1;\n\n\twritel(temp, fsl_lpspi->base + IMX7ULP_FCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"FCR=0x%x\\n\", temp);\n}\n\nstatic int fsl_lpspi_set_bitrate(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tstruct lpspi_config config = fsl_lpspi->config;\n\tunsigned int perclk_rate, scldiv;\n\tu8 prescale;\n\n\tperclk_rate = clk_get_rate(fsl_lpspi->clk_per);\n\n\tif (config.speed_hz > perclk_rate / 2) {\n\t\tdev_err(fsl_lpspi->dev,\n\t\t      \"per-clk should be at least two times of transfer speed\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (prescale = 0; prescale < 8; prescale++) {\n\t\tscldiv = perclk_rate /\n\t\t\t (clkdivs[prescale] * config.speed_hz) - 2;\n\t\tif (scldiv < 256) {\n\t\t\tfsl_lpspi->config.prescale = prescale;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prescale == 8 && scldiv >= 256)\n\t\treturn -EINVAL;\n\n\twritel(scldiv | (scldiv << 8) | ((scldiv >> 1) << 16),\n\t\t\t\t\tfsl_lpspi->base + IMX7ULP_CCR);\n\n\tdev_dbg(fsl_lpspi->dev, \"perclk=%d, speed=%d, prescale=%d, scldiv=%d\\n\",\n\t\tperclk_rate, config.speed_hz, prescale, scldiv);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_dma_configure(struct spi_controller *controller)\n{\n\tint ret;\n\tenum dma_slave_buswidth buswidth;\n\tstruct dma_slave_config rx = {}, tx = {};\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tswitch (fsl_lpspi_bytes_per_word(fsl_lpspi->config.bpw)) {\n\tcase 4:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tcase 2:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase 1:\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttx.direction = DMA_MEM_TO_DEV;\n\ttx.dst_addr = fsl_lpspi->base_phys + IMX7ULP_TDR;\n\ttx.dst_addr_width = buswidth;\n\ttx.dst_maxburst = 1;\n\tret = dmaengine_slave_config(controller->dma_tx, &tx);\n\tif (ret) {\n\t\tdev_err(fsl_lpspi->dev, \"TX dma configuration failed with %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trx.direction = DMA_DEV_TO_MEM;\n\trx.src_addr = fsl_lpspi->base_phys + IMX7ULP_RDR;\n\trx.src_addr_width = buswidth;\n\trx.src_maxburst = 1;\n\tret = dmaengine_slave_config(controller->dma_rx, &rx);\n\tif (ret) {\n\t\tdev_err(fsl_lpspi->dev, \"RX dma configuration failed with %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_config(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\tint ret;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tret = fsl_lpspi_set_bitrate(fsl_lpspi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfsl_lpspi_set_watermark(fsl_lpspi);\n\n\tif (!fsl_lpspi->is_slave)\n\t\ttemp = CFGR1_MASTER;\n\telse\n\t\ttemp = CFGR1_PINCFG;\n\tif (fsl_lpspi->config.mode & SPI_CS_HIGH)\n\t\ttemp |= CFGR1_PCSPOL;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CFGR1);\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_CR);\n\ttemp |= CR_RRF | CR_RTF | CR_MEN;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CR);\n\n\ttemp = 0;\n\tif (fsl_lpspi->usedma)\n\t\ttemp = DER_TDDE | DER_RDDE;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_DER);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_setup_transfer(struct spi_controller *controller,\n\t\t\t\t     struct spi_device *spi,\n\t\t\t\t     struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(spi->controller);\n\n\tif (t == NULL)\n\t\treturn -EINVAL;\n\n\tfsl_lpspi->config.mode = spi->mode;\n\tfsl_lpspi->config.bpw = t->bits_per_word;\n\tfsl_lpspi->config.speed_hz = t->speed_hz;\n\tfsl_lpspi->config.chip_select = spi->chip_select;\n\n\tif (!fsl_lpspi->config.speed_hz)\n\t\tfsl_lpspi->config.speed_hz = spi->max_speed_hz;\n\tif (!fsl_lpspi->config.bpw)\n\t\tfsl_lpspi->config.bpw = spi->bits_per_word;\n\n\t/* Initialize the functions for transfer */\n\tif (fsl_lpspi->config.bpw <= 8) {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u8;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u8;\n\t} else if (fsl_lpspi->config.bpw <= 16) {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u16;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u16;\n\t} else {\n\t\tfsl_lpspi->rx = fsl_lpspi_buf_rx_u32;\n\t\tfsl_lpspi->tx = fsl_lpspi_buf_tx_u32;\n\t}\n\n\tif (t->len <= fsl_lpspi->txfifosize)\n\t\tfsl_lpspi->watermark = t->len;\n\telse\n\t\tfsl_lpspi->watermark = fsl_lpspi->txfifosize;\n\n\tif (fsl_lpspi_can_dma(controller, spi, t))\n\t\tfsl_lpspi->usedma = 1;\n\telse\n\t\tfsl_lpspi->usedma = 0;\n\n\treturn fsl_lpspi_config(fsl_lpspi);\n}\n\nstatic int fsl_lpspi_slave_abort(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tfsl_lpspi->slave_aborted = true;\n\tif (!fsl_lpspi->usedma)\n\t\tcomplete(&fsl_lpspi->xfer_done);\n\telse {\n\t\tcomplete(&fsl_lpspi->dma_tx_completion);\n\t\tcomplete(&fsl_lpspi->dma_rx_completion);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_wait_for_completion(struct spi_controller *controller)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tif (fsl_lpspi->is_slave) {\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->xfer_done) ||\n\t\t\tfsl_lpspi->slave_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev, \"interrupted\\n\");\n\t\t\treturn -EINTR;\n\t\t}\n\t} else {\n\t\tif (!wait_for_completion_timeout(&fsl_lpspi->xfer_done, HZ)) {\n\t\t\tdev_dbg(fsl_lpspi->dev, \"wait for completion timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_reset(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tu32 temp;\n\n\tif (!fsl_lpspi->usedma) {\n\t\t/* Disable all interrupt */\n\t\tfsl_lpspi_intctrl(fsl_lpspi, 0);\n\t}\n\n\t/* W1C for all flags in SR */\n\ttemp = 0x3F << 8;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_SR);\n\n\t/* Clear FIFO and disable module */\n\ttemp = CR_RRF | CR_RTF;\n\twritel(temp, fsl_lpspi->base + IMX7ULP_CR);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_dma_rx_callback(void *cookie)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi = (struct fsl_lpspi_data *)cookie;\n\n\tcomplete(&fsl_lpspi->dma_rx_completion);\n}\n\nstatic void fsl_lpspi_dma_tx_callback(void *cookie)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi = (struct fsl_lpspi_data *)cookie;\n\n\tcomplete(&fsl_lpspi->dma_tx_completion);\n}\n\nstatic int fsl_lpspi_calculate_timeout(struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t\t       int size)\n{\n\tunsigned long timeout = 0;\n\n\t/* Time with actual data transfer and CS change delay related to HW */\n\ttimeout = (8 + 4) * size / fsl_lpspi->config.speed_hz;\n\n\t/* Add extra second for scheduler related activities */\n\ttimeout += 1;\n\n\t/* Double calculated timeout */\n\treturn msecs_to_jiffies(2 * timeout * MSEC_PER_SEC);\n}\n\nstatic int fsl_lpspi_dma_transfer(struct spi_controller *controller,\n\t\t\t\tstruct fsl_lpspi_data *fsl_lpspi,\n\t\t\t\tstruct spi_transfer *transfer)\n{\n\tstruct dma_async_tx_descriptor *desc_tx, *desc_rx;\n\tunsigned long transfer_timeout;\n\tunsigned long timeout;\n\tstruct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;\n\tint ret;\n\n\tret = fsl_lpspi_dma_configure(controller);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc_rx = dmaengine_prep_slave_sg(controller->dma_rx,\n\t\t\t\trx->sgl, rx->nents, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_rx)\n\t\treturn -EINVAL;\n\n\tdesc_rx->callback = fsl_lpspi_dma_rx_callback;\n\tdesc_rx->callback_param = (void *)fsl_lpspi;\n\tdmaengine_submit(desc_rx);\n\treinit_completion(&fsl_lpspi->dma_rx_completion);\n\tdma_async_issue_pending(controller->dma_rx);\n\n\tdesc_tx = dmaengine_prep_slave_sg(controller->dma_tx,\n\t\t\t\ttx->sgl, tx->nents, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc_tx) {\n\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc_tx->callback = fsl_lpspi_dma_tx_callback;\n\tdesc_tx->callback_param = (void *)fsl_lpspi;\n\tdmaengine_submit(desc_tx);\n\treinit_completion(&fsl_lpspi->dma_tx_completion);\n\tdma_async_issue_pending(controller->dma_tx);\n\n\tfsl_lpspi->slave_aborted = false;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\ttransfer_timeout = fsl_lpspi_calculate_timeout(fsl_lpspi,\n\t\t\t\t\t\t\t       transfer->len);\n\n\t\t/* Wait eDMA to finish the data transfer.*/\n\t\ttimeout = wait_for_completion_timeout(&fsl_lpspi->dma_tx_completion,\n\t\t\t\t\t\t      transfer_timeout);\n\t\tif (!timeout) {\n\t\t\tdev_err(fsl_lpspi->dev, \"I/O Error in DMA TX\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\ttimeout = wait_for_completion_timeout(&fsl_lpspi->dma_rx_completion,\n\t\t\t\t\t\t      transfer_timeout);\n\t\tif (!timeout) {\n\t\t\tdev_err(fsl_lpspi->dev, \"I/O Error in DMA RX\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->dma_tx_completion) ||\n\t\t\tfsl_lpspi->slave_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev,\n\t\t\t\t\"I/O Error in DMA TX interrupted\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (wait_for_completion_interruptible(&fsl_lpspi->dma_rx_completion) ||\n\t\t\tfsl_lpspi->slave_aborted) {\n\t\t\tdev_dbg(fsl_lpspi->dev,\n\t\t\t\t\"I/O Error in DMA RX interrupted\\n\");\n\t\t\tdmaengine_terminate_all(controller->dma_tx);\n\t\t\tdmaengine_terminate_all(controller->dma_rx);\n\t\t\tfsl_lpspi_reset(fsl_lpspi);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tfsl_lpspi_reset(fsl_lpspi);\n\n\treturn 0;\n}\n\nstatic void fsl_lpspi_dma_exit(struct spi_controller *controller)\n{\n\tif (controller->dma_rx) {\n\t\tdma_release_channel(controller->dma_rx);\n\t\tcontroller->dma_rx = NULL;\n\t}\n\n\tif (controller->dma_tx) {\n\t\tdma_release_channel(controller->dma_tx);\n\t\tcontroller->dma_tx = NULL;\n\t}\n}\n\nstatic int fsl_lpspi_dma_init(struct device *dev,\n\t\t\t      struct fsl_lpspi_data *fsl_lpspi,\n\t\t\t      struct spi_controller *controller)\n{\n\tint ret;\n\n\t/* Prepare for TX DMA: */\n\tcontroller->dma_tx = dma_request_slave_channel_reason(dev, \"tx\");\n\tif (IS_ERR(controller->dma_tx)) {\n\t\tret = PTR_ERR(controller->dma_tx);\n\t\tdev_dbg(dev, \"can't get the TX DMA channel, error %d!\\n\", ret);\n\t\tcontroller->dma_tx = NULL;\n\t\tgoto err;\n\t}\n\n\t/* Prepare for RX DMA: */\n\tcontroller->dma_rx = dma_request_slave_channel_reason(dev, \"rx\");\n\tif (IS_ERR(controller->dma_rx)) {\n\t\tret = PTR_ERR(controller->dma_rx);\n\t\tdev_dbg(dev, \"can't get the RX DMA channel, error %d\\n\", ret);\n\t\tcontroller->dma_rx = NULL;\n\t\tgoto err;\n\t}\n\n\tinit_completion(&fsl_lpspi->dma_rx_completion);\n\tinit_completion(&fsl_lpspi->dma_tx_completion);\n\tcontroller->can_dma = fsl_lpspi_can_dma;\n\tcontroller->max_dma_len = FSL_LPSPI_MAX_EDMA_BYTES;\n\n\treturn 0;\nerr:\n\tfsl_lpspi_dma_exit(controller);\n\treturn ret;\n}\n\nstatic int fsl_lpspi_pio_transfer(struct spi_controller *controller,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tfsl_lpspi->tx_buf = t->tx_buf;\n\tfsl_lpspi->rx_buf = t->rx_buf;\n\tfsl_lpspi->remain = t->len;\n\n\treinit_completion(&fsl_lpspi->xfer_done);\n\tfsl_lpspi->slave_aborted = false;\n\n\tfsl_lpspi_write_tx_fifo(fsl_lpspi);\n\n\tret = fsl_lpspi_wait_for_completion(controller);\n\tif (ret)\n\t\treturn ret;\n\n\tfsl_lpspi_reset(fsl_lpspi);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_transfer_one(struct spi_controller *controller,\n\t\t\t\t  struct spi_device *spi,\n\t\t\t\t  struct spi_transfer *t)\n{\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\t\tspi_controller_get_devdata(controller);\n\tint ret;\n\n\tfsl_lpspi->is_first_byte = true;\n\tret = fsl_lpspi_setup_transfer(controller, spi, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsl_lpspi_set_cmd(fsl_lpspi);\n\tfsl_lpspi->is_first_byte = false;\n\n\tif (fsl_lpspi->usedma)\n\t\tret = fsl_lpspi_dma_transfer(controller, fsl_lpspi, t);\n\telse\n\t\tret = fsl_lpspi_pio_transfer(controller, t);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic irqreturn_t fsl_lpspi_isr(int irq, void *dev_id)\n{\n\tu32 temp_SR, temp_IER;\n\tstruct fsl_lpspi_data *fsl_lpspi = dev_id;\n\n\ttemp_IER = readl(fsl_lpspi->base + IMX7ULP_IER);\n\tfsl_lpspi_intctrl(fsl_lpspi, 0);\n\ttemp_SR = readl(fsl_lpspi->base + IMX7ULP_SR);\n\n\tfsl_lpspi_read_rx_fifo(fsl_lpspi);\n\n\tif ((temp_SR & SR_TDF) && (temp_IER & IER_TDIE)) {\n\t\tfsl_lpspi_write_tx_fifo(fsl_lpspi);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (temp_SR & SR_MBF ||\n\t    readl(fsl_lpspi->base + IMX7ULP_FSR) & FSR_TXCOUNT) {\n\t\twritel(SR_FCF, fsl_lpspi->base + IMX7ULP_SR);\n\t\tfsl_lpspi_intctrl(fsl_lpspi, IER_FCIE);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (temp_SR & SR_FCF && (temp_IER & IER_FCIE)) {\n\t\twritel(SR_FCF, fsl_lpspi->base + IMX7ULP_SR);\n\t\t\tcomplete(&fsl_lpspi->xfer_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_lpspi_runtime_resume(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tint ret;\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\n\tret = clk_prepare_enable(fsl_lpspi->clk_per);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(fsl_lpspi->clk_ipg);\n\tif (ret) {\n\t\tclk_disable_unprepare(fsl_lpspi->clk_per);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_controller *controller = dev_get_drvdata(dev);\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\n\tclk_disable_unprepare(fsl_lpspi->clk_per);\n\tclk_disable_unprepare(fsl_lpspi->clk_ipg);\n\n\treturn 0;\n}\n#endif\n\nstatic int fsl_lpspi_init_rpm(struct fsl_lpspi_data *fsl_lpspi)\n{\n\tstruct device *dev = fsl_lpspi->dev;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, FSL_LPSPI_RPM_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_master *lpspi_platform_info =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, irq;\n\tu32 temp;\n\tbool is_slave;\n\n\tis_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_slave)\n\t\tcontroller = spi_alloc_slave(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_master(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_slave = is_slave;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tfor (i = 0; i < controller->num_chipselect; i++) {\n\t\t\tint cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);\n\n\t\t\tif (!gpio_is_valid(cs_gpio) && lpspi_platform_info)\n\t\t\t\tcs_gpio = lpspi_platform_info->chipselect[i];\n\n\t\t\tfsl_lpspi->chipselect[i] = cs_gpio;\n\t\t\tif (!gpio_is_valid(cs_gpio))\n\t\t\t\tcontinue;\n\n\t\t\tret = devm_gpio_request(&pdev->dev,\n\t\t\t\t\t\tfsl_lpspi->chipselect[i],\n\t\t\t\t\t\tDRIVER_NAME);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"can't get cs gpios\\n\");\n\t\t\t\tgoto out_controller_put;\n\t\t\t}\n\t\t}\n\t\tcontroller->cs_gpios = fsl_lpspi->chipselect;\n\t\tcontroller->prepare_message = fsl_lpspi_prepare_message;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->slave_abort = fsl_lpspi_slave_abort;\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t/* enable the clock */\n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_controller_put;\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller error.\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\treturn 0;\n\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}\n\nstatic int fsl_lpspi_remove(struct platform_device *pdev)\n{\n\tstruct spi_controller *controller = platform_get_drvdata(pdev);\n\tstruct fsl_lpspi_data *fsl_lpspi =\n\t\t\t\tspi_controller_get_devdata(controller);\n\n\tpm_runtime_disable(fsl_lpspi->dev);\n\n\tspi_master_put(controller);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsl_lpspi_suspend(struct device *dev)\n{\n\tint ret;\n\n\tpinctrl_pm_select_sleep_state(dev);\n\tret = pm_runtime_force_suspend(dev);\n\treturn ret;\n}\n\nstatic int fsl_lpspi_resume(struct device *dev)\n{\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Error in resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn 0;\n}\n#endif /* CONFIG_PM_SLEEP */\n\nstatic const struct dev_pm_ops fsl_lpspi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_lpspi_runtime_suspend,\n\t\t\t\tfsl_lpspi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(fsl_lpspi_suspend, fsl_lpspi_resume)\n};\n\nstatic struct platform_driver fsl_lpspi_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = fsl_lpspi_dt_ids,\n\t\t.pm = &fsl_lpspi_pm_ops,\n\t},\n\t.probe = fsl_lpspi_probe,\n\t.remove = fsl_lpspi_remove,\n};\nmodule_platform_driver(fsl_lpspi_driver);\n\nMODULE_DESCRIPTION(\"LPSPI Controller driver\");\nMODULE_AUTHOR(\"Gao Pan <pandy.gao@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/spi/spi-fsl-lpspi.c"], "buggy_code_start_loc": [941], "buggy_code_end_loc": [942], "fixing_code_start_loc": [941], "fixing_code_end_loc": [942], "type": "CWE-401", "message": "** DISPUTED ** A memory leak in the fsl_lpspi_probe() function in drivers/spi/spi-fsl-lpspi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering pm_runtime_get_sync() failures, aka CID-057b8945f78f. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control these failures at probe time.", "other": {"cve": {"id": "CVE-2019-19064", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.607", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A memory leak in the fsl_lpspi_probe() function in drivers/spi/spi-fsl-lpspi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering pm_runtime_get_sync() failures, aka CID-057b8945f78f. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control these failures at probe time."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n fsl_lpspi_probe() en el archivo drivers/spi/spi-fsl-lpspi.c en el kernel de Linux versiones hasta 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos en la funci\u00f3n pm_runtime_get_sync(), tambi\u00e9n se conoce como CID -057b8945f78f."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1157300", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86"}}