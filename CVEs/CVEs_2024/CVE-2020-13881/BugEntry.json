{"buggy_code": ["/* support.c - support functions for pam_tacplus.c\n * \n * Copyright (C) 2010, Pawel Krawczyk <pawel.krawczyk@hush.com> and\n * Jeroen Nijhof <jeroen@jeroennijhof.nl>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program - see the file COPYING.\n *\n * See `CHANGES' file for revision history.\n */\n\n#define PAM_SM_AUTH\n#define PAM_SM_ACCOUNT\n#define PAM_SM_SESSION\n#define PAM_SM_PASSWORD\n\n#include \"config.h\"\n#include \"support.h\"\n#include \"pam_tacplus.h\"\n\n#ifdef HAVE_LIMITS_H\n\n#include <limits.h>\n\n#endif\n\ntacplus_server_t tac_srv[TAC_PLUS_MAXSERVERS];\nunsigned int tac_srv_no = 0;\n\nchar tac_service[64];\nchar tac_protocol[64];\nchar tac_prompt[64];\nstruct addrinfo tac_srv_addr[TAC_PLUS_MAXSERVERS];\nstruct sockaddr tac_sock_addr[TAC_PLUS_MAXSERVERS];\n\nstruct sockaddr_in6 tac_sock6_addr[TAC_PLUS_MAXSERVERS];\nchar tac_srv_key[TAC_PLUS_MAXSERVERS][TAC_SECRET_MAX_LEN+1];\n\nvoid _pam_log(int err, const char *format, ...) {\n    char msg[256];\n    va_list args;\n\n    va_start(args, format);\n    vsnprintf(msg, sizeof(msg), format, args);\n    syslog(err, \"PAM-tacplus: %s\", msg);\n    va_end(args);\n}\n\nchar *_pam_get_user(pam_handle_t *pamh) {\n    int retval;\n    char *user;\n\n    retval = pam_get_user(pamh, (void *) &user, \"Username: \");\n    if (retval != PAM_SUCCESS || user == NULL || *user == '\\0') {\n        _pam_log(LOG_ERR, \"unable to obtain username\");\n        user = NULL;\n    }\n    return user;\n}\n\nchar *_pam_get_terminal(pam_handle_t *pamh) {\n    int retval;\n    char *tty;\n\n    retval = pam_get_item(pamh, PAM_TTY, (void *) &tty);\n    if (retval != PAM_SUCCESS || tty == NULL || *tty == '\\0') {\n        tty = ttyname(STDIN_FILENO);\n        if (tty == NULL || *tty == '\\0')\n            tty = \"unknown\";\n    }\n    return tty;\n}\n\nchar *_pam_get_rhost(pam_handle_t *pamh) {\n    int retval;\n    char *rhost;\n\n    retval = pam_get_item(pamh, PAM_RHOST, (void *) &rhost);\n    if (retval != PAM_SUCCESS || rhost == NULL || *rhost == '\\0') {\n        rhost = \"unknown\";\n    }\n    return rhost;\n}\n\nint converse(pam_handle_t *pamh, int nargs, const struct pam_message *message,\n             struct pam_response **response) {\n\n    int retval;\n    struct pam_conv *conv;\n\n    if ((retval = pam_get_item(pamh, PAM_CONV, (const void **) &conv)) == PAM_SUCCESS) {\n        retval = conv->conv(nargs, &message, response, conv->appdata_ptr);\n\n        if (retval != PAM_SUCCESS) {\n            _pam_log(LOG_ERR, \"(pam_tacplus) converse returned %d\", retval);\n            _pam_log(LOG_ERR, \"that is: %s\", pam_strerror(pamh, retval));\n        }\n    } else {\n        _pam_log(LOG_ERR, \"(pam_tacplus) converse failed to get pam_conv\");\n    }\n\n    return retval;\n}\n\n/* stolen from pam_stress */\nint tacacs_get_password(pam_handle_t *pamh, int flags __Unused,\n                        int ctrl, char **password) {\n\n    (void) flags;\n    const void *pam_pass;\n    char *pass = NULL;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: called\", __FUNCTION__);\n\n    if ((ctrl & (PAM_TAC_TRY_FIRST_PASS | PAM_TAC_USE_FIRST_PASS))\n        && (pam_get_item(pamh, PAM_AUTHTOK, &pam_pass) == PAM_SUCCESS)\n        && (pam_pass != NULL)) {\n        if ((pass = strdup(pam_pass)) == NULL)\n            return PAM_BUF_ERR;\n    } else if ((ctrl & PAM_TAC_USE_FIRST_PASS)) {\n        _pam_log(LOG_WARNING, \"no forwarded password\");\n        return PAM_PERM_DENIED;\n    } else {\n        struct pam_message msg;\n        struct pam_response *resp = NULL;\n        int retval;\n\n        /* set up conversation call */\n        msg.msg_style = PAM_PROMPT_ECHO_OFF;\n\n        if (!tac_prompt[0]) {\n            msg.msg = \"Password: \";\n        } else {\n            msg.msg = tac_prompt;\n        }\n\n        if ((retval = converse(pamh, 1, &msg, &resp)) != PAM_SUCCESS)\n            return retval;\n\n        if (resp != NULL) {\n            if (resp->resp == NULL && (ctrl & PAM_TAC_DEBUG))\n                _pam_log(LOG_DEBUG, \"pam_sm_authenticate: NULL authtok given\");\n\n            pass = resp->resp;    /* remember this! */\n            resp->resp = NULL;\n\n            free(resp);\n            resp = NULL;\n        } else {\n            if (ctrl & PAM_TAC_DEBUG) {\n                _pam_log(LOG_DEBUG, \"pam_sm_authenticate: no error reported\");\n                _pam_log(LOG_DEBUG, \"getting password, but NULL returned!?\");\n            }\n            return PAM_CONV_ERR;\n        }\n    }\n\n    /*\n       FIXME *password can still turn out as NULL\n       and it can't be free()d when it's NULL\n    */\n    *password = pass;       /* this *MUST* be free()'d by this module */\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: obtained password\", __FUNCTION__);\n\n    return PAM_SUCCESS;\n}\n\nvoid tac_copy_addr_info(struct addrinfo *p_dst, const struct addrinfo *p_src) {\n    if (p_dst && p_src) {\n        p_dst->ai_flags = p_src->ai_flags;\n        p_dst->ai_family = p_src->ai_family;\n        p_dst->ai_socktype = p_src->ai_socktype;\n        p_dst->ai_protocol = p_src->ai_protocol;\n        p_dst->ai_addrlen = p_src->ai_addrlen;\n\n        /* ipv6 check */\n        if (p_dst->ai_family == AF_INET6) {\n          memcpy (p_dst->ai_addr, p_src->ai_addr, sizeof(struct sockaddr_in6));\n          memset ((struct sockaddr_in6*)p_dst->ai_addr, 0 , sizeof(struct sockaddr_in6));\n          memcpy ((struct sockaddr_in6*)p_dst->ai_addr, (struct sockaddr_in6*)p_src->ai_addr, sizeof(struct sockaddr_in6));\n        } else {\n           memcpy (p_dst->ai_addr, p_src->ai_addr, sizeof(struct sockaddr)); \n        }\n\n        p_dst->ai_canonname = NULL; /* we do not care it */\n        p_dst->ai_next = NULL;      /* no more chain */\n    }\n}\n\nstatic void set_tac_srv_addr (unsigned int srv_no, const struct addrinfo *addr)\n{\n    _pam_log(LOG_DEBUG, \"%s: server [%s]\", __FUNCTION__,\n                        tac_ntop(addr->ai_addr));\n\n    if (srv_no < TAC_PLUS_MAXSERVERS) {\n        if (addr) {\n          if (addr->ai_family == AF_INET6) {\n            tac_srv_addr[srv_no].ai_addr = (struct sockaddr *)&tac_sock6_addr[srv_no];\n          } else {\n            tac_srv_addr[srv_no].ai_addr = &tac_sock_addr[srv_no];\n          }\n          tac_copy_addr_info (&tac_srv_addr[srv_no], addr);\n          tac_srv[srv_no].addr = &tac_srv_addr[srv_no];\n\n          /*this code will copy the ipv6 address to a temp variable */\n          /*and copies to global tac_srv array*/\n          if (addr->ai_family == AF_INET6) {\n            memset (&tac_sock6_addr[srv_no], 0, sizeof(struct sockaddr_in6));\n            memcpy (&tac_sock6_addr[srv_no], (struct sockaddr_in6*)addr->ai_addr, sizeof(struct sockaddr_in6));\n            tac_srv[srv_no].addr->ai_addr = (struct sockaddr *)&tac_sock6_addr[srv_no];\n          }\n          _pam_log(LOG_DEBUG, \"%s: server %d after copy [%s]\",  __FUNCTION__, srv_no,\n                        tac_ntop(tac_srv[srv_no].addr->ai_addr));\n        } \n        else {\n            tac_srv[srv_no].addr = NULL;\n        }\n    }\n}\n\nstatic void set_tac_srv_key(unsigned int srv_no, const char *key) {\n    if (srv_no < TAC_PLUS_MAXSERVERS) {\n        if (key) {\n            strncpy(tac_srv_key[srv_no], key, TAC_SECRET_MAX_LEN - 1);\n            tac_srv[srv_no].key = tac_srv_key[srv_no];\n        }\n        else {\n            _pam_log(LOG_DEBUG, \"%s: server %d key is null; address [%s]\", __FUNCTION__,srv_no,\n                              tac_ntop(tac_srv[srv_no].addr->ai_addr));\n            tac_srv[srv_no].key = NULL;\n        }\n    }\n}\n\nint _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),\n                     tac_srv[n].key);\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}    /* _pam_parse */\n\n"], "fixing_code": ["/* support.c - support functions for pam_tacplus.c\n * \n * Copyright (C) 2010, Pawel Krawczyk <pawel.krawczyk@hush.com> and\n * Jeroen Nijhof <jeroen@jeroennijhof.nl>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program - see the file COPYING.\n *\n * See `CHANGES' file for revision history.\n */\n\n#define PAM_SM_AUTH\n#define PAM_SM_ACCOUNT\n#define PAM_SM_SESSION\n#define PAM_SM_PASSWORD\n\n#include \"config.h\"\n#include \"support.h\"\n#include \"pam_tacplus.h\"\n\n#ifdef HAVE_LIMITS_H\n\n#include <limits.h>\n\n#endif\n\ntacplus_server_t tac_srv[TAC_PLUS_MAXSERVERS];\nunsigned int tac_srv_no = 0;\n\nchar tac_service[64];\nchar tac_protocol[64];\nchar tac_prompt[64];\nstruct addrinfo tac_srv_addr[TAC_PLUS_MAXSERVERS];\nstruct sockaddr tac_sock_addr[TAC_PLUS_MAXSERVERS];\n\nstruct sockaddr_in6 tac_sock6_addr[TAC_PLUS_MAXSERVERS];\nchar tac_srv_key[TAC_PLUS_MAXSERVERS][TAC_SECRET_MAX_LEN+1];\n\nvoid _pam_log(int err, const char *format, ...) {\n    char msg[256];\n    va_list args;\n\n    va_start(args, format);\n    vsnprintf(msg, sizeof(msg), format, args);\n    syslog(err, \"PAM-tacplus: %s\", msg);\n    va_end(args);\n}\n\nchar *_pam_get_user(pam_handle_t *pamh) {\n    int retval;\n    char *user;\n\n    retval = pam_get_user(pamh, (void *) &user, \"Username: \");\n    if (retval != PAM_SUCCESS || user == NULL || *user == '\\0') {\n        _pam_log(LOG_ERR, \"unable to obtain username\");\n        user = NULL;\n    }\n    return user;\n}\n\nchar *_pam_get_terminal(pam_handle_t *pamh) {\n    int retval;\n    char *tty;\n\n    retval = pam_get_item(pamh, PAM_TTY, (void *) &tty);\n    if (retval != PAM_SUCCESS || tty == NULL || *tty == '\\0') {\n        tty = ttyname(STDIN_FILENO);\n        if (tty == NULL || *tty == '\\0')\n            tty = \"unknown\";\n    }\n    return tty;\n}\n\nchar *_pam_get_rhost(pam_handle_t *pamh) {\n    int retval;\n    char *rhost;\n\n    retval = pam_get_item(pamh, PAM_RHOST, (void *) &rhost);\n    if (retval != PAM_SUCCESS || rhost == NULL || *rhost == '\\0') {\n        rhost = \"unknown\";\n    }\n    return rhost;\n}\n\nint converse(pam_handle_t *pamh, int nargs, const struct pam_message *message,\n             struct pam_response **response) {\n\n    int retval;\n    struct pam_conv *conv;\n\n    if ((retval = pam_get_item(pamh, PAM_CONV, (const void **) &conv)) == PAM_SUCCESS) {\n        retval = conv->conv(nargs, &message, response, conv->appdata_ptr);\n\n        if (retval != PAM_SUCCESS) {\n            _pam_log(LOG_ERR, \"(pam_tacplus) converse returned %d\", retval);\n            _pam_log(LOG_ERR, \"that is: %s\", pam_strerror(pamh, retval));\n        }\n    } else {\n        _pam_log(LOG_ERR, \"(pam_tacplus) converse failed to get pam_conv\");\n    }\n\n    return retval;\n}\n\n/* stolen from pam_stress */\nint tacacs_get_password(pam_handle_t *pamh, int flags __Unused,\n                        int ctrl, char **password) {\n\n    (void) flags;\n    const void *pam_pass;\n    char *pass = NULL;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: called\", __FUNCTION__);\n\n    if ((ctrl & (PAM_TAC_TRY_FIRST_PASS | PAM_TAC_USE_FIRST_PASS))\n        && (pam_get_item(pamh, PAM_AUTHTOK, &pam_pass) == PAM_SUCCESS)\n        && (pam_pass != NULL)) {\n        if ((pass = strdup(pam_pass)) == NULL)\n            return PAM_BUF_ERR;\n    } else if ((ctrl & PAM_TAC_USE_FIRST_PASS)) {\n        _pam_log(LOG_WARNING, \"no forwarded password\");\n        return PAM_PERM_DENIED;\n    } else {\n        struct pam_message msg;\n        struct pam_response *resp = NULL;\n        int retval;\n\n        /* set up conversation call */\n        msg.msg_style = PAM_PROMPT_ECHO_OFF;\n\n        if (!tac_prompt[0]) {\n            msg.msg = \"Password: \";\n        } else {\n            msg.msg = tac_prompt;\n        }\n\n        if ((retval = converse(pamh, 1, &msg, &resp)) != PAM_SUCCESS)\n            return retval;\n\n        if (resp != NULL) {\n            if (resp->resp == NULL && (ctrl & PAM_TAC_DEBUG))\n                _pam_log(LOG_DEBUG, \"pam_sm_authenticate: NULL authtok given\");\n\n            pass = resp->resp;    /* remember this! */\n            resp->resp = NULL;\n\n            free(resp);\n            resp = NULL;\n        } else {\n            if (ctrl & PAM_TAC_DEBUG) {\n                _pam_log(LOG_DEBUG, \"pam_sm_authenticate: no error reported\");\n                _pam_log(LOG_DEBUG, \"getting password, but NULL returned!?\");\n            }\n            return PAM_CONV_ERR;\n        }\n    }\n\n    /*\n       FIXME *password can still turn out as NULL\n       and it can't be free()d when it's NULL\n    */\n    *password = pass;       /* this *MUST* be free()'d by this module */\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: obtained password\", __FUNCTION__);\n\n    return PAM_SUCCESS;\n}\n\nvoid tac_copy_addr_info(struct addrinfo *p_dst, const struct addrinfo *p_src) {\n    if (p_dst && p_src) {\n        p_dst->ai_flags = p_src->ai_flags;\n        p_dst->ai_family = p_src->ai_family;\n        p_dst->ai_socktype = p_src->ai_socktype;\n        p_dst->ai_protocol = p_src->ai_protocol;\n        p_dst->ai_addrlen = p_src->ai_addrlen;\n\n        /* ipv6 check */\n        if (p_dst->ai_family == AF_INET6) {\n          memcpy (p_dst->ai_addr, p_src->ai_addr, sizeof(struct sockaddr_in6));\n          memset ((struct sockaddr_in6*)p_dst->ai_addr, 0 , sizeof(struct sockaddr_in6));\n          memcpy ((struct sockaddr_in6*)p_dst->ai_addr, (struct sockaddr_in6*)p_src->ai_addr, sizeof(struct sockaddr_in6));\n        } else {\n           memcpy (p_dst->ai_addr, p_src->ai_addr, sizeof(struct sockaddr)); \n        }\n\n        p_dst->ai_canonname = NULL; /* we do not care it */\n        p_dst->ai_next = NULL;      /* no more chain */\n    }\n}\n\nstatic void set_tac_srv_addr (unsigned int srv_no, const struct addrinfo *addr)\n{\n    _pam_log(LOG_DEBUG, \"%s: server [%s]\", __FUNCTION__,\n                        tac_ntop(addr->ai_addr));\n\n    if (srv_no < TAC_PLUS_MAXSERVERS) {\n        if (addr) {\n          if (addr->ai_family == AF_INET6) {\n            tac_srv_addr[srv_no].ai_addr = (struct sockaddr *)&tac_sock6_addr[srv_no];\n          } else {\n            tac_srv_addr[srv_no].ai_addr = &tac_sock_addr[srv_no];\n          }\n          tac_copy_addr_info (&tac_srv_addr[srv_no], addr);\n          tac_srv[srv_no].addr = &tac_srv_addr[srv_no];\n\n          /*this code will copy the ipv6 address to a temp variable */\n          /*and copies to global tac_srv array*/\n          if (addr->ai_family == AF_INET6) {\n            memset (&tac_sock6_addr[srv_no], 0, sizeof(struct sockaddr_in6));\n            memcpy (&tac_sock6_addr[srv_no], (struct sockaddr_in6*)addr->ai_addr, sizeof(struct sockaddr_in6));\n            tac_srv[srv_no].addr->ai_addr = (struct sockaddr *)&tac_sock6_addr[srv_no];\n          }\n          _pam_log(LOG_DEBUG, \"%s: server %d after copy [%s]\",  __FUNCTION__, srv_no,\n                        tac_ntop(tac_srv[srv_no].addr->ai_addr));\n        } \n        else {\n            tac_srv[srv_no].addr = NULL;\n        }\n    }\n}\n\nstatic void set_tac_srv_key(unsigned int srv_no, const char *key) {\n    if (srv_no < TAC_PLUS_MAXSERVERS) {\n        if (key) {\n            strncpy(tac_srv_key[srv_no], key, TAC_SECRET_MAX_LEN - 1);\n            tac_srv[srv_no].key = tac_srv_key[srv_no];\n        }\n        else {\n            _pam_log(LOG_DEBUG, \"%s: server %d key is null; address [%s]\", __FUNCTION__,srv_no,\n                              tac_ntop(tac_srv[srv_no].addr->ai_addr));\n            tac_srv[srv_no].key = NULL;\n        }\n    }\n}\n\nint _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}    /* _pam_parse */\n\n"], "filenames": ["support.c"], "buggy_code_start_loc": [377], "buggy_code_end_loc": [379], "fixing_code_start_loc": [377], "fixing_code_end_loc": [379], "type": "CWE-532", "message": "In support.c in pam_tacplus 1.3.8 through 1.5.1, the TACACS+ shared secret gets logged via syslog if the DEBUG loglevel and journald are used.", "other": {"cve": {"id": "CVE-2020-13881", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-06T19:15:09.610", "lastModified": "2022-04-05T15:04:59.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In support.c in pam_tacplus 1.3.8 through 1.5.1, the TACACS+ shared secret gets logged via syslog if the DEBUG loglevel and journald are used."}, {"lang": "es", "value": "En el archivo support.c en pam_tacplus versiones 1.3.8 hasta 1.5.1, el secreto compartido TACACS+ es registrado por medio de syslog si el nivel de registro DEBUG y journald son usados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pam_tacplus_project:pam_tacplus:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.8", "versionEndIncluding": "1.5.1", "matchCriteriaId": "5CBB04E0-1798-4128-B107-EC27FE0CEAAB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:arista:cloudvision_portal:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020.1.2", "matchCriteriaId": "35B44A14-EADC-4094-AE6E-FA8441CA52FC"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2020/06/08/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kravietz/pam_tacplus/issues/149", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/08/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4521-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.arista.com/en/support/advisories-notices/security-advisories/11705-security-advisory-50", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0"}}