{"buggy_code": ["/** \\ingroup payload\n * \\file lib/fsm.c\n * File state machine to handle a payload from a package.\n */\n\n#include \"system.h\"\n\n#include <inttypes.h>\n#include <utime.h>\n#include <errno.h>\n#include <fcntl.h>\n#if WITH_CAP\n#include <sys/capability.h>\n#endif\n\n#include <rpm/rpmte.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n#include <rpm/rpmmacro.h>\n\n#include \"rpmio/rpmio_internal.h\"\t/* fdInit/FiniDigest */\n#include \"lib/fsm.h\"\n#include \"lib/rpmte_internal.h\"\t/* XXX rpmfs */\n#include \"lib/rpmfi_internal.h\" /* rpmfiSetOnChdir */\n#include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n#include \"lib/rpmug.h\"\n\n#include \"debug.h\"\n\n#define\t_FSM_DEBUG\t0\nint _fsm_debug = _FSM_DEBUG;\n\n/* XXX Failure to remove is not (yet) cause for failure. */\nstatic int strict_erasures = 0;\n\n#define\tSUFFIX_RPMORIG\t\".rpmorig\"\n#define\tSUFFIX_RPMSAVE\t\".rpmsave\"\n#define\tSUFFIX_RPMNEW\t\".rpmnew\"\n\n/* Default directory and file permissions if not mapped */\n#define _dirPerms 0755\n#define _filePerms 0644\n\nenum filestage_e {\n    FILE_COMMIT = -1,\n    FILE_NONE   = 0,\n    FILE_PRE    = 1,\n    FILE_UNPACK = 2,\n    FILE_PREP   = 3,\n    FILE_POST   = 4,\n};\n\nstruct filedata_s {\n    int stage;\n    int setmeta;\n    int skip;\n    rpmFileAction action;\n    const char *suffix;\n    char *fpath;\n    struct stat sb;\n};\n\n/* \n * XXX Forward declarations for previously exported functions to avoid moving \n * things around needlessly \n */ \nstatic const char * fileActionString(rpmFileAction a);\nstatic int fsmOpenat(int dirfd, const char *path, int flags);\n\n/** \\ingroup payload\n * Build path to file from file info, optionally ornamented with suffix.\n * @param fi\t\tfile info iterator\n * @param suffix\tsuffix to use (NULL disables)\n * @param[out]\t\tpath to file (malloced)\n */\nstatic char * fsmFsPath(rpmfi fi, const char * suffix)\n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}\n\nstatic int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)\n{\n    int rc = linkat(odirfd, opath, dirfd, path, 0);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, %d %s) %s\\n\", __func__,\n\t       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_LINK_FAILED;\n    return rc;\n}\n\nstatic int cap_set_fileat(int dirfd, const char *path, cap_t fcaps)\n{\n    int rc = -1;\n    int fd = fsmOpenat(dirfd, path, O_RDONLY|O_NOFOLLOW);\n    if (fd >= 0) {\n\trc = cap_set_fd(fd, fcaps);\n\tclose(fd);\n    }\n    return rc;\n}\n\nstatic int fsmSetFCaps(int fd, int dirfd, const char *path, const char *captxt)\n{\n    int rc = 0;\n\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\n\tif (fd >= 0) {\n\t    if (fcaps == NULL || cap_set_fd(fd, fcaps))\n\t\trc = RPMERR_SETCAP_FAILED;\n\t} else {\n\t    if (fcaps == NULL || cap_set_fileat(dirfd, path, fcaps))\n\t\trc = RPMERR_SETCAP_FAILED;\n\t}\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %s) %s\\n\", __func__,\n\t\t   fd, dirfd, path, captxt, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}\n\nstatic int fsmClose(int *wfdp)\n{\n    int rc = 0;\n    if (wfdp && *wfdp >= 0) {\n\tint myerrno = errno;\n\tstatic int oneshot = 0;\n\tstatic int flush_io = 0;\n\tint fdno = *wfdp;\n\n\tif (!oneshot) {\n\t    flush_io = (rpmExpandNumeric(\"%{?_flush_io}\") > 0);\n\t    oneshot = 1;\n\t}\n\tif (flush_io) {\n\t    fsync(fdno);\n\t}\n\tif (close(fdno))\n\t    rc = RPMERR_CLOSE_FAILED;\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s ([%d]) %s\\n\", __func__,\n\t\t   fdno, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\t*wfdp = -1;\n\terrno = myerrno;\n    }\n    return rc;\n}\n\nstatic int fsmOpen(int *wfdp, int dirfd, const char *dest)\n{\n    int rc = 0;\n    /* Create the file with 0200 permissions (write by owner). */\n    int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT, 0200);\n\n    if (fd < 0)\n\trc = RPMERR_OPEN_FAILED;\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s [%d]) %s\\n\", __func__,\n\t       dest, fd, (rc < 0 ? strerror(errno) : \"\"));\n    }\n    *wfdp = fd;\n\n    return rc;\n}\n\nstatic int fsmUnpack(rpmfi fi, int fdno, rpmpsm psm, int nodigest)\n{\n    FD_t fd = fdDup(fdno);\n    int rc = rpmfiArchiveReadToFilePsm(fi, fd, nodigest, psm);\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s %\" PRIu64 \" bytes [%d]) %s\\n\", __func__,\n\t       rpmfiFN(fi), rpmfiFSize(fi), Fileno(fd),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    Fclose(fd);\n    return rc;\n}\n\nstatic int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest,\n\t\t     struct filedata_s ** firstlink, int *firstlinkfile,\n\t\t     int *fdp)\n{\n    int rc = 0;\n    int fd = -1;\n\n    if (*firstlink == NULL) {\n\t/* First encounter, open file for writing */\n\trc = fsmOpen(&fd, dirfd, fp->fpath);\n\t/* If it's a part of a hardlinked set, the content may come later */\n\tif (fp->sb.st_nlink > 1) {\n\t    *firstlink = fp;\n\t    *firstlinkfile = fd;\n\t}\n    } else {\n\t/* Create hard links for others and avoid redundant metadata setting */\n\tif (*firstlink != fp) {\n\t    rc = fsmLink(dirfd, (*firstlink)->fpath, dirfd, fp->fpath);\n\t}\n\tfd = *firstlinkfile;\n    }\n\n    /* If the file has content, unpack it */\n    if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = fsmUnpack(fi, fd, psm, nodigest);\n\t/* Last file of hardlink set, ensure metadata gets set */\n\tif (*firstlink) {\n\t    fp->setmeta = 1;\n\t    *firstlink = NULL;\n\t    *firstlinkfile = -1;\n\t}\n    }\n    *fdp = fd;\n\n    return rc;\n}\n\nstatic int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}\n\nstatic int fsmStat(int dirfd, const char *path, int dolstat, struct stat *sb)\n{\n    int flags = dolstat ? AT_SYMLINK_NOFOLLOW : 0;\n    int rc = fstatat(dirfd, path, sb, flags);\n\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%d %s, ost) %s\\n\",\n               __func__,\n               dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}\n\nstatic int fsmRmdir(int dirfd, const char *path)\n{\n    int rc = unlinkat(dirfd, path, AT_REMOVEDIR);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}\n\nstatic int fsmMkdir(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}\n\nstatic int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n\n    /*\n     * Only ever follow symlinks by root or target owner. Since we can't\n     * open the symlink itself, the order matters: we stat the link *after*\n     * opening the target, and if the link ownership changed between the calls\n     * it could've only been the link owner or root.\n     */\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}\n\nstatic int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,\n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n\n    /* Run fsm file pre hook for all plugins */\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n\n    /* Run fsm file post hook for all plugins */\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n\n    return rc;\n}\n\nstatic int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,\n\t\t    int quiet, int *dirfdp)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n    int rc = 0;\n\n    if (*dirfdp >= 0)\n\treturn rc;\n\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; /* special case of \"/\" */\n\n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode);\n\t    if (!rc)\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t}\n\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    rc = RPMERR_ENOTDIR;\n\t    break;\n\t}\n\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    if (!quiet) {\n\t\trpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\tbn, p, strerror(errno));\n\t    }\n\t    rc = RPMERR_OPEN_FAILED;\n\t    break;\n\t}\n\n\tdp = NULL;\n    }\n\n    if (rc) {\n\tclose(fd);\n\tclose(dirfd);\n\tdirfd = -1;\n    } else {\n\trc = 0;\n    }\n    *dirfdp = dirfd;\n\n    free(path);\n    return rc;\n}\n\nstatic int fsmMkfifo(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkfifoat(dirfd, path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\",\n\t       __func__, dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}\n\nstatic int fsmMknod(int dirfd, const char *path, mode_t mode, dev_t dev)\n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknodat(dirfd, path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%o, 0x%x) %s\\n\",\n\t       __func__, dirfd, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}\n\nstatic void removeSBITS(const char *path)\n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}\n\nstatic void fsmDebug(const char *fpath, rpmFileAction action,\n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}\n\nstatic int fsmSymlink(const char *opath, int dirfd, const char *path)\n{\n    int rc = symlinkat(opath, dirfd, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d %s) %s\\n\", __func__,\n\t       opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}\n\nstatic int fsmUnlink(int dirfd, const char *path)\n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlinkat(dirfd, path, 0);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}\n\nstatic int fsmRename(int odirfd, const char *opath, int dirfd, const char *path)\n{\n    removeSBITS(path);\n    int rc = renameat(odirfd, opath, dirfd, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\t/* Rename within the original directory */\n\trc = renameat(odirfd, path, odirfd, rmpath);\n\tif (!rc) rc = renameat(odirfd, opath, dirfd, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, %d %s) %s\\n\", __func__,\n\t       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}\n\nstatic int fsmRemove(int dirfd, const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);\n}\n\nstatic int fsmChown(int fd, int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc;\n    struct stat st;\n\n    if (fd >= 0) {\n\trc = fchown(fd, uid, gid);\n\tif (rc < 0) {\n\t    if (fstat(fd, &st) == 0 && (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\tint flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;\n\trc = fchownat(dirfd, path, uid, gid, flags);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, flags) == 0 &&\n\t\t    (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %d, %d) %s\\n\", __func__,\n\t       fd, dirfd, path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}\n\nstatic int fsmChmod(int fd, int dirfd, const char *path, mode_t mode)\n{\n    mode_t fmode = (mode & 07777);\n    int rc;\n    if (fd >= 0) {\n\trc = fchmod(fd, fmode);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstat(fd, &st) == 0 && (st.st_mode & 07777) == fmode) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\trc = fchmodat(dirfd, path, fmode, 0);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&\n\t\t    (st.st_mode & 07777) == fmode) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, 0%04o) %s\\n\", __func__,\n\t       fd, dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}\n\nstatic int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mtime)\n{\n    int rc = 0;\n    struct timespec stamps[2] = {\n\t{ .tv_sec = mtime, .tv_nsec = 0 },\n\t{ .tv_sec = mtime, .tv_nsec = 0 },\n    };\n\n    if (fd >= 0)\n\trc = futimens(fd, stamps);\n    else\n\trc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, 0x%x) %s\\n\", __func__,\n\t       fd, dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}\n\nstatic int fsmVerify(int dirfd, const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(dirfd, path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(dirfd, path, dirfd, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(dirfd, rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(dirfd, path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(dirfd, path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}\n\n#define\tIS_DEV_LOG(_x)\t\\\n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))\n\n\n\n/* Rename pre-existing modified or unmanaged file. */\nstatic int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(dirfd, opath, dirfd, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}\n\nstatic int fsmSetmeta(int fd, int dirfd, const char *path,\n\t\t      rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(fd, dirfd, path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(fd, dirfd, path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(fd, dirfd, path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(fd, dirfd, path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest,\n\t\t\t\t\t  st->st_mode, action);\n    }\n\n    return rc;\n}\n\nstatic int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(dirfd, *path, dirfd, dest);\n\t    if (!rc) {\n\t\tif (nsuffix) {\n\t\t    char * opath = fsmFsPath(fi, NULL);\n\t\t    rpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t\t   opath, dest);\n\t\t    free(opath);\n\t\t}\n\t\tfree(*path);\n\t\t*path = dest;\n\t    }\n\t}\n    }\n\n    return rc;\n}\n\n/**\n * Return formatted string representation of file disposition.\n * @param a\t\tfile disposition\n * @return\t\tformatted string\n */\nstatic const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n\n/* Remember any non-regular file state for recording in the rpmdb */\nstatic void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}\n\nstruct diriter_s {\n    int dirfd;\n};\n\nstatic int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}\n\nstatic rpmfi fsmIter(FD_t payload, rpmfiles files, rpmFileIter iter, void *data)\n{\n    rpmfi fi;\n    if (payload)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, iter);\n    if (fi && data)\n\trpmfiSetOnChdir(fi, onChdir, data);\n    return fi;\n}\n\nstatic rpmfi fsmIterFini(rpmfi fi, struct diriter_s *di)\n{\n    close(di->dirfd);\n    di->dirfd = -1;\n    return rpmfiFree(fi);\n}\n\nint rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}\n\n\nint rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    struct diriter_s di = { -1 };\n    rpmfi fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int fc = rpmfilesFC(files);\n    int fx = -1;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    int rc = 0;\n\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tfp->action = rpmfsGetAction(fs, rpmfiFX(fi));\n\n\tif (XFA_SKIPPING(fp->action))\n\t    continue;\n\n\tfp->fpath = fsmFsPath(fi, NULL);\n\t/* If the directory doesn't exist there's nothing to clean up */\n\tif (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t    continue;\n\n\trc = fsmStat(di.dirfd, fp->fpath, 1, &fp->sb);\n\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\n\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n        /* Remove erased files. */\n        if (fp->action == FA_ERASE) {\n\t    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));\n\n\t    rc = fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\n\t    /*\n\t     * Missing %ghost or %missingok entries are not errors.\n\t     * XXX: Are non-existent files ever an actual error here? Afterall\n\t     * that's exactly what we're trying to accomplish here,\n\t     * and complaining about job already done seems like kinderkarten\n\t     * level \"But it was MY turn!\" whining...\n\t     */\n\t    if (rc == RPMERR_ENOENT && missingok) {\n\t\trc = 0;\n\t    }\n\n\t    /*\n\t     * Dont whine on non-empty directories for now. We might be able\n\t     * to track at least some of the expected failures though,\n\t     * such as when we knowingly left config file backups etc behind.\n\t     */\n\t    if (rc == RPMERR_ENOTEMPTY) {\n\t\trc = 0;\n\t    }\n\n\t    if (rc) {\n\t\tint lvl = strict_erasures ? RPMLOG_ERR : RPMLOG_WARNING;\n\t\trpmlog(lvl, _(\"%s %s: remove failed: %s\\n\"),\n\t\t\tS_ISDIR(fp->sb.st_mode) ? _(\"directory\") : _(\"file\"),\n\t\t\tfp->fpath, strerror(errno));\n            }\n        }\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t  fp->sb.st_mode, fp->action, rc);\n\n        /* XXX Failure to remove is not (yet) cause for failure. */\n        if (!strict_erasures) rc = 0;\n\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\n\tif (rc == 0) {\n\t    /* Notify on success. */\n\t    /* On erase we're iterating backwards, fixup for progress */\n\t    rpm_loff_t amount = rpmfiFC(fi) - rpmfiFX(fi);\n\t    rpmpsmNotify(psm, RPMCALLBACK_UNINST_PROGRESS, amount);\n\t}\n    }\n\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n    fsmIterFini(fi, &di);\n\n    return rc;\n}\n\n\n"], "fixing_code": ["/** \\ingroup payload\n * \\file lib/fsm.c\n * File state machine to handle a payload from a package.\n */\n\n#include \"system.h\"\n\n#include <inttypes.h>\n#include <utime.h>\n#include <errno.h>\n#include <fcntl.h>\n#if WITH_CAP\n#include <sys/capability.h>\n#endif\n\n#include <rpm/rpmte.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n#include <rpm/rpmmacro.h>\n\n#include \"rpmio/rpmio_internal.h\"\t/* fdInit/FiniDigest */\n#include \"lib/fsm.h\"\n#include \"lib/rpmte_internal.h\"\t/* XXX rpmfs */\n#include \"lib/rpmfi_internal.h\" /* rpmfiSetOnChdir */\n#include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n#include \"lib/rpmug.h\"\n\n#include \"debug.h\"\n\n#define\t_FSM_DEBUG\t0\nint _fsm_debug = _FSM_DEBUG;\n\n/* XXX Failure to remove is not (yet) cause for failure. */\nstatic int strict_erasures = 0;\n\n#define\tSUFFIX_RPMORIG\t\".rpmorig\"\n#define\tSUFFIX_RPMSAVE\t\".rpmsave\"\n#define\tSUFFIX_RPMNEW\t\".rpmnew\"\n\n/* Default directory and file permissions if not mapped */\n#define _dirPerms 0755\n#define _filePerms 0644\n\nenum filestage_e {\n    FILE_COMMIT = -1,\n    FILE_NONE   = 0,\n    FILE_PRE    = 1,\n    FILE_UNPACK = 2,\n    FILE_PREP   = 3,\n    FILE_POST   = 4,\n};\n\nstruct filedata_s {\n    int stage;\n    int setmeta;\n    int skip;\n    rpmFileAction action;\n    const char *suffix;\n    char *fpath;\n    struct stat sb;\n};\n\n/* \n * XXX Forward declarations for previously exported functions to avoid moving \n * things around needlessly \n */ \nstatic const char * fileActionString(rpmFileAction a);\nstatic int fsmOpenat(int dirfd, const char *path, int flags);\n\n/** \\ingroup payload\n * Build path to file from file info, optionally ornamented with suffix.\n * @param fi\t\tfile info iterator\n * @param suffix\tsuffix to use (NULL disables)\n * @param[out]\t\tpath to file (malloced)\n */\nstatic char * fsmFsPath(rpmfi fi, const char * suffix)\n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}\n\nstatic int fsmLink(int odirfd, const char *opath, int dirfd, const char *path)\n{\n    int rc = linkat(odirfd, opath, dirfd, path, 0);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, %d %s) %s\\n\", __func__,\n\t       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_LINK_FAILED;\n    return rc;\n}\n\nstatic int cap_set_fileat(int dirfd, const char *path, cap_t fcaps)\n{\n    int rc = -1;\n    int fd = fsmOpenat(dirfd, path, O_RDONLY|O_NOFOLLOW);\n    if (fd >= 0) {\n\trc = cap_set_fd(fd, fcaps);\n\tclose(fd);\n    }\n    return rc;\n}\n\nstatic int fsmSetFCaps(int fd, int dirfd, const char *path, const char *captxt)\n{\n    int rc = 0;\n\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\n\tif (fd >= 0) {\n\t    if (fcaps == NULL || cap_set_fd(fd, fcaps))\n\t\trc = RPMERR_SETCAP_FAILED;\n\t} else {\n\t    if (fcaps == NULL || cap_set_fileat(dirfd, path, fcaps))\n\t\trc = RPMERR_SETCAP_FAILED;\n\t}\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %s) %s\\n\", __func__,\n\t\t   fd, dirfd, path, captxt, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}\n\nstatic int fsmClose(int *wfdp)\n{\n    int rc = 0;\n    if (wfdp && *wfdp >= 0) {\n\tint myerrno = errno;\n\tstatic int oneshot = 0;\n\tstatic int flush_io = 0;\n\tint fdno = *wfdp;\n\n\tif (!oneshot) {\n\t    flush_io = (rpmExpandNumeric(\"%{?_flush_io}\") > 0);\n\t    oneshot = 1;\n\t}\n\tif (flush_io) {\n\t    fsync(fdno);\n\t}\n\tif (close(fdno))\n\t    rc = RPMERR_CLOSE_FAILED;\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s ([%d]) %s\\n\", __func__,\n\t\t   fdno, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\t*wfdp = -1;\n\terrno = myerrno;\n    }\n    return rc;\n}\n\nstatic int fsmOpen(int *wfdp, int dirfd, const char *dest)\n{\n    int rc = 0;\n    /* Create the file with 0200 permissions (write by owner). */\n    int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT, 0200);\n\n    if (fd < 0)\n\trc = RPMERR_OPEN_FAILED;\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s [%d]) %s\\n\", __func__,\n\t       dest, fd, (rc < 0 ? strerror(errno) : \"\"));\n    }\n    *wfdp = fd;\n\n    return rc;\n}\n\nstatic int fsmUnpack(rpmfi fi, int fdno, rpmpsm psm, int nodigest)\n{\n    FD_t fd = fdDup(fdno);\n    int rc = rpmfiArchiveReadToFilePsm(fi, fd, nodigest, psm);\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s %\" PRIu64 \" bytes [%d]) %s\\n\", __func__,\n\t       rpmfiFN(fi), rpmfiFSize(fi), Fileno(fd),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    Fclose(fd);\n    return rc;\n}\n\nstatic int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest,\n\t\t     struct filedata_s ** firstlink, int *firstlinkfile,\n\t\t     int *fdp)\n{\n    int rc = 0;\n    int fd = -1;\n\n    if (*firstlink == NULL) {\n\t/* First encounter, open file for writing */\n\trc = fsmOpen(&fd, dirfd, fp->fpath);\n\t/* If it's a part of a hardlinked set, the content may come later */\n\tif (fp->sb.st_nlink > 1) {\n\t    *firstlink = fp;\n\t    *firstlinkfile = fd;\n\t}\n    } else {\n\t/* Create hard links for others and avoid redundant metadata setting */\n\tif (*firstlink != fp) {\n\t    rc = fsmLink(dirfd, (*firstlink)->fpath, dirfd, fp->fpath);\n\t}\n\tfd = *firstlinkfile;\n    }\n\n    /* If the file has content, unpack it */\n    if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = fsmUnpack(fi, fd, psm, nodigest);\n\t/* Last file of hardlink set, ensure metadata gets set */\n\tif (*firstlink) {\n\t    fp->setmeta = 1;\n\t    *firstlink = NULL;\n\t    *firstlinkfile = -1;\n\t}\n    }\n    *fdp = fd;\n\n    return rc;\n}\n\nstatic int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}\n\nstatic int fsmStat(int dirfd, const char *path, int dolstat, struct stat *sb)\n{\n    int flags = dolstat ? AT_SYMLINK_NOFOLLOW : 0;\n    int rc = fstatat(dirfd, path, sb, flags);\n\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%d %s, ost) %s\\n\",\n               __func__,\n               dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}\n\nstatic int fsmRmdir(int dirfd, const char *path)\n{\n    int rc = unlinkat(dirfd, path, AT_REMOVEDIR);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}\n\nstatic int fsmMkdir(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}\n\nstatic int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n\n    /*\n     * Only ever follow symlinks by root or target owner. Since we can't\n     * open the symlink itself, the order matters: we stat the link *after*\n     * opening the target, and if the link ownership changed between the calls\n     * it could've only been the link owner or root.\n     */\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}\n\nstatic int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,\n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n\n    /* Run fsm file pre hook for all plugins */\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n\n    /* Run fsm file post hook for all plugins */\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n\n    return rc;\n}\n\nstatic int ensureDir(rpmPlugins plugins, const char *p, int owned, int create,\n\t\t    int quiet, int *dirfdp)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n    int rc = 0;\n\n    if (*dirfdp >= 0)\n\treturn rc;\n\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; /* special case of \"/\" */\n\n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode);\n\t    if (!rc)\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t}\n\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    rc = RPMERR_ENOTDIR;\n\t    break;\n\t}\n\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    if (!quiet) {\n\t\trpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\tbn, p, strerror(errno));\n\t    }\n\t    rc = RPMERR_OPEN_FAILED;\n\t    break;\n\t}\n\n\tdp = NULL;\n    }\n\n    if (rc) {\n\tclose(fd);\n\tclose(dirfd);\n\tdirfd = -1;\n    } else {\n\trc = 0;\n    }\n    *dirfdp = dirfd;\n\n    free(path);\n    return rc;\n}\n\nstatic int fsmMkfifo(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkfifoat(dirfd, path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\",\n\t       __func__, dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}\n\nstatic int fsmMknod(int dirfd, const char *path, mode_t mode, dev_t dev)\n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknodat(dirfd, path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%o, 0x%x) %s\\n\",\n\t       __func__, dirfd, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}\n\nstatic void removeSBITS(const char *path)\n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}\n\nstatic void fsmDebug(const char *fpath, rpmFileAction action,\n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}\n\nstatic int fsmSymlink(const char *opath, int dirfd, const char *path)\n{\n    int rc = symlinkat(opath, dirfd, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d %s) %s\\n\", __func__,\n\t       opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}\n\nstatic int fsmUnlink(int dirfd, const char *path)\n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlinkat(dirfd, path, 0);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}\n\nstatic int fsmRename(int odirfd, const char *opath, int dirfd, const char *path)\n{\n    removeSBITS(path);\n    int rc = renameat(odirfd, opath, dirfd, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\t/* Rename within the original directory */\n\trc = renameat(odirfd, path, odirfd, rmpath);\n\tif (!rc) rc = renameat(odirfd, opath, dirfd, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, %d %s) %s\\n\", __func__,\n\t       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}\n\nstatic int fsmRemove(int dirfd, const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);\n}\n\nstatic int fsmChown(int fd, int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc;\n    struct stat st;\n\n    if (fd >= 0) {\n\trc = fchown(fd, uid, gid);\n\tif (rc < 0) {\n\t    if (fstat(fd, &st) == 0 && (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\tint flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;\n\trc = fchownat(dirfd, path, uid, gid, flags);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, flags) == 0 &&\n\t\t    (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %d, %d) %s\\n\", __func__,\n\t       fd, dirfd, path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}\n\nstatic int fsmChmod(int fd, int dirfd, const char *path, mode_t mode)\n{\n    mode_t fmode = (mode & 07777);\n    int rc;\n    if (fd >= 0) {\n\trc = fchmod(fd, fmode);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstat(fd, &st) == 0 && (st.st_mode & 07777) == fmode) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\trc = fchmodat(dirfd, path, fmode, 0);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&\n\t\t    (st.st_mode & 07777) == fmode) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, 0%04o) %s\\n\", __func__,\n\t       fd, dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}\n\nstatic int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mtime)\n{\n    int rc = 0;\n    struct timespec stamps[2] = {\n\t{ .tv_sec = mtime, .tv_nsec = 0 },\n\t{ .tv_sec = mtime, .tv_nsec = 0 },\n    };\n\n    if (fd >= 0)\n\trc = futimens(fd, stamps);\n    else\n\trc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, 0x%x) %s\\n\", __func__,\n\t       fd, dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}\n\nstatic int fsmVerify(int dirfd, const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(dirfd, path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(dirfd, path, dirfd, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(dirfd, rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(dirfd, path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(dirfd, path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}\n\n#define\tIS_DEV_LOG(_x)\t\\\n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))\n\n\n\n/* Rename pre-existing modified or unmanaged file. */\nstatic int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(dirfd, opath, dirfd, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}\n\nstatic int fsmSetmeta(int fd, int dirfd, const char *path,\n\t\t      rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(fd, dirfd, path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(fd, dirfd, path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(fd, dirfd, path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(fd, dirfd, path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest,\n\t\t\t\t\t  st->st_mode, action);\n    }\n\n    return rc;\n}\n\nstatic int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(dirfd, *path, dirfd, dest);\n\t    if (!rc) {\n\t\tif (nsuffix) {\n\t\t    char * opath = fsmFsPath(fi, NULL);\n\t\t    rpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t\t   opath, dest);\n\t\t    free(opath);\n\t\t}\n\t\tfree(*path);\n\t\t*path = dest;\n\t    }\n\t}\n    }\n\n    return rc;\n}\n\n/**\n * Return formatted string representation of file disposition.\n * @param a\t\tfile disposition\n * @return\t\tformatted string\n */\nstatic const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n\n/* Remember any non-regular file state for recording in the rpmdb */\nstatic void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}\n\nstruct diriter_s {\n    int dirfd;\n};\n\nstatic int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}\n\nstatic rpmfi fsmIter(FD_t payload, rpmfiles files, rpmFileIter iter, void *data)\n{\n    rpmfi fi;\n    if (payload)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, iter);\n    if (fi && data)\n\trpmfiSetOnChdir(fi, onChdir, data);\n    return fi;\n}\n\nstatic rpmfi fsmIterFini(rpmfi fi, struct diriter_s *di)\n{\n    close(di->dirfd);\n    di->dirfd = -1;\n    return rpmfiFree(fi);\n}\n\nint rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\n\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n\t\t/* Only follow safe symlinks, and never on temporary files */\n\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n\t\tif (fd < 0)\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t    }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}\n\n\nint rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    struct diriter_s di = { -1 };\n    rpmfi fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int fc = rpmfilesFC(files);\n    int fx = -1;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    int rc = 0;\n\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tfp->action = rpmfsGetAction(fs, rpmfiFX(fi));\n\n\tif (XFA_SKIPPING(fp->action))\n\t    continue;\n\n\tfp->fpath = fsmFsPath(fi, NULL);\n\t/* If the directory doesn't exist there's nothing to clean up */\n\tif (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t    continue;\n\n\trc = fsmStat(di.dirfd, fp->fpath, 1, &fp->sb);\n\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\n\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n        /* Remove erased files. */\n        if (fp->action == FA_ERASE) {\n\t    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));\n\n\t    rc = fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\n\t    /*\n\t     * Missing %ghost or %missingok entries are not errors.\n\t     * XXX: Are non-existent files ever an actual error here? Afterall\n\t     * that's exactly what we're trying to accomplish here,\n\t     * and complaining about job already done seems like kinderkarten\n\t     * level \"But it was MY turn!\" whining...\n\t     */\n\t    if (rc == RPMERR_ENOENT && missingok) {\n\t\trc = 0;\n\t    }\n\n\t    /*\n\t     * Dont whine on non-empty directories for now. We might be able\n\t     * to track at least some of the expected failures though,\n\t     * such as when we knowingly left config file backups etc behind.\n\t     */\n\t    if (rc == RPMERR_ENOTEMPTY) {\n\t\trc = 0;\n\t    }\n\n\t    if (rc) {\n\t\tint lvl = strict_erasures ? RPMLOG_ERR : RPMLOG_WARNING;\n\t\trpmlog(lvl, _(\"%s %s: remove failed: %s\\n\"),\n\t\t\tS_ISDIR(fp->sb.st_mode) ? _(\"directory\") : _(\"file\"),\n\t\t\tfp->fpath, strerror(errno));\n            }\n        }\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t  fp->sb.st_mode, fp->action, rc);\n\n        /* XXX Failure to remove is not (yet) cause for failure. */\n        if (!strict_erasures) rc = 0;\n\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\n\tif (rc == 0) {\n\t    /* Notify on success. */\n\t    /* On erase we're iterating backwards, fixup for progress */\n\t    rpm_loff_t amount = rpmfiFC(fi) - rpmfiFX(fi);\n\t    rpmpsmNotify(psm, RPMCALLBACK_UNINST_PROGRESS, amount);\n\t}\n    }\n\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n    fsmIterFini(fi, &di);\n\n    return rc;\n}\n\n\n"], "filenames": ["lib/fsm.c"], "buggy_code_start_loc": [992], "buggy_code_end_loc": [992], "fixing_code_start_loc": [993], "fixing_code_end_loc": [1001], "type": "CWE-59", "message": "A symbolic link issue was found in rpm. It occurs when rpm sets the desired permissions and credentials after installing a file. A local unprivileged user could use this flaw to exchange the original file with a symbolic link to a security-critical file and escalate their privileges on the system. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.", "other": {"cve": {"id": "CVE-2021-35938", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-25T20:15:09.307", "lastModified": "2022-11-29T18:06:15.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A symbolic link issue was found in rpm. It occurs when rpm sets the desired permissions and credentials after installing a file. A local unprivileged user could use this flaw to exchange the original file with a symbolic link to a security-critical file and escalate their privileges on the system. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability."}, {"lang": "es", "value": "Se ha encontrado un problema de enlaces simb\u00f3licos en rpm. Es producido cuando rpm establece los permisos y credenciales deseados despu\u00e9s de instalar un archivo. Un usuario local no privilegiado podr\u00eda usar este fallo para cambiar el archivo original por un enlace simb\u00f3lico a un archivo cr\u00edtico para la seguridad y escalar sus privilegios en el sistema. La mayor amenaza de esta vulnerabilidad es para la confidencialidad e integridad de los datos, as\u00ed como para la disponibilidad del sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.18.0", "matchCriteriaId": "2E92EAAF-D2B5-458B-BBF4-363FD16D3931"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-35938", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1964114", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1157880", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/rpm/pull/1919", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://rpm.org/wiki/Releases/4.18.0", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "https://security.gentoo.org/glsa/202210-22", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033"}}