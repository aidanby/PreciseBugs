{"buggy_code": ["package server\n\nimport (\n\t\"crypto/sha256\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n\t\"github.com/gorilla/mux\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/connector\"\n\t\"github.com/dexidp/dex/server/internal\"\n\t\"github.com/dexidp/dex/storage\"\n)\n\nconst (\n\tcodeChallengeMethodPlain = \"plain\"\n\tcodeChallengeMethodS256  = \"S256\"\n)\n\nfunc (s *Server) handlePublicKeys(w http.ResponseWriter, r *http.Request) {\n\t// TODO(ericchiang): Cache this.\n\tkeys, err := s.storage.GetKeys()\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to get keys: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\treturn\n\t}\n\n\tif keys.SigningKeyPub == nil {\n\t\ts.logger.Errorf(\"No public keys found.\")\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\treturn\n\t}\n\n\tjwks := jose.JSONWebKeySet{\n\t\tKeys: make([]jose.JSONWebKey, len(keys.VerificationKeys)+1),\n\t}\n\tjwks.Keys[0] = *keys.SigningKeyPub\n\tfor i, verificationKey := range keys.VerificationKeys {\n\t\tjwks.Keys[i+1] = *verificationKey.PublicKey\n\t}\n\n\tdata, err := json.MarshalIndent(jwks, \"\", \"  \")\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to marshal discovery data: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\treturn\n\t}\n\tmaxAge := keys.NextRotation.Sub(s.now())\n\tif maxAge < (time.Minute * 2) {\n\t\tmaxAge = time.Minute * 2\n\t}\n\n\tw.Header().Set(\"Cache-Control\", fmt.Sprintf(\"max-age=%d, must-revalidate\", int(maxAge.Seconds())))\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\tw.Write(data)\n}\n\ntype discovery struct {\n\tIssuer            string   `json:\"issuer\"`\n\tAuth              string   `json:\"authorization_endpoint\"`\n\tToken             string   `json:\"token_endpoint\"`\n\tKeys              string   `json:\"jwks_uri\"`\n\tUserInfo          string   `json:\"userinfo_endpoint\"`\n\tDeviceEndpoint    string   `json:\"device_authorization_endpoint\"`\n\tGrantTypes        []string `json:\"grant_types_supported\"`\n\tResponseTypes     []string `json:\"response_types_supported\"`\n\tSubjects          []string `json:\"subject_types_supported\"`\n\tIDTokenAlgs       []string `json:\"id_token_signing_alg_values_supported\"`\n\tCodeChallengeAlgs []string `json:\"code_challenge_methods_supported\"`\n\tScopes            []string `json:\"scopes_supported\"`\n\tAuthMethods       []string `json:\"token_endpoint_auth_methods_supported\"`\n\tClaims            []string `json:\"claims_supported\"`\n}\n\nfunc (s *Server) discoveryHandler() (http.HandlerFunc, error) {\n\td := discovery{\n\t\tIssuer:            s.issuerURL.String(),\n\t\tAuth:              s.absURL(\"/auth\"),\n\t\tToken:             s.absURL(\"/token\"),\n\t\tKeys:              s.absURL(\"/keys\"),\n\t\tUserInfo:          s.absURL(\"/userinfo\"),\n\t\tDeviceEndpoint:    s.absURL(\"/device/code\"),\n\t\tSubjects:          []string{\"public\"},\n\t\tIDTokenAlgs:       []string{string(jose.RS256)},\n\t\tCodeChallengeAlgs: []string{codeChallengeMethodS256, codeChallengeMethodPlain},\n\t\tScopes:            []string{\"openid\", \"email\", \"groups\", \"profile\", \"offline_access\"},\n\t\tAuthMethods:       []string{\"client_secret_basic\", \"client_secret_post\"},\n\t\tClaims: []string{\n\t\t\t\"iss\", \"sub\", \"aud\", \"iat\", \"exp\", \"email\", \"email_verified\",\n\t\t\t\"locale\", \"name\", \"preferred_username\", \"at_hash\",\n\t\t},\n\t}\n\n\tfor responseType := range s.supportedResponseTypes {\n\t\td.ResponseTypes = append(d.ResponseTypes, responseType)\n\t}\n\tsort.Strings(d.ResponseTypes)\n\n\td.GrantTypes = s.supportedGrantTypes\n\n\tdata, err := json.MarshalIndent(d, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal discovery data: %v\", err)\n\t}\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\t\tw.Write(data)\n\t}), nil\n}\n\n// handleAuthorization handles the OAuth2 auth endpoint.\nfunc (s *Server) handleAuthorization(w http.ResponseWriter, r *http.Request) {\n\t// Extract the arguments\n\tif err := r.ParseForm(); err != nil {\n\t\ts.logger.Errorf(\"Failed to parse arguments: %v\", err)\n\n\t\ts.renderError(r, w, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\n\tconnectorID := r.Form.Get(\"connector_id\")\n\n\tconnectors, err := s.storage.ListConnectors()\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get list of connectors: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Failed to retrieve connector list.\")\n\t\treturn\n\t}\n\n\t// We don't need connector_id any more\n\tr.Form.Del(\"connector_id\")\n\n\t// Construct a URL with all of the arguments in its query\n\tconnURL := url.URL{\n\t\tRawQuery: r.Form.Encode(),\n\t}\n\n\t// Redirect if a client chooses a specific connector_id\n\tif connectorID != \"\" {\n\t\tfor _, c := range connectors {\n\t\t\tif c.ID == connectorID {\n\t\t\t\tconnURL.Path = s.absPath(\"/auth\", url.PathEscape(c.ID))\n\t\t\t\thttp.Redirect(w, r, connURL.String(), http.StatusFound)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Connector ID does not match a valid Connector\")\n\t\treturn\n\t}\n\n\tif len(connectors) == 1 && !s.alwaysShowLogin {\n\t\tconnURL.Path = s.absPath(\"/auth\", url.PathEscape(connectors[0].ID))\n\t\thttp.Redirect(w, r, connURL.String(), http.StatusFound)\n\t}\n\n\tconnectorInfos := make([]connectorInfo, len(connectors))\n\tfor index, conn := range connectors {\n\t\tconnURL.Path = s.absPath(\"/auth\", url.PathEscape(conn.ID))\n\t\tconnectorInfos[index] = connectorInfo{\n\t\t\tID:   conn.ID,\n\t\t\tName: conn.Name,\n\t\t\tType: conn.Type,\n\t\t\tURL:  template.URL(connURL.String()),\n\t\t}\n\t}\n\n\tif err := s.templates.login(r, w, connectorInfos); err != nil {\n\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t}\n}\n\nfunc (s *Server) handleConnectorLogin(w http.ResponseWriter, r *http.Request) {\n\tauthReq, err := s.parseAuthorizationRequest(r)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to parse authorization request: %v\", err)\n\n\t\tswitch authErr := err.(type) {\n\t\tcase *redirectedAuthErr:\n\t\t\tauthErr.Handler().ServeHTTP(w, r)\n\t\tcase *displayedAuthErr:\n\t\t\ts.renderError(r, w, authErr.Status, err.Error())\n\t\tdefault:\n\t\t\tpanic(\"unsupported error type\")\n\t\t}\n\n\t\treturn\n\t}\n\n\tconnID, err := url.PathUnescape(mux.Vars(r)[\"connector\"])\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to parse connector: %v\", err)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist\")\n\t\treturn\n\t}\n\n\tconn, err := s.getConnector(connID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector: %v\", err)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist\")\n\t\treturn\n\t}\n\n\t// Set the connector being used for the login.\n\tif authReq.ConnectorID != \"\" && authReq.ConnectorID != connID {\n\t\ts.logger.Errorf(\"Mismatched connector ID in auth request: %s vs %s\",\n\t\t\tauthReq.ConnectorID, connID)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Bad connector ID\")\n\t\treturn\n\t}\n\n\tauthReq.ConnectorID = connID\n\n\t// Actually create the auth request\n\tauthReq.Expiry = s.now().Add(s.authRequestsValidFor)\n\tif err := s.storage.CreateAuthRequest(*authReq); err != nil {\n\t\ts.logger.Errorf(\"Failed to create authorization request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Failed to connect to the database.\")\n\t\treturn\n\t}\n\n\tscopes := parseScopes(authReq.Scopes)\n\n\t// Work out where the \"Select another login method\" link should go.\n\tbackLink := \"\"\n\tif len(s.connectors) > 1 {\n\t\tbackLinkURL := url.URL{\n\t\t\tPath:     s.absPath(\"/auth\"),\n\t\t\tRawQuery: r.Form.Encode(),\n\t\t}\n\t\tbackLink = backLinkURL.String()\n\t}\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tswitch conn := conn.Connector.(type) {\n\t\tcase connector.CallbackConnector:\n\t\t\t// Use the auth request ID as the \"state\" token.\n\t\t\t//\n\t\t\t// TODO(ericchiang): Is this appropriate or should we also be using a nonce?\n\t\t\tcallbackURL, err := conn.LoginURL(scopes, s.absURL(\"/callback\"), authReq.ID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"Connector %q returned error when creating callback: %v\", connID, err)\n\t\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login error.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Redirect(w, r, callbackURL, http.StatusFound)\n\t\tcase connector.PasswordConnector:\n\t\t\tloginURL := url.URL{\n\t\t\t\tPath: s.absPath(\"/auth\", connID, \"login\"),\n\t\t\t}\n\t\t\tq := loginURL.Query()\n\t\t\tq.Set(\"state\", authReq.ID)\n\t\t\tq.Set(\"back\", backLink)\n\t\t\tloginURL.RawQuery = q.Encode()\n\n\t\t\thttp.Redirect(w, r, loginURL.String(), http.StatusFound)\n\t\tcase connector.SAMLConnector:\n\t\t\taction, value, err := conn.POSTData(scopes, authReq.ID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"Creating SAML data: %v\", err)\n\t\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Connector Login Error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// TODO(ericchiang): Don't inline this.\n\t\t\tfmt.Fprintf(w, `<!DOCTYPE html>\n\t\t\t  <html lang=\"en\">\n\t\t\t  <head>\n\t\t\t    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n\t\t\t    <title>SAML login</title>\n\t\t\t  </head>\n\t\t\t  <body>\n\t\t\t    <form method=\"post\" action=\"%s\" >\n\t\t\t\t    <input type=\"hidden\" name=\"SAMLRequest\" value=\"%s\" />\n\t\t\t\t    <input type=\"hidden\" name=\"RelayState\" value=\"%s\" />\n\t\t\t    </form>\n\t\t\t\t<script>\n\t\t\t\t    document.forms[0].submit();\n\t\t\t\t</script>\n\t\t\t  </body>\n\t\t\t  </html>`, action, value, authReq.ID)\n\t\tdefault:\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist.\")\n\t\t}\n\tdefault:\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Unsupported request method.\")\n\t}\n}\n\nfunc (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {\n\tauthID := r.URL.Query().Get(\"state\")\n\tif authID == \"\" {\n\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\treturn\n\t}\n\n\tbackLink := r.URL.Query().Get(\"back\")\n\n\tauthReq, err := s.storage.GetAuthRequest(authID)\n\tif err != nil {\n\t\tif err == storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Invalid 'state' parameter provided: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist.\")\n\t\t\treturn\n\t\t}\n\t\ts.logger.Errorf(\"Failed to get auth request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Database error.\")\n\t\treturn\n\t}\n\n\tconnID, err := url.PathUnescape(mux.Vars(r)[\"connector\"])\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to parse connector: %v\", err)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist\")\n\t\treturn\n\t} else if connID != \"\" && connID != authReq.ConnectorID {\n\t\ts.logger.Errorf(\"Connector mismatch: authentication started with id %q, but password login for id %q was triggered\", authReq.ConnectorID, connID)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tconn, err := s.getConnector(authReq.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector with id %q : %v\", authReq.ConnectorID, err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tpwConn, ok := conn.Connector.(connector.PasswordConnector)\n\tif !ok {\n\t\ts.logger.Errorf(\"Expected password connector in handlePasswordLogin(), but got %v\", pwConn)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif err := s.templates.password(r, w, r.URL.String(), \"\", usernamePrompt(pwConn), false, backLink); err != nil {\n\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t}\n\tcase http.MethodPost:\n\t\tusername := r.FormValue(\"login\")\n\t\tpassword := r.FormValue(\"password\")\n\t\tscopes := parseScopes(authReq.Scopes)\n\n\t\tidentity, ok, err := pwConn.Login(r.Context(), scopes, username, password)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to login user: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, fmt.Sprintf(\"Login error: %v\", err))\n\t\t\treturn\n\t\t}\n\t\tif !ok {\n\t\t\tif err := s.templates.password(r, w, r.URL.String(), username, usernamePrompt(pwConn), true, backLink); err != nil {\n\t\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tredirectURL, err := s.finalizeLogin(identity, authReq, conn.Connector)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to finalize login: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login error.\")\n\t\t\treturn\n\t\t}\n\n\t\thttp.Redirect(w, r, redirectURL, http.StatusSeeOther)\n\tdefault:\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Unsupported request method.\")\n\t}\n}\n\nfunc (s *Server) handleConnectorCallback(w http.ResponseWriter, r *http.Request) {\n\tvar authID string\n\tswitch r.Method {\n\tcase http.MethodGet: // OAuth2 callback\n\t\tif authID = r.URL.Query().Get(\"state\"); authID == \"\" {\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\t\treturn\n\t\t}\n\tcase http.MethodPost: // SAML POST binding\n\t\tif authID = r.PostFormValue(\"RelayState\"); authID == \"\" {\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Method not supported\")\n\t\treturn\n\t}\n\n\tauthReq, err := s.storage.GetAuthRequest(authID)\n\tif err != nil {\n\t\tif err == storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Invalid 'state' parameter provided: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist.\")\n\t\t\treturn\n\t\t}\n\t\ts.logger.Errorf(\"Failed to get auth request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Database error.\")\n\t\treturn\n\t}\n\n\tconnID, err := url.PathUnescape(mux.Vars(r)[\"connector\"])\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector with id %q : %v\", authReq.ConnectorID, err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t} else if connID != \"\" && connID != authReq.ConnectorID {\n\t\ts.logger.Errorf(\"Connector mismatch: authentication started with id %q, but callback for id %q was triggered\", authReq.ConnectorID, connID)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tconn, err := s.getConnector(authReq.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector with id %q : %v\", authReq.ConnectorID, err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tvar identity connector.Identity\n\tswitch conn := conn.Connector.(type) {\n\tcase connector.CallbackConnector:\n\t\tif r.Method != http.MethodGet {\n\t\t\ts.logger.Errorf(\"SAML request mapped to OAuth2 connector\")\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Invalid request\")\n\t\t\treturn\n\t\t}\n\t\tidentity, err = conn.HandleCallback(parseScopes(authReq.Scopes), r)\n\tcase connector.SAMLConnector:\n\t\tif r.Method != http.MethodPost {\n\t\t\ts.logger.Errorf(\"OAuth2 request mapped to SAML connector\")\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Invalid request\")\n\t\t\treturn\n\t\t}\n\t\tidentity, err = conn.HandlePOST(parseScopes(authReq.Scopes), r.PostFormValue(\"SAMLResponse\"), authReq.ID)\n\tdefault:\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to authenticate: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, fmt.Sprintf(\"Failed to authenticate: %v\", err))\n\t\treturn\n\t}\n\n\tredirectURL, err := s.finalizeLogin(identity, authReq, conn.Connector)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to finalize login: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login error.\")\n\t\treturn\n\t}\n\n\thttp.Redirect(w, r, redirectURL, http.StatusSeeOther)\n}\n\n// finalizeLogin associates the user's identity with the current AuthRequest, then returns\n// the approval page's path.\nfunc (s *Server) finalizeLogin(identity connector.Identity, authReq storage.AuthRequest, conn connector.Connector) (string, error) {\n\tclaims := storage.Claims{\n\t\tUserID:            identity.UserID,\n\t\tUsername:          identity.Username,\n\t\tPreferredUsername: identity.PreferredUsername,\n\t\tEmail:             identity.Email,\n\t\tEmailVerified:     identity.EmailVerified,\n\t\tGroups:            identity.Groups,\n\t}\n\n\tupdater := func(a storage.AuthRequest) (storage.AuthRequest, error) {\n\t\ta.LoggedIn = true\n\t\ta.Claims = claims\n\t\ta.ConnectorData = identity.ConnectorData\n\t\treturn a, nil\n\t}\n\tif err := s.storage.UpdateAuthRequest(authReq.ID, updater); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to update auth request: %v\", err)\n\t}\n\n\temail := claims.Email\n\tif !claims.EmailVerified {\n\t\temail += \" (unverified)\"\n\t}\n\n\ts.logger.Infof(\"login successful: connector %q, username=%q, preferred_username=%q, email=%q, groups=%q\",\n\t\tauthReq.ConnectorID, claims.Username, claims.PreferredUsername, email, claims.Groups)\n\n\treturnURL := path.Join(s.issuerURL.Path, \"/approval\") + \"?req=\" + authReq.ID\n\t_, ok := conn.(connector.RefreshConnector)\n\tif !ok {\n\t\treturn returnURL, nil\n\t}\n\n\t// Try to retrieve an existing OfflineSession object for the corresponding user.\n\tsession, err := s.storage.GetOfflineSessions(identity.UserID, authReq.ConnectorID)\n\tif err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"failed to get offline session: %v\", err)\n\t\t\treturn \"\", err\n\t\t}\n\t\tofflineSessions := storage.OfflineSessions{\n\t\t\tUserID:        identity.UserID,\n\t\t\tConnID:        authReq.ConnectorID,\n\t\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\t\tConnectorData: identity.ConnectorData,\n\t\t}\n\n\t\t// Create a new OfflineSession object for the user and add a reference object for\n\t\t// the newly received refreshtoken.\n\t\tif err := s.storage.CreateOfflineSessions(offlineSessions); err != nil {\n\t\t\ts.logger.Errorf(\"failed to create offline session: %v\", err)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn returnURL, nil\n\t}\n\n\t// Update existing OfflineSession obj with new RefreshTokenRef.\n\tif err := s.storage.UpdateOfflineSessions(session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\tif len(identity.ConnectorData) > 0 {\n\t\t\told.ConnectorData = identity.ConnectorData\n\t\t}\n\t\treturn old, nil\n\t}); err != nil {\n\t\ts.logger.Errorf(\"failed to update offline session: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn returnURL, nil\n}\n\nfunc (s *Server) handleApproval(w http.ResponseWriter, r *http.Request) {\n\tauthReq, err := s.storage.GetAuthRequest(r.FormValue(\"req\"))\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get auth request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Database error.\")\n\t\treturn\n\t}\n\tif !authReq.LoggedIn {\n\t\ts.logger.Errorf(\"Auth request does not have an identity for approval\")\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login process not yet finalized.\")\n\t\treturn\n\t}\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif s.skipApproval {\n\t\t\ts.sendCodeResponse(w, r, authReq)\n\t\t\treturn\n\t\t}\n\t\tclient, err := s.storage.GetClient(authReq.ClientID)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to get client %q: %v\", authReq.ClientID, err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Failed to retrieve client.\")\n\t\t\treturn\n\t\t}\n\t\tif err := s.templates.approval(r, w, authReq.ID, authReq.Claims.Username, client.Name, authReq.Scopes); err != nil {\n\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t}\n\tcase http.MethodPost:\n\t\tif r.FormValue(\"approval\") != \"approve\" {\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Approval rejected.\")\n\t\t\treturn\n\t\t}\n\t\ts.sendCodeResponse(w, r, authReq)\n\t}\n}\n\nfunc (s *Server) sendCodeResponse(w http.ResponseWriter, r *http.Request, authReq storage.AuthRequest) {\n\tif s.now().After(authReq.Expiry) {\n\t\ts.renderError(r, w, http.StatusBadRequest, \"User session has expired.\")\n\t\treturn\n\t}\n\n\tif err := s.storage.DeleteAuthRequest(authReq.ID); err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Failed to delete authorization request: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\t} else {\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\t}\n\t\treturn\n\t}\n\tu, err := url.Parse(authReq.RedirectURI)\n\tif err != nil {\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Invalid redirect URI.\")\n\t\treturn\n\t}\n\n\tvar (\n\t\t// Was the initial request using the implicit or hybrid flow instead of\n\t\t// the \"normal\" code flow?\n\t\timplicitOrHybrid = false\n\n\t\t// Only present in hybrid or code flow. code.ID == \"\" if this is not set.\n\t\tcode storage.AuthCode\n\n\t\t// ID token returned immediately if the response_type includes \"id_token\".\n\t\t// Only valid for implicit and hybrid flows.\n\t\tidToken       string\n\t\tidTokenExpiry time.Time\n\n\t\t// Access token\n\t\taccessToken string\n\t)\n\n\tfor _, responseType := range authReq.ResponseTypes {\n\t\tswitch responseType {\n\t\tcase responseTypeCode:\n\t\t\tcode = storage.AuthCode{\n\t\t\t\tID:            storage.NewID(),\n\t\t\t\tClientID:      authReq.ClientID,\n\t\t\t\tConnectorID:   authReq.ConnectorID,\n\t\t\t\tNonce:         authReq.Nonce,\n\t\t\t\tScopes:        authReq.Scopes,\n\t\t\t\tClaims:        authReq.Claims,\n\t\t\t\tExpiry:        s.now().Add(time.Minute * 30),\n\t\t\t\tRedirectURI:   authReq.RedirectURI,\n\t\t\t\tConnectorData: authReq.ConnectorData,\n\t\t\t\tPKCE:          authReq.PKCE,\n\t\t\t}\n\t\t\tif err := s.storage.CreateAuthCode(code); err != nil {\n\t\t\t\ts.logger.Errorf(\"Failed to create auth code: %v\", err)\n\t\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Implicit and hybrid flows that try to use the OOB redirect URI are\n\t\t\t// rejected earlier. If we got here we're using the code flow.\n\t\t\tif authReq.RedirectURI == redirectURIOOB {\n\t\t\t\tif err := s.templates.oob(r, w, code.ID); err != nil {\n\t\t\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\tcase responseTypeToken:\n\t\t\timplicitOrHybrid = true\n\t\tcase responseTypeIDToken:\n\t\t\timplicitOrHybrid = true\n\t\t\tvar err error\n\n\t\t\taccessToken, err = s.newAccessToken(authReq.ClientID, authReq.Claims, authReq.Scopes, authReq.Nonce, authReq.ConnectorID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create new access token: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tidToken, idTokenExpiry, err = s.newIDToken(authReq.ClientID, authReq.Claims, authReq.Scopes, authReq.Nonce, accessToken, code.ID, authReq.ConnectorID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create ID token: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif implicitOrHybrid {\n\t\tv := url.Values{}\n\t\tv.Set(\"access_token\", accessToken)\n\t\tv.Set(\"token_type\", \"bearer\")\n\t\tv.Set(\"state\", authReq.State)\n\t\tif idToken != \"\" {\n\t\t\tv.Set(\"id_token\", idToken)\n\t\t\t// The hybrid flow with only \"code token\" or \"code id_token\" doesn't return an\n\t\t\t// \"expires_in\" value. If \"code\" wasn't provided, indicating the implicit flow,\n\t\t\t// don't add it.\n\t\t\t//\n\t\t\t// https://openid.net/specs/openid-connect-core-1_0.html#HybridAuthResponse\n\t\t\tif code.ID == \"\" {\n\t\t\t\tv.Set(\"expires_in\", strconv.Itoa(int(idTokenExpiry.Sub(s.now()).Seconds())))\n\t\t\t}\n\t\t}\n\t\tif code.ID != \"\" {\n\t\t\tv.Set(\"code\", code.ID)\n\t\t}\n\n\t\t// Implicit and hybrid flows return their values as part of the fragment.\n\t\t//\n\t\t//   HTTP/1.1 303 See Other\n\t\t//   Location: https://client.example.org/cb#\n\t\t//     access_token=SlAV32hkKG\n\t\t//     &token_type=bearer\n\t\t//     &id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso\n\t\t//     &expires_in=3600\n\t\t//     &state=af0ifjsldkj\n\t\t//\n\t\tu.Fragment = v.Encode()\n\t} else {\n\t\t// The code flow add values to the URL query.\n\t\t//\n\t\t//   HTTP/1.1 303 See Other\n\t\t//   Location: https://client.example.org/cb?\n\t\t//     code=SplxlOBeZQQYbYS6WxSbIA\n\t\t//     &state=af0ifjsldkj\n\t\t//\n\t\tq := u.Query()\n\t\tq.Set(\"code\", code.ID)\n\t\tq.Set(\"state\", authReq.State)\n\t\tu.RawQuery = q.Encode()\n\t}\n\n\thttp.Redirect(w, r, u.String(), http.StatusSeeOther)\n}\n\nfunc (s *Server) withClientFromStorage(w http.ResponseWriter, r *http.Request, handler func(http.ResponseWriter, *http.Request, storage.Client)) {\n\tclientID, clientSecret, ok := r.BasicAuth()\n\tif ok {\n\t\tvar err error\n\t\tif clientID, err = url.QueryUnescape(clientID); err != nil {\n\t\t\ts.tokenErrHelper(w, errInvalidRequest, \"client_id improperly encoded\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif clientSecret, err = url.QueryUnescape(clientSecret); err != nil {\n\t\t\ts.tokenErrHelper(w, errInvalidRequest, \"client_secret improperly encoded\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tclientID = r.PostFormValue(\"client_id\")\n\t\tclientSecret = r.PostFormValue(\"client_secret\")\n\t}\n\n\tclient, err := s.storage.GetClient(clientID)\n\tif err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"failed to get client: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t} else {\n\t\t\ts.tokenErrHelper(w, errInvalidClient, \"Invalid client credentials.\", http.StatusUnauthorized)\n\t\t}\n\t\treturn\n\t}\n\n\tif subtle.ConstantTimeCompare([]byte(client.Secret), []byte(clientSecret)) != 1 {\n\t\tif clientSecret == \"\" {\n\t\t\ts.logger.Infof(\"missing client_secret on token request for client: %s\", client.ID)\n\t\t} else {\n\t\t\ts.logger.Infof(\"invalid client_secret on token request for client: %s\", client.ID)\n\t\t}\n\t\ts.tokenErrHelper(w, errInvalidClient, \"Invalid client credentials.\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\thandler(w, r, client)\n}\n\nfunc (s *Server) handleToken(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif r.Method != http.MethodPost {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"method not allowed\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := r.ParseForm()\n\tif err != nil {\n\t\ts.logger.Errorf(\"Could not parse request body: %v\", err)\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tgrantType := r.PostFormValue(\"grant_type\")\n\tswitch grantType {\n\tcase grantTypeDeviceCode:\n\t\ts.handleDeviceToken(w, r)\n\tcase grantTypeAuthorizationCode:\n\t\ts.withClientFromStorage(w, r, s.handleAuthCode)\n\tcase grantTypeRefreshToken:\n\t\ts.withClientFromStorage(w, r, s.handleRefreshToken)\n\tcase grantTypePassword:\n\t\ts.withClientFromStorage(w, r, s.handlePasswordGrant)\n\tdefault:\n\t\ts.tokenErrHelper(w, errUnsupportedGrantType, \"\", http.StatusBadRequest)\n\t}\n}\n\nfunc (s *Server) calculateCodeChallenge(codeVerifier, codeChallengeMethod string) (string, error) {\n\tswitch codeChallengeMethod {\n\tcase codeChallengeMethodPlain:\n\t\treturn codeVerifier, nil\n\tcase codeChallengeMethodS256:\n\t\tshaSum := sha256.Sum256([]byte(codeVerifier))\n\t\treturn base64.RawURLEncoding.EncodeToString(shaSum[:]), nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown challenge method (%v)\", codeChallengeMethod)\n\t}\n}\n\n// handle an access token request https://tools.ietf.org/html/rfc6749#section-4.1.3\nfunc (s *Server) handleAuthCode(w http.ResponseWriter, r *http.Request, client storage.Client) {\n\tcode := r.PostFormValue(\"code\")\n\tredirectURI := r.PostFormValue(\"redirect_uri\")\n\n\tif code == \"\" {\n\t\ts.tokenErrHelper(w, errInvalidRequest, `Required param: code.`, http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tauthCode, err := s.storage.GetAuthCode(code)\n\tif err != nil || s.now().After(authCode.Expiry) || authCode.ClientID != client.ID {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"failed to get auth code: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t} else {\n\t\t\ts.tokenErrHelper(w, errInvalidGrant, \"Invalid or expired code parameter.\", http.StatusBadRequest)\n\t\t}\n\t\treturn\n\t}\n\n\t// RFC 7636 (PKCE)\n\tcodeChallengeFromStorage := authCode.PKCE.CodeChallenge\n\tprovidedCodeVerifier := r.PostFormValue(\"code_verifier\")\n\n\tswitch {\n\tcase providedCodeVerifier != \"\" && codeChallengeFromStorage != \"\":\n\t\tcalculatedCodeChallenge, err := s.calculateCodeChallenge(providedCodeVerifier, authCode.PKCE.CodeChallengeMethod)\n\t\tif err != nil {\n\t\t\ts.logger.Error(err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif codeChallengeFromStorage != calculatedCodeChallenge {\n\t\t\ts.tokenErrHelper(w, errInvalidGrant, \"Invalid code_verifier.\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\tcase providedCodeVerifier != \"\":\n\t\t// Received no code_challenge on /auth, but a code_verifier on /token\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"No PKCE flow started. Cannot check code_verifier.\", http.StatusBadRequest)\n\t\treturn\n\tcase codeChallengeFromStorage != \"\":\n\t\t// Received PKCE request on /auth, but no code_verifier on /token\n\t\ts.tokenErrHelper(w, errInvalidGrant, \"Expecting parameter code_verifier in PKCE flow.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif authCode.RedirectURI != redirectURI {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"redirect_uri did not match URI from initial request.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokenResponse, err := s.exchangeAuthCode(w, authCode, client)\n\tif err != nil {\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\ts.writeAccessToken(w, tokenResponse)\n}\n\nfunc (s *Server) exchangeAuthCode(w http.ResponseWriter, authCode storage.AuthCode, client storage.Client) (*accessTokenResponse, error) {\n\taccessToken, err := s.newAccessToken(client.ID, authCode.Claims, authCode.Scopes, authCode.Nonce, authCode.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to create new access token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\tidToken, expiry, err := s.newIDToken(client.ID, authCode.Claims, authCode.Scopes, authCode.Nonce, accessToken, authCode.ID, authCode.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to create ID token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\tif err := s.storage.DeleteAuthCode(authCode.ID); err != nil {\n\t\ts.logger.Errorf(\"failed to delete auth code: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\treqRefresh := func() bool {\n\t\t// Ensure the connector supports refresh tokens.\n\t\t//\n\t\t// Connectors like `saml` do not implement RefreshConnector.\n\t\tconn, err := s.getConnector(authCode.ConnectorID)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"connector with ID %q not found: %v\", authCode.ConnectorID, err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn false\n\t\t}\n\n\t\t_, ok := conn.Connector.(connector.RefreshConnector)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tfor _, scope := range authCode.Scopes {\n\t\t\tif scope == scopeOfflineAccess {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}()\n\tvar refreshToken string\n\tif reqRefresh {\n\t\trefresh := storage.RefreshToken{\n\t\t\tID:            storage.NewID(),\n\t\t\tToken:         storage.NewID(),\n\t\t\tClientID:      authCode.ClientID,\n\t\t\tConnectorID:   authCode.ConnectorID,\n\t\t\tScopes:        authCode.Scopes,\n\t\t\tClaims:        authCode.Claims,\n\t\t\tNonce:         authCode.Nonce,\n\t\t\tConnectorData: authCode.ConnectorData,\n\t\t\tCreatedAt:     s.now(),\n\t\t\tLastUsed:      s.now(),\n\t\t}\n\t\ttoken := &internal.RefreshToken{\n\t\t\tRefreshId: refresh.ID,\n\t\t\tToken:     refresh.Token,\n\t\t}\n\t\tif refreshToken, err = internal.Marshal(token); err != nil {\n\t\t\ts.logger.Errorf(\"failed to marshal refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := s.storage.CreateRefresh(refresh); err != nil {\n\t\t\ts.logger.Errorf(\"failed to create refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// deleteToken determines if we need to delete the newly created refresh token\n\t\t// due to a failure in updating/creating the OfflineSession object for the\n\t\t// corresponding user.\n\t\tvar deleteToken bool\n\t\tdefer func() {\n\t\t\tif deleteToken {\n\t\t\t\t// Delete newly created refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(refresh.ID); err != nil {\n\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttokenRef := storage.RefreshTokenRef{\n\t\t\tID:        refresh.ID,\n\t\t\tClientID:  refresh.ClientID,\n\t\t\tCreatedAt: refresh.CreatedAt,\n\t\t\tLastUsed:  refresh.LastUsed,\n\t\t}\n\n\t\t// Try to retrieve an existing OfflineSession object for the corresponding user.\n\t\tif session, err := s.storage.GetOfflineSessions(refresh.Claims.UserID, refresh.ConnectorID); err != nil {\n\t\t\tif err != storage.ErrNotFound {\n\t\t\t\ts.logger.Errorf(\"failed to get offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tofflineSessions := storage.OfflineSessions{\n\t\t\t\tUserID:  refresh.Claims.UserID,\n\t\t\t\tConnID:  refresh.ConnectorID,\n\t\t\t\tRefresh: make(map[string]*storage.RefreshTokenRef),\n\t\t\t}\n\t\t\tofflineSessions.Refresh[tokenRef.ClientID] = &tokenRef\n\n\t\t\t// Create a new OfflineSession object for the user and add a reference object for\n\t\t\t// the newly received refreshtoken.\n\t\t\tif err := s.storage.CreateOfflineSessions(offlineSessions); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tif oldTokenRef, ok := session.Refresh[tokenRef.ClientID]; ok {\n\t\t\t\t// Delete old refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(oldTokenRef.ID); err != nil && err != storage.ErrNotFound {\n\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\tdeleteToken = true\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update existing OfflineSession obj with new RefreshTokenRef.\n\t\t\tif err := s.storage.UpdateOfflineSessions(session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\t\t\told.Refresh[tokenRef.ClientID] = &tokenRef\n\t\t\t\treturn old, nil\n\t\t\t}); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to update offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn s.toAccessTokenResponse(idToken, accessToken, refreshToken, expiry), nil\n}\n\nfunc (s *Server) handleUserInfo(w http.ResponseWriter, r *http.Request) {\n\tconst prefix = \"Bearer \"\n\n\tauth := r.Header.Get(\"authorization\")\n\tif len(auth) < len(prefix) || !strings.EqualFold(prefix, auth[:len(prefix)]) {\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Bearer\")\n\t\ts.tokenErrHelper(w, errAccessDenied, \"Invalid bearer token.\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\trawIDToken := auth[len(prefix):]\n\n\tverifier := oidc.NewVerifier(s.issuerURL.String(), &storageKeySet{s.storage}, &oidc.Config{SkipClientIDCheck: true})\n\tidToken, err := verifier.Verify(r.Context(), rawIDToken)\n\tif err != nil {\n\t\ts.tokenErrHelper(w, errAccessDenied, err.Error(), http.StatusForbidden)\n\t\treturn\n\t}\n\n\tvar claims json.RawMessage\n\tif err := idToken.Claims(&claims); err != nil {\n\t\ts.tokenErrHelper(w, errServerError, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(claims)\n}\n\nfunc (s *Server) handlePasswordGrant(w http.ResponseWriter, r *http.Request, client storage.Client) {\n\t// Parse the fields\n\tif err := r.ParseForm(); err != nil {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Couldn't parse data\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tq := r.Form\n\n\tnonce := q.Get(\"nonce\")\n\t// Some clients, like the old go-oidc, provide extra whitespace. Tolerate this.\n\tscopes := strings.Fields(q.Get(\"scope\"))\n\n\t// Parse the scopes if they are passed\n\tvar (\n\t\tunrecognized  []string\n\t\tinvalidScopes []string\n\t)\n\thasOpenIDScope := false\n\tfor _, scope := range scopes {\n\t\tswitch scope {\n\t\tcase scopeOpenID:\n\t\t\thasOpenIDScope = true\n\t\tcase scopeOfflineAccess, scopeEmail, scopeProfile, scopeGroups, scopeFederatedID:\n\t\tdefault:\n\t\t\tpeerID, ok := parseCrossClientScope(scope)\n\t\t\tif !ok {\n\t\t\t\tunrecognized = append(unrecognized, scope)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tisTrusted, err := s.validateCrossClientTrust(client.ID, peerID)\n\t\t\tif err != nil {\n\t\t\t\ts.tokenErrHelper(w, errInvalidClient, fmt.Sprintf(\"Error validating cross client trust %v.\", err), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !isTrusted {\n\t\t\t\tinvalidScopes = append(invalidScopes, scope)\n\t\t\t}\n\t\t}\n\t}\n\tif !hasOpenIDScope {\n\t\ts.tokenErrHelper(w, errInvalidRequest, `Missing required scope(s) [\"openid\"].`, http.StatusBadRequest)\n\t\treturn\n\t}\n\tif len(unrecognized) > 0 {\n\t\ts.tokenErrHelper(w, errInvalidRequest, fmt.Sprintf(\"Unrecognized scope(s) %q\", unrecognized), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif len(invalidScopes) > 0 {\n\t\ts.tokenErrHelper(w, errInvalidRequest, fmt.Sprintf(\"Client can't request scope(s) %q\", invalidScopes), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Which connector\n\tconnID := s.passwordConnector\n\tconn, err := s.getConnector(connID)\n\tif err != nil {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Requested connector does not exist.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tpasswordConnector, ok := conn.Connector.(connector.PasswordConnector)\n\tif !ok {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Requested password connector does not correct type.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Login\n\tusername := q.Get(\"username\")\n\tpassword := q.Get(\"password\")\n\tidentity, ok, err := passwordConnector.Login(r.Context(), parseScopes(scopes), username, password)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to login user: %v\", err)\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Could not login user\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif !ok {\n\t\ts.tokenErrHelper(w, errAccessDenied, \"Invalid username or password\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Build the claims to send the id token\n\tclaims := storage.Claims{\n\t\tUserID:            identity.UserID,\n\t\tUsername:          identity.Username,\n\t\tPreferredUsername: identity.PreferredUsername,\n\t\tEmail:             identity.Email,\n\t\tEmailVerified:     identity.EmailVerified,\n\t\tGroups:            identity.Groups,\n\t}\n\n\taccessToken, err := s.newAccessToken(client.ID, claims, scopes, nonce, connID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"password grant failed to create new access token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tidToken, expiry, err := s.newIDToken(client.ID, claims, scopes, nonce, accessToken, \"\", connID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"password grant failed to create new ID token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\treqRefresh := func() bool {\n\t\t// Ensure the connector supports refresh tokens.\n\t\t//\n\t\t// Connectors like `saml` do not implement RefreshConnector.\n\t\t_, ok := conn.Connector.(connector.RefreshConnector)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tfor _, scope := range scopes {\n\t\t\tif scope == scopeOfflineAccess {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}()\n\tvar refreshToken string\n\tif reqRefresh {\n\t\trefresh := storage.RefreshToken{\n\t\t\tID:          storage.NewID(),\n\t\t\tToken:       storage.NewID(),\n\t\t\tClientID:    client.ID,\n\t\t\tConnectorID: connID,\n\t\t\tScopes:      scopes,\n\t\t\tClaims:      claims,\n\t\t\tNonce:       nonce,\n\t\t\t// ConnectorData: authCode.ConnectorData,\n\t\t\tCreatedAt: s.now(),\n\t\t\tLastUsed:  s.now(),\n\t\t}\n\t\ttoken := &internal.RefreshToken{\n\t\t\tRefreshId: refresh.ID,\n\t\t\tToken:     refresh.Token,\n\t\t}\n\t\tif refreshToken, err = internal.Marshal(token); err != nil {\n\t\t\ts.logger.Errorf(\"failed to marshal refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.storage.CreateRefresh(refresh); err != nil {\n\t\t\ts.logger.Errorf(\"failed to create refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// deleteToken determines if we need to delete the newly created refresh token\n\t\t// due to a failure in updating/creating the OfflineSession object for the\n\t\t// corresponding user.\n\t\tvar deleteToken bool\n\t\tdefer func() {\n\t\t\tif deleteToken {\n\t\t\t\t// Delete newly created refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(refresh.ID); err != nil {\n\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttokenRef := storage.RefreshTokenRef{\n\t\t\tID:        refresh.ID,\n\t\t\tClientID:  refresh.ClientID,\n\t\t\tCreatedAt: refresh.CreatedAt,\n\t\t\tLastUsed:  refresh.LastUsed,\n\t\t}\n\n\t\t// Try to retrieve an existing OfflineSession object for the corresponding user.\n\t\tif session, err := s.storage.GetOfflineSessions(refresh.Claims.UserID, refresh.ConnectorID); err != nil {\n\t\t\tif err != storage.ErrNotFound {\n\t\t\t\ts.logger.Errorf(\"failed to get offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn\n\t\t\t}\n\t\t\tofflineSessions := storage.OfflineSessions{\n\t\t\t\tUserID:        refresh.Claims.UserID,\n\t\t\t\tConnID:        refresh.ConnectorID,\n\t\t\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\t\t\tConnectorData: identity.ConnectorData,\n\t\t\t}\n\t\t\tofflineSessions.Refresh[tokenRef.ClientID] = &tokenRef\n\n\t\t\t// Create a new OfflineSession object for the user and add a reference object for\n\t\t\t// the newly received refreshtoken.\n\t\t\tif err := s.storage.CreateOfflineSessions(offlineSessions); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif oldTokenRef, ok := session.Refresh[tokenRef.ClientID]; ok {\n\t\t\t\t// Delete old refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(oldTokenRef.ID); err != nil {\n\t\t\t\t\tif err == storage.ErrNotFound {\n\t\t\t\t\t\ts.logger.Warnf(\"database inconsistent, refresh token missing: %v\", oldTokenRef.ID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\t\tdeleteToken = true\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update existing OfflineSession obj with new RefreshTokenRef.\n\t\t\tif err := s.storage.UpdateOfflineSessions(session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\t\t\told.Refresh[tokenRef.ClientID] = &tokenRef\n\t\t\t\told.ConnectorData = identity.ConnectorData\n\t\t\t\treturn old, nil\n\t\t\t}); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to update offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tresp := s.toAccessTokenResponse(idToken, accessToken, refreshToken, expiry)\n\ts.writeAccessToken(w, resp)\n}\n\ntype accessTokenResponse struct {\n\tAccessToken  string `json:\"access_token\"`\n\tTokenType    string `json:\"token_type\"`\n\tExpiresIn    int    `json:\"expires_in\"`\n\tRefreshToken string `json:\"refresh_token,omitempty\"`\n\tIDToken      string `json:\"id_token\"`\n}\n\nfunc (s *Server) toAccessTokenResponse(idToken, accessToken, refreshToken string, expiry time.Time) *accessTokenResponse {\n\treturn &accessTokenResponse{\n\t\taccessToken,\n\t\t\"bearer\",\n\t\tint(expiry.Sub(s.now()).Seconds()),\n\t\trefreshToken,\n\t\tidToken,\n\t}\n}\n\nfunc (s *Server) writeAccessToken(w http.ResponseWriter, resp *accessTokenResponse) {\n\tdata, err := json.Marshal(resp)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to marshal access token response: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\n\t// Token response must include cache headers https://tools.ietf.org/html/rfc6749#section-5.1\n\tw.Header().Set(\"Cache-Control\", \"no-store\")\n\tw.Header().Set(\"Pragma\", \"no-cache\")\n\tw.Write(data)\n}\n\nfunc (s *Server) renderError(r *http.Request, w http.ResponseWriter, status int, description string) {\n\tif err := s.templates.err(r, w, status, description); err != nil {\n\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t}\n}\n\nfunc (s *Server) tokenErrHelper(w http.ResponseWriter, typ string, description string, statusCode int) {\n\tif err := tokenErr(w, typ, description, statusCode); err != nil {\n\t\ts.logger.Errorf(\"token error response: %v\", err)\n\t}\n}\n\n// Check for username prompt override from connector. Defaults to \"Username\".\nfunc usernamePrompt(conn connector.PasswordConnector) string {\n\tif attr := conn.Prompt(); attr != \"\" {\n\t\treturn attr\n\t}\n\treturn \"Username\"\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/connector\"\n\t\"github.com/dexidp/dex/server/internal\"\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// TODO(ericchiang): clean this file up and figure out more idiomatic error handling.\n\n// See: https://tools.ietf.org/html/rfc6749#section-4.1.2.1\n\n// displayedAuthErr is an error that should be displayed to the user as a web page\ntype displayedAuthErr struct {\n\tStatus      int\n\tDescription string\n}\n\nfunc (err *displayedAuthErr) Error() string {\n\treturn err.Description\n}\n\nfunc newDisplayedErr(status int, format string, a ...interface{}) *displayedAuthErr {\n\treturn &displayedAuthErr{status, fmt.Sprintf(format, a...)}\n}\n\n// redirectedAuthErr is an error that should be reported back to the client by 302 redirect\ntype redirectedAuthErr struct {\n\tState       string\n\tRedirectURI string\n\tType        string\n\tDescription string\n}\n\nfunc (err *redirectedAuthErr) Error() string {\n\treturn err.Description\n}\n\nfunc (err *redirectedAuthErr) Handler() http.Handler {\n\thf := func(w http.ResponseWriter, r *http.Request) {\n\t\tv := url.Values{}\n\t\tv.Add(\"state\", err.State)\n\t\tv.Add(\"error\", err.Type)\n\t\tif err.Description != \"\" {\n\t\t\tv.Add(\"error_description\", err.Description)\n\t\t}\n\t\tvar redirectURI string\n\t\tif strings.Contains(err.RedirectURI, \"?\") {\n\t\t\tredirectURI = err.RedirectURI + \"&\" + v.Encode()\n\t\t} else {\n\t\t\tredirectURI = err.RedirectURI + \"?\" + v.Encode()\n\t\t}\n\t\thttp.Redirect(w, r, redirectURI, http.StatusSeeOther)\n\t}\n\treturn http.HandlerFunc(hf)\n}\n\nfunc tokenErr(w http.ResponseWriter, typ, description string, statusCode int) error {\n\tdata := struct {\n\t\tError       string `json:\"error\"`\n\t\tDescription string `json:\"error_description,omitempty\"`\n\t}{typ, description}\n\tbody, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal token error response: %v\", err)\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(body)))\n\tw.WriteHeader(statusCode)\n\tw.Write(body)\n\treturn nil\n}\n\n// nolint\nconst (\n\terrInvalidRequest          = \"invalid_request\"\n\terrUnauthorizedClient      = \"unauthorized_client\"\n\terrAccessDenied            = \"access_denied\"\n\terrUnsupportedResponseType = \"unsupported_response_type\"\n\terrRequestNotSupported     = \"request_not_supported\"\n\terrInvalidScope            = \"invalid_scope\"\n\terrServerError             = \"server_error\"\n\terrTemporarilyUnavailable  = \"temporarily_unavailable\"\n\terrUnsupportedGrantType    = \"unsupported_grant_type\"\n\terrInvalidGrant            = \"invalid_grant\"\n\terrInvalidClient           = \"invalid_client\"\n)\n\nconst (\n\tscopeOfflineAccess     = \"offline_access\" // Request a refresh token.\n\tscopeOpenID            = \"openid\"\n\tscopeGroups            = \"groups\"\n\tscopeEmail             = \"email\"\n\tscopeProfile           = \"profile\"\n\tscopeFederatedID       = \"federated:id\"\n\tscopeCrossClientPrefix = \"audience:server:client_id:\"\n)\n\nconst (\n\tdeviceCallbackURI = \"/device/callback\"\n)\n\nconst (\n\tredirectURIOOB = \"urn:ietf:wg:oauth:2.0:oob\"\n)\n\nconst (\n\tgrantTypeAuthorizationCode = \"authorization_code\"\n\tgrantTypeRefreshToken      = \"refresh_token\"\n\tgrantTypeImplicit          = \"implicit\"\n\tgrantTypePassword          = \"password\"\n\tgrantTypeDeviceCode        = \"urn:ietf:params:oauth:grant-type:device_code\"\n)\n\nconst (\n\tresponseTypeCode    = \"code\"     // \"Regular\" flow\n\tresponseTypeToken   = \"token\"    // Implicit flow for frontend apps.\n\tresponseTypeIDToken = \"id_token\" // ID Token in url fragment\n)\n\nconst (\n\tdeviceTokenPending  = \"authorization_pending\"\n\tdeviceTokenComplete = \"complete\"\n\tdeviceTokenSlowDown = \"slow_down\"\n\tdeviceTokenExpired  = \"expired_token\"\n)\n\nfunc parseScopes(scopes []string) connector.Scopes {\n\tvar s connector.Scopes\n\tfor _, scope := range scopes {\n\t\tswitch scope {\n\t\tcase scopeOfflineAccess:\n\t\t\ts.OfflineAccess = true\n\t\tcase scopeGroups:\n\t\t\ts.Groups = true\n\t\t}\n\t}\n\treturn s\n}\n\n// Determine the signature algorithm for a JWT.\nfunc signatureAlgorithm(jwk *jose.JSONWebKey) (alg jose.SignatureAlgorithm, err error) {\n\tif jwk.Key == nil {\n\t\treturn alg, errors.New(\"no signing key\")\n\t}\n\tswitch key := jwk.Key.(type) {\n\tcase *rsa.PrivateKey:\n\t\t// Because OIDC mandates that we support RS256, we always return that\n\t\t// value. In the future, we might want to make this configurable on a\n\t\t// per client basis. For example allowing PS256 or ECDSA variants.\n\t\t//\n\t\t// See https://github.com/dexidp/dex/issues/692\n\t\treturn jose.RS256, nil\n\tcase *ecdsa.PrivateKey:\n\t\t// We don't actually support ECDSA keys yet, but they're tested for\n\t\t// in case we want to in the future.\n\t\t//\n\t\t// These values are prescribed depending on the ECDSA key type. We\n\t\t// can't return different values.\n\t\tswitch key.Params() {\n\t\tcase elliptic.P256().Params():\n\t\t\treturn jose.ES256, nil\n\t\tcase elliptic.P384().Params():\n\t\t\treturn jose.ES384, nil\n\t\tcase elliptic.P521().Params():\n\t\t\treturn jose.ES512, nil\n\t\tdefault:\n\t\t\treturn alg, errors.New(\"unsupported ecdsa curve\")\n\t\t}\n\tdefault:\n\t\treturn alg, fmt.Errorf(\"unsupported signing key type %T\", key)\n\t}\n}\n\nfunc signPayload(key *jose.JSONWebKey, alg jose.SignatureAlgorithm, payload []byte) (jws string, err error) {\n\tsigningKey := jose.SigningKey{Key: key, Algorithm: alg}\n\n\tsigner, err := jose.NewSigner(signingKey, &jose.SignerOptions{})\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"new signer: %v\", err)\n\t}\n\tsignature, err := signer.Sign(payload)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"signing payload: %v\", err)\n\t}\n\treturn signature.CompactSerialize()\n}\n\n// The hash algorithm for the at_hash is determined by the signing\n// algorithm used for the id_token. From the spec:\n//\n//    ...the hash algorithm used is the hash algorithm used in the alg Header\n//    Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256,\n//    hash the access_token value with SHA-256\n//\n// https://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDToken\nvar hashForSigAlg = map[jose.SignatureAlgorithm]func() hash.Hash{\n\tjose.RS256: sha256.New,\n\tjose.RS384: sha512.New384,\n\tjose.RS512: sha512.New,\n\tjose.ES256: sha256.New,\n\tjose.ES384: sha512.New384,\n\tjose.ES512: sha512.New,\n}\n\n// Compute an at_hash from a raw access token and a signature algorithm\n//\n// See: https://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDToken\nfunc accessTokenHash(alg jose.SignatureAlgorithm, accessToken string) (string, error) {\n\tnewHash, ok := hashForSigAlg[alg]\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"unsupported signature algorithm: %s\", alg)\n\t}\n\n\thashFunc := newHash()\n\tif _, err := io.WriteString(hashFunc, accessToken); err != nil {\n\t\treturn \"\", fmt.Errorf(\"computing hash: %v\", err)\n\t}\n\tsum := hashFunc.Sum(nil)\n\treturn base64.RawURLEncoding.EncodeToString(sum[:len(sum)/2]), nil\n}\n\ntype audience []string\n\nfunc (a audience) contains(aud string) bool {\n\tfor _, e := range a {\n\t\tif aud == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (a audience) MarshalJSON() ([]byte, error) {\n\tif len(a) == 1 {\n\t\treturn json.Marshal(a[0])\n\t}\n\treturn json.Marshal([]string(a))\n}\n\ntype idTokenClaims struct {\n\tIssuer           string   `json:\"iss\"`\n\tSubject          string   `json:\"sub\"`\n\tAudience         audience `json:\"aud\"`\n\tExpiry           int64    `json:\"exp\"`\n\tIssuedAt         int64    `json:\"iat\"`\n\tAuthorizingParty string   `json:\"azp,omitempty\"`\n\tNonce            string   `json:\"nonce,omitempty\"`\n\n\tAccessTokenHash string `json:\"at_hash,omitempty\"`\n\tCodeHash        string `json:\"c_hash,omitempty\"`\n\n\tEmail         string `json:\"email,omitempty\"`\n\tEmailVerified *bool  `json:\"email_verified,omitempty\"`\n\n\tGroups []string `json:\"groups,omitempty\"`\n\n\tName              string `json:\"name,omitempty\"`\n\tPreferredUsername string `json:\"preferred_username,omitempty\"`\n\n\tFederatedIDClaims *federatedIDClaims `json:\"federated_claims,omitempty\"`\n}\n\ntype federatedIDClaims struct {\n\tConnectorID string `json:\"connector_id,omitempty\"`\n\tUserID      string `json:\"user_id,omitempty\"`\n}\n\nfunc (s *Server) newAccessToken(clientID string, claims storage.Claims, scopes []string, nonce, connID string) (accessToken string, err error) {\n\tidToken, _, err := s.newIDToken(clientID, claims, scopes, nonce, storage.NewID(), \"\", connID)\n\treturn idToken, err\n}\n\nfunc (s *Server) newIDToken(clientID string, claims storage.Claims, scopes []string, nonce, accessToken, code, connID string) (idToken string, expiry time.Time, err error) {\n\tkeys, err := s.storage.GetKeys()\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get keys: %v\", err)\n\t\treturn \"\", expiry, err\n\t}\n\n\tsigningKey := keys.SigningKey\n\tif signingKey == nil {\n\t\treturn \"\", expiry, fmt.Errorf(\"no key to sign payload with\")\n\t}\n\tsigningAlg, err := signatureAlgorithm(signingKey)\n\tif err != nil {\n\t\treturn \"\", expiry, err\n\t}\n\n\tissuedAt := s.now()\n\texpiry = issuedAt.Add(s.idTokensValidFor)\n\n\tsub := &internal.IDTokenSubject{\n\t\tUserId: claims.UserID,\n\t\tConnId: connID,\n\t}\n\n\tsubjectString, err := internal.Marshal(sub)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to marshal offline session ID: %v\", err)\n\t\treturn \"\", expiry, fmt.Errorf(\"failed to marshal offline session ID: %v\", err)\n\t}\n\n\ttok := idTokenClaims{\n\t\tIssuer:   s.issuerURL.String(),\n\t\tSubject:  subjectString,\n\t\tNonce:    nonce,\n\t\tExpiry:   expiry.Unix(),\n\t\tIssuedAt: issuedAt.Unix(),\n\t}\n\n\tif accessToken != \"\" {\n\t\tatHash, err := accessTokenHash(signingAlg, accessToken)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"error computing at_hash: %v\", err)\n\t\t\treturn \"\", expiry, fmt.Errorf(\"error computing at_hash: %v\", err)\n\t\t}\n\t\ttok.AccessTokenHash = atHash\n\t}\n\n\tif code != \"\" {\n\t\tcHash, err := accessTokenHash(signingAlg, code)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"error computing c_hash: %v\", err)\n\t\t\treturn \"\", expiry, fmt.Errorf(\"error computing c_hash: #{err}\")\n\t\t}\n\t\ttok.CodeHash = cHash\n\t}\n\n\tfor _, scope := range scopes {\n\t\tswitch {\n\t\tcase scope == scopeEmail:\n\t\t\ttok.Email = claims.Email\n\t\t\ttok.EmailVerified = &claims.EmailVerified\n\t\tcase scope == scopeGroups:\n\t\t\ttok.Groups = claims.Groups\n\t\tcase scope == scopeProfile:\n\t\t\ttok.Name = claims.Username\n\t\t\ttok.PreferredUsername = claims.PreferredUsername\n\t\tcase scope == scopeFederatedID:\n\t\t\ttok.FederatedIDClaims = &federatedIDClaims{\n\t\t\t\tConnectorID: connID,\n\t\t\t\tUserID:      claims.UserID,\n\t\t\t}\n\t\tdefault:\n\t\t\tpeerID, ok := parseCrossClientScope(scope)\n\t\t\tif !ok {\n\t\t\t\t// Ignore unknown scopes. These are already validated during the\n\t\t\t\t// initial auth request.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tisTrusted, err := s.validateCrossClientTrust(clientID, peerID)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", expiry, err\n\t\t\t}\n\t\t\tif !isTrusted {\n\t\t\t\t// TODO(ericchiang): propagate this error to the client.\n\t\t\t\treturn \"\", expiry, fmt.Errorf(\"peer (%s) does not trust client\", peerID)\n\t\t\t}\n\t\t\ttok.Audience = append(tok.Audience, peerID)\n\t\t}\n\t}\n\n\tif len(tok.Audience) == 0 {\n\t\t// Client didn't ask for cross client audience. Set the current\n\t\t// client as the audience.\n\t\ttok.Audience = audience{clientID}\n\t} else {\n\t\t// Client asked for cross client audience:\n\t\t// if the current client was not requested explicitly\n\t\tif !tok.Audience.contains(clientID) {\n\t\t\t// by default it becomes one of entries in Audience\n\t\t\ttok.Audience = append(tok.Audience, clientID)\n\t\t}\n\t\t// The current client becomes the authorizing party.\n\t\ttok.AuthorizingParty = clientID\n\t}\n\n\tpayload, err := json.Marshal(tok)\n\tif err != nil {\n\t\treturn \"\", expiry, fmt.Errorf(\"could not serialize claims: %v\", err)\n\t}\n\n\tif idToken, err = signPayload(signingKey, signingAlg, payload); err != nil {\n\t\treturn \"\", expiry, fmt.Errorf(\"failed to sign payload: %v\", err)\n\t}\n\treturn idToken, expiry, nil\n}\n\n// parse the initial request from the OAuth2 client.\nfunc (s *Server) parseAuthorizationRequest(r *http.Request) (*storage.AuthRequest, error) {\n\tif err := r.ParseForm(); err != nil {\n\t\treturn nil, newDisplayedErr(http.StatusBadRequest, \"Failed to parse request.\")\n\t}\n\tq := r.Form\n\tredirectURI, err := url.QueryUnescape(q.Get(\"redirect_uri\"))\n\tif err != nil {\n\t\treturn nil, newDisplayedErr(http.StatusBadRequest, \"No redirect_uri provided.\")\n\t}\n\n\tclientID := q.Get(\"client_id\")\n\tstate := q.Get(\"state\")\n\tnonce := q.Get(\"nonce\")\n\tconnectorID := q.Get(\"connector_id\")\n\t// Some clients, like the old go-oidc, provide extra whitespace. Tolerate this.\n\tscopes := strings.Fields(q.Get(\"scope\"))\n\tresponseTypes := strings.Fields(q.Get(\"response_type\"))\n\n\tcodeChallenge := q.Get(\"code_challenge\")\n\tcodeChallengeMethod := q.Get(\"code_challenge_method\")\n\n\tif codeChallengeMethod == \"\" {\n\t\tcodeChallengeMethod = codeChallengeMethodPlain\n\t}\n\n\tclient, err := s.storage.GetClient(clientID)\n\tif err != nil {\n\t\tif err == storage.ErrNotFound {\n\t\t\treturn nil, newDisplayedErr(http.StatusNotFound, \"Invalid client_id (%q).\", clientID)\n\t\t}\n\t\ts.logger.Errorf(\"Failed to get client: %v\", err)\n\t\treturn nil, newDisplayedErr(http.StatusInternalServerError, \"Database error.\")\n\t}\n\n\tif !validateRedirectURI(client, redirectURI) {\n\t\treturn nil, newDisplayedErr(http.StatusBadRequest, \"Unregistered redirect_uri (%q).\", redirectURI)\n\t}\n\tif redirectURI == deviceCallbackURI && client.Public {\n\t\tredirectURI = s.issuerURL.Path + deviceCallbackURI\n\t}\n\n\t// From here on out, we want to redirect back to the client with an error.\n\tnewRedirectedErr := func(typ, format string, a ...interface{}) *redirectedAuthErr {\n\t\treturn &redirectedAuthErr{state, redirectURI, typ, fmt.Sprintf(format, a...)}\n\t}\n\n\tif connectorID != \"\" {\n\t\tconnectors, err := s.storage.ListConnectors()\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to list connectors: %v\", err)\n\t\t\treturn nil, newRedirectedErr(errServerError, \"Unable to retrieve connectors\")\n\t\t}\n\t\tif !validateConnectorID(connectors, connectorID) {\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Invalid ConnectorID\")\n\t\t}\n\t}\n\n\t// dex doesn't support request parameter and must return request_not_supported error\n\t// https://openid.net/specs/openid-connect-core-1_0.html#6.1\n\tif q.Get(\"request\") != \"\" {\n\t\treturn nil, newRedirectedErr(errRequestNotSupported, \"Server does not support request parameter.\")\n\t}\n\n\tif codeChallengeMethod != codeChallengeMethodS256 && codeChallengeMethod != codeChallengeMethodPlain {\n\t\tdescription := fmt.Sprintf(\"Unsupported PKCE challenge method (%q).\", codeChallengeMethod)\n\t\treturn nil, newRedirectedErr(errInvalidRequest, description)\n\t}\n\n\tvar (\n\t\tunrecognized  []string\n\t\tinvalidScopes []string\n\t)\n\thasOpenIDScope := false\n\tfor _, scope := range scopes {\n\t\tswitch scope {\n\t\tcase scopeOpenID:\n\t\t\thasOpenIDScope = true\n\t\tcase scopeOfflineAccess, scopeEmail, scopeProfile, scopeGroups, scopeFederatedID:\n\t\tdefault:\n\t\t\tpeerID, ok := parseCrossClientScope(scope)\n\t\t\tif !ok {\n\t\t\t\tunrecognized = append(unrecognized, scope)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tisTrusted, err := s.validateCrossClientTrust(clientID, peerID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, newRedirectedErr(errServerError, \"Internal server error.\")\n\t\t\t}\n\t\t\tif !isTrusted {\n\t\t\t\tinvalidScopes = append(invalidScopes, scope)\n\t\t\t}\n\t\t}\n\t}\n\tif !hasOpenIDScope {\n\t\treturn nil, newRedirectedErr(errInvalidScope, `Missing required scope(s) [\"openid\"].`)\n\t}\n\tif len(unrecognized) > 0 {\n\t\treturn nil, newRedirectedErr(errInvalidScope, \"Unrecognized scope(s) %q\", unrecognized)\n\t}\n\tif len(invalidScopes) > 0 {\n\t\treturn nil, newRedirectedErr(errInvalidScope, \"Client can't request scope(s) %q\", invalidScopes)\n\t}\n\n\tvar rt struct {\n\t\tcode    bool\n\t\tidToken bool\n\t\ttoken   bool\n\t}\n\n\tfor _, responseType := range responseTypes {\n\t\tswitch responseType {\n\t\tcase responseTypeCode:\n\t\t\trt.code = true\n\t\tcase responseTypeIDToken:\n\t\t\trt.idToken = true\n\t\tcase responseTypeToken:\n\t\t\trt.token = true\n\t\tdefault:\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Invalid response type %q\", responseType)\n\t\t}\n\n\t\tif !s.supportedResponseTypes[responseType] {\n\t\t\treturn nil, newRedirectedErr(errUnsupportedResponseType, \"Unsupported response type %q\", responseType)\n\t\t}\n\t}\n\n\tif len(responseTypes) == 0 {\n\t\treturn nil, newRedirectedErr(errInvalidRequest, \"No response_type provided\")\n\t}\n\n\tif rt.token && !rt.code && !rt.idToken {\n\t\t// \"token\" can't be provided by its own.\n\t\t//\n\t\t// https://openid.net/specs/openid-connect-core-1_0.html#Authentication\n\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Response type 'token' must be provided with type 'id_token' and/or 'code'\")\n\t}\n\tif !rt.code {\n\t\t// Either \"id_token token\" or \"id_token\" has been provided which implies the\n\t\t// implicit flow. Implicit flow requires a nonce value.\n\t\t//\n\t\t// https://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest\n\t\tif nonce == \"\" {\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Response type 'token' requires a 'nonce' value.\")\n\t\t}\n\t}\n\tif rt.token {\n\t\tif redirectURI == redirectURIOOB {\n\t\t\terr := fmt.Sprintf(\"Cannot use response type 'token' with redirect_uri '%s'.\", redirectURIOOB)\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, err)\n\t\t}\n\t}\n\n\treturn &storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            client.ID,\n\t\tState:               state,\n\t\tNonce:               nonce,\n\t\tForceApprovalPrompt: q.Get(\"approval_prompt\") == \"force\",\n\t\tScopes:              scopes,\n\t\tRedirectURI:         redirectURI,\n\t\tResponseTypes:       responseTypes,\n\t\tConnectorID:         connectorID,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       codeChallenge,\n\t\t\tCodeChallengeMethod: codeChallengeMethod,\n\t\t},\n\t}, nil\n}\n\nfunc parseCrossClientScope(scope string) (peerID string, ok bool) {\n\tif ok = strings.HasPrefix(scope, scopeCrossClientPrefix); ok {\n\t\tpeerID = scope[len(scopeCrossClientPrefix):]\n\t}\n\treturn\n}\n\nfunc (s *Server) validateCrossClientTrust(clientID, peerID string) (trusted bool, err error) {\n\tif peerID == clientID {\n\t\treturn true, nil\n\t}\n\tpeer, err := s.storage.GetClient(peerID)\n\tif err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Failed to get client: %v\", err)\n\t\t\treturn false, err\n\t\t}\n\t\treturn false, nil\n\t}\n\tfor _, id := range peer.TrustedPeers {\n\t\tif id == clientID {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc validateRedirectURI(client storage.Client, redirectURI string) bool {\n\t// Allow named RedirectURIs for both public and non-public clients.\n\t// This is required make PKCE-enabled web apps work, when configured as public clients.\n\tfor _, uri := range client.RedirectURIs {\n\t\tif redirectURI == uri {\n\t\t\treturn true\n\t\t}\n\t}\n\t// For non-public clients or when RedirectURIs is set, we allow only explicitly named RedirectURIs.\n\t// Otherwise, we check below for special URIs used for desktop or mobile apps.\n\tif !client.Public || len(client.RedirectURIs) > 0 {\n\t\treturn false\n\t}\n\n\tif redirectURI == redirectURIOOB || redirectURI == deviceCallbackURI {\n\t\treturn true\n\t}\n\n\t// verify that the host is of form \"http://localhost:(port)(path)\" or \"http://localhost(path)\"\n\tu, err := url.Parse(redirectURI)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif u.Scheme != \"http\" {\n\t\treturn false\n\t}\n\tif u.Host == \"localhost\" {\n\t\treturn true\n\t}\n\thost, _, err := net.SplitHostPort(u.Host)\n\treturn err == nil && host == \"localhost\"\n}\n\nfunc validateConnectorID(connectors []storage.Connector, connectorID string) bool {\n\tfor _, c := range connectors {\n\t\tif c.ID == connectorID {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// storageKeySet implements the oidc.KeySet interface backed by Dex storage\ntype storageKeySet struct {\n\tstorage.Storage\n}\n\nfunc (s *storageKeySet) VerifySignature(_ context.Context, jwt string) (payload []byte, err error) {\n\tjws, err := jose.ParseSigned(jwt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeyID := \"\"\n\tfor _, sig := range jws.Signatures {\n\t\tkeyID = sig.Header.KeyID\n\t\tbreak\n\t}\n\n\tskeys, err := s.Storage.GetKeys()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeys := []*jose.JSONWebKey{skeys.SigningKeyPub}\n\tfor _, vk := range skeys.VerificationKeys {\n\t\tkeys = append(keys, vk.PublicKey)\n\t}\n\n\tfor _, key := range keys {\n\t\tif keyID == \"\" || key.KeyID == keyID {\n\t\t\tif payload, err := jws.Verify(key); err == nil {\n\t\t\t\treturn payload, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"failed to verify id token signature\")\n}\n", "// Package conformance provides conformance tests for storage implementations.\npackage conformance\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/kylelemons/godebug/pretty\"\n\t\"golang.org/x/crypto/bcrypt\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// ensure that values being tested on never expire.\nvar neverExpire = time.Now().UTC().Add(time.Hour * 24 * 365 * 100)\n\ntype subTest struct {\n\tname string\n\trun  func(t *testing.T, s storage.Storage)\n}\n\nfunc runTests(t *testing.T, newStorage func() storage.Storage, tests []subTest) {\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ts := newStorage()\n\t\t\ttest.run(t, s)\n\t\t\ts.Close()\n\t\t})\n\t}\n}\n\n// RunTests runs a set of conformance tests against a storage. newStorage should\n// return an initialized but empty storage. The storage will be closed at the\n// end of each test run.\nfunc RunTests(t *testing.T, newStorage func() storage.Storage) {\n\trunTests(t, newStorage, []subTest{\n\t\t{\"AuthCodeCRUD\", testAuthCodeCRUD},\n\t\t{\"AuthRequestCRUD\", testAuthRequestCRUD},\n\t\t{\"ClientCRUD\", testClientCRUD},\n\t\t{\"RefreshTokenCRUD\", testRefreshTokenCRUD},\n\t\t{\"PasswordCRUD\", testPasswordCRUD},\n\t\t{\"KeysCRUD\", testKeysCRUD},\n\t\t{\"OfflineSessionCRUD\", testOfflineSessionCRUD},\n\t\t{\"ConnectorCRUD\", testConnectorCRUD},\n\t\t{\"GarbageCollection\", testGC},\n\t\t{\"TimezoneSupport\", testTimezones},\n\t\t{\"DeviceRequestCRUD\", testDeviceRequestCRUD},\n\t\t{\"DeviceTokenCRUD\", testDeviceTokenCRUD},\n\t})\n}\n\nfunc mustLoadJWK(b string) *jose.JSONWebKey {\n\tvar jwt jose.JSONWebKey\n\tif err := jwt.UnmarshalJSON([]byte(b)); err != nil {\n\t\tpanic(err)\n\t}\n\treturn &jwt\n}\n\nfunc mustBeErrNotFound(t *testing.T, kind string, err error) {\n\tswitch {\n\tcase err == nil:\n\t\tt.Errorf(\"deleting non-existent %s should return an error\", kind)\n\tcase err != storage.ErrNotFound:\n\t\tt.Errorf(\"deleting %s expected storage.ErrNotFound, got %v\", kind, err)\n\t}\n}\n\nfunc mustBeErrAlreadyExists(t *testing.T, kind string, err error) {\n\tswitch {\n\tcase err == nil:\n\t\tt.Errorf(\"attempting to create an existing %s should return an error\", kind)\n\tcase err != storage.ErrAlreadyExists:\n\t\tt.Errorf(\"creating an existing %s expected storage.ErrAlreadyExists, got %v\", kind, err)\n\t}\n}\n\nfunc testAuthRequestCRUD(t *testing.T, s storage.Storage) {\n\tcodeChallenge := storage.PKCE{\n\t\tCodeChallenge:       \"code_challenge_test\",\n\t\tCodeChallengeMethod: \"plain\",\n\t}\n\n\ta1 := storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            \"client1\",\n\t\tResponseTypes:       []string{\"code\"},\n\t\tScopes:              []string{\"openid\", \"email\"},\n\t\tRedirectURI:         \"https://localhost:80/callback\",\n\t\tNonce:               \"foo\",\n\t\tState:               \"bar\",\n\t\tForceApprovalPrompt: true,\n\t\tLoggedIn:            true,\n\t\tExpiry:              neverExpire,\n\t\tConnectorID:         \"ldap\",\n\t\tConnectorData:       []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tPKCE: codeChallenge,\n\t}\n\n\tidentity := storage.Claims{Email: \"foobar\"}\n\n\tif err := s.CreateAuthRequest(a1); err != nil {\n\t\tt.Fatalf(\"failed creating auth request: %v\", err)\n\t}\n\n\t// Attempt to create same AuthRequest twice.\n\terr := s.CreateAuthRequest(a1)\n\tmustBeErrAlreadyExists(t, \"auth request\", err)\n\n\ta2 := storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            \"client2\",\n\t\tResponseTypes:       []string{\"code\"},\n\t\tScopes:              []string{\"openid\", \"email\"},\n\t\tRedirectURI:         \"https://localhost:80/callback\",\n\t\tNonce:               \"bar\",\n\t\tState:               \"foo\",\n\t\tForceApprovalPrompt: true,\n\t\tLoggedIn:            true,\n\t\tExpiry:              neverExpire,\n\t\tConnectorID:         \"ldap\",\n\t\tConnectorData:       []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"2\",\n\t\t\tUsername:      \"john\",\n\t\t\tEmail:         \"john.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\"},\n\t\t},\n\t}\n\n\tif err := s.CreateAuthRequest(a2); err != nil {\n\t\tt.Fatalf(\"failed creating auth request: %v\", err)\n\t}\n\n\tif err := s.UpdateAuthRequest(a1.ID, func(old storage.AuthRequest) (storage.AuthRequest, error) {\n\t\told.Claims = identity\n\t\told.ConnectorID = \"connID\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update auth request: %v\", err)\n\t}\n\n\tgot, err := s.GetAuthRequest(a1.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get auth req: %v\", err)\n\t}\n\tif !reflect.DeepEqual(got.Claims, identity) {\n\t\tt.Fatalf(\"update failed, wanted identity=%#v got %#v\", identity, got.Claims)\n\t}\n\n\tif !reflect.DeepEqual(got.PKCE, codeChallenge) {\n\t\tt.Fatalf(\"storage does not support PKCE, wanted challenge=%#v got %#v\", codeChallenge, got.PKCE)\n\t}\n\n\tif err := s.DeleteAuthRequest(a1.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete auth request: %v\", err)\n\t}\n\n\tif err := s.DeleteAuthRequest(a2.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete auth request: %v\", err)\n\t}\n\n\t_, err = s.GetAuthRequest(a1.ID)\n\tmustBeErrNotFound(t, \"auth request\", err)\n}\n\nfunc testAuthCodeCRUD(t *testing.T, s storage.Storage) {\n\ta1 := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"client1\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        neverExpire,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       \"12345\",\n\t\t\tCodeChallengeMethod: \"Whatever\",\n\t\t},\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\n\tif err := s.CreateAuthCode(a1); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\n\ta2 := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"client2\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        neverExpire,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"2\",\n\t\t\tUsername:      \"john\",\n\t\t\tEmail:         \"john.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\"},\n\t\t},\n\t}\n\n\t// Attempt to create same AuthCode twice.\n\terr := s.CreateAuthCode(a1)\n\tmustBeErrAlreadyExists(t, \"auth code\", err)\n\n\tif err := s.CreateAuthCode(a2); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\n\tgot, err := s.GetAuthCode(a1.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get auth code: %v\", err)\n\t}\n\tif a1.Expiry.Unix() != got.Expiry.Unix() {\n\t\tt.Errorf(\"auth code expiry did not match want=%s vs got=%s\", a1.Expiry, got.Expiry)\n\t}\n\tgot.Expiry = a1.Expiry // time fields do not compare well\n\tif diff := pretty.Compare(a1, got); diff != \"\" {\n\t\tt.Errorf(\"auth code retrieved from storage did not match: %s\", diff)\n\t}\n\n\tif err := s.DeleteAuthCode(a1.ID); err != nil {\n\t\tt.Fatalf(\"delete auth code: %v\", err)\n\t}\n\n\tif err := s.DeleteAuthCode(a2.ID); err != nil {\n\t\tt.Fatalf(\"delete auth code: %v\", err)\n\t}\n\n\t_, err = s.GetAuthCode(a1.ID)\n\tmustBeErrNotFound(t, \"auth code\", err)\n}\n\nfunc testClientCRUD(t *testing.T, s storage.Storage) {\n\tid1 := storage.NewID()\n\tc1 := storage.Client{\n\t\tID:           id1,\n\t\tSecret:       \"foobar\",\n\t\tRedirectURIs: []string{\"foo://bar.com/\", \"https://auth.example.com\"},\n\t\tName:         \"dex client\",\n\t\tLogoURL:      \"https://goo.gl/JIyzIC\",\n\t}\n\terr := s.DeleteClient(id1)\n\tmustBeErrNotFound(t, \"client\", err)\n\n\tif err := s.CreateClient(c1); err != nil {\n\t\tt.Fatalf(\"create client: %v\", err)\n\t}\n\n\t// Attempt to create same Client twice.\n\terr = s.CreateClient(c1)\n\tmustBeErrAlreadyExists(t, \"client\", err)\n\n\tid2 := storage.NewID()\n\tc2 := storage.Client{\n\t\tID:           id2,\n\t\tSecret:       \"barfoo\",\n\t\tRedirectURIs: []string{\"foo://bar.com/\", \"https://auth.example.com\"},\n\t\tName:         \"dex client\",\n\t\tLogoURL:      \"https://goo.gl/JIyzIC\",\n\t}\n\n\tif err := s.CreateClient(c2); err != nil {\n\t\tt.Fatalf(\"create client: %v\", err)\n\t}\n\n\tgetAndCompare := func(_ string, want storage.Client) {\n\t\tgc, err := s.GetClient(id1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get client: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif diff := pretty.Compare(want, gc); diff != \"\" {\n\t\t\tt.Errorf(\"client retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(id1, c1)\n\n\tnewSecret := \"barfoo\"\n\terr = s.UpdateClient(id1, func(old storage.Client) (storage.Client, error) {\n\t\told.Secret = newSecret\n\t\treturn old, nil\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"update client: %v\", err)\n\t}\n\tc1.Secret = newSecret\n\tgetAndCompare(id1, c1)\n\n\tif err := s.DeleteClient(id1); err != nil {\n\t\tt.Fatalf(\"delete client: %v\", err)\n\t}\n\n\tif err := s.DeleteClient(id2); err != nil {\n\t\tt.Fatalf(\"delete client: %v\", err)\n\t}\n\n\t_, err = s.GetClient(id1)\n\tmustBeErrNotFound(t, \"client\", err)\n}\n\nfunc testRefreshTokenCRUD(t *testing.T, s storage.Storage) {\n\tid := storage.NewID()\n\trefresh := storage.RefreshToken{\n\t\tID:            id,\n\t\tToken:         \"bar\",\n\t\tObsoleteToken: \"\",\n\t\tNonce:         \"foo\",\n\t\tClientID:      \"client_id\",\n\t\tConnectorID:   \"client_secret\",\n\t\tScopes:        []string{\"openid\", \"email\", \"profile\"},\n\t\tCreatedAt:     time.Now().UTC().Round(time.Millisecond),\n\t\tLastUsed:      time.Now().UTC().Round(time.Millisecond),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\tif err := s.CreateRefresh(refresh); err != nil {\n\t\tt.Fatalf(\"create refresh token: %v\", err)\n\t}\n\n\t// Attempt to create same Refresh Token twice.\n\terr := s.CreateRefresh(refresh)\n\tmustBeErrAlreadyExists(t, \"refresh token\", err)\n\n\tgetAndCompare := func(id string, want storage.RefreshToken) {\n\t\tgr, err := s.GetRefresh(id)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get refresh: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif diff := pretty.Compare(gr.CreatedAt.UnixNano(), gr.CreatedAt.UnixNano()); diff != \"\" {\n\t\t\tt.Errorf(\"refresh token created timestamp retrieved from storage did not match: %s\", diff)\n\t\t}\n\n\t\tif diff := pretty.Compare(gr.LastUsed.UnixNano(), gr.LastUsed.UnixNano()); diff != \"\" {\n\t\t\tt.Errorf(\"refresh token last used timestamp retrieved from storage did not match: %s\", diff)\n\t\t}\n\n\t\tgr.CreatedAt = time.Time{}\n\t\tgr.LastUsed = time.Time{}\n\t\twant.CreatedAt = time.Time{}\n\t\twant.LastUsed = time.Time{}\n\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"refresh token retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(id, refresh)\n\n\tid2 := storage.NewID()\n\trefresh2 := storage.RefreshToken{\n\t\tID:            id2,\n\t\tToken:         \"bar_2\",\n\t\tObsoleteToken: refresh.Token,\n\t\tNonce:         \"foo_2\",\n\t\tClientID:      \"client_id_2\",\n\t\tConnectorID:   \"client_secret\",\n\t\tScopes:        []string{\"openid\", \"email\", \"profile\"},\n\t\tCreatedAt:     time.Now().UTC().Round(time.Millisecond),\n\t\tLastUsed:      time.Now().UTC().Round(time.Millisecond),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"2\",\n\t\t\tUsername:      \"john\",\n\t\t\tEmail:         \"john.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\n\tif err := s.CreateRefresh(refresh2); err != nil {\n\t\tt.Fatalf(\"create second refresh token: %v\", err)\n\t}\n\n\tgetAndCompare(id2, refresh2)\n\n\tupdatedAt := time.Now().UTC().Round(time.Millisecond)\n\n\tupdater := func(r storage.RefreshToken) (storage.RefreshToken, error) {\n\t\tr.Token = \"spam\"\n\t\tr.LastUsed = updatedAt\n\t\treturn r, nil\n\t}\n\tif err := s.UpdateRefreshToken(id, updater); err != nil {\n\t\tt.Errorf(\"failed to update refresh token: %v\", err)\n\t}\n\trefresh.Token = \"spam\"\n\trefresh.LastUsed = updatedAt\n\tgetAndCompare(id, refresh)\n\n\t// Ensure that updating the first token doesn't impact the second. Issue #847.\n\tgetAndCompare(id2, refresh2)\n\n\tif err := s.DeleteRefresh(id); err != nil {\n\t\tt.Fatalf(\"failed to delete refresh request: %v\", err)\n\t}\n\n\tif err := s.DeleteRefresh(id2); err != nil {\n\t\tt.Fatalf(\"failed to delete refresh request: %v\", err)\n\t}\n\n\t_, err = s.GetRefresh(id)\n\tmustBeErrNotFound(t, \"refresh token\", err)\n}\n\ntype byEmail []storage.Password\n\nfunc (n byEmail) Len() int           { return len(n) }\nfunc (n byEmail) Less(i, j int) bool { return n[i].Email < n[j].Email }\nfunc (n byEmail) Swap(i, j int)      { n[i], n[j] = n[j], n[i] }\n\nfunc testPasswordCRUD(t *testing.T, s storage.Storage) {\n\t// Use bcrypt.MinCost to keep the tests short.\n\tpasswordHash1, err := bcrypt.GenerateFromPassword([]byte(\"secret\"), bcrypt.MinCost)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpassword1 := storage.Password{\n\t\tEmail:    \"jane@example.com\",\n\t\tHash:     passwordHash1,\n\t\tUsername: \"jane\",\n\t\tUserID:   \"foobar\",\n\t}\n\tif err := s.CreatePassword(password1); err != nil {\n\t\tt.Fatalf(\"create password token: %v\", err)\n\t}\n\n\t// Attempt to create same Password twice.\n\terr = s.CreatePassword(password1)\n\tmustBeErrAlreadyExists(t, \"password\", err)\n\n\tpasswordHash2, err := bcrypt.GenerateFromPassword([]byte(\"password\"), bcrypt.MinCost)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpassword2 := storage.Password{\n\t\tEmail:    \"john@example.com\",\n\t\tHash:     passwordHash2,\n\t\tUsername: \"john\",\n\t\tUserID:   \"barfoo\",\n\t}\n\tif err := s.CreatePassword(password2); err != nil {\n\t\tt.Fatalf(\"create password token: %v\", err)\n\t}\n\n\tgetAndCompare := func(id string, want storage.Password) {\n\t\tgr, err := s.GetPassword(id)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get password %q: %v\", id, err)\n\t\t\treturn\n\t\t}\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"password retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(\"jane@example.com\", password1)\n\tgetAndCompare(\"JANE@example.com\", password1) // Emails should be case insensitive\n\n\tif err := s.UpdatePassword(password1.Email, func(old storage.Password) (storage.Password, error) {\n\t\told.Username = \"jane doe\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update auth request: %v\", err)\n\t}\n\n\tpassword1.Username = \"jane doe\"\n\tgetAndCompare(\"jane@example.com\", password1)\n\n\tvar passwordList []storage.Password\n\tpasswordList = append(passwordList, password1, password2)\n\n\tlistAndCompare := func(want []storage.Password) {\n\t\tpasswords, err := s.ListPasswords()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"list password: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tsort.Sort(byEmail(want))\n\t\tsort.Sort(byEmail(passwords))\n\t\tif diff := pretty.Compare(want, passwords); diff != \"\" {\n\t\t\tt.Errorf(\"password list retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tlistAndCompare(passwordList)\n\n\tif err := s.DeletePassword(password1.Email); err != nil {\n\t\tt.Fatalf(\"failed to delete password: %v\", err)\n\t}\n\n\tif err := s.DeletePassword(password2.Email); err != nil {\n\t\tt.Fatalf(\"failed to delete password: %v\", err)\n\t}\n\n\t_, err = s.GetPassword(password1.Email)\n\tmustBeErrNotFound(t, \"password\", err)\n}\n\nfunc testOfflineSessionCRUD(t *testing.T, s storage.Storage) {\n\tuserID1 := storage.NewID()\n\tsession1 := storage.OfflineSessions{\n\t\tUserID:        userID1,\n\t\tConnID:        \"Conn1\",\n\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\n\t// Creating an OfflineSession with an empty Refresh list to ensure that\n\t// an empty map is translated as expected by the storage.\n\tif err := s.CreateOfflineSessions(session1); err != nil {\n\t\tt.Fatalf(\"create offline session with UserID = %s: %v\", session1.UserID, err)\n\t}\n\n\t// Attempt to create same OfflineSession twice.\n\terr := s.CreateOfflineSessions(session1)\n\tmustBeErrAlreadyExists(t, \"offline session\", err)\n\n\tuserID2 := storage.NewID()\n\tsession2 := storage.OfflineSessions{\n\t\tUserID:        userID2,\n\t\tConnID:        \"Conn2\",\n\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\n\tif err := s.CreateOfflineSessions(session2); err != nil {\n\t\tt.Fatalf(\"create offline session with UserID = %s: %v\", session2.UserID, err)\n\t}\n\n\tgetAndCompare := func(userID string, connID string, want storage.OfflineSessions) {\n\t\tgr, err := s.GetOfflineSessions(userID, connID)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get offline session: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"offline session retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(userID1, \"Conn1\", session1)\n\n\tid := storage.NewID()\n\ttokenRef := storage.RefreshTokenRef{\n\t\tID:        id,\n\t\tClientID:  \"client_id\",\n\t\tCreatedAt: time.Now().UTC().Round(time.Millisecond),\n\t\tLastUsed:  time.Now().UTC().Round(time.Millisecond),\n\t}\n\tsession1.Refresh[tokenRef.ClientID] = &tokenRef\n\n\tif err := s.UpdateOfflineSessions(session1.UserID, session1.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\told.Refresh[tokenRef.ClientID] = &tokenRef\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update offline session: %v\", err)\n\t}\n\n\tgetAndCompare(userID1, \"Conn1\", session1)\n\n\tif err := s.DeleteOfflineSessions(session1.UserID, session1.ConnID); err != nil {\n\t\tt.Fatalf(\"failed to delete offline session: %v\", err)\n\t}\n\n\tif err := s.DeleteOfflineSessions(session2.UserID, session2.ConnID); err != nil {\n\t\tt.Fatalf(\"failed to delete offline session: %v\", err)\n\t}\n\n\t_, err = s.GetOfflineSessions(session1.UserID, session1.ConnID)\n\tmustBeErrNotFound(t, \"offline session\", err)\n}\n\nfunc testConnectorCRUD(t *testing.T, s storage.Storage) {\n\tid1 := storage.NewID()\n\tconfig1 := []byte(`{\"issuer\": \"https://accounts.google.com\"}`)\n\tc1 := storage.Connector{\n\t\tID:     id1,\n\t\tType:   \"Default\",\n\t\tName:   \"Default\",\n\t\tConfig: config1,\n\t}\n\n\tif err := s.CreateConnector(c1); err != nil {\n\t\tt.Fatalf(\"create connector with ID = %s: %v\", c1.ID, err)\n\t}\n\n\t// Attempt to create same Connector twice.\n\terr := s.CreateConnector(c1)\n\tmustBeErrAlreadyExists(t, \"connector\", err)\n\n\tid2 := storage.NewID()\n\tconfig2 := []byte(`{\"redirectURI\": \"http://127.0.0.1:5556/dex/callback\"}`)\n\tc2 := storage.Connector{\n\t\tID:     id2,\n\t\tType:   \"Mock\",\n\t\tName:   \"Mock\",\n\t\tConfig: config2,\n\t}\n\n\tif err := s.CreateConnector(c2); err != nil {\n\t\tt.Fatalf(\"create connector with ID = %s: %v\", c2.ID, err)\n\t}\n\n\tgetAndCompare := func(id string, want storage.Connector) {\n\t\tgr, err := s.GetConnector(id)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get connector: %v\", err)\n\t\t\treturn\n\t\t}\n\t\t// ignore resource version comparison\n\t\tgr.ResourceVersion = \"\"\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"connector retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(id1, c1)\n\n\tif err := s.UpdateConnector(c1.ID, func(old storage.Connector) (storage.Connector, error) {\n\t\told.Type = \"oidc\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update Connector: %v\", err)\n\t}\n\n\tc1.Type = \"oidc\"\n\tgetAndCompare(id1, c1)\n\n\tconnectorList := []storage.Connector{c1, c2}\n\tlistAndCompare := func(want []storage.Connector) {\n\t\tconnectors, err := s.ListConnectors()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"list connectors: %v\", err)\n\t\t\treturn\n\t\t}\n\t\t// ignore resource version comparison\n\t\tfor i := range connectors {\n\t\t\tconnectors[i].ResourceVersion = \"\"\n\t\t}\n\t\tsort.Slice(connectors, func(i, j int) bool {\n\t\t\treturn connectors[i].Name < connectors[j].Name\n\t\t})\n\t\tif diff := pretty.Compare(want, connectors); diff != \"\" {\n\t\t\tt.Errorf(\"connector list retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\tlistAndCompare(connectorList)\n\n\tif err := s.DeleteConnector(c1.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete connector: %v\", err)\n\t}\n\n\tif err := s.DeleteConnector(c2.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete connector: %v\", err)\n\t}\n\n\t_, err = s.GetConnector(c1.ID)\n\tmustBeErrNotFound(t, \"connector\", err)\n}\n\nfunc testKeysCRUD(t *testing.T, s storage.Storage) {\n\tupdateAndCompare := func(k storage.Keys) {\n\t\terr := s.UpdateKeys(func(oldKeys storage.Keys) (storage.Keys, error) {\n\t\t\treturn k, nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to update keys: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif got, err := s.GetKeys(); err != nil {\n\t\t\tt.Errorf(\"failed to get keys: %v\", err)\n\t\t} else {\n\t\t\tgot.NextRotation = got.NextRotation.UTC()\n\t\t\tif diff := pretty.Compare(k, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"got keys did not equal expected: %s\", diff)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Postgres isn't as accurate with nano seconds as we'd like\n\tn := time.Now().UTC().Round(time.Second)\n\n\tkeys1 := storage.Keys{\n\t\tSigningKey:    jsonWebKeys[0].Private,\n\t\tSigningKeyPub: jsonWebKeys[0].Public,\n\t\tNextRotation:  n,\n\t}\n\n\tkeys2 := storage.Keys{\n\t\tSigningKey:    jsonWebKeys[2].Private,\n\t\tSigningKeyPub: jsonWebKeys[2].Public,\n\t\tNextRotation:  n.Add(time.Hour),\n\t\tVerificationKeys: []storage.VerificationKey{\n\t\t\t{\n\t\t\t\tPublicKey: jsonWebKeys[0].Public,\n\t\t\t\tExpiry:    n.Add(time.Hour),\n\t\t\t},\n\t\t\t{\n\t\t\t\tPublicKey: jsonWebKeys[1].Public,\n\t\t\t\tExpiry:    n.Add(time.Hour * 2),\n\t\t\t},\n\t\t},\n\t}\n\n\tupdateAndCompare(keys1)\n\tupdateAndCompare(keys2)\n}\n\nfunc testGC(t *testing.T, s storage.Storage) {\n\test, err := time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpst, err := time.LoadLocation(\"America/Los_Angeles\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpiry := time.Now().In(est)\n\tc := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"foobar\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        expiry,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\n\tif err := s.CreateAuthCode(c); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.AuthCodes != 0 || result.AuthRequests != 0 {\n\t\t\tt.Errorf(\"expected no garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetAuthCode(c.ID); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get auth code after GC: %v\", err)\n\t\t}\n\t}\n\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.AuthCodes != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 objects, got %d\", r.AuthCodes)\n\t}\n\n\tif _, err := s.GetAuthCode(c.ID); err == nil {\n\t\tt.Errorf(\"expected auth code to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n\n\ta := storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            \"foobar\",\n\t\tResponseTypes:       []string{\"code\"},\n\t\tScopes:              []string{\"openid\", \"email\"},\n\t\tRedirectURI:         \"https://localhost:80/callback\",\n\t\tNonce:               \"foo\",\n\t\tState:               \"bar\",\n\t\tForceApprovalPrompt: true,\n\t\tLoggedIn:            true,\n\t\tExpiry:              expiry,\n\t\tConnectorID:         \"ldap\",\n\t\tConnectorData:       []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\n\tif err := s.CreateAuthRequest(a); err != nil {\n\t\tt.Fatalf(\"failed creating auth request: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.AuthCodes != 0 || result.AuthRequests != 0 {\n\t\t\tt.Errorf(\"expected no garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetAuthRequest(a.ID); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get auth request after GC: %v\", err)\n\t\t}\n\t}\n\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.AuthRequests != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 objects, got %d\", r.AuthRequests)\n\t}\n\n\tif _, err := s.GetAuthRequest(a.ID); err == nil {\n\t\tt.Errorf(\"expected auth request to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n\n\td := storage.DeviceRequest{\n\t\tUserCode:     storage.NewUserCode(),\n\t\tDeviceCode:   storage.NewID(),\n\t\tClientID:     \"client1\",\n\t\tClientSecret: \"secret1\",\n\t\tScopes:       []string{\"openid\", \"email\"},\n\t\tExpiry:       expiry,\n\t}\n\n\tif err := s.CreateDeviceRequest(d); err != nil {\n\t\tt.Fatalf(\"failed creating device request: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.DeviceRequests != 0 {\n\t\t\tt.Errorf(\"expected no device garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetDeviceRequest(d.UserCode); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get auth request after GC: %v\", err)\n\t\t}\n\t}\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.DeviceRequests != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 device request, got %d\", r.DeviceRequests)\n\t}\n\n\tif _, err := s.GetDeviceRequest(d.UserCode); err == nil {\n\t\tt.Errorf(\"expected device request to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n\n\tdt := storage.DeviceToken{\n\t\tDeviceCode:          storage.NewID(),\n\t\tStatus:              \"pending\",\n\t\tToken:               \"foo\",\n\t\tExpiry:              expiry,\n\t\tLastRequestTime:     time.Now(),\n\t\tPollIntervalSeconds: 0,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       \"challenge\",\n\t\t\tCodeChallengeMethod: \"S256\",\n\t\t},\n\t}\n\n\tif err := s.CreateDeviceToken(dt); err != nil {\n\t\tt.Fatalf(\"failed creating device token: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.DeviceTokens != 0 {\n\t\t\tt.Errorf(\"expected no device token garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetDeviceToken(dt.DeviceCode); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get device token after GC: %v\", err)\n\t\t}\n\t}\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.DeviceTokens != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 device token, got %d\", r.DeviceTokens)\n\t}\n\n\tif _, err := s.GetDeviceToken(dt.DeviceCode); err == nil {\n\t\tt.Errorf(\"expected device token to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n}\n\n// testTimezones tests that backends either fully support timezones or\n// do the correct standardization.\nfunc testTimezones(t *testing.T, s storage.Storage) {\n\test, err := time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create an expiry with timezone info. Only expect backends to be\n\t// accurate to the millisecond\n\texpiry := time.Now().In(est).Round(time.Millisecond)\n\n\tc := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"foobar\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        expiry,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\tif err := s.CreateAuthCode(c); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\tgot, err := s.GetAuthCode(c.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get auth code: %v\", err)\n\t}\n\n\t// Ensure that if the resulting time is converted to the same\n\t// timezone, it's the same value. We DO NOT expect timezones\n\t// to be preserved.\n\tgotTime := got.Expiry.In(est)\n\twantTime := expiry\n\tif !gotTime.Equal(wantTime) {\n\t\tt.Fatalf(\"expected expiry %v got %v\", wantTime, gotTime)\n\t}\n}\n\nfunc testDeviceRequestCRUD(t *testing.T, s storage.Storage) {\n\td1 := storage.DeviceRequest{\n\t\tUserCode:     storage.NewUserCode(),\n\t\tDeviceCode:   storage.NewID(),\n\t\tClientID:     \"client1\",\n\t\tClientSecret: \"secret1\",\n\t\tScopes:       []string{\"openid\", \"email\"},\n\t\tExpiry:       neverExpire,\n\t}\n\n\tif err := s.CreateDeviceRequest(d1); err != nil {\n\t\tt.Fatalf(\"failed creating device request: %v\", err)\n\t}\n\n\t// Attempt to create same DeviceRequest twice.\n\terr := s.CreateDeviceRequest(d1)\n\tmustBeErrAlreadyExists(t, \"device request\", err)\n\n\t// No manual deletes for device requests, will be handled by garbage collection routines\n\t// see testGC\n}\n\nfunc testDeviceTokenCRUD(t *testing.T, s storage.Storage) {\n\tcodeChallenge := storage.PKCE{\n\t\tCodeChallenge:       \"code_challenge_test\",\n\t\tCodeChallengeMethod: \"plain\",\n\t}\n\n\t// Create a Token\n\td1 := storage.DeviceToken{\n\t\tDeviceCode:          storage.NewID(),\n\t\tStatus:              \"pending\",\n\t\tToken:               storage.NewID(),\n\t\tExpiry:              neverExpire,\n\t\tLastRequestTime:     time.Now(),\n\t\tPollIntervalSeconds: 0,\n\t\tPKCE:                codeChallenge,\n\t}\n\n\tif err := s.CreateDeviceToken(d1); err != nil {\n\t\tt.Fatalf(\"failed creating device token: %v\", err)\n\t}\n\n\t// Attempt to create same Device Token twice.\n\terr := s.CreateDeviceToken(d1)\n\tmustBeErrAlreadyExists(t, \"device token\", err)\n\n\t// Update the device token, simulate a redemption\n\tif err := s.UpdateDeviceToken(d1.DeviceCode, func(old storage.DeviceToken) (storage.DeviceToken, error) {\n\t\told.Token = \"token data\"\n\t\told.Status = \"complete\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update device token: %v\", err)\n\t}\n\n\t// Retrieve the device token\n\tgot, err := s.GetDeviceToken(d1.DeviceCode)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get device token: %v\", err)\n\t}\n\n\t// Validate expected result set\n\tif got.Status != \"complete\" {\n\t\tt.Fatalf(\"update failed, wanted token status=%v got %v\", \"complete\", got.Status)\n\t}\n\tif got.Token != \"token data\" {\n\t\tt.Fatalf(\"update failed, wanted token %v got %v\", \"token data\", got.Token)\n\t}\n\tif !reflect.DeepEqual(got.PKCE, codeChallenge) {\n\t\tt.Fatalf(\"storage does not support PKCE, wanted challenge=%#v got %#v\", codeChallenge, got.PKCE)\n\t}\n}\n", "package client\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// CreateAuthRequest saves provided auth request into the database.\nfunc (d *Database) CreateAuthRequest(authRequest storage.AuthRequest) error {\n\t_, err := d.client.AuthRequest.Create().\n\t\tSetID(authRequest.ID).\n\t\tSetClientID(authRequest.ClientID).\n\t\tSetScopes(authRequest.Scopes).\n\t\tSetResponseTypes(authRequest.ResponseTypes).\n\t\tSetRedirectURI(authRequest.RedirectURI).\n\t\tSetState(authRequest.State).\n\t\tSetNonce(authRequest.Nonce).\n\t\tSetForceApprovalPrompt(authRequest.ForceApprovalPrompt).\n\t\tSetLoggedIn(authRequest.LoggedIn).\n\t\tSetClaimsUserID(authRequest.Claims.UserID).\n\t\tSetClaimsEmail(authRequest.Claims.Email).\n\t\tSetClaimsEmailVerified(authRequest.Claims.EmailVerified).\n\t\tSetClaimsUsername(authRequest.Claims.Username).\n\t\tSetClaimsPreferredUsername(authRequest.Claims.PreferredUsername).\n\t\tSetClaimsGroups(authRequest.Claims.Groups).\n\t\tSetCodeChallenge(authRequest.PKCE.CodeChallenge).\n\t\tSetCodeChallengeMethod(authRequest.PKCE.CodeChallengeMethod).\n\t\t// Save utc time into database because ent doesn't support comparing dates with different timezones\n\t\tSetExpiry(authRequest.Expiry.UTC()).\n\t\tSetConnectorID(authRequest.ConnectorID).\n\t\tSetConnectorData(authRequest.ConnectorData).\n\t\tSave(context.TODO())\n\tif err != nil {\n\t\treturn convertDBError(\"create auth request: %w\", err)\n\t}\n\treturn nil\n}\n\n// GetAuthRequest extracts an auth request from the database by id.\nfunc (d *Database) GetAuthRequest(id string) (storage.AuthRequest, error) {\n\tauthRequest, err := d.client.AuthRequest.Get(context.TODO(), id)\n\tif err != nil {\n\t\treturn storage.AuthRequest{}, convertDBError(\"get auth request: %w\", err)\n\t}\n\treturn toStorageAuthRequest(authRequest), nil\n}\n\n// DeleteAuthRequest deletes an auth request from the database by id.\nfunc (d *Database) DeleteAuthRequest(id string) error {\n\terr := d.client.AuthRequest.DeleteOneID(id).Exec(context.TODO())\n\tif err != nil {\n\t\treturn convertDBError(\"delete auth request: %w\", err)\n\t}\n\treturn nil\n}\n\n// UpdateAuthRequest changes an auth request by id using an updater function and saves it to the database.\nfunc (d *Database) UpdateAuthRequest(id string, updater func(old storage.AuthRequest) (storage.AuthRequest, error)) error {\n\ttx, err := d.BeginTx(context.TODO())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"update auth request tx: %w\", err)\n\t}\n\n\tauthRequest, err := tx.AuthRequest.Get(context.TODO(), id)\n\tif err != nil {\n\t\treturn rollback(tx, \"update auth request database: %w\", err)\n\t}\n\n\tnewAuthRequest, err := updater(toStorageAuthRequest(authRequest))\n\tif err != nil {\n\t\treturn rollback(tx, \"update auth request updating: %w\", err)\n\t}\n\n\t_, err = tx.AuthRequest.UpdateOneID(newAuthRequest.ID).\n\t\tSetClientID(newAuthRequest.ClientID).\n\t\tSetScopes(newAuthRequest.Scopes).\n\t\tSetResponseTypes(newAuthRequest.ResponseTypes).\n\t\tSetRedirectURI(newAuthRequest.RedirectURI).\n\t\tSetState(newAuthRequest.State).\n\t\tSetNonce(newAuthRequest.Nonce).\n\t\tSetForceApprovalPrompt(newAuthRequest.ForceApprovalPrompt).\n\t\tSetLoggedIn(newAuthRequest.LoggedIn).\n\t\tSetClaimsUserID(newAuthRequest.Claims.UserID).\n\t\tSetClaimsEmail(newAuthRequest.Claims.Email).\n\t\tSetClaimsEmailVerified(newAuthRequest.Claims.EmailVerified).\n\t\tSetClaimsUsername(newAuthRequest.Claims.Username).\n\t\tSetClaimsPreferredUsername(newAuthRequest.Claims.PreferredUsername).\n\t\tSetClaimsGroups(newAuthRequest.Claims.Groups).\n\t\tSetCodeChallenge(newAuthRequest.PKCE.CodeChallenge).\n\t\tSetCodeChallengeMethod(newAuthRequest.PKCE.CodeChallengeMethod).\n\t\t// Save utc time into database because ent doesn't support comparing dates with different timezones\n\t\tSetExpiry(newAuthRequest.Expiry.UTC()).\n\t\tSetConnectorID(newAuthRequest.ConnectorID).\n\t\tSetConnectorData(newAuthRequest.ConnectorData).\n\t\tSave(context.TODO())\n\tif err != nil {\n\t\treturn rollback(tx, \"update auth request uploading: %w\", err)\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\treturn rollback(tx, \"update auth request commit: %w\", err)\n\t}\n\n\treturn nil\n}\n", "package client\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/ent/db\"\n)\n\nconst keysRowID = \"keys\"\n\nfunc toStorageKeys(keys *db.Keys) storage.Keys {\n\treturn storage.Keys{\n\t\tSigningKey:       &keys.SigningKey,\n\t\tSigningKeyPub:    &keys.SigningKeyPub,\n\t\tVerificationKeys: keys.VerificationKeys,\n\t\tNextRotation:     keys.NextRotation,\n\t}\n}\n\nfunc toStorageAuthRequest(a *db.AuthRequest) storage.AuthRequest {\n\treturn storage.AuthRequest{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       *a.ConnectorData,\n\t\tExpiry:              a.Expiry,\n\t\tClaims: storage.Claims{\n\t\t\tUserID:            a.ClaimsUserID,\n\t\t\tUsername:          a.ClaimsUsername,\n\t\t\tPreferredUsername: a.ClaimsPreferredUsername,\n\t\t\tEmail:             a.ClaimsEmail,\n\t\t\tEmailVerified:     a.ClaimsEmailVerified,\n\t\t\tGroups:            a.ClaimsGroups,\n\t\t},\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\nfunc toStorageAuthCode(a *db.AuthCode) storage.AuthCode {\n\treturn storage.AuthCode{\n\t\tID:            a.ID,\n\t\tClientID:      a.ClientID,\n\t\tScopes:        a.Scopes,\n\t\tRedirectURI:   a.RedirectURI,\n\t\tNonce:         a.Nonce,\n\t\tConnectorID:   a.ConnectorID,\n\t\tConnectorData: *a.ConnectorData,\n\t\tExpiry:        a.Expiry,\n\t\tClaims: storage.Claims{\n\t\t\tUserID:            a.ClaimsUserID,\n\t\t\tUsername:          a.ClaimsUsername,\n\t\t\tPreferredUsername: a.ClaimsPreferredUsername,\n\t\t\tEmail:             a.ClaimsEmail,\n\t\t\tEmailVerified:     a.ClaimsEmailVerified,\n\t\t\tGroups:            a.ClaimsGroups,\n\t\t},\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\nfunc toStorageClient(c *db.OAuth2Client) storage.Client {\n\treturn storage.Client{\n\t\tID:           c.ID,\n\t\tSecret:       c.Secret,\n\t\tRedirectURIs: c.RedirectUris,\n\t\tTrustedPeers: c.TrustedPeers,\n\t\tPublic:       c.Public,\n\t\tName:         c.Name,\n\t\tLogoURL:      c.LogoURL,\n\t}\n}\n\nfunc toStorageConnector(c *db.Connector) storage.Connector {\n\treturn storage.Connector{\n\t\tID:     c.ID,\n\t\tType:   c.Type,\n\t\tName:   c.Name,\n\t\tConfig: c.Config,\n\t}\n}\n\nfunc toStorageOfflineSession(o *db.OfflineSession) storage.OfflineSessions {\n\ts := storage.OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tConnectorData: *o.ConnectorData,\n\t}\n\n\tif o.Refresh != nil {\n\t\tif err := json.Unmarshal(o.Refresh, &s.Refresh); err != nil {\n\t\t\t// Correctness of json structure if guaranteed on uploading\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\t// Server code assumes this will be non-nil.\n\t\ts.Refresh = make(map[string]*storage.RefreshTokenRef)\n\t}\n\treturn s\n}\n\nfunc toStorageRefreshToken(r *db.RefreshToken) storage.RefreshToken {\n\treturn storage.RefreshToken{\n\t\tID:            r.ID,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: *r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims: storage.Claims{\n\t\t\tUserID:            r.ClaimsUserID,\n\t\t\tUsername:          r.ClaimsUsername,\n\t\t\tPreferredUsername: r.ClaimsPreferredUsername,\n\t\t\tEmail:             r.ClaimsEmail,\n\t\t\tEmailVerified:     r.ClaimsEmailVerified,\n\t\t\tGroups:            r.ClaimsGroups,\n\t\t},\n\t}\n}\n\nfunc toStoragePassword(p *db.Password) storage.Password {\n\treturn storage.Password{\n\t\tEmail:    p.Email,\n\t\tHash:     p.Hash,\n\t\tUsername: p.Username,\n\t\tUserID:   p.UserID,\n\t}\n}\n\nfunc toStorageDeviceRequest(r *db.DeviceRequest) storage.DeviceRequest {\n\treturn storage.DeviceRequest{\n\t\tUserCode:     strings.ToUpper(r.UserCode),\n\t\tDeviceCode:   r.DeviceCode,\n\t\tClientID:     r.ClientID,\n\t\tClientSecret: r.ClientSecret,\n\t\tScopes:       r.Scopes,\n\t\tExpiry:       r.Expiry,\n\t}\n}\n\nfunc toStorageDeviceToken(t *db.DeviceToken) storage.DeviceToken {\n\treturn storage.DeviceToken{\n\t\tDeviceCode:          t.DeviceCode,\n\t\tStatus:              t.Status,\n\t\tToken:               string(*t.Token),\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequest,\n\t\tPollIntervalSeconds: t.PollInterval,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       t.CodeChallenge,\n\t\t\tCodeChallengeMethod: t.CodeChallengeMethod,\n\t\t},\n\t}\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n)\n\n// AuthRequest is the model entity for the AuthRequest schema.\ntype AuthRequest struct {\n\tconfig `json:\"-\"`\n\t// ID of the ent.\n\tID string `json:\"id,omitempty\"`\n\t// ClientID holds the value of the \"client_id\" field.\n\tClientID string `json:\"client_id,omitempty\"`\n\t// Scopes holds the value of the \"scopes\" field.\n\tScopes []string `json:\"scopes,omitempty\"`\n\t// ResponseTypes holds the value of the \"response_types\" field.\n\tResponseTypes []string `json:\"response_types,omitempty\"`\n\t// RedirectURI holds the value of the \"redirect_uri\" field.\n\tRedirectURI string `json:\"redirect_uri,omitempty\"`\n\t// Nonce holds the value of the \"nonce\" field.\n\tNonce string `json:\"nonce,omitempty\"`\n\t// State holds the value of the \"state\" field.\n\tState string `json:\"state,omitempty\"`\n\t// ForceApprovalPrompt holds the value of the \"force_approval_prompt\" field.\n\tForceApprovalPrompt bool `json:\"force_approval_prompt,omitempty\"`\n\t// LoggedIn holds the value of the \"logged_in\" field.\n\tLoggedIn bool `json:\"logged_in,omitempty\"`\n\t// ClaimsUserID holds the value of the \"claims_user_id\" field.\n\tClaimsUserID string `json:\"claims_user_id,omitempty\"`\n\t// ClaimsUsername holds the value of the \"claims_username\" field.\n\tClaimsUsername string `json:\"claims_username,omitempty\"`\n\t// ClaimsEmail holds the value of the \"claims_email\" field.\n\tClaimsEmail string `json:\"claims_email,omitempty\"`\n\t// ClaimsEmailVerified holds the value of the \"claims_email_verified\" field.\n\tClaimsEmailVerified bool `json:\"claims_email_verified,omitempty\"`\n\t// ClaimsGroups holds the value of the \"claims_groups\" field.\n\tClaimsGroups []string `json:\"claims_groups,omitempty\"`\n\t// ClaimsPreferredUsername holds the value of the \"claims_preferred_username\" field.\n\tClaimsPreferredUsername string `json:\"claims_preferred_username,omitempty\"`\n\t// ConnectorID holds the value of the \"connector_id\" field.\n\tConnectorID string `json:\"connector_id,omitempty\"`\n\t// ConnectorData holds the value of the \"connector_data\" field.\n\tConnectorData *[]byte `json:\"connector_data,omitempty\"`\n\t// Expiry holds the value of the \"expiry\" field.\n\tExpiry time.Time `json:\"expiry,omitempty\"`\n\t// CodeChallenge holds the value of the \"code_challenge\" field.\n\tCodeChallenge string `json:\"code_challenge,omitempty\"`\n\t// CodeChallengeMethod holds the value of the \"code_challenge_method\" field.\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\n// scanValues returns the types for scanning values from sql.Rows.\nfunc (*AuthRequest) scanValues(columns []string) ([]interface{}, error) {\n\tvalues := make([]interface{}, len(columns))\n\tfor i := range columns {\n\t\tswitch columns[i] {\n\t\tcase authrequest.FieldScopes, authrequest.FieldResponseTypes, authrequest.FieldClaimsGroups, authrequest.FieldConnectorData:\n\t\t\tvalues[i] = new([]byte)\n\t\tcase authrequest.FieldForceApprovalPrompt, authrequest.FieldLoggedIn, authrequest.FieldClaimsEmailVerified:\n\t\t\tvalues[i] = new(sql.NullBool)\n\t\tcase authrequest.FieldID, authrequest.FieldClientID, authrequest.FieldRedirectURI, authrequest.FieldNonce, authrequest.FieldState, authrequest.FieldClaimsUserID, authrequest.FieldClaimsUsername, authrequest.FieldClaimsEmail, authrequest.FieldClaimsPreferredUsername, authrequest.FieldConnectorID, authrequest.FieldCodeChallenge, authrequest.FieldCodeChallengeMethod:\n\t\t\tvalues[i] = new(sql.NullString)\n\t\tcase authrequest.FieldExpiry:\n\t\t\tvalues[i] = new(sql.NullTime)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected column %q for type AuthRequest\", columns[i])\n\t\t}\n\t}\n\treturn values, nil\n}\n\n// assignValues assigns the values that were returned from sql.Rows (after scanning)\n// to the AuthRequest fields.\nfunc (ar *AuthRequest) assignValues(columns []string, values []interface{}) error {\n\tif m, n := len(values), len(columns); m < n {\n\t\treturn fmt.Errorf(\"mismatch number of scan values: %d != %d\", m, n)\n\t}\n\tfor i := range columns {\n\t\tswitch columns[i] {\n\t\tcase authrequest.FieldID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClientID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field client_id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClientID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldScopes:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field scopes\", values[i])\n\t\t\t} else if value != nil && len(*value) > 0 {\n\t\t\t\tif err := json.Unmarshal(*value, &ar.Scopes); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal field scopes: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase authrequest.FieldResponseTypes:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field response_types\", values[i])\n\t\t\t} else if value != nil && len(*value) > 0 {\n\t\t\t\tif err := json.Unmarshal(*value, &ar.ResponseTypes); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal field response_types: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase authrequest.FieldRedirectURI:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field redirect_uri\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.RedirectURI = value.String\n\t\t\t}\n\t\tcase authrequest.FieldNonce:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field nonce\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.Nonce = value.String\n\t\t\t}\n\t\tcase authrequest.FieldState:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field state\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.State = value.String\n\t\t\t}\n\t\tcase authrequest.FieldForceApprovalPrompt:\n\t\t\tif value, ok := values[i].(*sql.NullBool); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field force_approval_prompt\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ForceApprovalPrompt = value.Bool\n\t\t\t}\n\t\tcase authrequest.FieldLoggedIn:\n\t\t\tif value, ok := values[i].(*sql.NullBool); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field logged_in\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.LoggedIn = value.Bool\n\t\t\t}\n\t\tcase authrequest.FieldClaimsUserID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_user_id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsUserID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClaimsUsername:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_username\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsUsername = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClaimsEmail:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_email\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsEmail = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClaimsEmailVerified:\n\t\t\tif value, ok := values[i].(*sql.NullBool); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_email_verified\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsEmailVerified = value.Bool\n\t\t\t}\n\t\tcase authrequest.FieldClaimsGroups:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_groups\", values[i])\n\t\t\t} else if value != nil && len(*value) > 0 {\n\t\t\t\tif err := json.Unmarshal(*value, &ar.ClaimsGroups); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal field claims_groups: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase authrequest.FieldClaimsPreferredUsername:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_preferred_username\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsPreferredUsername = value.String\n\t\t\t}\n\t\tcase authrequest.FieldConnectorID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field connector_id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ConnectorID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldConnectorData:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field connector_data\", values[i])\n\t\t\t} else if value != nil {\n\t\t\t\tar.ConnectorData = value\n\t\t\t}\n\t\tcase authrequest.FieldExpiry:\n\t\t\tif value, ok := values[i].(*sql.NullTime); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field expiry\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.Expiry = value.Time\n\t\t\t}\n\t\tcase authrequest.FieldCodeChallenge:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field code_challenge\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.CodeChallenge = value.String\n\t\t\t}\n\t\tcase authrequest.FieldCodeChallengeMethod:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field code_challenge_method\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.CodeChallengeMethod = value.String\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Update returns a builder for updating this AuthRequest.\n// Note that you need to call AuthRequest.Unwrap() before calling this method if this AuthRequest\n// was returned from a transaction, and the transaction was committed or rolled back.\nfunc (ar *AuthRequest) Update() *AuthRequestUpdateOne {\n\treturn (&AuthRequestClient{config: ar.config}).UpdateOne(ar)\n}\n\n// Unwrap unwraps the AuthRequest entity that was returned from a transaction after it was closed,\n// so that all future queries will be executed through the driver which created the transaction.\nfunc (ar *AuthRequest) Unwrap() *AuthRequest {\n\t_tx, ok := ar.config.driver.(*txDriver)\n\tif !ok {\n\t\tpanic(\"db: AuthRequest is not a transactional entity\")\n\t}\n\tar.config.driver = _tx.drv\n\treturn ar\n}\n\n// String implements the fmt.Stringer.\nfunc (ar *AuthRequest) String() string {\n\tvar builder strings.Builder\n\tbuilder.WriteString(\"AuthRequest(\")\n\tbuilder.WriteString(fmt.Sprintf(\"id=%v, \", ar.ID))\n\tbuilder.WriteString(\"client_id=\")\n\tbuilder.WriteString(ar.ClientID)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"scopes=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.Scopes))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"response_types=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ResponseTypes))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"redirect_uri=\")\n\tbuilder.WriteString(ar.RedirectURI)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"nonce=\")\n\tbuilder.WriteString(ar.Nonce)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"state=\")\n\tbuilder.WriteString(ar.State)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"force_approval_prompt=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ForceApprovalPrompt))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"logged_in=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.LoggedIn))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_user_id=\")\n\tbuilder.WriteString(ar.ClaimsUserID)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_username=\")\n\tbuilder.WriteString(ar.ClaimsUsername)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_email=\")\n\tbuilder.WriteString(ar.ClaimsEmail)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_email_verified=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ClaimsEmailVerified))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_groups=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ClaimsGroups))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_preferred_username=\")\n\tbuilder.WriteString(ar.ClaimsPreferredUsername)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"connector_id=\")\n\tbuilder.WriteString(ar.ConnectorID)\n\tbuilder.WriteString(\", \")\n\tif v := ar.ConnectorData; v != nil {\n\t\tbuilder.WriteString(\"connector_data=\")\n\t\tbuilder.WriteString(fmt.Sprintf(\"%v\", *v))\n\t}\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"expiry=\")\n\tbuilder.WriteString(ar.Expiry.Format(time.ANSIC))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"code_challenge=\")\n\tbuilder.WriteString(ar.CodeChallenge)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"code_challenge_method=\")\n\tbuilder.WriteString(ar.CodeChallengeMethod)\n\tbuilder.WriteByte(')')\n\treturn builder.String()\n}\n\n// AuthRequests is a parsable slice of AuthRequest.\ntype AuthRequests []*AuthRequest\n\nfunc (ar AuthRequests) config(cfg config) {\n\tfor _i := range ar {\n\t\tar[_i].config = cfg\n\t}\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage authrequest\n\nconst (\n\t// Label holds the string label denoting the authrequest type in the database.\n\tLabel = \"auth_request\"\n\t// FieldID holds the string denoting the id field in the database.\n\tFieldID = \"id\"\n\t// FieldClientID holds the string denoting the client_id field in the database.\n\tFieldClientID = \"client_id\"\n\t// FieldScopes holds the string denoting the scopes field in the database.\n\tFieldScopes = \"scopes\"\n\t// FieldResponseTypes holds the string denoting the response_types field in the database.\n\tFieldResponseTypes = \"response_types\"\n\t// FieldRedirectURI holds the string denoting the redirect_uri field in the database.\n\tFieldRedirectURI = \"redirect_uri\"\n\t// FieldNonce holds the string denoting the nonce field in the database.\n\tFieldNonce = \"nonce\"\n\t// FieldState holds the string denoting the state field in the database.\n\tFieldState = \"state\"\n\t// FieldForceApprovalPrompt holds the string denoting the force_approval_prompt field in the database.\n\tFieldForceApprovalPrompt = \"force_approval_prompt\"\n\t// FieldLoggedIn holds the string denoting the logged_in field in the database.\n\tFieldLoggedIn = \"logged_in\"\n\t// FieldClaimsUserID holds the string denoting the claims_user_id field in the database.\n\tFieldClaimsUserID = \"claims_user_id\"\n\t// FieldClaimsUsername holds the string denoting the claims_username field in the database.\n\tFieldClaimsUsername = \"claims_username\"\n\t// FieldClaimsEmail holds the string denoting the claims_email field in the database.\n\tFieldClaimsEmail = \"claims_email\"\n\t// FieldClaimsEmailVerified holds the string denoting the claims_email_verified field in the database.\n\tFieldClaimsEmailVerified = \"claims_email_verified\"\n\t// FieldClaimsGroups holds the string denoting the claims_groups field in the database.\n\tFieldClaimsGroups = \"claims_groups\"\n\t// FieldClaimsPreferredUsername holds the string denoting the claims_preferred_username field in the database.\n\tFieldClaimsPreferredUsername = \"claims_preferred_username\"\n\t// FieldConnectorID holds the string denoting the connector_id field in the database.\n\tFieldConnectorID = \"connector_id\"\n\t// FieldConnectorData holds the string denoting the connector_data field in the database.\n\tFieldConnectorData = \"connector_data\"\n\t// FieldExpiry holds the string denoting the expiry field in the database.\n\tFieldExpiry = \"expiry\"\n\t// FieldCodeChallenge holds the string denoting the code_challenge field in the database.\n\tFieldCodeChallenge = \"code_challenge\"\n\t// FieldCodeChallengeMethod holds the string denoting the code_challenge_method field in the database.\n\tFieldCodeChallengeMethod = \"code_challenge_method\"\n\t// Table holds the table name of the authrequest in the database.\n\tTable = \"auth_requests\"\n)\n\n// Columns holds all SQL columns for authrequest fields.\nvar Columns = []string{\n\tFieldID,\n\tFieldClientID,\n\tFieldScopes,\n\tFieldResponseTypes,\n\tFieldRedirectURI,\n\tFieldNonce,\n\tFieldState,\n\tFieldForceApprovalPrompt,\n\tFieldLoggedIn,\n\tFieldClaimsUserID,\n\tFieldClaimsUsername,\n\tFieldClaimsEmail,\n\tFieldClaimsEmailVerified,\n\tFieldClaimsGroups,\n\tFieldClaimsPreferredUsername,\n\tFieldConnectorID,\n\tFieldConnectorData,\n\tFieldExpiry,\n\tFieldCodeChallenge,\n\tFieldCodeChallengeMethod,\n}\n\n// ValidColumn reports if the column name is valid (part of the table columns).\nfunc ValidColumn(column string) bool {\n\tfor i := range Columns {\n\t\tif column == Columns[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar (\n\t// DefaultClaimsPreferredUsername holds the default value on creation for the \"claims_preferred_username\" field.\n\tDefaultClaimsPreferredUsername string\n\t// DefaultCodeChallenge holds the default value on creation for the \"code_challenge\" field.\n\tDefaultCodeChallenge string\n\t// DefaultCodeChallengeMethod holds the default value on creation for the \"code_challenge_method\" field.\n\tDefaultCodeChallengeMethod string\n\t// IDValidator is a validator for the \"id\" field. It is called by the builders before save.\n\tIDValidator func(string) error\n)\n", "// Code generated by ent, DO NOT EDIT.\n\npackage authrequest\n\nimport (\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql\"\n\t\"github.com/dexidp/dex/storage/ent/db/predicate\"\n)\n\n// ID filters vertices based on their ID field.\nfunc ID(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldID), id))\n\t})\n}\n\n// IDEQ applies the EQ predicate on the ID field.\nfunc IDEQ(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldID), id))\n\t})\n}\n\n// IDNEQ applies the NEQ predicate on the ID field.\nfunc IDNEQ(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldID), id))\n\t})\n}\n\n// IDIn applies the In predicate on the ID field.\nfunc IDIn(ids ...string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldID), v...))\n\t})\n}\n\n// IDNotIn applies the NotIn predicate on the ID field.\nfunc IDNotIn(ids ...string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldID), v...))\n\t})\n}\n\n// IDGT applies the GT predicate on the ID field.\nfunc IDGT(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldID), id))\n\t})\n}\n\n// IDGTE applies the GTE predicate on the ID field.\nfunc IDGTE(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldID), id))\n\t})\n}\n\n// IDLT applies the LT predicate on the ID field.\nfunc IDLT(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldID), id))\n\t})\n}\n\n// IDLTE applies the LTE predicate on the ID field.\nfunc IDLTE(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldID), id))\n\t})\n}\n\n// ClientID applies equality check predicate on the \"client_id\" field. It's identical to ClientIDEQ.\nfunc ClientID(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClientID), v))\n\t})\n}\n\n// RedirectURI applies equality check predicate on the \"redirect_uri\" field. It's identical to RedirectURIEQ.\nfunc RedirectURI(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// Nonce applies equality check predicate on the \"nonce\" field. It's identical to NonceEQ.\nfunc Nonce(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldNonce), v))\n\t})\n}\n\n// State applies equality check predicate on the \"state\" field. It's identical to StateEQ.\nfunc State(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldState), v))\n\t})\n}\n\n// ForceApprovalPrompt applies equality check predicate on the \"force_approval_prompt\" field. It's identical to ForceApprovalPromptEQ.\nfunc ForceApprovalPrompt(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldForceApprovalPrompt), v))\n\t})\n}\n\n// LoggedIn applies equality check predicate on the \"logged_in\" field. It's identical to LoggedInEQ.\nfunc LoggedIn(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldLoggedIn), v))\n\t})\n}\n\n// ClaimsUserID applies equality check predicate on the \"claims_user_id\" field. It's identical to ClaimsUserIDEQ.\nfunc ClaimsUserID(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUsername applies equality check predicate on the \"claims_username\" field. It's identical to ClaimsUsernameEQ.\nfunc ClaimsUsername(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsEmail applies equality check predicate on the \"claims_email\" field. It's identical to ClaimsEmailEQ.\nfunc ClaimsEmail(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailVerified applies equality check predicate on the \"claims_email_verified\" field. It's identical to ClaimsEmailVerifiedEQ.\nfunc ClaimsEmailVerified(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmailVerified), v))\n\t})\n}\n\n// ClaimsPreferredUsername applies equality check predicate on the \"claims_preferred_username\" field. It's identical to ClaimsPreferredUsernameEQ.\nfunc ClaimsPreferredUsername(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ConnectorID applies equality check predicate on the \"connector_id\" field. It's identical to ConnectorIDEQ.\nfunc ConnectorID(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorData applies equality check predicate on the \"connector_data\" field. It's identical to ConnectorDataEQ.\nfunc ConnectorData(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorData), v))\n\t})\n}\n\n// Expiry applies equality check predicate on the \"expiry\" field. It's identical to ExpiryEQ.\nfunc Expiry(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldExpiry), v))\n\t})\n}\n\n// CodeChallenge applies equality check predicate on the \"code_challenge\" field. It's identical to CodeChallengeEQ.\nfunc CodeChallenge(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeMethod applies equality check predicate on the \"code_challenge_method\" field. It's identical to CodeChallengeMethodEQ.\nfunc CodeChallengeMethod(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// ClientIDEQ applies the EQ predicate on the \"client_id\" field.\nfunc ClientIDEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDNEQ applies the NEQ predicate on the \"client_id\" field.\nfunc ClientIDNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDIn applies the In predicate on the \"client_id\" field.\nfunc ClientIDIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClientID), v...))\n\t})\n}\n\n// ClientIDNotIn applies the NotIn predicate on the \"client_id\" field.\nfunc ClientIDNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClientID), v...))\n\t})\n}\n\n// ClientIDGT applies the GT predicate on the \"client_id\" field.\nfunc ClientIDGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDGTE applies the GTE predicate on the \"client_id\" field.\nfunc ClientIDGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDLT applies the LT predicate on the \"client_id\" field.\nfunc ClientIDLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDLTE applies the LTE predicate on the \"client_id\" field.\nfunc ClientIDLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDContains applies the Contains predicate on the \"client_id\" field.\nfunc ClientIDContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDHasPrefix applies the HasPrefix predicate on the \"client_id\" field.\nfunc ClientIDHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDHasSuffix applies the HasSuffix predicate on the \"client_id\" field.\nfunc ClientIDHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDEqualFold applies the EqualFold predicate on the \"client_id\" field.\nfunc ClientIDEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDContainsFold applies the ContainsFold predicate on the \"client_id\" field.\nfunc ClientIDContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClientID), v))\n\t})\n}\n\n// ScopesIsNil applies the IsNil predicate on the \"scopes\" field.\nfunc ScopesIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldScopes)))\n\t})\n}\n\n// ScopesNotNil applies the NotNil predicate on the \"scopes\" field.\nfunc ScopesNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldScopes)))\n\t})\n}\n\n// ResponseTypesIsNil applies the IsNil predicate on the \"response_types\" field.\nfunc ResponseTypesIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldResponseTypes)))\n\t})\n}\n\n// ResponseTypesNotNil applies the NotNil predicate on the \"response_types\" field.\nfunc ResponseTypesNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldResponseTypes)))\n\t})\n}\n\n// RedirectURIEQ applies the EQ predicate on the \"redirect_uri\" field.\nfunc RedirectURIEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURINEQ applies the NEQ predicate on the \"redirect_uri\" field.\nfunc RedirectURINEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIIn applies the In predicate on the \"redirect_uri\" field.\nfunc RedirectURIIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldRedirectURI), v...))\n\t})\n}\n\n// RedirectURINotIn applies the NotIn predicate on the \"redirect_uri\" field.\nfunc RedirectURINotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldRedirectURI), v...))\n\t})\n}\n\n// RedirectURIGT applies the GT predicate on the \"redirect_uri\" field.\nfunc RedirectURIGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIGTE applies the GTE predicate on the \"redirect_uri\" field.\nfunc RedirectURIGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURILT applies the LT predicate on the \"redirect_uri\" field.\nfunc RedirectURILT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURILTE applies the LTE predicate on the \"redirect_uri\" field.\nfunc RedirectURILTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIContains applies the Contains predicate on the \"redirect_uri\" field.\nfunc RedirectURIContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIHasPrefix applies the HasPrefix predicate on the \"redirect_uri\" field.\nfunc RedirectURIHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIHasSuffix applies the HasSuffix predicate on the \"redirect_uri\" field.\nfunc RedirectURIHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIEqualFold applies the EqualFold predicate on the \"redirect_uri\" field.\nfunc RedirectURIEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIContainsFold applies the ContainsFold predicate on the \"redirect_uri\" field.\nfunc RedirectURIContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// NonceEQ applies the EQ predicate on the \"nonce\" field.\nfunc NonceEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceNEQ applies the NEQ predicate on the \"nonce\" field.\nfunc NonceNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceIn applies the In predicate on the \"nonce\" field.\nfunc NonceIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldNonce), v...))\n\t})\n}\n\n// NonceNotIn applies the NotIn predicate on the \"nonce\" field.\nfunc NonceNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldNonce), v...))\n\t})\n}\n\n// NonceGT applies the GT predicate on the \"nonce\" field.\nfunc NonceGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceGTE applies the GTE predicate on the \"nonce\" field.\nfunc NonceGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceLT applies the LT predicate on the \"nonce\" field.\nfunc NonceLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceLTE applies the LTE predicate on the \"nonce\" field.\nfunc NonceLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceContains applies the Contains predicate on the \"nonce\" field.\nfunc NonceContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceHasPrefix applies the HasPrefix predicate on the \"nonce\" field.\nfunc NonceHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceHasSuffix applies the HasSuffix predicate on the \"nonce\" field.\nfunc NonceHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceEqualFold applies the EqualFold predicate on the \"nonce\" field.\nfunc NonceEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceContainsFold applies the ContainsFold predicate on the \"nonce\" field.\nfunc NonceContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldNonce), v))\n\t})\n}\n\n// StateEQ applies the EQ predicate on the \"state\" field.\nfunc StateEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldState), v))\n\t})\n}\n\n// StateNEQ applies the NEQ predicate on the \"state\" field.\nfunc StateNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldState), v))\n\t})\n}\n\n// StateIn applies the In predicate on the \"state\" field.\nfunc StateIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldState), v...))\n\t})\n}\n\n// StateNotIn applies the NotIn predicate on the \"state\" field.\nfunc StateNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldState), v...))\n\t})\n}\n\n// StateGT applies the GT predicate on the \"state\" field.\nfunc StateGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldState), v))\n\t})\n}\n\n// StateGTE applies the GTE predicate on the \"state\" field.\nfunc StateGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldState), v))\n\t})\n}\n\n// StateLT applies the LT predicate on the \"state\" field.\nfunc StateLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldState), v))\n\t})\n}\n\n// StateLTE applies the LTE predicate on the \"state\" field.\nfunc StateLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldState), v))\n\t})\n}\n\n// StateContains applies the Contains predicate on the \"state\" field.\nfunc StateContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldState), v))\n\t})\n}\n\n// StateHasPrefix applies the HasPrefix predicate on the \"state\" field.\nfunc StateHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldState), v))\n\t})\n}\n\n// StateHasSuffix applies the HasSuffix predicate on the \"state\" field.\nfunc StateHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldState), v))\n\t})\n}\n\n// StateEqualFold applies the EqualFold predicate on the \"state\" field.\nfunc StateEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldState), v))\n\t})\n}\n\n// StateContainsFold applies the ContainsFold predicate on the \"state\" field.\nfunc StateContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldState), v))\n\t})\n}\n\n// ForceApprovalPromptEQ applies the EQ predicate on the \"force_approval_prompt\" field.\nfunc ForceApprovalPromptEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldForceApprovalPrompt), v))\n\t})\n}\n\n// ForceApprovalPromptNEQ applies the NEQ predicate on the \"force_approval_prompt\" field.\nfunc ForceApprovalPromptNEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldForceApprovalPrompt), v))\n\t})\n}\n\n// LoggedInEQ applies the EQ predicate on the \"logged_in\" field.\nfunc LoggedInEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldLoggedIn), v))\n\t})\n}\n\n// LoggedInNEQ applies the NEQ predicate on the \"logged_in\" field.\nfunc LoggedInNEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldLoggedIn), v))\n\t})\n}\n\n// ClaimsUserIDEQ applies the EQ predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDNEQ applies the NEQ predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDIn applies the In predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsUserID), v...))\n\t})\n}\n\n// ClaimsUserIDNotIn applies the NotIn predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsUserID), v...))\n\t})\n}\n\n// ClaimsUserIDGT applies the GT predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDGTE applies the GTE predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDLT applies the LT predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDLTE applies the LTE predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDContains applies the Contains predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDHasPrefix applies the HasPrefix predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDHasSuffix applies the HasSuffix predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDEqualFold applies the EqualFold predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDContainsFold applies the ContainsFold predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUsernameEQ applies the EQ predicate on the \"claims_username\" field.\nfunc ClaimsUsernameEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameNEQ applies the NEQ predicate on the \"claims_username\" field.\nfunc ClaimsUsernameNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameIn applies the In predicate on the \"claims_username\" field.\nfunc ClaimsUsernameIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsUsername), v...))\n\t})\n}\n\n// ClaimsUsernameNotIn applies the NotIn predicate on the \"claims_username\" field.\nfunc ClaimsUsernameNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsUsername), v...))\n\t})\n}\n\n// ClaimsUsernameGT applies the GT predicate on the \"claims_username\" field.\nfunc ClaimsUsernameGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameGTE applies the GTE predicate on the \"claims_username\" field.\nfunc ClaimsUsernameGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameLT applies the LT predicate on the \"claims_username\" field.\nfunc ClaimsUsernameLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameLTE applies the LTE predicate on the \"claims_username\" field.\nfunc ClaimsUsernameLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameContains applies the Contains predicate on the \"claims_username\" field.\nfunc ClaimsUsernameContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameHasPrefix applies the HasPrefix predicate on the \"claims_username\" field.\nfunc ClaimsUsernameHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameHasSuffix applies the HasSuffix predicate on the \"claims_username\" field.\nfunc ClaimsUsernameHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameEqualFold applies the EqualFold predicate on the \"claims_username\" field.\nfunc ClaimsUsernameEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameContainsFold applies the ContainsFold predicate on the \"claims_username\" field.\nfunc ClaimsUsernameContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsEmailEQ applies the EQ predicate on the \"claims_email\" field.\nfunc ClaimsEmailEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailNEQ applies the NEQ predicate on the \"claims_email\" field.\nfunc ClaimsEmailNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailIn applies the In predicate on the \"claims_email\" field.\nfunc ClaimsEmailIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsEmail), v...))\n\t})\n}\n\n// ClaimsEmailNotIn applies the NotIn predicate on the \"claims_email\" field.\nfunc ClaimsEmailNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsEmail), v...))\n\t})\n}\n\n// ClaimsEmailGT applies the GT predicate on the \"claims_email\" field.\nfunc ClaimsEmailGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailGTE applies the GTE predicate on the \"claims_email\" field.\nfunc ClaimsEmailGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailLT applies the LT predicate on the \"claims_email\" field.\nfunc ClaimsEmailLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailLTE applies the LTE predicate on the \"claims_email\" field.\nfunc ClaimsEmailLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailContains applies the Contains predicate on the \"claims_email\" field.\nfunc ClaimsEmailContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailHasPrefix applies the HasPrefix predicate on the \"claims_email\" field.\nfunc ClaimsEmailHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailHasSuffix applies the HasSuffix predicate on the \"claims_email\" field.\nfunc ClaimsEmailHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailEqualFold applies the EqualFold predicate on the \"claims_email\" field.\nfunc ClaimsEmailEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailContainsFold applies the ContainsFold predicate on the \"claims_email\" field.\nfunc ClaimsEmailContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailVerifiedEQ applies the EQ predicate on the \"claims_email_verified\" field.\nfunc ClaimsEmailVerifiedEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmailVerified), v))\n\t})\n}\n\n// ClaimsEmailVerifiedNEQ applies the NEQ predicate on the \"claims_email_verified\" field.\nfunc ClaimsEmailVerifiedNEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsEmailVerified), v))\n\t})\n}\n\n// ClaimsGroupsIsNil applies the IsNil predicate on the \"claims_groups\" field.\nfunc ClaimsGroupsIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldClaimsGroups)))\n\t})\n}\n\n// ClaimsGroupsNotNil applies the NotNil predicate on the \"claims_groups\" field.\nfunc ClaimsGroupsNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldClaimsGroups)))\n\t})\n}\n\n// ClaimsPreferredUsernameEQ applies the EQ predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameNEQ applies the NEQ predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameIn applies the In predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsPreferredUsername), v...))\n\t})\n}\n\n// ClaimsPreferredUsernameNotIn applies the NotIn predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsPreferredUsername), v...))\n\t})\n}\n\n// ClaimsPreferredUsernameGT applies the GT predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameGTE applies the GTE predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameLT applies the LT predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameLTE applies the LTE predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameContains applies the Contains predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameHasPrefix applies the HasPrefix predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameHasSuffix applies the HasSuffix predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameEqualFold applies the EqualFold predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameContainsFold applies the ContainsFold predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ConnectorIDEQ applies the EQ predicate on the \"connector_id\" field.\nfunc ConnectorIDEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDNEQ applies the NEQ predicate on the \"connector_id\" field.\nfunc ConnectorIDNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDIn applies the In predicate on the \"connector_id\" field.\nfunc ConnectorIDIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldConnectorID), v...))\n\t})\n}\n\n// ConnectorIDNotIn applies the NotIn predicate on the \"connector_id\" field.\nfunc ConnectorIDNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldConnectorID), v...))\n\t})\n}\n\n// ConnectorIDGT applies the GT predicate on the \"connector_id\" field.\nfunc ConnectorIDGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDGTE applies the GTE predicate on the \"connector_id\" field.\nfunc ConnectorIDGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDLT applies the LT predicate on the \"connector_id\" field.\nfunc ConnectorIDLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDLTE applies the LTE predicate on the \"connector_id\" field.\nfunc ConnectorIDLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDContains applies the Contains predicate on the \"connector_id\" field.\nfunc ConnectorIDContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDHasPrefix applies the HasPrefix predicate on the \"connector_id\" field.\nfunc ConnectorIDHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDHasSuffix applies the HasSuffix predicate on the \"connector_id\" field.\nfunc ConnectorIDHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDEqualFold applies the EqualFold predicate on the \"connector_id\" field.\nfunc ConnectorIDEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDContainsFold applies the ContainsFold predicate on the \"connector_id\" field.\nfunc ConnectorIDContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorDataEQ applies the EQ predicate on the \"connector_data\" field.\nfunc ConnectorDataEQ(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataNEQ applies the NEQ predicate on the \"connector_data\" field.\nfunc ConnectorDataNEQ(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataIn applies the In predicate on the \"connector_data\" field.\nfunc ConnectorDataIn(vs ...[]byte) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldConnectorData), v...))\n\t})\n}\n\n// ConnectorDataNotIn applies the NotIn predicate on the \"connector_data\" field.\nfunc ConnectorDataNotIn(vs ...[]byte) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldConnectorData), v...))\n\t})\n}\n\n// ConnectorDataGT applies the GT predicate on the \"connector_data\" field.\nfunc ConnectorDataGT(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataGTE applies the GTE predicate on the \"connector_data\" field.\nfunc ConnectorDataGTE(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataLT applies the LT predicate on the \"connector_data\" field.\nfunc ConnectorDataLT(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataLTE applies the LTE predicate on the \"connector_data\" field.\nfunc ConnectorDataLTE(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataIsNil applies the IsNil predicate on the \"connector_data\" field.\nfunc ConnectorDataIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldConnectorData)))\n\t})\n}\n\n// ConnectorDataNotNil applies the NotNil predicate on the \"connector_data\" field.\nfunc ConnectorDataNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldConnectorData)))\n\t})\n}\n\n// ExpiryEQ applies the EQ predicate on the \"expiry\" field.\nfunc ExpiryEQ(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryNEQ applies the NEQ predicate on the \"expiry\" field.\nfunc ExpiryNEQ(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryIn applies the In predicate on the \"expiry\" field.\nfunc ExpiryIn(vs ...time.Time) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldExpiry), v...))\n\t})\n}\n\n// ExpiryNotIn applies the NotIn predicate on the \"expiry\" field.\nfunc ExpiryNotIn(vs ...time.Time) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldExpiry), v...))\n\t})\n}\n\n// ExpiryGT applies the GT predicate on the \"expiry\" field.\nfunc ExpiryGT(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryGTE applies the GTE predicate on the \"expiry\" field.\nfunc ExpiryGTE(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryLT applies the LT predicate on the \"expiry\" field.\nfunc ExpiryLT(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryLTE applies the LTE predicate on the \"expiry\" field.\nfunc ExpiryLTE(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldExpiry), v))\n\t})\n}\n\n// CodeChallengeEQ applies the EQ predicate on the \"code_challenge\" field.\nfunc CodeChallengeEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeNEQ applies the NEQ predicate on the \"code_challenge\" field.\nfunc CodeChallengeNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeIn applies the In predicate on the \"code_challenge\" field.\nfunc CodeChallengeIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldCodeChallenge), v...))\n\t})\n}\n\n// CodeChallengeNotIn applies the NotIn predicate on the \"code_challenge\" field.\nfunc CodeChallengeNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldCodeChallenge), v...))\n\t})\n}\n\n// CodeChallengeGT applies the GT predicate on the \"code_challenge\" field.\nfunc CodeChallengeGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeGTE applies the GTE predicate on the \"code_challenge\" field.\nfunc CodeChallengeGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeLT applies the LT predicate on the \"code_challenge\" field.\nfunc CodeChallengeLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeLTE applies the LTE predicate on the \"code_challenge\" field.\nfunc CodeChallengeLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeContains applies the Contains predicate on the \"code_challenge\" field.\nfunc CodeChallengeContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeHasPrefix applies the HasPrefix predicate on the \"code_challenge\" field.\nfunc CodeChallengeHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeHasSuffix applies the HasSuffix predicate on the \"code_challenge\" field.\nfunc CodeChallengeHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeEqualFold applies the EqualFold predicate on the \"code_challenge\" field.\nfunc CodeChallengeEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeContainsFold applies the ContainsFold predicate on the \"code_challenge\" field.\nfunc CodeChallengeContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeMethodEQ applies the EQ predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodNEQ applies the NEQ predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodIn applies the In predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldCodeChallengeMethod), v...))\n\t})\n}\n\n// CodeChallengeMethodNotIn applies the NotIn predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldCodeChallengeMethod), v...))\n\t})\n}\n\n// CodeChallengeMethodGT applies the GT predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodGTE applies the GTE predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodLT applies the LT predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodLTE applies the LTE predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodContains applies the Contains predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodHasPrefix applies the HasPrefix predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodHasSuffix applies the HasSuffix predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodEqualFold applies the EqualFold predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodContainsFold applies the ContainsFold predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// And groups predicates with the AND operator between them.\nfunc And(predicates ...predicate.AuthRequest) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts1 := s.Clone().SetP(nil)\n\t\tfor _, p := range predicates {\n\t\t\tp(s1)\n\t\t}\n\t\ts.Where(s1.P())\n\t})\n}\n\n// Or groups predicates with the OR operator between them.\nfunc Or(predicates ...predicate.AuthRequest) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts1 := s.Clone().SetP(nil)\n\t\tfor i, p := range predicates {\n\t\t\tif i > 0 {\n\t\t\t\ts1.Or()\n\t\t\t}\n\t\t\tp(s1)\n\t\t}\n\t\ts.Where(s1.P())\n\t})\n}\n\n// Not applies the not operator on the given predicate.\nfunc Not(p predicate.AuthRequest) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\tp(s.Not())\n\t})\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql/sqlgraph\"\n\t\"entgo.io/ent/schema/field\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n)\n\n// AuthRequestCreate is the builder for creating a AuthRequest entity.\ntype AuthRequestCreate struct {\n\tconfig\n\tmutation *AuthRequestMutation\n\thooks    []Hook\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (arc *AuthRequestCreate) SetClientID(s string) *AuthRequestCreate {\n\tarc.mutation.SetClientID(s)\n\treturn arc\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (arc *AuthRequestCreate) SetScopes(s []string) *AuthRequestCreate {\n\tarc.mutation.SetScopes(s)\n\treturn arc\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (arc *AuthRequestCreate) SetResponseTypes(s []string) *AuthRequestCreate {\n\tarc.mutation.SetResponseTypes(s)\n\treturn arc\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (arc *AuthRequestCreate) SetRedirectURI(s string) *AuthRequestCreate {\n\tarc.mutation.SetRedirectURI(s)\n\treturn arc\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (arc *AuthRequestCreate) SetNonce(s string) *AuthRequestCreate {\n\tarc.mutation.SetNonce(s)\n\treturn arc\n}\n\n// SetState sets the \"state\" field.\nfunc (arc *AuthRequestCreate) SetState(s string) *AuthRequestCreate {\n\tarc.mutation.SetState(s)\n\treturn arc\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (arc *AuthRequestCreate) SetForceApprovalPrompt(b bool) *AuthRequestCreate {\n\tarc.mutation.SetForceApprovalPrompt(b)\n\treturn arc\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (arc *AuthRequestCreate) SetLoggedIn(b bool) *AuthRequestCreate {\n\tarc.mutation.SetLoggedIn(b)\n\treturn arc\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (arc *AuthRequestCreate) SetClaimsUserID(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsUserID(s)\n\treturn arc\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (arc *AuthRequestCreate) SetClaimsUsername(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsUsername(s)\n\treturn arc\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (arc *AuthRequestCreate) SetClaimsEmail(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsEmail(s)\n\treturn arc\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (arc *AuthRequestCreate) SetClaimsEmailVerified(b bool) *AuthRequestCreate {\n\tarc.mutation.SetClaimsEmailVerified(b)\n\treturn arc\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (arc *AuthRequestCreate) SetClaimsGroups(s []string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsGroups(s)\n\treturn arc\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (arc *AuthRequestCreate) SetClaimsPreferredUsername(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsPreferredUsername(s)\n\treturn arc\n}\n\n// SetNillableClaimsPreferredUsername sets the \"claims_preferred_username\" field if the given value is not nil.\nfunc (arc *AuthRequestCreate) SetNillableClaimsPreferredUsername(s *string) *AuthRequestCreate {\n\tif s != nil {\n\t\tarc.SetClaimsPreferredUsername(*s)\n\t}\n\treturn arc\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (arc *AuthRequestCreate) SetConnectorID(s string) *AuthRequestCreate {\n\tarc.mutation.SetConnectorID(s)\n\treturn arc\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (arc *AuthRequestCreate) SetConnectorData(b []byte) *AuthRequestCreate {\n\tarc.mutation.SetConnectorData(b)\n\treturn arc\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (arc *AuthRequestCreate) SetExpiry(t time.Time) *AuthRequestCreate {\n\tarc.mutation.SetExpiry(t)\n\treturn arc\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (arc *AuthRequestCreate) SetCodeChallenge(s string) *AuthRequestCreate {\n\tarc.mutation.SetCodeChallenge(s)\n\treturn arc\n}\n\n// SetNillableCodeChallenge sets the \"code_challenge\" field if the given value is not nil.\nfunc (arc *AuthRequestCreate) SetNillableCodeChallenge(s *string) *AuthRequestCreate {\n\tif s != nil {\n\t\tarc.SetCodeChallenge(*s)\n\t}\n\treturn arc\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (arc *AuthRequestCreate) SetCodeChallengeMethod(s string) *AuthRequestCreate {\n\tarc.mutation.SetCodeChallengeMethod(s)\n\treturn arc\n}\n\n// SetNillableCodeChallengeMethod sets the \"code_challenge_method\" field if the given value is not nil.\nfunc (arc *AuthRequestCreate) SetNillableCodeChallengeMethod(s *string) *AuthRequestCreate {\n\tif s != nil {\n\t\tarc.SetCodeChallengeMethod(*s)\n\t}\n\treturn arc\n}\n\n// SetID sets the \"id\" field.\nfunc (arc *AuthRequestCreate) SetID(s string) *AuthRequestCreate {\n\tarc.mutation.SetID(s)\n\treturn arc\n}\n\n// Mutation returns the AuthRequestMutation object of the builder.\nfunc (arc *AuthRequestCreate) Mutation() *AuthRequestMutation {\n\treturn arc.mutation\n}\n\n// Save creates the AuthRequest in the database.\nfunc (arc *AuthRequestCreate) Save(ctx context.Context) (*AuthRequest, error) {\n\tvar (\n\t\terr  error\n\t\tnode *AuthRequest\n\t)\n\tarc.defaults()\n\tif len(arc.hooks) == 0 {\n\t\tif err = arc.check(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnode, err = arc.sqlSave(ctx)\n\t} else {\n\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t}\n\t\t\tif err = arc.check(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tarc.mutation = mutation\n\t\t\tif node, err = arc.sqlSave(ctx); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmutation.id = &node.ID\n\t\t\tmutation.done = true\n\t\t\treturn node, err\n\t\t})\n\t\tfor i := len(arc.hooks) - 1; i >= 0; i-- {\n\t\t\tif arc.hooks[i] == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"db: uninitialized hook (forgotten import db/runtime?)\")\n\t\t\t}\n\t\t\tmut = arc.hooks[i](mut)\n\t\t}\n\t\tv, err := mut.Mutate(ctx, arc.mutation)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnv, ok := v.(*AuthRequest)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected node type %T returned from AuthRequestMutation\", v)\n\t\t}\n\t\tnode = nv\n\t}\n\treturn node, err\n}\n\n// SaveX calls Save and panics if Save returns an error.\nfunc (arc *AuthRequestCreate) SaveX(ctx context.Context) *AuthRequest {\n\tv, err := arc.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}\n\n// Exec executes the query.\nfunc (arc *AuthRequestCreate) Exec(ctx context.Context) error {\n\t_, err := arc.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (arc *AuthRequestCreate) ExecX(ctx context.Context) {\n\tif err := arc.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// defaults sets the default values of the builder before save.\nfunc (arc *AuthRequestCreate) defaults() {\n\tif _, ok := arc.mutation.ClaimsPreferredUsername(); !ok {\n\t\tv := authrequest.DefaultClaimsPreferredUsername\n\t\tarc.mutation.SetClaimsPreferredUsername(v)\n\t}\n\tif _, ok := arc.mutation.CodeChallenge(); !ok {\n\t\tv := authrequest.DefaultCodeChallenge\n\t\tarc.mutation.SetCodeChallenge(v)\n\t}\n\tif _, ok := arc.mutation.CodeChallengeMethod(); !ok {\n\t\tv := authrequest.DefaultCodeChallengeMethod\n\t\tarc.mutation.SetCodeChallengeMethod(v)\n\t}\n}\n\n// check runs all checks and user-defined validators on the builder.\nfunc (arc *AuthRequestCreate) check() error {\n\tif _, ok := arc.mutation.ClientID(); !ok {\n\t\treturn &ValidationError{Name: \"client_id\", err: errors.New(`db: missing required field \"AuthRequest.client_id\"`)}\n\t}\n\tif _, ok := arc.mutation.RedirectURI(); !ok {\n\t\treturn &ValidationError{Name: \"redirect_uri\", err: errors.New(`db: missing required field \"AuthRequest.redirect_uri\"`)}\n\t}\n\tif _, ok := arc.mutation.Nonce(); !ok {\n\t\treturn &ValidationError{Name: \"nonce\", err: errors.New(`db: missing required field \"AuthRequest.nonce\"`)}\n\t}\n\tif _, ok := arc.mutation.State(); !ok {\n\t\treturn &ValidationError{Name: \"state\", err: errors.New(`db: missing required field \"AuthRequest.state\"`)}\n\t}\n\tif _, ok := arc.mutation.ForceApprovalPrompt(); !ok {\n\t\treturn &ValidationError{Name: \"force_approval_prompt\", err: errors.New(`db: missing required field \"AuthRequest.force_approval_prompt\"`)}\n\t}\n\tif _, ok := arc.mutation.LoggedIn(); !ok {\n\t\treturn &ValidationError{Name: \"logged_in\", err: errors.New(`db: missing required field \"AuthRequest.logged_in\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsUserID(); !ok {\n\t\treturn &ValidationError{Name: \"claims_user_id\", err: errors.New(`db: missing required field \"AuthRequest.claims_user_id\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsUsername(); !ok {\n\t\treturn &ValidationError{Name: \"claims_username\", err: errors.New(`db: missing required field \"AuthRequest.claims_username\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsEmail(); !ok {\n\t\treturn &ValidationError{Name: \"claims_email\", err: errors.New(`db: missing required field \"AuthRequest.claims_email\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsEmailVerified(); !ok {\n\t\treturn &ValidationError{Name: \"claims_email_verified\", err: errors.New(`db: missing required field \"AuthRequest.claims_email_verified\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsPreferredUsername(); !ok {\n\t\treturn &ValidationError{Name: \"claims_preferred_username\", err: errors.New(`db: missing required field \"AuthRequest.claims_preferred_username\"`)}\n\t}\n\tif _, ok := arc.mutation.ConnectorID(); !ok {\n\t\treturn &ValidationError{Name: \"connector_id\", err: errors.New(`db: missing required field \"AuthRequest.connector_id\"`)}\n\t}\n\tif _, ok := arc.mutation.Expiry(); !ok {\n\t\treturn &ValidationError{Name: \"expiry\", err: errors.New(`db: missing required field \"AuthRequest.expiry\"`)}\n\t}\n\tif _, ok := arc.mutation.CodeChallenge(); !ok {\n\t\treturn &ValidationError{Name: \"code_challenge\", err: errors.New(`db: missing required field \"AuthRequest.code_challenge\"`)}\n\t}\n\tif _, ok := arc.mutation.CodeChallengeMethod(); !ok {\n\t\treturn &ValidationError{Name: \"code_challenge_method\", err: errors.New(`db: missing required field \"AuthRequest.code_challenge_method\"`)}\n\t}\n\tif v, ok := arc.mutation.ID(); ok {\n\t\tif err := authrequest.IDValidator(v); err != nil {\n\t\t\treturn &ValidationError{Name: \"id\", err: fmt.Errorf(`db: validator failed for field \"AuthRequest.id\": %w`, err)}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (arc *AuthRequestCreate) sqlSave(ctx context.Context) (*AuthRequest, error) {\n\t_node, _spec := arc.createSpec()\n\tif err := sqlgraph.CreateNode(ctx, arc.driver, _spec); err != nil {\n\t\tif sqlgraph.IsConstraintError(err) {\n\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t}\n\t\treturn nil, err\n\t}\n\tif _spec.ID.Value != nil {\n\t\tif id, ok := _spec.ID.Value.(string); ok {\n\t\t\t_node.ID = id\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"unexpected AuthRequest.ID type: %T\", _spec.ID.Value)\n\t\t}\n\t}\n\treturn _node, nil\n}\n\nfunc (arc *AuthRequestCreate) createSpec() (*AuthRequest, *sqlgraph.CreateSpec) {\n\tvar (\n\t\t_node = &AuthRequest{config: arc.config}\n\t\t_spec = &sqlgraph.CreateSpec{\n\t\t\tTable: authrequest.Table,\n\t\t\tID: &sqlgraph.FieldSpec{\n\t\t\t\tType:   field.TypeString,\n\t\t\t\tColumn: authrequest.FieldID,\n\t\t\t},\n\t\t}\n\t)\n\tif id, ok := arc.mutation.ID(); ok {\n\t\t_node.ID = id\n\t\t_spec.ID.Value = id\n\t}\n\tif value, ok := arc.mutation.ClientID(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClientID,\n\t\t})\n\t\t_node.ClientID = value\n\t}\n\tif value, ok := arc.mutation.Scopes(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t\t_node.Scopes = value\n\t}\n\tif value, ok := arc.mutation.ResponseTypes(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t\t_node.ResponseTypes = value\n\t}\n\tif value, ok := arc.mutation.RedirectURI(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldRedirectURI,\n\t\t})\n\t\t_node.RedirectURI = value\n\t}\n\tif value, ok := arc.mutation.Nonce(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldNonce,\n\t\t})\n\t\t_node.Nonce = value\n\t}\n\tif value, ok := arc.mutation.State(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldState,\n\t\t})\n\t\t_node.State = value\n\t}\n\tif value, ok := arc.mutation.ForceApprovalPrompt(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldForceApprovalPrompt,\n\t\t})\n\t\t_node.ForceApprovalPrompt = value\n\t}\n\tif value, ok := arc.mutation.LoggedIn(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldLoggedIn,\n\t\t})\n\t\t_node.LoggedIn = value\n\t}\n\tif value, ok := arc.mutation.ClaimsUserID(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUserID,\n\t\t})\n\t\t_node.ClaimsUserID = value\n\t}\n\tif value, ok := arc.mutation.ClaimsUsername(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUsername,\n\t\t})\n\t\t_node.ClaimsUsername = value\n\t}\n\tif value, ok := arc.mutation.ClaimsEmail(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmail,\n\t\t})\n\t\t_node.ClaimsEmail = value\n\t}\n\tif value, ok := arc.mutation.ClaimsEmailVerified(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmailVerified,\n\t\t})\n\t\t_node.ClaimsEmailVerified = value\n\t}\n\tif value, ok := arc.mutation.ClaimsGroups(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t\t_node.ClaimsGroups = value\n\t}\n\tif value, ok := arc.mutation.ClaimsPreferredUsername(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsPreferredUsername,\n\t\t})\n\t\t_node.ClaimsPreferredUsername = value\n\t}\n\tif value, ok := arc.mutation.ConnectorID(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorID,\n\t\t})\n\t\t_node.ConnectorID = value\n\t}\n\tif value, ok := arc.mutation.ConnectorData(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t\t_node.ConnectorData = &value\n\t}\n\tif value, ok := arc.mutation.Expiry(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeTime,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldExpiry,\n\t\t})\n\t\t_node.Expiry = value\n\t}\n\tif value, ok := arc.mutation.CodeChallenge(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallenge,\n\t\t})\n\t\t_node.CodeChallenge = value\n\t}\n\tif value, ok := arc.mutation.CodeChallengeMethod(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallengeMethod,\n\t\t})\n\t\t_node.CodeChallengeMethod = value\n\t}\n\treturn _node, _spec\n}\n\n// AuthRequestCreateBulk is the builder for creating many AuthRequest entities in bulk.\ntype AuthRequestCreateBulk struct {\n\tconfig\n\tbuilders []*AuthRequestCreate\n}\n\n// Save creates the AuthRequest entities in the database.\nfunc (arcb *AuthRequestCreateBulk) Save(ctx context.Context) ([]*AuthRequest, error) {\n\tspecs := make([]*sqlgraph.CreateSpec, len(arcb.builders))\n\tnodes := make([]*AuthRequest, len(arcb.builders))\n\tmutators := make([]Mutator, len(arcb.builders))\n\tfor i := range arcb.builders {\n\t\tfunc(i int, root context.Context) {\n\t\t\tbuilder := arcb.builders[i]\n\t\t\tbuilder.defaults()\n\t\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t\t}\n\t\t\t\tif err := builder.check(); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tbuilder.mutation = mutation\n\t\t\t\tnodes[i], specs[i] = builder.createSpec()\n\t\t\t\tvar err error\n\t\t\t\tif i < len(mutators)-1 {\n\t\t\t\t\t_, err = mutators[i+1].Mutate(root, arcb.builders[i+1].mutation)\n\t\t\t\t} else {\n\t\t\t\t\tspec := &sqlgraph.BatchCreateSpec{Nodes: specs}\n\t\t\t\t\t// Invoke the actual operation on the latest mutation in the chain.\n\t\t\t\t\tif err = sqlgraph.BatchCreate(ctx, arcb.driver, spec); err != nil {\n\t\t\t\t\t\tif sqlgraph.IsConstraintError(err) {\n\t\t\t\t\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tmutation.id = &nodes[i].ID\n\t\t\t\tmutation.done = true\n\t\t\t\treturn nodes[i], nil\n\t\t\t})\n\t\t\tfor i := len(builder.hooks) - 1; i >= 0; i-- {\n\t\t\t\tmut = builder.hooks[i](mut)\n\t\t\t}\n\t\t\tmutators[i] = mut\n\t\t}(i, ctx)\n\t}\n\tif len(mutators) > 0 {\n\t\tif _, err := mutators[0].Mutate(ctx, arcb.builders[0].mutation); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nodes, nil\n}\n\n// SaveX is like Save, but panics if an error occurs.\nfunc (arcb *AuthRequestCreateBulk) SaveX(ctx context.Context) []*AuthRequest {\n\tv, err := arcb.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}\n\n// Exec executes the query.\nfunc (arcb *AuthRequestCreateBulk) Exec(ctx context.Context) error {\n\t_, err := arcb.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (arcb *AuthRequestCreateBulk) ExecX(ctx context.Context) {\n\tif err := arcb.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql\"\n\t\"entgo.io/ent/dialect/sql/sqlgraph\"\n\t\"entgo.io/ent/schema/field\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n\t\"github.com/dexidp/dex/storage/ent/db/predicate\"\n)\n\n// AuthRequestUpdate is the builder for updating AuthRequest entities.\ntype AuthRequestUpdate struct {\n\tconfig\n\thooks    []Hook\n\tmutation *AuthRequestMutation\n}\n\n// Where appends a list predicates to the AuthRequestUpdate builder.\nfunc (aru *AuthRequestUpdate) Where(ps ...predicate.AuthRequest) *AuthRequestUpdate {\n\taru.mutation.Where(ps...)\n\treturn aru\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (aru *AuthRequestUpdate) SetClientID(s string) *AuthRequestUpdate {\n\taru.mutation.SetClientID(s)\n\treturn aru\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (aru *AuthRequestUpdate) SetScopes(s []string) *AuthRequestUpdate {\n\taru.mutation.SetScopes(s)\n\treturn aru\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (aru *AuthRequestUpdate) ClearScopes() *AuthRequestUpdate {\n\taru.mutation.ClearScopes()\n\treturn aru\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (aru *AuthRequestUpdate) SetResponseTypes(s []string) *AuthRequestUpdate {\n\taru.mutation.SetResponseTypes(s)\n\treturn aru\n}\n\n// ClearResponseTypes clears the value of the \"response_types\" field.\nfunc (aru *AuthRequestUpdate) ClearResponseTypes() *AuthRequestUpdate {\n\taru.mutation.ClearResponseTypes()\n\treturn aru\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (aru *AuthRequestUpdate) SetRedirectURI(s string) *AuthRequestUpdate {\n\taru.mutation.SetRedirectURI(s)\n\treturn aru\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (aru *AuthRequestUpdate) SetNonce(s string) *AuthRequestUpdate {\n\taru.mutation.SetNonce(s)\n\treturn aru\n}\n\n// SetState sets the \"state\" field.\nfunc (aru *AuthRequestUpdate) SetState(s string) *AuthRequestUpdate {\n\taru.mutation.SetState(s)\n\treturn aru\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (aru *AuthRequestUpdate) SetForceApprovalPrompt(b bool) *AuthRequestUpdate {\n\taru.mutation.SetForceApprovalPrompt(b)\n\treturn aru\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (aru *AuthRequestUpdate) SetLoggedIn(b bool) *AuthRequestUpdate {\n\taru.mutation.SetLoggedIn(b)\n\treturn aru\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsUserID(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsUserID(s)\n\treturn aru\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsUsername(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsUsername(s)\n\treturn aru\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsEmail(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsEmail(s)\n\treturn aru\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsEmailVerified(b bool) *AuthRequestUpdate {\n\taru.mutation.SetClaimsEmailVerified(b)\n\treturn aru\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsGroups(s []string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsGroups(s)\n\treturn aru\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (aru *AuthRequestUpdate) ClearClaimsGroups() *AuthRequestUpdate {\n\taru.mutation.ClearClaimsGroups()\n\treturn aru\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsPreferredUsername(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsPreferredUsername(s)\n\treturn aru\n}\n\n// SetNillableClaimsPreferredUsername sets the \"claims_preferred_username\" field if the given value is not nil.\nfunc (aru *AuthRequestUpdate) SetNillableClaimsPreferredUsername(s *string) *AuthRequestUpdate {\n\tif s != nil {\n\t\taru.SetClaimsPreferredUsername(*s)\n\t}\n\treturn aru\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (aru *AuthRequestUpdate) SetConnectorID(s string) *AuthRequestUpdate {\n\taru.mutation.SetConnectorID(s)\n\treturn aru\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (aru *AuthRequestUpdate) SetConnectorData(b []byte) *AuthRequestUpdate {\n\taru.mutation.SetConnectorData(b)\n\treturn aru\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (aru *AuthRequestUpdate) ClearConnectorData() *AuthRequestUpdate {\n\taru.mutation.ClearConnectorData()\n\treturn aru\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (aru *AuthRequestUpdate) SetExpiry(t time.Time) *AuthRequestUpdate {\n\taru.mutation.SetExpiry(t)\n\treturn aru\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (aru *AuthRequestUpdate) SetCodeChallenge(s string) *AuthRequestUpdate {\n\taru.mutation.SetCodeChallenge(s)\n\treturn aru\n}\n\n// SetNillableCodeChallenge sets the \"code_challenge\" field if the given value is not nil.\nfunc (aru *AuthRequestUpdate) SetNillableCodeChallenge(s *string) *AuthRequestUpdate {\n\tif s != nil {\n\t\taru.SetCodeChallenge(*s)\n\t}\n\treturn aru\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (aru *AuthRequestUpdate) SetCodeChallengeMethod(s string) *AuthRequestUpdate {\n\taru.mutation.SetCodeChallengeMethod(s)\n\treturn aru\n}\n\n// SetNillableCodeChallengeMethod sets the \"code_challenge_method\" field if the given value is not nil.\nfunc (aru *AuthRequestUpdate) SetNillableCodeChallengeMethod(s *string) *AuthRequestUpdate {\n\tif s != nil {\n\t\taru.SetCodeChallengeMethod(*s)\n\t}\n\treturn aru\n}\n\n// Mutation returns the AuthRequestMutation object of the builder.\nfunc (aru *AuthRequestUpdate) Mutation() *AuthRequestMutation {\n\treturn aru.mutation\n}\n\n// Save executes the query and returns the number of nodes affected by the update operation.\nfunc (aru *AuthRequestUpdate) Save(ctx context.Context) (int, error) {\n\tvar (\n\t\terr      error\n\t\taffected int\n\t)\n\tif len(aru.hooks) == 0 {\n\t\taffected, err = aru.sqlSave(ctx)\n\t} else {\n\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t}\n\t\t\taru.mutation = mutation\n\t\t\taffected, err = aru.sqlSave(ctx)\n\t\t\tmutation.done = true\n\t\t\treturn affected, err\n\t\t})\n\t\tfor i := len(aru.hooks) - 1; i >= 0; i-- {\n\t\t\tif aru.hooks[i] == nil {\n\t\t\t\treturn 0, fmt.Errorf(\"db: uninitialized hook (forgotten import db/runtime?)\")\n\t\t\t}\n\t\t\tmut = aru.hooks[i](mut)\n\t\t}\n\t\tif _, err := mut.Mutate(ctx, aru.mutation); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn affected, err\n}\n\n// SaveX is like Save, but panics if an error occurs.\nfunc (aru *AuthRequestUpdate) SaveX(ctx context.Context) int {\n\taffected, err := aru.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn affected\n}\n\n// Exec executes the query.\nfunc (aru *AuthRequestUpdate) Exec(ctx context.Context) error {\n\t_, err := aru.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (aru *AuthRequestUpdate) ExecX(ctx context.Context) {\n\tif err := aru.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (aru *AuthRequestUpdate) sqlSave(ctx context.Context) (n int, err error) {\n\t_spec := &sqlgraph.UpdateSpec{\n\t\tNode: &sqlgraph.NodeSpec{\n\t\t\tTable:   authrequest.Table,\n\t\t\tColumns: authrequest.Columns,\n\t\t\tID: &sqlgraph.FieldSpec{\n\t\t\t\tType:   field.TypeString,\n\t\t\t\tColumn: authrequest.FieldID,\n\t\t\t},\n\t\t},\n\t}\n\tif ps := aru.mutation.predicates; len(ps) > 0 {\n\t\t_spec.Predicate = func(selector *sql.Selector) {\n\t\t\tfor i := range ps {\n\t\t\t\tps[i](selector)\n\t\t\t}\n\t\t}\n\t}\n\tif value, ok := aru.mutation.ClientID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClientID,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.Scopes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif aru.mutation.ScopesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ResponseTypes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif aru.mutation.ResponseTypesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.RedirectURI(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldRedirectURI,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.Nonce(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldNonce,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.State(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldState,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ForceApprovalPrompt(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldForceApprovalPrompt,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.LoggedIn(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldLoggedIn,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsUserID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUserID,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUsername,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsEmail(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmail,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsEmailVerified(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmailVerified,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsGroups(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif aru.mutation.ClaimsGroupsCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsPreferredUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsPreferredUsername,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ConnectorID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorID,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ConnectorData(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif aru.mutation.ConnectorDataCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.Expiry(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeTime,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldExpiry,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.CodeChallenge(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallenge,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.CodeChallengeMethod(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallengeMethod,\n\t\t})\n\t}\n\tif n, err = sqlgraph.UpdateNodes(ctx, aru.driver, _spec); err != nil {\n\t\tif _, ok := err.(*sqlgraph.NotFoundError); ok {\n\t\t\terr = &NotFoundError{authrequest.Label}\n\t\t} else if sqlgraph.IsConstraintError(err) {\n\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn n, nil\n}\n\n// AuthRequestUpdateOne is the builder for updating a single AuthRequest entity.\ntype AuthRequestUpdateOne struct {\n\tconfig\n\tfields   []string\n\thooks    []Hook\n\tmutation *AuthRequestMutation\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClientID(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClientID(s)\n\treturn aruo\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (aruo *AuthRequestUpdateOne) SetScopes(s []string) *AuthRequestUpdateOne {\n\taruo.mutation.SetScopes(s)\n\treturn aruo\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearScopes() *AuthRequestUpdateOne {\n\taruo.mutation.ClearScopes()\n\treturn aruo\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (aruo *AuthRequestUpdateOne) SetResponseTypes(s []string) *AuthRequestUpdateOne {\n\taruo.mutation.SetResponseTypes(s)\n\treturn aruo\n}\n\n// ClearResponseTypes clears the value of the \"response_types\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearResponseTypes() *AuthRequestUpdateOne {\n\taruo.mutation.ClearResponseTypes()\n\treturn aruo\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (aruo *AuthRequestUpdateOne) SetRedirectURI(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetRedirectURI(s)\n\treturn aruo\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (aruo *AuthRequestUpdateOne) SetNonce(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetNonce(s)\n\treturn aruo\n}\n\n// SetState sets the \"state\" field.\nfunc (aruo *AuthRequestUpdateOne) SetState(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetState(s)\n\treturn aruo\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (aruo *AuthRequestUpdateOne) SetForceApprovalPrompt(b bool) *AuthRequestUpdateOne {\n\taruo.mutation.SetForceApprovalPrompt(b)\n\treturn aruo\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (aruo *AuthRequestUpdateOne) SetLoggedIn(b bool) *AuthRequestUpdateOne {\n\taruo.mutation.SetLoggedIn(b)\n\treturn aruo\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsUserID(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsUserID(s)\n\treturn aruo\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsUsername(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsUsername(s)\n\treturn aruo\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsEmail(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsEmail(s)\n\treturn aruo\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsEmailVerified(b bool) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsEmailVerified(b)\n\treturn aruo\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsGroups(s []string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsGroups(s)\n\treturn aruo\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearClaimsGroups() *AuthRequestUpdateOne {\n\taruo.mutation.ClearClaimsGroups()\n\treturn aruo\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsPreferredUsername(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsPreferredUsername(s)\n\treturn aruo\n}\n\n// SetNillableClaimsPreferredUsername sets the \"claims_preferred_username\" field if the given value is not nil.\nfunc (aruo *AuthRequestUpdateOne) SetNillableClaimsPreferredUsername(s *string) *AuthRequestUpdateOne {\n\tif s != nil {\n\t\taruo.SetClaimsPreferredUsername(*s)\n\t}\n\treturn aruo\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (aruo *AuthRequestUpdateOne) SetConnectorID(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetConnectorID(s)\n\treturn aruo\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (aruo *AuthRequestUpdateOne) SetConnectorData(b []byte) *AuthRequestUpdateOne {\n\taruo.mutation.SetConnectorData(b)\n\treturn aruo\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearConnectorData() *AuthRequestUpdateOne {\n\taruo.mutation.ClearConnectorData()\n\treturn aruo\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (aruo *AuthRequestUpdateOne) SetExpiry(t time.Time) *AuthRequestUpdateOne {\n\taruo.mutation.SetExpiry(t)\n\treturn aruo\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (aruo *AuthRequestUpdateOne) SetCodeChallenge(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetCodeChallenge(s)\n\treturn aruo\n}\n\n// SetNillableCodeChallenge sets the \"code_challenge\" field if the given value is not nil.\nfunc (aruo *AuthRequestUpdateOne) SetNillableCodeChallenge(s *string) *AuthRequestUpdateOne {\n\tif s != nil {\n\t\taruo.SetCodeChallenge(*s)\n\t}\n\treturn aruo\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (aruo *AuthRequestUpdateOne) SetCodeChallengeMethod(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetCodeChallengeMethod(s)\n\treturn aruo\n}\n\n// SetNillableCodeChallengeMethod sets the \"code_challenge_method\" field if the given value is not nil.\nfunc (aruo *AuthRequestUpdateOne) SetNillableCodeChallengeMethod(s *string) *AuthRequestUpdateOne {\n\tif s != nil {\n\t\taruo.SetCodeChallengeMethod(*s)\n\t}\n\treturn aruo\n}\n\n// Mutation returns the AuthRequestMutation object of the builder.\nfunc (aruo *AuthRequestUpdateOne) Mutation() *AuthRequestMutation {\n\treturn aruo.mutation\n}\n\n// Select allows selecting one or more fields (columns) of the returned entity.\n// The default is selecting all fields defined in the entity schema.\nfunc (aruo *AuthRequestUpdateOne) Select(field string, fields ...string) *AuthRequestUpdateOne {\n\taruo.fields = append([]string{field}, fields...)\n\treturn aruo\n}\n\n// Save executes the query and returns the updated AuthRequest entity.\nfunc (aruo *AuthRequestUpdateOne) Save(ctx context.Context) (*AuthRequest, error) {\n\tvar (\n\t\terr  error\n\t\tnode *AuthRequest\n\t)\n\tif len(aruo.hooks) == 0 {\n\t\tnode, err = aruo.sqlSave(ctx)\n\t} else {\n\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t}\n\t\t\taruo.mutation = mutation\n\t\t\tnode, err = aruo.sqlSave(ctx)\n\t\t\tmutation.done = true\n\t\t\treturn node, err\n\t\t})\n\t\tfor i := len(aruo.hooks) - 1; i >= 0; i-- {\n\t\t\tif aruo.hooks[i] == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"db: uninitialized hook (forgotten import db/runtime?)\")\n\t\t\t}\n\t\t\tmut = aruo.hooks[i](mut)\n\t\t}\n\t\tv, err := mut.Mutate(ctx, aruo.mutation)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnv, ok := v.(*AuthRequest)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected node type %T returned from AuthRequestMutation\", v)\n\t\t}\n\t\tnode = nv\n\t}\n\treturn node, err\n}\n\n// SaveX is like Save, but panics if an error occurs.\nfunc (aruo *AuthRequestUpdateOne) SaveX(ctx context.Context) *AuthRequest {\n\tnode, err := aruo.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn node\n}\n\n// Exec executes the query on the entity.\nfunc (aruo *AuthRequestUpdateOne) Exec(ctx context.Context) error {\n\t_, err := aruo.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (aruo *AuthRequestUpdateOne) ExecX(ctx context.Context) {\n\tif err := aruo.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (aruo *AuthRequestUpdateOne) sqlSave(ctx context.Context) (_node *AuthRequest, err error) {\n\t_spec := &sqlgraph.UpdateSpec{\n\t\tNode: &sqlgraph.NodeSpec{\n\t\t\tTable:   authrequest.Table,\n\t\t\tColumns: authrequest.Columns,\n\t\t\tID: &sqlgraph.FieldSpec{\n\t\t\t\tType:   field.TypeString,\n\t\t\t\tColumn: authrequest.FieldID,\n\t\t\t},\n\t\t},\n\t}\n\tid, ok := aruo.mutation.ID()\n\tif !ok {\n\t\treturn nil, &ValidationError{Name: \"id\", err: errors.New(`db: missing \"AuthRequest.id\" for update`)}\n\t}\n\t_spec.Node.ID.Value = id\n\tif fields := aruo.fields; len(fields) > 0 {\n\t\t_spec.Node.Columns = make([]string, 0, len(fields))\n\t\t_spec.Node.Columns = append(_spec.Node.Columns, authrequest.FieldID)\n\t\tfor _, f := range fields {\n\t\t\tif !authrequest.ValidColumn(f) {\n\t\t\t\treturn nil, &ValidationError{Name: f, err: fmt.Errorf(\"db: invalid field %q for query\", f)}\n\t\t\t}\n\t\t\tif f != authrequest.FieldID {\n\t\t\t\t_spec.Node.Columns = append(_spec.Node.Columns, f)\n\t\t\t}\n\t\t}\n\t}\n\tif ps := aruo.mutation.predicates; len(ps) > 0 {\n\t\t_spec.Predicate = func(selector *sql.Selector) {\n\t\t\tfor i := range ps {\n\t\t\t\tps[i](selector)\n\t\t\t}\n\t\t}\n\t}\n\tif value, ok := aruo.mutation.ClientID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClientID,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.Scopes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif aruo.mutation.ScopesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ResponseTypes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif aruo.mutation.ResponseTypesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.RedirectURI(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldRedirectURI,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.Nonce(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldNonce,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.State(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldState,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ForceApprovalPrompt(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldForceApprovalPrompt,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.LoggedIn(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldLoggedIn,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsUserID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUserID,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUsername,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsEmail(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmail,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsEmailVerified(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmailVerified,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsGroups(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif aruo.mutation.ClaimsGroupsCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsPreferredUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsPreferredUsername,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ConnectorID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorID,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ConnectorData(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif aruo.mutation.ConnectorDataCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.Expiry(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeTime,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldExpiry,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.CodeChallenge(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallenge,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.CodeChallengeMethod(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallengeMethod,\n\t\t})\n\t}\n\t_node = &AuthRequest{config: aruo.config}\n\t_spec.Assign = _node.assignValues\n\t_spec.ScanValues = _node.scanValues\n\tif err = sqlgraph.UpdateNode(ctx, aruo.driver, _spec); err != nil {\n\t\tif _, ok := err.(*sqlgraph.NotFoundError); ok {\n\t\t\terr = &NotFoundError{authrequest.Label}\n\t\t} else if sqlgraph.IsConstraintError(err) {\n\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn _node, nil\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage migrate\n\nimport (\n\t\"entgo.io/ent/dialect/sql/schema\"\n\t\"entgo.io/ent/schema/field\"\n)\n\nvar (\n\t// AuthCodesColumns holds the columns for the \"auth_codes\" table.\n\tAuthCodesColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"nonce\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"redirect_uri\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email_verified\", Type: field.TypeBool},\n\t\t{Name: \"claims_groups\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"claims_preferred_username\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"code_challenge\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"code_challenge_method\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// AuthCodesTable holds the schema information for the \"auth_codes\" table.\n\tAuthCodesTable = &schema.Table{\n\t\tName:       \"auth_codes\",\n\t\tColumns:    AuthCodesColumns,\n\t\tPrimaryKey: []*schema.Column{AuthCodesColumns[0]},\n\t}\n\t// AuthRequestsColumns holds the columns for the \"auth_requests\" table.\n\tAuthRequestsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"response_types\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"redirect_uri\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"nonce\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"state\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"force_approval_prompt\", Type: field.TypeBool},\n\t\t{Name: \"logged_in\", Type: field.TypeBool},\n\t\t{Name: \"claims_user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email_verified\", Type: field.TypeBool},\n\t\t{Name: \"claims_groups\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"claims_preferred_username\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"code_challenge\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"code_challenge_method\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// AuthRequestsTable holds the schema information for the \"auth_requests\" table.\n\tAuthRequestsTable = &schema.Table{\n\t\tName:       \"auth_requests\",\n\t\tColumns:    AuthRequestsColumns,\n\t\tPrimaryKey: []*schema.Column{AuthRequestsColumns[0]},\n\t}\n\t// ConnectorsColumns holds the columns for the \"connectors\" table.\n\tConnectorsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 100, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"type\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"name\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"resource_version\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"config\", Type: field.TypeBytes},\n\t}\n\t// ConnectorsTable holds the schema information for the \"connectors\" table.\n\tConnectorsTable = &schema.Table{\n\t\tName:       \"connectors\",\n\t\tColumns:    ConnectorsColumns,\n\t\tPrimaryKey: []*schema.Column{ConnectorsColumns[0]},\n\t}\n\t// DeviceRequestsColumns holds the columns for the \"device_requests\" table.\n\tDeviceRequestsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeInt, Increment: true},\n\t\t{Name: \"user_code\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"device_code\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_secret\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t}\n\t// DeviceRequestsTable holds the schema information for the \"device_requests\" table.\n\tDeviceRequestsTable = &schema.Table{\n\t\tName:       \"device_requests\",\n\t\tColumns:    DeviceRequestsColumns,\n\t\tPrimaryKey: []*schema.Column{DeviceRequestsColumns[0]},\n\t}\n\t// DeviceTokensColumns holds the columns for the \"device_tokens\" table.\n\tDeviceTokensColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeInt, Increment: true},\n\t\t{Name: \"device_code\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"status\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"token\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"last_request\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"poll_interval\", Type: field.TypeInt},\n\t\t{Name: \"code_challenge\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"code_challenge_method\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// DeviceTokensTable holds the schema information for the \"device_tokens\" table.\n\tDeviceTokensTable = &schema.Table{\n\t\tName:       \"device_tokens\",\n\t\tColumns:    DeviceTokensColumns,\n\t\tPrimaryKey: []*schema.Column{DeviceTokensColumns[0]},\n\t}\n\t// KeysColumns holds the columns for the \"keys\" table.\n\tKeysColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"verification_keys\", Type: field.TypeJSON},\n\t\t{Name: \"signing_key\", Type: field.TypeJSON},\n\t\t{Name: \"signing_key_pub\", Type: field.TypeJSON},\n\t\t{Name: \"next_rotation\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t}\n\t// KeysTable holds the schema information for the \"keys\" table.\n\tKeysTable = &schema.Table{\n\t\tName:       \"keys\",\n\t\tColumns:    KeysColumns,\n\t\tPrimaryKey: []*schema.Column{KeysColumns[0]},\n\t}\n\t// Oauth2clientsColumns holds the columns for the \"oauth2clients\" table.\n\tOauth2clientsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 100, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"secret\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"redirect_uris\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"trusted_peers\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"public\", Type: field.TypeBool},\n\t\t{Name: \"name\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"logo_url\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// Oauth2clientsTable holds the schema information for the \"oauth2clients\" table.\n\tOauth2clientsTable = &schema.Table{\n\t\tName:       \"oauth2clients\",\n\t\tColumns:    Oauth2clientsColumns,\n\t\tPrimaryKey: []*schema.Column{Oauth2clientsColumns[0]},\n\t}\n\t// OfflineSessionsColumns holds the columns for the \"offline_sessions\" table.\n\tOfflineSessionsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"conn_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"refresh\", Type: field.TypeBytes},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t}\n\t// OfflineSessionsTable holds the schema information for the \"offline_sessions\" table.\n\tOfflineSessionsTable = &schema.Table{\n\t\tName:       \"offline_sessions\",\n\t\tColumns:    OfflineSessionsColumns,\n\t\tPrimaryKey: []*schema.Column{OfflineSessionsColumns[0]},\n\t}\n\t// PasswordsColumns holds the columns for the \"passwords\" table.\n\tPasswordsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeInt, Increment: true},\n\t\t{Name: \"email\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"hash\", Type: field.TypeBytes},\n\t\t{Name: \"username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// PasswordsTable holds the schema information for the \"passwords\" table.\n\tPasswordsTable = &schema.Table{\n\t\tName:       \"passwords\",\n\t\tColumns:    PasswordsColumns,\n\t\tPrimaryKey: []*schema.Column{PasswordsColumns[0]},\n\t}\n\t// RefreshTokensColumns holds the columns for the \"refresh_tokens\" table.\n\tRefreshTokensColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"nonce\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email_verified\", Type: field.TypeBool},\n\t\t{Name: \"claims_groups\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"claims_preferred_username\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"token\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"obsolete_token\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"created_at\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"last_used\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t}\n\t// RefreshTokensTable holds the schema information for the \"refresh_tokens\" table.\n\tRefreshTokensTable = &schema.Table{\n\t\tName:       \"refresh_tokens\",\n\t\tColumns:    RefreshTokensColumns,\n\t\tPrimaryKey: []*schema.Column{RefreshTokensColumns[0]},\n\t}\n\t// Tables holds all the tables in the schema.\n\tTables = []*schema.Table{\n\t\tAuthCodesTable,\n\t\tAuthRequestsTable,\n\t\tConnectorsTable,\n\t\tDeviceRequestsTable,\n\t\tDeviceTokensTable,\n\t\tKeysTable,\n\t\tOauth2clientsTable,\n\t\tOfflineSessionsTable,\n\t\tPasswordsTable,\n\t\tRefreshTokensTable,\n\t}\n)\n\nfunc init() {\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/ent/db/authcode\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n\t\"github.com/dexidp/dex/storage/ent/db/connector\"\n\t\"github.com/dexidp/dex/storage/ent/db/devicerequest\"\n\t\"github.com/dexidp/dex/storage/ent/db/devicetoken\"\n\t\"github.com/dexidp/dex/storage/ent/db/keys\"\n\t\"github.com/dexidp/dex/storage/ent/db/oauth2client\"\n\t\"github.com/dexidp/dex/storage/ent/db/offlinesession\"\n\t\"github.com/dexidp/dex/storage/ent/db/password\"\n\t\"github.com/dexidp/dex/storage/ent/db/predicate\"\n\t\"github.com/dexidp/dex/storage/ent/db/refreshtoken\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"entgo.io/ent\"\n)\n\nconst (\n\t// Operation types.\n\tOpCreate    = ent.OpCreate\n\tOpDelete    = ent.OpDelete\n\tOpDeleteOne = ent.OpDeleteOne\n\tOpUpdate    = ent.OpUpdate\n\tOpUpdateOne = ent.OpUpdateOne\n\n\t// Node types.\n\tTypeAuthCode       = \"AuthCode\"\n\tTypeAuthRequest    = \"AuthRequest\"\n\tTypeConnector      = \"Connector\"\n\tTypeDeviceRequest  = \"DeviceRequest\"\n\tTypeDeviceToken    = \"DeviceToken\"\n\tTypeKeys           = \"Keys\"\n\tTypeOAuth2Client   = \"OAuth2Client\"\n\tTypeOfflineSession = \"OfflineSession\"\n\tTypePassword       = \"Password\"\n\tTypeRefreshToken   = \"RefreshToken\"\n)\n\n// AuthCodeMutation represents an operation that mutates the AuthCode nodes in the graph.\ntype AuthCodeMutation struct {\n\tconfig\n\top                        Op\n\ttyp                       string\n\tid                        *string\n\tclient_id                 *string\n\tscopes                    *[]string\n\tnonce                     *string\n\tredirect_uri              *string\n\tclaims_user_id            *string\n\tclaims_username           *string\n\tclaims_email              *string\n\tclaims_email_verified     *bool\n\tclaims_groups             *[]string\n\tclaims_preferred_username *string\n\tconnector_id              *string\n\tconnector_data            *[]byte\n\texpiry                    *time.Time\n\tcode_challenge            *string\n\tcode_challenge_method     *string\n\tclearedFields             map[string]struct{}\n\tdone                      bool\n\toldValue                  func(context.Context) (*AuthCode, error)\n\tpredicates                []predicate.AuthCode\n}\n\nvar _ ent.Mutation = (*AuthCodeMutation)(nil)\n\n// authcodeOption allows management of the mutation configuration using functional options.\ntype authcodeOption func(*AuthCodeMutation)\n\n// newAuthCodeMutation creates new mutation for the AuthCode entity.\nfunc newAuthCodeMutation(c config, op Op, opts ...authcodeOption) *AuthCodeMutation {\n\tm := &AuthCodeMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeAuthCode,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withAuthCodeID sets the ID field of the mutation.\nfunc withAuthCodeID(id string) authcodeOption {\n\treturn func(m *AuthCodeMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *AuthCode\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*AuthCode, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().AuthCode.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withAuthCode sets the old AuthCode of the mutation.\nfunc withAuthCode(node *AuthCode) authcodeOption {\n\treturn func(m *AuthCodeMutation) {\n\t\tm.oldValue = func(context.Context) (*AuthCode, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m AuthCodeMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m AuthCodeMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of AuthCode entities.\nfunc (m *AuthCodeMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *AuthCodeMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *AuthCodeMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().AuthCode.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *AuthCodeMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *AuthCodeMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *AuthCodeMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *AuthCodeMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *AuthCodeMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *AuthCodeMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[authcode.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *AuthCodeMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[authcode.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *AuthCodeMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, authcode.FieldScopes)\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (m *AuthCodeMutation) SetNonce(s string) {\n\tm.nonce = &s\n}\n\n// Nonce returns the value of the \"nonce\" field in the mutation.\nfunc (m *AuthCodeMutation) Nonce() (r string, exists bool) {\n\tv := m.nonce\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNonce returns the old \"nonce\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldNonce(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNonce is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNonce requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNonce: %w\", err)\n\t}\n\treturn oldValue.Nonce, nil\n}\n\n// ResetNonce resets all changes to the \"nonce\" field.\nfunc (m *AuthCodeMutation) ResetNonce() {\n\tm.nonce = nil\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (m *AuthCodeMutation) SetRedirectURI(s string) {\n\tm.redirect_uri = &s\n}\n\n// RedirectURI returns the value of the \"redirect_uri\" field in the mutation.\nfunc (m *AuthCodeMutation) RedirectURI() (r string, exists bool) {\n\tv := m.redirect_uri\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRedirectURI returns the old \"redirect_uri\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRedirectURI is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRedirectURI requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRedirectURI: %w\", err)\n\t}\n\treturn oldValue.RedirectURI, nil\n}\n\n// ResetRedirectURI resets all changes to the \"redirect_uri\" field.\nfunc (m *AuthCodeMutation) ResetRedirectURI() {\n\tm.redirect_uri = nil\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (m *AuthCodeMutation) SetClaimsUserID(s string) {\n\tm.claims_user_id = &s\n}\n\n// ClaimsUserID returns the value of the \"claims_user_id\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsUserID() (r string, exists bool) {\n\tv := m.claims_user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUserID returns the old \"claims_user_id\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUserID: %w\", err)\n\t}\n\treturn oldValue.ClaimsUserID, nil\n}\n\n// ResetClaimsUserID resets all changes to the \"claims_user_id\" field.\nfunc (m *AuthCodeMutation) ResetClaimsUserID() {\n\tm.claims_user_id = nil\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (m *AuthCodeMutation) SetClaimsUsername(s string) {\n\tm.claims_username = &s\n}\n\n// ClaimsUsername returns the value of the \"claims_username\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsUsername() (r string, exists bool) {\n\tv := m.claims_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUsername returns the old \"claims_username\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsUsername, nil\n}\n\n// ResetClaimsUsername resets all changes to the \"claims_username\" field.\nfunc (m *AuthCodeMutation) ResetClaimsUsername() {\n\tm.claims_username = nil\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (m *AuthCodeMutation) SetClaimsEmail(s string) {\n\tm.claims_email = &s\n}\n\n// ClaimsEmail returns the value of the \"claims_email\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsEmail() (r string, exists bool) {\n\tv := m.claims_email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmail returns the old \"claims_email\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmail: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmail, nil\n}\n\n// ResetClaimsEmail resets all changes to the \"claims_email\" field.\nfunc (m *AuthCodeMutation) ResetClaimsEmail() {\n\tm.claims_email = nil\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (m *AuthCodeMutation) SetClaimsEmailVerified(b bool) {\n\tm.claims_email_verified = &b\n}\n\n// ClaimsEmailVerified returns the value of the \"claims_email_verified\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsEmailVerified() (r bool, exists bool) {\n\tv := m.claims_email_verified\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmailVerified returns the old \"claims_email_verified\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmailVerified: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmailVerified, nil\n}\n\n// ResetClaimsEmailVerified resets all changes to the \"claims_email_verified\" field.\nfunc (m *AuthCodeMutation) ResetClaimsEmailVerified() {\n\tm.claims_email_verified = nil\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (m *AuthCodeMutation) SetClaimsGroups(s []string) {\n\tm.claims_groups = &s\n}\n\n// ClaimsGroups returns the value of the \"claims_groups\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsGroups() (r []string, exists bool) {\n\tv := m.claims_groups\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsGroups returns the old \"claims_groups\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsGroups is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsGroups requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsGroups: %w\", err)\n\t}\n\treturn oldValue.ClaimsGroups, nil\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (m *AuthCodeMutation) ClearClaimsGroups() {\n\tm.claims_groups = nil\n\tm.clearedFields[authcode.FieldClaimsGroups] = struct{}{}\n}\n\n// ClaimsGroupsCleared returns if the \"claims_groups\" field was cleared in this mutation.\nfunc (m *AuthCodeMutation) ClaimsGroupsCleared() bool {\n\t_, ok := m.clearedFields[authcode.FieldClaimsGroups]\n\treturn ok\n}\n\n// ResetClaimsGroups resets all changes to the \"claims_groups\" field.\nfunc (m *AuthCodeMutation) ResetClaimsGroups() {\n\tm.claims_groups = nil\n\tdelete(m.clearedFields, authcode.FieldClaimsGroups)\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (m *AuthCodeMutation) SetClaimsPreferredUsername(s string) {\n\tm.claims_preferred_username = &s\n}\n\n// ClaimsPreferredUsername returns the value of the \"claims_preferred_username\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsPreferredUsername() (r string, exists bool) {\n\tv := m.claims_preferred_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsPreferredUsername returns the old \"claims_preferred_username\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsPreferredUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsPreferredUsername, nil\n}\n\n// ResetClaimsPreferredUsername resets all changes to the \"claims_preferred_username\" field.\nfunc (m *AuthCodeMutation) ResetClaimsPreferredUsername() {\n\tm.claims_preferred_username = nil\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (m *AuthCodeMutation) SetConnectorID(s string) {\n\tm.connector_id = &s\n}\n\n// ConnectorID returns the value of the \"connector_id\" field in the mutation.\nfunc (m *AuthCodeMutation) ConnectorID() (r string, exists bool) {\n\tv := m.connector_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorID returns the old \"connector_id\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldConnectorID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorID: %w\", err)\n\t}\n\treturn oldValue.ConnectorID, nil\n}\n\n// ResetConnectorID resets all changes to the \"connector_id\" field.\nfunc (m *AuthCodeMutation) ResetConnectorID() {\n\tm.connector_id = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *AuthCodeMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *AuthCodeMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *AuthCodeMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[authcode.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *AuthCodeMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[authcode.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *AuthCodeMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, authcode.FieldConnectorData)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *AuthCodeMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *AuthCodeMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *AuthCodeMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (m *AuthCodeMutation) SetCodeChallenge(s string) {\n\tm.code_challenge = &s\n}\n\n// CodeChallenge returns the value of the \"code_challenge\" field in the mutation.\nfunc (m *AuthCodeMutation) CodeChallenge() (r string, exists bool) {\n\tv := m.code_challenge\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallenge returns the old \"code_challenge\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallenge is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallenge requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallenge: %w\", err)\n\t}\n\treturn oldValue.CodeChallenge, nil\n}\n\n// ResetCodeChallenge resets all changes to the \"code_challenge\" field.\nfunc (m *AuthCodeMutation) ResetCodeChallenge() {\n\tm.code_challenge = nil\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (m *AuthCodeMutation) SetCodeChallengeMethod(s string) {\n\tm.code_challenge_method = &s\n}\n\n// CodeChallengeMethod returns the value of the \"code_challenge_method\" field in the mutation.\nfunc (m *AuthCodeMutation) CodeChallengeMethod() (r string, exists bool) {\n\tv := m.code_challenge_method\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallengeMethod returns the old \"code_challenge_method\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallengeMethod: %w\", err)\n\t}\n\treturn oldValue.CodeChallengeMethod, nil\n}\n\n// ResetCodeChallengeMethod resets all changes to the \"code_challenge_method\" field.\nfunc (m *AuthCodeMutation) ResetCodeChallengeMethod() {\n\tm.code_challenge_method = nil\n}\n\n// Where appends a list predicates to the AuthCodeMutation builder.\nfunc (m *AuthCodeMutation) Where(ps ...predicate.AuthCode) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *AuthCodeMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (AuthCode).\nfunc (m *AuthCodeMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *AuthCodeMutation) Fields() []string {\n\tfields := make([]string, 0, 15)\n\tif m.client_id != nil {\n\t\tfields = append(fields, authcode.FieldClientID)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, authcode.FieldScopes)\n\t}\n\tif m.nonce != nil {\n\t\tfields = append(fields, authcode.FieldNonce)\n\t}\n\tif m.redirect_uri != nil {\n\t\tfields = append(fields, authcode.FieldRedirectURI)\n\t}\n\tif m.claims_user_id != nil {\n\t\tfields = append(fields, authcode.FieldClaimsUserID)\n\t}\n\tif m.claims_username != nil {\n\t\tfields = append(fields, authcode.FieldClaimsUsername)\n\t}\n\tif m.claims_email != nil {\n\t\tfields = append(fields, authcode.FieldClaimsEmail)\n\t}\n\tif m.claims_email_verified != nil {\n\t\tfields = append(fields, authcode.FieldClaimsEmailVerified)\n\t}\n\tif m.claims_groups != nil {\n\t\tfields = append(fields, authcode.FieldClaimsGroups)\n\t}\n\tif m.claims_preferred_username != nil {\n\t\tfields = append(fields, authcode.FieldClaimsPreferredUsername)\n\t}\n\tif m.connector_id != nil {\n\t\tfields = append(fields, authcode.FieldConnectorID)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, authcode.FieldConnectorData)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, authcode.FieldExpiry)\n\t}\n\tif m.code_challenge != nil {\n\t\tfields = append(fields, authcode.FieldCodeChallenge)\n\t}\n\tif m.code_challenge_method != nil {\n\t\tfields = append(fields, authcode.FieldCodeChallengeMethod)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *AuthCodeMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\treturn m.ClientID()\n\tcase authcode.FieldScopes:\n\t\treturn m.Scopes()\n\tcase authcode.FieldNonce:\n\t\treturn m.Nonce()\n\tcase authcode.FieldRedirectURI:\n\t\treturn m.RedirectURI()\n\tcase authcode.FieldClaimsUserID:\n\t\treturn m.ClaimsUserID()\n\tcase authcode.FieldClaimsUsername:\n\t\treturn m.ClaimsUsername()\n\tcase authcode.FieldClaimsEmail:\n\t\treturn m.ClaimsEmail()\n\tcase authcode.FieldClaimsEmailVerified:\n\t\treturn m.ClaimsEmailVerified()\n\tcase authcode.FieldClaimsGroups:\n\t\treturn m.ClaimsGroups()\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\treturn m.ClaimsPreferredUsername()\n\tcase authcode.FieldConnectorID:\n\t\treturn m.ConnectorID()\n\tcase authcode.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\tcase authcode.FieldExpiry:\n\t\treturn m.Expiry()\n\tcase authcode.FieldCodeChallenge:\n\t\treturn m.CodeChallenge()\n\tcase authcode.FieldCodeChallengeMethod:\n\t\treturn m.CodeChallengeMethod()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *AuthCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase authcode.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase authcode.FieldNonce:\n\t\treturn m.OldNonce(ctx)\n\tcase authcode.FieldRedirectURI:\n\t\treturn m.OldRedirectURI(ctx)\n\tcase authcode.FieldClaimsUserID:\n\t\treturn m.OldClaimsUserID(ctx)\n\tcase authcode.FieldClaimsUsername:\n\t\treturn m.OldClaimsUsername(ctx)\n\tcase authcode.FieldClaimsEmail:\n\t\treturn m.OldClaimsEmail(ctx)\n\tcase authcode.FieldClaimsEmailVerified:\n\t\treturn m.OldClaimsEmailVerified(ctx)\n\tcase authcode.FieldClaimsGroups:\n\t\treturn m.OldClaimsGroups(ctx)\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\treturn m.OldClaimsPreferredUsername(ctx)\n\tcase authcode.FieldConnectorID:\n\t\treturn m.OldConnectorID(ctx)\n\tcase authcode.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\tcase authcode.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\tcase authcode.FieldCodeChallenge:\n\t\treturn m.OldCodeChallenge(ctx)\n\tcase authcode.FieldCodeChallengeMethod:\n\t\treturn m.OldCodeChallengeMethod(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown AuthCode field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthCodeMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase authcode.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase authcode.FieldNonce:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNonce(v)\n\t\treturn nil\n\tcase authcode.FieldRedirectURI:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRedirectURI(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUserID(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUsername(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmail(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsEmailVerified:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmailVerified(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsGroups:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsGroups(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsPreferredUsername(v)\n\t\treturn nil\n\tcase authcode.FieldConnectorID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorID(v)\n\t\treturn nil\n\tcase authcode.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\tcase authcode.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\tcase authcode.FieldCodeChallenge:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallenge(v)\n\t\treturn nil\n\tcase authcode.FieldCodeChallengeMethod:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallengeMethod(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *AuthCodeMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *AuthCodeMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthCodeMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *AuthCodeMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(authcode.FieldScopes) {\n\t\tfields = append(fields, authcode.FieldScopes)\n\t}\n\tif m.FieldCleared(authcode.FieldClaimsGroups) {\n\t\tfields = append(fields, authcode.FieldClaimsGroups)\n\t}\n\tif m.FieldCleared(authcode.FieldConnectorData) {\n\t\tfields = append(fields, authcode.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *AuthCodeMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *AuthCodeMutation) ClearField(name string) error {\n\tswitch name {\n\tcase authcode.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\tcase authcode.FieldClaimsGroups:\n\t\tm.ClearClaimsGroups()\n\t\treturn nil\n\tcase authcode.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *AuthCodeMutation) ResetField(name string) error {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase authcode.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase authcode.FieldNonce:\n\t\tm.ResetNonce()\n\t\treturn nil\n\tcase authcode.FieldRedirectURI:\n\t\tm.ResetRedirectURI()\n\t\treturn nil\n\tcase authcode.FieldClaimsUserID:\n\t\tm.ResetClaimsUserID()\n\t\treturn nil\n\tcase authcode.FieldClaimsUsername:\n\t\tm.ResetClaimsUsername()\n\t\treturn nil\n\tcase authcode.FieldClaimsEmail:\n\t\tm.ResetClaimsEmail()\n\t\treturn nil\n\tcase authcode.FieldClaimsEmailVerified:\n\t\tm.ResetClaimsEmailVerified()\n\t\treturn nil\n\tcase authcode.FieldClaimsGroups:\n\t\tm.ResetClaimsGroups()\n\t\treturn nil\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\tm.ResetClaimsPreferredUsername()\n\t\treturn nil\n\tcase authcode.FieldConnectorID:\n\t\tm.ResetConnectorID()\n\t\treturn nil\n\tcase authcode.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\tcase authcode.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\tcase authcode.FieldCodeChallenge:\n\t\tm.ResetCodeChallenge()\n\t\treturn nil\n\tcase authcode.FieldCodeChallengeMethod:\n\t\tm.ResetCodeChallengeMethod()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *AuthCodeMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *AuthCodeMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *AuthCodeMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *AuthCodeMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *AuthCodeMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *AuthCodeMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *AuthCodeMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthCode unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *AuthCodeMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthCode edge %s\", name)\n}\n\n// AuthRequestMutation represents an operation that mutates the AuthRequest nodes in the graph.\ntype AuthRequestMutation struct {\n\tconfig\n\top                        Op\n\ttyp                       string\n\tid                        *string\n\tclient_id                 *string\n\tscopes                    *[]string\n\tresponse_types            *[]string\n\tredirect_uri              *string\n\tnonce                     *string\n\tstate                     *string\n\tforce_approval_prompt     *bool\n\tlogged_in                 *bool\n\tclaims_user_id            *string\n\tclaims_username           *string\n\tclaims_email              *string\n\tclaims_email_verified     *bool\n\tclaims_groups             *[]string\n\tclaims_preferred_username *string\n\tconnector_id              *string\n\tconnector_data            *[]byte\n\texpiry                    *time.Time\n\tcode_challenge            *string\n\tcode_challenge_method     *string\n\tclearedFields             map[string]struct{}\n\tdone                      bool\n\toldValue                  func(context.Context) (*AuthRequest, error)\n\tpredicates                []predicate.AuthRequest\n}\n\nvar _ ent.Mutation = (*AuthRequestMutation)(nil)\n\n// authrequestOption allows management of the mutation configuration using functional options.\ntype authrequestOption func(*AuthRequestMutation)\n\n// newAuthRequestMutation creates new mutation for the AuthRequest entity.\nfunc newAuthRequestMutation(c config, op Op, opts ...authrequestOption) *AuthRequestMutation {\n\tm := &AuthRequestMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeAuthRequest,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withAuthRequestID sets the ID field of the mutation.\nfunc withAuthRequestID(id string) authrequestOption {\n\treturn func(m *AuthRequestMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *AuthRequest\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*AuthRequest, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().AuthRequest.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withAuthRequest sets the old AuthRequest of the mutation.\nfunc withAuthRequest(node *AuthRequest) authrequestOption {\n\treturn func(m *AuthRequestMutation) {\n\t\tm.oldValue = func(context.Context) (*AuthRequest, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m AuthRequestMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m AuthRequestMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of AuthRequest entities.\nfunc (m *AuthRequestMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *AuthRequestMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *AuthRequestMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().AuthRequest.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *AuthRequestMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *AuthRequestMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *AuthRequestMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *AuthRequestMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *AuthRequestMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *AuthRequestMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[authrequest.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *AuthRequestMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, authrequest.FieldScopes)\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (m *AuthRequestMutation) SetResponseTypes(s []string) {\n\tm.response_types = &s\n}\n\n// ResponseTypes returns the value of the \"response_types\" field in the mutation.\nfunc (m *AuthRequestMutation) ResponseTypes() (r []string, exists bool) {\n\tv := m.response_types\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldResponseTypes returns the old \"response_types\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldResponseTypes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldResponseTypes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldResponseTypes: %w\", err)\n\t}\n\treturn oldValue.ResponseTypes, nil\n}\n\n// ClearResponseTypes clears the value of the \"response_types\" field.\nfunc (m *AuthRequestMutation) ClearResponseTypes() {\n\tm.response_types = nil\n\tm.clearedFields[authrequest.FieldResponseTypes] = struct{}{}\n}\n\n// ResponseTypesCleared returns if the \"response_types\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ResponseTypesCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldResponseTypes]\n\treturn ok\n}\n\n// ResetResponseTypes resets all changes to the \"response_types\" field.\nfunc (m *AuthRequestMutation) ResetResponseTypes() {\n\tm.response_types = nil\n\tdelete(m.clearedFields, authrequest.FieldResponseTypes)\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (m *AuthRequestMutation) SetRedirectURI(s string) {\n\tm.redirect_uri = &s\n}\n\n// RedirectURI returns the value of the \"redirect_uri\" field in the mutation.\nfunc (m *AuthRequestMutation) RedirectURI() (r string, exists bool) {\n\tv := m.redirect_uri\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRedirectURI returns the old \"redirect_uri\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldRedirectURI(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRedirectURI is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRedirectURI requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRedirectURI: %w\", err)\n\t}\n\treturn oldValue.RedirectURI, nil\n}\n\n// ResetRedirectURI resets all changes to the \"redirect_uri\" field.\nfunc (m *AuthRequestMutation) ResetRedirectURI() {\n\tm.redirect_uri = nil\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (m *AuthRequestMutation) SetNonce(s string) {\n\tm.nonce = &s\n}\n\n// Nonce returns the value of the \"nonce\" field in the mutation.\nfunc (m *AuthRequestMutation) Nonce() (r string, exists bool) {\n\tv := m.nonce\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNonce returns the old \"nonce\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldNonce(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNonce is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNonce requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNonce: %w\", err)\n\t}\n\treturn oldValue.Nonce, nil\n}\n\n// ResetNonce resets all changes to the \"nonce\" field.\nfunc (m *AuthRequestMutation) ResetNonce() {\n\tm.nonce = nil\n}\n\n// SetState sets the \"state\" field.\nfunc (m *AuthRequestMutation) SetState(s string) {\n\tm.state = &s\n}\n\n// State returns the value of the \"state\" field in the mutation.\nfunc (m *AuthRequestMutation) State() (r string, exists bool) {\n\tv := m.state\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldState returns the old \"state\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldState(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldState is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldState requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldState: %w\", err)\n\t}\n\treturn oldValue.State, nil\n}\n\n// ResetState resets all changes to the \"state\" field.\nfunc (m *AuthRequestMutation) ResetState() {\n\tm.state = nil\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (m *AuthRequestMutation) SetForceApprovalPrompt(b bool) {\n\tm.force_approval_prompt = &b\n}\n\n// ForceApprovalPrompt returns the value of the \"force_approval_prompt\" field in the mutation.\nfunc (m *AuthRequestMutation) ForceApprovalPrompt() (r bool, exists bool) {\n\tv := m.force_approval_prompt\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldForceApprovalPrompt returns the old \"force_approval_prompt\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldForceApprovalPrompt(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldForceApprovalPrompt is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldForceApprovalPrompt requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldForceApprovalPrompt: %w\", err)\n\t}\n\treturn oldValue.ForceApprovalPrompt, nil\n}\n\n// ResetForceApprovalPrompt resets all changes to the \"force_approval_prompt\" field.\nfunc (m *AuthRequestMutation) ResetForceApprovalPrompt() {\n\tm.force_approval_prompt = nil\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (m *AuthRequestMutation) SetLoggedIn(b bool) {\n\tm.logged_in = &b\n}\n\n// LoggedIn returns the value of the \"logged_in\" field in the mutation.\nfunc (m *AuthRequestMutation) LoggedIn() (r bool, exists bool) {\n\tv := m.logged_in\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLoggedIn returns the old \"logged_in\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldLoggedIn(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLoggedIn is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLoggedIn requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLoggedIn: %w\", err)\n\t}\n\treturn oldValue.LoggedIn, nil\n}\n\n// ResetLoggedIn resets all changes to the \"logged_in\" field.\nfunc (m *AuthRequestMutation) ResetLoggedIn() {\n\tm.logged_in = nil\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (m *AuthRequestMutation) SetClaimsUserID(s string) {\n\tm.claims_user_id = &s\n}\n\n// ClaimsUserID returns the value of the \"claims_user_id\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsUserID() (r string, exists bool) {\n\tv := m.claims_user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUserID returns the old \"claims_user_id\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUserID: %w\", err)\n\t}\n\treturn oldValue.ClaimsUserID, nil\n}\n\n// ResetClaimsUserID resets all changes to the \"claims_user_id\" field.\nfunc (m *AuthRequestMutation) ResetClaimsUserID() {\n\tm.claims_user_id = nil\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (m *AuthRequestMutation) SetClaimsUsername(s string) {\n\tm.claims_username = &s\n}\n\n// ClaimsUsername returns the value of the \"claims_username\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsUsername() (r string, exists bool) {\n\tv := m.claims_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUsername returns the old \"claims_username\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsUsername, nil\n}\n\n// ResetClaimsUsername resets all changes to the \"claims_username\" field.\nfunc (m *AuthRequestMutation) ResetClaimsUsername() {\n\tm.claims_username = nil\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (m *AuthRequestMutation) SetClaimsEmail(s string) {\n\tm.claims_email = &s\n}\n\n// ClaimsEmail returns the value of the \"claims_email\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsEmail() (r string, exists bool) {\n\tv := m.claims_email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmail returns the old \"claims_email\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmail: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmail, nil\n}\n\n// ResetClaimsEmail resets all changes to the \"claims_email\" field.\nfunc (m *AuthRequestMutation) ResetClaimsEmail() {\n\tm.claims_email = nil\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (m *AuthRequestMutation) SetClaimsEmailVerified(b bool) {\n\tm.claims_email_verified = &b\n}\n\n// ClaimsEmailVerified returns the value of the \"claims_email_verified\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsEmailVerified() (r bool, exists bool) {\n\tv := m.claims_email_verified\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmailVerified returns the old \"claims_email_verified\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmailVerified: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmailVerified, nil\n}\n\n// ResetClaimsEmailVerified resets all changes to the \"claims_email_verified\" field.\nfunc (m *AuthRequestMutation) ResetClaimsEmailVerified() {\n\tm.claims_email_verified = nil\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (m *AuthRequestMutation) SetClaimsGroups(s []string) {\n\tm.claims_groups = &s\n}\n\n// ClaimsGroups returns the value of the \"claims_groups\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsGroups() (r []string, exists bool) {\n\tv := m.claims_groups\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsGroups returns the old \"claims_groups\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsGroups is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsGroups requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsGroups: %w\", err)\n\t}\n\treturn oldValue.ClaimsGroups, nil\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (m *AuthRequestMutation) ClearClaimsGroups() {\n\tm.claims_groups = nil\n\tm.clearedFields[authrequest.FieldClaimsGroups] = struct{}{}\n}\n\n// ClaimsGroupsCleared returns if the \"claims_groups\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ClaimsGroupsCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldClaimsGroups]\n\treturn ok\n}\n\n// ResetClaimsGroups resets all changes to the \"claims_groups\" field.\nfunc (m *AuthRequestMutation) ResetClaimsGroups() {\n\tm.claims_groups = nil\n\tdelete(m.clearedFields, authrequest.FieldClaimsGroups)\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (m *AuthRequestMutation) SetClaimsPreferredUsername(s string) {\n\tm.claims_preferred_username = &s\n}\n\n// ClaimsPreferredUsername returns the value of the \"claims_preferred_username\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsPreferredUsername() (r string, exists bool) {\n\tv := m.claims_preferred_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsPreferredUsername returns the old \"claims_preferred_username\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsPreferredUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsPreferredUsername, nil\n}\n\n// ResetClaimsPreferredUsername resets all changes to the \"claims_preferred_username\" field.\nfunc (m *AuthRequestMutation) ResetClaimsPreferredUsername() {\n\tm.claims_preferred_username = nil\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (m *AuthRequestMutation) SetConnectorID(s string) {\n\tm.connector_id = &s\n}\n\n// ConnectorID returns the value of the \"connector_id\" field in the mutation.\nfunc (m *AuthRequestMutation) ConnectorID() (r string, exists bool) {\n\tv := m.connector_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorID returns the old \"connector_id\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldConnectorID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorID: %w\", err)\n\t}\n\treturn oldValue.ConnectorID, nil\n}\n\n// ResetConnectorID resets all changes to the \"connector_id\" field.\nfunc (m *AuthRequestMutation) ResetConnectorID() {\n\tm.connector_id = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *AuthRequestMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *AuthRequestMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *AuthRequestMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[authrequest.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *AuthRequestMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, authrequest.FieldConnectorData)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *AuthRequestMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *AuthRequestMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *AuthRequestMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (m *AuthRequestMutation) SetCodeChallenge(s string) {\n\tm.code_challenge = &s\n}\n\n// CodeChallenge returns the value of the \"code_challenge\" field in the mutation.\nfunc (m *AuthRequestMutation) CodeChallenge() (r string, exists bool) {\n\tv := m.code_challenge\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallenge returns the old \"code_challenge\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallenge is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallenge requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallenge: %w\", err)\n\t}\n\treturn oldValue.CodeChallenge, nil\n}\n\n// ResetCodeChallenge resets all changes to the \"code_challenge\" field.\nfunc (m *AuthRequestMutation) ResetCodeChallenge() {\n\tm.code_challenge = nil\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (m *AuthRequestMutation) SetCodeChallengeMethod(s string) {\n\tm.code_challenge_method = &s\n}\n\n// CodeChallengeMethod returns the value of the \"code_challenge_method\" field in the mutation.\nfunc (m *AuthRequestMutation) CodeChallengeMethod() (r string, exists bool) {\n\tv := m.code_challenge_method\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallengeMethod returns the old \"code_challenge_method\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallengeMethod: %w\", err)\n\t}\n\treturn oldValue.CodeChallengeMethod, nil\n}\n\n// ResetCodeChallengeMethod resets all changes to the \"code_challenge_method\" field.\nfunc (m *AuthRequestMutation) ResetCodeChallengeMethod() {\n\tm.code_challenge_method = nil\n}\n\n// Where appends a list predicates to the AuthRequestMutation builder.\nfunc (m *AuthRequestMutation) Where(ps ...predicate.AuthRequest) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *AuthRequestMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (AuthRequest).\nfunc (m *AuthRequestMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *AuthRequestMutation) Fields() []string {\n\tfields := make([]string, 0, 19)\n\tif m.client_id != nil {\n\t\tfields = append(fields, authrequest.FieldClientID)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, authrequest.FieldScopes)\n\t}\n\tif m.response_types != nil {\n\t\tfields = append(fields, authrequest.FieldResponseTypes)\n\t}\n\tif m.redirect_uri != nil {\n\t\tfields = append(fields, authrequest.FieldRedirectURI)\n\t}\n\tif m.nonce != nil {\n\t\tfields = append(fields, authrequest.FieldNonce)\n\t}\n\tif m.state != nil {\n\t\tfields = append(fields, authrequest.FieldState)\n\t}\n\tif m.force_approval_prompt != nil {\n\t\tfields = append(fields, authrequest.FieldForceApprovalPrompt)\n\t}\n\tif m.logged_in != nil {\n\t\tfields = append(fields, authrequest.FieldLoggedIn)\n\t}\n\tif m.claims_user_id != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsUserID)\n\t}\n\tif m.claims_username != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsUsername)\n\t}\n\tif m.claims_email != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsEmail)\n\t}\n\tif m.claims_email_verified != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsEmailVerified)\n\t}\n\tif m.claims_groups != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsGroups)\n\t}\n\tif m.claims_preferred_username != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsPreferredUsername)\n\t}\n\tif m.connector_id != nil {\n\t\tfields = append(fields, authrequest.FieldConnectorID)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, authrequest.FieldConnectorData)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, authrequest.FieldExpiry)\n\t}\n\tif m.code_challenge != nil {\n\t\tfields = append(fields, authrequest.FieldCodeChallenge)\n\t}\n\tif m.code_challenge_method != nil {\n\t\tfields = append(fields, authrequest.FieldCodeChallengeMethod)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *AuthRequestMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\treturn m.ClientID()\n\tcase authrequest.FieldScopes:\n\t\treturn m.Scopes()\n\tcase authrequest.FieldResponseTypes:\n\t\treturn m.ResponseTypes()\n\tcase authrequest.FieldRedirectURI:\n\t\treturn m.RedirectURI()\n\tcase authrequest.FieldNonce:\n\t\treturn m.Nonce()\n\tcase authrequest.FieldState:\n\t\treturn m.State()\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\treturn m.ForceApprovalPrompt()\n\tcase authrequest.FieldLoggedIn:\n\t\treturn m.LoggedIn()\n\tcase authrequest.FieldClaimsUserID:\n\t\treturn m.ClaimsUserID()\n\tcase authrequest.FieldClaimsUsername:\n\t\treturn m.ClaimsUsername()\n\tcase authrequest.FieldClaimsEmail:\n\t\treturn m.ClaimsEmail()\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\treturn m.ClaimsEmailVerified()\n\tcase authrequest.FieldClaimsGroups:\n\t\treturn m.ClaimsGroups()\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\treturn m.ClaimsPreferredUsername()\n\tcase authrequest.FieldConnectorID:\n\t\treturn m.ConnectorID()\n\tcase authrequest.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\tcase authrequest.FieldExpiry:\n\t\treturn m.Expiry()\n\tcase authrequest.FieldCodeChallenge:\n\t\treturn m.CodeChallenge()\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\treturn m.CodeChallengeMethod()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *AuthRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase authrequest.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase authrequest.FieldResponseTypes:\n\t\treturn m.OldResponseTypes(ctx)\n\tcase authrequest.FieldRedirectURI:\n\t\treturn m.OldRedirectURI(ctx)\n\tcase authrequest.FieldNonce:\n\t\treturn m.OldNonce(ctx)\n\tcase authrequest.FieldState:\n\t\treturn m.OldState(ctx)\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\treturn m.OldForceApprovalPrompt(ctx)\n\tcase authrequest.FieldLoggedIn:\n\t\treturn m.OldLoggedIn(ctx)\n\tcase authrequest.FieldClaimsUserID:\n\t\treturn m.OldClaimsUserID(ctx)\n\tcase authrequest.FieldClaimsUsername:\n\t\treturn m.OldClaimsUsername(ctx)\n\tcase authrequest.FieldClaimsEmail:\n\t\treturn m.OldClaimsEmail(ctx)\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\treturn m.OldClaimsEmailVerified(ctx)\n\tcase authrequest.FieldClaimsGroups:\n\t\treturn m.OldClaimsGroups(ctx)\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\treturn m.OldClaimsPreferredUsername(ctx)\n\tcase authrequest.FieldConnectorID:\n\t\treturn m.OldConnectorID(ctx)\n\tcase authrequest.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\tcase authrequest.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\tcase authrequest.FieldCodeChallenge:\n\t\treturn m.OldCodeChallenge(ctx)\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\treturn m.OldCodeChallengeMethod(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown AuthRequest field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthRequestMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase authrequest.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase authrequest.FieldResponseTypes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetResponseTypes(v)\n\t\treturn nil\n\tcase authrequest.FieldRedirectURI:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRedirectURI(v)\n\t\treturn nil\n\tcase authrequest.FieldNonce:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNonce(v)\n\t\treturn nil\n\tcase authrequest.FieldState:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetState(v)\n\t\treturn nil\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetForceApprovalPrompt(v)\n\t\treturn nil\n\tcase authrequest.FieldLoggedIn:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLoggedIn(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUserID(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUsername(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmail(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmailVerified(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsGroups:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsGroups(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsPreferredUsername(v)\n\t\treturn nil\n\tcase authrequest.FieldConnectorID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorID(v)\n\t\treturn nil\n\tcase authrequest.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\tcase authrequest.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\tcase authrequest.FieldCodeChallenge:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallenge(v)\n\t\treturn nil\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallengeMethod(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *AuthRequestMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *AuthRequestMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthRequestMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *AuthRequestMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(authrequest.FieldScopes) {\n\t\tfields = append(fields, authrequest.FieldScopes)\n\t}\n\tif m.FieldCleared(authrequest.FieldResponseTypes) {\n\t\tfields = append(fields, authrequest.FieldResponseTypes)\n\t}\n\tif m.FieldCleared(authrequest.FieldClaimsGroups) {\n\t\tfields = append(fields, authrequest.FieldClaimsGroups)\n\t}\n\tif m.FieldCleared(authrequest.FieldConnectorData) {\n\t\tfields = append(fields, authrequest.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *AuthRequestMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *AuthRequestMutation) ClearField(name string) error {\n\tswitch name {\n\tcase authrequest.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\tcase authrequest.FieldResponseTypes:\n\t\tm.ClearResponseTypes()\n\t\treturn nil\n\tcase authrequest.FieldClaimsGroups:\n\t\tm.ClearClaimsGroups()\n\t\treturn nil\n\tcase authrequest.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *AuthRequestMutation) ResetField(name string) error {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase authrequest.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase authrequest.FieldResponseTypes:\n\t\tm.ResetResponseTypes()\n\t\treturn nil\n\tcase authrequest.FieldRedirectURI:\n\t\tm.ResetRedirectURI()\n\t\treturn nil\n\tcase authrequest.FieldNonce:\n\t\tm.ResetNonce()\n\t\treturn nil\n\tcase authrequest.FieldState:\n\t\tm.ResetState()\n\t\treturn nil\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\tm.ResetForceApprovalPrompt()\n\t\treturn nil\n\tcase authrequest.FieldLoggedIn:\n\t\tm.ResetLoggedIn()\n\t\treturn nil\n\tcase authrequest.FieldClaimsUserID:\n\t\tm.ResetClaimsUserID()\n\t\treturn nil\n\tcase authrequest.FieldClaimsUsername:\n\t\tm.ResetClaimsUsername()\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmail:\n\t\tm.ResetClaimsEmail()\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\tm.ResetClaimsEmailVerified()\n\t\treturn nil\n\tcase authrequest.FieldClaimsGroups:\n\t\tm.ResetClaimsGroups()\n\t\treturn nil\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\tm.ResetClaimsPreferredUsername()\n\t\treturn nil\n\tcase authrequest.FieldConnectorID:\n\t\tm.ResetConnectorID()\n\t\treturn nil\n\tcase authrequest.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\tcase authrequest.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\tcase authrequest.FieldCodeChallenge:\n\t\tm.ResetCodeChallenge()\n\t\treturn nil\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\tm.ResetCodeChallengeMethod()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *AuthRequestMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *AuthRequestMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *AuthRequestMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *AuthRequestMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *AuthRequestMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *AuthRequestMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *AuthRequestMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthRequest unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *AuthRequestMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthRequest edge %s\", name)\n}\n\n// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.\ntype ConnectorMutation struct {\n\tconfig\n\top               Op\n\ttyp              string\n\tid               *string\n\t_type            *string\n\tname             *string\n\tresource_version *string\n\t_config          *[]byte\n\tclearedFields    map[string]struct{}\n\tdone             bool\n\toldValue         func(context.Context) (*Connector, error)\n\tpredicates       []predicate.Connector\n}\n\nvar _ ent.Mutation = (*ConnectorMutation)(nil)\n\n// connectorOption allows management of the mutation configuration using functional options.\ntype connectorOption func(*ConnectorMutation)\n\n// newConnectorMutation creates new mutation for the Connector entity.\nfunc newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {\n\tm := &ConnectorMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeConnector,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withConnectorID sets the ID field of the mutation.\nfunc withConnectorID(id string) connectorOption {\n\treturn func(m *ConnectorMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Connector\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Connector, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Connector.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withConnector sets the old Connector of the mutation.\nfunc withConnector(node *Connector) connectorOption {\n\treturn func(m *ConnectorMutation) {\n\t\tm.oldValue = func(context.Context) (*Connector, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m ConnectorMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m ConnectorMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of Connector entities.\nfunc (m *ConnectorMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *ConnectorMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *ConnectorMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetType sets the \"type\" field.\nfunc (m *ConnectorMutation) SetType(s string) {\n\tm._type = &s\n}\n\n// GetType returns the value of the \"type\" field in the mutation.\nfunc (m *ConnectorMutation) GetType() (r string, exists bool) {\n\tv := m._type\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldType returns the old \"type\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldType(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldType is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldType requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldType: %w\", err)\n\t}\n\treturn oldValue.Type, nil\n}\n\n// ResetType resets all changes to the \"type\" field.\nfunc (m *ConnectorMutation) ResetType() {\n\tm._type = nil\n}\n\n// SetName sets the \"name\" field.\nfunc (m *ConnectorMutation) SetName(s string) {\n\tm.name = &s\n}\n\n// Name returns the value of the \"name\" field in the mutation.\nfunc (m *ConnectorMutation) Name() (r string, exists bool) {\n\tv := m.name\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldName returns the old \"name\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldName(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldName is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldName requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldName: %w\", err)\n\t}\n\treturn oldValue.Name, nil\n}\n\n// ResetName resets all changes to the \"name\" field.\nfunc (m *ConnectorMutation) ResetName() {\n\tm.name = nil\n}\n\n// SetResourceVersion sets the \"resource_version\" field.\nfunc (m *ConnectorMutation) SetResourceVersion(s string) {\n\tm.resource_version = &s\n}\n\n// ResourceVersion returns the value of the \"resource_version\" field in the mutation.\nfunc (m *ConnectorMutation) ResourceVersion() (r string, exists bool) {\n\tv := m.resource_version\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldResourceVersion returns the old \"resource_version\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldResourceVersion(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldResourceVersion is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldResourceVersion requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldResourceVersion: %w\", err)\n\t}\n\treturn oldValue.ResourceVersion, nil\n}\n\n// ResetResourceVersion resets all changes to the \"resource_version\" field.\nfunc (m *ConnectorMutation) ResetResourceVersion() {\n\tm.resource_version = nil\n}\n\n// SetConfig sets the \"config\" field.\nfunc (m *ConnectorMutation) SetConfig(b []byte) {\n\tm._config = &b\n}\n\n// Config returns the value of the \"config\" field in the mutation.\nfunc (m *ConnectorMutation) Config() (r []byte, exists bool) {\n\tv := m._config\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConfig returns the old \"config\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldConfig(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConfig is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConfig requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConfig: %w\", err)\n\t}\n\treturn oldValue.Config, nil\n}\n\n// ResetConfig resets all changes to the \"config\" field.\nfunc (m *ConnectorMutation) ResetConfig() {\n\tm._config = nil\n}\n\n// Where appends a list predicates to the ConnectorMutation builder.\nfunc (m *ConnectorMutation) Where(ps ...predicate.Connector) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *ConnectorMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (Connector).\nfunc (m *ConnectorMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *ConnectorMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m._type != nil {\n\t\tfields = append(fields, connector.FieldType)\n\t}\n\tif m.name != nil {\n\t\tfields = append(fields, connector.FieldName)\n\t}\n\tif m.resource_version != nil {\n\t\tfields = append(fields, connector.FieldResourceVersion)\n\t}\n\tif m._config != nil {\n\t\tfields = append(fields, connector.FieldConfig)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *ConnectorMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase connector.FieldType:\n\t\treturn m.GetType()\n\tcase connector.FieldName:\n\t\treturn m.Name()\n\tcase connector.FieldResourceVersion:\n\t\treturn m.ResourceVersion()\n\tcase connector.FieldConfig:\n\t\treturn m.Config()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase connector.FieldType:\n\t\treturn m.OldType(ctx)\n\tcase connector.FieldName:\n\t\treturn m.OldName(ctx)\n\tcase connector.FieldResourceVersion:\n\t\treturn m.OldResourceVersion(ctx)\n\tcase connector.FieldConfig:\n\t\treturn m.OldConfig(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown Connector field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *ConnectorMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase connector.FieldType:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetType(v)\n\t\treturn nil\n\tcase connector.FieldName:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetName(v)\n\t\treturn nil\n\tcase connector.FieldResourceVersion:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetResourceVersion(v)\n\t\treturn nil\n\tcase connector.FieldConfig:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConfig(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Connector field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *ConnectorMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *ConnectorMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown Connector numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *ConnectorMutation) ClearedFields() []string {\n\treturn nil\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *ConnectorMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *ConnectorMutation) ClearField(name string) error {\n\treturn fmt.Errorf(\"unknown Connector nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *ConnectorMutation) ResetField(name string) error {\n\tswitch name {\n\tcase connector.FieldType:\n\t\tm.ResetType()\n\t\treturn nil\n\tcase connector.FieldName:\n\t\tm.ResetName()\n\t\treturn nil\n\tcase connector.FieldResourceVersion:\n\t\tm.ResetResourceVersion()\n\t\treturn nil\n\tcase connector.FieldConfig:\n\t\tm.ResetConfig()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Connector field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *ConnectorMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *ConnectorMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *ConnectorMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *ConnectorMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *ConnectorMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *ConnectorMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Connector unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *ConnectorMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Connector edge %s\", name)\n}\n\n// DeviceRequestMutation represents an operation that mutates the DeviceRequest nodes in the graph.\ntype DeviceRequestMutation struct {\n\tconfig\n\top            Op\n\ttyp           string\n\tid            *int\n\tuser_code     *string\n\tdevice_code   *string\n\tclient_id     *string\n\tclient_secret *string\n\tscopes        *[]string\n\texpiry        *time.Time\n\tclearedFields map[string]struct{}\n\tdone          bool\n\toldValue      func(context.Context) (*DeviceRequest, error)\n\tpredicates    []predicate.DeviceRequest\n}\n\nvar _ ent.Mutation = (*DeviceRequestMutation)(nil)\n\n// devicerequestOption allows management of the mutation configuration using functional options.\ntype devicerequestOption func(*DeviceRequestMutation)\n\n// newDeviceRequestMutation creates new mutation for the DeviceRequest entity.\nfunc newDeviceRequestMutation(c config, op Op, opts ...devicerequestOption) *DeviceRequestMutation {\n\tm := &DeviceRequestMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeDeviceRequest,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withDeviceRequestID sets the ID field of the mutation.\nfunc withDeviceRequestID(id int) devicerequestOption {\n\treturn func(m *DeviceRequestMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *DeviceRequest\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*DeviceRequest, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().DeviceRequest.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withDeviceRequest sets the old DeviceRequest of the mutation.\nfunc withDeviceRequest(node *DeviceRequest) devicerequestOption {\n\treturn func(m *DeviceRequestMutation) {\n\t\tm.oldValue = func(context.Context) (*DeviceRequest, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m DeviceRequestMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m DeviceRequestMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *DeviceRequestMutation) ID() (id int, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *DeviceRequestMutation) IDs(ctx context.Context) ([]int, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []int{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().DeviceRequest.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetUserCode sets the \"user_code\" field.\nfunc (m *DeviceRequestMutation) SetUserCode(s string) {\n\tm.user_code = &s\n}\n\n// UserCode returns the value of the \"user_code\" field in the mutation.\nfunc (m *DeviceRequestMutation) UserCode() (r string, exists bool) {\n\tv := m.user_code\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUserCode returns the old \"user_code\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldUserCode(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUserCode is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUserCode requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUserCode: %w\", err)\n\t}\n\treturn oldValue.UserCode, nil\n}\n\n// ResetUserCode resets all changes to the \"user_code\" field.\nfunc (m *DeviceRequestMutation) ResetUserCode() {\n\tm.user_code = nil\n}\n\n// SetDeviceCode sets the \"device_code\" field.\nfunc (m *DeviceRequestMutation) SetDeviceCode(s string) {\n\tm.device_code = &s\n}\n\n// DeviceCode returns the value of the \"device_code\" field in the mutation.\nfunc (m *DeviceRequestMutation) DeviceCode() (r string, exists bool) {\n\tv := m.device_code\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldDeviceCode returns the old \"device_code\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldDeviceCode(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldDeviceCode is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldDeviceCode requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldDeviceCode: %w\", err)\n\t}\n\treturn oldValue.DeviceCode, nil\n}\n\n// ResetDeviceCode resets all changes to the \"device_code\" field.\nfunc (m *DeviceRequestMutation) ResetDeviceCode() {\n\tm.device_code = nil\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *DeviceRequestMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *DeviceRequestMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *DeviceRequestMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetClientSecret sets the \"client_secret\" field.\nfunc (m *DeviceRequestMutation) SetClientSecret(s string) {\n\tm.client_secret = &s\n}\n\n// ClientSecret returns the value of the \"client_secret\" field in the mutation.\nfunc (m *DeviceRequestMutation) ClientSecret() (r string, exists bool) {\n\tv := m.client_secret\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientSecret returns the old \"client_secret\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldClientSecret(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientSecret is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientSecret requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientSecret: %w\", err)\n\t}\n\treturn oldValue.ClientSecret, nil\n}\n\n// ResetClientSecret resets all changes to the \"client_secret\" field.\nfunc (m *DeviceRequestMutation) ResetClientSecret() {\n\tm.client_secret = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *DeviceRequestMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *DeviceRequestMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *DeviceRequestMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[devicerequest.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *DeviceRequestMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[devicerequest.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *DeviceRequestMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, devicerequest.FieldScopes)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *DeviceRequestMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *DeviceRequestMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *DeviceRequestMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// Where appends a list predicates to the DeviceRequestMutation builder.\nfunc (m *DeviceRequestMutation) Where(ps ...predicate.DeviceRequest) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *DeviceRequestMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (DeviceRequest).\nfunc (m *DeviceRequestMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *DeviceRequestMutation) Fields() []string {\n\tfields := make([]string, 0, 6)\n\tif m.user_code != nil {\n\t\tfields = append(fields, devicerequest.FieldUserCode)\n\t}\n\tif m.device_code != nil {\n\t\tfields = append(fields, devicerequest.FieldDeviceCode)\n\t}\n\tif m.client_id != nil {\n\t\tfields = append(fields, devicerequest.FieldClientID)\n\t}\n\tif m.client_secret != nil {\n\t\tfields = append(fields, devicerequest.FieldClientSecret)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, devicerequest.FieldScopes)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, devicerequest.FieldExpiry)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *DeviceRequestMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\treturn m.UserCode()\n\tcase devicerequest.FieldDeviceCode:\n\t\treturn m.DeviceCode()\n\tcase devicerequest.FieldClientID:\n\t\treturn m.ClientID()\n\tcase devicerequest.FieldClientSecret:\n\t\treturn m.ClientSecret()\n\tcase devicerequest.FieldScopes:\n\t\treturn m.Scopes()\n\tcase devicerequest.FieldExpiry:\n\t\treturn m.Expiry()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *DeviceRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\treturn m.OldUserCode(ctx)\n\tcase devicerequest.FieldDeviceCode:\n\t\treturn m.OldDeviceCode(ctx)\n\tcase devicerequest.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase devicerequest.FieldClientSecret:\n\t\treturn m.OldClientSecret(ctx)\n\tcase devicerequest.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase devicerequest.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown DeviceRequest field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceRequestMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUserCode(v)\n\t\treturn nil\n\tcase devicerequest.FieldDeviceCode:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetDeviceCode(v)\n\t\treturn nil\n\tcase devicerequest.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase devicerequest.FieldClientSecret:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientSecret(v)\n\t\treturn nil\n\tcase devicerequest.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase devicerequest.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *DeviceRequestMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *DeviceRequestMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceRequestMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *DeviceRequestMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(devicerequest.FieldScopes) {\n\t\tfields = append(fields, devicerequest.FieldScopes)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *DeviceRequestMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *DeviceRequestMutation) ClearField(name string) error {\n\tswitch name {\n\tcase devicerequest.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *DeviceRequestMutation) ResetField(name string) error {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\tm.ResetUserCode()\n\t\treturn nil\n\tcase devicerequest.FieldDeviceCode:\n\t\tm.ResetDeviceCode()\n\t\treturn nil\n\tcase devicerequest.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase devicerequest.FieldClientSecret:\n\t\tm.ResetClientSecret()\n\t\treturn nil\n\tcase devicerequest.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase devicerequest.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *DeviceRequestMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *DeviceRequestMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *DeviceRequestMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *DeviceRequestMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *DeviceRequestMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *DeviceRequestMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *DeviceRequestMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceRequest unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *DeviceRequestMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceRequest edge %s\", name)\n}\n\n// DeviceTokenMutation represents an operation that mutates the DeviceToken nodes in the graph.\ntype DeviceTokenMutation struct {\n\tconfig\n\top                    Op\n\ttyp                   string\n\tid                    *int\n\tdevice_code           *string\n\tstatus                *string\n\ttoken                 *[]byte\n\texpiry                *time.Time\n\tlast_request          *time.Time\n\tpoll_interval         *int\n\taddpoll_interval      *int\n\tcode_challenge        *string\n\tcode_challenge_method *string\n\tclearedFields         map[string]struct{}\n\tdone                  bool\n\toldValue              func(context.Context) (*DeviceToken, error)\n\tpredicates            []predicate.DeviceToken\n}\n\nvar _ ent.Mutation = (*DeviceTokenMutation)(nil)\n\n// devicetokenOption allows management of the mutation configuration using functional options.\ntype devicetokenOption func(*DeviceTokenMutation)\n\n// newDeviceTokenMutation creates new mutation for the DeviceToken entity.\nfunc newDeviceTokenMutation(c config, op Op, opts ...devicetokenOption) *DeviceTokenMutation {\n\tm := &DeviceTokenMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeDeviceToken,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withDeviceTokenID sets the ID field of the mutation.\nfunc withDeviceTokenID(id int) devicetokenOption {\n\treturn func(m *DeviceTokenMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *DeviceToken\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*DeviceToken, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().DeviceToken.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withDeviceToken sets the old DeviceToken of the mutation.\nfunc withDeviceToken(node *DeviceToken) devicetokenOption {\n\treturn func(m *DeviceTokenMutation) {\n\t\tm.oldValue = func(context.Context) (*DeviceToken, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m DeviceTokenMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m DeviceTokenMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *DeviceTokenMutation) ID() (id int, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *DeviceTokenMutation) IDs(ctx context.Context) ([]int, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []int{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().DeviceToken.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetDeviceCode sets the \"device_code\" field.\nfunc (m *DeviceTokenMutation) SetDeviceCode(s string) {\n\tm.device_code = &s\n}\n\n// DeviceCode returns the value of the \"device_code\" field in the mutation.\nfunc (m *DeviceTokenMutation) DeviceCode() (r string, exists bool) {\n\tv := m.device_code\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldDeviceCode returns the old \"device_code\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldDeviceCode(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldDeviceCode is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldDeviceCode requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldDeviceCode: %w\", err)\n\t}\n\treturn oldValue.DeviceCode, nil\n}\n\n// ResetDeviceCode resets all changes to the \"device_code\" field.\nfunc (m *DeviceTokenMutation) ResetDeviceCode() {\n\tm.device_code = nil\n}\n\n// SetStatus sets the \"status\" field.\nfunc (m *DeviceTokenMutation) SetStatus(s string) {\n\tm.status = &s\n}\n\n// Status returns the value of the \"status\" field in the mutation.\nfunc (m *DeviceTokenMutation) Status() (r string, exists bool) {\n\tv := m.status\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldStatus returns the old \"status\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldStatus(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldStatus is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldStatus requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldStatus: %w\", err)\n\t}\n\treturn oldValue.Status, nil\n}\n\n// ResetStatus resets all changes to the \"status\" field.\nfunc (m *DeviceTokenMutation) ResetStatus() {\n\tm.status = nil\n}\n\n// SetToken sets the \"token\" field.\nfunc (m *DeviceTokenMutation) SetToken(b []byte) {\n\tm.token = &b\n}\n\n// Token returns the value of the \"token\" field in the mutation.\nfunc (m *DeviceTokenMutation) Token() (r []byte, exists bool) {\n\tv := m.token\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldToken returns the old \"token\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldToken(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldToken is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldToken requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldToken: %w\", err)\n\t}\n\treturn oldValue.Token, nil\n}\n\n// ClearToken clears the value of the \"token\" field.\nfunc (m *DeviceTokenMutation) ClearToken() {\n\tm.token = nil\n\tm.clearedFields[devicetoken.FieldToken] = struct{}{}\n}\n\n// TokenCleared returns if the \"token\" field was cleared in this mutation.\nfunc (m *DeviceTokenMutation) TokenCleared() bool {\n\t_, ok := m.clearedFields[devicetoken.FieldToken]\n\treturn ok\n}\n\n// ResetToken resets all changes to the \"token\" field.\nfunc (m *DeviceTokenMutation) ResetToken() {\n\tm.token = nil\n\tdelete(m.clearedFields, devicetoken.FieldToken)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *DeviceTokenMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *DeviceTokenMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *DeviceTokenMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// SetLastRequest sets the \"last_request\" field.\nfunc (m *DeviceTokenMutation) SetLastRequest(t time.Time) {\n\tm.last_request = &t\n}\n\n// LastRequest returns the value of the \"last_request\" field in the mutation.\nfunc (m *DeviceTokenMutation) LastRequest() (r time.Time, exists bool) {\n\tv := m.last_request\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLastRequest returns the old \"last_request\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldLastRequest(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLastRequest is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLastRequest requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLastRequest: %w\", err)\n\t}\n\treturn oldValue.LastRequest, nil\n}\n\n// ResetLastRequest resets all changes to the \"last_request\" field.\nfunc (m *DeviceTokenMutation) ResetLastRequest() {\n\tm.last_request = nil\n}\n\n// SetPollInterval sets the \"poll_interval\" field.\nfunc (m *DeviceTokenMutation) SetPollInterval(i int) {\n\tm.poll_interval = &i\n\tm.addpoll_interval = nil\n}\n\n// PollInterval returns the value of the \"poll_interval\" field in the mutation.\nfunc (m *DeviceTokenMutation) PollInterval() (r int, exists bool) {\n\tv := m.poll_interval\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldPollInterval returns the old \"poll_interval\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldPollInterval(ctx context.Context) (v int, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldPollInterval is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldPollInterval requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldPollInterval: %w\", err)\n\t}\n\treturn oldValue.PollInterval, nil\n}\n\n// AddPollInterval adds i to the \"poll_interval\" field.\nfunc (m *DeviceTokenMutation) AddPollInterval(i int) {\n\tif m.addpoll_interval != nil {\n\t\t*m.addpoll_interval += i\n\t} else {\n\t\tm.addpoll_interval = &i\n\t}\n}\n\n// AddedPollInterval returns the value that was added to the \"poll_interval\" field in this mutation.\nfunc (m *DeviceTokenMutation) AddedPollInterval() (r int, exists bool) {\n\tv := m.addpoll_interval\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// ResetPollInterval resets all changes to the \"poll_interval\" field.\nfunc (m *DeviceTokenMutation) ResetPollInterval() {\n\tm.poll_interval = nil\n\tm.addpoll_interval = nil\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (m *DeviceTokenMutation) SetCodeChallenge(s string) {\n\tm.code_challenge = &s\n}\n\n// CodeChallenge returns the value of the \"code_challenge\" field in the mutation.\nfunc (m *DeviceTokenMutation) CodeChallenge() (r string, exists bool) {\n\tv := m.code_challenge\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallenge returns the old \"code_challenge\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallenge is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallenge requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallenge: %w\", err)\n\t}\n\treturn oldValue.CodeChallenge, nil\n}\n\n// ResetCodeChallenge resets all changes to the \"code_challenge\" field.\nfunc (m *DeviceTokenMutation) ResetCodeChallenge() {\n\tm.code_challenge = nil\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (m *DeviceTokenMutation) SetCodeChallengeMethod(s string) {\n\tm.code_challenge_method = &s\n}\n\n// CodeChallengeMethod returns the value of the \"code_challenge_method\" field in the mutation.\nfunc (m *DeviceTokenMutation) CodeChallengeMethod() (r string, exists bool) {\n\tv := m.code_challenge_method\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallengeMethod returns the old \"code_challenge_method\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallengeMethod: %w\", err)\n\t}\n\treturn oldValue.CodeChallengeMethod, nil\n}\n\n// ResetCodeChallengeMethod resets all changes to the \"code_challenge_method\" field.\nfunc (m *DeviceTokenMutation) ResetCodeChallengeMethod() {\n\tm.code_challenge_method = nil\n}\n\n// Where appends a list predicates to the DeviceTokenMutation builder.\nfunc (m *DeviceTokenMutation) Where(ps ...predicate.DeviceToken) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *DeviceTokenMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (DeviceToken).\nfunc (m *DeviceTokenMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *DeviceTokenMutation) Fields() []string {\n\tfields := make([]string, 0, 8)\n\tif m.device_code != nil {\n\t\tfields = append(fields, devicetoken.FieldDeviceCode)\n\t}\n\tif m.status != nil {\n\t\tfields = append(fields, devicetoken.FieldStatus)\n\t}\n\tif m.token != nil {\n\t\tfields = append(fields, devicetoken.FieldToken)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, devicetoken.FieldExpiry)\n\t}\n\tif m.last_request != nil {\n\t\tfields = append(fields, devicetoken.FieldLastRequest)\n\t}\n\tif m.poll_interval != nil {\n\t\tfields = append(fields, devicetoken.FieldPollInterval)\n\t}\n\tif m.code_challenge != nil {\n\t\tfields = append(fields, devicetoken.FieldCodeChallenge)\n\t}\n\tif m.code_challenge_method != nil {\n\t\tfields = append(fields, devicetoken.FieldCodeChallengeMethod)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *DeviceTokenMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\treturn m.DeviceCode()\n\tcase devicetoken.FieldStatus:\n\t\treturn m.Status()\n\tcase devicetoken.FieldToken:\n\t\treturn m.Token()\n\tcase devicetoken.FieldExpiry:\n\t\treturn m.Expiry()\n\tcase devicetoken.FieldLastRequest:\n\t\treturn m.LastRequest()\n\tcase devicetoken.FieldPollInterval:\n\t\treturn m.PollInterval()\n\tcase devicetoken.FieldCodeChallenge:\n\t\treturn m.CodeChallenge()\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\treturn m.CodeChallengeMethod()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *DeviceTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\treturn m.OldDeviceCode(ctx)\n\tcase devicetoken.FieldStatus:\n\t\treturn m.OldStatus(ctx)\n\tcase devicetoken.FieldToken:\n\t\treturn m.OldToken(ctx)\n\tcase devicetoken.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\tcase devicetoken.FieldLastRequest:\n\t\treturn m.OldLastRequest(ctx)\n\tcase devicetoken.FieldPollInterval:\n\t\treturn m.OldPollInterval(ctx)\n\tcase devicetoken.FieldCodeChallenge:\n\t\treturn m.OldCodeChallenge(ctx)\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\treturn m.OldCodeChallengeMethod(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown DeviceToken field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceTokenMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetDeviceCode(v)\n\t\treturn nil\n\tcase devicetoken.FieldStatus:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetStatus(v)\n\t\treturn nil\n\tcase devicetoken.FieldToken:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetToken(v)\n\t\treturn nil\n\tcase devicetoken.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\tcase devicetoken.FieldLastRequest:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLastRequest(v)\n\t\treturn nil\n\tcase devicetoken.FieldPollInterval:\n\t\tv, ok := value.(int)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetPollInterval(v)\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallenge:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallenge(v)\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallengeMethod(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *DeviceTokenMutation) AddedFields() []string {\n\tvar fields []string\n\tif m.addpoll_interval != nil {\n\t\tfields = append(fields, devicetoken.FieldPollInterval)\n\t}\n\treturn fields\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *DeviceTokenMutation) AddedField(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase devicetoken.FieldPollInterval:\n\t\treturn m.AddedPollInterval()\n\t}\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceTokenMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\tcase devicetoken.FieldPollInterval:\n\t\tv, ok := value.(int)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.AddPollInterval(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *DeviceTokenMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(devicetoken.FieldToken) {\n\t\tfields = append(fields, devicetoken.FieldToken)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *DeviceTokenMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *DeviceTokenMutation) ClearField(name string) error {\n\tswitch name {\n\tcase devicetoken.FieldToken:\n\t\tm.ClearToken()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *DeviceTokenMutation) ResetField(name string) error {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\tm.ResetDeviceCode()\n\t\treturn nil\n\tcase devicetoken.FieldStatus:\n\t\tm.ResetStatus()\n\t\treturn nil\n\tcase devicetoken.FieldToken:\n\t\tm.ResetToken()\n\t\treturn nil\n\tcase devicetoken.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\tcase devicetoken.FieldLastRequest:\n\t\tm.ResetLastRequest()\n\t\treturn nil\n\tcase devicetoken.FieldPollInterval:\n\t\tm.ResetPollInterval()\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallenge:\n\t\tm.ResetCodeChallenge()\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\tm.ResetCodeChallengeMethod()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *DeviceTokenMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *DeviceTokenMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *DeviceTokenMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *DeviceTokenMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *DeviceTokenMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *DeviceTokenMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *DeviceTokenMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceToken unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *DeviceTokenMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceToken edge %s\", name)\n}\n\n// KeysMutation represents an operation that mutates the Keys nodes in the graph.\ntype KeysMutation struct {\n\tconfig\n\top                Op\n\ttyp               string\n\tid                *string\n\tverification_keys *[]storage.VerificationKey\n\tsigning_key       *jose.JSONWebKey\n\tsigning_key_pub   *jose.JSONWebKey\n\tnext_rotation     *time.Time\n\tclearedFields     map[string]struct{}\n\tdone              bool\n\toldValue          func(context.Context) (*Keys, error)\n\tpredicates        []predicate.Keys\n}\n\nvar _ ent.Mutation = (*KeysMutation)(nil)\n\n// keysOption allows management of the mutation configuration using functional options.\ntype keysOption func(*KeysMutation)\n\n// newKeysMutation creates new mutation for the Keys entity.\nfunc newKeysMutation(c config, op Op, opts ...keysOption) *KeysMutation {\n\tm := &KeysMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeKeys,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withKeysID sets the ID field of the mutation.\nfunc withKeysID(id string) keysOption {\n\treturn func(m *KeysMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Keys\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Keys, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Keys.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withKeys sets the old Keys of the mutation.\nfunc withKeys(node *Keys) keysOption {\n\treturn func(m *KeysMutation) {\n\t\tm.oldValue = func(context.Context) (*Keys, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m KeysMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m KeysMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of Keys entities.\nfunc (m *KeysMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *KeysMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *KeysMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().Keys.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetVerificationKeys sets the \"verification_keys\" field.\nfunc (m *KeysMutation) SetVerificationKeys(sk []storage.VerificationKey) {\n\tm.verification_keys = &sk\n}\n\n// VerificationKeys returns the value of the \"verification_keys\" field in the mutation.\nfunc (m *KeysMutation) VerificationKeys() (r []storage.VerificationKey, exists bool) {\n\tv := m.verification_keys\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldVerificationKeys returns the old \"verification_keys\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldVerificationKeys(ctx context.Context) (v []storage.VerificationKey, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldVerificationKeys is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldVerificationKeys requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldVerificationKeys: %w\", err)\n\t}\n\treturn oldValue.VerificationKeys, nil\n}\n\n// ResetVerificationKeys resets all changes to the \"verification_keys\" field.\nfunc (m *KeysMutation) ResetVerificationKeys() {\n\tm.verification_keys = nil\n}\n\n// SetSigningKey sets the \"signing_key\" field.\nfunc (m *KeysMutation) SetSigningKey(jwk jose.JSONWebKey) {\n\tm.signing_key = &jwk\n}\n\n// SigningKey returns the value of the \"signing_key\" field in the mutation.\nfunc (m *KeysMutation) SigningKey() (r jose.JSONWebKey, exists bool) {\n\tv := m.signing_key\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldSigningKey returns the old \"signing_key\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldSigningKey(ctx context.Context) (v jose.JSONWebKey, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldSigningKey is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldSigningKey requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldSigningKey: %w\", err)\n\t}\n\treturn oldValue.SigningKey, nil\n}\n\n// ResetSigningKey resets all changes to the \"signing_key\" field.\nfunc (m *KeysMutation) ResetSigningKey() {\n\tm.signing_key = nil\n}\n\n// SetSigningKeyPub sets the \"signing_key_pub\" field.\nfunc (m *KeysMutation) SetSigningKeyPub(jwk jose.JSONWebKey) {\n\tm.signing_key_pub = &jwk\n}\n\n// SigningKeyPub returns the value of the \"signing_key_pub\" field in the mutation.\nfunc (m *KeysMutation) SigningKeyPub() (r jose.JSONWebKey, exists bool) {\n\tv := m.signing_key_pub\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldSigningKeyPub returns the old \"signing_key_pub\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldSigningKeyPub(ctx context.Context) (v jose.JSONWebKey, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldSigningKeyPub is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldSigningKeyPub requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldSigningKeyPub: %w\", err)\n\t}\n\treturn oldValue.SigningKeyPub, nil\n}\n\n// ResetSigningKeyPub resets all changes to the \"signing_key_pub\" field.\nfunc (m *KeysMutation) ResetSigningKeyPub() {\n\tm.signing_key_pub = nil\n}\n\n// SetNextRotation sets the \"next_rotation\" field.\nfunc (m *KeysMutation) SetNextRotation(t time.Time) {\n\tm.next_rotation = &t\n}\n\n// NextRotation returns the value of the \"next_rotation\" field in the mutation.\nfunc (m *KeysMutation) NextRotation() (r time.Time, exists bool) {\n\tv := m.next_rotation\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNextRotation returns the old \"next_rotation\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldNextRotation(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNextRotation is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNextRotation requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNextRotation: %w\", err)\n\t}\n\treturn oldValue.NextRotation, nil\n}\n\n// ResetNextRotation resets all changes to the \"next_rotation\" field.\nfunc (m *KeysMutation) ResetNextRotation() {\n\tm.next_rotation = nil\n}\n\n// Where appends a list predicates to the KeysMutation builder.\nfunc (m *KeysMutation) Where(ps ...predicate.Keys) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *KeysMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (Keys).\nfunc (m *KeysMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *KeysMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m.verification_keys != nil {\n\t\tfields = append(fields, keys.FieldVerificationKeys)\n\t}\n\tif m.signing_key != nil {\n\t\tfields = append(fields, keys.FieldSigningKey)\n\t}\n\tif m.signing_key_pub != nil {\n\t\tfields = append(fields, keys.FieldSigningKeyPub)\n\t}\n\tif m.next_rotation != nil {\n\t\tfields = append(fields, keys.FieldNextRotation)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *KeysMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\treturn m.VerificationKeys()\n\tcase keys.FieldSigningKey:\n\t\treturn m.SigningKey()\n\tcase keys.FieldSigningKeyPub:\n\t\treturn m.SigningKeyPub()\n\tcase keys.FieldNextRotation:\n\t\treturn m.NextRotation()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *KeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\treturn m.OldVerificationKeys(ctx)\n\tcase keys.FieldSigningKey:\n\t\treturn m.OldSigningKey(ctx)\n\tcase keys.FieldSigningKeyPub:\n\t\treturn m.OldSigningKeyPub(ctx)\n\tcase keys.FieldNextRotation:\n\t\treturn m.OldNextRotation(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown Keys field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *KeysMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\tv, ok := value.([]storage.VerificationKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetVerificationKeys(v)\n\t\treturn nil\n\tcase keys.FieldSigningKey:\n\t\tv, ok := value.(jose.JSONWebKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetSigningKey(v)\n\t\treturn nil\n\tcase keys.FieldSigningKeyPub:\n\t\tv, ok := value.(jose.JSONWebKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetSigningKeyPub(v)\n\t\treturn nil\n\tcase keys.FieldNextRotation:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNextRotation(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Keys field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *KeysMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *KeysMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *KeysMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown Keys numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *KeysMutation) ClearedFields() []string {\n\treturn nil\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *KeysMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *KeysMutation) ClearField(name string) error {\n\treturn fmt.Errorf(\"unknown Keys nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *KeysMutation) ResetField(name string) error {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\tm.ResetVerificationKeys()\n\t\treturn nil\n\tcase keys.FieldSigningKey:\n\t\tm.ResetSigningKey()\n\t\treturn nil\n\tcase keys.FieldSigningKeyPub:\n\t\tm.ResetSigningKeyPub()\n\t\treturn nil\n\tcase keys.FieldNextRotation:\n\t\tm.ResetNextRotation()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Keys field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *KeysMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *KeysMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *KeysMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *KeysMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *KeysMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *KeysMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *KeysMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Keys unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *KeysMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Keys edge %s\", name)\n}\n\n// OAuth2ClientMutation represents an operation that mutates the OAuth2Client nodes in the graph.\ntype OAuth2ClientMutation struct {\n\tconfig\n\top            Op\n\ttyp           string\n\tid            *string\n\tsecret        *string\n\tredirect_uris *[]string\n\ttrusted_peers *[]string\n\tpublic        *bool\n\tname          *string\n\tlogo_url      *string\n\tclearedFields map[string]struct{}\n\tdone          bool\n\toldValue      func(context.Context) (*OAuth2Client, error)\n\tpredicates    []predicate.OAuth2Client\n}\n\nvar _ ent.Mutation = (*OAuth2ClientMutation)(nil)\n\n// oauth2clientOption allows management of the mutation configuration using functional options.\ntype oauth2clientOption func(*OAuth2ClientMutation)\n\n// newOAuth2ClientMutation creates new mutation for the OAuth2Client entity.\nfunc newOAuth2ClientMutation(c config, op Op, opts ...oauth2clientOption) *OAuth2ClientMutation {\n\tm := &OAuth2ClientMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeOAuth2Client,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withOAuth2ClientID sets the ID field of the mutation.\nfunc withOAuth2ClientID(id string) oauth2clientOption {\n\treturn func(m *OAuth2ClientMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *OAuth2Client\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*OAuth2Client, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().OAuth2Client.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withOAuth2Client sets the old OAuth2Client of the mutation.\nfunc withOAuth2Client(node *OAuth2Client) oauth2clientOption {\n\treturn func(m *OAuth2ClientMutation) {\n\t\tm.oldValue = func(context.Context) (*OAuth2Client, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m OAuth2ClientMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m OAuth2ClientMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of OAuth2Client entities.\nfunc (m *OAuth2ClientMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *OAuth2ClientMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *OAuth2ClientMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().OAuth2Client.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetSecret sets the \"secret\" field.\nfunc (m *OAuth2ClientMutation) SetSecret(s string) {\n\tm.secret = &s\n}\n\n// Secret returns the value of the \"secret\" field in the mutation.\nfunc (m *OAuth2ClientMutation) Secret() (r string, exists bool) {\n\tv := m.secret\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldSecret returns the old \"secret\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldSecret(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldSecret is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldSecret requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldSecret: %w\", err)\n\t}\n\treturn oldValue.Secret, nil\n}\n\n// ResetSecret resets all changes to the \"secret\" field.\nfunc (m *OAuth2ClientMutation) ResetSecret() {\n\tm.secret = nil\n}\n\n// SetRedirectUris sets the \"redirect_uris\" field.\nfunc (m *OAuth2ClientMutation) SetRedirectUris(s []string) {\n\tm.redirect_uris = &s\n}\n\n// RedirectUris returns the value of the \"redirect_uris\" field in the mutation.\nfunc (m *OAuth2ClientMutation) RedirectUris() (r []string, exists bool) {\n\tv := m.redirect_uris\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRedirectUris returns the old \"redirect_uris\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRedirectUris is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRedirectUris requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRedirectUris: %w\", err)\n\t}\n\treturn oldValue.RedirectUris, nil\n}\n\n// ClearRedirectUris clears the value of the \"redirect_uris\" field.\nfunc (m *OAuth2ClientMutation) ClearRedirectUris() {\n\tm.redirect_uris = nil\n\tm.clearedFields[oauth2client.FieldRedirectUris] = struct{}{}\n}\n\n// RedirectUrisCleared returns if the \"redirect_uris\" field was cleared in this mutation.\nfunc (m *OAuth2ClientMutation) RedirectUrisCleared() bool {\n\t_, ok := m.clearedFields[oauth2client.FieldRedirectUris]\n\treturn ok\n}\n\n// ResetRedirectUris resets all changes to the \"redirect_uris\" field.\nfunc (m *OAuth2ClientMutation) ResetRedirectUris() {\n\tm.redirect_uris = nil\n\tdelete(m.clearedFields, oauth2client.FieldRedirectUris)\n}\n\n// SetTrustedPeers sets the \"trusted_peers\" field.\nfunc (m *OAuth2ClientMutation) SetTrustedPeers(s []string) {\n\tm.trusted_peers = &s\n}\n\n// TrustedPeers returns the value of the \"trusted_peers\" field in the mutation.\nfunc (m *OAuth2ClientMutation) TrustedPeers() (r []string, exists bool) {\n\tv := m.trusted_peers\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldTrustedPeers returns the old \"trusted_peers\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldTrustedPeers(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldTrustedPeers is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldTrustedPeers requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldTrustedPeers: %w\", err)\n\t}\n\treturn oldValue.TrustedPeers, nil\n}\n\n// ClearTrustedPeers clears the value of the \"trusted_peers\" field.\nfunc (m *OAuth2ClientMutation) ClearTrustedPeers() {\n\tm.trusted_peers = nil\n\tm.clearedFields[oauth2client.FieldTrustedPeers] = struct{}{}\n}\n\n// TrustedPeersCleared returns if the \"trusted_peers\" field was cleared in this mutation.\nfunc (m *OAuth2ClientMutation) TrustedPeersCleared() bool {\n\t_, ok := m.clearedFields[oauth2client.FieldTrustedPeers]\n\treturn ok\n}\n\n// ResetTrustedPeers resets all changes to the \"trusted_peers\" field.\nfunc (m *OAuth2ClientMutation) ResetTrustedPeers() {\n\tm.trusted_peers = nil\n\tdelete(m.clearedFields, oauth2client.FieldTrustedPeers)\n}\n\n// SetPublic sets the \"public\" field.\nfunc (m *OAuth2ClientMutation) SetPublic(b bool) {\n\tm.public = &b\n}\n\n// Public returns the value of the \"public\" field in the mutation.\nfunc (m *OAuth2ClientMutation) Public() (r bool, exists bool) {\n\tv := m.public\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldPublic returns the old \"public\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldPublic(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldPublic is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldPublic requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldPublic: %w\", err)\n\t}\n\treturn oldValue.Public, nil\n}\n\n// ResetPublic resets all changes to the \"public\" field.\nfunc (m *OAuth2ClientMutation) ResetPublic() {\n\tm.public = nil\n}\n\n// SetName sets the \"name\" field.\nfunc (m *OAuth2ClientMutation) SetName(s string) {\n\tm.name = &s\n}\n\n// Name returns the value of the \"name\" field in the mutation.\nfunc (m *OAuth2ClientMutation) Name() (r string, exists bool) {\n\tv := m.name\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldName returns the old \"name\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldName(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldName is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldName requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldName: %w\", err)\n\t}\n\treturn oldValue.Name, nil\n}\n\n// ResetName resets all changes to the \"name\" field.\nfunc (m *OAuth2ClientMutation) ResetName() {\n\tm.name = nil\n}\n\n// SetLogoURL sets the \"logo_url\" field.\nfunc (m *OAuth2ClientMutation) SetLogoURL(s string) {\n\tm.logo_url = &s\n}\n\n// LogoURL returns the value of the \"logo_url\" field in the mutation.\nfunc (m *OAuth2ClientMutation) LogoURL() (r string, exists bool) {\n\tv := m.logo_url\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLogoURL returns the old \"logo_url\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldLogoURL(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLogoURL is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLogoURL requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLogoURL: %w\", err)\n\t}\n\treturn oldValue.LogoURL, nil\n}\n\n// ResetLogoURL resets all changes to the \"logo_url\" field.\nfunc (m *OAuth2ClientMutation) ResetLogoURL() {\n\tm.logo_url = nil\n}\n\n// Where appends a list predicates to the OAuth2ClientMutation builder.\nfunc (m *OAuth2ClientMutation) Where(ps ...predicate.OAuth2Client) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *OAuth2ClientMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (OAuth2Client).\nfunc (m *OAuth2ClientMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *OAuth2ClientMutation) Fields() []string {\n\tfields := make([]string, 0, 6)\n\tif m.secret != nil {\n\t\tfields = append(fields, oauth2client.FieldSecret)\n\t}\n\tif m.redirect_uris != nil {\n\t\tfields = append(fields, oauth2client.FieldRedirectUris)\n\t}\n\tif m.trusted_peers != nil {\n\t\tfields = append(fields, oauth2client.FieldTrustedPeers)\n\t}\n\tif m.public != nil {\n\t\tfields = append(fields, oauth2client.FieldPublic)\n\t}\n\tif m.name != nil {\n\t\tfields = append(fields, oauth2client.FieldName)\n\t}\n\tif m.logo_url != nil {\n\t\tfields = append(fields, oauth2client.FieldLogoURL)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *OAuth2ClientMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\treturn m.Secret()\n\tcase oauth2client.FieldRedirectUris:\n\t\treturn m.RedirectUris()\n\tcase oauth2client.FieldTrustedPeers:\n\t\treturn m.TrustedPeers()\n\tcase oauth2client.FieldPublic:\n\t\treturn m.Public()\n\tcase oauth2client.FieldName:\n\t\treturn m.Name()\n\tcase oauth2client.FieldLogoURL:\n\t\treturn m.LogoURL()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *OAuth2ClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\treturn m.OldSecret(ctx)\n\tcase oauth2client.FieldRedirectUris:\n\t\treturn m.OldRedirectUris(ctx)\n\tcase oauth2client.FieldTrustedPeers:\n\t\treturn m.OldTrustedPeers(ctx)\n\tcase oauth2client.FieldPublic:\n\t\treturn m.OldPublic(ctx)\n\tcase oauth2client.FieldName:\n\t\treturn m.OldName(ctx)\n\tcase oauth2client.FieldLogoURL:\n\t\treturn m.OldLogoURL(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown OAuth2Client field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OAuth2ClientMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetSecret(v)\n\t\treturn nil\n\tcase oauth2client.FieldRedirectUris:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRedirectUris(v)\n\t\treturn nil\n\tcase oauth2client.FieldTrustedPeers:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetTrustedPeers(v)\n\t\treturn nil\n\tcase oauth2client.FieldPublic:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetPublic(v)\n\t\treturn nil\n\tcase oauth2client.FieldName:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetName(v)\n\t\treturn nil\n\tcase oauth2client.FieldLogoURL:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLogoURL(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *OAuth2ClientMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *OAuth2ClientMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OAuth2ClientMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *OAuth2ClientMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(oauth2client.FieldRedirectUris) {\n\t\tfields = append(fields, oauth2client.FieldRedirectUris)\n\t}\n\tif m.FieldCleared(oauth2client.FieldTrustedPeers) {\n\t\tfields = append(fields, oauth2client.FieldTrustedPeers)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *OAuth2ClientMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ClearField(name string) error {\n\tswitch name {\n\tcase oauth2client.FieldRedirectUris:\n\t\tm.ClearRedirectUris()\n\t\treturn nil\n\tcase oauth2client.FieldTrustedPeers:\n\t\tm.ClearTrustedPeers()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ResetField(name string) error {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\tm.ResetSecret()\n\t\treturn nil\n\tcase oauth2client.FieldRedirectUris:\n\t\tm.ResetRedirectUris()\n\t\treturn nil\n\tcase oauth2client.FieldTrustedPeers:\n\t\tm.ResetTrustedPeers()\n\t\treturn nil\n\tcase oauth2client.FieldPublic:\n\t\tm.ResetPublic()\n\t\treturn nil\n\tcase oauth2client.FieldName:\n\t\tm.ResetName()\n\t\treturn nil\n\tcase oauth2client.FieldLogoURL:\n\t\tm.ResetLogoURL()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *OAuth2ClientMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *OAuth2ClientMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *OAuth2ClientMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *OAuth2ClientMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *OAuth2ClientMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *OAuth2ClientMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OAuth2Client unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OAuth2Client edge %s\", name)\n}\n\n// OfflineSessionMutation represents an operation that mutates the OfflineSession nodes in the graph.\ntype OfflineSessionMutation struct {\n\tconfig\n\top             Op\n\ttyp            string\n\tid             *string\n\tuser_id        *string\n\tconn_id        *string\n\trefresh        *[]byte\n\tconnector_data *[]byte\n\tclearedFields  map[string]struct{}\n\tdone           bool\n\toldValue       func(context.Context) (*OfflineSession, error)\n\tpredicates     []predicate.OfflineSession\n}\n\nvar _ ent.Mutation = (*OfflineSessionMutation)(nil)\n\n// offlinesessionOption allows management of the mutation configuration using functional options.\ntype offlinesessionOption func(*OfflineSessionMutation)\n\n// newOfflineSessionMutation creates new mutation for the OfflineSession entity.\nfunc newOfflineSessionMutation(c config, op Op, opts ...offlinesessionOption) *OfflineSessionMutation {\n\tm := &OfflineSessionMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeOfflineSession,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withOfflineSessionID sets the ID field of the mutation.\nfunc withOfflineSessionID(id string) offlinesessionOption {\n\treturn func(m *OfflineSessionMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *OfflineSession\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*OfflineSession, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().OfflineSession.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withOfflineSession sets the old OfflineSession of the mutation.\nfunc withOfflineSession(node *OfflineSession) offlinesessionOption {\n\treturn func(m *OfflineSessionMutation) {\n\t\tm.oldValue = func(context.Context) (*OfflineSession, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m OfflineSessionMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m OfflineSessionMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of OfflineSession entities.\nfunc (m *OfflineSessionMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *OfflineSessionMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *OfflineSessionMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().OfflineSession.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetUserID sets the \"user_id\" field.\nfunc (m *OfflineSessionMutation) SetUserID(s string) {\n\tm.user_id = &s\n}\n\n// UserID returns the value of the \"user_id\" field in the mutation.\nfunc (m *OfflineSessionMutation) UserID() (r string, exists bool) {\n\tv := m.user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUserID returns the old \"user_id\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUserID: %w\", err)\n\t}\n\treturn oldValue.UserID, nil\n}\n\n// ResetUserID resets all changes to the \"user_id\" field.\nfunc (m *OfflineSessionMutation) ResetUserID() {\n\tm.user_id = nil\n}\n\n// SetConnID sets the \"conn_id\" field.\nfunc (m *OfflineSessionMutation) SetConnID(s string) {\n\tm.conn_id = &s\n}\n\n// ConnID returns the value of the \"conn_id\" field in the mutation.\nfunc (m *OfflineSessionMutation) ConnID() (r string, exists bool) {\n\tv := m.conn_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnID returns the old \"conn_id\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldConnID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnID: %w\", err)\n\t}\n\treturn oldValue.ConnID, nil\n}\n\n// ResetConnID resets all changes to the \"conn_id\" field.\nfunc (m *OfflineSessionMutation) ResetConnID() {\n\tm.conn_id = nil\n}\n\n// SetRefresh sets the \"refresh\" field.\nfunc (m *OfflineSessionMutation) SetRefresh(b []byte) {\n\tm.refresh = &b\n}\n\n// Refresh returns the value of the \"refresh\" field in the mutation.\nfunc (m *OfflineSessionMutation) Refresh() (r []byte, exists bool) {\n\tv := m.refresh\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRefresh returns the old \"refresh\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldRefresh(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRefresh is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRefresh requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRefresh: %w\", err)\n\t}\n\treturn oldValue.Refresh, nil\n}\n\n// ResetRefresh resets all changes to the \"refresh\" field.\nfunc (m *OfflineSessionMutation) ResetRefresh() {\n\tm.refresh = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *OfflineSessionMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *OfflineSessionMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *OfflineSessionMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[offlinesession.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *OfflineSessionMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[offlinesession.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *OfflineSessionMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, offlinesession.FieldConnectorData)\n}\n\n// Where appends a list predicates to the OfflineSessionMutation builder.\nfunc (m *OfflineSessionMutation) Where(ps ...predicate.OfflineSession) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *OfflineSessionMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (OfflineSession).\nfunc (m *OfflineSessionMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *OfflineSessionMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m.user_id != nil {\n\t\tfields = append(fields, offlinesession.FieldUserID)\n\t}\n\tif m.conn_id != nil {\n\t\tfields = append(fields, offlinesession.FieldConnID)\n\t}\n\tif m.refresh != nil {\n\t\tfields = append(fields, offlinesession.FieldRefresh)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, offlinesession.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *OfflineSessionMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\treturn m.UserID()\n\tcase offlinesession.FieldConnID:\n\t\treturn m.ConnID()\n\tcase offlinesession.FieldRefresh:\n\t\treturn m.Refresh()\n\tcase offlinesession.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *OfflineSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\treturn m.OldUserID(ctx)\n\tcase offlinesession.FieldConnID:\n\t\treturn m.OldConnID(ctx)\n\tcase offlinesession.FieldRefresh:\n\t\treturn m.OldRefresh(ctx)\n\tcase offlinesession.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown OfflineSession field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OfflineSessionMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUserID(v)\n\t\treturn nil\n\tcase offlinesession.FieldConnID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnID(v)\n\t\treturn nil\n\tcase offlinesession.FieldRefresh:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRefresh(v)\n\t\treturn nil\n\tcase offlinesession.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *OfflineSessionMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *OfflineSessionMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OfflineSessionMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *OfflineSessionMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(offlinesession.FieldConnectorData) {\n\t\tfields = append(fields, offlinesession.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *OfflineSessionMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *OfflineSessionMutation) ClearField(name string) error {\n\tswitch name {\n\tcase offlinesession.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *OfflineSessionMutation) ResetField(name string) error {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\tm.ResetUserID()\n\t\treturn nil\n\tcase offlinesession.FieldConnID:\n\t\tm.ResetConnID()\n\t\treturn nil\n\tcase offlinesession.FieldRefresh:\n\t\tm.ResetRefresh()\n\t\treturn nil\n\tcase offlinesession.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *OfflineSessionMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *OfflineSessionMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *OfflineSessionMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *OfflineSessionMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *OfflineSessionMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *OfflineSessionMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *OfflineSessionMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OfflineSession unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *OfflineSessionMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OfflineSession edge %s\", name)\n}\n\n// PasswordMutation represents an operation that mutates the Password nodes in the graph.\ntype PasswordMutation struct {\n\tconfig\n\top            Op\n\ttyp           string\n\tid            *int\n\temail         *string\n\thash          *[]byte\n\tusername      *string\n\tuser_id       *string\n\tclearedFields map[string]struct{}\n\tdone          bool\n\toldValue      func(context.Context) (*Password, error)\n\tpredicates    []predicate.Password\n}\n\nvar _ ent.Mutation = (*PasswordMutation)(nil)\n\n// passwordOption allows management of the mutation configuration using functional options.\ntype passwordOption func(*PasswordMutation)\n\n// newPasswordMutation creates new mutation for the Password entity.\nfunc newPasswordMutation(c config, op Op, opts ...passwordOption) *PasswordMutation {\n\tm := &PasswordMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypePassword,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withPasswordID sets the ID field of the mutation.\nfunc withPasswordID(id int) passwordOption {\n\treturn func(m *PasswordMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Password\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Password, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Password.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withPassword sets the old Password of the mutation.\nfunc withPassword(node *Password) passwordOption {\n\treturn func(m *PasswordMutation) {\n\t\tm.oldValue = func(context.Context) (*Password, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m PasswordMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m PasswordMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *PasswordMutation) ID() (id int, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *PasswordMutation) IDs(ctx context.Context) ([]int, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []int{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().Password.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetEmail sets the \"email\" field.\nfunc (m *PasswordMutation) SetEmail(s string) {\n\tm.email = &s\n}\n\n// Email returns the value of the \"email\" field in the mutation.\nfunc (m *PasswordMutation) Email() (r string, exists bool) {\n\tv := m.email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldEmail returns the old \"email\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldEmail: %w\", err)\n\t}\n\treturn oldValue.Email, nil\n}\n\n// ResetEmail resets all changes to the \"email\" field.\nfunc (m *PasswordMutation) ResetEmail() {\n\tm.email = nil\n}\n\n// SetHash sets the \"hash\" field.\nfunc (m *PasswordMutation) SetHash(b []byte) {\n\tm.hash = &b\n}\n\n// Hash returns the value of the \"hash\" field in the mutation.\nfunc (m *PasswordMutation) Hash() (r []byte, exists bool) {\n\tv := m.hash\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldHash returns the old \"hash\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldHash(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldHash is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldHash requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldHash: %w\", err)\n\t}\n\treturn oldValue.Hash, nil\n}\n\n// ResetHash resets all changes to the \"hash\" field.\nfunc (m *PasswordMutation) ResetHash() {\n\tm.hash = nil\n}\n\n// SetUsername sets the \"username\" field.\nfunc (m *PasswordMutation) SetUsername(s string) {\n\tm.username = &s\n}\n\n// Username returns the value of the \"username\" field in the mutation.\nfunc (m *PasswordMutation) Username() (r string, exists bool) {\n\tv := m.username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUsername returns the old \"username\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUsername: %w\", err)\n\t}\n\treturn oldValue.Username, nil\n}\n\n// ResetUsername resets all changes to the \"username\" field.\nfunc (m *PasswordMutation) ResetUsername() {\n\tm.username = nil\n}\n\n// SetUserID sets the \"user_id\" field.\nfunc (m *PasswordMutation) SetUserID(s string) {\n\tm.user_id = &s\n}\n\n// UserID returns the value of the \"user_id\" field in the mutation.\nfunc (m *PasswordMutation) UserID() (r string, exists bool) {\n\tv := m.user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUserID returns the old \"user_id\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUserID: %w\", err)\n\t}\n\treturn oldValue.UserID, nil\n}\n\n// ResetUserID resets all changes to the \"user_id\" field.\nfunc (m *PasswordMutation) ResetUserID() {\n\tm.user_id = nil\n}\n\n// Where appends a list predicates to the PasswordMutation builder.\nfunc (m *PasswordMutation) Where(ps ...predicate.Password) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *PasswordMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (Password).\nfunc (m *PasswordMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *PasswordMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m.email != nil {\n\t\tfields = append(fields, password.FieldEmail)\n\t}\n\tif m.hash != nil {\n\t\tfields = append(fields, password.FieldHash)\n\t}\n\tif m.username != nil {\n\t\tfields = append(fields, password.FieldUsername)\n\t}\n\tif m.user_id != nil {\n\t\tfields = append(fields, password.FieldUserID)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *PasswordMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\treturn m.Email()\n\tcase password.FieldHash:\n\t\treturn m.Hash()\n\tcase password.FieldUsername:\n\t\treturn m.Username()\n\tcase password.FieldUserID:\n\t\treturn m.UserID()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *PasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\treturn m.OldEmail(ctx)\n\tcase password.FieldHash:\n\t\treturn m.OldHash(ctx)\n\tcase password.FieldUsername:\n\t\treturn m.OldUsername(ctx)\n\tcase password.FieldUserID:\n\t\treturn m.OldUserID(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown Password field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *PasswordMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetEmail(v)\n\t\treturn nil\n\tcase password.FieldHash:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetHash(v)\n\t\treturn nil\n\tcase password.FieldUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUsername(v)\n\t\treturn nil\n\tcase password.FieldUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUserID(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Password field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *PasswordMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *PasswordMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *PasswordMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown Password numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *PasswordMutation) ClearedFields() []string {\n\treturn nil\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *PasswordMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *PasswordMutation) ClearField(name string) error {\n\treturn fmt.Errorf(\"unknown Password nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *PasswordMutation) ResetField(name string) error {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\tm.ResetEmail()\n\t\treturn nil\n\tcase password.FieldHash:\n\t\tm.ResetHash()\n\t\treturn nil\n\tcase password.FieldUsername:\n\t\tm.ResetUsername()\n\t\treturn nil\n\tcase password.FieldUserID:\n\t\tm.ResetUserID()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Password field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *PasswordMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *PasswordMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *PasswordMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *PasswordMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *PasswordMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *PasswordMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *PasswordMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Password unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *PasswordMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Password edge %s\", name)\n}\n\n// RefreshTokenMutation represents an operation that mutates the RefreshToken nodes in the graph.\ntype RefreshTokenMutation struct {\n\tconfig\n\top                        Op\n\ttyp                       string\n\tid                        *string\n\tclient_id                 *string\n\tscopes                    *[]string\n\tnonce                     *string\n\tclaims_user_id            *string\n\tclaims_username           *string\n\tclaims_email              *string\n\tclaims_email_verified     *bool\n\tclaims_groups             *[]string\n\tclaims_preferred_username *string\n\tconnector_id              *string\n\tconnector_data            *[]byte\n\ttoken                     *string\n\tobsolete_token            *string\n\tcreated_at                *time.Time\n\tlast_used                 *time.Time\n\tclearedFields             map[string]struct{}\n\tdone                      bool\n\toldValue                  func(context.Context) (*RefreshToken, error)\n\tpredicates                []predicate.RefreshToken\n}\n\nvar _ ent.Mutation = (*RefreshTokenMutation)(nil)\n\n// refreshtokenOption allows management of the mutation configuration using functional options.\ntype refreshtokenOption func(*RefreshTokenMutation)\n\n// newRefreshTokenMutation creates new mutation for the RefreshToken entity.\nfunc newRefreshTokenMutation(c config, op Op, opts ...refreshtokenOption) *RefreshTokenMutation {\n\tm := &RefreshTokenMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeRefreshToken,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withRefreshTokenID sets the ID field of the mutation.\nfunc withRefreshTokenID(id string) refreshtokenOption {\n\treturn func(m *RefreshTokenMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *RefreshToken\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*RefreshToken, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().RefreshToken.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withRefreshToken sets the old RefreshToken of the mutation.\nfunc withRefreshToken(node *RefreshToken) refreshtokenOption {\n\treturn func(m *RefreshTokenMutation) {\n\t\tm.oldValue = func(context.Context) (*RefreshToken, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m RefreshTokenMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m RefreshTokenMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of RefreshToken entities.\nfunc (m *RefreshTokenMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *RefreshTokenMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *RefreshTokenMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().RefreshToken.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *RefreshTokenMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *RefreshTokenMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *RefreshTokenMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *RefreshTokenMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *RefreshTokenMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[refreshtoken.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *RefreshTokenMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[refreshtoken.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *RefreshTokenMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, refreshtoken.FieldScopes)\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (m *RefreshTokenMutation) SetNonce(s string) {\n\tm.nonce = &s\n}\n\n// Nonce returns the value of the \"nonce\" field in the mutation.\nfunc (m *RefreshTokenMutation) Nonce() (r string, exists bool) {\n\tv := m.nonce\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNonce returns the old \"nonce\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldNonce(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNonce is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNonce requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNonce: %w\", err)\n\t}\n\treturn oldValue.Nonce, nil\n}\n\n// ResetNonce resets all changes to the \"nonce\" field.\nfunc (m *RefreshTokenMutation) ResetNonce() {\n\tm.nonce = nil\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (m *RefreshTokenMutation) SetClaimsUserID(s string) {\n\tm.claims_user_id = &s\n}\n\n// ClaimsUserID returns the value of the \"claims_user_id\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsUserID() (r string, exists bool) {\n\tv := m.claims_user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUserID returns the old \"claims_user_id\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUserID: %w\", err)\n\t}\n\treturn oldValue.ClaimsUserID, nil\n}\n\n// ResetClaimsUserID resets all changes to the \"claims_user_id\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsUserID() {\n\tm.claims_user_id = nil\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (m *RefreshTokenMutation) SetClaimsUsername(s string) {\n\tm.claims_username = &s\n}\n\n// ClaimsUsername returns the value of the \"claims_username\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsUsername() (r string, exists bool) {\n\tv := m.claims_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUsername returns the old \"claims_username\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsUsername, nil\n}\n\n// ResetClaimsUsername resets all changes to the \"claims_username\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsUsername() {\n\tm.claims_username = nil\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (m *RefreshTokenMutation) SetClaimsEmail(s string) {\n\tm.claims_email = &s\n}\n\n// ClaimsEmail returns the value of the \"claims_email\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsEmail() (r string, exists bool) {\n\tv := m.claims_email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmail returns the old \"claims_email\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmail: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmail, nil\n}\n\n// ResetClaimsEmail resets all changes to the \"claims_email\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsEmail() {\n\tm.claims_email = nil\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (m *RefreshTokenMutation) SetClaimsEmailVerified(b bool) {\n\tm.claims_email_verified = &b\n}\n\n// ClaimsEmailVerified returns the value of the \"claims_email_verified\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsEmailVerified() (r bool, exists bool) {\n\tv := m.claims_email_verified\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmailVerified returns the old \"claims_email_verified\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmailVerified: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmailVerified, nil\n}\n\n// ResetClaimsEmailVerified resets all changes to the \"claims_email_verified\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsEmailVerified() {\n\tm.claims_email_verified = nil\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (m *RefreshTokenMutation) SetClaimsGroups(s []string) {\n\tm.claims_groups = &s\n}\n\n// ClaimsGroups returns the value of the \"claims_groups\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsGroups() (r []string, exists bool) {\n\tv := m.claims_groups\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsGroups returns the old \"claims_groups\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsGroups is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsGroups requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsGroups: %w\", err)\n\t}\n\treturn oldValue.ClaimsGroups, nil\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (m *RefreshTokenMutation) ClearClaimsGroups() {\n\tm.claims_groups = nil\n\tm.clearedFields[refreshtoken.FieldClaimsGroups] = struct{}{}\n}\n\n// ClaimsGroupsCleared returns if the \"claims_groups\" field was cleared in this mutation.\nfunc (m *RefreshTokenMutation) ClaimsGroupsCleared() bool {\n\t_, ok := m.clearedFields[refreshtoken.FieldClaimsGroups]\n\treturn ok\n}\n\n// ResetClaimsGroups resets all changes to the \"claims_groups\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsGroups() {\n\tm.claims_groups = nil\n\tdelete(m.clearedFields, refreshtoken.FieldClaimsGroups)\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (m *RefreshTokenMutation) SetClaimsPreferredUsername(s string) {\n\tm.claims_preferred_username = &s\n}\n\n// ClaimsPreferredUsername returns the value of the \"claims_preferred_username\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsPreferredUsername() (r string, exists bool) {\n\tv := m.claims_preferred_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsPreferredUsername returns the old \"claims_preferred_username\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsPreferredUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsPreferredUsername, nil\n}\n\n// ResetClaimsPreferredUsername resets all changes to the \"claims_preferred_username\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsPreferredUsername() {\n\tm.claims_preferred_username = nil\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (m *RefreshTokenMutation) SetConnectorID(s string) {\n\tm.connector_id = &s\n}\n\n// ConnectorID returns the value of the \"connector_id\" field in the mutation.\nfunc (m *RefreshTokenMutation) ConnectorID() (r string, exists bool) {\n\tv := m.connector_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorID returns the old \"connector_id\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldConnectorID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorID: %w\", err)\n\t}\n\treturn oldValue.ConnectorID, nil\n}\n\n// ResetConnectorID resets all changes to the \"connector_id\" field.\nfunc (m *RefreshTokenMutation) ResetConnectorID() {\n\tm.connector_id = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *RefreshTokenMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *RefreshTokenMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *RefreshTokenMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[refreshtoken.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *RefreshTokenMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[refreshtoken.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *RefreshTokenMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, refreshtoken.FieldConnectorData)\n}\n\n// SetToken sets the \"token\" field.\nfunc (m *RefreshTokenMutation) SetToken(s string) {\n\tm.token = &s\n}\n\n// Token returns the value of the \"token\" field in the mutation.\nfunc (m *RefreshTokenMutation) Token() (r string, exists bool) {\n\tv := m.token\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldToken returns the old \"token\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldToken(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldToken is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldToken requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldToken: %w\", err)\n\t}\n\treturn oldValue.Token, nil\n}\n\n// ResetToken resets all changes to the \"token\" field.\nfunc (m *RefreshTokenMutation) ResetToken() {\n\tm.token = nil\n}\n\n// SetObsoleteToken sets the \"obsolete_token\" field.\nfunc (m *RefreshTokenMutation) SetObsoleteToken(s string) {\n\tm.obsolete_token = &s\n}\n\n// ObsoleteToken returns the value of the \"obsolete_token\" field in the mutation.\nfunc (m *RefreshTokenMutation) ObsoleteToken() (r string, exists bool) {\n\tv := m.obsolete_token\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldObsoleteToken returns the old \"obsolete_token\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldObsoleteToken(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldObsoleteToken is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldObsoleteToken requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldObsoleteToken: %w\", err)\n\t}\n\treturn oldValue.ObsoleteToken, nil\n}\n\n// ResetObsoleteToken resets all changes to the \"obsolete_token\" field.\nfunc (m *RefreshTokenMutation) ResetObsoleteToken() {\n\tm.obsolete_token = nil\n}\n\n// SetCreatedAt sets the \"created_at\" field.\nfunc (m *RefreshTokenMutation) SetCreatedAt(t time.Time) {\n\tm.created_at = &t\n}\n\n// CreatedAt returns the value of the \"created_at\" field in the mutation.\nfunc (m *RefreshTokenMutation) CreatedAt() (r time.Time, exists bool) {\n\tv := m.created_at\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCreatedAt returns the old \"created_at\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCreatedAt is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCreatedAt requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCreatedAt: %w\", err)\n\t}\n\treturn oldValue.CreatedAt, nil\n}\n\n// ResetCreatedAt resets all changes to the \"created_at\" field.\nfunc (m *RefreshTokenMutation) ResetCreatedAt() {\n\tm.created_at = nil\n}\n\n// SetLastUsed sets the \"last_used\" field.\nfunc (m *RefreshTokenMutation) SetLastUsed(t time.Time) {\n\tm.last_used = &t\n}\n\n// LastUsed returns the value of the \"last_used\" field in the mutation.\nfunc (m *RefreshTokenMutation) LastUsed() (r time.Time, exists bool) {\n\tv := m.last_used\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLastUsed returns the old \"last_used\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLastUsed is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLastUsed requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLastUsed: %w\", err)\n\t}\n\treturn oldValue.LastUsed, nil\n}\n\n// ResetLastUsed resets all changes to the \"last_used\" field.\nfunc (m *RefreshTokenMutation) ResetLastUsed() {\n\tm.last_used = nil\n}\n\n// Where appends a list predicates to the RefreshTokenMutation builder.\nfunc (m *RefreshTokenMutation) Where(ps ...predicate.RefreshToken) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *RefreshTokenMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (RefreshToken).\nfunc (m *RefreshTokenMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *RefreshTokenMutation) Fields() []string {\n\tfields := make([]string, 0, 15)\n\tif m.client_id != nil {\n\t\tfields = append(fields, refreshtoken.FieldClientID)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, refreshtoken.FieldScopes)\n\t}\n\tif m.nonce != nil {\n\t\tfields = append(fields, refreshtoken.FieldNonce)\n\t}\n\tif m.claims_user_id != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsUserID)\n\t}\n\tif m.claims_username != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsUsername)\n\t}\n\tif m.claims_email != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsEmail)\n\t}\n\tif m.claims_email_verified != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsEmailVerified)\n\t}\n\tif m.claims_groups != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsGroups)\n\t}\n\tif m.claims_preferred_username != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsPreferredUsername)\n\t}\n\tif m.connector_id != nil {\n\t\tfields = append(fields, refreshtoken.FieldConnectorID)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, refreshtoken.FieldConnectorData)\n\t}\n\tif m.token != nil {\n\t\tfields = append(fields, refreshtoken.FieldToken)\n\t}\n\tif m.obsolete_token != nil {\n\t\tfields = append(fields, refreshtoken.FieldObsoleteToken)\n\t}\n\tif m.created_at != nil {\n\t\tfields = append(fields, refreshtoken.FieldCreatedAt)\n\t}\n\tif m.last_used != nil {\n\t\tfields = append(fields, refreshtoken.FieldLastUsed)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *RefreshTokenMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\treturn m.ClientID()\n\tcase refreshtoken.FieldScopes:\n\t\treturn m.Scopes()\n\tcase refreshtoken.FieldNonce:\n\t\treturn m.Nonce()\n\tcase refreshtoken.FieldClaimsUserID:\n\t\treturn m.ClaimsUserID()\n\tcase refreshtoken.FieldClaimsUsername:\n\t\treturn m.ClaimsUsername()\n\tcase refreshtoken.FieldClaimsEmail:\n\t\treturn m.ClaimsEmail()\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\treturn m.ClaimsEmailVerified()\n\tcase refreshtoken.FieldClaimsGroups:\n\t\treturn m.ClaimsGroups()\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\treturn m.ClaimsPreferredUsername()\n\tcase refreshtoken.FieldConnectorID:\n\t\treturn m.ConnectorID()\n\tcase refreshtoken.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\tcase refreshtoken.FieldToken:\n\t\treturn m.Token()\n\tcase refreshtoken.FieldObsoleteToken:\n\t\treturn m.ObsoleteToken()\n\tcase refreshtoken.FieldCreatedAt:\n\t\treturn m.CreatedAt()\n\tcase refreshtoken.FieldLastUsed:\n\t\treturn m.LastUsed()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *RefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase refreshtoken.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase refreshtoken.FieldNonce:\n\t\treturn m.OldNonce(ctx)\n\tcase refreshtoken.FieldClaimsUserID:\n\t\treturn m.OldClaimsUserID(ctx)\n\tcase refreshtoken.FieldClaimsUsername:\n\t\treturn m.OldClaimsUsername(ctx)\n\tcase refreshtoken.FieldClaimsEmail:\n\t\treturn m.OldClaimsEmail(ctx)\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\treturn m.OldClaimsEmailVerified(ctx)\n\tcase refreshtoken.FieldClaimsGroups:\n\t\treturn m.OldClaimsGroups(ctx)\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\treturn m.OldClaimsPreferredUsername(ctx)\n\tcase refreshtoken.FieldConnectorID:\n\t\treturn m.OldConnectorID(ctx)\n\tcase refreshtoken.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\tcase refreshtoken.FieldToken:\n\t\treturn m.OldToken(ctx)\n\tcase refreshtoken.FieldObsoleteToken:\n\t\treturn m.OldObsoleteToken(ctx)\n\tcase refreshtoken.FieldCreatedAt:\n\t\treturn m.OldCreatedAt(ctx)\n\tcase refreshtoken.FieldLastUsed:\n\t\treturn m.OldLastUsed(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown RefreshToken field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *RefreshTokenMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase refreshtoken.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase refreshtoken.FieldNonce:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNonce(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUserID(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUsername(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmail(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmailVerified(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsGroups:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsGroups(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsPreferredUsername(v)\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorID(v)\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\tcase refreshtoken.FieldToken:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetToken(v)\n\t\treturn nil\n\tcase refreshtoken.FieldObsoleteToken:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetObsoleteToken(v)\n\t\treturn nil\n\tcase refreshtoken.FieldCreatedAt:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCreatedAt(v)\n\t\treturn nil\n\tcase refreshtoken.FieldLastUsed:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLastUsed(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *RefreshTokenMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *RefreshTokenMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *RefreshTokenMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *RefreshTokenMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(refreshtoken.FieldScopes) {\n\t\tfields = append(fields, refreshtoken.FieldScopes)\n\t}\n\tif m.FieldCleared(refreshtoken.FieldClaimsGroups) {\n\t\tfields = append(fields, refreshtoken.FieldClaimsGroups)\n\t}\n\tif m.FieldCleared(refreshtoken.FieldConnectorData) {\n\t\tfields = append(fields, refreshtoken.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *RefreshTokenMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *RefreshTokenMutation) ClearField(name string) error {\n\tswitch name {\n\tcase refreshtoken.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsGroups:\n\t\tm.ClearClaimsGroups()\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *RefreshTokenMutation) ResetField(name string) error {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase refreshtoken.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase refreshtoken.FieldNonce:\n\t\tm.ResetNonce()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUserID:\n\t\tm.ResetClaimsUserID()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUsername:\n\t\tm.ResetClaimsUsername()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmail:\n\t\tm.ResetClaimsEmail()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\tm.ResetClaimsEmailVerified()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsGroups:\n\t\tm.ResetClaimsGroups()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\tm.ResetClaimsPreferredUsername()\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorID:\n\t\tm.ResetConnectorID()\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\tcase refreshtoken.FieldToken:\n\t\tm.ResetToken()\n\t\treturn nil\n\tcase refreshtoken.FieldObsoleteToken:\n\t\tm.ResetObsoleteToken()\n\t\treturn nil\n\tcase refreshtoken.FieldCreatedAt:\n\t\tm.ResetCreatedAt()\n\t\treturn nil\n\tcase refreshtoken.FieldLastUsed:\n\t\tm.ResetLastUsed()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *RefreshTokenMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *RefreshTokenMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *RefreshTokenMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *RefreshTokenMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *RefreshTokenMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *RefreshTokenMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *RefreshTokenMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown RefreshToken unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *RefreshTokenMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown RefreshToken edge %s\", name)\n}\n", "package schema\n\nimport (\n\t\"entgo.io/ent\"\n\t\"entgo.io/ent/schema/field\"\n)\n\n/* Original SQL table:\ncreate table auth_request\n(\n    id                        text      not null  primary key,\n    client_id                 text      not null,\n    response_types            blob      not null,\n    scopes                    blob      not null,\n    redirect_uri              text      not null,\n    nonce                     text      not null,\n    state                     text      not null,\n    force_approval_prompt     integer   not null,\n    logged_in                 integer   not null,\n    claims_user_id            text      not null,\n    claims_username           text      not null,\n    claims_email              text      not null,\n    claims_email_verified     integer   not null,\n    claims_groups             blob      not null,\n    connector_id              text      not null,\n    connector_data            blob,\n    expiry                    timestamp not null,\n    claims_preferred_username text default '' not null,\n    code_challenge            text default '' not null,\n    code_challenge_method     text default '' not null\n);\n*/\n\n// AuthRequest holds the schema definition for the AuthRequest entity.\ntype AuthRequest struct {\n\tent.Schema\n}\n\n// Fields of the AuthRequest.\nfunc (AuthRequest) Fields() []ent.Field {\n\treturn []ent.Field{\n\t\tfield.Text(\"id\").\n\t\t\tSchemaType(textSchema).\n\t\t\tNotEmpty().\n\t\t\tUnique(),\n\t\tfield.Text(\"client_id\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.JSON(\"scopes\", []string{}).\n\t\t\tOptional(),\n\t\tfield.JSON(\"response_types\", []string{}).\n\t\t\tOptional(),\n\t\tfield.Text(\"redirect_uri\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"nonce\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"state\").\n\t\t\tSchemaType(textSchema),\n\n\t\tfield.Bool(\"force_approval_prompt\"),\n\t\tfield.Bool(\"logged_in\"),\n\n\t\tfield.Text(\"claims_user_id\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"claims_username\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"claims_email\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Bool(\"claims_email_verified\"),\n\t\tfield.JSON(\"claims_groups\", []string{}).\n\t\t\tOptional(),\n\t\tfield.Text(\"claims_preferred_username\").\n\t\t\tSchemaType(textSchema).\n\t\t\tDefault(\"\"),\n\n\t\tfield.Text(\"connector_id\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Bytes(\"connector_data\").\n\t\t\tNillable().\n\t\t\tOptional(),\n\t\tfield.Time(\"expiry\").\n\t\t\tSchemaType(timeSchema),\n\n\t\tfield.Text(\"code_challenge\").\n\t\t\tSchemaType(textSchema).\n\t\t\tDefault(\"\"),\n\t\tfield.Text(\"code_challenge_method\").\n\t\t\tSchemaType(textSchema).\n\t\t\tDefault(\"\"),\n\t}\n}\n\n// Edges of the AuthRequest.\nfunc (AuthRequest) Edges() []ent.Edge {\n\treturn []ent.Edge{}\n}\n", "package etcd\n\nimport (\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// AuthCode is a mirrored struct from storage with JSON struct tags\ntype AuthCode struct {\n\tID          string   `json:\"ID\"`\n\tClientID    string   `json:\"clientID\"`\n\tRedirectURI string   `json:\"redirectURI\"`\n\tNonce       string   `json:\"nonce,omitempty\"`\n\tScopes      []string `json:\"scopes,omitempty\"`\n\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n\tClaims        Claims `json:\"claims,omitempty\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\nfunc toStorageAuthCode(a AuthCode) storage.AuthCode {\n\treturn storage.AuthCode{\n\t\tID:            a.ID,\n\t\tClientID:      a.ClientID,\n\t\tRedirectURI:   a.RedirectURI,\n\t\tConnectorID:   a.ConnectorID,\n\t\tConnectorData: a.ConnectorData,\n\t\tNonce:         a.Nonce,\n\t\tScopes:        a.Scopes,\n\t\tClaims:        toStorageClaims(a.Claims),\n\t\tExpiry:        a.Expiry,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\nfunc fromStorageAuthCode(a storage.AuthCode) AuthCode {\n\treturn AuthCode{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tNonce:               a.Nonce,\n\t\tScopes:              a.Scopes,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tExpiry:              a.Expiry,\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t}\n}\n\n// AuthRequest is a mirrored struct from storage with JSON struct tags\ntype AuthRequest struct {\n\tID       string `json:\"id\"`\n\tClientID string `json:\"client_id\"`\n\n\tResponseTypes []string `json:\"response_types\"`\n\tScopes        []string `json:\"scopes\"`\n\tRedirectURI   string   `json:\"redirect_uri\"`\n\tNonce         string   `json:\"nonce\"`\n\tState         string   `json:\"state\"`\n\n\tForceApprovalPrompt bool `json:\"force_approval_prompt\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tLoggedIn bool `json:\"logged_in\"`\n\n\tClaims Claims `json:\"claims\"`\n\n\tConnectorID   string `json:\"connector_id\"`\n\tConnectorData []byte `json:\"connector_data\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\nfunc fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {\n\treturn AuthRequest{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tExpiry:              a.Expiry,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t}\n}\n\nfunc toStorageAuthRequest(a AuthRequest) storage.AuthRequest {\n\treturn storage.AuthRequest{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tExpiry:              a.Expiry,\n\t\tClaims:              toStorageClaims(a.Claims),\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\n// RefreshToken is a mirrored struct from storage with JSON struct tags\ntype RefreshToken struct {\n\tID string `json:\"id\"`\n\n\tToken         string `json:\"token\"`\n\tObsoleteToken string `json:\"obsolete_token\"`\n\n\tCreatedAt time.Time `json:\"created_at\"`\n\tLastUsed  time.Time `json:\"last_used\"`\n\n\tClientID string `json:\"client_id\"`\n\n\tConnectorID   string `json:\"connector_id\"`\n\tConnectorData []byte `json:\"connector_data\"`\n\tClaims        Claims `json:\"claims\"`\n\n\tScopes []string `json:\"scopes\"`\n\n\tNonce string `json:\"nonce\"`\n}\n\nfunc toStorageRefreshToken(r RefreshToken) storage.RefreshToken {\n\treturn storage.RefreshToken{\n\t\tID:            r.ID,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        toStorageClaims(r.Claims),\n\t}\n}\n\nfunc fromStorageRefreshToken(r storage.RefreshToken) RefreshToken {\n\treturn RefreshToken{\n\t\tID:            r.ID,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        fromStorageClaims(r.Claims),\n\t}\n}\n\n// Claims is a mirrored struct from storage with JSON struct tags.\ntype Claims struct {\n\tUserID            string   `json:\"userID\"`\n\tUsername          string   `json:\"username\"`\n\tPreferredUsername string   `json:\"preferredUsername\"`\n\tEmail             string   `json:\"email\"`\n\tEmailVerified     bool     `json:\"emailVerified\"`\n\tGroups            []string `json:\"groups,omitempty\"`\n}\n\nfunc fromStorageClaims(i storage.Claims) Claims {\n\treturn Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\nfunc toStorageClaims(i Claims) storage.Claims {\n\treturn storage.Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\n// Keys is a mirrored struct from storage with JSON struct tags\ntype Keys struct {\n\tSigningKey       *jose.JSONWebKey          `json:\"signing_key,omitempty\"`\n\tSigningKeyPub    *jose.JSONWebKey          `json:\"signing_key_pub,omitempty\"`\n\tVerificationKeys []storage.VerificationKey `json:\"verification_keys\"`\n\tNextRotation     time.Time                 `json:\"next_rotation\"`\n}\n\n// OfflineSessions is a mirrored struct from storage with JSON struct tags\ntype OfflineSessions struct {\n\tUserID        string                              `json:\"user_id,omitempty\"`\n\tConnID        string                              `json:\"conn_id,omitempty\"`\n\tRefresh       map[string]*storage.RefreshTokenRef `json:\"refresh,omitempty\"`\n\tConnectorData []byte                              `json:\"connectorData,omitempty\"`\n}\n\nfunc fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {\n\treturn OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n}\n\nfunc toStorageOfflineSessions(o OfflineSessions) storage.OfflineSessions {\n\ts := storage.OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n\tif s.Refresh == nil {\n\t\t// Server code assumes this will be non-nil.\n\t\ts.Refresh = make(map[string]*storage.RefreshTokenRef)\n\t}\n\treturn s\n}\n\n// DeviceRequest is a mirrored struct from storage with JSON struct tags\ntype DeviceRequest struct {\n\tUserCode     string    `json:\"user_code\"`\n\tDeviceCode   string    `json:\"device_code\"`\n\tClientID     string    `json:\"client_id\"`\n\tClientSecret string    `json:\"client_secret\"`\n\tScopes       []string  `json:\"scopes\"`\n\tExpiry       time.Time `json:\"expiry\"`\n}\n\nfunc fromStorageDeviceRequest(d storage.DeviceRequest) DeviceRequest {\n\treturn DeviceRequest{\n\t\tUserCode:     d.UserCode,\n\t\tDeviceCode:   d.DeviceCode,\n\t\tClientID:     d.ClientID,\n\t\tClientSecret: d.ClientSecret,\n\t\tScopes:       d.Scopes,\n\t\tExpiry:       d.Expiry,\n\t}\n}\n\n// DeviceToken is a mirrored struct from storage with JSON struct tags\ntype DeviceToken struct {\n\tDeviceCode          string    `json:\"device_code\"`\n\tStatus              string    `json:\"status\"`\n\tToken               string    `json:\"token\"`\n\tExpiry              time.Time `json:\"expiry\"`\n\tLastRequestTime     time.Time `json:\"last_request\"`\n\tPollIntervalSeconds int       `json:\"poll_interval\"`\n\tCodeChallenge       string    `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string    `json:\"code_challenge_method,omitempty\"`\n}\n\nfunc fromStorageDeviceToken(t storage.DeviceToken) DeviceToken {\n\treturn DeviceToken{\n\t\tDeviceCode:          t.DeviceCode,\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tCodeChallenge:       t.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: t.PKCE.CodeChallengeMethod,\n\t}\n}\n\nfunc toStorageDeviceToken(t DeviceToken) storage.DeviceToken {\n\treturn storage.DeviceToken{\n\t\tDeviceCode:          t.DeviceCode,\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       t.CodeChallenge,\n\t\t\tCodeChallengeMethod: t.CodeChallengeMethod,\n\t\t},\n\t}\n}\n", "package storage\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// NewCustomHealthCheckFunc returns a new health check function.\nfunc NewCustomHealthCheckFunc(s Storage, now func() time.Time) func(context.Context) (details interface{}, err error) {\n\treturn func(_ context.Context) (details interface{}, err error) {\n\t\ta := AuthRequest{\n\t\t\tID:       NewID(),\n\t\t\tClientID: NewID(),\n\n\t\t\t// Set a short expiry so if the delete fails this will be cleaned up quickly by garbage collection.\n\t\t\tExpiry: now().Add(time.Minute),\n\t\t}\n\n\t\tif err := s.CreateAuthRequest(a); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"create auth request: %v\", err)\n\t\t}\n\n\t\tif err := s.DeleteAuthRequest(a.ID); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"delete auth request: %v\", err)\n\t\t}\n\n\t\treturn nil, nil\n\t}\n}\n", "package kubernetes\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/kubernetes/k8sapi\"\n)\n\nconst (\n\tapiGroup = \"dex.coreos.com\"\n\n\tlegacyCRDAPIVersion = \"apiextensions.k8s.io/v1beta1\"\n\tcrdAPIVersion       = \"apiextensions.k8s.io/v1\"\n)\n\n// The set of custom resource definitions required by the storage. These are managed by\n// the storage so it can migrate itself by creating new resources.\nfunc customResourceDefinitions(apiVersion string) []k8sapi.CustomResourceDefinition {\n\tcrdMeta := k8sapi.TypeMeta{\n\t\tAPIVersion: apiVersion,\n\t\tKind:       \"CustomResourceDefinition\",\n\t}\n\n\tvar version string\n\tvar scope k8sapi.ResourceScope\n\tvar versions []k8sapi.CustomResourceDefinitionVersion\n\n\tswitch apiVersion {\n\tcase crdAPIVersion:\n\t\tpreserveUnknownFields := true\n\t\tversions = []k8sapi.CustomResourceDefinitionVersion{\n\t\t\t{\n\t\t\t\tName:    \"v1\",\n\t\t\t\tServed:  true,\n\t\t\t\tStorage: true,\n\t\t\t\tSchema: &k8sapi.CustomResourceValidation{\n\t\t\t\t\tOpenAPIV3Schema: &k8sapi.JSONSchemaProps{\n\t\t\t\t\t\tType:                   \"object\",\n\t\t\t\t\t\tXPreserveUnknownFields: &preserveUnknownFields,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tscope = k8sapi.NamespaceScoped\n\tcase legacyCRDAPIVersion:\n\t\tversion = \"v1\"\n\tdefault:\n\t\tpanic(\"unknown apiVersion \" + apiVersion)\n\t}\n\n\treturn []k8sapi.CustomResourceDefinition{\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"authcodes.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"authcodes\",\n\t\t\t\t\tSingular: \"authcode\",\n\t\t\t\t\tKind:     \"AuthCode\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"authrequests.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"authrequests\",\n\t\t\t\t\tSingular: \"authrequest\",\n\t\t\t\t\tKind:     \"AuthRequest\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"oauth2clients.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"oauth2clients\",\n\t\t\t\t\tSingular: \"oauth2client\",\n\t\t\t\t\tKind:     \"OAuth2Client\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"signingkeies.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\t// `signingkeies` is an artifact from the old TPR pluralization.\n\t\t\t\t\t// Users don't directly interact with this value, hence leaving it\n\t\t\t\t\t// as is.\n\t\t\t\t\tPlural:   \"signingkeies\",\n\t\t\t\t\tSingular: \"signingkey\",\n\t\t\t\t\tKind:     \"SigningKey\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"refreshtokens.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"refreshtokens\",\n\t\t\t\t\tSingular: \"refreshtoken\",\n\t\t\t\t\tKind:     \"RefreshToken\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"passwords.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"passwords\",\n\t\t\t\t\tSingular: \"password\",\n\t\t\t\t\tKind:     \"Password\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"offlinesessionses.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"offlinesessionses\",\n\t\t\t\t\tSingular: \"offlinesessions\",\n\t\t\t\t\tKind:     \"OfflineSessions\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"connectors.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"connectors\",\n\t\t\t\t\tSingular: \"connector\",\n\t\t\t\t\tKind:     \"Connector\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"devicerequests.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"devicerequests\",\n\t\t\t\t\tSingular: \"devicerequest\",\n\t\t\t\t\tKind:     \"DeviceRequest\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"devicetokens.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"devicetokens\",\n\t\t\t\t\tSingular: \"devicetoken\",\n\t\t\t\t\tKind:     \"DeviceToken\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\n// There will only ever be a single keys resource. Maintain this by setting a\n// common name.\nconst keysName = \"openid-connect-keys\"\n\n// Client is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype Client struct {\n\t// Name is a hash of the ID.\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// ID is immutable, since it's a primary key and should not be changed.\n\tID string `json:\"id,omitempty\"`\n\n\tSecret       string   `json:\"secret,omitempty\"`\n\tRedirectURIs []string `json:\"redirectURIs,omitempty\"`\n\tTrustedPeers []string `json:\"trustedPeers,omitempty\"`\n\n\tPublic bool `json:\"public\"`\n\n\tName    string `json:\"name,omitempty\"`\n\tLogoURL string `json:\"logoURL,omitempty\"`\n}\n\n// ClientList is a list of Clients.\ntype ClientList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tClients         []Client `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageClient(c storage.Client) Client {\n\treturn Client{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindClient,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      cli.idToName(c.ID),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tID:           c.ID,\n\t\tSecret:       c.Secret,\n\t\tRedirectURIs: c.RedirectURIs,\n\t\tTrustedPeers: c.TrustedPeers,\n\t\tPublic:       c.Public,\n\t\tName:         c.Name,\n\t\tLogoURL:      c.LogoURL,\n\t}\n}\n\nfunc toStorageClient(c Client) storage.Client {\n\treturn storage.Client{\n\t\tID:           c.ID,\n\t\tSecret:       c.Secret,\n\t\tRedirectURIs: c.RedirectURIs,\n\t\tTrustedPeers: c.TrustedPeers,\n\t\tPublic:       c.Public,\n\t\tName:         c.Name,\n\t\tLogoURL:      c.LogoURL,\n\t}\n}\n\n// Claims is a mirrored struct from storage with JSON struct tags.\ntype Claims struct {\n\tUserID            string   `json:\"userID\"`\n\tUsername          string   `json:\"username\"`\n\tPreferredUsername string   `json:\"preferredUsername\"`\n\tEmail             string   `json:\"email\"`\n\tEmailVerified     bool     `json:\"emailVerified\"`\n\tGroups            []string `json:\"groups,omitempty\"`\n}\n\nfunc fromStorageClaims(i storage.Claims) Claims {\n\treturn Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\nfunc toStorageClaims(i Claims) storage.Claims {\n\treturn storage.Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\n// AuthRequest is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype AuthRequest struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tClientID      string   `json:\"clientID\"`\n\tResponseTypes []string `json:\"responseTypes,omitempty\"`\n\tScopes        []string `json:\"scopes,omitempty\"`\n\tRedirectURI   string   `json:\"redirectURI\"`\n\n\tNonce string `json:\"nonce,omitempty\"`\n\tState string `json:\"state,omitempty\"`\n\n\t// The client has indicated that the end user must be shown an approval prompt\n\t// on all requests. The server cannot cache their initial action for subsequent\n\t// attempts.\n\tForceApprovalPrompt bool `json:\"forceApprovalPrompt,omitempty\"`\n\n\tLoggedIn bool `json:\"loggedIn\"`\n\n\t// The identity of the end user. Generally nil until the user authenticates\n\t// with a backend.\n\tClaims Claims `json:\"claims,omitempty\"`\n\t// The connector used to login the user. Set when the user authenticates.\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\n// AuthRequestList is a list of AuthRequests.\ntype AuthRequestList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tAuthRequests    []AuthRequest `json:\"items\"`\n}\n\nfunc toStorageAuthRequest(req AuthRequest) storage.AuthRequest {\n\ta := storage.AuthRequest{\n\t\tID:                  req.ObjectMeta.Name,\n\t\tClientID:            req.ClientID,\n\t\tResponseTypes:       req.ResponseTypes,\n\t\tScopes:              req.Scopes,\n\t\tRedirectURI:         req.RedirectURI,\n\t\tNonce:               req.Nonce,\n\t\tState:               req.State,\n\t\tForceApprovalPrompt: req.ForceApprovalPrompt,\n\t\tLoggedIn:            req.LoggedIn,\n\t\tConnectorID:         req.ConnectorID,\n\t\tConnectorData:       req.ConnectorData,\n\t\tExpiry:              req.Expiry,\n\t\tClaims:              toStorageClaims(req.Claims),\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       req.CodeChallenge,\n\t\t\tCodeChallengeMethod: req.CodeChallengeMethod,\n\t\t},\n\t}\n\treturn a\n}\n\nfunc (cli *client) fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {\n\treq := AuthRequest{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindAuthRequest,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      a.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tExpiry:              a.Expiry,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t}\n\treturn req\n}\n\n// Password is a mirrored struct from the storage with JSON struct tags and\n// Kubernetes type metadata.\ntype Password struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// The Kubernetes name is actually an encoded version of this value.\n\t//\n\t// This field is IMMUTABLE. Do not change.\n\tEmail string `json:\"email,omitempty\"`\n\n\tHash     []byte `json:\"hash,omitempty\"`\n\tUsername string `json:\"username,omitempty\"`\n\tUserID   string `json:\"userID,omitempty\"`\n}\n\n// PasswordList is a list of Passwords.\ntype PasswordList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tPasswords       []Password `json:\"items\"`\n}\n\nfunc (cli *client) fromStoragePassword(p storage.Password) Password {\n\temail := strings.ToLower(p.Email)\n\treturn Password{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindPassword,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      cli.idToName(email),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tEmail:    email,\n\t\tHash:     p.Hash,\n\t\tUsername: p.Username,\n\t\tUserID:   p.UserID,\n\t}\n}\n\nfunc toStoragePassword(p Password) storage.Password {\n\treturn storage.Password{\n\t\tEmail:    p.Email,\n\t\tHash:     p.Hash,\n\t\tUsername: p.Username,\n\t\tUserID:   p.UserID,\n\t}\n}\n\n// AuthCode is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype AuthCode struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tClientID    string   `json:\"clientID\"`\n\tScopes      []string `json:\"scopes,omitempty\"`\n\tRedirectURI string   `json:\"redirectURI\"`\n\n\tNonce string `json:\"nonce,omitempty\"`\n\tState string `json:\"state,omitempty\"`\n\n\tClaims Claims `json:\"claims,omitempty\"`\n\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\n// AuthCodeList is a list of AuthCodes.\ntype AuthCodeList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tAuthCodes       []AuthCode `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageAuthCode(a storage.AuthCode) AuthCode {\n\treturn AuthCode{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindAuthCode,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      a.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tClientID:            a.ClientID,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tNonce:               a.Nonce,\n\t\tScopes:              a.Scopes,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tExpiry:              a.Expiry,\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t}\n}\n\nfunc toStorageAuthCode(a AuthCode) storage.AuthCode {\n\treturn storage.AuthCode{\n\t\tID:            a.ObjectMeta.Name,\n\t\tClientID:      a.ClientID,\n\t\tRedirectURI:   a.RedirectURI,\n\t\tConnectorID:   a.ConnectorID,\n\t\tConnectorData: a.ConnectorData,\n\t\tNonce:         a.Nonce,\n\t\tScopes:        a.Scopes,\n\t\tClaims:        toStorageClaims(a.Claims),\n\t\tExpiry:        a.Expiry,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\n// RefreshToken is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype RefreshToken struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tCreatedAt time.Time\n\tLastUsed  time.Time\n\n\tClientID string   `json:\"clientID\"`\n\tScopes   []string `json:\"scopes,omitempty\"`\n\n\tToken         string `json:\"token,omitempty\"`\n\tObsoleteToken string `json:\"obsoleteToken,omitempty\"`\n\n\tNonce string `json:\"nonce,omitempty\"`\n\n\tClaims        Claims `json:\"claims,omitempty\"`\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n}\n\n// RefreshList is a list of refresh tokens.\ntype RefreshList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tRefreshTokens   []RefreshToken `json:\"items\"`\n}\n\nfunc toStorageRefreshToken(r RefreshToken) storage.RefreshToken {\n\treturn storage.RefreshToken{\n\t\tID:            r.ObjectMeta.Name,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        toStorageClaims(r.Claims),\n\t}\n}\n\nfunc (cli *client) fromStorageRefreshToken(r storage.RefreshToken) RefreshToken {\n\treturn RefreshToken{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindRefreshToken,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      r.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        fromStorageClaims(r.Claims),\n\t}\n}\n\n// Keys is a mirrored struct from storage with JSON struct tags and Kubernetes\n// type metadata.\ntype Keys struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// Key for creating and verifying signatures. These may be nil.\n\tSigningKey    *jose.JSONWebKey `json:\"signingKey,omitempty\"`\n\tSigningKeyPub *jose.JSONWebKey `json:\"signingKeyPub,omitempty\"`\n\t// Old signing keys which have been rotated but can still be used to validate\n\t// existing signatures.\n\tVerificationKeys []storage.VerificationKey `json:\"verificationKeys,omitempty\"`\n\n\t// The next time the signing key will rotate.\n\t//\n\t// For caching purposes, implementations MUST NOT update keys before this time.\n\tNextRotation time.Time `json:\"nextRotation\"`\n}\n\nfunc (cli *client) fromStorageKeys(keys storage.Keys) Keys {\n\treturn Keys{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindKeys,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      keysName,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tSigningKey:       keys.SigningKey,\n\t\tSigningKeyPub:    keys.SigningKeyPub,\n\t\tVerificationKeys: keys.VerificationKeys,\n\t\tNextRotation:     keys.NextRotation,\n\t}\n}\n\nfunc toStorageKeys(keys Keys) storage.Keys {\n\treturn storage.Keys{\n\t\tSigningKey:       keys.SigningKey,\n\t\tSigningKeyPub:    keys.SigningKeyPub,\n\t\tVerificationKeys: keys.VerificationKeys,\n\t\tNextRotation:     keys.NextRotation,\n\t}\n}\n\n// OfflineSessions is a mirrored struct from storage with JSON struct tags and Kubernetes\n// type metadata.\ntype OfflineSessions struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tUserID        string                              `json:\"userID,omitempty\"`\n\tConnID        string                              `json:\"connID,omitempty\"`\n\tRefresh       map[string]*storage.RefreshTokenRef `json:\"refresh,omitempty\"`\n\tConnectorData []byte                              `json:\"connectorData,omitempty\"`\n}\n\nfunc (cli *client) fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {\n\treturn OfflineSessions{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindOfflineSessions,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      cli.offlineTokenName(o.UserID, o.ConnID),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n}\n\nfunc toStorageOfflineSessions(o OfflineSessions) storage.OfflineSessions {\n\ts := storage.OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n\tif s.Refresh == nil {\n\t\t// Server code assumes this will be non-nil.\n\t\ts.Refresh = make(map[string]*storage.RefreshTokenRef)\n\t}\n\treturn s\n}\n\n// Connector is a mirrored struct from storage with JSON struct tags and Kubernetes\n// type metadata.\ntype Connector struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tID   string `json:\"id,omitempty\"`\n\tType string `json:\"type,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n\t// Config holds connector specific configuration information\n\tConfig []byte `json:\"config,omitempty\"`\n}\n\nfunc (cli *client) fromStorageConnector(c storage.Connector) Connector {\n\treturn Connector{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindConnector,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      c.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tID:     c.ID,\n\t\tType:   c.Type,\n\t\tName:   c.Name,\n\t\tConfig: c.Config,\n\t}\n}\n\nfunc toStorageConnector(c Connector) storage.Connector {\n\treturn storage.Connector{\n\t\tID:              c.ID,\n\t\tType:            c.Type,\n\t\tName:            c.Name,\n\t\tResourceVersion: c.ObjectMeta.ResourceVersion,\n\t\tConfig:          c.Config,\n\t}\n}\n\n// ConnectorList is a list of Connectors.\ntype ConnectorList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tConnectors      []Connector `json:\"items\"`\n}\n\n// DeviceRequest is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype DeviceRequest struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tDeviceCode   string    `json:\"device_code,omitempty\"`\n\tClientID     string    `json:\"client_id,omitempty\"`\n\tClientSecret string    `json:\"client_secret,omitempty\"`\n\tScopes       []string  `json:\"scopes,omitempty\"`\n\tExpiry       time.Time `json:\"expiry\"`\n}\n\n// DeviceRequestList is a list of DeviceRequests.\ntype DeviceRequestList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tDeviceRequests  []DeviceRequest `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageDeviceRequest(a storage.DeviceRequest) DeviceRequest {\n\treq := DeviceRequest{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindDeviceRequest,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      strings.ToLower(a.UserCode),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tDeviceCode:   a.DeviceCode,\n\t\tClientID:     a.ClientID,\n\t\tClientSecret: a.ClientSecret,\n\t\tScopes:       a.Scopes,\n\t\tExpiry:       a.Expiry,\n\t}\n\treturn req\n}\n\nfunc toStorageDeviceRequest(req DeviceRequest) storage.DeviceRequest {\n\treturn storage.DeviceRequest{\n\t\tUserCode:     strings.ToUpper(req.ObjectMeta.Name),\n\t\tDeviceCode:   req.DeviceCode,\n\t\tClientID:     req.ClientID,\n\t\tClientSecret: req.ClientSecret,\n\t\tScopes:       req.Scopes,\n\t\tExpiry:       req.Expiry,\n\t}\n}\n\n// DeviceToken is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype DeviceToken struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tStatus              string    `json:\"status,omitempty\"`\n\tToken               string    `json:\"token,omitempty\"`\n\tExpiry              time.Time `json:\"expiry\"`\n\tLastRequestTime     time.Time `json:\"last_request\"`\n\tPollIntervalSeconds int       `json:\"poll_interval\"`\n\tCodeChallenge       string    `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string    `json:\"code_challenge_method,omitempty\"`\n}\n\n// DeviceTokenList is a list of DeviceTokens.\ntype DeviceTokenList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tDeviceTokens    []DeviceToken `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageDeviceToken(t storage.DeviceToken) DeviceToken {\n\treq := DeviceToken{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindDeviceToken,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      t.DeviceCode,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tCodeChallenge:       t.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: t.PKCE.CodeChallengeMethod,\n\t}\n\treturn req\n}\n\nfunc toStorageDeviceToken(t DeviceToken) storage.DeviceToken {\n\treturn storage.DeviceToken{\n\t\tDeviceCode:          t.ObjectMeta.Name,\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       t.CodeChallenge,\n\t\t\tCodeChallengeMethod: t.CodeChallengeMethod,\n\t\t},\n\t}\n}\n", "package sql\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// TODO(ericchiang): The update, insert, and select methods queries are all\n// very repetitive. Consider creating them programmatically.\n\n// keysRowID is the ID of the only row we expect to populate the \"keys\" table.\nconst keysRowID = \"keys\"\n\n// encoder wraps the underlying value in a JSON marshaler which is automatically\n// called by the database/sql package.\n//\n//\t\ts := []string{\"planes\", \"bears\"}\n//\t\terr := db.Exec(`insert into t1 (id, things) values (1, $1)`, encoder(s))\n//\t\tif err != nil {\n//\t\t\t// handle error\n//\t\t}\n//\n//\t\tvar r []byte\n//\t\terr = db.QueryRow(`select things from t1 where id = 1;`).Scan(&r)\n//\t\tif err != nil {\n//\t\t\t// handle error\n//\t\t}\n//\t\tfmt.Printf(\"%s\\n\", r) // [\"planes\",\"bears\"]\n//\nfunc encoder(i interface{}) driver.Valuer {\n\treturn jsonEncoder{i}\n}\n\n// decoder wraps the underlying value in a JSON unmarshaler which can then be passed\n// to a database Scan() method.\nfunc decoder(i interface{}) sql.Scanner {\n\treturn jsonDecoder{i}\n}\n\ntype jsonEncoder struct {\n\ti interface{}\n}\n\nfunc (j jsonEncoder) Value() (driver.Value, error) {\n\tb, err := json.Marshal(j.i)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"marshal: %v\", err)\n\t}\n\treturn b, nil\n}\n\ntype jsonDecoder struct {\n\ti interface{}\n}\n\nfunc (j jsonDecoder) Scan(dest interface{}) error {\n\tif dest == nil {\n\t\treturn errors.New(\"nil value\")\n\t}\n\tb, ok := dest.([]byte)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected []byte got %T\", dest)\n\t}\n\tif err := json.Unmarshal(b, &j.i); err != nil {\n\t\treturn fmt.Errorf(\"unmarshal: %v\", err)\n\t}\n\treturn nil\n}\n\n// Abstract conn vs trans.\ntype querier interface {\n\tQueryRow(query string, args ...interface{}) *sql.Row\n}\n\n// Abstract row vs rows.\ntype scanner interface {\n\tScan(dest ...interface{}) error\n}\n\nfunc (c *conn) GarbageCollect(now time.Time) (storage.GCResult, error) {\n\tresult := storage.GCResult{}\n\n\tr, err := c.Exec(`delete from auth_request where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc auth_request: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.AuthRequests = n\n\t}\n\n\tr, err = c.Exec(`delete from auth_code where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc auth_code: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.AuthCodes = n\n\t}\n\n\tr, err = c.Exec(`delete from device_request where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc device_request: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.DeviceRequests = n\n\t}\n\n\tr, err = c.Exec(`delete from device_token where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc device_token: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.DeviceTokens = n\n\t}\n\n\treturn result, err\n}\n\nfunc (c *conn) CreateAuthRequest(a storage.AuthRequest) error {\n\t_, err := c.Exec(`\n\t\tinsert into auth_request (\n\t\t\tid, client_id, response_types, scopes, redirect_uri, nonce, state,\n\t\t\tforce_approval_prompt, logged_in,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\texpiry,\n\t\t\tcode_challenge, code_challenge_method\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20\n\t\t);\n\t`,\n\t\ta.ID, a.ClientID, encoder(a.ResponseTypes), encoder(a.Scopes), a.RedirectURI, a.Nonce, a.State,\n\t\ta.ForceApprovalPrompt, a.LoggedIn,\n\t\ta.Claims.UserID, a.Claims.Username, a.Claims.PreferredUsername,\n\t\ta.Claims.Email, a.Claims.EmailVerified, encoder(a.Claims.Groups),\n\t\ta.ConnectorID, a.ConnectorData,\n\t\ta.Expiry,\n\t\ta.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert auth request: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateAuthRequest(id string, updater func(a storage.AuthRequest) (storage.AuthRequest, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tr, err := getAuthRequest(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ta, err := updater(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate auth_request\n\t\t\tset\n\t\t\t\tclient_id = $1, response_types = $2, scopes = $3, redirect_uri = $4,\n\t\t\t\tnonce = $5, state = $6, force_approval_prompt = $7, logged_in = $8,\n\t\t\t\tclaims_user_id = $9, claims_username = $10, claims_preferred_username = $11,\n\t\t\t\tclaims_email = $12, claims_email_verified = $13,\n\t\t\t\tclaims_groups = $14,\n\t\t\t\tconnector_id = $15, connector_data = $16,\n\t\t\t\texpiry = $17,\n\t\t\t\tcode_challenge = $18, code_challenge_method = $19\n\t\t\twhere id = $20;\n\t\t`,\n\t\t\ta.ClientID, encoder(a.ResponseTypes), encoder(a.Scopes), a.RedirectURI, a.Nonce, a.State,\n\t\t\ta.ForceApprovalPrompt, a.LoggedIn,\n\t\t\ta.Claims.UserID, a.Claims.Username, a.Claims.PreferredUsername,\n\t\t\ta.Claims.Email, a.Claims.EmailVerified,\n\t\t\tencoder(a.Claims.Groups),\n\t\t\ta.ConnectorID, a.ConnectorData,\n\t\t\ta.Expiry,\n\t\t\ta.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod,\n\t\t\tr.ID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update auth request: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetAuthRequest(id string) (storage.AuthRequest, error) {\n\treturn getAuthRequest(c, id)\n}\n\nfunc getAuthRequest(q querier, id string) (a storage.AuthRequest, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n\t\t\tid, client_id, response_types, scopes, redirect_uri, nonce, state,\n\t\t\tforce_approval_prompt, logged_in,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data, expiry,\n\t\t\tcode_challenge, code_challenge_method\n\t\tfrom auth_request where id = $1;\n\t`, id).Scan(\n\t\t&a.ID, &a.ClientID, decoder(&a.ResponseTypes), decoder(&a.Scopes), &a.RedirectURI, &a.Nonce, &a.State,\n\t\t&a.ForceApprovalPrompt, &a.LoggedIn,\n\t\t&a.Claims.UserID, &a.Claims.Username, &a.Claims.PreferredUsername,\n\t\t&a.Claims.Email, &a.Claims.EmailVerified,\n\t\tdecoder(&a.Claims.Groups),\n\t\t&a.ConnectorID, &a.ConnectorData, &a.Expiry,\n\t\t&a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn a, storage.ErrNotFound\n\t\t}\n\t\treturn a, fmt.Errorf(\"select auth request: %v\", err)\n\t}\n\treturn a, nil\n}\n\nfunc (c *conn) CreateAuthCode(a storage.AuthCode) error {\n\t_, err := c.Exec(`\n\t\tinsert into auth_code (\n\t\t\tid, client_id, scopes, nonce, redirect_uri,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\texpiry,\n\t\t\tcode_challenge, code_challenge_method\n\t\t)\n\t\tvalues ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16);\n\t`,\n\t\ta.ID, a.ClientID, encoder(a.Scopes), a.Nonce, a.RedirectURI, a.Claims.UserID,\n\t\ta.Claims.Username, a.Claims.PreferredUsername, a.Claims.Email, a.Claims.EmailVerified,\n\t\tencoder(a.Claims.Groups), a.ConnectorID, a.ConnectorData, a.Expiry,\n\t\ta.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert auth code: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) GetAuthCode(id string) (a storage.AuthCode, err error) {\n\terr = c.QueryRow(`\n\t\tselect\n\t\t\tid, client_id, scopes, nonce, redirect_uri,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\texpiry,\n\t\t\tcode_challenge, code_challenge_method\n\t\tfrom auth_code where id = $1;\n\t`, id).Scan(\n\t\t&a.ID, &a.ClientID, decoder(&a.Scopes), &a.Nonce, &a.RedirectURI, &a.Claims.UserID,\n\t\t&a.Claims.Username, &a.Claims.PreferredUsername, &a.Claims.Email, &a.Claims.EmailVerified,\n\t\tdecoder(&a.Claims.Groups), &a.ConnectorID, &a.ConnectorData, &a.Expiry,\n\t\t&a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn a, storage.ErrNotFound\n\t\t}\n\t\treturn a, fmt.Errorf(\"select auth code: %v\", err)\n\t}\n\treturn a, nil\n}\n\nfunc (c *conn) CreateRefresh(r storage.RefreshToken) error {\n\t_, err := c.Exec(`\n\t\tinsert into refresh_token (\n\t\t\tid, client_id, scopes, nonce,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\ttoken, obsolete_token, created_at, last_used\n\t\t)\n\t\tvalues ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16);\n\t`,\n\t\tr.ID, r.ClientID, encoder(r.Scopes), r.Nonce,\n\t\tr.Claims.UserID, r.Claims.Username, r.Claims.PreferredUsername,\n\t\tr.Claims.Email, r.Claims.EmailVerified,\n\t\tencoder(r.Claims.Groups),\n\t\tr.ConnectorID, r.ConnectorData,\n\t\tr.Token, r.ObsoleteToken, r.CreatedAt, r.LastUsed,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert refresh_token: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateRefreshToken(id string, updater func(old storage.RefreshToken) (storage.RefreshToken, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tr, err := getRefresh(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r, err = updater(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate refresh_token\n\t\t\tset\n\t\t\t\tclient_id = $1,\n\t\t\t\tscopes = $2,\n\t\t\t\tnonce = $3,\n\t\t\t\tclaims_user_id = $4,\n\t\t\t\tclaims_username = $5,\n\t\t\t\tclaims_preferred_username = $6,\n\t\t\t\tclaims_email = $7,\n\t\t\t\tclaims_email_verified = $8,\n\t\t\t\tclaims_groups = $9,\n\t\t\t\tconnector_id = $10,\n\t\t\t\tconnector_data = $11,\n\t\t\t\ttoken = $12,\n                obsolete_token = $13,\n\t\t\t\tcreated_at = $14,\n\t\t\t\tlast_used = $15\n\t\t\twhere\n\t\t\t\tid = $16\n\t\t`,\n\t\t\tr.ClientID, encoder(r.Scopes), r.Nonce,\n\t\t\tr.Claims.UserID, r.Claims.Username, r.Claims.PreferredUsername,\n\t\t\tr.Claims.Email, r.Claims.EmailVerified,\n\t\t\tencoder(r.Claims.Groups),\n\t\t\tr.ConnectorID, r.ConnectorData,\n\t\t\tr.Token, r.ObsoleteToken, r.CreatedAt, r.LastUsed, id,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update refresh token: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetRefresh(id string) (storage.RefreshToken, error) {\n\treturn getRefresh(c, id)\n}\n\nfunc getRefresh(q querier, id string) (storage.RefreshToken, error) {\n\treturn scanRefresh(q.QueryRow(`\n\t\tselect\n\t\t\tid, client_id, scopes, nonce,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified,\n\t\t\tclaims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\ttoken, obsolete_token, created_at, last_used\n\t\tfrom refresh_token where id = $1;\n\t`, id))\n}\n\nfunc (c *conn) ListRefreshTokens() ([]storage.RefreshToken, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\tid, client_id, scopes, nonce,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\ttoken, obsolete_token, created_at, last_used\n\t\tfrom refresh_token;\n\t`)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query: %v\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar tokens []storage.RefreshToken\n\tfor rows.Next() {\n\t\tr, err := scanRefresh(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttokens = append(tokens, r)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"scan: %v\", err)\n\t}\n\treturn tokens, nil\n}\n\nfunc scanRefresh(s scanner) (r storage.RefreshToken, err error) {\n\terr = s.Scan(\n\t\t&r.ID, &r.ClientID, decoder(&r.Scopes), &r.Nonce,\n\t\t&r.Claims.UserID, &r.Claims.Username, &r.Claims.PreferredUsername,\n\t\t&r.Claims.Email, &r.Claims.EmailVerified,\n\t\tdecoder(&r.Claims.Groups),\n\t\t&r.ConnectorID, &r.ConnectorData,\n\t\t&r.Token, &r.ObsoleteToken, &r.CreatedAt, &r.LastUsed,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn r, storage.ErrNotFound\n\t\t}\n\t\treturn r, fmt.Errorf(\"scan refresh_token: %v\", err)\n\t}\n\treturn r, nil\n}\n\nfunc (c *conn) UpdateKeys(updater func(old storage.Keys) (storage.Keys, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tfirstUpdate := false\n\t\t// TODO(ericchiang): errors may cause a transaction be rolled back by the SQL\n\t\t// server. Test this, and consider adding a COUNT() command beforehand.\n\t\told, err := getKeys(tx)\n\t\tif err != nil {\n\t\t\tif err != storage.ErrNotFound {\n\t\t\t\treturn fmt.Errorf(\"get keys: %v\", err)\n\t\t\t}\n\t\t\tfirstUpdate = true\n\t\t\told = storage.Keys{}\n\t\t}\n\n\t\tnk, err := updater(old)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif firstUpdate {\n\t\t\t_, err = tx.Exec(`\n\t\t\t\tinsert into keys (\n\t\t\t\t\tid, verification_keys, signing_key, signing_key_pub, next_rotation\n\t\t\t\t)\n\t\t\t\tvalues ($1, $2, $3, $4, $5);\n\t\t\t`,\n\t\t\t\tkeysRowID, encoder(nk.VerificationKeys), encoder(nk.SigningKey),\n\t\t\t\tencoder(nk.SigningKeyPub), nk.NextRotation,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"insert: %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t_, err = tx.Exec(`\n\t\t\t\tupdate keys\n\t\t\t\tset\n\t\t\t\t    verification_keys = $1,\n\t\t\t\t\tsigning_key = $2,\n\t\t\t\t\tsigning_key_pub = $3,\n\t\t\t\t\tnext_rotation = $4\n\t\t\t\twhere id = $5;\n\t\t\t`,\n\t\t\t\tencoder(nk.VerificationKeys), encoder(nk.SigningKey),\n\t\t\t\tencoder(nk.SigningKeyPub), nk.NextRotation, keysRowID,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"update: %v\", err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetKeys() (keys storage.Keys, err error) {\n\treturn getKeys(c)\n}\n\nfunc getKeys(q querier) (keys storage.Keys, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n\t\t\tverification_keys, signing_key, signing_key_pub, next_rotation\n\t\tfrom keys\n\t\twhere id=$1\n\t`, keysRowID).Scan(\n\t\tdecoder(&keys.VerificationKeys), decoder(&keys.SigningKey),\n\t\tdecoder(&keys.SigningKeyPub), &keys.NextRotation,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn keys, storage.ErrNotFound\n\t\t}\n\t\treturn keys, fmt.Errorf(\"query keys: %v\", err)\n\t}\n\treturn keys, nil\n}\n\nfunc (c *conn) UpdateClient(id string, updater func(old storage.Client) (storage.Client, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tcli, err := getClient(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnc, err := updater(cli)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = tx.Exec(`\n\t\t\tupdate client\n\t\t\tset\n\t\t\t\tsecret = $1,\n\t\t\t\tredirect_uris = $2,\n\t\t\t\ttrusted_peers = $3,\n\t\t\t\tpublic = $4,\n\t\t\t\tname = $5,\n\t\t\t\tlogo_url = $6\n\t\t\twhere id = $7;\n\t\t`, nc.Secret, encoder(nc.RedirectURIs), encoder(nc.TrustedPeers), nc.Public, nc.Name, nc.LogoURL, id,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update client: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) CreateClient(cli storage.Client) error {\n\t_, err := c.Exec(`\n\t\tinsert into client (\n\t\t\tid, secret, redirect_uris, trusted_peers, public, name, logo_url\n\t\t)\n\t\tvalues ($1, $2, $3, $4, $5, $6, $7);\n\t`,\n\t\tcli.ID, cli.Secret, encoder(cli.RedirectURIs), encoder(cli.TrustedPeers),\n\t\tcli.Public, cli.Name, cli.LogoURL,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert client: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc getClient(q querier, id string) (storage.Client, error) {\n\treturn scanClient(q.QueryRow(`\n\t\tselect\n\t\t\tid, secret, redirect_uris, trusted_peers, public, name, logo_url\n\t    from client where id = $1;\n\t`, id))\n}\n\nfunc (c *conn) GetClient(id string) (storage.Client, error) {\n\treturn getClient(c, id)\n}\n\nfunc (c *conn) ListClients() ([]storage.Client, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\tid, secret, redirect_uris, trusted_peers, public, name, logo_url\n\t\tfrom client;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar clients []storage.Client\n\tfor rows.Next() {\n\t\tcli, err := scanClient(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tclients = append(clients, cli)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn clients, nil\n}\n\nfunc scanClient(s scanner) (cli storage.Client, err error) {\n\terr = s.Scan(\n\t\t&cli.ID, &cli.Secret, decoder(&cli.RedirectURIs), decoder(&cli.TrustedPeers),\n\t\t&cli.Public, &cli.Name, &cli.LogoURL,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn cli, storage.ErrNotFound\n\t\t}\n\t\treturn cli, fmt.Errorf(\"get client: %v\", err)\n\t}\n\treturn cli, nil\n}\n\nfunc (c *conn) CreatePassword(p storage.Password) error {\n\tp.Email = strings.ToLower(p.Email)\n\t_, err := c.Exec(`\n\t\tinsert into password (\n\t\t\temail, hash, username, user_id\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4\n\t\t);\n\t`,\n\t\tp.Email, p.Hash, p.Username, p.UserID,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert password: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdatePassword(email string, updater func(p storage.Password) (storage.Password, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tp, err := getPassword(tx, email)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnp, err := updater(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate password\n\t\t\tset\n\t\t\t\thash = $1, username = $2, user_id = $3\n\t\t\twhere email = $4;\n\t\t`,\n\t\t\tnp.Hash, np.Username, np.UserID, p.Email,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update password: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetPassword(email string) (storage.Password, error) {\n\treturn getPassword(c, email)\n}\n\nfunc getPassword(q querier, email string) (p storage.Password, err error) {\n\treturn scanPassword(q.QueryRow(`\n\t\tselect\n\t\t\temail, hash, username, user_id\n\t\tfrom password where email = $1;\n\t`, strings.ToLower(email)))\n}\n\nfunc (c *conn) ListPasswords() ([]storage.Password, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\temail, hash, username, user_id\n\t\tfrom password;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar passwords []storage.Password\n\tfor rows.Next() {\n\t\tp, err := scanPassword(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpasswords = append(passwords, p)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn passwords, nil\n}\n\nfunc scanPassword(s scanner) (p storage.Password, err error) {\n\terr = s.Scan(\n\t\t&p.Email, &p.Hash, &p.Username, &p.UserID,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn p, storage.ErrNotFound\n\t\t}\n\t\treturn p, fmt.Errorf(\"select password: %v\", err)\n\t}\n\treturn p, nil\n}\n\nfunc (c *conn) CreateOfflineSessions(s storage.OfflineSessions) error {\n\t_, err := c.Exec(`\n\t\tinsert into offline_session (\n\t\t\tuser_id, conn_id, refresh, connector_data\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4\n\t\t);\n\t`,\n\t\ts.UserID, s.ConnID, encoder(s.Refresh), s.ConnectorData,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert offline session: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateOfflineSessions(userID string, connID string, updater func(s storage.OfflineSessions) (storage.OfflineSessions, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\ts, err := getOfflineSessions(tx, userID, connID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnewSession, err := updater(s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate offline_session\n\t\t\tset\n\t\t\t\trefresh = $1,\n\t\t\t\tconnector_data = $2\n\t\t\twhere user_id = $3 AND conn_id = $4;\n\t\t`,\n\t\t\tencoder(newSession.Refresh), newSession.ConnectorData, s.UserID, s.ConnID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update offline session: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetOfflineSessions(userID string, connID string) (storage.OfflineSessions, error) {\n\treturn getOfflineSessions(c, userID, connID)\n}\n\nfunc getOfflineSessions(q querier, userID string, connID string) (storage.OfflineSessions, error) {\n\treturn scanOfflineSessions(q.QueryRow(`\n\t\tselect\n\t\t\tuser_id, conn_id, refresh, connector_data\n\t\tfrom offline_session\n\t\twhere user_id = $1 AND conn_id = $2;\n\t\t`, userID, connID))\n}\n\nfunc scanOfflineSessions(s scanner) (o storage.OfflineSessions, err error) {\n\terr = s.Scan(\n\t\t&o.UserID, &o.ConnID, decoder(&o.Refresh), &o.ConnectorData,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn o, storage.ErrNotFound\n\t\t}\n\t\treturn o, fmt.Errorf(\"select offline session: %v\", err)\n\t}\n\treturn o, nil\n}\n\nfunc (c *conn) CreateConnector(connector storage.Connector) error {\n\t_, err := c.Exec(`\n\t\tinsert into connector (\n\t\t\tid, type, name, resource_version, config\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5\n\t\t);\n\t`,\n\t\tconnector.ID, connector.Type, connector.Name, connector.ResourceVersion, connector.Config,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert connector: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateConnector(id string, updater func(s storage.Connector) (storage.Connector, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tconnector, err := getConnector(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnewConn, err := updater(connector)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate connector\n\t\t\tset\n\t\t\t    type = $1,\n\t\t\t    name = $2,\n\t\t\t    resource_version = $3,\n\t\t\t    config = $4\n\t\t\twhere id = $5;\n\t\t`,\n\t\t\tnewConn.Type, newConn.Name, newConn.ResourceVersion, newConn.Config, connector.ID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update connector: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetConnector(id string) (storage.Connector, error) {\n\treturn getConnector(c, id)\n}\n\nfunc getConnector(q querier, id string) (storage.Connector, error) {\n\treturn scanConnector(q.QueryRow(`\n\t\tselect\n\t\t\tid, type, name, resource_version, config\n\t\tfrom connector\n\t\twhere id = $1;\n\t\t`, id))\n}\n\nfunc scanConnector(s scanner) (c storage.Connector, err error) {\n\terr = s.Scan(\n\t\t&c.ID, &c.Type, &c.Name, &c.ResourceVersion, &c.Config,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn c, storage.ErrNotFound\n\t\t}\n\t\treturn c, fmt.Errorf(\"select connector: %v\", err)\n\t}\n\treturn c, nil\n}\n\nfunc (c *conn) ListConnectors() ([]storage.Connector, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\tid, type, name, resource_version, config\n\t\tfrom connector;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar connectors []storage.Connector\n\tfor rows.Next() {\n\t\tconn, err := scanConnector(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconnectors = append(connectors, conn)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn connectors, nil\n}\n\nfunc (c *conn) DeleteAuthRequest(id string) error { return c.delete(\"auth_request\", \"id\", id) }\nfunc (c *conn) DeleteAuthCode(id string) error    { return c.delete(\"auth_code\", \"id\", id) }\nfunc (c *conn) DeleteClient(id string) error      { return c.delete(\"client\", \"id\", id) }\nfunc (c *conn) DeleteRefresh(id string) error     { return c.delete(\"refresh_token\", \"id\", id) }\nfunc (c *conn) DeletePassword(email string) error {\n\treturn c.delete(\"password\", \"email\", strings.ToLower(email))\n}\nfunc (c *conn) DeleteConnector(id string) error { return c.delete(\"connector\", \"id\", id) }\n\nfunc (c *conn) DeleteOfflineSessions(userID string, connID string) error {\n\tresult, err := c.Exec(`delete from offline_session where user_id = $1 AND conn_id = $2`, userID, connID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete offline_session: user_id = %s, conn_id = %s\", userID, connID)\n\t}\n\n\t// For now mandate that the driver implements RowsAffected. If we ever need to support\n\t// a driver that doesn't implement this, we can run this in a transaction with a get beforehand.\n\tn, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rows affected: %v\", err)\n\t}\n\tif n < 1 {\n\t\treturn storage.ErrNotFound\n\t}\n\treturn nil\n}\n\n// Do NOT call directly. Does not escape table.\nfunc (c *conn) delete(table, field, id string) error {\n\tresult, err := c.Exec(`delete from `+table+` where `+field+` = $1`, id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete %s: %v\", table, id)\n\t}\n\n\t// For now mandate that the driver implements RowsAffected. If we ever need to support\n\t// a driver that doesn't implement this, we can run this in a transaction with a get beforehand.\n\tn, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rows affected: %v\", err)\n\t}\n\tif n < 1 {\n\t\treturn storage.ErrNotFound\n\t}\n\treturn nil\n}\n\nfunc (c *conn) CreateDeviceRequest(d storage.DeviceRequest) error {\n\t_, err := c.Exec(`\n\t\tinsert into device_request (\n\t\t\tuser_code, device_code, client_id, client_secret, scopes, expiry\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5, $6\n\t\t);`,\n\t\td.UserCode, d.DeviceCode, d.ClientID, d.ClientSecret, encoder(d.Scopes), d.Expiry,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert device request: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) CreateDeviceToken(t storage.DeviceToken) error {\n\t_, err := c.Exec(`\n\t\tinsert into device_token (\n\t\t\tdevice_code, status, token, expiry, last_request, poll_interval, code_challenge, code_challenge_method\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5, $6, $7, $8\n\t\t);`,\n\t\tt.DeviceCode, t.Status, t.Token, t.Expiry, t.LastRequestTime, t.PollIntervalSeconds, t.PKCE.CodeChallenge, t.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert device token: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) GetDeviceRequest(userCode string) (storage.DeviceRequest, error) {\n\treturn getDeviceRequest(c, userCode)\n}\n\nfunc getDeviceRequest(q querier, userCode string) (d storage.DeviceRequest, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n            device_code, client_id, client_secret, scopes, expiry\n\t\tfrom device_request where user_code = $1;\n\t`, userCode).Scan(\n\t\t&d.DeviceCode, &d.ClientID, &d.ClientSecret, decoder(&d.Scopes), &d.Expiry,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn d, storage.ErrNotFound\n\t\t}\n\t\treturn d, fmt.Errorf(\"select device token: %v\", err)\n\t}\n\td.UserCode = userCode\n\treturn d, nil\n}\n\nfunc (c *conn) GetDeviceToken(deviceCode string) (storage.DeviceToken, error) {\n\treturn getDeviceToken(c, deviceCode)\n}\n\nfunc getDeviceToken(q querier, deviceCode string) (a storage.DeviceToken, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n            status, token, expiry, last_request, poll_interval, code_challenge, code_challenge_method\n\t\tfrom device_token where device_code = $1;\n\t`, deviceCode).Scan(\n\t\t&a.Status, &a.Token, &a.Expiry, &a.LastRequestTime, &a.PollIntervalSeconds, &a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn a, storage.ErrNotFound\n\t\t}\n\t\treturn a, fmt.Errorf(\"select device token: %v\", err)\n\t}\n\ta.DeviceCode = deviceCode\n\treturn a, nil\n}\n\nfunc (c *conn) UpdateDeviceToken(deviceCode string, updater func(old storage.DeviceToken) (storage.DeviceToken, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tr, err := getDeviceToken(tx, deviceCode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r, err = updater(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate device_token\n\t\t\tset\n\t\t\t\tstatus = $1, \n\t\t\t\ttoken = $2,\n\t\t\t\tlast_request = $3,\n\t\t\t\tpoll_interval = $4,\n\t\t\t\tcode_challenge = $5,\n\t\t\t\tcode_challenge_method = $6\n\t\t\twhere\n\t\t\t\tdevice_code = $7\n\t\t`,\n\t\t\tr.Status, r.Token, r.LastRequestTime, r.PollIntervalSeconds, r.PKCE.CodeChallenge, r.PKCE.CodeChallengeMethod, r.DeviceCode,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update device token: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package sql\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n)\n\nfunc (c *conn) migrate() (int, error) {\n\t_, err := c.Exec(`\n\t\tcreate table if not exists migrations (\n\t\t\tnum integer not null,\n\t\t\tat timestamptz not null\n\t\t);\n\t`)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"creating migration table: %v\", err)\n\t}\n\n\ti := 0\n\tdone := false\n\n\tvar flavorMigrations []migration\n\tfor _, m := range migrations {\n\t\tif m.flavor == nil || m.flavor == c.flavor {\n\t\t\tflavorMigrations = append(flavorMigrations, m)\n\t\t}\n\t}\n\n\tfor {\n\t\terr := c.ExecTx(func(tx *trans) error {\n\t\t\t// Within a transaction, perform a single migration.\n\t\t\tvar (\n\t\t\t\tnum sql.NullInt64\n\t\t\t\tn   int\n\t\t\t)\n\t\t\tif err := tx.QueryRow(`select max(num) from migrations;`).Scan(&num); err != nil {\n\t\t\t\treturn fmt.Errorf(\"select max migration: %v\", err)\n\t\t\t}\n\t\t\tif num.Valid {\n\t\t\t\tn = int(num.Int64)\n\t\t\t}\n\t\t\tif n >= len(flavorMigrations) {\n\t\t\t\tdone = true\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tmigrationNum := n + 1\n\t\t\tm := flavorMigrations[n]\n\t\t\tfor i := range m.stmts {\n\t\t\t\tif _, err := tx.Exec(m.stmts[i]); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"migration %d statement %d failed: %v\", migrationNum, i+1, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq := `insert into migrations (num, at) values ($1, now());`\n\t\t\tif _, err := tx.Exec(q, migrationNum); err != nil {\n\t\t\t\treturn fmt.Errorf(\"update migration table: %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn i, err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\ti++\n\t}\n\n\treturn i, nil\n}\n\ntype migration struct {\n\tstmts []string\n\n\t// If flavor is nil the migration will take place for all database backend flavors.\n\t// If specified, only for that corresponding flavor, in that case stmts can be written\n\t// in the specific SQL dialect.\n\tflavor *flavor\n}\n\n// All SQL flavors share migration strategies.\nvar migrations = []migration{\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table client (\n\t\t\t\tid text not null primary key,\n\t\t\t\tsecret text not null,\n\t\t\t\tredirect_uris bytea not null, -- JSON array of strings\n\t\t\t\ttrusted_peers bytea not null, -- JSON array of strings\n\t\t\t\tpublic boolean not null,\n\t\t\t\tname text not null,\n\t\t\t\tlogo_url text not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table auth_request (\n\t\t\t\tid text not null primary key,\n\t\t\t\tclient_id text not null,\n\t\t\t\tresponse_types bytea not null, -- JSON array of strings\n\t\t\t\tscopes bytea not null,         -- JSON array of strings\n\t\t\t\tredirect_uri text not null,\n\t\t\t\tnonce text not null,\n\t\t\t\tstate text not null,\n\t\t\t\tforce_approval_prompt boolean not null,\n\n\t\t\t\tlogged_in boolean not null,\n\n\t\t\t\tclaims_user_id text not null,\n\t\t\t\tclaims_username text not null,\n\t\t\t\tclaims_email text not null,\n\t\t\t\tclaims_email_verified boolean not null,\n\t\t\t\tclaims_groups bytea not null, -- JSON array of strings\n\n\t\t\t\tconnector_id text not null,\n\t\t\t\tconnector_data bytea,\n\n\t\t\t\texpiry timestamptz not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table auth_code (\n\t\t\t\tid text not null primary key,\n\t\t\t\tclient_id text not null,\n\t\t\t\tscopes bytea not null, -- JSON array of strings\n\t\t\t\tnonce text not null,\n\t\t\t\tredirect_uri text not null,\n\n\t\t\t\tclaims_user_id text not null,\n\t\t\t\tclaims_username text not null,\n\t\t\t\tclaims_email text not null,\n\t\t\t\tclaims_email_verified boolean not null,\n\t\t\t\tclaims_groups bytea not null, -- JSON array of strings\n\n\t\t\t\tconnector_id text not null,\n\t\t\t\tconnector_data bytea,\n\n\t\t\t\texpiry timestamptz not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table refresh_token (\n\t\t\t\tid text not null primary key,\n\t\t\t\tclient_id text not null,\n\t\t\t\tscopes bytea not null, -- JSON array of strings\n\t\t\t\tnonce text not null,\n\n\t\t\t\tclaims_user_id text not null,\n\t\t\t\tclaims_username text not null,\n\t\t\t\tclaims_email text not null,\n\t\t\t\tclaims_email_verified boolean not null,\n\t\t\t\tclaims_groups bytea not null, -- JSON array of strings\n\n\t\t\t\tconnector_id text not null,\n\t\t\t\tconnector_data bytea\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table password (\n\t\t\t\temail text not null primary key,\n\t\t\t\thash bytea not null,\n\t\t\t\tusername text not null,\n\t\t\t\tuser_id text not null\n\t\t\t);`,\n\t\t\t`\n\t\t\t-- keys is a weird table because we only ever expect there to be a single row\n\t\t\tcreate table keys (\n\t\t\t\tid text not null primary key,\n\t\t\t\tverification_keys bytea not null, -- JSON array\n\t\t\t\tsigning_key bytea not null,       -- JSON object\n\t\t\t\tsigning_key_pub bytea not null,   -- JSON object\n\t\t\t\tnext_rotation timestamptz not null\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column token text not null default '';`,\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column created_at timestamptz not null default '0001-01-01 00:00:00 UTC';`,\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column last_used timestamptz not null default '0001-01-01 00:00:00 UTC';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table offline_session (\n\t\t\t\tuser_id text not null,\n\t\t\t\tconn_id text not null,\n\t\t\t\trefresh bytea not null,\n\t\t\t\tPRIMARY KEY (user_id, conn_id)\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table connector (\n\t\t\t\tid text not null primary key,\n\t\t\t\ttype text not null,\n\t\t\t\tname text not null,\n\t\t\t\tresource_version text not null,\n\t\t\t\tconfig bytea\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_code\n\t\t\t\tadd column claims_preferred_username text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column claims_preferred_username text not null default '';`,\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column claims_preferred_username text not null default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table offline_session\n\t\t\t\tadd column connector_data bytea;\n\t\t\t`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tmodify column state varchar(4096);\n\t\t\t`,\n\t\t},\n\t\tflavor: &flavorMySQL,\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table device_request (\n\t\t\t\tuser_code text not null primary key,\n\t\t\t\tdevice_code text not null,\n\t\t\t\tclient_id text not null,\n\t\t\t\tclient_secret text ,\n\t\t\t\tscopes bytea not null, -- JSON array of strings\n\t\t\t\texpiry timestamptz not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table device_token (\n\t\t\t\tdevice_code text not null primary key,\n\t\t\t\tstatus text not null,\n\t\t\t\ttoken bytea,\n\t\t\t\texpiry timestamptz not null,\n\t\t\t\tlast_request timestamptz not null,\n                poll_interval integer not null\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column code_challenge text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column code_challenge_method text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_code\n\t\t\t\tadd column code_challenge text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_code\n\t\t\t\tadd column code_challenge_method text not null default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column obsolete_token text default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table device_token\n\t\t\t\tadd column code_challenge text not null default '';`,\n\t\t\t`\n\t\t\talter table device_token\n\t\t\t\tadd column code_challenge_method text not null default '';`,\n\t\t},\n\t},\n}\n", "package storage\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base32\"\n\t\"errors\"\n\t\"io\"\n\t\"math/big\"\n\t\"strings\"\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n)\n\nvar (\n\t// ErrNotFound is the error returned by storages if a resource cannot be found.\n\tErrNotFound = errors.New(\"not found\")\n\n\t// ErrAlreadyExists is the error returned by storages if a resource ID is taken during a create.\n\tErrAlreadyExists = errors.New(\"ID already exists\")\n)\n\n// Kubernetes only allows lower case letters for names.\n//\n// TODO(ericchiang): refactor ID creation onto the storage.\nvar encoding = base32.NewEncoding(\"abcdefghijklmnopqrstuvwxyz234567\")\n\n// Valid characters for user codes\nconst validUserCharacters = \"BCDFGHJKLMNPQRSTVWXZ\"\n\n// NewDeviceCode returns a 32 char alphanumeric cryptographically secure string\nfunc NewDeviceCode() string {\n\treturn newSecureID(32)\n}\n\n// NewID returns a random string which can be used as an ID for objects.\nfunc NewID() string {\n\treturn newSecureID(16)\n}\n\nfunc newSecureID(len int) string {\n\tbuff := make([]byte, len) // random ID.\n\tif _, err := io.ReadFull(rand.Reader, buff); err != nil {\n\t\tpanic(err)\n\t}\n\t// Avoid the identifier to begin with number and trim padding\n\treturn string(buff[0]%26+'a') + strings.TrimRight(encoding.EncodeToString(buff[1:]), \"=\")\n}\n\n// GCResult returns the number of objects deleted by garbage collection.\ntype GCResult struct {\n\tAuthRequests   int64\n\tAuthCodes      int64\n\tDeviceRequests int64\n\tDeviceTokens   int64\n}\n\n// IsEmpty returns whether the garbage collection result is empty or not.\nfunc (g *GCResult) IsEmpty() bool {\n\treturn g.AuthRequests == 0 &&\n\t\tg.AuthCodes == 0 &&\n\t\tg.DeviceRequests == 0 &&\n\t\tg.DeviceTokens == 0\n}\n\n// Storage is the storage interface used by the server. Implementations are\n// required to be able to perform atomic compare-and-swap updates and either\n// support timezones or standardize on UTC.\ntype Storage interface {\n\tClose() error\n\n\t// TODO(ericchiang): Let the storages set the IDs of these objects.\n\tCreateAuthRequest(a AuthRequest) error\n\tCreateClient(c Client) error\n\tCreateAuthCode(c AuthCode) error\n\tCreateRefresh(r RefreshToken) error\n\tCreatePassword(p Password) error\n\tCreateOfflineSessions(s OfflineSessions) error\n\tCreateConnector(c Connector) error\n\tCreateDeviceRequest(d DeviceRequest) error\n\tCreateDeviceToken(d DeviceToken) error\n\n\t// TODO(ericchiang): return (T, bool, error) so we can indicate not found\n\t// requests that way instead of using ErrNotFound.\n\tGetAuthRequest(id string) (AuthRequest, error)\n\tGetAuthCode(id string) (AuthCode, error)\n\tGetClient(id string) (Client, error)\n\tGetKeys() (Keys, error)\n\tGetRefresh(id string) (RefreshToken, error)\n\tGetPassword(email string) (Password, error)\n\tGetOfflineSessions(userID string, connID string) (OfflineSessions, error)\n\tGetConnector(id string) (Connector, error)\n\tGetDeviceRequest(userCode string) (DeviceRequest, error)\n\tGetDeviceToken(deviceCode string) (DeviceToken, error)\n\n\tListClients() ([]Client, error)\n\tListRefreshTokens() ([]RefreshToken, error)\n\tListPasswords() ([]Password, error)\n\tListConnectors() ([]Connector, error)\n\n\t// Delete methods MUST be atomic.\n\tDeleteAuthRequest(id string) error\n\tDeleteAuthCode(code string) error\n\tDeleteClient(id string) error\n\tDeleteRefresh(id string) error\n\tDeletePassword(email string) error\n\tDeleteOfflineSessions(userID string, connID string) error\n\tDeleteConnector(id string) error\n\n\t// Update methods take a function for updating an object then performs that update within\n\t// a transaction. \"updater\" functions may be called multiple times by a single update call.\n\t//\n\t// Because new fields may be added to resources, updaters should only modify existing\n\t// fields on the old object rather then creating new structs. For example:\n\t//\n\t//\t\tupdater := func(old storage.Client) (storage.Client, error) {\n\t//\t\t\told.Secret = newSecret\n\t//\t\t\treturn old, nil\n\t//\t\t}\n\t//\t\tif err := s.UpdateClient(clientID, updater); err != nil {\n\t//\t\t\t// update failed, handle error\n\t//\t\t}\n\t//\n\tUpdateClient(id string, updater func(old Client) (Client, error)) error\n\tUpdateKeys(updater func(old Keys) (Keys, error)) error\n\tUpdateAuthRequest(id string, updater func(a AuthRequest) (AuthRequest, error)) error\n\tUpdateRefreshToken(id string, updater func(r RefreshToken) (RefreshToken, error)) error\n\tUpdatePassword(email string, updater func(p Password) (Password, error)) error\n\tUpdateOfflineSessions(userID string, connID string, updater func(s OfflineSessions) (OfflineSessions, error)) error\n\tUpdateConnector(id string, updater func(c Connector) (Connector, error)) error\n\tUpdateDeviceToken(deviceCode string, updater func(t DeviceToken) (DeviceToken, error)) error\n\n\t// GarbageCollect deletes all expired AuthCodes,\n\t// AuthRequests, DeviceRequests, and DeviceTokens.\n\tGarbageCollect(now time.Time) (GCResult, error)\n}\n\n// Client represents an OAuth2 client.\n//\n// For further reading see:\n//   * Trusted peers: https://developers.google.com/identity/protocols/CrossClientAuth\n//   * Public clients: https://developers.google.com/api-client-library/python/auth/installed-app\ntype Client struct {\n\t// Client ID and secret used to identify the client.\n\tID        string `json:\"id\" yaml:\"id\"`\n\tIDEnv     string `json:\"idEnv\" yaml:\"idEnv\"`\n\tSecret    string `json:\"secret\" yaml:\"secret\"`\n\tSecretEnv string `json:\"secretEnv\" yaml:\"secretEnv\"`\n\n\t// A registered set of redirect URIs. When redirecting from dex to the client, the URI\n\t// requested to redirect to MUST match one of these values, unless the client is \"public\".\n\tRedirectURIs []string `json:\"redirectURIs\" yaml:\"redirectURIs\"`\n\n\t// TrustedPeers are a list of peers which can issue tokens on this client's behalf using\n\t// the dynamic \"oauth2:server:client_id:(client_id)\" scope. If a peer makes such a request,\n\t// this client's ID will appear as the ID Token's audience.\n\t//\n\t// Clients inherently trust themselves.\n\tTrustedPeers []string `json:\"trustedPeers\" yaml:\"trustedPeers\"`\n\n\t// Public clients must use either use a redirectURL 127.0.0.1:X or \"urn:ietf:wg:oauth:2.0:oob\"\n\tPublic bool `json:\"public\" yaml:\"public\"`\n\n\t// Name and LogoURL used when displaying this client to the end user.\n\tName    string `json:\"name\" yaml:\"name\"`\n\tLogoURL string `json:\"logoURL\" yaml:\"logoURL\"`\n}\n\n// Claims represents the ID Token claims supported by the server.\ntype Claims struct {\n\tUserID            string\n\tUsername          string\n\tPreferredUsername string\n\tEmail             string\n\tEmailVerified     bool\n\n\tGroups []string\n}\n\n// PKCE is a container for the data needed to perform Proof Key for Code Exchange (RFC 7636) auth flow\ntype PKCE struct {\n\tCodeChallenge       string\n\tCodeChallengeMethod string\n}\n\n// AuthRequest represents a OAuth2 client authorization request. It holds the state\n// of a single auth flow up to the point that the user authorizes the client.\ntype AuthRequest struct {\n\t// ID used to identify the authorization request.\n\tID string\n\n\t// ID of the client requesting authorization from a user.\n\tClientID string\n\n\t// Values parsed from the initial request. These describe the resources the client is\n\t// requesting as well as values describing the form of the response.\n\tResponseTypes []string\n\tScopes        []string\n\tRedirectURI   string\n\tNonce         string\n\tState         string\n\n\t// The client has indicated that the end user must be shown an approval prompt\n\t// on all requests. The server cannot cache their initial action for subsequent\n\t// attempts.\n\tForceApprovalPrompt bool\n\n\tExpiry time.Time\n\n\t// Has the user proved their identity through a backing identity provider?\n\t//\n\t// If false, the following fields are invalid.\n\tLoggedIn bool\n\n\t// The identity of the end user. Generally nil until the user authenticates\n\t// with a backend.\n\tClaims Claims\n\n\t// The connector used to login the user and any data the connector wishes to persists.\n\t// Set when the user authenticates.\n\tConnectorID   string\n\tConnectorData []byte\n\n\t// PKCE CodeChallenge and CodeChallengeMethod\n\tPKCE PKCE\n}\n\n// AuthCode represents a code which can be exchanged for an OAuth2 token response.\n//\n// This value is created once an end user has authorized a client, the server has\n// redirect the end user back to the client, but the client hasn't exchanged the\n// code for an access_token and id_token.\ntype AuthCode struct {\n\t// Actual string returned as the \"code\" value.\n\tID string\n\n\t// The client this code value is valid for. When exchanging the code for a\n\t// token response, the client must use its client_secret to authenticate.\n\tClientID string\n\n\t// As part of the OAuth2 spec when a client makes a token request it MUST\n\t// present the same redirect_uri as the initial redirect. This values is saved\n\t// to make this check.\n\t//\n\t// https://tools.ietf.org/html/rfc6749#section-4.1.3\n\tRedirectURI string\n\n\t// If provided by the client in the initial request, the provider MUST create\n\t// a ID Token with this nonce in the JWT payload.\n\tNonce string\n\n\t// Scopes authorized by the end user for the client.\n\tScopes []string\n\n\t// Authentication data provided by an upstream source.\n\tConnectorID   string\n\tConnectorData []byte\n\tClaims        Claims\n\n\tExpiry time.Time\n\n\t// PKCE CodeChallenge and CodeChallengeMethod\n\tPKCE PKCE\n}\n\n// RefreshToken is an OAuth2 refresh token which allows a client to request new\n// tokens on the end user's behalf.\ntype RefreshToken struct {\n\tID string\n\n\t// A single token that's rotated every time the refresh token is refreshed.\n\t//\n\t// May be empty.\n\tToken         string\n\tObsoleteToken string\n\n\tCreatedAt time.Time\n\tLastUsed  time.Time\n\n\t// Client this refresh token is valid for.\n\tClientID string\n\n\t// Authentication data provided by an upstream source.\n\tConnectorID   string\n\tConnectorData []byte\n\tClaims        Claims\n\n\t// Scopes present in the initial request. Refresh requests may specify a set\n\t// of scopes different from the initial request when refreshing a token,\n\t// however those scopes must be encompassed by this set.\n\tScopes []string\n\n\t// Nonce value supplied during the initial redirect. This is required to be part\n\t// of the claims of any future id_token generated by the client.\n\tNonce string\n}\n\n// RefreshTokenRef is a reference object that contains metadata about refresh tokens.\ntype RefreshTokenRef struct {\n\tID string\n\n\t// Client the refresh token is valid for.\n\tClientID string\n\n\tCreatedAt time.Time\n\tLastUsed  time.Time\n}\n\n// OfflineSessions objects are sessions pertaining to users with refresh tokens.\ntype OfflineSessions struct {\n\t// UserID of an end user who has logged in to the server.\n\tUserID string\n\n\t// The ID of the connector used to login the user.\n\tConnID string\n\n\t// Refresh is a hash table of refresh token reference objects\n\t// indexed by the ClientID of the refresh token.\n\tRefresh map[string]*RefreshTokenRef\n\n\t// Authentication data provided by an upstream source.\n\tConnectorData []byte\n}\n\n// Password is an email to password mapping managed by the storage.\ntype Password struct {\n\t// Email and identifying name of the password. Emails are assumed to be valid and\n\t// determining that an end-user controls the address is left to an outside application.\n\t//\n\t// Emails are case insensitive and should be standardized by the storage.\n\t//\n\t// Storages that don't support an extended character set for IDs, such as '.' and '@'\n\t// (cough cough, kubernetes), must map this value appropriately.\n\tEmail string `json:\"email\"`\n\n\t// Bcrypt encoded hash of the password. This package enforces a min cost value of 10\n\tHash []byte `json:\"hash\"`\n\n\t// Bcrypt encoded hash of the password set in environment variable of this name.\n\tHashFromEnv string `json:\"hashFromEnv\"`\n\n\t// Optional username to display. NOT used during login.\n\tUsername string `json:\"username\"`\n\n\t// Randomly generated user ID. This is NOT the primary ID of the Password object.\n\tUserID string `json:\"userID\"`\n}\n\n// Connector is an object that contains the metadata about connectors used to login to Dex.\ntype Connector struct {\n\t// ID that will uniquely identify the connector object.\n\tID string `json:\"id\"`\n\t// The Type of the connector. E.g. 'oidc' or 'ldap'\n\tType string `json:\"type\"`\n\t// The Name of the connector that is used when displaying it to the end user.\n\tName string `json:\"name\"`\n\t// ResourceVersion is the static versioning used to keep track of dynamic configuration\n\t// changes to the connector object made by the API calls.\n\tResourceVersion string `json:\"resourceVersion\"`\n\t// Config holds all the configuration information specific to the connector type. Since there\n\t// no generic struct we can use for this purpose, it is stored as a byte stream.\n\tConfig []byte `json:\"email\"`\n}\n\n// VerificationKey is a rotated signing key which can still be used to verify\n// signatures.\ntype VerificationKey struct {\n\tPublicKey *jose.JSONWebKey `json:\"publicKey\"`\n\tExpiry    time.Time        `json:\"expiry\"`\n}\n\n// Keys hold encryption and signing keys.\ntype Keys struct {\n\t// Key for creating and verifying signatures. These may be nil.\n\tSigningKey    *jose.JSONWebKey\n\tSigningKeyPub *jose.JSONWebKey\n\n\t// Old signing keys which have been rotated but can still be used to validate\n\t// existing signatures.\n\tVerificationKeys []VerificationKey\n\n\t// The next time the signing key will rotate.\n\t//\n\t// For caching purposes, implementations MUST NOT update keys before this time.\n\tNextRotation time.Time\n}\n\n// NewUserCode returns a randomized 8 character user code for the device flow.\n// No vowels are included to prevent accidental generation of words\nfunc NewUserCode() string {\n\tcode := randomString(8)\n\treturn code[:4] + \"-\" + code[4:]\n}\n\nfunc randomString(n int) string {\n\tv := big.NewInt(int64(len(validUserCharacters)))\n\tbytes := make([]byte, n)\n\tfor i := 0; i < n; i++ {\n\t\tc, _ := rand.Int(rand.Reader, v)\n\t\tbytes[i] = validUserCharacters[c.Int64()]\n\t}\n\treturn string(bytes)\n}\n\n// DeviceRequest represents an OIDC device authorization request. It holds the state of a device request until the user\n// authenticates using their user code or the expiry time passes.\ntype DeviceRequest struct {\n\t// The code the user will enter in a browser\n\tUserCode string\n\t// The unique device code for device authentication\n\tDeviceCode string\n\t// The client ID the code is for\n\tClientID string\n\t// The Client Secret\n\tClientSecret string\n\t// The scopes the device requests\n\tScopes []string\n\t// The expire time\n\tExpiry time.Time\n}\n\n// DeviceToken is a structure which represents the actual token of an authorized device and its rotation parameters\ntype DeviceToken struct {\n\tDeviceCode          string\n\tStatus              string\n\tToken               string\n\tExpiry              time.Time\n\tLastRequestTime     time.Time\n\tPollIntervalSeconds int\n\tPKCE                PKCE\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n\t\"github.com/gorilla/mux\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/connector\"\n\t\"github.com/dexidp/dex/server/internal\"\n\t\"github.com/dexidp/dex/storage\"\n)\n\nconst (\n\tcodeChallengeMethodPlain = \"plain\"\n\tcodeChallengeMethodS256  = \"S256\"\n)\n\nfunc (s *Server) handlePublicKeys(w http.ResponseWriter, r *http.Request) {\n\t// TODO(ericchiang): Cache this.\n\tkeys, err := s.storage.GetKeys()\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to get keys: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\treturn\n\t}\n\n\tif keys.SigningKeyPub == nil {\n\t\ts.logger.Errorf(\"No public keys found.\")\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\treturn\n\t}\n\n\tjwks := jose.JSONWebKeySet{\n\t\tKeys: make([]jose.JSONWebKey, len(keys.VerificationKeys)+1),\n\t}\n\tjwks.Keys[0] = *keys.SigningKeyPub\n\tfor i, verificationKey := range keys.VerificationKeys {\n\t\tjwks.Keys[i+1] = *verificationKey.PublicKey\n\t}\n\n\tdata, err := json.MarshalIndent(jwks, \"\", \"  \")\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to marshal discovery data: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\treturn\n\t}\n\tmaxAge := keys.NextRotation.Sub(s.now())\n\tif maxAge < (time.Minute * 2) {\n\t\tmaxAge = time.Minute * 2\n\t}\n\n\tw.Header().Set(\"Cache-Control\", fmt.Sprintf(\"max-age=%d, must-revalidate\", int(maxAge.Seconds())))\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\tw.Write(data)\n}\n\ntype discovery struct {\n\tIssuer            string   `json:\"issuer\"`\n\tAuth              string   `json:\"authorization_endpoint\"`\n\tToken             string   `json:\"token_endpoint\"`\n\tKeys              string   `json:\"jwks_uri\"`\n\tUserInfo          string   `json:\"userinfo_endpoint\"`\n\tDeviceEndpoint    string   `json:\"device_authorization_endpoint\"`\n\tGrantTypes        []string `json:\"grant_types_supported\"`\n\tResponseTypes     []string `json:\"response_types_supported\"`\n\tSubjects          []string `json:\"subject_types_supported\"`\n\tIDTokenAlgs       []string `json:\"id_token_signing_alg_values_supported\"`\n\tCodeChallengeAlgs []string `json:\"code_challenge_methods_supported\"`\n\tScopes            []string `json:\"scopes_supported\"`\n\tAuthMethods       []string `json:\"token_endpoint_auth_methods_supported\"`\n\tClaims            []string `json:\"claims_supported\"`\n}\n\nfunc (s *Server) discoveryHandler() (http.HandlerFunc, error) {\n\td := discovery{\n\t\tIssuer:            s.issuerURL.String(),\n\t\tAuth:              s.absURL(\"/auth\"),\n\t\tToken:             s.absURL(\"/token\"),\n\t\tKeys:              s.absURL(\"/keys\"),\n\t\tUserInfo:          s.absURL(\"/userinfo\"),\n\t\tDeviceEndpoint:    s.absURL(\"/device/code\"),\n\t\tSubjects:          []string{\"public\"},\n\t\tIDTokenAlgs:       []string{string(jose.RS256)},\n\t\tCodeChallengeAlgs: []string{codeChallengeMethodS256, codeChallengeMethodPlain},\n\t\tScopes:            []string{\"openid\", \"email\", \"groups\", \"profile\", \"offline_access\"},\n\t\tAuthMethods:       []string{\"client_secret_basic\", \"client_secret_post\"},\n\t\tClaims: []string{\n\t\t\t\"iss\", \"sub\", \"aud\", \"iat\", \"exp\", \"email\", \"email_verified\",\n\t\t\t\"locale\", \"name\", \"preferred_username\", \"at_hash\",\n\t\t},\n\t}\n\n\tfor responseType := range s.supportedResponseTypes {\n\t\td.ResponseTypes = append(d.ResponseTypes, responseType)\n\t}\n\tsort.Strings(d.ResponseTypes)\n\n\td.GrantTypes = s.supportedGrantTypes\n\n\tdata, err := json.MarshalIndent(d, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal discovery data: %v\", err)\n\t}\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\t\tw.Write(data)\n\t}), nil\n}\n\n// handleAuthorization handles the OAuth2 auth endpoint.\nfunc (s *Server) handleAuthorization(w http.ResponseWriter, r *http.Request) {\n\t// Extract the arguments\n\tif err := r.ParseForm(); err != nil {\n\t\ts.logger.Errorf(\"Failed to parse arguments: %v\", err)\n\n\t\ts.renderError(r, w, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\n\tconnectorID := r.Form.Get(\"connector_id\")\n\n\tconnectors, err := s.storage.ListConnectors()\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get list of connectors: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Failed to retrieve connector list.\")\n\t\treturn\n\t}\n\n\t// We don't need connector_id any more\n\tr.Form.Del(\"connector_id\")\n\n\t// Construct a URL with all of the arguments in its query\n\tconnURL := url.URL{\n\t\tRawQuery: r.Form.Encode(),\n\t}\n\n\t// Redirect if a client chooses a specific connector_id\n\tif connectorID != \"\" {\n\t\tfor _, c := range connectors {\n\t\t\tif c.ID == connectorID {\n\t\t\t\tconnURL.Path = s.absPath(\"/auth\", url.PathEscape(c.ID))\n\t\t\t\thttp.Redirect(w, r, connURL.String(), http.StatusFound)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Connector ID does not match a valid Connector\")\n\t\treturn\n\t}\n\n\tif len(connectors) == 1 && !s.alwaysShowLogin {\n\t\tconnURL.Path = s.absPath(\"/auth\", url.PathEscape(connectors[0].ID))\n\t\thttp.Redirect(w, r, connURL.String(), http.StatusFound)\n\t}\n\n\tconnectorInfos := make([]connectorInfo, len(connectors))\n\tfor index, conn := range connectors {\n\t\tconnURL.Path = s.absPath(\"/auth\", url.PathEscape(conn.ID))\n\t\tconnectorInfos[index] = connectorInfo{\n\t\t\tID:   conn.ID,\n\t\t\tName: conn.Name,\n\t\t\tType: conn.Type,\n\t\t\tURL:  template.URL(connURL.String()),\n\t\t}\n\t}\n\n\tif err := s.templates.login(r, w, connectorInfos); err != nil {\n\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t}\n}\n\nfunc (s *Server) handleConnectorLogin(w http.ResponseWriter, r *http.Request) {\n\tauthReq, err := s.parseAuthorizationRequest(r)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to parse authorization request: %v\", err)\n\n\t\tswitch authErr := err.(type) {\n\t\tcase *redirectedAuthErr:\n\t\t\tauthErr.Handler().ServeHTTP(w, r)\n\t\tcase *displayedAuthErr:\n\t\t\ts.renderError(r, w, authErr.Status, err.Error())\n\t\tdefault:\n\t\t\tpanic(\"unsupported error type\")\n\t\t}\n\n\t\treturn\n\t}\n\n\tconnID, err := url.PathUnescape(mux.Vars(r)[\"connector\"])\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to parse connector: %v\", err)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist\")\n\t\treturn\n\t}\n\n\tconn, err := s.getConnector(connID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector: %v\", err)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist\")\n\t\treturn\n\t}\n\n\t// Set the connector being used for the login.\n\tif authReq.ConnectorID != \"\" && authReq.ConnectorID != connID {\n\t\ts.logger.Errorf(\"Mismatched connector ID in auth request: %s vs %s\",\n\t\t\tauthReq.ConnectorID, connID)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Bad connector ID\")\n\t\treturn\n\t}\n\n\tauthReq.ConnectorID = connID\n\n\t// Actually create the auth request\n\tauthReq.Expiry = s.now().Add(s.authRequestsValidFor)\n\tif err := s.storage.CreateAuthRequest(*authReq); err != nil {\n\t\ts.logger.Errorf(\"Failed to create authorization request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Failed to connect to the database.\")\n\t\treturn\n\t}\n\n\tscopes := parseScopes(authReq.Scopes)\n\n\t// Work out where the \"Select another login method\" link should go.\n\tbackLink := \"\"\n\tif len(s.connectors) > 1 {\n\t\tbackLinkURL := url.URL{\n\t\t\tPath:     s.absPath(\"/auth\"),\n\t\t\tRawQuery: r.Form.Encode(),\n\t\t}\n\t\tbackLink = backLinkURL.String()\n\t}\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tswitch conn := conn.Connector.(type) {\n\t\tcase connector.CallbackConnector:\n\t\t\t// Use the auth request ID as the \"state\" token.\n\t\t\t//\n\t\t\t// TODO(ericchiang): Is this appropriate or should we also be using a nonce?\n\t\t\tcallbackURL, err := conn.LoginURL(scopes, s.absURL(\"/callback\"), authReq.ID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"Connector %q returned error when creating callback: %v\", connID, err)\n\t\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login error.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Redirect(w, r, callbackURL, http.StatusFound)\n\t\tcase connector.PasswordConnector:\n\t\t\tloginURL := url.URL{\n\t\t\t\tPath: s.absPath(\"/auth\", connID, \"login\"),\n\t\t\t}\n\t\t\tq := loginURL.Query()\n\t\t\tq.Set(\"state\", authReq.ID)\n\t\t\tq.Set(\"back\", backLink)\n\t\t\tloginURL.RawQuery = q.Encode()\n\n\t\t\thttp.Redirect(w, r, loginURL.String(), http.StatusFound)\n\t\tcase connector.SAMLConnector:\n\t\t\taction, value, err := conn.POSTData(scopes, authReq.ID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"Creating SAML data: %v\", err)\n\t\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Connector Login Error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// TODO(ericchiang): Don't inline this.\n\t\t\tfmt.Fprintf(w, `<!DOCTYPE html>\n\t\t\t  <html lang=\"en\">\n\t\t\t  <head>\n\t\t\t    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n\t\t\t    <title>SAML login</title>\n\t\t\t  </head>\n\t\t\t  <body>\n\t\t\t    <form method=\"post\" action=\"%s\" >\n\t\t\t\t    <input type=\"hidden\" name=\"SAMLRequest\" value=\"%s\" />\n\t\t\t\t    <input type=\"hidden\" name=\"RelayState\" value=\"%s\" />\n\t\t\t    </form>\n\t\t\t\t<script>\n\t\t\t\t    document.forms[0].submit();\n\t\t\t\t</script>\n\t\t\t  </body>\n\t\t\t  </html>`, action, value, authReq.ID)\n\t\tdefault:\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist.\")\n\t\t}\n\tdefault:\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Unsupported request method.\")\n\t}\n}\n\nfunc (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {\n\tauthID := r.URL.Query().Get(\"state\")\n\tif authID == \"\" {\n\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\treturn\n\t}\n\n\tbackLink := r.URL.Query().Get(\"back\")\n\n\tauthReq, err := s.storage.GetAuthRequest(authID)\n\tif err != nil {\n\t\tif err == storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Invalid 'state' parameter provided: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist.\")\n\t\t\treturn\n\t\t}\n\t\ts.logger.Errorf(\"Failed to get auth request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Database error.\")\n\t\treturn\n\t}\n\n\tconnID, err := url.PathUnescape(mux.Vars(r)[\"connector\"])\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to parse connector: %v\", err)\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist\")\n\t\treturn\n\t} else if connID != \"\" && connID != authReq.ConnectorID {\n\t\ts.logger.Errorf(\"Connector mismatch: authentication started with id %q, but password login for id %q was triggered\", authReq.ConnectorID, connID)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tconn, err := s.getConnector(authReq.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector with id %q : %v\", authReq.ConnectorID, err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tpwConn, ok := conn.Connector.(connector.PasswordConnector)\n\tif !ok {\n\t\ts.logger.Errorf(\"Expected password connector in handlePasswordLogin(), but got %v\", pwConn)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif err := s.templates.password(r, w, r.URL.String(), \"\", usernamePrompt(pwConn), false, backLink); err != nil {\n\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t}\n\tcase http.MethodPost:\n\t\tusername := r.FormValue(\"login\")\n\t\tpassword := r.FormValue(\"password\")\n\t\tscopes := parseScopes(authReq.Scopes)\n\n\t\tidentity, ok, err := pwConn.Login(r.Context(), scopes, username, password)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to login user: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, fmt.Sprintf(\"Login error: %v\", err))\n\t\t\treturn\n\t\t}\n\t\tif !ok {\n\t\t\tif err := s.templates.password(r, w, r.URL.String(), username, usernamePrompt(pwConn), true, backLink); err != nil {\n\t\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tredirectURL, err := s.finalizeLogin(identity, authReq, conn.Connector)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to finalize login: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login error.\")\n\t\t\treturn\n\t\t}\n\n\t\thttp.Redirect(w, r, redirectURL, http.StatusSeeOther)\n\tdefault:\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Unsupported request method.\")\n\t}\n}\n\nfunc (s *Server) handleConnectorCallback(w http.ResponseWriter, r *http.Request) {\n\tvar authID string\n\tswitch r.Method {\n\tcase http.MethodGet: // OAuth2 callback\n\t\tif authID = r.URL.Query().Get(\"state\"); authID == \"\" {\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\t\treturn\n\t\t}\n\tcase http.MethodPost: // SAML POST binding\n\t\tif authID = r.PostFormValue(\"RelayState\"); authID == \"\" {\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\ts.renderError(r, w, http.StatusBadRequest, \"Method not supported\")\n\t\treturn\n\t}\n\n\tauthReq, err := s.storage.GetAuthRequest(authID)\n\tif err != nil {\n\t\tif err == storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Invalid 'state' parameter provided: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Requested resource does not exist.\")\n\t\t\treturn\n\t\t}\n\t\ts.logger.Errorf(\"Failed to get auth request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Database error.\")\n\t\treturn\n\t}\n\n\tconnID, err := url.PathUnescape(mux.Vars(r)[\"connector\"])\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector with id %q : %v\", authReq.ConnectorID, err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t} else if connID != \"\" && connID != authReq.ConnectorID {\n\t\ts.logger.Errorf(\"Connector mismatch: authentication started with id %q, but callback for id %q was triggered\", authReq.ConnectorID, connID)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tconn, err := s.getConnector(authReq.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get connector with id %q : %v\", authReq.ConnectorID, err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tvar identity connector.Identity\n\tswitch conn := conn.Connector.(type) {\n\tcase connector.CallbackConnector:\n\t\tif r.Method != http.MethodGet {\n\t\t\ts.logger.Errorf(\"SAML request mapped to OAuth2 connector\")\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Invalid request\")\n\t\t\treturn\n\t\t}\n\t\tidentity, err = conn.HandleCallback(parseScopes(authReq.Scopes), r)\n\tcase connector.SAMLConnector:\n\t\tif r.Method != http.MethodPost {\n\t\t\ts.logger.Errorf(\"OAuth2 request mapped to SAML connector\")\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"Invalid request\")\n\t\t\treturn\n\t\t}\n\t\tidentity, err = conn.HandlePOST(parseScopes(authReq.Scopes), r.PostFormValue(\"SAMLResponse\"), authReq.ID)\n\tdefault:\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Requested resource does not exist.\")\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to authenticate: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, fmt.Sprintf(\"Failed to authenticate: %v\", err))\n\t\treturn\n\t}\n\n\tredirectURL, err := s.finalizeLogin(identity, authReq, conn.Connector)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to finalize login: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login error.\")\n\t\treturn\n\t}\n\n\thttp.Redirect(w, r, redirectURL, http.StatusSeeOther)\n}\n\n// finalizeLogin associates the user's identity with the current AuthRequest, then returns\n// the approval page's path.\nfunc (s *Server) finalizeLogin(identity connector.Identity, authReq storage.AuthRequest, conn connector.Connector) (string, error) {\n\tclaims := storage.Claims{\n\t\tUserID:            identity.UserID,\n\t\tUsername:          identity.Username,\n\t\tPreferredUsername: identity.PreferredUsername,\n\t\tEmail:             identity.Email,\n\t\tEmailVerified:     identity.EmailVerified,\n\t\tGroups:            identity.Groups,\n\t}\n\n\tupdater := func(a storage.AuthRequest) (storage.AuthRequest, error) {\n\t\ta.LoggedIn = true\n\t\ta.Claims = claims\n\t\ta.ConnectorData = identity.ConnectorData\n\t\treturn a, nil\n\t}\n\tif err := s.storage.UpdateAuthRequest(authReq.ID, updater); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to update auth request: %v\", err)\n\t}\n\n\temail := claims.Email\n\tif !claims.EmailVerified {\n\t\temail += \" (unverified)\"\n\t}\n\n\ts.logger.Infof(\"login successful: connector %q, username=%q, preferred_username=%q, email=%q, groups=%q\",\n\t\tauthReq.ConnectorID, claims.Username, claims.PreferredUsername, email, claims.Groups)\n\n\t// TODO: if s.skipApproval or !authReq.ForceApprovalPrompt, we can skip the redirect to /approval and go ahead and send code\n\n\t// an HMAC is used here to ensure that the request ID is unpredictable, ensuring that an attacker who intercepted the original\n\t// flow would be unable to poll for the result at the /approval endpoint\n\th := hmac.New(sha256.New, authReq.HMACKey)\n\th.Write([]byte(authReq.ID))\n\tmac := h.Sum(nil)\n\n\treturnURL := path.Join(s.issuerURL.Path, \"/approval\") + \"?req=\" + authReq.ID + \"&hmac=\" + base64.RawURLEncoding.EncodeToString(mac)\n\t_, ok := conn.(connector.RefreshConnector)\n\tif !ok {\n\t\treturn returnURL, nil\n\t}\n\n\t// Try to retrieve an existing OfflineSession object for the corresponding user.\n\tsession, err := s.storage.GetOfflineSessions(identity.UserID, authReq.ConnectorID)\n\tif err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"failed to get offline session: %v\", err)\n\t\t\treturn \"\", err\n\t\t}\n\t\tofflineSessions := storage.OfflineSessions{\n\t\t\tUserID:        identity.UserID,\n\t\t\tConnID:        authReq.ConnectorID,\n\t\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\t\tConnectorData: identity.ConnectorData,\n\t\t}\n\n\t\t// Create a new OfflineSession object for the user and add a reference object for\n\t\t// the newly received refreshtoken.\n\t\tif err := s.storage.CreateOfflineSessions(offlineSessions); err != nil {\n\t\t\ts.logger.Errorf(\"failed to create offline session: %v\", err)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn returnURL, nil\n\t}\n\n\t// Update existing OfflineSession obj with new RefreshTokenRef.\n\tif err := s.storage.UpdateOfflineSessions(session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\tif len(identity.ConnectorData) > 0 {\n\t\t\told.ConnectorData = identity.ConnectorData\n\t\t}\n\t\treturn old, nil\n\t}); err != nil {\n\t\ts.logger.Errorf(\"failed to update offline session: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn returnURL, nil\n}\n\nfunc (s *Server) handleApproval(w http.ResponseWriter, r *http.Request) {\n\tmacEncoded := r.FormValue(\"hmac\")\n\tif macEncoded == \"\" {\n\t\ts.renderError(r, w, http.StatusUnauthorized, \"Unauthorized request\")\n\t\treturn\n\t}\n\tmac, err := base64.RawURLEncoding.DecodeString(macEncoded)\n\tif err != nil {\n\t\ts.renderError(r, w, http.StatusUnauthorized, \"Unauthorized request\")\n\t\treturn\n\t}\n\n\tauthReq, err := s.storage.GetAuthRequest(r.FormValue(\"req\"))\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get auth request: %v\", err)\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Database error.\")\n\t\treturn\n\t}\n\tif !authReq.LoggedIn {\n\t\ts.logger.Errorf(\"Auth request does not have an identity for approval\")\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Login process not yet finalized.\")\n\t\treturn\n\t}\n\n\t// build expected hmac with secret key\n\th := hmac.New(sha256.New, authReq.HMACKey)\n\th.Write([]byte(authReq.ID))\n\texpectedMAC := h.Sum(nil)\n\t// constant time comparison\n\tif !hmac.Equal(mac, expectedMAC) {\n\t\ts.renderError(r, w, http.StatusUnauthorized, \"Unauthorized request\")\n\t\treturn\n\t}\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif s.skipApproval {\n\t\t\ts.sendCodeResponse(w, r, authReq)\n\t\t\treturn\n\t\t}\n\t\tclient, err := s.storage.GetClient(authReq.ClientID)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to get client %q: %v\", authReq.ClientID, err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Failed to retrieve client.\")\n\t\t\treturn\n\t\t}\n\t\tif err := s.templates.approval(r, w, authReq.ID, authReq.Claims.Username, client.Name, authReq.Scopes); err != nil {\n\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t}\n\tcase http.MethodPost:\n\t\tif r.FormValue(\"approval\") != \"approve\" {\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Approval rejected.\")\n\t\t\treturn\n\t\t}\n\t\ts.sendCodeResponse(w, r, authReq)\n\t}\n}\n\nfunc (s *Server) sendCodeResponse(w http.ResponseWriter, r *http.Request, authReq storage.AuthRequest) {\n\tif s.now().After(authReq.Expiry) {\n\t\ts.renderError(r, w, http.StatusBadRequest, \"User session has expired.\")\n\t\treturn\n\t}\n\n\tif err := s.storage.DeleteAuthRequest(authReq.ID); err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Failed to delete authorization request: %v\", err)\n\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\t} else {\n\t\t\ts.renderError(r, w, http.StatusBadRequest, \"User session error.\")\n\t\t}\n\t\treturn\n\t}\n\tu, err := url.Parse(authReq.RedirectURI)\n\tif err != nil {\n\t\ts.renderError(r, w, http.StatusInternalServerError, \"Invalid redirect URI.\")\n\t\treturn\n\t}\n\n\tvar (\n\t\t// Was the initial request using the implicit or hybrid flow instead of\n\t\t// the \"normal\" code flow?\n\t\timplicitOrHybrid = false\n\n\t\t// Only present in hybrid or code flow. code.ID == \"\" if this is not set.\n\t\tcode storage.AuthCode\n\n\t\t// ID token returned immediately if the response_type includes \"id_token\".\n\t\t// Only valid for implicit and hybrid flows.\n\t\tidToken       string\n\t\tidTokenExpiry time.Time\n\n\t\t// Access token\n\t\taccessToken string\n\t)\n\n\tfor _, responseType := range authReq.ResponseTypes {\n\t\tswitch responseType {\n\t\tcase responseTypeCode:\n\t\t\tcode = storage.AuthCode{\n\t\t\t\tID:            storage.NewID(),\n\t\t\t\tClientID:      authReq.ClientID,\n\t\t\t\tConnectorID:   authReq.ConnectorID,\n\t\t\t\tNonce:         authReq.Nonce,\n\t\t\t\tScopes:        authReq.Scopes,\n\t\t\t\tClaims:        authReq.Claims,\n\t\t\t\tExpiry:        s.now().Add(time.Minute * 30),\n\t\t\t\tRedirectURI:   authReq.RedirectURI,\n\t\t\t\tConnectorData: authReq.ConnectorData,\n\t\t\t\tPKCE:          authReq.PKCE,\n\t\t\t}\n\t\t\tif err := s.storage.CreateAuthCode(code); err != nil {\n\t\t\t\ts.logger.Errorf(\"Failed to create auth code: %v\", err)\n\t\t\t\ts.renderError(r, w, http.StatusInternalServerError, \"Internal server error.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Implicit and hybrid flows that try to use the OOB redirect URI are\n\t\t\t// rejected earlier. If we got here we're using the code flow.\n\t\t\tif authReq.RedirectURI == redirectURIOOB {\n\t\t\t\tif err := s.templates.oob(r, w, code.ID); err != nil {\n\t\t\t\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\tcase responseTypeToken:\n\t\t\timplicitOrHybrid = true\n\t\tcase responseTypeIDToken:\n\t\t\timplicitOrHybrid = true\n\t\t\tvar err error\n\n\t\t\taccessToken, err = s.newAccessToken(authReq.ClientID, authReq.Claims, authReq.Scopes, authReq.Nonce, authReq.ConnectorID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create new access token: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tidToken, idTokenExpiry, err = s.newIDToken(authReq.ClientID, authReq.Claims, authReq.Scopes, authReq.Nonce, accessToken, code.ID, authReq.ConnectorID)\n\t\t\tif err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create ID token: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif implicitOrHybrid {\n\t\tv := url.Values{}\n\t\tv.Set(\"access_token\", accessToken)\n\t\tv.Set(\"token_type\", \"bearer\")\n\t\tv.Set(\"state\", authReq.State)\n\t\tif idToken != \"\" {\n\t\t\tv.Set(\"id_token\", idToken)\n\t\t\t// The hybrid flow with only \"code token\" or \"code id_token\" doesn't return an\n\t\t\t// \"expires_in\" value. If \"code\" wasn't provided, indicating the implicit flow,\n\t\t\t// don't add it.\n\t\t\t//\n\t\t\t// https://openid.net/specs/openid-connect-core-1_0.html#HybridAuthResponse\n\t\t\tif code.ID == \"\" {\n\t\t\t\tv.Set(\"expires_in\", strconv.Itoa(int(idTokenExpiry.Sub(s.now()).Seconds())))\n\t\t\t}\n\t\t}\n\t\tif code.ID != \"\" {\n\t\t\tv.Set(\"code\", code.ID)\n\t\t}\n\n\t\t// Implicit and hybrid flows return their values as part of the fragment.\n\t\t//\n\t\t//   HTTP/1.1 303 See Other\n\t\t//   Location: https://client.example.org/cb#\n\t\t//     access_token=SlAV32hkKG\n\t\t//     &token_type=bearer\n\t\t//     &id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso\n\t\t//     &expires_in=3600\n\t\t//     &state=af0ifjsldkj\n\t\t//\n\t\tu.Fragment = v.Encode()\n\t} else {\n\t\t// The code flow add values to the URL query.\n\t\t//\n\t\t//   HTTP/1.1 303 See Other\n\t\t//   Location: https://client.example.org/cb?\n\t\t//     code=SplxlOBeZQQYbYS6WxSbIA\n\t\t//     &state=af0ifjsldkj\n\t\t//\n\t\tq := u.Query()\n\t\tq.Set(\"code\", code.ID)\n\t\tq.Set(\"state\", authReq.State)\n\t\tu.RawQuery = q.Encode()\n\t}\n\n\thttp.Redirect(w, r, u.String(), http.StatusSeeOther)\n}\n\nfunc (s *Server) withClientFromStorage(w http.ResponseWriter, r *http.Request, handler func(http.ResponseWriter, *http.Request, storage.Client)) {\n\tclientID, clientSecret, ok := r.BasicAuth()\n\tif ok {\n\t\tvar err error\n\t\tif clientID, err = url.QueryUnescape(clientID); err != nil {\n\t\t\ts.tokenErrHelper(w, errInvalidRequest, \"client_id improperly encoded\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif clientSecret, err = url.QueryUnescape(clientSecret); err != nil {\n\t\t\ts.tokenErrHelper(w, errInvalidRequest, \"client_secret improperly encoded\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tclientID = r.PostFormValue(\"client_id\")\n\t\tclientSecret = r.PostFormValue(\"client_secret\")\n\t}\n\n\tclient, err := s.storage.GetClient(clientID)\n\tif err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"failed to get client: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t} else {\n\t\t\ts.tokenErrHelper(w, errInvalidClient, \"Invalid client credentials.\", http.StatusUnauthorized)\n\t\t}\n\t\treturn\n\t}\n\n\tif subtle.ConstantTimeCompare([]byte(client.Secret), []byte(clientSecret)) != 1 {\n\t\tif clientSecret == \"\" {\n\t\t\ts.logger.Infof(\"missing client_secret on token request for client: %s\", client.ID)\n\t\t} else {\n\t\t\ts.logger.Infof(\"invalid client_secret on token request for client: %s\", client.ID)\n\t\t}\n\t\ts.tokenErrHelper(w, errInvalidClient, \"Invalid client credentials.\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\thandler(w, r, client)\n}\n\nfunc (s *Server) handleToken(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif r.Method != http.MethodPost {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"method not allowed\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr := r.ParseForm()\n\tif err != nil {\n\t\ts.logger.Errorf(\"Could not parse request body: %v\", err)\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tgrantType := r.PostFormValue(\"grant_type\")\n\tswitch grantType {\n\tcase grantTypeDeviceCode:\n\t\ts.handleDeviceToken(w, r)\n\tcase grantTypeAuthorizationCode:\n\t\ts.withClientFromStorage(w, r, s.handleAuthCode)\n\tcase grantTypeRefreshToken:\n\t\ts.withClientFromStorage(w, r, s.handleRefreshToken)\n\tcase grantTypePassword:\n\t\ts.withClientFromStorage(w, r, s.handlePasswordGrant)\n\tdefault:\n\t\ts.tokenErrHelper(w, errUnsupportedGrantType, \"\", http.StatusBadRequest)\n\t}\n}\n\nfunc (s *Server) calculateCodeChallenge(codeVerifier, codeChallengeMethod string) (string, error) {\n\tswitch codeChallengeMethod {\n\tcase codeChallengeMethodPlain:\n\t\treturn codeVerifier, nil\n\tcase codeChallengeMethodS256:\n\t\tshaSum := sha256.Sum256([]byte(codeVerifier))\n\t\treturn base64.RawURLEncoding.EncodeToString(shaSum[:]), nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown challenge method (%v)\", codeChallengeMethod)\n\t}\n}\n\n// handle an access token request https://tools.ietf.org/html/rfc6749#section-4.1.3\nfunc (s *Server) handleAuthCode(w http.ResponseWriter, r *http.Request, client storage.Client) {\n\tcode := r.PostFormValue(\"code\")\n\tredirectURI := r.PostFormValue(\"redirect_uri\")\n\n\tif code == \"\" {\n\t\ts.tokenErrHelper(w, errInvalidRequest, `Required param: code.`, http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tauthCode, err := s.storage.GetAuthCode(code)\n\tif err != nil || s.now().After(authCode.Expiry) || authCode.ClientID != client.ID {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"failed to get auth code: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t} else {\n\t\t\ts.tokenErrHelper(w, errInvalidGrant, \"Invalid or expired code parameter.\", http.StatusBadRequest)\n\t\t}\n\t\treturn\n\t}\n\n\t// RFC 7636 (PKCE)\n\tcodeChallengeFromStorage := authCode.PKCE.CodeChallenge\n\tprovidedCodeVerifier := r.PostFormValue(\"code_verifier\")\n\n\tswitch {\n\tcase providedCodeVerifier != \"\" && codeChallengeFromStorage != \"\":\n\t\tcalculatedCodeChallenge, err := s.calculateCodeChallenge(providedCodeVerifier, authCode.PKCE.CodeChallengeMethod)\n\t\tif err != nil {\n\t\t\ts.logger.Error(err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif codeChallengeFromStorage != calculatedCodeChallenge {\n\t\t\ts.tokenErrHelper(w, errInvalidGrant, \"Invalid code_verifier.\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\tcase providedCodeVerifier != \"\":\n\t\t// Received no code_challenge on /auth, but a code_verifier on /token\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"No PKCE flow started. Cannot check code_verifier.\", http.StatusBadRequest)\n\t\treturn\n\tcase codeChallengeFromStorage != \"\":\n\t\t// Received PKCE request on /auth, but no code_verifier on /token\n\t\ts.tokenErrHelper(w, errInvalidGrant, \"Expecting parameter code_verifier in PKCE flow.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif authCode.RedirectURI != redirectURI {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"redirect_uri did not match URI from initial request.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttokenResponse, err := s.exchangeAuthCode(w, authCode, client)\n\tif err != nil {\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\ts.writeAccessToken(w, tokenResponse)\n}\n\nfunc (s *Server) exchangeAuthCode(w http.ResponseWriter, authCode storage.AuthCode, client storage.Client) (*accessTokenResponse, error) {\n\taccessToken, err := s.newAccessToken(client.ID, authCode.Claims, authCode.Scopes, authCode.Nonce, authCode.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to create new access token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\tidToken, expiry, err := s.newIDToken(client.ID, authCode.Claims, authCode.Scopes, authCode.Nonce, accessToken, authCode.ID, authCode.ConnectorID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to create ID token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\tif err := s.storage.DeleteAuthCode(authCode.ID); err != nil {\n\t\ts.logger.Errorf(\"failed to delete auth code: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\treqRefresh := func() bool {\n\t\t// Ensure the connector supports refresh tokens.\n\t\t//\n\t\t// Connectors like `saml` do not implement RefreshConnector.\n\t\tconn, err := s.getConnector(authCode.ConnectorID)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"connector with ID %q not found: %v\", authCode.ConnectorID, err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn false\n\t\t}\n\n\t\t_, ok := conn.Connector.(connector.RefreshConnector)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tfor _, scope := range authCode.Scopes {\n\t\t\tif scope == scopeOfflineAccess {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}()\n\tvar refreshToken string\n\tif reqRefresh {\n\t\trefresh := storage.RefreshToken{\n\t\t\tID:            storage.NewID(),\n\t\t\tToken:         storage.NewID(),\n\t\t\tClientID:      authCode.ClientID,\n\t\t\tConnectorID:   authCode.ConnectorID,\n\t\t\tScopes:        authCode.Scopes,\n\t\t\tClaims:        authCode.Claims,\n\t\t\tNonce:         authCode.Nonce,\n\t\t\tConnectorData: authCode.ConnectorData,\n\t\t\tCreatedAt:     s.now(),\n\t\t\tLastUsed:      s.now(),\n\t\t}\n\t\ttoken := &internal.RefreshToken{\n\t\t\tRefreshId: refresh.ID,\n\t\t\tToken:     refresh.Token,\n\t\t}\n\t\tif refreshToken, err = internal.Marshal(token); err != nil {\n\t\t\ts.logger.Errorf(\"failed to marshal refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := s.storage.CreateRefresh(refresh); err != nil {\n\t\t\ts.logger.Errorf(\"failed to create refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// deleteToken determines if we need to delete the newly created refresh token\n\t\t// due to a failure in updating/creating the OfflineSession object for the\n\t\t// corresponding user.\n\t\tvar deleteToken bool\n\t\tdefer func() {\n\t\t\tif deleteToken {\n\t\t\t\t// Delete newly created refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(refresh.ID); err != nil {\n\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttokenRef := storage.RefreshTokenRef{\n\t\t\tID:        refresh.ID,\n\t\t\tClientID:  refresh.ClientID,\n\t\t\tCreatedAt: refresh.CreatedAt,\n\t\t\tLastUsed:  refresh.LastUsed,\n\t\t}\n\n\t\t// Try to retrieve an existing OfflineSession object for the corresponding user.\n\t\tif session, err := s.storage.GetOfflineSessions(refresh.Claims.UserID, refresh.ConnectorID); err != nil {\n\t\t\tif err != storage.ErrNotFound {\n\t\t\t\ts.logger.Errorf(\"failed to get offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tofflineSessions := storage.OfflineSessions{\n\t\t\t\tUserID:  refresh.Claims.UserID,\n\t\t\t\tConnID:  refresh.ConnectorID,\n\t\t\t\tRefresh: make(map[string]*storage.RefreshTokenRef),\n\t\t\t}\n\t\t\tofflineSessions.Refresh[tokenRef.ClientID] = &tokenRef\n\n\t\t\t// Create a new OfflineSession object for the user and add a reference object for\n\t\t\t// the newly received refreshtoken.\n\t\t\tif err := s.storage.CreateOfflineSessions(offlineSessions); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tif oldTokenRef, ok := session.Refresh[tokenRef.ClientID]; ok {\n\t\t\t\t// Delete old refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(oldTokenRef.ID); err != nil && err != storage.ErrNotFound {\n\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\tdeleteToken = true\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update existing OfflineSession obj with new RefreshTokenRef.\n\t\t\tif err := s.storage.UpdateOfflineSessions(session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\t\t\told.Refresh[tokenRef.ClientID] = &tokenRef\n\t\t\t\treturn old, nil\n\t\t\t}); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to update offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn s.toAccessTokenResponse(idToken, accessToken, refreshToken, expiry), nil\n}\n\nfunc (s *Server) handleUserInfo(w http.ResponseWriter, r *http.Request) {\n\tconst prefix = \"Bearer \"\n\n\tauth := r.Header.Get(\"authorization\")\n\tif len(auth) < len(prefix) || !strings.EqualFold(prefix, auth[:len(prefix)]) {\n\t\tw.Header().Set(\"WWW-Authenticate\", \"Bearer\")\n\t\ts.tokenErrHelper(w, errAccessDenied, \"Invalid bearer token.\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\trawIDToken := auth[len(prefix):]\n\n\tverifier := oidc.NewVerifier(s.issuerURL.String(), &storageKeySet{s.storage}, &oidc.Config{SkipClientIDCheck: true})\n\tidToken, err := verifier.Verify(r.Context(), rawIDToken)\n\tif err != nil {\n\t\ts.tokenErrHelper(w, errAccessDenied, err.Error(), http.StatusForbidden)\n\t\treturn\n\t}\n\n\tvar claims json.RawMessage\n\tif err := idToken.Claims(&claims); err != nil {\n\t\ts.tokenErrHelper(w, errServerError, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(claims)\n}\n\nfunc (s *Server) handlePasswordGrant(w http.ResponseWriter, r *http.Request, client storage.Client) {\n\t// Parse the fields\n\tif err := r.ParseForm(); err != nil {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Couldn't parse data\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tq := r.Form\n\n\tnonce := q.Get(\"nonce\")\n\t// Some clients, like the old go-oidc, provide extra whitespace. Tolerate this.\n\tscopes := strings.Fields(q.Get(\"scope\"))\n\n\t// Parse the scopes if they are passed\n\tvar (\n\t\tunrecognized  []string\n\t\tinvalidScopes []string\n\t)\n\thasOpenIDScope := false\n\tfor _, scope := range scopes {\n\t\tswitch scope {\n\t\tcase scopeOpenID:\n\t\t\thasOpenIDScope = true\n\t\tcase scopeOfflineAccess, scopeEmail, scopeProfile, scopeGroups, scopeFederatedID:\n\t\tdefault:\n\t\t\tpeerID, ok := parseCrossClientScope(scope)\n\t\t\tif !ok {\n\t\t\t\tunrecognized = append(unrecognized, scope)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tisTrusted, err := s.validateCrossClientTrust(client.ID, peerID)\n\t\t\tif err != nil {\n\t\t\t\ts.tokenErrHelper(w, errInvalidClient, fmt.Sprintf(\"Error validating cross client trust %v.\", err), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !isTrusted {\n\t\t\t\tinvalidScopes = append(invalidScopes, scope)\n\t\t\t}\n\t\t}\n\t}\n\tif !hasOpenIDScope {\n\t\ts.tokenErrHelper(w, errInvalidRequest, `Missing required scope(s) [\"openid\"].`, http.StatusBadRequest)\n\t\treturn\n\t}\n\tif len(unrecognized) > 0 {\n\t\ts.tokenErrHelper(w, errInvalidRequest, fmt.Sprintf(\"Unrecognized scope(s) %q\", unrecognized), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif len(invalidScopes) > 0 {\n\t\ts.tokenErrHelper(w, errInvalidRequest, fmt.Sprintf(\"Client can't request scope(s) %q\", invalidScopes), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Which connector\n\tconnID := s.passwordConnector\n\tconn, err := s.getConnector(connID)\n\tif err != nil {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Requested connector does not exist.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tpasswordConnector, ok := conn.Connector.(connector.PasswordConnector)\n\tif !ok {\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Requested password connector does not correct type.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Login\n\tusername := q.Get(\"username\")\n\tpassword := q.Get(\"password\")\n\tidentity, ok, err := passwordConnector.Login(r.Context(), parseScopes(scopes), username, password)\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to login user: %v\", err)\n\t\ts.tokenErrHelper(w, errInvalidRequest, \"Could not login user\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif !ok {\n\t\ts.tokenErrHelper(w, errAccessDenied, \"Invalid username or password\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Build the claims to send the id token\n\tclaims := storage.Claims{\n\t\tUserID:            identity.UserID,\n\t\tUsername:          identity.Username,\n\t\tPreferredUsername: identity.PreferredUsername,\n\t\tEmail:             identity.Email,\n\t\tEmailVerified:     identity.EmailVerified,\n\t\tGroups:            identity.Groups,\n\t}\n\n\taccessToken, err := s.newAccessToken(client.ID, claims, scopes, nonce, connID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"password grant failed to create new access token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tidToken, expiry, err := s.newIDToken(client.ID, claims, scopes, nonce, accessToken, \"\", connID)\n\tif err != nil {\n\t\ts.logger.Errorf(\"password grant failed to create new ID token: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\treqRefresh := func() bool {\n\t\t// Ensure the connector supports refresh tokens.\n\t\t//\n\t\t// Connectors like `saml` do not implement RefreshConnector.\n\t\t_, ok := conn.Connector.(connector.RefreshConnector)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tfor _, scope := range scopes {\n\t\t\tif scope == scopeOfflineAccess {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}()\n\tvar refreshToken string\n\tif reqRefresh {\n\t\trefresh := storage.RefreshToken{\n\t\t\tID:          storage.NewID(),\n\t\t\tToken:       storage.NewID(),\n\t\t\tClientID:    client.ID,\n\t\t\tConnectorID: connID,\n\t\t\tScopes:      scopes,\n\t\t\tClaims:      claims,\n\t\t\tNonce:       nonce,\n\t\t\t// ConnectorData: authCode.ConnectorData,\n\t\t\tCreatedAt: s.now(),\n\t\t\tLastUsed:  s.now(),\n\t\t}\n\t\ttoken := &internal.RefreshToken{\n\t\t\tRefreshId: refresh.ID,\n\t\t\tToken:     refresh.Token,\n\t\t}\n\t\tif refreshToken, err = internal.Marshal(token); err != nil {\n\t\t\ts.logger.Errorf(\"failed to marshal refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.storage.CreateRefresh(refresh); err != nil {\n\t\t\ts.logger.Errorf(\"failed to create refresh token: %v\", err)\n\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// deleteToken determines if we need to delete the newly created refresh token\n\t\t// due to a failure in updating/creating the OfflineSession object for the\n\t\t// corresponding user.\n\t\tvar deleteToken bool\n\t\tdefer func() {\n\t\t\tif deleteToken {\n\t\t\t\t// Delete newly created refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(refresh.ID); err != nil {\n\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttokenRef := storage.RefreshTokenRef{\n\t\t\tID:        refresh.ID,\n\t\t\tClientID:  refresh.ClientID,\n\t\t\tCreatedAt: refresh.CreatedAt,\n\t\t\tLastUsed:  refresh.LastUsed,\n\t\t}\n\n\t\t// Try to retrieve an existing OfflineSession object for the corresponding user.\n\t\tif session, err := s.storage.GetOfflineSessions(refresh.Claims.UserID, refresh.ConnectorID); err != nil {\n\t\t\tif err != storage.ErrNotFound {\n\t\t\t\ts.logger.Errorf(\"failed to get offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn\n\t\t\t}\n\t\t\tofflineSessions := storage.OfflineSessions{\n\t\t\t\tUserID:        refresh.Claims.UserID,\n\t\t\t\tConnID:        refresh.ConnectorID,\n\t\t\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\t\t\tConnectorData: identity.ConnectorData,\n\t\t\t}\n\t\t\tofflineSessions.Refresh[tokenRef.ClientID] = &tokenRef\n\n\t\t\t// Create a new OfflineSession object for the user and add a reference object for\n\t\t\t// the newly received refreshtoken.\n\t\t\tif err := s.storage.CreateOfflineSessions(offlineSessions); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to create offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif oldTokenRef, ok := session.Refresh[tokenRef.ClientID]; ok {\n\t\t\t\t// Delete old refresh token from storage.\n\t\t\t\tif err := s.storage.DeleteRefresh(oldTokenRef.ID); err != nil {\n\t\t\t\t\tif err == storage.ErrNotFound {\n\t\t\t\t\t\ts.logger.Warnf(\"database inconsistent, refresh token missing: %v\", oldTokenRef.ID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts.logger.Errorf(\"failed to delete refresh token: %v\", err)\n\t\t\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\t\t\tdeleteToken = true\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update existing OfflineSession obj with new RefreshTokenRef.\n\t\t\tif err := s.storage.UpdateOfflineSessions(session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\t\t\told.Refresh[tokenRef.ClientID] = &tokenRef\n\t\t\t\told.ConnectorData = identity.ConnectorData\n\t\t\t\treturn old, nil\n\t\t\t}); err != nil {\n\t\t\t\ts.logger.Errorf(\"failed to update offline session: %v\", err)\n\t\t\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\t\t\tdeleteToken = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tresp := s.toAccessTokenResponse(idToken, accessToken, refreshToken, expiry)\n\ts.writeAccessToken(w, resp)\n}\n\ntype accessTokenResponse struct {\n\tAccessToken  string `json:\"access_token\"`\n\tTokenType    string `json:\"token_type\"`\n\tExpiresIn    int    `json:\"expires_in\"`\n\tRefreshToken string `json:\"refresh_token,omitempty\"`\n\tIDToken      string `json:\"id_token\"`\n}\n\nfunc (s *Server) toAccessTokenResponse(idToken, accessToken, refreshToken string, expiry time.Time) *accessTokenResponse {\n\treturn &accessTokenResponse{\n\t\taccessToken,\n\t\t\"bearer\",\n\t\tint(expiry.Sub(s.now()).Seconds()),\n\t\trefreshToken,\n\t\tidToken,\n\t}\n}\n\nfunc (s *Server) writeAccessToken(w http.ResponseWriter, resp *accessTokenResponse) {\n\tdata, err := json.Marshal(resp)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to marshal access token response: %v\", err)\n\t\ts.tokenErrHelper(w, errServerError, \"\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\n\t// Token response must include cache headers https://tools.ietf.org/html/rfc6749#section-5.1\n\tw.Header().Set(\"Cache-Control\", \"no-store\")\n\tw.Header().Set(\"Pragma\", \"no-cache\")\n\tw.Write(data)\n}\n\nfunc (s *Server) renderError(r *http.Request, w http.ResponseWriter, status int, description string) {\n\tif err := s.templates.err(r, w, status, description); err != nil {\n\t\ts.logger.Errorf(\"Server template error: %v\", err)\n\t}\n}\n\nfunc (s *Server) tokenErrHelper(w http.ResponseWriter, typ string, description string, statusCode int) {\n\tif err := tokenErr(w, typ, description, statusCode); err != nil {\n\t\ts.logger.Errorf(\"token error response: %v\", err)\n\t}\n}\n\n// Check for username prompt override from connector. Defaults to \"Username\".\nfunc usernamePrompt(conn connector.PasswordConnector) string {\n\tif attr := conn.Prompt(); attr != \"\" {\n\t\treturn attr\n\t}\n\treturn \"Username\"\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/connector\"\n\t\"github.com/dexidp/dex/server/internal\"\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// TODO(ericchiang): clean this file up and figure out more idiomatic error handling.\n\n// See: https://tools.ietf.org/html/rfc6749#section-4.1.2.1\n\n// displayedAuthErr is an error that should be displayed to the user as a web page\ntype displayedAuthErr struct {\n\tStatus      int\n\tDescription string\n}\n\nfunc (err *displayedAuthErr) Error() string {\n\treturn err.Description\n}\n\nfunc newDisplayedErr(status int, format string, a ...interface{}) *displayedAuthErr {\n\treturn &displayedAuthErr{status, fmt.Sprintf(format, a...)}\n}\n\n// redirectedAuthErr is an error that should be reported back to the client by 302 redirect\ntype redirectedAuthErr struct {\n\tState       string\n\tRedirectURI string\n\tType        string\n\tDescription string\n}\n\nfunc (err *redirectedAuthErr) Error() string {\n\treturn err.Description\n}\n\nfunc (err *redirectedAuthErr) Handler() http.Handler {\n\thf := func(w http.ResponseWriter, r *http.Request) {\n\t\tv := url.Values{}\n\t\tv.Add(\"state\", err.State)\n\t\tv.Add(\"error\", err.Type)\n\t\tif err.Description != \"\" {\n\t\t\tv.Add(\"error_description\", err.Description)\n\t\t}\n\t\tvar redirectURI string\n\t\tif strings.Contains(err.RedirectURI, \"?\") {\n\t\t\tredirectURI = err.RedirectURI + \"&\" + v.Encode()\n\t\t} else {\n\t\t\tredirectURI = err.RedirectURI + \"?\" + v.Encode()\n\t\t}\n\t\thttp.Redirect(w, r, redirectURI, http.StatusSeeOther)\n\t}\n\treturn http.HandlerFunc(hf)\n}\n\nfunc tokenErr(w http.ResponseWriter, typ, description string, statusCode int) error {\n\tdata := struct {\n\t\tError       string `json:\"error\"`\n\t\tDescription string `json:\"error_description,omitempty\"`\n\t}{typ, description}\n\tbody, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal token error response: %v\", err)\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(body)))\n\tw.WriteHeader(statusCode)\n\tw.Write(body)\n\treturn nil\n}\n\n// nolint\nconst (\n\terrInvalidRequest          = \"invalid_request\"\n\terrUnauthorizedClient      = \"unauthorized_client\"\n\terrAccessDenied            = \"access_denied\"\n\terrUnsupportedResponseType = \"unsupported_response_type\"\n\terrRequestNotSupported     = \"request_not_supported\"\n\terrInvalidScope            = \"invalid_scope\"\n\terrServerError             = \"server_error\"\n\terrTemporarilyUnavailable  = \"temporarily_unavailable\"\n\terrUnsupportedGrantType    = \"unsupported_grant_type\"\n\terrInvalidGrant            = \"invalid_grant\"\n\terrInvalidClient           = \"invalid_client\"\n)\n\nconst (\n\tscopeOfflineAccess     = \"offline_access\" // Request a refresh token.\n\tscopeOpenID            = \"openid\"\n\tscopeGroups            = \"groups\"\n\tscopeEmail             = \"email\"\n\tscopeProfile           = \"profile\"\n\tscopeFederatedID       = \"federated:id\"\n\tscopeCrossClientPrefix = \"audience:server:client_id:\"\n)\n\nconst (\n\tdeviceCallbackURI = \"/device/callback\"\n)\n\nconst (\n\tredirectURIOOB = \"urn:ietf:wg:oauth:2.0:oob\"\n)\n\nconst (\n\tgrantTypeAuthorizationCode = \"authorization_code\"\n\tgrantTypeRefreshToken      = \"refresh_token\"\n\tgrantTypeImplicit          = \"implicit\"\n\tgrantTypePassword          = \"password\"\n\tgrantTypeDeviceCode        = \"urn:ietf:params:oauth:grant-type:device_code\"\n)\n\nconst (\n\tresponseTypeCode    = \"code\"     // \"Regular\" flow\n\tresponseTypeToken   = \"token\"    // Implicit flow for frontend apps.\n\tresponseTypeIDToken = \"id_token\" // ID Token in url fragment\n)\n\nconst (\n\tdeviceTokenPending  = \"authorization_pending\"\n\tdeviceTokenComplete = \"complete\"\n\tdeviceTokenSlowDown = \"slow_down\"\n\tdeviceTokenExpired  = \"expired_token\"\n)\n\nfunc parseScopes(scopes []string) connector.Scopes {\n\tvar s connector.Scopes\n\tfor _, scope := range scopes {\n\t\tswitch scope {\n\t\tcase scopeOfflineAccess:\n\t\t\ts.OfflineAccess = true\n\t\tcase scopeGroups:\n\t\t\ts.Groups = true\n\t\t}\n\t}\n\treturn s\n}\n\n// Determine the signature algorithm for a JWT.\nfunc signatureAlgorithm(jwk *jose.JSONWebKey) (alg jose.SignatureAlgorithm, err error) {\n\tif jwk.Key == nil {\n\t\treturn alg, errors.New(\"no signing key\")\n\t}\n\tswitch key := jwk.Key.(type) {\n\tcase *rsa.PrivateKey:\n\t\t// Because OIDC mandates that we support RS256, we always return that\n\t\t// value. In the future, we might want to make this configurable on a\n\t\t// per client basis. For example allowing PS256 or ECDSA variants.\n\t\t//\n\t\t// See https://github.com/dexidp/dex/issues/692\n\t\treturn jose.RS256, nil\n\tcase *ecdsa.PrivateKey:\n\t\t// We don't actually support ECDSA keys yet, but they're tested for\n\t\t// in case we want to in the future.\n\t\t//\n\t\t// These values are prescribed depending on the ECDSA key type. We\n\t\t// can't return different values.\n\t\tswitch key.Params() {\n\t\tcase elliptic.P256().Params():\n\t\t\treturn jose.ES256, nil\n\t\tcase elliptic.P384().Params():\n\t\t\treturn jose.ES384, nil\n\t\tcase elliptic.P521().Params():\n\t\t\treturn jose.ES512, nil\n\t\tdefault:\n\t\t\treturn alg, errors.New(\"unsupported ecdsa curve\")\n\t\t}\n\tdefault:\n\t\treturn alg, fmt.Errorf(\"unsupported signing key type %T\", key)\n\t}\n}\n\nfunc signPayload(key *jose.JSONWebKey, alg jose.SignatureAlgorithm, payload []byte) (jws string, err error) {\n\tsigningKey := jose.SigningKey{Key: key, Algorithm: alg}\n\n\tsigner, err := jose.NewSigner(signingKey, &jose.SignerOptions{})\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"new signer: %v\", err)\n\t}\n\tsignature, err := signer.Sign(payload)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"signing payload: %v\", err)\n\t}\n\treturn signature.CompactSerialize()\n}\n\n// The hash algorithm for the at_hash is determined by the signing\n// algorithm used for the id_token. From the spec:\n//\n//    ...the hash algorithm used is the hash algorithm used in the alg Header\n//    Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256,\n//    hash the access_token value with SHA-256\n//\n// https://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDToken\nvar hashForSigAlg = map[jose.SignatureAlgorithm]func() hash.Hash{\n\tjose.RS256: sha256.New,\n\tjose.RS384: sha512.New384,\n\tjose.RS512: sha512.New,\n\tjose.ES256: sha256.New,\n\tjose.ES384: sha512.New384,\n\tjose.ES512: sha512.New,\n}\n\n// Compute an at_hash from a raw access token and a signature algorithm\n//\n// See: https://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDToken\nfunc accessTokenHash(alg jose.SignatureAlgorithm, accessToken string) (string, error) {\n\tnewHash, ok := hashForSigAlg[alg]\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"unsupported signature algorithm: %s\", alg)\n\t}\n\n\thashFunc := newHash()\n\tif _, err := io.WriteString(hashFunc, accessToken); err != nil {\n\t\treturn \"\", fmt.Errorf(\"computing hash: %v\", err)\n\t}\n\tsum := hashFunc.Sum(nil)\n\treturn base64.RawURLEncoding.EncodeToString(sum[:len(sum)/2]), nil\n}\n\ntype audience []string\n\nfunc (a audience) contains(aud string) bool {\n\tfor _, e := range a {\n\t\tif aud == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (a audience) MarshalJSON() ([]byte, error) {\n\tif len(a) == 1 {\n\t\treturn json.Marshal(a[0])\n\t}\n\treturn json.Marshal([]string(a))\n}\n\ntype idTokenClaims struct {\n\tIssuer           string   `json:\"iss\"`\n\tSubject          string   `json:\"sub\"`\n\tAudience         audience `json:\"aud\"`\n\tExpiry           int64    `json:\"exp\"`\n\tIssuedAt         int64    `json:\"iat\"`\n\tAuthorizingParty string   `json:\"azp,omitempty\"`\n\tNonce            string   `json:\"nonce,omitempty\"`\n\n\tAccessTokenHash string `json:\"at_hash,omitempty\"`\n\tCodeHash        string `json:\"c_hash,omitempty\"`\n\n\tEmail         string `json:\"email,omitempty\"`\n\tEmailVerified *bool  `json:\"email_verified,omitempty\"`\n\n\tGroups []string `json:\"groups,omitempty\"`\n\n\tName              string `json:\"name,omitempty\"`\n\tPreferredUsername string `json:\"preferred_username,omitempty\"`\n\n\tFederatedIDClaims *federatedIDClaims `json:\"federated_claims,omitempty\"`\n}\n\ntype federatedIDClaims struct {\n\tConnectorID string `json:\"connector_id,omitempty\"`\n\tUserID      string `json:\"user_id,omitempty\"`\n}\n\nfunc (s *Server) newAccessToken(clientID string, claims storage.Claims, scopes []string, nonce, connID string) (accessToken string, err error) {\n\tidToken, _, err := s.newIDToken(clientID, claims, scopes, nonce, storage.NewID(), \"\", connID)\n\treturn idToken, err\n}\n\nfunc (s *Server) newIDToken(clientID string, claims storage.Claims, scopes []string, nonce, accessToken, code, connID string) (idToken string, expiry time.Time, err error) {\n\tkeys, err := s.storage.GetKeys()\n\tif err != nil {\n\t\ts.logger.Errorf(\"Failed to get keys: %v\", err)\n\t\treturn \"\", expiry, err\n\t}\n\n\tsigningKey := keys.SigningKey\n\tif signingKey == nil {\n\t\treturn \"\", expiry, fmt.Errorf(\"no key to sign payload with\")\n\t}\n\tsigningAlg, err := signatureAlgorithm(signingKey)\n\tif err != nil {\n\t\treturn \"\", expiry, err\n\t}\n\n\tissuedAt := s.now()\n\texpiry = issuedAt.Add(s.idTokensValidFor)\n\n\tsub := &internal.IDTokenSubject{\n\t\tUserId: claims.UserID,\n\t\tConnId: connID,\n\t}\n\n\tsubjectString, err := internal.Marshal(sub)\n\tif err != nil {\n\t\ts.logger.Errorf(\"failed to marshal offline session ID: %v\", err)\n\t\treturn \"\", expiry, fmt.Errorf(\"failed to marshal offline session ID: %v\", err)\n\t}\n\n\ttok := idTokenClaims{\n\t\tIssuer:   s.issuerURL.String(),\n\t\tSubject:  subjectString,\n\t\tNonce:    nonce,\n\t\tExpiry:   expiry.Unix(),\n\t\tIssuedAt: issuedAt.Unix(),\n\t}\n\n\tif accessToken != \"\" {\n\t\tatHash, err := accessTokenHash(signingAlg, accessToken)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"error computing at_hash: %v\", err)\n\t\t\treturn \"\", expiry, fmt.Errorf(\"error computing at_hash: %v\", err)\n\t\t}\n\t\ttok.AccessTokenHash = atHash\n\t}\n\n\tif code != \"\" {\n\t\tcHash, err := accessTokenHash(signingAlg, code)\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"error computing c_hash: %v\", err)\n\t\t\treturn \"\", expiry, fmt.Errorf(\"error computing c_hash: #{err}\")\n\t\t}\n\t\ttok.CodeHash = cHash\n\t}\n\n\tfor _, scope := range scopes {\n\t\tswitch {\n\t\tcase scope == scopeEmail:\n\t\t\ttok.Email = claims.Email\n\t\t\ttok.EmailVerified = &claims.EmailVerified\n\t\tcase scope == scopeGroups:\n\t\t\ttok.Groups = claims.Groups\n\t\tcase scope == scopeProfile:\n\t\t\ttok.Name = claims.Username\n\t\t\ttok.PreferredUsername = claims.PreferredUsername\n\t\tcase scope == scopeFederatedID:\n\t\t\ttok.FederatedIDClaims = &federatedIDClaims{\n\t\t\t\tConnectorID: connID,\n\t\t\t\tUserID:      claims.UserID,\n\t\t\t}\n\t\tdefault:\n\t\t\tpeerID, ok := parseCrossClientScope(scope)\n\t\t\tif !ok {\n\t\t\t\t// Ignore unknown scopes. These are already validated during the\n\t\t\t\t// initial auth request.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tisTrusted, err := s.validateCrossClientTrust(clientID, peerID)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", expiry, err\n\t\t\t}\n\t\t\tif !isTrusted {\n\t\t\t\t// TODO(ericchiang): propagate this error to the client.\n\t\t\t\treturn \"\", expiry, fmt.Errorf(\"peer (%s) does not trust client\", peerID)\n\t\t\t}\n\t\t\ttok.Audience = append(tok.Audience, peerID)\n\t\t}\n\t}\n\n\tif len(tok.Audience) == 0 {\n\t\t// Client didn't ask for cross client audience. Set the current\n\t\t// client as the audience.\n\t\ttok.Audience = audience{clientID}\n\t} else {\n\t\t// Client asked for cross client audience:\n\t\t// if the current client was not requested explicitly\n\t\tif !tok.Audience.contains(clientID) {\n\t\t\t// by default it becomes one of entries in Audience\n\t\t\ttok.Audience = append(tok.Audience, clientID)\n\t\t}\n\t\t// The current client becomes the authorizing party.\n\t\ttok.AuthorizingParty = clientID\n\t}\n\n\tpayload, err := json.Marshal(tok)\n\tif err != nil {\n\t\treturn \"\", expiry, fmt.Errorf(\"could not serialize claims: %v\", err)\n\t}\n\n\tif idToken, err = signPayload(signingKey, signingAlg, payload); err != nil {\n\t\treturn \"\", expiry, fmt.Errorf(\"failed to sign payload: %v\", err)\n\t}\n\treturn idToken, expiry, nil\n}\n\n// parse the initial request from the OAuth2 client.\nfunc (s *Server) parseAuthorizationRequest(r *http.Request) (*storage.AuthRequest, error) {\n\tif err := r.ParseForm(); err != nil {\n\t\treturn nil, newDisplayedErr(http.StatusBadRequest, \"Failed to parse request.\")\n\t}\n\tq := r.Form\n\tredirectURI, err := url.QueryUnescape(q.Get(\"redirect_uri\"))\n\tif err != nil {\n\t\treturn nil, newDisplayedErr(http.StatusBadRequest, \"No redirect_uri provided.\")\n\t}\n\n\tclientID := q.Get(\"client_id\")\n\tstate := q.Get(\"state\")\n\tnonce := q.Get(\"nonce\")\n\tconnectorID := q.Get(\"connector_id\")\n\t// Some clients, like the old go-oidc, provide extra whitespace. Tolerate this.\n\tscopes := strings.Fields(q.Get(\"scope\"))\n\tresponseTypes := strings.Fields(q.Get(\"response_type\"))\n\n\tcodeChallenge := q.Get(\"code_challenge\")\n\tcodeChallengeMethod := q.Get(\"code_challenge_method\")\n\n\tif codeChallengeMethod == \"\" {\n\t\tcodeChallengeMethod = codeChallengeMethodPlain\n\t}\n\n\tclient, err := s.storage.GetClient(clientID)\n\tif err != nil {\n\t\tif err == storage.ErrNotFound {\n\t\t\treturn nil, newDisplayedErr(http.StatusNotFound, \"Invalid client_id (%q).\", clientID)\n\t\t}\n\t\ts.logger.Errorf(\"Failed to get client: %v\", err)\n\t\treturn nil, newDisplayedErr(http.StatusInternalServerError, \"Database error.\")\n\t}\n\n\tif !validateRedirectURI(client, redirectURI) {\n\t\treturn nil, newDisplayedErr(http.StatusBadRequest, \"Unregistered redirect_uri (%q).\", redirectURI)\n\t}\n\tif redirectURI == deviceCallbackURI && client.Public {\n\t\tredirectURI = s.issuerURL.Path + deviceCallbackURI\n\t}\n\n\t// From here on out, we want to redirect back to the client with an error.\n\tnewRedirectedErr := func(typ, format string, a ...interface{}) *redirectedAuthErr {\n\t\treturn &redirectedAuthErr{state, redirectURI, typ, fmt.Sprintf(format, a...)}\n\t}\n\n\tif connectorID != \"\" {\n\t\tconnectors, err := s.storage.ListConnectors()\n\t\tif err != nil {\n\t\t\ts.logger.Errorf(\"Failed to list connectors: %v\", err)\n\t\t\treturn nil, newRedirectedErr(errServerError, \"Unable to retrieve connectors\")\n\t\t}\n\t\tif !validateConnectorID(connectors, connectorID) {\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Invalid ConnectorID\")\n\t\t}\n\t}\n\n\t// dex doesn't support request parameter and must return request_not_supported error\n\t// https://openid.net/specs/openid-connect-core-1_0.html#6.1\n\tif q.Get(\"request\") != \"\" {\n\t\treturn nil, newRedirectedErr(errRequestNotSupported, \"Server does not support request parameter.\")\n\t}\n\n\tif codeChallengeMethod != codeChallengeMethodS256 && codeChallengeMethod != codeChallengeMethodPlain {\n\t\tdescription := fmt.Sprintf(\"Unsupported PKCE challenge method (%q).\", codeChallengeMethod)\n\t\treturn nil, newRedirectedErr(errInvalidRequest, description)\n\t}\n\n\tvar (\n\t\tunrecognized  []string\n\t\tinvalidScopes []string\n\t)\n\thasOpenIDScope := false\n\tfor _, scope := range scopes {\n\t\tswitch scope {\n\t\tcase scopeOpenID:\n\t\t\thasOpenIDScope = true\n\t\tcase scopeOfflineAccess, scopeEmail, scopeProfile, scopeGroups, scopeFederatedID:\n\t\tdefault:\n\t\t\tpeerID, ok := parseCrossClientScope(scope)\n\t\t\tif !ok {\n\t\t\t\tunrecognized = append(unrecognized, scope)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tisTrusted, err := s.validateCrossClientTrust(clientID, peerID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, newRedirectedErr(errServerError, \"Internal server error.\")\n\t\t\t}\n\t\t\tif !isTrusted {\n\t\t\t\tinvalidScopes = append(invalidScopes, scope)\n\t\t\t}\n\t\t}\n\t}\n\tif !hasOpenIDScope {\n\t\treturn nil, newRedirectedErr(errInvalidScope, `Missing required scope(s) [\"openid\"].`)\n\t}\n\tif len(unrecognized) > 0 {\n\t\treturn nil, newRedirectedErr(errInvalidScope, \"Unrecognized scope(s) %q\", unrecognized)\n\t}\n\tif len(invalidScopes) > 0 {\n\t\treturn nil, newRedirectedErr(errInvalidScope, \"Client can't request scope(s) %q\", invalidScopes)\n\t}\n\n\tvar rt struct {\n\t\tcode    bool\n\t\tidToken bool\n\t\ttoken   bool\n\t}\n\n\tfor _, responseType := range responseTypes {\n\t\tswitch responseType {\n\t\tcase responseTypeCode:\n\t\t\trt.code = true\n\t\tcase responseTypeIDToken:\n\t\t\trt.idToken = true\n\t\tcase responseTypeToken:\n\t\t\trt.token = true\n\t\tdefault:\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Invalid response type %q\", responseType)\n\t\t}\n\n\t\tif !s.supportedResponseTypes[responseType] {\n\t\t\treturn nil, newRedirectedErr(errUnsupportedResponseType, \"Unsupported response type %q\", responseType)\n\t\t}\n\t}\n\n\tif len(responseTypes) == 0 {\n\t\treturn nil, newRedirectedErr(errInvalidRequest, \"No response_type provided\")\n\t}\n\n\tif rt.token && !rt.code && !rt.idToken {\n\t\t// \"token\" can't be provided by its own.\n\t\t//\n\t\t// https://openid.net/specs/openid-connect-core-1_0.html#Authentication\n\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Response type 'token' must be provided with type 'id_token' and/or 'code'\")\n\t}\n\tif !rt.code {\n\t\t// Either \"id_token token\" or \"id_token\" has been provided which implies the\n\t\t// implicit flow. Implicit flow requires a nonce value.\n\t\t//\n\t\t// https://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest\n\t\tif nonce == \"\" {\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, \"Response type 'token' requires a 'nonce' value.\")\n\t\t}\n\t}\n\tif rt.token {\n\t\tif redirectURI == redirectURIOOB {\n\t\t\terr := fmt.Sprintf(\"Cannot use response type 'token' with redirect_uri '%s'.\", redirectURIOOB)\n\t\t\treturn nil, newRedirectedErr(errInvalidRequest, err)\n\t\t}\n\t}\n\n\treturn &storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            client.ID,\n\t\tState:               state,\n\t\tNonce:               nonce,\n\t\tForceApprovalPrompt: q.Get(\"approval_prompt\") == \"force\",\n\t\tScopes:              scopes,\n\t\tRedirectURI:         redirectURI,\n\t\tResponseTypes:       responseTypes,\n\t\tConnectorID:         connectorID,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       codeChallenge,\n\t\t\tCodeChallengeMethod: codeChallengeMethod,\n\t\t},\n\t\tHMACKey: storage.NewHMACKey(crypto.SHA256),\n\t}, nil\n}\n\nfunc parseCrossClientScope(scope string) (peerID string, ok bool) {\n\tif ok = strings.HasPrefix(scope, scopeCrossClientPrefix); ok {\n\t\tpeerID = scope[len(scopeCrossClientPrefix):]\n\t}\n\treturn\n}\n\nfunc (s *Server) validateCrossClientTrust(clientID, peerID string) (trusted bool, err error) {\n\tif peerID == clientID {\n\t\treturn true, nil\n\t}\n\tpeer, err := s.storage.GetClient(peerID)\n\tif err != nil {\n\t\tif err != storage.ErrNotFound {\n\t\t\ts.logger.Errorf(\"Failed to get client: %v\", err)\n\t\t\treturn false, err\n\t\t}\n\t\treturn false, nil\n\t}\n\tfor _, id := range peer.TrustedPeers {\n\t\tif id == clientID {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc validateRedirectURI(client storage.Client, redirectURI string) bool {\n\t// Allow named RedirectURIs for both public and non-public clients.\n\t// This is required make PKCE-enabled web apps work, when configured as public clients.\n\tfor _, uri := range client.RedirectURIs {\n\t\tif redirectURI == uri {\n\t\t\treturn true\n\t\t}\n\t}\n\t// For non-public clients or when RedirectURIs is set, we allow only explicitly named RedirectURIs.\n\t// Otherwise, we check below for special URIs used for desktop or mobile apps.\n\tif !client.Public || len(client.RedirectURIs) > 0 {\n\t\treturn false\n\t}\n\n\tif redirectURI == redirectURIOOB || redirectURI == deviceCallbackURI {\n\t\treturn true\n\t}\n\n\t// verify that the host is of form \"http://localhost:(port)(path)\" or \"http://localhost(path)\"\n\tu, err := url.Parse(redirectURI)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif u.Scheme != \"http\" {\n\t\treturn false\n\t}\n\tif u.Host == \"localhost\" {\n\t\treturn true\n\t}\n\thost, _, err := net.SplitHostPort(u.Host)\n\treturn err == nil && host == \"localhost\"\n}\n\nfunc validateConnectorID(connectors []storage.Connector, connectorID string) bool {\n\tfor _, c := range connectors {\n\t\tif c.ID == connectorID {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// storageKeySet implements the oidc.KeySet interface backed by Dex storage\ntype storageKeySet struct {\n\tstorage.Storage\n}\n\nfunc (s *storageKeySet) VerifySignature(_ context.Context, jwt string) (payload []byte, err error) {\n\tjws, err := jose.ParseSigned(jwt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeyID := \"\"\n\tfor _, sig := range jws.Signatures {\n\t\tkeyID = sig.Header.KeyID\n\t\tbreak\n\t}\n\n\tskeys, err := s.Storage.GetKeys()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeys := []*jose.JSONWebKey{skeys.SigningKeyPub}\n\tfor _, vk := range skeys.VerificationKeys {\n\t\tkeys = append(keys, vk.PublicKey)\n\t}\n\n\tfor _, key := range keys {\n\t\tif keyID == \"\" || key.KeyID == keyID {\n\t\t\tif payload, err := jws.Verify(key); err == nil {\n\t\t\t\treturn payload, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"failed to verify id token signature\")\n}\n", "// Package conformance provides conformance tests for storage implementations.\npackage conformance\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/kylelemons/godebug/pretty\"\n\t\"golang.org/x/crypto/bcrypt\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// ensure that values being tested on never expire.\nvar neverExpire = time.Now().UTC().Add(time.Hour * 24 * 365 * 100)\n\ntype subTest struct {\n\tname string\n\trun  func(t *testing.T, s storage.Storage)\n}\n\nfunc runTests(t *testing.T, newStorage func() storage.Storage, tests []subTest) {\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ts := newStorage()\n\t\t\ttest.run(t, s)\n\t\t\ts.Close()\n\t\t})\n\t}\n}\n\n// RunTests runs a set of conformance tests against a storage. newStorage should\n// return an initialized but empty storage. The storage will be closed at the\n// end of each test run.\nfunc RunTests(t *testing.T, newStorage func() storage.Storage) {\n\trunTests(t, newStorage, []subTest{\n\t\t{\"AuthCodeCRUD\", testAuthCodeCRUD},\n\t\t{\"AuthRequestCRUD\", testAuthRequestCRUD},\n\t\t{\"ClientCRUD\", testClientCRUD},\n\t\t{\"RefreshTokenCRUD\", testRefreshTokenCRUD},\n\t\t{\"PasswordCRUD\", testPasswordCRUD},\n\t\t{\"KeysCRUD\", testKeysCRUD},\n\t\t{\"OfflineSessionCRUD\", testOfflineSessionCRUD},\n\t\t{\"ConnectorCRUD\", testConnectorCRUD},\n\t\t{\"GarbageCollection\", testGC},\n\t\t{\"TimezoneSupport\", testTimezones},\n\t\t{\"DeviceRequestCRUD\", testDeviceRequestCRUD},\n\t\t{\"DeviceTokenCRUD\", testDeviceTokenCRUD},\n\t})\n}\n\nfunc mustLoadJWK(b string) *jose.JSONWebKey {\n\tvar jwt jose.JSONWebKey\n\tif err := jwt.UnmarshalJSON([]byte(b)); err != nil {\n\t\tpanic(err)\n\t}\n\treturn &jwt\n}\n\nfunc mustBeErrNotFound(t *testing.T, kind string, err error) {\n\tswitch {\n\tcase err == nil:\n\t\tt.Errorf(\"deleting non-existent %s should return an error\", kind)\n\tcase err != storage.ErrNotFound:\n\t\tt.Errorf(\"deleting %s expected storage.ErrNotFound, got %v\", kind, err)\n\t}\n}\n\nfunc mustBeErrAlreadyExists(t *testing.T, kind string, err error) {\n\tswitch {\n\tcase err == nil:\n\t\tt.Errorf(\"attempting to create an existing %s should return an error\", kind)\n\tcase err != storage.ErrAlreadyExists:\n\t\tt.Errorf(\"creating an existing %s expected storage.ErrAlreadyExists, got %v\", kind, err)\n\t}\n}\n\nfunc testAuthRequestCRUD(t *testing.T, s storage.Storage) {\n\tcodeChallenge := storage.PKCE{\n\t\tCodeChallenge:       \"code_challenge_test\",\n\t\tCodeChallengeMethod: \"plain\",\n\t}\n\n\ta1 := storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            \"client1\",\n\t\tResponseTypes:       []string{\"code\"},\n\t\tScopes:              []string{\"openid\", \"email\"},\n\t\tRedirectURI:         \"https://localhost:80/callback\",\n\t\tNonce:               \"foo\",\n\t\tState:               \"bar\",\n\t\tForceApprovalPrompt: true,\n\t\tLoggedIn:            true,\n\t\tExpiry:              neverExpire,\n\t\tConnectorID:         \"ldap\",\n\t\tConnectorData:       []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tPKCE:    codeChallenge,\n\t\tHMACKey: []byte(\"hmac_key\"),\n\t}\n\n\tidentity := storage.Claims{Email: \"foobar\"}\n\n\tif err := s.CreateAuthRequest(a1); err != nil {\n\t\tt.Fatalf(\"failed creating auth request: %v\", err)\n\t}\n\n\t// Attempt to create same AuthRequest twice.\n\terr := s.CreateAuthRequest(a1)\n\tmustBeErrAlreadyExists(t, \"auth request\", err)\n\n\ta2 := storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            \"client2\",\n\t\tResponseTypes:       []string{\"code\"},\n\t\tScopes:              []string{\"openid\", \"email\"},\n\t\tRedirectURI:         \"https://localhost:80/callback\",\n\t\tNonce:               \"bar\",\n\t\tState:               \"foo\",\n\t\tForceApprovalPrompt: true,\n\t\tLoggedIn:            true,\n\t\tExpiry:              neverExpire,\n\t\tConnectorID:         \"ldap\",\n\t\tConnectorData:       []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"2\",\n\t\t\tUsername:      \"john\",\n\t\t\tEmail:         \"john.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\"},\n\t\t},\n\t\tHMACKey: []byte(\"hmac_key\"),\n\t}\n\n\tif err := s.CreateAuthRequest(a2); err != nil {\n\t\tt.Fatalf(\"failed creating auth request: %v\", err)\n\t}\n\n\tif err := s.UpdateAuthRequest(a1.ID, func(old storage.AuthRequest) (storage.AuthRequest, error) {\n\t\told.Claims = identity\n\t\told.ConnectorID = \"connID\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update auth request: %v\", err)\n\t}\n\n\tgot, err := s.GetAuthRequest(a1.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get auth req: %v\", err)\n\t}\n\tif !reflect.DeepEqual(got.Claims, identity) {\n\t\tt.Fatalf(\"update failed, wanted identity=%#v got %#v\", identity, got.Claims)\n\t}\n\n\tif !reflect.DeepEqual(got.PKCE, codeChallenge) {\n\t\tt.Fatalf(\"storage does not support PKCE, wanted challenge=%#v got %#v\", codeChallenge, got.PKCE)\n\t}\n\n\tif err := s.DeleteAuthRequest(a1.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete auth request: %v\", err)\n\t}\n\n\tif err := s.DeleteAuthRequest(a2.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete auth request: %v\", err)\n\t}\n\n\t_, err = s.GetAuthRequest(a1.ID)\n\tmustBeErrNotFound(t, \"auth request\", err)\n}\n\nfunc testAuthCodeCRUD(t *testing.T, s storage.Storage) {\n\ta1 := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"client1\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        neverExpire,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       \"12345\",\n\t\t\tCodeChallengeMethod: \"Whatever\",\n\t\t},\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\n\tif err := s.CreateAuthCode(a1); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\n\ta2 := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"client2\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        neverExpire,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"2\",\n\t\t\tUsername:      \"john\",\n\t\t\tEmail:         \"john.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\"},\n\t\t},\n\t}\n\n\t// Attempt to create same AuthCode twice.\n\terr := s.CreateAuthCode(a1)\n\tmustBeErrAlreadyExists(t, \"auth code\", err)\n\n\tif err := s.CreateAuthCode(a2); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\n\tgot, err := s.GetAuthCode(a1.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get auth code: %v\", err)\n\t}\n\tif a1.Expiry.Unix() != got.Expiry.Unix() {\n\t\tt.Errorf(\"auth code expiry did not match want=%s vs got=%s\", a1.Expiry, got.Expiry)\n\t}\n\tgot.Expiry = a1.Expiry // time fields do not compare well\n\tif diff := pretty.Compare(a1, got); diff != \"\" {\n\t\tt.Errorf(\"auth code retrieved from storage did not match: %s\", diff)\n\t}\n\n\tif err := s.DeleteAuthCode(a1.ID); err != nil {\n\t\tt.Fatalf(\"delete auth code: %v\", err)\n\t}\n\n\tif err := s.DeleteAuthCode(a2.ID); err != nil {\n\t\tt.Fatalf(\"delete auth code: %v\", err)\n\t}\n\n\t_, err = s.GetAuthCode(a1.ID)\n\tmustBeErrNotFound(t, \"auth code\", err)\n}\n\nfunc testClientCRUD(t *testing.T, s storage.Storage) {\n\tid1 := storage.NewID()\n\tc1 := storage.Client{\n\t\tID:           id1,\n\t\tSecret:       \"foobar\",\n\t\tRedirectURIs: []string{\"foo://bar.com/\", \"https://auth.example.com\"},\n\t\tName:         \"dex client\",\n\t\tLogoURL:      \"https://goo.gl/JIyzIC\",\n\t}\n\terr := s.DeleteClient(id1)\n\tmustBeErrNotFound(t, \"client\", err)\n\n\tif err := s.CreateClient(c1); err != nil {\n\t\tt.Fatalf(\"create client: %v\", err)\n\t}\n\n\t// Attempt to create same Client twice.\n\terr = s.CreateClient(c1)\n\tmustBeErrAlreadyExists(t, \"client\", err)\n\n\tid2 := storage.NewID()\n\tc2 := storage.Client{\n\t\tID:           id2,\n\t\tSecret:       \"barfoo\",\n\t\tRedirectURIs: []string{\"foo://bar.com/\", \"https://auth.example.com\"},\n\t\tName:         \"dex client\",\n\t\tLogoURL:      \"https://goo.gl/JIyzIC\",\n\t}\n\n\tif err := s.CreateClient(c2); err != nil {\n\t\tt.Fatalf(\"create client: %v\", err)\n\t}\n\n\tgetAndCompare := func(_ string, want storage.Client) {\n\t\tgc, err := s.GetClient(id1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get client: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif diff := pretty.Compare(want, gc); diff != \"\" {\n\t\t\tt.Errorf(\"client retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(id1, c1)\n\n\tnewSecret := \"barfoo\"\n\terr = s.UpdateClient(id1, func(old storage.Client) (storage.Client, error) {\n\t\told.Secret = newSecret\n\t\treturn old, nil\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"update client: %v\", err)\n\t}\n\tc1.Secret = newSecret\n\tgetAndCompare(id1, c1)\n\n\tif err := s.DeleteClient(id1); err != nil {\n\t\tt.Fatalf(\"delete client: %v\", err)\n\t}\n\n\tif err := s.DeleteClient(id2); err != nil {\n\t\tt.Fatalf(\"delete client: %v\", err)\n\t}\n\n\t_, err = s.GetClient(id1)\n\tmustBeErrNotFound(t, \"client\", err)\n}\n\nfunc testRefreshTokenCRUD(t *testing.T, s storage.Storage) {\n\tid := storage.NewID()\n\trefresh := storage.RefreshToken{\n\t\tID:            id,\n\t\tToken:         \"bar\",\n\t\tObsoleteToken: \"\",\n\t\tNonce:         \"foo\",\n\t\tClientID:      \"client_id\",\n\t\tConnectorID:   \"client_secret\",\n\t\tScopes:        []string{\"openid\", \"email\", \"profile\"},\n\t\tCreatedAt:     time.Now().UTC().Round(time.Millisecond),\n\t\tLastUsed:      time.Now().UTC().Round(time.Millisecond),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\tif err := s.CreateRefresh(refresh); err != nil {\n\t\tt.Fatalf(\"create refresh token: %v\", err)\n\t}\n\n\t// Attempt to create same Refresh Token twice.\n\terr := s.CreateRefresh(refresh)\n\tmustBeErrAlreadyExists(t, \"refresh token\", err)\n\n\tgetAndCompare := func(id string, want storage.RefreshToken) {\n\t\tgr, err := s.GetRefresh(id)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get refresh: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif diff := pretty.Compare(gr.CreatedAt.UnixNano(), gr.CreatedAt.UnixNano()); diff != \"\" {\n\t\t\tt.Errorf(\"refresh token created timestamp retrieved from storage did not match: %s\", diff)\n\t\t}\n\n\t\tif diff := pretty.Compare(gr.LastUsed.UnixNano(), gr.LastUsed.UnixNano()); diff != \"\" {\n\t\t\tt.Errorf(\"refresh token last used timestamp retrieved from storage did not match: %s\", diff)\n\t\t}\n\n\t\tgr.CreatedAt = time.Time{}\n\t\tgr.LastUsed = time.Time{}\n\t\twant.CreatedAt = time.Time{}\n\t\twant.LastUsed = time.Time{}\n\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"refresh token retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(id, refresh)\n\n\tid2 := storage.NewID()\n\trefresh2 := storage.RefreshToken{\n\t\tID:            id2,\n\t\tToken:         \"bar_2\",\n\t\tObsoleteToken: refresh.Token,\n\t\tNonce:         \"foo_2\",\n\t\tClientID:      \"client_id_2\",\n\t\tConnectorID:   \"client_secret\",\n\t\tScopes:        []string{\"openid\", \"email\", \"profile\"},\n\t\tCreatedAt:     time.Now().UTC().Round(time.Millisecond),\n\t\tLastUsed:      time.Now().UTC().Round(time.Millisecond),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"2\",\n\t\t\tUsername:      \"john\",\n\t\t\tEmail:         \"john.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\n\tif err := s.CreateRefresh(refresh2); err != nil {\n\t\tt.Fatalf(\"create second refresh token: %v\", err)\n\t}\n\n\tgetAndCompare(id2, refresh2)\n\n\tupdatedAt := time.Now().UTC().Round(time.Millisecond)\n\n\tupdater := func(r storage.RefreshToken) (storage.RefreshToken, error) {\n\t\tr.Token = \"spam\"\n\t\tr.LastUsed = updatedAt\n\t\treturn r, nil\n\t}\n\tif err := s.UpdateRefreshToken(id, updater); err != nil {\n\t\tt.Errorf(\"failed to update refresh token: %v\", err)\n\t}\n\trefresh.Token = \"spam\"\n\trefresh.LastUsed = updatedAt\n\tgetAndCompare(id, refresh)\n\n\t// Ensure that updating the first token doesn't impact the second. Issue #847.\n\tgetAndCompare(id2, refresh2)\n\n\tif err := s.DeleteRefresh(id); err != nil {\n\t\tt.Fatalf(\"failed to delete refresh request: %v\", err)\n\t}\n\n\tif err := s.DeleteRefresh(id2); err != nil {\n\t\tt.Fatalf(\"failed to delete refresh request: %v\", err)\n\t}\n\n\t_, err = s.GetRefresh(id)\n\tmustBeErrNotFound(t, \"refresh token\", err)\n}\n\ntype byEmail []storage.Password\n\nfunc (n byEmail) Len() int           { return len(n) }\nfunc (n byEmail) Less(i, j int) bool { return n[i].Email < n[j].Email }\nfunc (n byEmail) Swap(i, j int)      { n[i], n[j] = n[j], n[i] }\n\nfunc testPasswordCRUD(t *testing.T, s storage.Storage) {\n\t// Use bcrypt.MinCost to keep the tests short.\n\tpasswordHash1, err := bcrypt.GenerateFromPassword([]byte(\"secret\"), bcrypt.MinCost)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpassword1 := storage.Password{\n\t\tEmail:    \"jane@example.com\",\n\t\tHash:     passwordHash1,\n\t\tUsername: \"jane\",\n\t\tUserID:   \"foobar\",\n\t}\n\tif err := s.CreatePassword(password1); err != nil {\n\t\tt.Fatalf(\"create password token: %v\", err)\n\t}\n\n\t// Attempt to create same Password twice.\n\terr = s.CreatePassword(password1)\n\tmustBeErrAlreadyExists(t, \"password\", err)\n\n\tpasswordHash2, err := bcrypt.GenerateFromPassword([]byte(\"password\"), bcrypt.MinCost)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpassword2 := storage.Password{\n\t\tEmail:    \"john@example.com\",\n\t\tHash:     passwordHash2,\n\t\tUsername: \"john\",\n\t\tUserID:   \"barfoo\",\n\t}\n\tif err := s.CreatePassword(password2); err != nil {\n\t\tt.Fatalf(\"create password token: %v\", err)\n\t}\n\n\tgetAndCompare := func(id string, want storage.Password) {\n\t\tgr, err := s.GetPassword(id)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get password %q: %v\", id, err)\n\t\t\treturn\n\t\t}\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"password retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(\"jane@example.com\", password1)\n\tgetAndCompare(\"JANE@example.com\", password1) // Emails should be case insensitive\n\n\tif err := s.UpdatePassword(password1.Email, func(old storage.Password) (storage.Password, error) {\n\t\told.Username = \"jane doe\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update auth request: %v\", err)\n\t}\n\n\tpassword1.Username = \"jane doe\"\n\tgetAndCompare(\"jane@example.com\", password1)\n\n\tvar passwordList []storage.Password\n\tpasswordList = append(passwordList, password1, password2)\n\n\tlistAndCompare := func(want []storage.Password) {\n\t\tpasswords, err := s.ListPasswords()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"list password: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tsort.Sort(byEmail(want))\n\t\tsort.Sort(byEmail(passwords))\n\t\tif diff := pretty.Compare(want, passwords); diff != \"\" {\n\t\t\tt.Errorf(\"password list retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tlistAndCompare(passwordList)\n\n\tif err := s.DeletePassword(password1.Email); err != nil {\n\t\tt.Fatalf(\"failed to delete password: %v\", err)\n\t}\n\n\tif err := s.DeletePassword(password2.Email); err != nil {\n\t\tt.Fatalf(\"failed to delete password: %v\", err)\n\t}\n\n\t_, err = s.GetPassword(password1.Email)\n\tmustBeErrNotFound(t, \"password\", err)\n}\n\nfunc testOfflineSessionCRUD(t *testing.T, s storage.Storage) {\n\tuserID1 := storage.NewID()\n\tsession1 := storage.OfflineSessions{\n\t\tUserID:        userID1,\n\t\tConnID:        \"Conn1\",\n\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\n\t// Creating an OfflineSession with an empty Refresh list to ensure that\n\t// an empty map is translated as expected by the storage.\n\tif err := s.CreateOfflineSessions(session1); err != nil {\n\t\tt.Fatalf(\"create offline session with UserID = %s: %v\", session1.UserID, err)\n\t}\n\n\t// Attempt to create same OfflineSession twice.\n\terr := s.CreateOfflineSessions(session1)\n\tmustBeErrAlreadyExists(t, \"offline session\", err)\n\n\tuserID2 := storage.NewID()\n\tsession2 := storage.OfflineSessions{\n\t\tUserID:        userID2,\n\t\tConnID:        \"Conn2\",\n\t\tRefresh:       make(map[string]*storage.RefreshTokenRef),\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t}\n\n\tif err := s.CreateOfflineSessions(session2); err != nil {\n\t\tt.Fatalf(\"create offline session with UserID = %s: %v\", session2.UserID, err)\n\t}\n\n\tgetAndCompare := func(userID string, connID string, want storage.OfflineSessions) {\n\t\tgr, err := s.GetOfflineSessions(userID, connID)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get offline session: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"offline session retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(userID1, \"Conn1\", session1)\n\n\tid := storage.NewID()\n\ttokenRef := storage.RefreshTokenRef{\n\t\tID:        id,\n\t\tClientID:  \"client_id\",\n\t\tCreatedAt: time.Now().UTC().Round(time.Millisecond),\n\t\tLastUsed:  time.Now().UTC().Round(time.Millisecond),\n\t}\n\tsession1.Refresh[tokenRef.ClientID] = &tokenRef\n\n\tif err := s.UpdateOfflineSessions(session1.UserID, session1.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {\n\t\told.Refresh[tokenRef.ClientID] = &tokenRef\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update offline session: %v\", err)\n\t}\n\n\tgetAndCompare(userID1, \"Conn1\", session1)\n\n\tif err := s.DeleteOfflineSessions(session1.UserID, session1.ConnID); err != nil {\n\t\tt.Fatalf(\"failed to delete offline session: %v\", err)\n\t}\n\n\tif err := s.DeleteOfflineSessions(session2.UserID, session2.ConnID); err != nil {\n\t\tt.Fatalf(\"failed to delete offline session: %v\", err)\n\t}\n\n\t_, err = s.GetOfflineSessions(session1.UserID, session1.ConnID)\n\tmustBeErrNotFound(t, \"offline session\", err)\n}\n\nfunc testConnectorCRUD(t *testing.T, s storage.Storage) {\n\tid1 := storage.NewID()\n\tconfig1 := []byte(`{\"issuer\": \"https://accounts.google.com\"}`)\n\tc1 := storage.Connector{\n\t\tID:     id1,\n\t\tType:   \"Default\",\n\t\tName:   \"Default\",\n\t\tConfig: config1,\n\t}\n\n\tif err := s.CreateConnector(c1); err != nil {\n\t\tt.Fatalf(\"create connector with ID = %s: %v\", c1.ID, err)\n\t}\n\n\t// Attempt to create same Connector twice.\n\terr := s.CreateConnector(c1)\n\tmustBeErrAlreadyExists(t, \"connector\", err)\n\n\tid2 := storage.NewID()\n\tconfig2 := []byte(`{\"redirectURI\": \"http://127.0.0.1:5556/dex/callback\"}`)\n\tc2 := storage.Connector{\n\t\tID:     id2,\n\t\tType:   \"Mock\",\n\t\tName:   \"Mock\",\n\t\tConfig: config2,\n\t}\n\n\tif err := s.CreateConnector(c2); err != nil {\n\t\tt.Fatalf(\"create connector with ID = %s: %v\", c2.ID, err)\n\t}\n\n\tgetAndCompare := func(id string, want storage.Connector) {\n\t\tgr, err := s.GetConnector(id)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"get connector: %v\", err)\n\t\t\treturn\n\t\t}\n\t\t// ignore resource version comparison\n\t\tgr.ResourceVersion = \"\"\n\t\tif diff := pretty.Compare(want, gr); diff != \"\" {\n\t\t\tt.Errorf(\"connector retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\n\tgetAndCompare(id1, c1)\n\n\tif err := s.UpdateConnector(c1.ID, func(old storage.Connector) (storage.Connector, error) {\n\t\told.Type = \"oidc\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update Connector: %v\", err)\n\t}\n\n\tc1.Type = \"oidc\"\n\tgetAndCompare(id1, c1)\n\n\tconnectorList := []storage.Connector{c1, c2}\n\tlistAndCompare := func(want []storage.Connector) {\n\t\tconnectors, err := s.ListConnectors()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"list connectors: %v\", err)\n\t\t\treturn\n\t\t}\n\t\t// ignore resource version comparison\n\t\tfor i := range connectors {\n\t\t\tconnectors[i].ResourceVersion = \"\"\n\t\t}\n\t\tsort.Slice(connectors, func(i, j int) bool {\n\t\t\treturn connectors[i].Name < connectors[j].Name\n\t\t})\n\t\tif diff := pretty.Compare(want, connectors); diff != \"\" {\n\t\t\tt.Errorf(\"connector list retrieved from storage did not match: %s\", diff)\n\t\t}\n\t}\n\tlistAndCompare(connectorList)\n\n\tif err := s.DeleteConnector(c1.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete connector: %v\", err)\n\t}\n\n\tif err := s.DeleteConnector(c2.ID); err != nil {\n\t\tt.Fatalf(\"failed to delete connector: %v\", err)\n\t}\n\n\t_, err = s.GetConnector(c1.ID)\n\tmustBeErrNotFound(t, \"connector\", err)\n}\n\nfunc testKeysCRUD(t *testing.T, s storage.Storage) {\n\tupdateAndCompare := func(k storage.Keys) {\n\t\terr := s.UpdateKeys(func(oldKeys storage.Keys) (storage.Keys, error) {\n\t\t\treturn k, nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to update keys: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif got, err := s.GetKeys(); err != nil {\n\t\t\tt.Errorf(\"failed to get keys: %v\", err)\n\t\t} else {\n\t\t\tgot.NextRotation = got.NextRotation.UTC()\n\t\t\tif diff := pretty.Compare(k, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"got keys did not equal expected: %s\", diff)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Postgres isn't as accurate with nano seconds as we'd like\n\tn := time.Now().UTC().Round(time.Second)\n\n\tkeys1 := storage.Keys{\n\t\tSigningKey:    jsonWebKeys[0].Private,\n\t\tSigningKeyPub: jsonWebKeys[0].Public,\n\t\tNextRotation:  n,\n\t}\n\n\tkeys2 := storage.Keys{\n\t\tSigningKey:    jsonWebKeys[2].Private,\n\t\tSigningKeyPub: jsonWebKeys[2].Public,\n\t\tNextRotation:  n.Add(time.Hour),\n\t\tVerificationKeys: []storage.VerificationKey{\n\t\t\t{\n\t\t\t\tPublicKey: jsonWebKeys[0].Public,\n\t\t\t\tExpiry:    n.Add(time.Hour),\n\t\t\t},\n\t\t\t{\n\t\t\t\tPublicKey: jsonWebKeys[1].Public,\n\t\t\t\tExpiry:    n.Add(time.Hour * 2),\n\t\t\t},\n\t\t},\n\t}\n\n\tupdateAndCompare(keys1)\n\tupdateAndCompare(keys2)\n}\n\nfunc testGC(t *testing.T, s storage.Storage) {\n\test, err := time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpst, err := time.LoadLocation(\"America/Los_Angeles\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpiry := time.Now().In(est)\n\tc := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"foobar\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        expiry,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\n\tif err := s.CreateAuthCode(c); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.AuthCodes != 0 || result.AuthRequests != 0 {\n\t\t\tt.Errorf(\"expected no garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetAuthCode(c.ID); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get auth code after GC: %v\", err)\n\t\t}\n\t}\n\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.AuthCodes != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 objects, got %d\", r.AuthCodes)\n\t}\n\n\tif _, err := s.GetAuthCode(c.ID); err == nil {\n\t\tt.Errorf(\"expected auth code to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n\n\ta := storage.AuthRequest{\n\t\tID:                  storage.NewID(),\n\t\tClientID:            \"foobar\",\n\t\tResponseTypes:       []string{\"code\"},\n\t\tScopes:              []string{\"openid\", \"email\"},\n\t\tRedirectURI:         \"https://localhost:80/callback\",\n\t\tNonce:               \"foo\",\n\t\tState:               \"bar\",\n\t\tForceApprovalPrompt: true,\n\t\tLoggedIn:            true,\n\t\tExpiry:              expiry,\n\t\tConnectorID:         \"ldap\",\n\t\tConnectorData:       []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t\tHMACKey: []byte(\"hmac_key\"),\n\t}\n\n\tif err := s.CreateAuthRequest(a); err != nil {\n\t\tt.Fatalf(\"failed creating auth request: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.AuthCodes != 0 || result.AuthRequests != 0 {\n\t\t\tt.Errorf(\"expected no garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetAuthRequest(a.ID); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get auth request after GC: %v\", err)\n\t\t}\n\t}\n\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.AuthRequests != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 objects, got %d\", r.AuthRequests)\n\t}\n\n\tif _, err := s.GetAuthRequest(a.ID); err == nil {\n\t\tt.Errorf(\"expected auth request to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n\n\td := storage.DeviceRequest{\n\t\tUserCode:     storage.NewUserCode(),\n\t\tDeviceCode:   storage.NewID(),\n\t\tClientID:     \"client1\",\n\t\tClientSecret: \"secret1\",\n\t\tScopes:       []string{\"openid\", \"email\"},\n\t\tExpiry:       expiry,\n\t}\n\n\tif err := s.CreateDeviceRequest(d); err != nil {\n\t\tt.Fatalf(\"failed creating device request: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.DeviceRequests != 0 {\n\t\t\tt.Errorf(\"expected no device garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetDeviceRequest(d.UserCode); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get auth request after GC: %v\", err)\n\t\t}\n\t}\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.DeviceRequests != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 device request, got %d\", r.DeviceRequests)\n\t}\n\n\tif _, err := s.GetDeviceRequest(d.UserCode); err == nil {\n\t\tt.Errorf(\"expected device request to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n\n\tdt := storage.DeviceToken{\n\t\tDeviceCode:          storage.NewID(),\n\t\tStatus:              \"pending\",\n\t\tToken:               \"foo\",\n\t\tExpiry:              expiry,\n\t\tLastRequestTime:     time.Now(),\n\t\tPollIntervalSeconds: 0,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       \"challenge\",\n\t\t\tCodeChallengeMethod: \"S256\",\n\t\t},\n\t}\n\n\tif err := s.CreateDeviceToken(dt); err != nil {\n\t\tt.Fatalf(\"failed creating device token: %v\", err)\n\t}\n\n\tfor _, tz := range []*time.Location{time.UTC, est, pst} {\n\t\tresult, err := s.GarbageCollect(expiry.Add(-time.Hour).In(tz))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t\t} else if result.DeviceTokens != 0 {\n\t\t\tt.Errorf(\"expected no device token garbage collection results, got %#v\", result)\n\t\t}\n\t\tif _, err := s.GetDeviceToken(dt.DeviceCode); err != nil {\n\t\t\tt.Errorf(\"expected to be able to get device token after GC: %v\", err)\n\t\t}\n\t}\n\tif r, err := s.GarbageCollect(expiry.Add(time.Hour)); err != nil {\n\t\tt.Errorf(\"garbage collection failed: %v\", err)\n\t} else if r.DeviceTokens != 1 {\n\t\tt.Errorf(\"expected to garbage collect 1 device token, got %d\", r.DeviceTokens)\n\t}\n\n\tif _, err := s.GetDeviceToken(dt.DeviceCode); err == nil {\n\t\tt.Errorf(\"expected device token to be GC'd\")\n\t} else if err != storage.ErrNotFound {\n\t\tt.Errorf(\"expected storage.ErrNotFound, got %v\", err)\n\t}\n}\n\n// testTimezones tests that backends either fully support timezones or\n// do the correct standardization.\nfunc testTimezones(t *testing.T, s storage.Storage) {\n\test, err := time.LoadLocation(\"America/New_York\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Create an expiry with timezone info. Only expect backends to be\n\t// accurate to the millisecond\n\texpiry := time.Now().In(est).Round(time.Millisecond)\n\n\tc := storage.AuthCode{\n\t\tID:            storage.NewID(),\n\t\tClientID:      \"foobar\",\n\t\tRedirectURI:   \"https://localhost:80/callback\",\n\t\tNonce:         \"foobar\",\n\t\tScopes:        []string{\"openid\", \"email\"},\n\t\tExpiry:        expiry,\n\t\tConnectorID:   \"ldap\",\n\t\tConnectorData: []byte(`{\"some\":\"data\"}`),\n\t\tClaims: storage.Claims{\n\t\t\tUserID:        \"1\",\n\t\t\tUsername:      \"jane\",\n\t\t\tEmail:         \"jane.doe@example.com\",\n\t\t\tEmailVerified: true,\n\t\t\tGroups:        []string{\"a\", \"b\"},\n\t\t},\n\t}\n\tif err := s.CreateAuthCode(c); err != nil {\n\t\tt.Fatalf(\"failed creating auth code: %v\", err)\n\t}\n\tgot, err := s.GetAuthCode(c.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get auth code: %v\", err)\n\t}\n\n\t// Ensure that if the resulting time is converted to the same\n\t// timezone, it's the same value. We DO NOT expect timezones\n\t// to be preserved.\n\tgotTime := got.Expiry.In(est)\n\twantTime := expiry\n\tif !gotTime.Equal(wantTime) {\n\t\tt.Fatalf(\"expected expiry %v got %v\", wantTime, gotTime)\n\t}\n}\n\nfunc testDeviceRequestCRUD(t *testing.T, s storage.Storage) {\n\td1 := storage.DeviceRequest{\n\t\tUserCode:     storage.NewUserCode(),\n\t\tDeviceCode:   storage.NewID(),\n\t\tClientID:     \"client1\",\n\t\tClientSecret: \"secret1\",\n\t\tScopes:       []string{\"openid\", \"email\"},\n\t\tExpiry:       neverExpire,\n\t}\n\n\tif err := s.CreateDeviceRequest(d1); err != nil {\n\t\tt.Fatalf(\"failed creating device request: %v\", err)\n\t}\n\n\t// Attempt to create same DeviceRequest twice.\n\terr := s.CreateDeviceRequest(d1)\n\tmustBeErrAlreadyExists(t, \"device request\", err)\n\n\t// No manual deletes for device requests, will be handled by garbage collection routines\n\t// see testGC\n}\n\nfunc testDeviceTokenCRUD(t *testing.T, s storage.Storage) {\n\tcodeChallenge := storage.PKCE{\n\t\tCodeChallenge:       \"code_challenge_test\",\n\t\tCodeChallengeMethod: \"plain\",\n\t}\n\n\t// Create a Token\n\td1 := storage.DeviceToken{\n\t\tDeviceCode:          storage.NewID(),\n\t\tStatus:              \"pending\",\n\t\tToken:               storage.NewID(),\n\t\tExpiry:              neverExpire,\n\t\tLastRequestTime:     time.Now(),\n\t\tPollIntervalSeconds: 0,\n\t\tPKCE:                codeChallenge,\n\t}\n\n\tif err := s.CreateDeviceToken(d1); err != nil {\n\t\tt.Fatalf(\"failed creating device token: %v\", err)\n\t}\n\n\t// Attempt to create same Device Token twice.\n\terr := s.CreateDeviceToken(d1)\n\tmustBeErrAlreadyExists(t, \"device token\", err)\n\n\t// Update the device token, simulate a redemption\n\tif err := s.UpdateDeviceToken(d1.DeviceCode, func(old storage.DeviceToken) (storage.DeviceToken, error) {\n\t\told.Token = \"token data\"\n\t\told.Status = \"complete\"\n\t\treturn old, nil\n\t}); err != nil {\n\t\tt.Fatalf(\"failed to update device token: %v\", err)\n\t}\n\n\t// Retrieve the device token\n\tgot, err := s.GetDeviceToken(d1.DeviceCode)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get device token: %v\", err)\n\t}\n\n\t// Validate expected result set\n\tif got.Status != \"complete\" {\n\t\tt.Fatalf(\"update failed, wanted token status=%v got %v\", \"complete\", got.Status)\n\t}\n\tif got.Token != \"token data\" {\n\t\tt.Fatalf(\"update failed, wanted token %v got %v\", \"token data\", got.Token)\n\t}\n\tif !reflect.DeepEqual(got.PKCE, codeChallenge) {\n\t\tt.Fatalf(\"storage does not support PKCE, wanted challenge=%#v got %#v\", codeChallenge, got.PKCE)\n\t}\n}\n", "package client\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// CreateAuthRequest saves provided auth request into the database.\nfunc (d *Database) CreateAuthRequest(authRequest storage.AuthRequest) error {\n\t_, err := d.client.AuthRequest.Create().\n\t\tSetID(authRequest.ID).\n\t\tSetClientID(authRequest.ClientID).\n\t\tSetScopes(authRequest.Scopes).\n\t\tSetResponseTypes(authRequest.ResponseTypes).\n\t\tSetRedirectURI(authRequest.RedirectURI).\n\t\tSetState(authRequest.State).\n\t\tSetNonce(authRequest.Nonce).\n\t\tSetForceApprovalPrompt(authRequest.ForceApprovalPrompt).\n\t\tSetLoggedIn(authRequest.LoggedIn).\n\t\tSetClaimsUserID(authRequest.Claims.UserID).\n\t\tSetClaimsEmail(authRequest.Claims.Email).\n\t\tSetClaimsEmailVerified(authRequest.Claims.EmailVerified).\n\t\tSetClaimsUsername(authRequest.Claims.Username).\n\t\tSetClaimsPreferredUsername(authRequest.Claims.PreferredUsername).\n\t\tSetClaimsGroups(authRequest.Claims.Groups).\n\t\tSetCodeChallenge(authRequest.PKCE.CodeChallenge).\n\t\tSetCodeChallengeMethod(authRequest.PKCE.CodeChallengeMethod).\n\t\t// Save utc time into database because ent doesn't support comparing dates with different timezones\n\t\tSetExpiry(authRequest.Expiry.UTC()).\n\t\tSetConnectorID(authRequest.ConnectorID).\n\t\tSetConnectorData(authRequest.ConnectorData).\n\t\tSetHmacKey(authRequest.HMACKey).\n\t\tSave(context.TODO())\n\tif err != nil {\n\t\treturn convertDBError(\"create auth request: %w\", err)\n\t}\n\treturn nil\n}\n\n// GetAuthRequest extracts an auth request from the database by id.\nfunc (d *Database) GetAuthRequest(id string) (storage.AuthRequest, error) {\n\tauthRequest, err := d.client.AuthRequest.Get(context.TODO(), id)\n\tif err != nil {\n\t\treturn storage.AuthRequest{}, convertDBError(\"get auth request: %w\", err)\n\t}\n\treturn toStorageAuthRequest(authRequest), nil\n}\n\n// DeleteAuthRequest deletes an auth request from the database by id.\nfunc (d *Database) DeleteAuthRequest(id string) error {\n\terr := d.client.AuthRequest.DeleteOneID(id).Exec(context.TODO())\n\tif err != nil {\n\t\treturn convertDBError(\"delete auth request: %w\", err)\n\t}\n\treturn nil\n}\n\n// UpdateAuthRequest changes an auth request by id using an updater function and saves it to the database.\nfunc (d *Database) UpdateAuthRequest(id string, updater func(old storage.AuthRequest) (storage.AuthRequest, error)) error {\n\ttx, err := d.BeginTx(context.TODO())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"update auth request tx: %w\", err)\n\t}\n\n\tauthRequest, err := tx.AuthRequest.Get(context.TODO(), id)\n\tif err != nil {\n\t\treturn rollback(tx, \"update auth request database: %w\", err)\n\t}\n\n\tnewAuthRequest, err := updater(toStorageAuthRequest(authRequest))\n\tif err != nil {\n\t\treturn rollback(tx, \"update auth request updating: %w\", err)\n\t}\n\n\t_, err = tx.AuthRequest.UpdateOneID(newAuthRequest.ID).\n\t\tSetClientID(newAuthRequest.ClientID).\n\t\tSetScopes(newAuthRequest.Scopes).\n\t\tSetResponseTypes(newAuthRequest.ResponseTypes).\n\t\tSetRedirectURI(newAuthRequest.RedirectURI).\n\t\tSetState(newAuthRequest.State).\n\t\tSetNonce(newAuthRequest.Nonce).\n\t\tSetForceApprovalPrompt(newAuthRequest.ForceApprovalPrompt).\n\t\tSetLoggedIn(newAuthRequest.LoggedIn).\n\t\tSetClaimsUserID(newAuthRequest.Claims.UserID).\n\t\tSetClaimsEmail(newAuthRequest.Claims.Email).\n\t\tSetClaimsEmailVerified(newAuthRequest.Claims.EmailVerified).\n\t\tSetClaimsUsername(newAuthRequest.Claims.Username).\n\t\tSetClaimsPreferredUsername(newAuthRequest.Claims.PreferredUsername).\n\t\tSetClaimsGroups(newAuthRequest.Claims.Groups).\n\t\tSetCodeChallenge(newAuthRequest.PKCE.CodeChallenge).\n\t\tSetCodeChallengeMethod(newAuthRequest.PKCE.CodeChallengeMethod).\n\t\t// Save utc time into database because ent doesn't support comparing dates with different timezones\n\t\tSetExpiry(newAuthRequest.Expiry.UTC()).\n\t\tSetConnectorID(newAuthRequest.ConnectorID).\n\t\tSetConnectorData(newAuthRequest.ConnectorData).\n\t\tSetHmacKey(newAuthRequest.HMACKey).\n\t\tSave(context.TODO())\n\tif err != nil {\n\t\treturn rollback(tx, \"update auth request uploading: %w\", err)\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\treturn rollback(tx, \"update auth request commit: %w\", err)\n\t}\n\n\treturn nil\n}\n", "package client\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/ent/db\"\n)\n\nconst keysRowID = \"keys\"\n\nfunc toStorageKeys(keys *db.Keys) storage.Keys {\n\treturn storage.Keys{\n\t\tSigningKey:       &keys.SigningKey,\n\t\tSigningKeyPub:    &keys.SigningKeyPub,\n\t\tVerificationKeys: keys.VerificationKeys,\n\t\tNextRotation:     keys.NextRotation,\n\t}\n}\n\nfunc toStorageAuthRequest(a *db.AuthRequest) storage.AuthRequest {\n\treturn storage.AuthRequest{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       *a.ConnectorData,\n\t\tExpiry:              a.Expiry,\n\t\tClaims: storage.Claims{\n\t\t\tUserID:            a.ClaimsUserID,\n\t\t\tUsername:          a.ClaimsUsername,\n\t\t\tPreferredUsername: a.ClaimsPreferredUsername,\n\t\t\tEmail:             a.ClaimsEmail,\n\t\t\tEmailVerified:     a.ClaimsEmailVerified,\n\t\t\tGroups:            a.ClaimsGroups,\n\t\t},\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t\tHMACKey: a.HmacKey,\n\t}\n}\n\nfunc toStorageAuthCode(a *db.AuthCode) storage.AuthCode {\n\treturn storage.AuthCode{\n\t\tID:            a.ID,\n\t\tClientID:      a.ClientID,\n\t\tScopes:        a.Scopes,\n\t\tRedirectURI:   a.RedirectURI,\n\t\tNonce:         a.Nonce,\n\t\tConnectorID:   a.ConnectorID,\n\t\tConnectorData: *a.ConnectorData,\n\t\tExpiry:        a.Expiry,\n\t\tClaims: storage.Claims{\n\t\t\tUserID:            a.ClaimsUserID,\n\t\t\tUsername:          a.ClaimsUsername,\n\t\t\tPreferredUsername: a.ClaimsPreferredUsername,\n\t\t\tEmail:             a.ClaimsEmail,\n\t\t\tEmailVerified:     a.ClaimsEmailVerified,\n\t\t\tGroups:            a.ClaimsGroups,\n\t\t},\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\nfunc toStorageClient(c *db.OAuth2Client) storage.Client {\n\treturn storage.Client{\n\t\tID:           c.ID,\n\t\tSecret:       c.Secret,\n\t\tRedirectURIs: c.RedirectUris,\n\t\tTrustedPeers: c.TrustedPeers,\n\t\tPublic:       c.Public,\n\t\tName:         c.Name,\n\t\tLogoURL:      c.LogoURL,\n\t}\n}\n\nfunc toStorageConnector(c *db.Connector) storage.Connector {\n\treturn storage.Connector{\n\t\tID:     c.ID,\n\t\tType:   c.Type,\n\t\tName:   c.Name,\n\t\tConfig: c.Config,\n\t}\n}\n\nfunc toStorageOfflineSession(o *db.OfflineSession) storage.OfflineSessions {\n\ts := storage.OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tConnectorData: *o.ConnectorData,\n\t}\n\n\tif o.Refresh != nil {\n\t\tif err := json.Unmarshal(o.Refresh, &s.Refresh); err != nil {\n\t\t\t// Correctness of json structure if guaranteed on uploading\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\t// Server code assumes this will be non-nil.\n\t\ts.Refresh = make(map[string]*storage.RefreshTokenRef)\n\t}\n\treturn s\n}\n\nfunc toStorageRefreshToken(r *db.RefreshToken) storage.RefreshToken {\n\treturn storage.RefreshToken{\n\t\tID:            r.ID,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: *r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims: storage.Claims{\n\t\t\tUserID:            r.ClaimsUserID,\n\t\t\tUsername:          r.ClaimsUsername,\n\t\t\tPreferredUsername: r.ClaimsPreferredUsername,\n\t\t\tEmail:             r.ClaimsEmail,\n\t\t\tEmailVerified:     r.ClaimsEmailVerified,\n\t\t\tGroups:            r.ClaimsGroups,\n\t\t},\n\t}\n}\n\nfunc toStoragePassword(p *db.Password) storage.Password {\n\treturn storage.Password{\n\t\tEmail:    p.Email,\n\t\tHash:     p.Hash,\n\t\tUsername: p.Username,\n\t\tUserID:   p.UserID,\n\t}\n}\n\nfunc toStorageDeviceRequest(r *db.DeviceRequest) storage.DeviceRequest {\n\treturn storage.DeviceRequest{\n\t\tUserCode:     strings.ToUpper(r.UserCode),\n\t\tDeviceCode:   r.DeviceCode,\n\t\tClientID:     r.ClientID,\n\t\tClientSecret: r.ClientSecret,\n\t\tScopes:       r.Scopes,\n\t\tExpiry:       r.Expiry,\n\t}\n}\n\nfunc toStorageDeviceToken(t *db.DeviceToken) storage.DeviceToken {\n\treturn storage.DeviceToken{\n\t\tDeviceCode:          t.DeviceCode,\n\t\tStatus:              t.Status,\n\t\tToken:               string(*t.Token),\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequest,\n\t\tPollIntervalSeconds: t.PollInterval,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       t.CodeChallenge,\n\t\t\tCodeChallengeMethod: t.CodeChallengeMethod,\n\t\t},\n\t}\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n)\n\n// AuthRequest is the model entity for the AuthRequest schema.\ntype AuthRequest struct {\n\tconfig `json:\"-\"`\n\t// ID of the ent.\n\tID string `json:\"id,omitempty\"`\n\t// ClientID holds the value of the \"client_id\" field.\n\tClientID string `json:\"client_id,omitempty\"`\n\t// Scopes holds the value of the \"scopes\" field.\n\tScopes []string `json:\"scopes,omitempty\"`\n\t// ResponseTypes holds the value of the \"response_types\" field.\n\tResponseTypes []string `json:\"response_types,omitempty\"`\n\t// RedirectURI holds the value of the \"redirect_uri\" field.\n\tRedirectURI string `json:\"redirect_uri,omitempty\"`\n\t// Nonce holds the value of the \"nonce\" field.\n\tNonce string `json:\"nonce,omitempty\"`\n\t// State holds the value of the \"state\" field.\n\tState string `json:\"state,omitempty\"`\n\t// ForceApprovalPrompt holds the value of the \"force_approval_prompt\" field.\n\tForceApprovalPrompt bool `json:\"force_approval_prompt,omitempty\"`\n\t// LoggedIn holds the value of the \"logged_in\" field.\n\tLoggedIn bool `json:\"logged_in,omitempty\"`\n\t// ClaimsUserID holds the value of the \"claims_user_id\" field.\n\tClaimsUserID string `json:\"claims_user_id,omitempty\"`\n\t// ClaimsUsername holds the value of the \"claims_username\" field.\n\tClaimsUsername string `json:\"claims_username,omitempty\"`\n\t// ClaimsEmail holds the value of the \"claims_email\" field.\n\tClaimsEmail string `json:\"claims_email,omitempty\"`\n\t// ClaimsEmailVerified holds the value of the \"claims_email_verified\" field.\n\tClaimsEmailVerified bool `json:\"claims_email_verified,omitempty\"`\n\t// ClaimsGroups holds the value of the \"claims_groups\" field.\n\tClaimsGroups []string `json:\"claims_groups,omitempty\"`\n\t// ClaimsPreferredUsername holds the value of the \"claims_preferred_username\" field.\n\tClaimsPreferredUsername string `json:\"claims_preferred_username,omitempty\"`\n\t// ConnectorID holds the value of the \"connector_id\" field.\n\tConnectorID string `json:\"connector_id,omitempty\"`\n\t// ConnectorData holds the value of the \"connector_data\" field.\n\tConnectorData *[]byte `json:\"connector_data,omitempty\"`\n\t// Expiry holds the value of the \"expiry\" field.\n\tExpiry time.Time `json:\"expiry,omitempty\"`\n\t// CodeChallenge holds the value of the \"code_challenge\" field.\n\tCodeChallenge string `json:\"code_challenge,omitempty\"`\n\t// CodeChallengeMethod holds the value of the \"code_challenge_method\" field.\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n\t// HmacKey holds the value of the \"hmac_key\" field.\n\tHmacKey []byte `json:\"hmac_key,omitempty\"`\n}\n\n// scanValues returns the types for scanning values from sql.Rows.\nfunc (*AuthRequest) scanValues(columns []string) ([]interface{}, error) {\n\tvalues := make([]interface{}, len(columns))\n\tfor i := range columns {\n\t\tswitch columns[i] {\n\t\tcase authrequest.FieldScopes, authrequest.FieldResponseTypes, authrequest.FieldClaimsGroups, authrequest.FieldConnectorData, authrequest.FieldHmacKey:\n\t\t\tvalues[i] = new([]byte)\n\t\tcase authrequest.FieldForceApprovalPrompt, authrequest.FieldLoggedIn, authrequest.FieldClaimsEmailVerified:\n\t\t\tvalues[i] = new(sql.NullBool)\n\t\tcase authrequest.FieldID, authrequest.FieldClientID, authrequest.FieldRedirectURI, authrequest.FieldNonce, authrequest.FieldState, authrequest.FieldClaimsUserID, authrequest.FieldClaimsUsername, authrequest.FieldClaimsEmail, authrequest.FieldClaimsPreferredUsername, authrequest.FieldConnectorID, authrequest.FieldCodeChallenge, authrequest.FieldCodeChallengeMethod:\n\t\t\tvalues[i] = new(sql.NullString)\n\t\tcase authrequest.FieldExpiry:\n\t\t\tvalues[i] = new(sql.NullTime)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected column %q for type AuthRequest\", columns[i])\n\t\t}\n\t}\n\treturn values, nil\n}\n\n// assignValues assigns the values that were returned from sql.Rows (after scanning)\n// to the AuthRequest fields.\nfunc (ar *AuthRequest) assignValues(columns []string, values []interface{}) error {\n\tif m, n := len(values), len(columns); m < n {\n\t\treturn fmt.Errorf(\"mismatch number of scan values: %d != %d\", m, n)\n\t}\n\tfor i := range columns {\n\t\tswitch columns[i] {\n\t\tcase authrequest.FieldID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClientID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field client_id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClientID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldScopes:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field scopes\", values[i])\n\t\t\t} else if value != nil && len(*value) > 0 {\n\t\t\t\tif err := json.Unmarshal(*value, &ar.Scopes); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal field scopes: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase authrequest.FieldResponseTypes:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field response_types\", values[i])\n\t\t\t} else if value != nil && len(*value) > 0 {\n\t\t\t\tif err := json.Unmarshal(*value, &ar.ResponseTypes); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal field response_types: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase authrequest.FieldRedirectURI:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field redirect_uri\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.RedirectURI = value.String\n\t\t\t}\n\t\tcase authrequest.FieldNonce:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field nonce\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.Nonce = value.String\n\t\t\t}\n\t\tcase authrequest.FieldState:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field state\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.State = value.String\n\t\t\t}\n\t\tcase authrequest.FieldForceApprovalPrompt:\n\t\t\tif value, ok := values[i].(*sql.NullBool); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field force_approval_prompt\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ForceApprovalPrompt = value.Bool\n\t\t\t}\n\t\tcase authrequest.FieldLoggedIn:\n\t\t\tif value, ok := values[i].(*sql.NullBool); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field logged_in\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.LoggedIn = value.Bool\n\t\t\t}\n\t\tcase authrequest.FieldClaimsUserID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_user_id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsUserID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClaimsUsername:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_username\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsUsername = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClaimsEmail:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_email\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsEmail = value.String\n\t\t\t}\n\t\tcase authrequest.FieldClaimsEmailVerified:\n\t\t\tif value, ok := values[i].(*sql.NullBool); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_email_verified\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsEmailVerified = value.Bool\n\t\t\t}\n\t\tcase authrequest.FieldClaimsGroups:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_groups\", values[i])\n\t\t\t} else if value != nil && len(*value) > 0 {\n\t\t\t\tif err := json.Unmarshal(*value, &ar.ClaimsGroups); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal field claims_groups: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase authrequest.FieldClaimsPreferredUsername:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field claims_preferred_username\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ClaimsPreferredUsername = value.String\n\t\t\t}\n\t\tcase authrequest.FieldConnectorID:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field connector_id\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.ConnectorID = value.String\n\t\t\t}\n\t\tcase authrequest.FieldConnectorData:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field connector_data\", values[i])\n\t\t\t} else if value != nil {\n\t\t\t\tar.ConnectorData = value\n\t\t\t}\n\t\tcase authrequest.FieldExpiry:\n\t\t\tif value, ok := values[i].(*sql.NullTime); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field expiry\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.Expiry = value.Time\n\t\t\t}\n\t\tcase authrequest.FieldCodeChallenge:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field code_challenge\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.CodeChallenge = value.String\n\t\t\t}\n\t\tcase authrequest.FieldCodeChallengeMethod:\n\t\t\tif value, ok := values[i].(*sql.NullString); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field code_challenge_method\", values[i])\n\t\t\t} else if value.Valid {\n\t\t\t\tar.CodeChallengeMethod = value.String\n\t\t\t}\n\t\tcase authrequest.FieldHmacKey:\n\t\t\tif value, ok := values[i].(*[]byte); !ok {\n\t\t\t\treturn fmt.Errorf(\"unexpected type %T for field hmac_key\", values[i])\n\t\t\t} else if value != nil {\n\t\t\t\tar.HmacKey = *value\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Update returns a builder for updating this AuthRequest.\n// Note that you need to call AuthRequest.Unwrap() before calling this method if this AuthRequest\n// was returned from a transaction, and the transaction was committed or rolled back.\nfunc (ar *AuthRequest) Update() *AuthRequestUpdateOne {\n\treturn (&AuthRequestClient{config: ar.config}).UpdateOne(ar)\n}\n\n// Unwrap unwraps the AuthRequest entity that was returned from a transaction after it was closed,\n// so that all future queries will be executed through the driver which created the transaction.\nfunc (ar *AuthRequest) Unwrap() *AuthRequest {\n\t_tx, ok := ar.config.driver.(*txDriver)\n\tif !ok {\n\t\tpanic(\"db: AuthRequest is not a transactional entity\")\n\t}\n\tar.config.driver = _tx.drv\n\treturn ar\n}\n\n// String implements the fmt.Stringer.\nfunc (ar *AuthRequest) String() string {\n\tvar builder strings.Builder\n\tbuilder.WriteString(\"AuthRequest(\")\n\tbuilder.WriteString(fmt.Sprintf(\"id=%v, \", ar.ID))\n\tbuilder.WriteString(\"client_id=\")\n\tbuilder.WriteString(ar.ClientID)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"scopes=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.Scopes))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"response_types=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ResponseTypes))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"redirect_uri=\")\n\tbuilder.WriteString(ar.RedirectURI)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"nonce=\")\n\tbuilder.WriteString(ar.Nonce)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"state=\")\n\tbuilder.WriteString(ar.State)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"force_approval_prompt=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ForceApprovalPrompt))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"logged_in=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.LoggedIn))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_user_id=\")\n\tbuilder.WriteString(ar.ClaimsUserID)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_username=\")\n\tbuilder.WriteString(ar.ClaimsUsername)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_email=\")\n\tbuilder.WriteString(ar.ClaimsEmail)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_email_verified=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ClaimsEmailVerified))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_groups=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.ClaimsGroups))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"claims_preferred_username=\")\n\tbuilder.WriteString(ar.ClaimsPreferredUsername)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"connector_id=\")\n\tbuilder.WriteString(ar.ConnectorID)\n\tbuilder.WriteString(\", \")\n\tif v := ar.ConnectorData; v != nil {\n\t\tbuilder.WriteString(\"connector_data=\")\n\t\tbuilder.WriteString(fmt.Sprintf(\"%v\", *v))\n\t}\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"expiry=\")\n\tbuilder.WriteString(ar.Expiry.Format(time.ANSIC))\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"code_challenge=\")\n\tbuilder.WriteString(ar.CodeChallenge)\n\tbuilder.WriteString(\", \")\n\tbuilder.WriteString(\"code_challenge_method=\")\n\tbuilder.WriteString(ar.CodeChallengeMethod)\n\tbuilder.WriteString(\", hmac_key=\")\n\tbuilder.WriteString(fmt.Sprintf(\"%v\", ar.HmacKey))\n\tbuilder.WriteByte(')')\n\treturn builder.String()\n}\n\n// AuthRequests is a parsable slice of AuthRequest.\ntype AuthRequests []*AuthRequest\n\nfunc (ar AuthRequests) config(cfg config) {\n\tfor _i := range ar {\n\t\tar[_i].config = cfg\n\t}\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage authrequest\n\nconst (\n\t// Label holds the string label denoting the authrequest type in the database.\n\tLabel = \"auth_request\"\n\t// FieldID holds the string denoting the id field in the database.\n\tFieldID = \"id\"\n\t// FieldClientID holds the string denoting the client_id field in the database.\n\tFieldClientID = \"client_id\"\n\t// FieldScopes holds the string denoting the scopes field in the database.\n\tFieldScopes = \"scopes\"\n\t// FieldResponseTypes holds the string denoting the response_types field in the database.\n\tFieldResponseTypes = \"response_types\"\n\t// FieldRedirectURI holds the string denoting the redirect_uri field in the database.\n\tFieldRedirectURI = \"redirect_uri\"\n\t// FieldNonce holds the string denoting the nonce field in the database.\n\tFieldNonce = \"nonce\"\n\t// FieldState holds the string denoting the state field in the database.\n\tFieldState = \"state\"\n\t// FieldForceApprovalPrompt holds the string denoting the force_approval_prompt field in the database.\n\tFieldForceApprovalPrompt = \"force_approval_prompt\"\n\t// FieldLoggedIn holds the string denoting the logged_in field in the database.\n\tFieldLoggedIn = \"logged_in\"\n\t// FieldClaimsUserID holds the string denoting the claims_user_id field in the database.\n\tFieldClaimsUserID = \"claims_user_id\"\n\t// FieldClaimsUsername holds the string denoting the claims_username field in the database.\n\tFieldClaimsUsername = \"claims_username\"\n\t// FieldClaimsEmail holds the string denoting the claims_email field in the database.\n\tFieldClaimsEmail = \"claims_email\"\n\t// FieldClaimsEmailVerified holds the string denoting the claims_email_verified field in the database.\n\tFieldClaimsEmailVerified = \"claims_email_verified\"\n\t// FieldClaimsGroups holds the string denoting the claims_groups field in the database.\n\tFieldClaimsGroups = \"claims_groups\"\n\t// FieldClaimsPreferredUsername holds the string denoting the claims_preferred_username field in the database.\n\tFieldClaimsPreferredUsername = \"claims_preferred_username\"\n\t// FieldConnectorID holds the string denoting the connector_id field in the database.\n\tFieldConnectorID = \"connector_id\"\n\t// FieldConnectorData holds the string denoting the connector_data field in the database.\n\tFieldConnectorData = \"connector_data\"\n\t// FieldExpiry holds the string denoting the expiry field in the database.\n\tFieldExpiry = \"expiry\"\n\t// FieldCodeChallenge holds the string denoting the code_challenge field in the database.\n\tFieldCodeChallenge = \"code_challenge\"\n\t// FieldCodeChallengeMethod holds the string denoting the code_challenge_method field in the database.\n\tFieldCodeChallengeMethod = \"code_challenge_method\"\n\t// FieldHmacKey holds the string denoting the hmac_key field in the database.\n\tFieldHmacKey = \"hmac_key\"\n\t// Table holds the table name of the authrequest in the database.\n\tTable = \"auth_requests\"\n)\n\n// Columns holds all SQL columns for authrequest fields.\nvar Columns = []string{\n\tFieldID,\n\tFieldClientID,\n\tFieldScopes,\n\tFieldResponseTypes,\n\tFieldRedirectURI,\n\tFieldNonce,\n\tFieldState,\n\tFieldForceApprovalPrompt,\n\tFieldLoggedIn,\n\tFieldClaimsUserID,\n\tFieldClaimsUsername,\n\tFieldClaimsEmail,\n\tFieldClaimsEmailVerified,\n\tFieldClaimsGroups,\n\tFieldClaimsPreferredUsername,\n\tFieldConnectorID,\n\tFieldConnectorData,\n\tFieldExpiry,\n\tFieldCodeChallenge,\n\tFieldCodeChallengeMethod,\n\tFieldHmacKey,\n}\n\n// ValidColumn reports if the column name is valid (part of the table columns).\nfunc ValidColumn(column string) bool {\n\tfor i := range Columns {\n\t\tif column == Columns[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar (\n\t// DefaultClaimsPreferredUsername holds the default value on creation for the \"claims_preferred_username\" field.\n\tDefaultClaimsPreferredUsername string\n\t// DefaultCodeChallenge holds the default value on creation for the \"code_challenge\" field.\n\tDefaultCodeChallenge string\n\t// DefaultCodeChallengeMethod holds the default value on creation for the \"code_challenge_method\" field.\n\tDefaultCodeChallengeMethod string\n\t// IDValidator is a validator for the \"id\" field. It is called by the builders before save.\n\tIDValidator func(string) error\n)\n", "// Code generated by ent, DO NOT EDIT.\n\npackage authrequest\n\nimport (\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql\"\n\t\"github.com/dexidp/dex/storage/ent/db/predicate\"\n)\n\n// ID filters vertices based on their ID field.\nfunc ID(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldID), id))\n\t})\n}\n\n// IDEQ applies the EQ predicate on the ID field.\nfunc IDEQ(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldID), id))\n\t})\n}\n\n// IDNEQ applies the NEQ predicate on the ID field.\nfunc IDNEQ(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldID), id))\n\t})\n}\n\n// IDIn applies the In predicate on the ID field.\nfunc IDIn(ids ...string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldID), v...))\n\t})\n}\n\n// IDNotIn applies the NotIn predicate on the ID field.\nfunc IDNotIn(ids ...string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\tv := make([]interface{}, len(ids))\n\t\tfor i := range v {\n\t\t\tv[i] = ids[i]\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldID), v...))\n\t})\n}\n\n// IDGT applies the GT predicate on the ID field.\nfunc IDGT(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldID), id))\n\t})\n}\n\n// IDGTE applies the GTE predicate on the ID field.\nfunc IDGTE(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldID), id))\n\t})\n}\n\n// IDLT applies the LT predicate on the ID field.\nfunc IDLT(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldID), id))\n\t})\n}\n\n// IDLTE applies the LTE predicate on the ID field.\nfunc IDLTE(id string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldID), id))\n\t})\n}\n\n// ClientID applies equality check predicate on the \"client_id\" field. It's identical to ClientIDEQ.\nfunc ClientID(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClientID), v))\n\t})\n}\n\n// RedirectURI applies equality check predicate on the \"redirect_uri\" field. It's identical to RedirectURIEQ.\nfunc RedirectURI(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// Nonce applies equality check predicate on the \"nonce\" field. It's identical to NonceEQ.\nfunc Nonce(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldNonce), v))\n\t})\n}\n\n// State applies equality check predicate on the \"state\" field. It's identical to StateEQ.\nfunc State(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldState), v))\n\t})\n}\n\n// ForceApprovalPrompt applies equality check predicate on the \"force_approval_prompt\" field. It's identical to ForceApprovalPromptEQ.\nfunc ForceApprovalPrompt(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldForceApprovalPrompt), v))\n\t})\n}\n\n// LoggedIn applies equality check predicate on the \"logged_in\" field. It's identical to LoggedInEQ.\nfunc LoggedIn(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldLoggedIn), v))\n\t})\n}\n\n// ClaimsUserID applies equality check predicate on the \"claims_user_id\" field. It's identical to ClaimsUserIDEQ.\nfunc ClaimsUserID(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUsername applies equality check predicate on the \"claims_username\" field. It's identical to ClaimsUsernameEQ.\nfunc ClaimsUsername(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsEmail applies equality check predicate on the \"claims_email\" field. It's identical to ClaimsEmailEQ.\nfunc ClaimsEmail(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailVerified applies equality check predicate on the \"claims_email_verified\" field. It's identical to ClaimsEmailVerifiedEQ.\nfunc ClaimsEmailVerified(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmailVerified), v))\n\t})\n}\n\n// ClaimsPreferredUsername applies equality check predicate on the \"claims_preferred_username\" field. It's identical to ClaimsPreferredUsernameEQ.\nfunc ClaimsPreferredUsername(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ConnectorID applies equality check predicate on the \"connector_id\" field. It's identical to ConnectorIDEQ.\nfunc ConnectorID(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorData applies equality check predicate on the \"connector_data\" field. It's identical to ConnectorDataEQ.\nfunc ConnectorData(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorData), v))\n\t})\n}\n\n// Expiry applies equality check predicate on the \"expiry\" field. It's identical to ExpiryEQ.\nfunc Expiry(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldExpiry), v))\n\t})\n}\n\n// CodeChallenge applies equality check predicate on the \"code_challenge\" field. It's identical to CodeChallengeEQ.\nfunc CodeChallenge(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeMethod applies equality check predicate on the \"code_challenge_method\" field. It's identical to CodeChallengeMethodEQ.\nfunc CodeChallengeMethod(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// HmacKey applies equality check predicate on the \"hmac_key\" field. It's identical to HmacKeyEQ.\nfunc HmacKey(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldHmacKey), v))\n\t})\n}\n\n// ClientIDEQ applies the EQ predicate on the \"client_id\" field.\nfunc ClientIDEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDNEQ applies the NEQ predicate on the \"client_id\" field.\nfunc ClientIDNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDIn applies the In predicate on the \"client_id\" field.\nfunc ClientIDIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClientID), v...))\n\t})\n}\n\n// ClientIDNotIn applies the NotIn predicate on the \"client_id\" field.\nfunc ClientIDNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClientID), v...))\n\t})\n}\n\n// ClientIDGT applies the GT predicate on the \"client_id\" field.\nfunc ClientIDGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDGTE applies the GTE predicate on the \"client_id\" field.\nfunc ClientIDGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDLT applies the LT predicate on the \"client_id\" field.\nfunc ClientIDLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDLTE applies the LTE predicate on the \"client_id\" field.\nfunc ClientIDLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDContains applies the Contains predicate on the \"client_id\" field.\nfunc ClientIDContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDHasPrefix applies the HasPrefix predicate on the \"client_id\" field.\nfunc ClientIDHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDHasSuffix applies the HasSuffix predicate on the \"client_id\" field.\nfunc ClientIDHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDEqualFold applies the EqualFold predicate on the \"client_id\" field.\nfunc ClientIDEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClientID), v))\n\t})\n}\n\n// ClientIDContainsFold applies the ContainsFold predicate on the \"client_id\" field.\nfunc ClientIDContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClientID), v))\n\t})\n}\n\n// ScopesIsNil applies the IsNil predicate on the \"scopes\" field.\nfunc ScopesIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldScopes)))\n\t})\n}\n\n// ScopesNotNil applies the NotNil predicate on the \"scopes\" field.\nfunc ScopesNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldScopes)))\n\t})\n}\n\n// ResponseTypesIsNil applies the IsNil predicate on the \"response_types\" field.\nfunc ResponseTypesIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldResponseTypes)))\n\t})\n}\n\n// ResponseTypesNotNil applies the NotNil predicate on the \"response_types\" field.\nfunc ResponseTypesNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldResponseTypes)))\n\t})\n}\n\n// RedirectURIEQ applies the EQ predicate on the \"redirect_uri\" field.\nfunc RedirectURIEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURINEQ applies the NEQ predicate on the \"redirect_uri\" field.\nfunc RedirectURINEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIIn applies the In predicate on the \"redirect_uri\" field.\nfunc RedirectURIIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldRedirectURI), v...))\n\t})\n}\n\n// RedirectURINotIn applies the NotIn predicate on the \"redirect_uri\" field.\nfunc RedirectURINotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldRedirectURI), v...))\n\t})\n}\n\n// RedirectURIGT applies the GT predicate on the \"redirect_uri\" field.\nfunc RedirectURIGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIGTE applies the GTE predicate on the \"redirect_uri\" field.\nfunc RedirectURIGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURILT applies the LT predicate on the \"redirect_uri\" field.\nfunc RedirectURILT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURILTE applies the LTE predicate on the \"redirect_uri\" field.\nfunc RedirectURILTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIContains applies the Contains predicate on the \"redirect_uri\" field.\nfunc RedirectURIContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIHasPrefix applies the HasPrefix predicate on the \"redirect_uri\" field.\nfunc RedirectURIHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIHasSuffix applies the HasSuffix predicate on the \"redirect_uri\" field.\nfunc RedirectURIHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIEqualFold applies the EqualFold predicate on the \"redirect_uri\" field.\nfunc RedirectURIEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// RedirectURIContainsFold applies the ContainsFold predicate on the \"redirect_uri\" field.\nfunc RedirectURIContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldRedirectURI), v))\n\t})\n}\n\n// NonceEQ applies the EQ predicate on the \"nonce\" field.\nfunc NonceEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceNEQ applies the NEQ predicate on the \"nonce\" field.\nfunc NonceNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceIn applies the In predicate on the \"nonce\" field.\nfunc NonceIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldNonce), v...))\n\t})\n}\n\n// NonceNotIn applies the NotIn predicate on the \"nonce\" field.\nfunc NonceNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldNonce), v...))\n\t})\n}\n\n// NonceGT applies the GT predicate on the \"nonce\" field.\nfunc NonceGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceGTE applies the GTE predicate on the \"nonce\" field.\nfunc NonceGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceLT applies the LT predicate on the \"nonce\" field.\nfunc NonceLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceLTE applies the LTE predicate on the \"nonce\" field.\nfunc NonceLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceContains applies the Contains predicate on the \"nonce\" field.\nfunc NonceContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceHasPrefix applies the HasPrefix predicate on the \"nonce\" field.\nfunc NonceHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceHasSuffix applies the HasSuffix predicate on the \"nonce\" field.\nfunc NonceHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceEqualFold applies the EqualFold predicate on the \"nonce\" field.\nfunc NonceEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldNonce), v))\n\t})\n}\n\n// NonceContainsFold applies the ContainsFold predicate on the \"nonce\" field.\nfunc NonceContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldNonce), v))\n\t})\n}\n\n// StateEQ applies the EQ predicate on the \"state\" field.\nfunc StateEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldState), v))\n\t})\n}\n\n// StateNEQ applies the NEQ predicate on the \"state\" field.\nfunc StateNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldState), v))\n\t})\n}\n\n// StateIn applies the In predicate on the \"state\" field.\nfunc StateIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldState), v...))\n\t})\n}\n\n// StateNotIn applies the NotIn predicate on the \"state\" field.\nfunc StateNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldState), v...))\n\t})\n}\n\n// StateGT applies the GT predicate on the \"state\" field.\nfunc StateGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldState), v))\n\t})\n}\n\n// StateGTE applies the GTE predicate on the \"state\" field.\nfunc StateGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldState), v))\n\t})\n}\n\n// StateLT applies the LT predicate on the \"state\" field.\nfunc StateLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldState), v))\n\t})\n}\n\n// StateLTE applies the LTE predicate on the \"state\" field.\nfunc StateLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldState), v))\n\t})\n}\n\n// StateContains applies the Contains predicate on the \"state\" field.\nfunc StateContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldState), v))\n\t})\n}\n\n// StateHasPrefix applies the HasPrefix predicate on the \"state\" field.\nfunc StateHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldState), v))\n\t})\n}\n\n// StateHasSuffix applies the HasSuffix predicate on the \"state\" field.\nfunc StateHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldState), v))\n\t})\n}\n\n// StateEqualFold applies the EqualFold predicate on the \"state\" field.\nfunc StateEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldState), v))\n\t})\n}\n\n// StateContainsFold applies the ContainsFold predicate on the \"state\" field.\nfunc StateContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldState), v))\n\t})\n}\n\n// ForceApprovalPromptEQ applies the EQ predicate on the \"force_approval_prompt\" field.\nfunc ForceApprovalPromptEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldForceApprovalPrompt), v))\n\t})\n}\n\n// ForceApprovalPromptNEQ applies the NEQ predicate on the \"force_approval_prompt\" field.\nfunc ForceApprovalPromptNEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldForceApprovalPrompt), v))\n\t})\n}\n\n// LoggedInEQ applies the EQ predicate on the \"logged_in\" field.\nfunc LoggedInEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldLoggedIn), v))\n\t})\n}\n\n// LoggedInNEQ applies the NEQ predicate on the \"logged_in\" field.\nfunc LoggedInNEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldLoggedIn), v))\n\t})\n}\n\n// ClaimsUserIDEQ applies the EQ predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDNEQ applies the NEQ predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDIn applies the In predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsUserID), v...))\n\t})\n}\n\n// ClaimsUserIDNotIn applies the NotIn predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsUserID), v...))\n\t})\n}\n\n// ClaimsUserIDGT applies the GT predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDGTE applies the GTE predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDLT applies the LT predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDLTE applies the LTE predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDContains applies the Contains predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDHasPrefix applies the HasPrefix predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDHasSuffix applies the HasSuffix predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDEqualFold applies the EqualFold predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUserIDContainsFold applies the ContainsFold predicate on the \"claims_user_id\" field.\nfunc ClaimsUserIDContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsUserID), v))\n\t})\n}\n\n// ClaimsUsernameEQ applies the EQ predicate on the \"claims_username\" field.\nfunc ClaimsUsernameEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameNEQ applies the NEQ predicate on the \"claims_username\" field.\nfunc ClaimsUsernameNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameIn applies the In predicate on the \"claims_username\" field.\nfunc ClaimsUsernameIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsUsername), v...))\n\t})\n}\n\n// ClaimsUsernameNotIn applies the NotIn predicate on the \"claims_username\" field.\nfunc ClaimsUsernameNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsUsername), v...))\n\t})\n}\n\n// ClaimsUsernameGT applies the GT predicate on the \"claims_username\" field.\nfunc ClaimsUsernameGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameGTE applies the GTE predicate on the \"claims_username\" field.\nfunc ClaimsUsernameGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameLT applies the LT predicate on the \"claims_username\" field.\nfunc ClaimsUsernameLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameLTE applies the LTE predicate on the \"claims_username\" field.\nfunc ClaimsUsernameLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameContains applies the Contains predicate on the \"claims_username\" field.\nfunc ClaimsUsernameContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameHasPrefix applies the HasPrefix predicate on the \"claims_username\" field.\nfunc ClaimsUsernameHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameHasSuffix applies the HasSuffix predicate on the \"claims_username\" field.\nfunc ClaimsUsernameHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameEqualFold applies the EqualFold predicate on the \"claims_username\" field.\nfunc ClaimsUsernameEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsUsernameContainsFold applies the ContainsFold predicate on the \"claims_username\" field.\nfunc ClaimsUsernameContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsUsername), v))\n\t})\n}\n\n// ClaimsEmailEQ applies the EQ predicate on the \"claims_email\" field.\nfunc ClaimsEmailEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailNEQ applies the NEQ predicate on the \"claims_email\" field.\nfunc ClaimsEmailNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailIn applies the In predicate on the \"claims_email\" field.\nfunc ClaimsEmailIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsEmail), v...))\n\t})\n}\n\n// ClaimsEmailNotIn applies the NotIn predicate on the \"claims_email\" field.\nfunc ClaimsEmailNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsEmail), v...))\n\t})\n}\n\n// ClaimsEmailGT applies the GT predicate on the \"claims_email\" field.\nfunc ClaimsEmailGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailGTE applies the GTE predicate on the \"claims_email\" field.\nfunc ClaimsEmailGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailLT applies the LT predicate on the \"claims_email\" field.\nfunc ClaimsEmailLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailLTE applies the LTE predicate on the \"claims_email\" field.\nfunc ClaimsEmailLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailContains applies the Contains predicate on the \"claims_email\" field.\nfunc ClaimsEmailContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailHasPrefix applies the HasPrefix predicate on the \"claims_email\" field.\nfunc ClaimsEmailHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailHasSuffix applies the HasSuffix predicate on the \"claims_email\" field.\nfunc ClaimsEmailHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailEqualFold applies the EqualFold predicate on the \"claims_email\" field.\nfunc ClaimsEmailEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailContainsFold applies the ContainsFold predicate on the \"claims_email\" field.\nfunc ClaimsEmailContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsEmail), v))\n\t})\n}\n\n// ClaimsEmailVerifiedEQ applies the EQ predicate on the \"claims_email_verified\" field.\nfunc ClaimsEmailVerifiedEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsEmailVerified), v))\n\t})\n}\n\n// ClaimsEmailVerifiedNEQ applies the NEQ predicate on the \"claims_email_verified\" field.\nfunc ClaimsEmailVerifiedNEQ(v bool) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsEmailVerified), v))\n\t})\n}\n\n// ClaimsGroupsIsNil applies the IsNil predicate on the \"claims_groups\" field.\nfunc ClaimsGroupsIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldClaimsGroups)))\n\t})\n}\n\n// ClaimsGroupsNotNil applies the NotNil predicate on the \"claims_groups\" field.\nfunc ClaimsGroupsNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldClaimsGroups)))\n\t})\n}\n\n// ClaimsPreferredUsernameEQ applies the EQ predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameNEQ applies the NEQ predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameIn applies the In predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldClaimsPreferredUsername), v...))\n\t})\n}\n\n// ClaimsPreferredUsernameNotIn applies the NotIn predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldClaimsPreferredUsername), v...))\n\t})\n}\n\n// ClaimsPreferredUsernameGT applies the GT predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameGTE applies the GTE predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameLT applies the LT predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameLTE applies the LTE predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameContains applies the Contains predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameHasPrefix applies the HasPrefix predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameHasSuffix applies the HasSuffix predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameEqualFold applies the EqualFold predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ClaimsPreferredUsernameContainsFold applies the ContainsFold predicate on the \"claims_preferred_username\" field.\nfunc ClaimsPreferredUsernameContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldClaimsPreferredUsername), v))\n\t})\n}\n\n// ConnectorIDEQ applies the EQ predicate on the \"connector_id\" field.\nfunc ConnectorIDEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDNEQ applies the NEQ predicate on the \"connector_id\" field.\nfunc ConnectorIDNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDIn applies the In predicate on the \"connector_id\" field.\nfunc ConnectorIDIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldConnectorID), v...))\n\t})\n}\n\n// ConnectorIDNotIn applies the NotIn predicate on the \"connector_id\" field.\nfunc ConnectorIDNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldConnectorID), v...))\n\t})\n}\n\n// ConnectorIDGT applies the GT predicate on the \"connector_id\" field.\nfunc ConnectorIDGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDGTE applies the GTE predicate on the \"connector_id\" field.\nfunc ConnectorIDGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDLT applies the LT predicate on the \"connector_id\" field.\nfunc ConnectorIDLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDLTE applies the LTE predicate on the \"connector_id\" field.\nfunc ConnectorIDLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDContains applies the Contains predicate on the \"connector_id\" field.\nfunc ConnectorIDContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDHasPrefix applies the HasPrefix predicate on the \"connector_id\" field.\nfunc ConnectorIDHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDHasSuffix applies the HasSuffix predicate on the \"connector_id\" field.\nfunc ConnectorIDHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDEqualFold applies the EqualFold predicate on the \"connector_id\" field.\nfunc ConnectorIDEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorIDContainsFold applies the ContainsFold predicate on the \"connector_id\" field.\nfunc ConnectorIDContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldConnectorID), v))\n\t})\n}\n\n// ConnectorDataEQ applies the EQ predicate on the \"connector_data\" field.\nfunc ConnectorDataEQ(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataNEQ applies the NEQ predicate on the \"connector_data\" field.\nfunc ConnectorDataNEQ(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataIn applies the In predicate on the \"connector_data\" field.\nfunc ConnectorDataIn(vs ...[]byte) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldConnectorData), v...))\n\t})\n}\n\n// ConnectorDataNotIn applies the NotIn predicate on the \"connector_data\" field.\nfunc ConnectorDataNotIn(vs ...[]byte) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldConnectorData), v...))\n\t})\n}\n\n// ConnectorDataGT applies the GT predicate on the \"connector_data\" field.\nfunc ConnectorDataGT(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataGTE applies the GTE predicate on the \"connector_data\" field.\nfunc ConnectorDataGTE(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataLT applies the LT predicate on the \"connector_data\" field.\nfunc ConnectorDataLT(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataLTE applies the LTE predicate on the \"connector_data\" field.\nfunc ConnectorDataLTE(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldConnectorData), v))\n\t})\n}\n\n// ConnectorDataIsNil applies the IsNil predicate on the \"connector_data\" field.\nfunc ConnectorDataIsNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.IsNull(s.C(FieldConnectorData)))\n\t})\n}\n\n// ConnectorDataNotNil applies the NotNil predicate on the \"connector_data\" field.\nfunc ConnectorDataNotNil() predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotNull(s.C(FieldConnectorData)))\n\t})\n}\n\n// ExpiryEQ applies the EQ predicate on the \"expiry\" field.\nfunc ExpiryEQ(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryNEQ applies the NEQ predicate on the \"expiry\" field.\nfunc ExpiryNEQ(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryIn applies the In predicate on the \"expiry\" field.\nfunc ExpiryIn(vs ...time.Time) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldExpiry), v...))\n\t})\n}\n\n// ExpiryNotIn applies the NotIn predicate on the \"expiry\" field.\nfunc ExpiryNotIn(vs ...time.Time) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldExpiry), v...))\n\t})\n}\n\n// ExpiryGT applies the GT predicate on the \"expiry\" field.\nfunc ExpiryGT(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryGTE applies the GTE predicate on the \"expiry\" field.\nfunc ExpiryGTE(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryLT applies the LT predicate on the \"expiry\" field.\nfunc ExpiryLT(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldExpiry), v))\n\t})\n}\n\n// ExpiryLTE applies the LTE predicate on the \"expiry\" field.\nfunc ExpiryLTE(v time.Time) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldExpiry), v))\n\t})\n}\n\n// CodeChallengeEQ applies the EQ predicate on the \"code_challenge\" field.\nfunc CodeChallengeEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeNEQ applies the NEQ predicate on the \"code_challenge\" field.\nfunc CodeChallengeNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeIn applies the In predicate on the \"code_challenge\" field.\nfunc CodeChallengeIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldCodeChallenge), v...))\n\t})\n}\n\n// CodeChallengeNotIn applies the NotIn predicate on the \"code_challenge\" field.\nfunc CodeChallengeNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldCodeChallenge), v...))\n\t})\n}\n\n// CodeChallengeGT applies the GT predicate on the \"code_challenge\" field.\nfunc CodeChallengeGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeGTE applies the GTE predicate on the \"code_challenge\" field.\nfunc CodeChallengeGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeLT applies the LT predicate on the \"code_challenge\" field.\nfunc CodeChallengeLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeLTE applies the LTE predicate on the \"code_challenge\" field.\nfunc CodeChallengeLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeContains applies the Contains predicate on the \"code_challenge\" field.\nfunc CodeChallengeContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeHasPrefix applies the HasPrefix predicate on the \"code_challenge\" field.\nfunc CodeChallengeHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeHasSuffix applies the HasSuffix predicate on the \"code_challenge\" field.\nfunc CodeChallengeHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeEqualFold applies the EqualFold predicate on the \"code_challenge\" field.\nfunc CodeChallengeEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeContainsFold applies the ContainsFold predicate on the \"code_challenge\" field.\nfunc CodeChallengeContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldCodeChallenge), v))\n\t})\n}\n\n// CodeChallengeMethodEQ applies the EQ predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodNEQ applies the NEQ predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodNEQ(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodIn applies the In predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.In(s.C(FieldCodeChallengeMethod), v...))\n\t})\n}\n\n// CodeChallengeMethodNotIn applies the NotIn predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodNotIn(vs ...string) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NotIn(s.C(FieldCodeChallengeMethod), v...))\n\t})\n}\n\n// CodeChallengeMethodGT applies the GT predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodGT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodGTE applies the GTE predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodGTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodLT applies the LT predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodLT(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodLTE applies the LTE predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodLTE(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodContains applies the Contains predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodContains(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.Contains(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodHasPrefix applies the HasPrefix predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodHasPrefix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasPrefix(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodHasSuffix applies the HasSuffix predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodHasSuffix(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.HasSuffix(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodEqualFold applies the EqualFold predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodEqualFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EqualFold(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// CodeChallengeMethodContainsFold applies the ContainsFold predicate on the \"code_challenge_method\" field.\nfunc CodeChallengeMethodContainsFold(v string) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.ContainsFold(s.C(FieldCodeChallengeMethod), v))\n\t})\n}\n\n// HmacKeyEQ applies the EQ predicate on the \"hmac_key\" field.\nfunc HmacKeyEQ(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.EQ(s.C(FieldHmacKey), v))\n\t})\n}\n\n// HmacKeyNEQ applies the NEQ predicate on the \"hmac_key\" field.\nfunc HmacKeyNEQ(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.NEQ(s.C(FieldHmacKey), v))\n\t})\n}\n\n// HmacKeyIn applies the In predicate on the \"hmac_key\" field.\nfunc HmacKeyIn(vs ...[]byte) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.In(s.C(FieldHmacKey), v...))\n\t})\n}\n\n// HmacKeyNotIn applies the NotIn predicate on the \"hmac_key\" field.\nfunc HmacKeyNotIn(vs ...[]byte) predicate.AuthRequest {\n\tv := make([]interface{}, len(vs))\n\tfor i := range v {\n\t\tv[i] = vs[i]\n\t}\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\t// if not arguments were provided, append the FALSE constants,\n\t\t// since we can't apply \"IN ()\". This will make this predicate falsy.\n\t\tif len(v) == 0 {\n\t\t\ts.Where(sql.False())\n\t\t\treturn\n\t\t}\n\t\ts.Where(sql.NotIn(s.C(FieldHmacKey), v...))\n\t})\n}\n\n// HmacKeyGT applies the GT predicate on the \"hmac_key\" field.\nfunc HmacKeyGT(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GT(s.C(FieldHmacKey), v))\n\t})\n}\n\n// HmacKeyGTE applies the GTE predicate on the \"hmac_key\" field.\nfunc HmacKeyGTE(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.GTE(s.C(FieldHmacKey), v))\n\t})\n}\n\n// HmacKeyLT applies the LT predicate on the \"hmac_key\" field.\nfunc HmacKeyLT(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LT(s.C(FieldHmacKey), v))\n\t})\n}\n\n// HmacKeyLTE applies the LTE predicate on the \"hmac_key\" field.\nfunc HmacKeyLTE(v []byte) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts.Where(sql.LTE(s.C(FieldHmacKey), v))\n\t})\n}\n\n// And groups predicates with the AND operator between them.\nfunc And(predicates ...predicate.AuthRequest) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts1 := s.Clone().SetP(nil)\n\t\tfor _, p := range predicates {\n\t\t\tp(s1)\n\t\t}\n\t\ts.Where(s1.P())\n\t})\n}\n\n// Or groups predicates with the OR operator between them.\nfunc Or(predicates ...predicate.AuthRequest) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\ts1 := s.Clone().SetP(nil)\n\t\tfor i, p := range predicates {\n\t\t\tif i > 0 {\n\t\t\t\ts1.Or()\n\t\t\t}\n\t\t\tp(s1)\n\t\t}\n\t\ts.Where(s1.P())\n\t})\n}\n\n// Not applies the not operator on the given predicate.\nfunc Not(p predicate.AuthRequest) predicate.AuthRequest {\n\treturn predicate.AuthRequest(func(s *sql.Selector) {\n\t\tp(s.Not())\n\t})\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql/sqlgraph\"\n\t\"entgo.io/ent/schema/field\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n)\n\n// AuthRequestCreate is the builder for creating a AuthRequest entity.\ntype AuthRequestCreate struct {\n\tconfig\n\tmutation *AuthRequestMutation\n\thooks    []Hook\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (arc *AuthRequestCreate) SetClientID(s string) *AuthRequestCreate {\n\tarc.mutation.SetClientID(s)\n\treturn arc\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (arc *AuthRequestCreate) SetScopes(s []string) *AuthRequestCreate {\n\tarc.mutation.SetScopes(s)\n\treturn arc\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (arc *AuthRequestCreate) SetResponseTypes(s []string) *AuthRequestCreate {\n\tarc.mutation.SetResponseTypes(s)\n\treturn arc\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (arc *AuthRequestCreate) SetRedirectURI(s string) *AuthRequestCreate {\n\tarc.mutation.SetRedirectURI(s)\n\treturn arc\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (arc *AuthRequestCreate) SetNonce(s string) *AuthRequestCreate {\n\tarc.mutation.SetNonce(s)\n\treturn arc\n}\n\n// SetState sets the \"state\" field.\nfunc (arc *AuthRequestCreate) SetState(s string) *AuthRequestCreate {\n\tarc.mutation.SetState(s)\n\treturn arc\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (arc *AuthRequestCreate) SetForceApprovalPrompt(b bool) *AuthRequestCreate {\n\tarc.mutation.SetForceApprovalPrompt(b)\n\treturn arc\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (arc *AuthRequestCreate) SetLoggedIn(b bool) *AuthRequestCreate {\n\tarc.mutation.SetLoggedIn(b)\n\treturn arc\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (arc *AuthRequestCreate) SetClaimsUserID(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsUserID(s)\n\treturn arc\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (arc *AuthRequestCreate) SetClaimsUsername(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsUsername(s)\n\treturn arc\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (arc *AuthRequestCreate) SetClaimsEmail(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsEmail(s)\n\treturn arc\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (arc *AuthRequestCreate) SetClaimsEmailVerified(b bool) *AuthRequestCreate {\n\tarc.mutation.SetClaimsEmailVerified(b)\n\treturn arc\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (arc *AuthRequestCreate) SetClaimsGroups(s []string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsGroups(s)\n\treturn arc\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (arc *AuthRequestCreate) SetClaimsPreferredUsername(s string) *AuthRequestCreate {\n\tarc.mutation.SetClaimsPreferredUsername(s)\n\treturn arc\n}\n\n// SetNillableClaimsPreferredUsername sets the \"claims_preferred_username\" field if the given value is not nil.\nfunc (arc *AuthRequestCreate) SetNillableClaimsPreferredUsername(s *string) *AuthRequestCreate {\n\tif s != nil {\n\t\tarc.SetClaimsPreferredUsername(*s)\n\t}\n\treturn arc\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (arc *AuthRequestCreate) SetConnectorID(s string) *AuthRequestCreate {\n\tarc.mutation.SetConnectorID(s)\n\treturn arc\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (arc *AuthRequestCreate) SetConnectorData(b []byte) *AuthRequestCreate {\n\tarc.mutation.SetConnectorData(b)\n\treturn arc\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (arc *AuthRequestCreate) SetExpiry(t time.Time) *AuthRequestCreate {\n\tarc.mutation.SetExpiry(t)\n\treturn arc\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (arc *AuthRequestCreate) SetCodeChallenge(s string) *AuthRequestCreate {\n\tarc.mutation.SetCodeChallenge(s)\n\treturn arc\n}\n\n// SetNillableCodeChallenge sets the \"code_challenge\" field if the given value is not nil.\nfunc (arc *AuthRequestCreate) SetNillableCodeChallenge(s *string) *AuthRequestCreate {\n\tif s != nil {\n\t\tarc.SetCodeChallenge(*s)\n\t}\n\treturn arc\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (arc *AuthRequestCreate) SetCodeChallengeMethod(s string) *AuthRequestCreate {\n\tarc.mutation.SetCodeChallengeMethod(s)\n\treturn arc\n}\n\n// SetNillableCodeChallengeMethod sets the \"code_challenge_method\" field if the given value is not nil.\nfunc (arc *AuthRequestCreate) SetNillableCodeChallengeMethod(s *string) *AuthRequestCreate {\n\tif s != nil {\n\t\tarc.SetCodeChallengeMethod(*s)\n\t}\n\treturn arc\n}\n\n// SetHmacKey sets the \"hmac_key\" field.\nfunc (arc *AuthRequestCreate) SetHmacKey(b []byte) *AuthRequestCreate {\n\tarc.mutation.SetHmacKey(b)\n\treturn arc\n}\n\n// SetID sets the \"id\" field.\nfunc (arc *AuthRequestCreate) SetID(s string) *AuthRequestCreate {\n\tarc.mutation.SetID(s)\n\treturn arc\n}\n\n// Mutation returns the AuthRequestMutation object of the builder.\nfunc (arc *AuthRequestCreate) Mutation() *AuthRequestMutation {\n\treturn arc.mutation\n}\n\n// Save creates the AuthRequest in the database.\nfunc (arc *AuthRequestCreate) Save(ctx context.Context) (*AuthRequest, error) {\n\tvar (\n\t\terr  error\n\t\tnode *AuthRequest\n\t)\n\tarc.defaults()\n\tif len(arc.hooks) == 0 {\n\t\tif err = arc.check(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnode, err = arc.sqlSave(ctx)\n\t} else {\n\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t}\n\t\t\tif err = arc.check(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tarc.mutation = mutation\n\t\t\tif node, err = arc.sqlSave(ctx); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmutation.id = &node.ID\n\t\t\tmutation.done = true\n\t\t\treturn node, err\n\t\t})\n\t\tfor i := len(arc.hooks) - 1; i >= 0; i-- {\n\t\t\tif arc.hooks[i] == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"db: uninitialized hook (forgotten import db/runtime?)\")\n\t\t\t}\n\t\t\tmut = arc.hooks[i](mut)\n\t\t}\n\t\tv, err := mut.Mutate(ctx, arc.mutation)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnv, ok := v.(*AuthRequest)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected node type %T returned from AuthRequestMutation\", v)\n\t\t}\n\t\tnode = nv\n\t}\n\treturn node, err\n}\n\n// SaveX calls Save and panics if Save returns an error.\nfunc (arc *AuthRequestCreate) SaveX(ctx context.Context) *AuthRequest {\n\tv, err := arc.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}\n\n// Exec executes the query.\nfunc (arc *AuthRequestCreate) Exec(ctx context.Context) error {\n\t_, err := arc.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (arc *AuthRequestCreate) ExecX(ctx context.Context) {\n\tif err := arc.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// defaults sets the default values of the builder before save.\nfunc (arc *AuthRequestCreate) defaults() {\n\tif _, ok := arc.mutation.ClaimsPreferredUsername(); !ok {\n\t\tv := authrequest.DefaultClaimsPreferredUsername\n\t\tarc.mutation.SetClaimsPreferredUsername(v)\n\t}\n\tif _, ok := arc.mutation.CodeChallenge(); !ok {\n\t\tv := authrequest.DefaultCodeChallenge\n\t\tarc.mutation.SetCodeChallenge(v)\n\t}\n\tif _, ok := arc.mutation.CodeChallengeMethod(); !ok {\n\t\tv := authrequest.DefaultCodeChallengeMethod\n\t\tarc.mutation.SetCodeChallengeMethod(v)\n\t}\n}\n\n// check runs all checks and user-defined validators on the builder.\nfunc (arc *AuthRequestCreate) check() error {\n\tif _, ok := arc.mutation.ClientID(); !ok {\n\t\treturn &ValidationError{Name: \"client_id\", err: errors.New(`db: missing required field \"AuthRequest.client_id\"`)}\n\t}\n\tif _, ok := arc.mutation.RedirectURI(); !ok {\n\t\treturn &ValidationError{Name: \"redirect_uri\", err: errors.New(`db: missing required field \"AuthRequest.redirect_uri\"`)}\n\t}\n\tif _, ok := arc.mutation.Nonce(); !ok {\n\t\treturn &ValidationError{Name: \"nonce\", err: errors.New(`db: missing required field \"AuthRequest.nonce\"`)}\n\t}\n\tif _, ok := arc.mutation.State(); !ok {\n\t\treturn &ValidationError{Name: \"state\", err: errors.New(`db: missing required field \"AuthRequest.state\"`)}\n\t}\n\tif _, ok := arc.mutation.ForceApprovalPrompt(); !ok {\n\t\treturn &ValidationError{Name: \"force_approval_prompt\", err: errors.New(`db: missing required field \"AuthRequest.force_approval_prompt\"`)}\n\t}\n\tif _, ok := arc.mutation.LoggedIn(); !ok {\n\t\treturn &ValidationError{Name: \"logged_in\", err: errors.New(`db: missing required field \"AuthRequest.logged_in\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsUserID(); !ok {\n\t\treturn &ValidationError{Name: \"claims_user_id\", err: errors.New(`db: missing required field \"AuthRequest.claims_user_id\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsUsername(); !ok {\n\t\treturn &ValidationError{Name: \"claims_username\", err: errors.New(`db: missing required field \"AuthRequest.claims_username\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsEmail(); !ok {\n\t\treturn &ValidationError{Name: \"claims_email\", err: errors.New(`db: missing required field \"AuthRequest.claims_email\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsEmailVerified(); !ok {\n\t\treturn &ValidationError{Name: \"claims_email_verified\", err: errors.New(`db: missing required field \"AuthRequest.claims_email_verified\"`)}\n\t}\n\tif _, ok := arc.mutation.ClaimsPreferredUsername(); !ok {\n\t\treturn &ValidationError{Name: \"claims_preferred_username\", err: errors.New(`db: missing required field \"AuthRequest.claims_preferred_username\"`)}\n\t}\n\tif _, ok := arc.mutation.ConnectorID(); !ok {\n\t\treturn &ValidationError{Name: \"connector_id\", err: errors.New(`db: missing required field \"AuthRequest.connector_id\"`)}\n\t}\n\tif _, ok := arc.mutation.Expiry(); !ok {\n\t\treturn &ValidationError{Name: \"expiry\", err: errors.New(`db: missing required field \"AuthRequest.expiry\"`)}\n\t}\n\tif _, ok := arc.mutation.CodeChallenge(); !ok {\n\t\treturn &ValidationError{Name: \"code_challenge\", err: errors.New(`db: missing required field \"AuthRequest.code_challenge\"`)}\n\t}\n\tif _, ok := arc.mutation.CodeChallengeMethod(); !ok {\n\t\treturn &ValidationError{Name: \"code_challenge_method\", err: errors.New(`db: missing required field \"AuthRequest.code_challenge_method\"`)}\n\t}\n\tif _, ok := arc.mutation.HmacKey(); !ok {\n\t\treturn &ValidationError{Name: \"hmac_key\", err: errors.New(`db: missing required field \"AuthRequest.hmac_key\"`)}\n\t}\n\tif v, ok := arc.mutation.ID(); ok {\n\t\tif err := authrequest.IDValidator(v); err != nil {\n\t\t\treturn &ValidationError{Name: \"id\", err: fmt.Errorf(`db: validator failed for field \"AuthRequest.id\": %w`, err)}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (arc *AuthRequestCreate) sqlSave(ctx context.Context) (*AuthRequest, error) {\n\t_node, _spec := arc.createSpec()\n\tif err := sqlgraph.CreateNode(ctx, arc.driver, _spec); err != nil {\n\t\tif sqlgraph.IsConstraintError(err) {\n\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t}\n\t\treturn nil, err\n\t}\n\tif _spec.ID.Value != nil {\n\t\tif id, ok := _spec.ID.Value.(string); ok {\n\t\t\t_node.ID = id\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"unexpected AuthRequest.ID type: %T\", _spec.ID.Value)\n\t\t}\n\t}\n\treturn _node, nil\n}\n\nfunc (arc *AuthRequestCreate) createSpec() (*AuthRequest, *sqlgraph.CreateSpec) {\n\tvar (\n\t\t_node = &AuthRequest{config: arc.config}\n\t\t_spec = &sqlgraph.CreateSpec{\n\t\t\tTable: authrequest.Table,\n\t\t\tID: &sqlgraph.FieldSpec{\n\t\t\t\tType:   field.TypeString,\n\t\t\t\tColumn: authrequest.FieldID,\n\t\t\t},\n\t\t}\n\t)\n\tif id, ok := arc.mutation.ID(); ok {\n\t\t_node.ID = id\n\t\t_spec.ID.Value = id\n\t}\n\tif value, ok := arc.mutation.ClientID(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClientID,\n\t\t})\n\t\t_node.ClientID = value\n\t}\n\tif value, ok := arc.mutation.Scopes(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t\t_node.Scopes = value\n\t}\n\tif value, ok := arc.mutation.ResponseTypes(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t\t_node.ResponseTypes = value\n\t}\n\tif value, ok := arc.mutation.RedirectURI(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldRedirectURI,\n\t\t})\n\t\t_node.RedirectURI = value\n\t}\n\tif value, ok := arc.mutation.Nonce(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldNonce,\n\t\t})\n\t\t_node.Nonce = value\n\t}\n\tif value, ok := arc.mutation.State(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldState,\n\t\t})\n\t\t_node.State = value\n\t}\n\tif value, ok := arc.mutation.ForceApprovalPrompt(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldForceApprovalPrompt,\n\t\t})\n\t\t_node.ForceApprovalPrompt = value\n\t}\n\tif value, ok := arc.mutation.LoggedIn(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldLoggedIn,\n\t\t})\n\t\t_node.LoggedIn = value\n\t}\n\tif value, ok := arc.mutation.ClaimsUserID(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUserID,\n\t\t})\n\t\t_node.ClaimsUserID = value\n\t}\n\tif value, ok := arc.mutation.ClaimsUsername(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUsername,\n\t\t})\n\t\t_node.ClaimsUsername = value\n\t}\n\tif value, ok := arc.mutation.ClaimsEmail(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmail,\n\t\t})\n\t\t_node.ClaimsEmail = value\n\t}\n\tif value, ok := arc.mutation.ClaimsEmailVerified(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmailVerified,\n\t\t})\n\t\t_node.ClaimsEmailVerified = value\n\t}\n\tif value, ok := arc.mutation.ClaimsGroups(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t\t_node.ClaimsGroups = value\n\t}\n\tif value, ok := arc.mutation.ClaimsPreferredUsername(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsPreferredUsername,\n\t\t})\n\t\t_node.ClaimsPreferredUsername = value\n\t}\n\tif value, ok := arc.mutation.ConnectorID(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorID,\n\t\t})\n\t\t_node.ConnectorID = value\n\t}\n\tif value, ok := arc.mutation.ConnectorData(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t\t_node.ConnectorData = &value\n\t}\n\tif value, ok := arc.mutation.Expiry(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeTime,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldExpiry,\n\t\t})\n\t\t_node.Expiry = value\n\t}\n\tif value, ok := arc.mutation.CodeChallenge(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallenge,\n\t\t})\n\t\t_node.CodeChallenge = value\n\t}\n\tif value, ok := arc.mutation.CodeChallengeMethod(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallengeMethod,\n\t\t})\n\t\t_node.CodeChallengeMethod = value\n\t}\n\tif value, ok := arc.mutation.HmacKey(); ok {\n\t\t_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldHmacKey,\n\t\t})\n\t\t_node.HmacKey = value\n\t}\n\treturn _node, _spec\n}\n\n// AuthRequestCreateBulk is the builder for creating many AuthRequest entities in bulk.\ntype AuthRequestCreateBulk struct {\n\tconfig\n\tbuilders []*AuthRequestCreate\n}\n\n// Save creates the AuthRequest entities in the database.\nfunc (arcb *AuthRequestCreateBulk) Save(ctx context.Context) ([]*AuthRequest, error) {\n\tspecs := make([]*sqlgraph.CreateSpec, len(arcb.builders))\n\tnodes := make([]*AuthRequest, len(arcb.builders))\n\tmutators := make([]Mutator, len(arcb.builders))\n\tfor i := range arcb.builders {\n\t\tfunc(i int, root context.Context) {\n\t\t\tbuilder := arcb.builders[i]\n\t\t\tbuilder.defaults()\n\t\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t\t}\n\t\t\t\tif err := builder.check(); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tbuilder.mutation = mutation\n\t\t\t\tnodes[i], specs[i] = builder.createSpec()\n\t\t\t\tvar err error\n\t\t\t\tif i < len(mutators)-1 {\n\t\t\t\t\t_, err = mutators[i+1].Mutate(root, arcb.builders[i+1].mutation)\n\t\t\t\t} else {\n\t\t\t\t\tspec := &sqlgraph.BatchCreateSpec{Nodes: specs}\n\t\t\t\t\t// Invoke the actual operation on the latest mutation in the chain.\n\t\t\t\t\tif err = sqlgraph.BatchCreate(ctx, arcb.driver, spec); err != nil {\n\t\t\t\t\t\tif sqlgraph.IsConstraintError(err) {\n\t\t\t\t\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tmutation.id = &nodes[i].ID\n\t\t\t\tmutation.done = true\n\t\t\t\treturn nodes[i], nil\n\t\t\t})\n\t\t\tfor i := len(builder.hooks) - 1; i >= 0; i-- {\n\t\t\t\tmut = builder.hooks[i](mut)\n\t\t\t}\n\t\t\tmutators[i] = mut\n\t\t}(i, ctx)\n\t}\n\tif len(mutators) > 0 {\n\t\tif _, err := mutators[0].Mutate(ctx, arcb.builders[0].mutation); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nodes, nil\n}\n\n// SaveX is like Save, but panics if an error occurs.\nfunc (arcb *AuthRequestCreateBulk) SaveX(ctx context.Context) []*AuthRequest {\n\tv, err := arcb.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}\n\n// Exec executes the query.\nfunc (arcb *AuthRequestCreateBulk) Exec(ctx context.Context) error {\n\t_, err := arcb.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (arcb *AuthRequestCreateBulk) ExecX(ctx context.Context) {\n\tif err := arcb.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"entgo.io/ent/dialect/sql\"\n\t\"entgo.io/ent/dialect/sql/sqlgraph\"\n\t\"entgo.io/ent/schema/field\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n\t\"github.com/dexidp/dex/storage/ent/db/predicate\"\n)\n\n// AuthRequestUpdate is the builder for updating AuthRequest entities.\ntype AuthRequestUpdate struct {\n\tconfig\n\thooks    []Hook\n\tmutation *AuthRequestMutation\n}\n\n// Where appends a list predicates to the AuthRequestUpdate builder.\nfunc (aru *AuthRequestUpdate) Where(ps ...predicate.AuthRequest) *AuthRequestUpdate {\n\taru.mutation.Where(ps...)\n\treturn aru\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (aru *AuthRequestUpdate) SetClientID(s string) *AuthRequestUpdate {\n\taru.mutation.SetClientID(s)\n\treturn aru\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (aru *AuthRequestUpdate) SetScopes(s []string) *AuthRequestUpdate {\n\taru.mutation.SetScopes(s)\n\treturn aru\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (aru *AuthRequestUpdate) ClearScopes() *AuthRequestUpdate {\n\taru.mutation.ClearScopes()\n\treturn aru\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (aru *AuthRequestUpdate) SetResponseTypes(s []string) *AuthRequestUpdate {\n\taru.mutation.SetResponseTypes(s)\n\treturn aru\n}\n\n// ClearResponseTypes clears the value of the \"response_types\" field.\nfunc (aru *AuthRequestUpdate) ClearResponseTypes() *AuthRequestUpdate {\n\taru.mutation.ClearResponseTypes()\n\treturn aru\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (aru *AuthRequestUpdate) SetRedirectURI(s string) *AuthRequestUpdate {\n\taru.mutation.SetRedirectURI(s)\n\treturn aru\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (aru *AuthRequestUpdate) SetNonce(s string) *AuthRequestUpdate {\n\taru.mutation.SetNonce(s)\n\treturn aru\n}\n\n// SetState sets the \"state\" field.\nfunc (aru *AuthRequestUpdate) SetState(s string) *AuthRequestUpdate {\n\taru.mutation.SetState(s)\n\treturn aru\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (aru *AuthRequestUpdate) SetForceApprovalPrompt(b bool) *AuthRequestUpdate {\n\taru.mutation.SetForceApprovalPrompt(b)\n\treturn aru\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (aru *AuthRequestUpdate) SetLoggedIn(b bool) *AuthRequestUpdate {\n\taru.mutation.SetLoggedIn(b)\n\treturn aru\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsUserID(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsUserID(s)\n\treturn aru\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsUsername(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsUsername(s)\n\treturn aru\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsEmail(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsEmail(s)\n\treturn aru\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsEmailVerified(b bool) *AuthRequestUpdate {\n\taru.mutation.SetClaimsEmailVerified(b)\n\treturn aru\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsGroups(s []string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsGroups(s)\n\treturn aru\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (aru *AuthRequestUpdate) ClearClaimsGroups() *AuthRequestUpdate {\n\taru.mutation.ClearClaimsGroups()\n\treturn aru\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (aru *AuthRequestUpdate) SetClaimsPreferredUsername(s string) *AuthRequestUpdate {\n\taru.mutation.SetClaimsPreferredUsername(s)\n\treturn aru\n}\n\n// SetNillableClaimsPreferredUsername sets the \"claims_preferred_username\" field if the given value is not nil.\nfunc (aru *AuthRequestUpdate) SetNillableClaimsPreferredUsername(s *string) *AuthRequestUpdate {\n\tif s != nil {\n\t\taru.SetClaimsPreferredUsername(*s)\n\t}\n\treturn aru\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (aru *AuthRequestUpdate) SetConnectorID(s string) *AuthRequestUpdate {\n\taru.mutation.SetConnectorID(s)\n\treturn aru\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (aru *AuthRequestUpdate) SetConnectorData(b []byte) *AuthRequestUpdate {\n\taru.mutation.SetConnectorData(b)\n\treturn aru\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (aru *AuthRequestUpdate) ClearConnectorData() *AuthRequestUpdate {\n\taru.mutation.ClearConnectorData()\n\treturn aru\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (aru *AuthRequestUpdate) SetExpiry(t time.Time) *AuthRequestUpdate {\n\taru.mutation.SetExpiry(t)\n\treturn aru\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (aru *AuthRequestUpdate) SetCodeChallenge(s string) *AuthRequestUpdate {\n\taru.mutation.SetCodeChallenge(s)\n\treturn aru\n}\n\n// SetNillableCodeChallenge sets the \"code_challenge\" field if the given value is not nil.\nfunc (aru *AuthRequestUpdate) SetNillableCodeChallenge(s *string) *AuthRequestUpdate {\n\tif s != nil {\n\t\taru.SetCodeChallenge(*s)\n\t}\n\treturn aru\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (aru *AuthRequestUpdate) SetCodeChallengeMethod(s string) *AuthRequestUpdate {\n\taru.mutation.SetCodeChallengeMethod(s)\n\treturn aru\n}\n\n// SetNillableCodeChallengeMethod sets the \"code_challenge_method\" field if the given value is not nil.\nfunc (aru *AuthRequestUpdate) SetNillableCodeChallengeMethod(s *string) *AuthRequestUpdate {\n\tif s != nil {\n\t\taru.SetCodeChallengeMethod(*s)\n\t}\n\treturn aru\n}\n\n// SetHmacKey sets the \"hmac_key\" field.\nfunc (aru *AuthRequestUpdate) SetHmacKey(b []byte) *AuthRequestUpdate {\n\taru.mutation.SetHmacKey(b)\n\treturn aru\n}\n\n// Mutation returns the AuthRequestMutation object of the builder.\nfunc (aru *AuthRequestUpdate) Mutation() *AuthRequestMutation {\n\treturn aru.mutation\n}\n\n// Save executes the query and returns the number of nodes affected by the update operation.\nfunc (aru *AuthRequestUpdate) Save(ctx context.Context) (int, error) {\n\tvar (\n\t\terr      error\n\t\taffected int\n\t)\n\tif len(aru.hooks) == 0 {\n\t\taffected, err = aru.sqlSave(ctx)\n\t} else {\n\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t}\n\t\t\taru.mutation = mutation\n\t\t\taffected, err = aru.sqlSave(ctx)\n\t\t\tmutation.done = true\n\t\t\treturn affected, err\n\t\t})\n\t\tfor i := len(aru.hooks) - 1; i >= 0; i-- {\n\t\t\tif aru.hooks[i] == nil {\n\t\t\t\treturn 0, fmt.Errorf(\"db: uninitialized hook (forgotten import db/runtime?)\")\n\t\t\t}\n\t\t\tmut = aru.hooks[i](mut)\n\t\t}\n\t\tif _, err := mut.Mutate(ctx, aru.mutation); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn affected, err\n}\n\n// SaveX is like Save, but panics if an error occurs.\nfunc (aru *AuthRequestUpdate) SaveX(ctx context.Context) int {\n\taffected, err := aru.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn affected\n}\n\n// Exec executes the query.\nfunc (aru *AuthRequestUpdate) Exec(ctx context.Context) error {\n\t_, err := aru.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (aru *AuthRequestUpdate) ExecX(ctx context.Context) {\n\tif err := aru.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (aru *AuthRequestUpdate) sqlSave(ctx context.Context) (n int, err error) {\n\t_spec := &sqlgraph.UpdateSpec{\n\t\tNode: &sqlgraph.NodeSpec{\n\t\t\tTable:   authrequest.Table,\n\t\t\tColumns: authrequest.Columns,\n\t\t\tID: &sqlgraph.FieldSpec{\n\t\t\t\tType:   field.TypeString,\n\t\t\t\tColumn: authrequest.FieldID,\n\t\t\t},\n\t\t},\n\t}\n\tif ps := aru.mutation.predicates; len(ps) > 0 {\n\t\t_spec.Predicate = func(selector *sql.Selector) {\n\t\t\tfor i := range ps {\n\t\t\t\tps[i](selector)\n\t\t\t}\n\t\t}\n\t}\n\tif value, ok := aru.mutation.ClientID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClientID,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.Scopes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif aru.mutation.ScopesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ResponseTypes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif aru.mutation.ResponseTypesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.RedirectURI(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldRedirectURI,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.Nonce(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldNonce,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.State(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldState,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ForceApprovalPrompt(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldForceApprovalPrompt,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.LoggedIn(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldLoggedIn,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsUserID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUserID,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUsername,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsEmail(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmail,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsEmailVerified(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmailVerified,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsGroups(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif aru.mutation.ClaimsGroupsCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ClaimsPreferredUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsPreferredUsername,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ConnectorID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorID,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.ConnectorData(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif aru.mutation.ConnectorDataCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.Expiry(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeTime,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldExpiry,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.CodeChallenge(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallenge,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.CodeChallengeMethod(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallengeMethod,\n\t\t})\n\t}\n\tif value, ok := aru.mutation.HmacKey(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldHmacKey,\n\t\t})\n\t}\n\tif n, err = sqlgraph.UpdateNodes(ctx, aru.driver, _spec); err != nil {\n\t\tif _, ok := err.(*sqlgraph.NotFoundError); ok {\n\t\t\terr = &NotFoundError{authrequest.Label}\n\t\t} else if sqlgraph.IsConstraintError(err) {\n\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t}\n\t\treturn 0, err\n\t}\n\treturn n, nil\n}\n\n// AuthRequestUpdateOne is the builder for updating a single AuthRequest entity.\ntype AuthRequestUpdateOne struct {\n\tconfig\n\tfields   []string\n\thooks    []Hook\n\tmutation *AuthRequestMutation\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClientID(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClientID(s)\n\treturn aruo\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (aruo *AuthRequestUpdateOne) SetScopes(s []string) *AuthRequestUpdateOne {\n\taruo.mutation.SetScopes(s)\n\treturn aruo\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearScopes() *AuthRequestUpdateOne {\n\taruo.mutation.ClearScopes()\n\treturn aruo\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (aruo *AuthRequestUpdateOne) SetResponseTypes(s []string) *AuthRequestUpdateOne {\n\taruo.mutation.SetResponseTypes(s)\n\treturn aruo\n}\n\n// ClearResponseTypes clears the value of the \"response_types\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearResponseTypes() *AuthRequestUpdateOne {\n\taruo.mutation.ClearResponseTypes()\n\treturn aruo\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (aruo *AuthRequestUpdateOne) SetRedirectURI(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetRedirectURI(s)\n\treturn aruo\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (aruo *AuthRequestUpdateOne) SetNonce(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetNonce(s)\n\treturn aruo\n}\n\n// SetState sets the \"state\" field.\nfunc (aruo *AuthRequestUpdateOne) SetState(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetState(s)\n\treturn aruo\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (aruo *AuthRequestUpdateOne) SetForceApprovalPrompt(b bool) *AuthRequestUpdateOne {\n\taruo.mutation.SetForceApprovalPrompt(b)\n\treturn aruo\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (aruo *AuthRequestUpdateOne) SetLoggedIn(b bool) *AuthRequestUpdateOne {\n\taruo.mutation.SetLoggedIn(b)\n\treturn aruo\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsUserID(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsUserID(s)\n\treturn aruo\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsUsername(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsUsername(s)\n\treturn aruo\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsEmail(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsEmail(s)\n\treturn aruo\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsEmailVerified(b bool) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsEmailVerified(b)\n\treturn aruo\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsGroups(s []string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsGroups(s)\n\treturn aruo\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearClaimsGroups() *AuthRequestUpdateOne {\n\taruo.mutation.ClearClaimsGroups()\n\treturn aruo\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (aruo *AuthRequestUpdateOne) SetClaimsPreferredUsername(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetClaimsPreferredUsername(s)\n\treturn aruo\n}\n\n// SetNillableClaimsPreferredUsername sets the \"claims_preferred_username\" field if the given value is not nil.\nfunc (aruo *AuthRequestUpdateOne) SetNillableClaimsPreferredUsername(s *string) *AuthRequestUpdateOne {\n\tif s != nil {\n\t\taruo.SetClaimsPreferredUsername(*s)\n\t}\n\treturn aruo\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (aruo *AuthRequestUpdateOne) SetConnectorID(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetConnectorID(s)\n\treturn aruo\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (aruo *AuthRequestUpdateOne) SetConnectorData(b []byte) *AuthRequestUpdateOne {\n\taruo.mutation.SetConnectorData(b)\n\treturn aruo\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (aruo *AuthRequestUpdateOne) ClearConnectorData() *AuthRequestUpdateOne {\n\taruo.mutation.ClearConnectorData()\n\treturn aruo\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (aruo *AuthRequestUpdateOne) SetExpiry(t time.Time) *AuthRequestUpdateOne {\n\taruo.mutation.SetExpiry(t)\n\treturn aruo\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (aruo *AuthRequestUpdateOne) SetCodeChallenge(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetCodeChallenge(s)\n\treturn aruo\n}\n\n// SetNillableCodeChallenge sets the \"code_challenge\" field if the given value is not nil.\nfunc (aruo *AuthRequestUpdateOne) SetNillableCodeChallenge(s *string) *AuthRequestUpdateOne {\n\tif s != nil {\n\t\taruo.SetCodeChallenge(*s)\n\t}\n\treturn aruo\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (aruo *AuthRequestUpdateOne) SetCodeChallengeMethod(s string) *AuthRequestUpdateOne {\n\taruo.mutation.SetCodeChallengeMethod(s)\n\treturn aruo\n}\n\n// SetNillableCodeChallengeMethod sets the \"code_challenge_method\" field if the given value is not nil.\nfunc (aruo *AuthRequestUpdateOne) SetNillableCodeChallengeMethod(s *string) *AuthRequestUpdateOne {\n\tif s != nil {\n\t\taruo.SetCodeChallengeMethod(*s)\n\t}\n\treturn aruo\n}\n\n// SetHmacKey sets the \"hmac_key\" field.\nfunc (aruo *AuthRequestUpdateOne) SetHmacKey(b []byte) *AuthRequestUpdateOne {\n\taruo.mutation.SetHmacKey(b)\n\treturn aruo\n}\n\n// Mutation returns the AuthRequestMutation object of the builder.\nfunc (aruo *AuthRequestUpdateOne) Mutation() *AuthRequestMutation {\n\treturn aruo.mutation\n}\n\n// Select allows selecting one or more fields (columns) of the returned entity.\n// The default is selecting all fields defined in the entity schema.\nfunc (aruo *AuthRequestUpdateOne) Select(field string, fields ...string) *AuthRequestUpdateOne {\n\taruo.fields = append([]string{field}, fields...)\n\treturn aruo\n}\n\n// Save executes the query and returns the updated AuthRequest entity.\nfunc (aruo *AuthRequestUpdateOne) Save(ctx context.Context) (*AuthRequest, error) {\n\tvar (\n\t\terr  error\n\t\tnode *AuthRequest\n\t)\n\tif len(aruo.hooks) == 0 {\n\t\tnode, err = aruo.sqlSave(ctx)\n\t} else {\n\t\tvar mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {\n\t\t\tmutation, ok := m.(*AuthRequestMutation)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t}\n\t\t\taruo.mutation = mutation\n\t\t\tnode, err = aruo.sqlSave(ctx)\n\t\t\tmutation.done = true\n\t\t\treturn node, err\n\t\t})\n\t\tfor i := len(aruo.hooks) - 1; i >= 0; i-- {\n\t\t\tif aruo.hooks[i] == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"db: uninitialized hook (forgotten import db/runtime?)\")\n\t\t\t}\n\t\t\tmut = aruo.hooks[i](mut)\n\t\t}\n\t\tv, err := mut.Mutate(ctx, aruo.mutation)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnv, ok := v.(*AuthRequest)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"unexpected node type %T returned from AuthRequestMutation\", v)\n\t\t}\n\t\tnode = nv\n\t}\n\treturn node, err\n}\n\n// SaveX is like Save, but panics if an error occurs.\nfunc (aruo *AuthRequestUpdateOne) SaveX(ctx context.Context) *AuthRequest {\n\tnode, err := aruo.Save(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn node\n}\n\n// Exec executes the query on the entity.\nfunc (aruo *AuthRequestUpdateOne) Exec(ctx context.Context) error {\n\t_, err := aruo.Save(ctx)\n\treturn err\n}\n\n// ExecX is like Exec, but panics if an error occurs.\nfunc (aruo *AuthRequestUpdateOne) ExecX(ctx context.Context) {\n\tif err := aruo.Exec(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (aruo *AuthRequestUpdateOne) sqlSave(ctx context.Context) (_node *AuthRequest, err error) {\n\t_spec := &sqlgraph.UpdateSpec{\n\t\tNode: &sqlgraph.NodeSpec{\n\t\t\tTable:   authrequest.Table,\n\t\t\tColumns: authrequest.Columns,\n\t\t\tID: &sqlgraph.FieldSpec{\n\t\t\t\tType:   field.TypeString,\n\t\t\t\tColumn: authrequest.FieldID,\n\t\t\t},\n\t\t},\n\t}\n\tid, ok := aruo.mutation.ID()\n\tif !ok {\n\t\treturn nil, &ValidationError{Name: \"id\", err: errors.New(`db: missing \"AuthRequest.id\" for update`)}\n\t}\n\t_spec.Node.ID.Value = id\n\tif fields := aruo.fields; len(fields) > 0 {\n\t\t_spec.Node.Columns = make([]string, 0, len(fields))\n\t\t_spec.Node.Columns = append(_spec.Node.Columns, authrequest.FieldID)\n\t\tfor _, f := range fields {\n\t\t\tif !authrequest.ValidColumn(f) {\n\t\t\t\treturn nil, &ValidationError{Name: f, err: fmt.Errorf(\"db: invalid field %q for query\", f)}\n\t\t\t}\n\t\t\tif f != authrequest.FieldID {\n\t\t\t\t_spec.Node.Columns = append(_spec.Node.Columns, f)\n\t\t\t}\n\t\t}\n\t}\n\tif ps := aruo.mutation.predicates; len(ps) > 0 {\n\t\t_spec.Predicate = func(selector *sql.Selector) {\n\t\t\tfor i := range ps {\n\t\t\t\tps[i](selector)\n\t\t\t}\n\t\t}\n\t}\n\tif value, ok := aruo.mutation.ClientID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClientID,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.Scopes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif aruo.mutation.ScopesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldScopes,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ResponseTypes(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif aruo.mutation.ResponseTypesCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldResponseTypes,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.RedirectURI(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldRedirectURI,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.Nonce(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldNonce,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.State(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldState,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ForceApprovalPrompt(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldForceApprovalPrompt,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.LoggedIn(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldLoggedIn,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsUserID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUserID,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsUsername,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsEmail(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmail,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsEmailVerified(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBool,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsEmailVerified,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsGroups(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif aruo.mutation.ClaimsGroupsCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeJSON,\n\t\t\tColumn: authrequest.FieldClaimsGroups,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ClaimsPreferredUsername(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldClaimsPreferredUsername,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ConnectorID(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorID,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.ConnectorData(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif aruo.mutation.ConnectorDataCleared() {\n\t\t_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tColumn: authrequest.FieldConnectorData,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.Expiry(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeTime,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldExpiry,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.CodeChallenge(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallenge,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.CodeChallengeMethod(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeString,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldCodeChallengeMethod,\n\t\t})\n\t}\n\tif value, ok := aruo.mutation.HmacKey(); ok {\n\t\t_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{\n\t\t\tType:   field.TypeBytes,\n\t\t\tValue:  value,\n\t\t\tColumn: authrequest.FieldHmacKey,\n\t\t})\n\t}\n\t_node = &AuthRequest{config: aruo.config}\n\t_spec.Assign = _node.assignValues\n\t_spec.ScanValues = _node.scanValues\n\tif err = sqlgraph.UpdateNode(ctx, aruo.driver, _spec); err != nil {\n\t\tif _, ok := err.(*sqlgraph.NotFoundError); ok {\n\t\t\terr = &NotFoundError{authrequest.Label}\n\t\t} else if sqlgraph.IsConstraintError(err) {\n\t\t\terr = &ConstraintError{msg: err.Error(), wrap: err}\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn _node, nil\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage migrate\n\nimport (\n\t\"entgo.io/ent/dialect/sql/schema\"\n\t\"entgo.io/ent/schema/field\"\n)\n\nvar (\n\t// AuthCodesColumns holds the columns for the \"auth_codes\" table.\n\tAuthCodesColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"nonce\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"redirect_uri\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email_verified\", Type: field.TypeBool},\n\t\t{Name: \"claims_groups\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"claims_preferred_username\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"code_challenge\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"code_challenge_method\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// AuthCodesTable holds the schema information for the \"auth_codes\" table.\n\tAuthCodesTable = &schema.Table{\n\t\tName:       \"auth_codes\",\n\t\tColumns:    AuthCodesColumns,\n\t\tPrimaryKey: []*schema.Column{AuthCodesColumns[0]},\n\t}\n\t// AuthRequestsColumns holds the columns for the \"auth_requests\" table.\n\tAuthRequestsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"response_types\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"redirect_uri\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"nonce\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"state\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"force_approval_prompt\", Type: field.TypeBool},\n\t\t{Name: \"logged_in\", Type: field.TypeBool},\n\t\t{Name: \"claims_user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email_verified\", Type: field.TypeBool},\n\t\t{Name: \"claims_groups\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"claims_preferred_username\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"code_challenge\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"code_challenge_method\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"hmac_key\", Type: field.TypeBytes},\n\t}\n\t// AuthRequestsTable holds the schema information for the \"auth_requests\" table.\n\tAuthRequestsTable = &schema.Table{\n\t\tName:       \"auth_requests\",\n\t\tColumns:    AuthRequestsColumns,\n\t\tPrimaryKey: []*schema.Column{AuthRequestsColumns[0]},\n\t}\n\t// ConnectorsColumns holds the columns for the \"connectors\" table.\n\tConnectorsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 100, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"type\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"name\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"resource_version\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"config\", Type: field.TypeBytes},\n\t}\n\t// ConnectorsTable holds the schema information for the \"connectors\" table.\n\tConnectorsTable = &schema.Table{\n\t\tName:       \"connectors\",\n\t\tColumns:    ConnectorsColumns,\n\t\tPrimaryKey: []*schema.Column{ConnectorsColumns[0]},\n\t}\n\t// DeviceRequestsColumns holds the columns for the \"device_requests\" table.\n\tDeviceRequestsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeInt, Increment: true},\n\t\t{Name: \"user_code\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"device_code\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_secret\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t}\n\t// DeviceRequestsTable holds the schema information for the \"device_requests\" table.\n\tDeviceRequestsTable = &schema.Table{\n\t\tName:       \"device_requests\",\n\t\tColumns:    DeviceRequestsColumns,\n\t\tPrimaryKey: []*schema.Column{DeviceRequestsColumns[0]},\n\t}\n\t// DeviceTokensColumns holds the columns for the \"device_tokens\" table.\n\tDeviceTokensColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeInt, Increment: true},\n\t\t{Name: \"device_code\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"status\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"token\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"expiry\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"last_request\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"poll_interval\", Type: field.TypeInt},\n\t\t{Name: \"code_challenge\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"code_challenge_method\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// DeviceTokensTable holds the schema information for the \"device_tokens\" table.\n\tDeviceTokensTable = &schema.Table{\n\t\tName:       \"device_tokens\",\n\t\tColumns:    DeviceTokensColumns,\n\t\tPrimaryKey: []*schema.Column{DeviceTokensColumns[0]},\n\t}\n\t// KeysColumns holds the columns for the \"keys\" table.\n\tKeysColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"verification_keys\", Type: field.TypeJSON},\n\t\t{Name: \"signing_key\", Type: field.TypeJSON},\n\t\t{Name: \"signing_key_pub\", Type: field.TypeJSON},\n\t\t{Name: \"next_rotation\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t}\n\t// KeysTable holds the schema information for the \"keys\" table.\n\tKeysTable = &schema.Table{\n\t\tName:       \"keys\",\n\t\tColumns:    KeysColumns,\n\t\tPrimaryKey: []*schema.Column{KeysColumns[0]},\n\t}\n\t// Oauth2clientsColumns holds the columns for the \"oauth2clients\" table.\n\tOauth2clientsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 100, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"secret\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"redirect_uris\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"trusted_peers\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"public\", Type: field.TypeBool},\n\t\t{Name: \"name\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"logo_url\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// Oauth2clientsTable holds the schema information for the \"oauth2clients\" table.\n\tOauth2clientsTable = &schema.Table{\n\t\tName:       \"oauth2clients\",\n\t\tColumns:    Oauth2clientsColumns,\n\t\tPrimaryKey: []*schema.Column{Oauth2clientsColumns[0]},\n\t}\n\t// OfflineSessionsColumns holds the columns for the \"offline_sessions\" table.\n\tOfflineSessionsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"conn_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"refresh\", Type: field.TypeBytes},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t}\n\t// OfflineSessionsTable holds the schema information for the \"offline_sessions\" table.\n\tOfflineSessionsTable = &schema.Table{\n\t\tName:       \"offline_sessions\",\n\t\tColumns:    OfflineSessionsColumns,\n\t\tPrimaryKey: []*schema.Column{OfflineSessionsColumns[0]},\n\t}\n\t// PasswordsColumns holds the columns for the \"passwords\" table.\n\tPasswordsColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeInt, Increment: true},\n\t\t{Name: \"email\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"hash\", Type: field.TypeBytes},\n\t\t{Name: \"username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t}\n\t// PasswordsTable holds the schema information for the \"passwords\" table.\n\tPasswordsTable = &schema.Table{\n\t\tName:       \"passwords\",\n\t\tColumns:    PasswordsColumns,\n\t\tPrimaryKey: []*schema.Column{PasswordsColumns[0]},\n\t}\n\t// RefreshTokensColumns holds the columns for the \"refresh_tokens\" table.\n\tRefreshTokensColumns = []*schema.Column{\n\t\t{Name: \"id\", Type: field.TypeString, Unique: true, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"client_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"scopes\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"nonce\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_user_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_username\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"claims_email_verified\", Type: field.TypeBool},\n\t\t{Name: \"claims_groups\", Type: field.TypeJSON, Nullable: true},\n\t\t{Name: \"claims_preferred_username\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_id\", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"connector_data\", Type: field.TypeBytes, Nullable: true},\n\t\t{Name: \"token\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"obsolete_token\", Type: field.TypeString, Size: 2147483647, Default: \"\", SchemaType: map[string]string{\"mysql\": \"varchar(384)\", \"postgres\": \"text\", \"sqlite3\": \"text\"}},\n\t\t{Name: \"created_at\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t\t{Name: \"last_used\", Type: field.TypeTime, SchemaType: map[string]string{\"mysql\": \"datetime(3)\", \"postgres\": \"timestamptz\", \"sqlite3\": \"timestamp\"}},\n\t}\n\t// RefreshTokensTable holds the schema information for the \"refresh_tokens\" table.\n\tRefreshTokensTable = &schema.Table{\n\t\tName:       \"refresh_tokens\",\n\t\tColumns:    RefreshTokensColumns,\n\t\tPrimaryKey: []*schema.Column{RefreshTokensColumns[0]},\n\t}\n\t// Tables holds all the tables in the schema.\n\tTables = []*schema.Table{\n\t\tAuthCodesTable,\n\t\tAuthRequestsTable,\n\t\tConnectorsTable,\n\t\tDeviceRequestsTable,\n\t\tDeviceTokensTable,\n\t\tKeysTable,\n\t\tOauth2clientsTable,\n\t\tOfflineSessionsTable,\n\t\tPasswordsTable,\n\t\tRefreshTokensTable,\n\t}\n)\n\nfunc init() {\n}\n", "// Code generated by ent, DO NOT EDIT.\n\npackage db\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/ent/db/authcode\"\n\t\"github.com/dexidp/dex/storage/ent/db/authrequest\"\n\t\"github.com/dexidp/dex/storage/ent/db/connector\"\n\t\"github.com/dexidp/dex/storage/ent/db/devicerequest\"\n\t\"github.com/dexidp/dex/storage/ent/db/devicetoken\"\n\t\"github.com/dexidp/dex/storage/ent/db/keys\"\n\t\"github.com/dexidp/dex/storage/ent/db/oauth2client\"\n\t\"github.com/dexidp/dex/storage/ent/db/offlinesession\"\n\t\"github.com/dexidp/dex/storage/ent/db/password\"\n\t\"github.com/dexidp/dex/storage/ent/db/predicate\"\n\t\"github.com/dexidp/dex/storage/ent/db/refreshtoken\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"entgo.io/ent\"\n)\n\nconst (\n\t// Operation types.\n\tOpCreate    = ent.OpCreate\n\tOpDelete    = ent.OpDelete\n\tOpDeleteOne = ent.OpDeleteOne\n\tOpUpdate    = ent.OpUpdate\n\tOpUpdateOne = ent.OpUpdateOne\n\n\t// Node types.\n\tTypeAuthCode       = \"AuthCode\"\n\tTypeAuthRequest    = \"AuthRequest\"\n\tTypeConnector      = \"Connector\"\n\tTypeDeviceRequest  = \"DeviceRequest\"\n\tTypeDeviceToken    = \"DeviceToken\"\n\tTypeKeys           = \"Keys\"\n\tTypeOAuth2Client   = \"OAuth2Client\"\n\tTypeOfflineSession = \"OfflineSession\"\n\tTypePassword       = \"Password\"\n\tTypeRefreshToken   = \"RefreshToken\"\n)\n\n// AuthCodeMutation represents an operation that mutates the AuthCode nodes in the graph.\ntype AuthCodeMutation struct {\n\tconfig\n\top                        Op\n\ttyp                       string\n\tid                        *string\n\tclient_id                 *string\n\tscopes                    *[]string\n\tnonce                     *string\n\tredirect_uri              *string\n\tclaims_user_id            *string\n\tclaims_username           *string\n\tclaims_email              *string\n\tclaims_email_verified     *bool\n\tclaims_groups             *[]string\n\tclaims_preferred_username *string\n\tconnector_id              *string\n\tconnector_data            *[]byte\n\texpiry                    *time.Time\n\tcode_challenge            *string\n\tcode_challenge_method     *string\n\tclearedFields             map[string]struct{}\n\tdone                      bool\n\toldValue                  func(context.Context) (*AuthCode, error)\n\tpredicates                []predicate.AuthCode\n}\n\nvar _ ent.Mutation = (*AuthCodeMutation)(nil)\n\n// authcodeOption allows management of the mutation configuration using functional options.\ntype authcodeOption func(*AuthCodeMutation)\n\n// newAuthCodeMutation creates new mutation for the AuthCode entity.\nfunc newAuthCodeMutation(c config, op Op, opts ...authcodeOption) *AuthCodeMutation {\n\tm := &AuthCodeMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeAuthCode,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withAuthCodeID sets the ID field of the mutation.\nfunc withAuthCodeID(id string) authcodeOption {\n\treturn func(m *AuthCodeMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *AuthCode\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*AuthCode, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().AuthCode.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withAuthCode sets the old AuthCode of the mutation.\nfunc withAuthCode(node *AuthCode) authcodeOption {\n\treturn func(m *AuthCodeMutation) {\n\t\tm.oldValue = func(context.Context) (*AuthCode, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m AuthCodeMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m AuthCodeMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of AuthCode entities.\nfunc (m *AuthCodeMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *AuthCodeMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *AuthCodeMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().AuthCode.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *AuthCodeMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *AuthCodeMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *AuthCodeMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *AuthCodeMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *AuthCodeMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *AuthCodeMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[authcode.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *AuthCodeMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[authcode.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *AuthCodeMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, authcode.FieldScopes)\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (m *AuthCodeMutation) SetNonce(s string) {\n\tm.nonce = &s\n}\n\n// Nonce returns the value of the \"nonce\" field in the mutation.\nfunc (m *AuthCodeMutation) Nonce() (r string, exists bool) {\n\tv := m.nonce\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNonce returns the old \"nonce\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldNonce(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNonce is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNonce requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNonce: %w\", err)\n\t}\n\treturn oldValue.Nonce, nil\n}\n\n// ResetNonce resets all changes to the \"nonce\" field.\nfunc (m *AuthCodeMutation) ResetNonce() {\n\tm.nonce = nil\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (m *AuthCodeMutation) SetRedirectURI(s string) {\n\tm.redirect_uri = &s\n}\n\n// RedirectURI returns the value of the \"redirect_uri\" field in the mutation.\nfunc (m *AuthCodeMutation) RedirectURI() (r string, exists bool) {\n\tv := m.redirect_uri\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRedirectURI returns the old \"redirect_uri\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRedirectURI is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRedirectURI requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRedirectURI: %w\", err)\n\t}\n\treturn oldValue.RedirectURI, nil\n}\n\n// ResetRedirectURI resets all changes to the \"redirect_uri\" field.\nfunc (m *AuthCodeMutation) ResetRedirectURI() {\n\tm.redirect_uri = nil\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (m *AuthCodeMutation) SetClaimsUserID(s string) {\n\tm.claims_user_id = &s\n}\n\n// ClaimsUserID returns the value of the \"claims_user_id\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsUserID() (r string, exists bool) {\n\tv := m.claims_user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUserID returns the old \"claims_user_id\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUserID: %w\", err)\n\t}\n\treturn oldValue.ClaimsUserID, nil\n}\n\n// ResetClaimsUserID resets all changes to the \"claims_user_id\" field.\nfunc (m *AuthCodeMutation) ResetClaimsUserID() {\n\tm.claims_user_id = nil\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (m *AuthCodeMutation) SetClaimsUsername(s string) {\n\tm.claims_username = &s\n}\n\n// ClaimsUsername returns the value of the \"claims_username\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsUsername() (r string, exists bool) {\n\tv := m.claims_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUsername returns the old \"claims_username\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsUsername, nil\n}\n\n// ResetClaimsUsername resets all changes to the \"claims_username\" field.\nfunc (m *AuthCodeMutation) ResetClaimsUsername() {\n\tm.claims_username = nil\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (m *AuthCodeMutation) SetClaimsEmail(s string) {\n\tm.claims_email = &s\n}\n\n// ClaimsEmail returns the value of the \"claims_email\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsEmail() (r string, exists bool) {\n\tv := m.claims_email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmail returns the old \"claims_email\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmail: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmail, nil\n}\n\n// ResetClaimsEmail resets all changes to the \"claims_email\" field.\nfunc (m *AuthCodeMutation) ResetClaimsEmail() {\n\tm.claims_email = nil\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (m *AuthCodeMutation) SetClaimsEmailVerified(b bool) {\n\tm.claims_email_verified = &b\n}\n\n// ClaimsEmailVerified returns the value of the \"claims_email_verified\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsEmailVerified() (r bool, exists bool) {\n\tv := m.claims_email_verified\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmailVerified returns the old \"claims_email_verified\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmailVerified: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmailVerified, nil\n}\n\n// ResetClaimsEmailVerified resets all changes to the \"claims_email_verified\" field.\nfunc (m *AuthCodeMutation) ResetClaimsEmailVerified() {\n\tm.claims_email_verified = nil\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (m *AuthCodeMutation) SetClaimsGroups(s []string) {\n\tm.claims_groups = &s\n}\n\n// ClaimsGroups returns the value of the \"claims_groups\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsGroups() (r []string, exists bool) {\n\tv := m.claims_groups\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsGroups returns the old \"claims_groups\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsGroups is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsGroups requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsGroups: %w\", err)\n\t}\n\treturn oldValue.ClaimsGroups, nil\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (m *AuthCodeMutation) ClearClaimsGroups() {\n\tm.claims_groups = nil\n\tm.clearedFields[authcode.FieldClaimsGroups] = struct{}{}\n}\n\n// ClaimsGroupsCleared returns if the \"claims_groups\" field was cleared in this mutation.\nfunc (m *AuthCodeMutation) ClaimsGroupsCleared() bool {\n\t_, ok := m.clearedFields[authcode.FieldClaimsGroups]\n\treturn ok\n}\n\n// ResetClaimsGroups resets all changes to the \"claims_groups\" field.\nfunc (m *AuthCodeMutation) ResetClaimsGroups() {\n\tm.claims_groups = nil\n\tdelete(m.clearedFields, authcode.FieldClaimsGroups)\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (m *AuthCodeMutation) SetClaimsPreferredUsername(s string) {\n\tm.claims_preferred_username = &s\n}\n\n// ClaimsPreferredUsername returns the value of the \"claims_preferred_username\" field in the mutation.\nfunc (m *AuthCodeMutation) ClaimsPreferredUsername() (r string, exists bool) {\n\tv := m.claims_preferred_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsPreferredUsername returns the old \"claims_preferred_username\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsPreferredUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsPreferredUsername, nil\n}\n\n// ResetClaimsPreferredUsername resets all changes to the \"claims_preferred_username\" field.\nfunc (m *AuthCodeMutation) ResetClaimsPreferredUsername() {\n\tm.claims_preferred_username = nil\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (m *AuthCodeMutation) SetConnectorID(s string) {\n\tm.connector_id = &s\n}\n\n// ConnectorID returns the value of the \"connector_id\" field in the mutation.\nfunc (m *AuthCodeMutation) ConnectorID() (r string, exists bool) {\n\tv := m.connector_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorID returns the old \"connector_id\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldConnectorID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorID: %w\", err)\n\t}\n\treturn oldValue.ConnectorID, nil\n}\n\n// ResetConnectorID resets all changes to the \"connector_id\" field.\nfunc (m *AuthCodeMutation) ResetConnectorID() {\n\tm.connector_id = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *AuthCodeMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *AuthCodeMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *AuthCodeMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[authcode.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *AuthCodeMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[authcode.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *AuthCodeMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, authcode.FieldConnectorData)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *AuthCodeMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *AuthCodeMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *AuthCodeMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (m *AuthCodeMutation) SetCodeChallenge(s string) {\n\tm.code_challenge = &s\n}\n\n// CodeChallenge returns the value of the \"code_challenge\" field in the mutation.\nfunc (m *AuthCodeMutation) CodeChallenge() (r string, exists bool) {\n\tv := m.code_challenge\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallenge returns the old \"code_challenge\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallenge is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallenge requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallenge: %w\", err)\n\t}\n\treturn oldValue.CodeChallenge, nil\n}\n\n// ResetCodeChallenge resets all changes to the \"code_challenge\" field.\nfunc (m *AuthCodeMutation) ResetCodeChallenge() {\n\tm.code_challenge = nil\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (m *AuthCodeMutation) SetCodeChallengeMethod(s string) {\n\tm.code_challenge_method = &s\n}\n\n// CodeChallengeMethod returns the value of the \"code_challenge_method\" field in the mutation.\nfunc (m *AuthCodeMutation) CodeChallengeMethod() (r string, exists bool) {\n\tv := m.code_challenge_method\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallengeMethod returns the old \"code_challenge_method\" field's value of the AuthCode entity.\n// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthCodeMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallengeMethod: %w\", err)\n\t}\n\treturn oldValue.CodeChallengeMethod, nil\n}\n\n// ResetCodeChallengeMethod resets all changes to the \"code_challenge_method\" field.\nfunc (m *AuthCodeMutation) ResetCodeChallengeMethod() {\n\tm.code_challenge_method = nil\n}\n\n// Where appends a list predicates to the AuthCodeMutation builder.\nfunc (m *AuthCodeMutation) Where(ps ...predicate.AuthCode) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *AuthCodeMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (AuthCode).\nfunc (m *AuthCodeMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *AuthCodeMutation) Fields() []string {\n\tfields := make([]string, 0, 15)\n\tif m.client_id != nil {\n\t\tfields = append(fields, authcode.FieldClientID)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, authcode.FieldScopes)\n\t}\n\tif m.nonce != nil {\n\t\tfields = append(fields, authcode.FieldNonce)\n\t}\n\tif m.redirect_uri != nil {\n\t\tfields = append(fields, authcode.FieldRedirectURI)\n\t}\n\tif m.claims_user_id != nil {\n\t\tfields = append(fields, authcode.FieldClaimsUserID)\n\t}\n\tif m.claims_username != nil {\n\t\tfields = append(fields, authcode.FieldClaimsUsername)\n\t}\n\tif m.claims_email != nil {\n\t\tfields = append(fields, authcode.FieldClaimsEmail)\n\t}\n\tif m.claims_email_verified != nil {\n\t\tfields = append(fields, authcode.FieldClaimsEmailVerified)\n\t}\n\tif m.claims_groups != nil {\n\t\tfields = append(fields, authcode.FieldClaimsGroups)\n\t}\n\tif m.claims_preferred_username != nil {\n\t\tfields = append(fields, authcode.FieldClaimsPreferredUsername)\n\t}\n\tif m.connector_id != nil {\n\t\tfields = append(fields, authcode.FieldConnectorID)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, authcode.FieldConnectorData)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, authcode.FieldExpiry)\n\t}\n\tif m.code_challenge != nil {\n\t\tfields = append(fields, authcode.FieldCodeChallenge)\n\t}\n\tif m.code_challenge_method != nil {\n\t\tfields = append(fields, authcode.FieldCodeChallengeMethod)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *AuthCodeMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\treturn m.ClientID()\n\tcase authcode.FieldScopes:\n\t\treturn m.Scopes()\n\tcase authcode.FieldNonce:\n\t\treturn m.Nonce()\n\tcase authcode.FieldRedirectURI:\n\t\treturn m.RedirectURI()\n\tcase authcode.FieldClaimsUserID:\n\t\treturn m.ClaimsUserID()\n\tcase authcode.FieldClaimsUsername:\n\t\treturn m.ClaimsUsername()\n\tcase authcode.FieldClaimsEmail:\n\t\treturn m.ClaimsEmail()\n\tcase authcode.FieldClaimsEmailVerified:\n\t\treturn m.ClaimsEmailVerified()\n\tcase authcode.FieldClaimsGroups:\n\t\treturn m.ClaimsGroups()\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\treturn m.ClaimsPreferredUsername()\n\tcase authcode.FieldConnectorID:\n\t\treturn m.ConnectorID()\n\tcase authcode.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\tcase authcode.FieldExpiry:\n\t\treturn m.Expiry()\n\tcase authcode.FieldCodeChallenge:\n\t\treturn m.CodeChallenge()\n\tcase authcode.FieldCodeChallengeMethod:\n\t\treturn m.CodeChallengeMethod()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *AuthCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase authcode.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase authcode.FieldNonce:\n\t\treturn m.OldNonce(ctx)\n\tcase authcode.FieldRedirectURI:\n\t\treturn m.OldRedirectURI(ctx)\n\tcase authcode.FieldClaimsUserID:\n\t\treturn m.OldClaimsUserID(ctx)\n\tcase authcode.FieldClaimsUsername:\n\t\treturn m.OldClaimsUsername(ctx)\n\tcase authcode.FieldClaimsEmail:\n\t\treturn m.OldClaimsEmail(ctx)\n\tcase authcode.FieldClaimsEmailVerified:\n\t\treturn m.OldClaimsEmailVerified(ctx)\n\tcase authcode.FieldClaimsGroups:\n\t\treturn m.OldClaimsGroups(ctx)\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\treturn m.OldClaimsPreferredUsername(ctx)\n\tcase authcode.FieldConnectorID:\n\t\treturn m.OldConnectorID(ctx)\n\tcase authcode.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\tcase authcode.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\tcase authcode.FieldCodeChallenge:\n\t\treturn m.OldCodeChallenge(ctx)\n\tcase authcode.FieldCodeChallengeMethod:\n\t\treturn m.OldCodeChallengeMethod(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown AuthCode field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthCodeMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase authcode.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase authcode.FieldNonce:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNonce(v)\n\t\treturn nil\n\tcase authcode.FieldRedirectURI:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRedirectURI(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUserID(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUsername(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmail(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsEmailVerified:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmailVerified(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsGroups:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsGroups(v)\n\t\treturn nil\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsPreferredUsername(v)\n\t\treturn nil\n\tcase authcode.FieldConnectorID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorID(v)\n\t\treturn nil\n\tcase authcode.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\tcase authcode.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\tcase authcode.FieldCodeChallenge:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallenge(v)\n\t\treturn nil\n\tcase authcode.FieldCodeChallengeMethod:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallengeMethod(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *AuthCodeMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *AuthCodeMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthCodeMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *AuthCodeMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(authcode.FieldScopes) {\n\t\tfields = append(fields, authcode.FieldScopes)\n\t}\n\tif m.FieldCleared(authcode.FieldClaimsGroups) {\n\t\tfields = append(fields, authcode.FieldClaimsGroups)\n\t}\n\tif m.FieldCleared(authcode.FieldConnectorData) {\n\t\tfields = append(fields, authcode.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *AuthCodeMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *AuthCodeMutation) ClearField(name string) error {\n\tswitch name {\n\tcase authcode.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\tcase authcode.FieldClaimsGroups:\n\t\tm.ClearClaimsGroups()\n\t\treturn nil\n\tcase authcode.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *AuthCodeMutation) ResetField(name string) error {\n\tswitch name {\n\tcase authcode.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase authcode.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase authcode.FieldNonce:\n\t\tm.ResetNonce()\n\t\treturn nil\n\tcase authcode.FieldRedirectURI:\n\t\tm.ResetRedirectURI()\n\t\treturn nil\n\tcase authcode.FieldClaimsUserID:\n\t\tm.ResetClaimsUserID()\n\t\treturn nil\n\tcase authcode.FieldClaimsUsername:\n\t\tm.ResetClaimsUsername()\n\t\treturn nil\n\tcase authcode.FieldClaimsEmail:\n\t\tm.ResetClaimsEmail()\n\t\treturn nil\n\tcase authcode.FieldClaimsEmailVerified:\n\t\tm.ResetClaimsEmailVerified()\n\t\treturn nil\n\tcase authcode.FieldClaimsGroups:\n\t\tm.ResetClaimsGroups()\n\t\treturn nil\n\tcase authcode.FieldClaimsPreferredUsername:\n\t\tm.ResetClaimsPreferredUsername()\n\t\treturn nil\n\tcase authcode.FieldConnectorID:\n\t\tm.ResetConnectorID()\n\t\treturn nil\n\tcase authcode.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\tcase authcode.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\tcase authcode.FieldCodeChallenge:\n\t\tm.ResetCodeChallenge()\n\t\treturn nil\n\tcase authcode.FieldCodeChallengeMethod:\n\t\tm.ResetCodeChallengeMethod()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthCode field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *AuthCodeMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *AuthCodeMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *AuthCodeMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *AuthCodeMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *AuthCodeMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *AuthCodeMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *AuthCodeMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthCode unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *AuthCodeMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthCode edge %s\", name)\n}\n\n// AuthRequestMutation represents an operation that mutates the AuthRequest nodes in the graph.\ntype AuthRequestMutation struct {\n\tconfig\n\top                        Op\n\ttyp                       string\n\tid                        *string\n\tclient_id                 *string\n\tscopes                    *[]string\n\tresponse_types            *[]string\n\tredirect_uri              *string\n\tnonce                     *string\n\tstate                     *string\n\tforce_approval_prompt     *bool\n\tlogged_in                 *bool\n\tclaims_user_id            *string\n\tclaims_username           *string\n\tclaims_email              *string\n\tclaims_email_verified     *bool\n\tclaims_groups             *[]string\n\tclaims_preferred_username *string\n\tconnector_id              *string\n\tconnector_data            *[]byte\n\texpiry                    *time.Time\n\tcode_challenge            *string\n\tcode_challenge_method     *string\n\thmac_key                  *[]byte\n\tclearedFields             map[string]struct{}\n\tdone                      bool\n\toldValue                  func(context.Context) (*AuthRequest, error)\n\tpredicates                []predicate.AuthRequest\n}\n\nvar _ ent.Mutation = (*AuthRequestMutation)(nil)\n\n// authrequestOption allows management of the mutation configuration using functional options.\ntype authrequestOption func(*AuthRequestMutation)\n\n// newAuthRequestMutation creates new mutation for the AuthRequest entity.\nfunc newAuthRequestMutation(c config, op Op, opts ...authrequestOption) *AuthRequestMutation {\n\tm := &AuthRequestMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeAuthRequest,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withAuthRequestID sets the ID field of the mutation.\nfunc withAuthRequestID(id string) authrequestOption {\n\treturn func(m *AuthRequestMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *AuthRequest\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*AuthRequest, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().AuthRequest.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withAuthRequest sets the old AuthRequest of the mutation.\nfunc withAuthRequest(node *AuthRequest) authrequestOption {\n\treturn func(m *AuthRequestMutation) {\n\t\tm.oldValue = func(context.Context) (*AuthRequest, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m AuthRequestMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m AuthRequestMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of AuthRequest entities.\nfunc (m *AuthRequestMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *AuthRequestMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *AuthRequestMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().AuthRequest.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *AuthRequestMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *AuthRequestMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *AuthRequestMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *AuthRequestMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *AuthRequestMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *AuthRequestMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[authrequest.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *AuthRequestMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, authrequest.FieldScopes)\n}\n\n// SetResponseTypes sets the \"response_types\" field.\nfunc (m *AuthRequestMutation) SetResponseTypes(s []string) {\n\tm.response_types = &s\n}\n\n// ResponseTypes returns the value of the \"response_types\" field in the mutation.\nfunc (m *AuthRequestMutation) ResponseTypes() (r []string, exists bool) {\n\tv := m.response_types\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldResponseTypes returns the old \"response_types\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldResponseTypes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldResponseTypes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldResponseTypes: %w\", err)\n\t}\n\treturn oldValue.ResponseTypes, nil\n}\n\n// ClearResponseTypes clears the value of the \"response_types\" field.\nfunc (m *AuthRequestMutation) ClearResponseTypes() {\n\tm.response_types = nil\n\tm.clearedFields[authrequest.FieldResponseTypes] = struct{}{}\n}\n\n// ResponseTypesCleared returns if the \"response_types\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ResponseTypesCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldResponseTypes]\n\treturn ok\n}\n\n// ResetResponseTypes resets all changes to the \"response_types\" field.\nfunc (m *AuthRequestMutation) ResetResponseTypes() {\n\tm.response_types = nil\n\tdelete(m.clearedFields, authrequest.FieldResponseTypes)\n}\n\n// SetRedirectURI sets the \"redirect_uri\" field.\nfunc (m *AuthRequestMutation) SetRedirectURI(s string) {\n\tm.redirect_uri = &s\n}\n\n// RedirectURI returns the value of the \"redirect_uri\" field in the mutation.\nfunc (m *AuthRequestMutation) RedirectURI() (r string, exists bool) {\n\tv := m.redirect_uri\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRedirectURI returns the old \"redirect_uri\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldRedirectURI(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRedirectURI is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRedirectURI requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRedirectURI: %w\", err)\n\t}\n\treturn oldValue.RedirectURI, nil\n}\n\n// ResetRedirectURI resets all changes to the \"redirect_uri\" field.\nfunc (m *AuthRequestMutation) ResetRedirectURI() {\n\tm.redirect_uri = nil\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (m *AuthRequestMutation) SetNonce(s string) {\n\tm.nonce = &s\n}\n\n// Nonce returns the value of the \"nonce\" field in the mutation.\nfunc (m *AuthRequestMutation) Nonce() (r string, exists bool) {\n\tv := m.nonce\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNonce returns the old \"nonce\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldNonce(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNonce is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNonce requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNonce: %w\", err)\n\t}\n\treturn oldValue.Nonce, nil\n}\n\n// ResetNonce resets all changes to the \"nonce\" field.\nfunc (m *AuthRequestMutation) ResetNonce() {\n\tm.nonce = nil\n}\n\n// SetState sets the \"state\" field.\nfunc (m *AuthRequestMutation) SetState(s string) {\n\tm.state = &s\n}\n\n// State returns the value of the \"state\" field in the mutation.\nfunc (m *AuthRequestMutation) State() (r string, exists bool) {\n\tv := m.state\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldState returns the old \"state\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldState(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldState is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldState requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldState: %w\", err)\n\t}\n\treturn oldValue.State, nil\n}\n\n// ResetState resets all changes to the \"state\" field.\nfunc (m *AuthRequestMutation) ResetState() {\n\tm.state = nil\n}\n\n// SetForceApprovalPrompt sets the \"force_approval_prompt\" field.\nfunc (m *AuthRequestMutation) SetForceApprovalPrompt(b bool) {\n\tm.force_approval_prompt = &b\n}\n\n// ForceApprovalPrompt returns the value of the \"force_approval_prompt\" field in the mutation.\nfunc (m *AuthRequestMutation) ForceApprovalPrompt() (r bool, exists bool) {\n\tv := m.force_approval_prompt\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldForceApprovalPrompt returns the old \"force_approval_prompt\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldForceApprovalPrompt(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldForceApprovalPrompt is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldForceApprovalPrompt requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldForceApprovalPrompt: %w\", err)\n\t}\n\treturn oldValue.ForceApprovalPrompt, nil\n}\n\n// ResetForceApprovalPrompt resets all changes to the \"force_approval_prompt\" field.\nfunc (m *AuthRequestMutation) ResetForceApprovalPrompt() {\n\tm.force_approval_prompt = nil\n}\n\n// SetLoggedIn sets the \"logged_in\" field.\nfunc (m *AuthRequestMutation) SetLoggedIn(b bool) {\n\tm.logged_in = &b\n}\n\n// LoggedIn returns the value of the \"logged_in\" field in the mutation.\nfunc (m *AuthRequestMutation) LoggedIn() (r bool, exists bool) {\n\tv := m.logged_in\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLoggedIn returns the old \"logged_in\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldLoggedIn(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLoggedIn is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLoggedIn requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLoggedIn: %w\", err)\n\t}\n\treturn oldValue.LoggedIn, nil\n}\n\n// ResetLoggedIn resets all changes to the \"logged_in\" field.\nfunc (m *AuthRequestMutation) ResetLoggedIn() {\n\tm.logged_in = nil\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (m *AuthRequestMutation) SetClaimsUserID(s string) {\n\tm.claims_user_id = &s\n}\n\n// ClaimsUserID returns the value of the \"claims_user_id\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsUserID() (r string, exists bool) {\n\tv := m.claims_user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUserID returns the old \"claims_user_id\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUserID: %w\", err)\n\t}\n\treturn oldValue.ClaimsUserID, nil\n}\n\n// ResetClaimsUserID resets all changes to the \"claims_user_id\" field.\nfunc (m *AuthRequestMutation) ResetClaimsUserID() {\n\tm.claims_user_id = nil\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (m *AuthRequestMutation) SetClaimsUsername(s string) {\n\tm.claims_username = &s\n}\n\n// ClaimsUsername returns the value of the \"claims_username\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsUsername() (r string, exists bool) {\n\tv := m.claims_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUsername returns the old \"claims_username\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsUsername, nil\n}\n\n// ResetClaimsUsername resets all changes to the \"claims_username\" field.\nfunc (m *AuthRequestMutation) ResetClaimsUsername() {\n\tm.claims_username = nil\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (m *AuthRequestMutation) SetClaimsEmail(s string) {\n\tm.claims_email = &s\n}\n\n// ClaimsEmail returns the value of the \"claims_email\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsEmail() (r string, exists bool) {\n\tv := m.claims_email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmail returns the old \"claims_email\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmail: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmail, nil\n}\n\n// ResetClaimsEmail resets all changes to the \"claims_email\" field.\nfunc (m *AuthRequestMutation) ResetClaimsEmail() {\n\tm.claims_email = nil\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (m *AuthRequestMutation) SetClaimsEmailVerified(b bool) {\n\tm.claims_email_verified = &b\n}\n\n// ClaimsEmailVerified returns the value of the \"claims_email_verified\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsEmailVerified() (r bool, exists bool) {\n\tv := m.claims_email_verified\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmailVerified returns the old \"claims_email_verified\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmailVerified: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmailVerified, nil\n}\n\n// ResetClaimsEmailVerified resets all changes to the \"claims_email_verified\" field.\nfunc (m *AuthRequestMutation) ResetClaimsEmailVerified() {\n\tm.claims_email_verified = nil\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (m *AuthRequestMutation) SetClaimsGroups(s []string) {\n\tm.claims_groups = &s\n}\n\n// ClaimsGroups returns the value of the \"claims_groups\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsGroups() (r []string, exists bool) {\n\tv := m.claims_groups\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsGroups returns the old \"claims_groups\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsGroups is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsGroups requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsGroups: %w\", err)\n\t}\n\treturn oldValue.ClaimsGroups, nil\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (m *AuthRequestMutation) ClearClaimsGroups() {\n\tm.claims_groups = nil\n\tm.clearedFields[authrequest.FieldClaimsGroups] = struct{}{}\n}\n\n// ClaimsGroupsCleared returns if the \"claims_groups\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ClaimsGroupsCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldClaimsGroups]\n\treturn ok\n}\n\n// ResetClaimsGroups resets all changes to the \"claims_groups\" field.\nfunc (m *AuthRequestMutation) ResetClaimsGroups() {\n\tm.claims_groups = nil\n\tdelete(m.clearedFields, authrequest.FieldClaimsGroups)\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (m *AuthRequestMutation) SetClaimsPreferredUsername(s string) {\n\tm.claims_preferred_username = &s\n}\n\n// ClaimsPreferredUsername returns the value of the \"claims_preferred_username\" field in the mutation.\nfunc (m *AuthRequestMutation) ClaimsPreferredUsername() (r string, exists bool) {\n\tv := m.claims_preferred_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsPreferredUsername returns the old \"claims_preferred_username\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsPreferredUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsPreferredUsername, nil\n}\n\n// ResetClaimsPreferredUsername resets all changes to the \"claims_preferred_username\" field.\nfunc (m *AuthRequestMutation) ResetClaimsPreferredUsername() {\n\tm.claims_preferred_username = nil\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (m *AuthRequestMutation) SetConnectorID(s string) {\n\tm.connector_id = &s\n}\n\n// ConnectorID returns the value of the \"connector_id\" field in the mutation.\nfunc (m *AuthRequestMutation) ConnectorID() (r string, exists bool) {\n\tv := m.connector_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorID returns the old \"connector_id\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldConnectorID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorID: %w\", err)\n\t}\n\treturn oldValue.ConnectorID, nil\n}\n\n// ResetConnectorID resets all changes to the \"connector_id\" field.\nfunc (m *AuthRequestMutation) ResetConnectorID() {\n\tm.connector_id = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *AuthRequestMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *AuthRequestMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *AuthRequestMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[authrequest.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *AuthRequestMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[authrequest.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *AuthRequestMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, authrequest.FieldConnectorData)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *AuthRequestMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *AuthRequestMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *AuthRequestMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (m *AuthRequestMutation) SetCodeChallenge(s string) {\n\tm.code_challenge = &s\n}\n\n// CodeChallenge returns the value of the \"code_challenge\" field in the mutation.\nfunc (m *AuthRequestMutation) CodeChallenge() (r string, exists bool) {\n\tv := m.code_challenge\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallenge returns the old \"code_challenge\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallenge is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallenge requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallenge: %w\", err)\n\t}\n\treturn oldValue.CodeChallenge, nil\n}\n\n// ResetCodeChallenge resets all changes to the \"code_challenge\" field.\nfunc (m *AuthRequestMutation) ResetCodeChallenge() {\n\tm.code_challenge = nil\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (m *AuthRequestMutation) SetCodeChallengeMethod(s string) {\n\tm.code_challenge_method = &s\n}\n\n// CodeChallengeMethod returns the value of the \"code_challenge_method\" field in the mutation.\nfunc (m *AuthRequestMutation) CodeChallengeMethod() (r string, exists bool) {\n\tv := m.code_challenge_method\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallengeMethod returns the old \"code_challenge_method\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallengeMethod: %w\", err)\n\t}\n\treturn oldValue.CodeChallengeMethod, nil\n}\n\n// ResetCodeChallengeMethod resets all changes to the \"code_challenge_method\" field.\nfunc (m *AuthRequestMutation) ResetCodeChallengeMethod() {\n\tm.code_challenge_method = nil\n}\n\n// SetHmacKey sets the \"hmac_key\" field.\nfunc (m *AuthRequestMutation) SetHmacKey(b []byte) {\n\tm.hmac_key = &b\n}\n\n// HmacKey returns the value of the \"hmac_key\" field in the mutation.\nfunc (m *AuthRequestMutation) HmacKey() (r []byte, exists bool) {\n\tv := m.hmac_key\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldHmacKey returns the old \"hmac_key\" field's value of the AuthRequest entity.\n// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *AuthRequestMutation) OldHmacKey(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldHmacKey is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldHmacKey requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldHmacKey: %w\", err)\n\t}\n\treturn oldValue.HmacKey, nil\n}\n\n// ResetHmacKey resets all changes to the \"hmac_key\" field.\nfunc (m *AuthRequestMutation) ResetHmacKey() {\n\tm.hmac_key = nil\n}\n\n// Where appends a list predicates to the AuthRequestMutation builder.\nfunc (m *AuthRequestMutation) Where(ps ...predicate.AuthRequest) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *AuthRequestMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (AuthRequest).\nfunc (m *AuthRequestMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *AuthRequestMutation) Fields() []string {\n\tfields := make([]string, 0, 20)\n\tif m.client_id != nil {\n\t\tfields = append(fields, authrequest.FieldClientID)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, authrequest.FieldScopes)\n\t}\n\tif m.response_types != nil {\n\t\tfields = append(fields, authrequest.FieldResponseTypes)\n\t}\n\tif m.redirect_uri != nil {\n\t\tfields = append(fields, authrequest.FieldRedirectURI)\n\t}\n\tif m.nonce != nil {\n\t\tfields = append(fields, authrequest.FieldNonce)\n\t}\n\tif m.state != nil {\n\t\tfields = append(fields, authrequest.FieldState)\n\t}\n\tif m.force_approval_prompt != nil {\n\t\tfields = append(fields, authrequest.FieldForceApprovalPrompt)\n\t}\n\tif m.logged_in != nil {\n\t\tfields = append(fields, authrequest.FieldLoggedIn)\n\t}\n\tif m.claims_user_id != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsUserID)\n\t}\n\tif m.claims_username != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsUsername)\n\t}\n\tif m.claims_email != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsEmail)\n\t}\n\tif m.claims_email_verified != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsEmailVerified)\n\t}\n\tif m.claims_groups != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsGroups)\n\t}\n\tif m.claims_preferred_username != nil {\n\t\tfields = append(fields, authrequest.FieldClaimsPreferredUsername)\n\t}\n\tif m.connector_id != nil {\n\t\tfields = append(fields, authrequest.FieldConnectorID)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, authrequest.FieldConnectorData)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, authrequest.FieldExpiry)\n\t}\n\tif m.code_challenge != nil {\n\t\tfields = append(fields, authrequest.FieldCodeChallenge)\n\t}\n\tif m.code_challenge_method != nil {\n\t\tfields = append(fields, authrequest.FieldCodeChallengeMethod)\n\t}\n\tif m.hmac_key != nil {\n\t\tfields = append(fields, authrequest.FieldHmacKey)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *AuthRequestMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\treturn m.ClientID()\n\tcase authrequest.FieldScopes:\n\t\treturn m.Scopes()\n\tcase authrequest.FieldResponseTypes:\n\t\treturn m.ResponseTypes()\n\tcase authrequest.FieldRedirectURI:\n\t\treturn m.RedirectURI()\n\tcase authrequest.FieldNonce:\n\t\treturn m.Nonce()\n\tcase authrequest.FieldState:\n\t\treturn m.State()\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\treturn m.ForceApprovalPrompt()\n\tcase authrequest.FieldLoggedIn:\n\t\treturn m.LoggedIn()\n\tcase authrequest.FieldClaimsUserID:\n\t\treturn m.ClaimsUserID()\n\tcase authrequest.FieldClaimsUsername:\n\t\treturn m.ClaimsUsername()\n\tcase authrequest.FieldClaimsEmail:\n\t\treturn m.ClaimsEmail()\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\treturn m.ClaimsEmailVerified()\n\tcase authrequest.FieldClaimsGroups:\n\t\treturn m.ClaimsGroups()\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\treturn m.ClaimsPreferredUsername()\n\tcase authrequest.FieldConnectorID:\n\t\treturn m.ConnectorID()\n\tcase authrequest.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\tcase authrequest.FieldExpiry:\n\t\treturn m.Expiry()\n\tcase authrequest.FieldCodeChallenge:\n\t\treturn m.CodeChallenge()\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\treturn m.CodeChallengeMethod()\n\tcase authrequest.FieldHmacKey:\n\t\treturn m.HmacKey()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *AuthRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase authrequest.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase authrequest.FieldResponseTypes:\n\t\treturn m.OldResponseTypes(ctx)\n\tcase authrequest.FieldRedirectURI:\n\t\treturn m.OldRedirectURI(ctx)\n\tcase authrequest.FieldNonce:\n\t\treturn m.OldNonce(ctx)\n\tcase authrequest.FieldState:\n\t\treturn m.OldState(ctx)\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\treturn m.OldForceApprovalPrompt(ctx)\n\tcase authrequest.FieldLoggedIn:\n\t\treturn m.OldLoggedIn(ctx)\n\tcase authrequest.FieldClaimsUserID:\n\t\treturn m.OldClaimsUserID(ctx)\n\tcase authrequest.FieldClaimsUsername:\n\t\treturn m.OldClaimsUsername(ctx)\n\tcase authrequest.FieldClaimsEmail:\n\t\treturn m.OldClaimsEmail(ctx)\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\treturn m.OldClaimsEmailVerified(ctx)\n\tcase authrequest.FieldClaimsGroups:\n\t\treturn m.OldClaimsGroups(ctx)\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\treturn m.OldClaimsPreferredUsername(ctx)\n\tcase authrequest.FieldConnectorID:\n\t\treturn m.OldConnectorID(ctx)\n\tcase authrequest.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\tcase authrequest.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\tcase authrequest.FieldCodeChallenge:\n\t\treturn m.OldCodeChallenge(ctx)\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\treturn m.OldCodeChallengeMethod(ctx)\n\tcase authrequest.FieldHmacKey:\n\t\treturn m.OldHmacKey(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown AuthRequest field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthRequestMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase authrequest.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase authrequest.FieldResponseTypes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetResponseTypes(v)\n\t\treturn nil\n\tcase authrequest.FieldRedirectURI:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRedirectURI(v)\n\t\treturn nil\n\tcase authrequest.FieldNonce:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNonce(v)\n\t\treturn nil\n\tcase authrequest.FieldState:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetState(v)\n\t\treturn nil\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetForceApprovalPrompt(v)\n\t\treturn nil\n\tcase authrequest.FieldLoggedIn:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLoggedIn(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUserID(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUsername(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmail(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmailVerified(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsGroups:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsGroups(v)\n\t\treturn nil\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsPreferredUsername(v)\n\t\treturn nil\n\tcase authrequest.FieldConnectorID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorID(v)\n\t\treturn nil\n\tcase authrequest.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\tcase authrequest.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\tcase authrequest.FieldCodeChallenge:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallenge(v)\n\t\treturn nil\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallengeMethod(v)\n\t\treturn nil\n\tcase authrequest.FieldHmacKey:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetHmacKey(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *AuthRequestMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *AuthRequestMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *AuthRequestMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *AuthRequestMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(authrequest.FieldScopes) {\n\t\tfields = append(fields, authrequest.FieldScopes)\n\t}\n\tif m.FieldCleared(authrequest.FieldResponseTypes) {\n\t\tfields = append(fields, authrequest.FieldResponseTypes)\n\t}\n\tif m.FieldCleared(authrequest.FieldClaimsGroups) {\n\t\tfields = append(fields, authrequest.FieldClaimsGroups)\n\t}\n\tif m.FieldCleared(authrequest.FieldConnectorData) {\n\t\tfields = append(fields, authrequest.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *AuthRequestMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *AuthRequestMutation) ClearField(name string) error {\n\tswitch name {\n\tcase authrequest.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\tcase authrequest.FieldResponseTypes:\n\t\tm.ClearResponseTypes()\n\t\treturn nil\n\tcase authrequest.FieldClaimsGroups:\n\t\tm.ClearClaimsGroups()\n\t\treturn nil\n\tcase authrequest.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *AuthRequestMutation) ResetField(name string) error {\n\tswitch name {\n\tcase authrequest.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase authrequest.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase authrequest.FieldResponseTypes:\n\t\tm.ResetResponseTypes()\n\t\treturn nil\n\tcase authrequest.FieldRedirectURI:\n\t\tm.ResetRedirectURI()\n\t\treturn nil\n\tcase authrequest.FieldNonce:\n\t\tm.ResetNonce()\n\t\treturn nil\n\tcase authrequest.FieldState:\n\t\tm.ResetState()\n\t\treturn nil\n\tcase authrequest.FieldForceApprovalPrompt:\n\t\tm.ResetForceApprovalPrompt()\n\t\treturn nil\n\tcase authrequest.FieldLoggedIn:\n\t\tm.ResetLoggedIn()\n\t\treturn nil\n\tcase authrequest.FieldClaimsUserID:\n\t\tm.ResetClaimsUserID()\n\t\treturn nil\n\tcase authrequest.FieldClaimsUsername:\n\t\tm.ResetClaimsUsername()\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmail:\n\t\tm.ResetClaimsEmail()\n\t\treturn nil\n\tcase authrequest.FieldClaimsEmailVerified:\n\t\tm.ResetClaimsEmailVerified()\n\t\treturn nil\n\tcase authrequest.FieldClaimsGroups:\n\t\tm.ResetClaimsGroups()\n\t\treturn nil\n\tcase authrequest.FieldClaimsPreferredUsername:\n\t\tm.ResetClaimsPreferredUsername()\n\t\treturn nil\n\tcase authrequest.FieldConnectorID:\n\t\tm.ResetConnectorID()\n\t\treturn nil\n\tcase authrequest.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\tcase authrequest.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\tcase authrequest.FieldCodeChallenge:\n\t\tm.ResetCodeChallenge()\n\t\treturn nil\n\tcase authrequest.FieldCodeChallengeMethod:\n\t\tm.ResetCodeChallengeMethod()\n\t\treturn nil\n\tcase authrequest.FieldHmacKey:\n\t\tm.ResetHmacKey()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown AuthRequest field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *AuthRequestMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *AuthRequestMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *AuthRequestMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *AuthRequestMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *AuthRequestMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *AuthRequestMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *AuthRequestMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthRequest unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *AuthRequestMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown AuthRequest edge %s\", name)\n}\n\n// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.\ntype ConnectorMutation struct {\n\tconfig\n\top               Op\n\ttyp              string\n\tid               *string\n\t_type            *string\n\tname             *string\n\tresource_version *string\n\t_config          *[]byte\n\tclearedFields    map[string]struct{}\n\tdone             bool\n\toldValue         func(context.Context) (*Connector, error)\n\tpredicates       []predicate.Connector\n}\n\nvar _ ent.Mutation = (*ConnectorMutation)(nil)\n\n// connectorOption allows management of the mutation configuration using functional options.\ntype connectorOption func(*ConnectorMutation)\n\n// newConnectorMutation creates new mutation for the Connector entity.\nfunc newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {\n\tm := &ConnectorMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeConnector,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withConnectorID sets the ID field of the mutation.\nfunc withConnectorID(id string) connectorOption {\n\treturn func(m *ConnectorMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Connector\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Connector, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Connector.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withConnector sets the old Connector of the mutation.\nfunc withConnector(node *Connector) connectorOption {\n\treturn func(m *ConnectorMutation) {\n\t\tm.oldValue = func(context.Context) (*Connector, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m ConnectorMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m ConnectorMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of Connector entities.\nfunc (m *ConnectorMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *ConnectorMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *ConnectorMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetType sets the \"type\" field.\nfunc (m *ConnectorMutation) SetType(s string) {\n\tm._type = &s\n}\n\n// GetType returns the value of the \"type\" field in the mutation.\nfunc (m *ConnectorMutation) GetType() (r string, exists bool) {\n\tv := m._type\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldType returns the old \"type\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldType(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldType is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldType requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldType: %w\", err)\n\t}\n\treturn oldValue.Type, nil\n}\n\n// ResetType resets all changes to the \"type\" field.\nfunc (m *ConnectorMutation) ResetType() {\n\tm._type = nil\n}\n\n// SetName sets the \"name\" field.\nfunc (m *ConnectorMutation) SetName(s string) {\n\tm.name = &s\n}\n\n// Name returns the value of the \"name\" field in the mutation.\nfunc (m *ConnectorMutation) Name() (r string, exists bool) {\n\tv := m.name\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldName returns the old \"name\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldName(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldName is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldName requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldName: %w\", err)\n\t}\n\treturn oldValue.Name, nil\n}\n\n// ResetName resets all changes to the \"name\" field.\nfunc (m *ConnectorMutation) ResetName() {\n\tm.name = nil\n}\n\n// SetResourceVersion sets the \"resource_version\" field.\nfunc (m *ConnectorMutation) SetResourceVersion(s string) {\n\tm.resource_version = &s\n}\n\n// ResourceVersion returns the value of the \"resource_version\" field in the mutation.\nfunc (m *ConnectorMutation) ResourceVersion() (r string, exists bool) {\n\tv := m.resource_version\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldResourceVersion returns the old \"resource_version\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldResourceVersion(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldResourceVersion is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldResourceVersion requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldResourceVersion: %w\", err)\n\t}\n\treturn oldValue.ResourceVersion, nil\n}\n\n// ResetResourceVersion resets all changes to the \"resource_version\" field.\nfunc (m *ConnectorMutation) ResetResourceVersion() {\n\tm.resource_version = nil\n}\n\n// SetConfig sets the \"config\" field.\nfunc (m *ConnectorMutation) SetConfig(b []byte) {\n\tm._config = &b\n}\n\n// Config returns the value of the \"config\" field in the mutation.\nfunc (m *ConnectorMutation) Config() (r []byte, exists bool) {\n\tv := m._config\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConfig returns the old \"config\" field's value of the Connector entity.\n// If the Connector object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *ConnectorMutation) OldConfig(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConfig is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConfig requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConfig: %w\", err)\n\t}\n\treturn oldValue.Config, nil\n}\n\n// ResetConfig resets all changes to the \"config\" field.\nfunc (m *ConnectorMutation) ResetConfig() {\n\tm._config = nil\n}\n\n// Where appends a list predicates to the ConnectorMutation builder.\nfunc (m *ConnectorMutation) Where(ps ...predicate.Connector) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *ConnectorMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (Connector).\nfunc (m *ConnectorMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *ConnectorMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m._type != nil {\n\t\tfields = append(fields, connector.FieldType)\n\t}\n\tif m.name != nil {\n\t\tfields = append(fields, connector.FieldName)\n\t}\n\tif m.resource_version != nil {\n\t\tfields = append(fields, connector.FieldResourceVersion)\n\t}\n\tif m._config != nil {\n\t\tfields = append(fields, connector.FieldConfig)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *ConnectorMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase connector.FieldType:\n\t\treturn m.GetType()\n\tcase connector.FieldName:\n\t\treturn m.Name()\n\tcase connector.FieldResourceVersion:\n\t\treturn m.ResourceVersion()\n\tcase connector.FieldConfig:\n\t\treturn m.Config()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase connector.FieldType:\n\t\treturn m.OldType(ctx)\n\tcase connector.FieldName:\n\t\treturn m.OldName(ctx)\n\tcase connector.FieldResourceVersion:\n\t\treturn m.OldResourceVersion(ctx)\n\tcase connector.FieldConfig:\n\t\treturn m.OldConfig(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown Connector field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *ConnectorMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase connector.FieldType:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetType(v)\n\t\treturn nil\n\tcase connector.FieldName:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetName(v)\n\t\treturn nil\n\tcase connector.FieldResourceVersion:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetResourceVersion(v)\n\t\treturn nil\n\tcase connector.FieldConfig:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConfig(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Connector field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *ConnectorMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *ConnectorMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown Connector numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *ConnectorMutation) ClearedFields() []string {\n\treturn nil\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *ConnectorMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *ConnectorMutation) ClearField(name string) error {\n\treturn fmt.Errorf(\"unknown Connector nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *ConnectorMutation) ResetField(name string) error {\n\tswitch name {\n\tcase connector.FieldType:\n\t\tm.ResetType()\n\t\treturn nil\n\tcase connector.FieldName:\n\t\tm.ResetName()\n\t\treturn nil\n\tcase connector.FieldResourceVersion:\n\t\tm.ResetResourceVersion()\n\t\treturn nil\n\tcase connector.FieldConfig:\n\t\tm.ResetConfig()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Connector field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *ConnectorMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *ConnectorMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *ConnectorMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *ConnectorMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *ConnectorMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *ConnectorMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Connector unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *ConnectorMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Connector edge %s\", name)\n}\n\n// DeviceRequestMutation represents an operation that mutates the DeviceRequest nodes in the graph.\ntype DeviceRequestMutation struct {\n\tconfig\n\top            Op\n\ttyp           string\n\tid            *int\n\tuser_code     *string\n\tdevice_code   *string\n\tclient_id     *string\n\tclient_secret *string\n\tscopes        *[]string\n\texpiry        *time.Time\n\tclearedFields map[string]struct{}\n\tdone          bool\n\toldValue      func(context.Context) (*DeviceRequest, error)\n\tpredicates    []predicate.DeviceRequest\n}\n\nvar _ ent.Mutation = (*DeviceRequestMutation)(nil)\n\n// devicerequestOption allows management of the mutation configuration using functional options.\ntype devicerequestOption func(*DeviceRequestMutation)\n\n// newDeviceRequestMutation creates new mutation for the DeviceRequest entity.\nfunc newDeviceRequestMutation(c config, op Op, opts ...devicerequestOption) *DeviceRequestMutation {\n\tm := &DeviceRequestMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeDeviceRequest,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withDeviceRequestID sets the ID field of the mutation.\nfunc withDeviceRequestID(id int) devicerequestOption {\n\treturn func(m *DeviceRequestMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *DeviceRequest\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*DeviceRequest, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().DeviceRequest.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withDeviceRequest sets the old DeviceRequest of the mutation.\nfunc withDeviceRequest(node *DeviceRequest) devicerequestOption {\n\treturn func(m *DeviceRequestMutation) {\n\t\tm.oldValue = func(context.Context) (*DeviceRequest, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m DeviceRequestMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m DeviceRequestMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *DeviceRequestMutation) ID() (id int, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *DeviceRequestMutation) IDs(ctx context.Context) ([]int, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []int{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().DeviceRequest.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetUserCode sets the \"user_code\" field.\nfunc (m *DeviceRequestMutation) SetUserCode(s string) {\n\tm.user_code = &s\n}\n\n// UserCode returns the value of the \"user_code\" field in the mutation.\nfunc (m *DeviceRequestMutation) UserCode() (r string, exists bool) {\n\tv := m.user_code\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUserCode returns the old \"user_code\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldUserCode(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUserCode is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUserCode requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUserCode: %w\", err)\n\t}\n\treturn oldValue.UserCode, nil\n}\n\n// ResetUserCode resets all changes to the \"user_code\" field.\nfunc (m *DeviceRequestMutation) ResetUserCode() {\n\tm.user_code = nil\n}\n\n// SetDeviceCode sets the \"device_code\" field.\nfunc (m *DeviceRequestMutation) SetDeviceCode(s string) {\n\tm.device_code = &s\n}\n\n// DeviceCode returns the value of the \"device_code\" field in the mutation.\nfunc (m *DeviceRequestMutation) DeviceCode() (r string, exists bool) {\n\tv := m.device_code\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldDeviceCode returns the old \"device_code\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldDeviceCode(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldDeviceCode is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldDeviceCode requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldDeviceCode: %w\", err)\n\t}\n\treturn oldValue.DeviceCode, nil\n}\n\n// ResetDeviceCode resets all changes to the \"device_code\" field.\nfunc (m *DeviceRequestMutation) ResetDeviceCode() {\n\tm.device_code = nil\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *DeviceRequestMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *DeviceRequestMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *DeviceRequestMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetClientSecret sets the \"client_secret\" field.\nfunc (m *DeviceRequestMutation) SetClientSecret(s string) {\n\tm.client_secret = &s\n}\n\n// ClientSecret returns the value of the \"client_secret\" field in the mutation.\nfunc (m *DeviceRequestMutation) ClientSecret() (r string, exists bool) {\n\tv := m.client_secret\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientSecret returns the old \"client_secret\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldClientSecret(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientSecret is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientSecret requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientSecret: %w\", err)\n\t}\n\treturn oldValue.ClientSecret, nil\n}\n\n// ResetClientSecret resets all changes to the \"client_secret\" field.\nfunc (m *DeviceRequestMutation) ResetClientSecret() {\n\tm.client_secret = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *DeviceRequestMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *DeviceRequestMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *DeviceRequestMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[devicerequest.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *DeviceRequestMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[devicerequest.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *DeviceRequestMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, devicerequest.FieldScopes)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *DeviceRequestMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *DeviceRequestMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the DeviceRequest entity.\n// If the DeviceRequest object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceRequestMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *DeviceRequestMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// Where appends a list predicates to the DeviceRequestMutation builder.\nfunc (m *DeviceRequestMutation) Where(ps ...predicate.DeviceRequest) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *DeviceRequestMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (DeviceRequest).\nfunc (m *DeviceRequestMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *DeviceRequestMutation) Fields() []string {\n\tfields := make([]string, 0, 6)\n\tif m.user_code != nil {\n\t\tfields = append(fields, devicerequest.FieldUserCode)\n\t}\n\tif m.device_code != nil {\n\t\tfields = append(fields, devicerequest.FieldDeviceCode)\n\t}\n\tif m.client_id != nil {\n\t\tfields = append(fields, devicerequest.FieldClientID)\n\t}\n\tif m.client_secret != nil {\n\t\tfields = append(fields, devicerequest.FieldClientSecret)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, devicerequest.FieldScopes)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, devicerequest.FieldExpiry)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *DeviceRequestMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\treturn m.UserCode()\n\tcase devicerequest.FieldDeviceCode:\n\t\treturn m.DeviceCode()\n\tcase devicerequest.FieldClientID:\n\t\treturn m.ClientID()\n\tcase devicerequest.FieldClientSecret:\n\t\treturn m.ClientSecret()\n\tcase devicerequest.FieldScopes:\n\t\treturn m.Scopes()\n\tcase devicerequest.FieldExpiry:\n\t\treturn m.Expiry()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *DeviceRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\treturn m.OldUserCode(ctx)\n\tcase devicerequest.FieldDeviceCode:\n\t\treturn m.OldDeviceCode(ctx)\n\tcase devicerequest.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase devicerequest.FieldClientSecret:\n\t\treturn m.OldClientSecret(ctx)\n\tcase devicerequest.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase devicerequest.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown DeviceRequest field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceRequestMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUserCode(v)\n\t\treturn nil\n\tcase devicerequest.FieldDeviceCode:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetDeviceCode(v)\n\t\treturn nil\n\tcase devicerequest.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase devicerequest.FieldClientSecret:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientSecret(v)\n\t\treturn nil\n\tcase devicerequest.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase devicerequest.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *DeviceRequestMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *DeviceRequestMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceRequestMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *DeviceRequestMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(devicerequest.FieldScopes) {\n\t\tfields = append(fields, devicerequest.FieldScopes)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *DeviceRequestMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *DeviceRequestMutation) ClearField(name string) error {\n\tswitch name {\n\tcase devicerequest.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *DeviceRequestMutation) ResetField(name string) error {\n\tswitch name {\n\tcase devicerequest.FieldUserCode:\n\t\tm.ResetUserCode()\n\t\treturn nil\n\tcase devicerequest.FieldDeviceCode:\n\t\tm.ResetDeviceCode()\n\t\treturn nil\n\tcase devicerequest.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase devicerequest.FieldClientSecret:\n\t\tm.ResetClientSecret()\n\t\treturn nil\n\tcase devicerequest.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase devicerequest.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceRequest field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *DeviceRequestMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *DeviceRequestMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *DeviceRequestMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *DeviceRequestMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *DeviceRequestMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *DeviceRequestMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *DeviceRequestMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceRequest unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *DeviceRequestMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceRequest edge %s\", name)\n}\n\n// DeviceTokenMutation represents an operation that mutates the DeviceToken nodes in the graph.\ntype DeviceTokenMutation struct {\n\tconfig\n\top                    Op\n\ttyp                   string\n\tid                    *int\n\tdevice_code           *string\n\tstatus                *string\n\ttoken                 *[]byte\n\texpiry                *time.Time\n\tlast_request          *time.Time\n\tpoll_interval         *int\n\taddpoll_interval      *int\n\tcode_challenge        *string\n\tcode_challenge_method *string\n\tclearedFields         map[string]struct{}\n\tdone                  bool\n\toldValue              func(context.Context) (*DeviceToken, error)\n\tpredicates            []predicate.DeviceToken\n}\n\nvar _ ent.Mutation = (*DeviceTokenMutation)(nil)\n\n// devicetokenOption allows management of the mutation configuration using functional options.\ntype devicetokenOption func(*DeviceTokenMutation)\n\n// newDeviceTokenMutation creates new mutation for the DeviceToken entity.\nfunc newDeviceTokenMutation(c config, op Op, opts ...devicetokenOption) *DeviceTokenMutation {\n\tm := &DeviceTokenMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeDeviceToken,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withDeviceTokenID sets the ID field of the mutation.\nfunc withDeviceTokenID(id int) devicetokenOption {\n\treturn func(m *DeviceTokenMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *DeviceToken\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*DeviceToken, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().DeviceToken.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withDeviceToken sets the old DeviceToken of the mutation.\nfunc withDeviceToken(node *DeviceToken) devicetokenOption {\n\treturn func(m *DeviceTokenMutation) {\n\t\tm.oldValue = func(context.Context) (*DeviceToken, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m DeviceTokenMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m DeviceTokenMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *DeviceTokenMutation) ID() (id int, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *DeviceTokenMutation) IDs(ctx context.Context) ([]int, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []int{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().DeviceToken.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetDeviceCode sets the \"device_code\" field.\nfunc (m *DeviceTokenMutation) SetDeviceCode(s string) {\n\tm.device_code = &s\n}\n\n// DeviceCode returns the value of the \"device_code\" field in the mutation.\nfunc (m *DeviceTokenMutation) DeviceCode() (r string, exists bool) {\n\tv := m.device_code\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldDeviceCode returns the old \"device_code\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldDeviceCode(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldDeviceCode is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldDeviceCode requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldDeviceCode: %w\", err)\n\t}\n\treturn oldValue.DeviceCode, nil\n}\n\n// ResetDeviceCode resets all changes to the \"device_code\" field.\nfunc (m *DeviceTokenMutation) ResetDeviceCode() {\n\tm.device_code = nil\n}\n\n// SetStatus sets the \"status\" field.\nfunc (m *DeviceTokenMutation) SetStatus(s string) {\n\tm.status = &s\n}\n\n// Status returns the value of the \"status\" field in the mutation.\nfunc (m *DeviceTokenMutation) Status() (r string, exists bool) {\n\tv := m.status\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldStatus returns the old \"status\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldStatus(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldStatus is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldStatus requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldStatus: %w\", err)\n\t}\n\treturn oldValue.Status, nil\n}\n\n// ResetStatus resets all changes to the \"status\" field.\nfunc (m *DeviceTokenMutation) ResetStatus() {\n\tm.status = nil\n}\n\n// SetToken sets the \"token\" field.\nfunc (m *DeviceTokenMutation) SetToken(b []byte) {\n\tm.token = &b\n}\n\n// Token returns the value of the \"token\" field in the mutation.\nfunc (m *DeviceTokenMutation) Token() (r []byte, exists bool) {\n\tv := m.token\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldToken returns the old \"token\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldToken(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldToken is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldToken requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldToken: %w\", err)\n\t}\n\treturn oldValue.Token, nil\n}\n\n// ClearToken clears the value of the \"token\" field.\nfunc (m *DeviceTokenMutation) ClearToken() {\n\tm.token = nil\n\tm.clearedFields[devicetoken.FieldToken] = struct{}{}\n}\n\n// TokenCleared returns if the \"token\" field was cleared in this mutation.\nfunc (m *DeviceTokenMutation) TokenCleared() bool {\n\t_, ok := m.clearedFields[devicetoken.FieldToken]\n\treturn ok\n}\n\n// ResetToken resets all changes to the \"token\" field.\nfunc (m *DeviceTokenMutation) ResetToken() {\n\tm.token = nil\n\tdelete(m.clearedFields, devicetoken.FieldToken)\n}\n\n// SetExpiry sets the \"expiry\" field.\nfunc (m *DeviceTokenMutation) SetExpiry(t time.Time) {\n\tm.expiry = &t\n}\n\n// Expiry returns the value of the \"expiry\" field in the mutation.\nfunc (m *DeviceTokenMutation) Expiry() (r time.Time, exists bool) {\n\tv := m.expiry\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldExpiry returns the old \"expiry\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldExpiry is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldExpiry requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldExpiry: %w\", err)\n\t}\n\treturn oldValue.Expiry, nil\n}\n\n// ResetExpiry resets all changes to the \"expiry\" field.\nfunc (m *DeviceTokenMutation) ResetExpiry() {\n\tm.expiry = nil\n}\n\n// SetLastRequest sets the \"last_request\" field.\nfunc (m *DeviceTokenMutation) SetLastRequest(t time.Time) {\n\tm.last_request = &t\n}\n\n// LastRequest returns the value of the \"last_request\" field in the mutation.\nfunc (m *DeviceTokenMutation) LastRequest() (r time.Time, exists bool) {\n\tv := m.last_request\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLastRequest returns the old \"last_request\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldLastRequest(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLastRequest is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLastRequest requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLastRequest: %w\", err)\n\t}\n\treturn oldValue.LastRequest, nil\n}\n\n// ResetLastRequest resets all changes to the \"last_request\" field.\nfunc (m *DeviceTokenMutation) ResetLastRequest() {\n\tm.last_request = nil\n}\n\n// SetPollInterval sets the \"poll_interval\" field.\nfunc (m *DeviceTokenMutation) SetPollInterval(i int) {\n\tm.poll_interval = &i\n\tm.addpoll_interval = nil\n}\n\n// PollInterval returns the value of the \"poll_interval\" field in the mutation.\nfunc (m *DeviceTokenMutation) PollInterval() (r int, exists bool) {\n\tv := m.poll_interval\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldPollInterval returns the old \"poll_interval\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldPollInterval(ctx context.Context) (v int, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldPollInterval is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldPollInterval requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldPollInterval: %w\", err)\n\t}\n\treturn oldValue.PollInterval, nil\n}\n\n// AddPollInterval adds i to the \"poll_interval\" field.\nfunc (m *DeviceTokenMutation) AddPollInterval(i int) {\n\tif m.addpoll_interval != nil {\n\t\t*m.addpoll_interval += i\n\t} else {\n\t\tm.addpoll_interval = &i\n\t}\n}\n\n// AddedPollInterval returns the value that was added to the \"poll_interval\" field in this mutation.\nfunc (m *DeviceTokenMutation) AddedPollInterval() (r int, exists bool) {\n\tv := m.addpoll_interval\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// ResetPollInterval resets all changes to the \"poll_interval\" field.\nfunc (m *DeviceTokenMutation) ResetPollInterval() {\n\tm.poll_interval = nil\n\tm.addpoll_interval = nil\n}\n\n// SetCodeChallenge sets the \"code_challenge\" field.\nfunc (m *DeviceTokenMutation) SetCodeChallenge(s string) {\n\tm.code_challenge = &s\n}\n\n// CodeChallenge returns the value of the \"code_challenge\" field in the mutation.\nfunc (m *DeviceTokenMutation) CodeChallenge() (r string, exists bool) {\n\tv := m.code_challenge\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallenge returns the old \"code_challenge\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallenge is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallenge requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallenge: %w\", err)\n\t}\n\treturn oldValue.CodeChallenge, nil\n}\n\n// ResetCodeChallenge resets all changes to the \"code_challenge\" field.\nfunc (m *DeviceTokenMutation) ResetCodeChallenge() {\n\tm.code_challenge = nil\n}\n\n// SetCodeChallengeMethod sets the \"code_challenge_method\" field.\nfunc (m *DeviceTokenMutation) SetCodeChallengeMethod(s string) {\n\tm.code_challenge_method = &s\n}\n\n// CodeChallengeMethod returns the value of the \"code_challenge_method\" field in the mutation.\nfunc (m *DeviceTokenMutation) CodeChallengeMethod() (r string, exists bool) {\n\tv := m.code_challenge_method\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCodeChallengeMethod returns the old \"code_challenge_method\" field's value of the DeviceToken entity.\n// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *DeviceTokenMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCodeChallengeMethod requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCodeChallengeMethod: %w\", err)\n\t}\n\treturn oldValue.CodeChallengeMethod, nil\n}\n\n// ResetCodeChallengeMethod resets all changes to the \"code_challenge_method\" field.\nfunc (m *DeviceTokenMutation) ResetCodeChallengeMethod() {\n\tm.code_challenge_method = nil\n}\n\n// Where appends a list predicates to the DeviceTokenMutation builder.\nfunc (m *DeviceTokenMutation) Where(ps ...predicate.DeviceToken) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *DeviceTokenMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (DeviceToken).\nfunc (m *DeviceTokenMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *DeviceTokenMutation) Fields() []string {\n\tfields := make([]string, 0, 8)\n\tif m.device_code != nil {\n\t\tfields = append(fields, devicetoken.FieldDeviceCode)\n\t}\n\tif m.status != nil {\n\t\tfields = append(fields, devicetoken.FieldStatus)\n\t}\n\tif m.token != nil {\n\t\tfields = append(fields, devicetoken.FieldToken)\n\t}\n\tif m.expiry != nil {\n\t\tfields = append(fields, devicetoken.FieldExpiry)\n\t}\n\tif m.last_request != nil {\n\t\tfields = append(fields, devicetoken.FieldLastRequest)\n\t}\n\tif m.poll_interval != nil {\n\t\tfields = append(fields, devicetoken.FieldPollInterval)\n\t}\n\tif m.code_challenge != nil {\n\t\tfields = append(fields, devicetoken.FieldCodeChallenge)\n\t}\n\tif m.code_challenge_method != nil {\n\t\tfields = append(fields, devicetoken.FieldCodeChallengeMethod)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *DeviceTokenMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\treturn m.DeviceCode()\n\tcase devicetoken.FieldStatus:\n\t\treturn m.Status()\n\tcase devicetoken.FieldToken:\n\t\treturn m.Token()\n\tcase devicetoken.FieldExpiry:\n\t\treturn m.Expiry()\n\tcase devicetoken.FieldLastRequest:\n\t\treturn m.LastRequest()\n\tcase devicetoken.FieldPollInterval:\n\t\treturn m.PollInterval()\n\tcase devicetoken.FieldCodeChallenge:\n\t\treturn m.CodeChallenge()\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\treturn m.CodeChallengeMethod()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *DeviceTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\treturn m.OldDeviceCode(ctx)\n\tcase devicetoken.FieldStatus:\n\t\treturn m.OldStatus(ctx)\n\tcase devicetoken.FieldToken:\n\t\treturn m.OldToken(ctx)\n\tcase devicetoken.FieldExpiry:\n\t\treturn m.OldExpiry(ctx)\n\tcase devicetoken.FieldLastRequest:\n\t\treturn m.OldLastRequest(ctx)\n\tcase devicetoken.FieldPollInterval:\n\t\treturn m.OldPollInterval(ctx)\n\tcase devicetoken.FieldCodeChallenge:\n\t\treturn m.OldCodeChallenge(ctx)\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\treturn m.OldCodeChallengeMethod(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown DeviceToken field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceTokenMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetDeviceCode(v)\n\t\treturn nil\n\tcase devicetoken.FieldStatus:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetStatus(v)\n\t\treturn nil\n\tcase devicetoken.FieldToken:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetToken(v)\n\t\treturn nil\n\tcase devicetoken.FieldExpiry:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetExpiry(v)\n\t\treturn nil\n\tcase devicetoken.FieldLastRequest:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLastRequest(v)\n\t\treturn nil\n\tcase devicetoken.FieldPollInterval:\n\t\tv, ok := value.(int)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetPollInterval(v)\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallenge:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallenge(v)\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCodeChallengeMethod(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *DeviceTokenMutation) AddedFields() []string {\n\tvar fields []string\n\tif m.addpoll_interval != nil {\n\t\tfields = append(fields, devicetoken.FieldPollInterval)\n\t}\n\treturn fields\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *DeviceTokenMutation) AddedField(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase devicetoken.FieldPollInterval:\n\t\treturn m.AddedPollInterval()\n\t}\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *DeviceTokenMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\tcase devicetoken.FieldPollInterval:\n\t\tv, ok := value.(int)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.AddPollInterval(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *DeviceTokenMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(devicetoken.FieldToken) {\n\t\tfields = append(fields, devicetoken.FieldToken)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *DeviceTokenMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *DeviceTokenMutation) ClearField(name string) error {\n\tswitch name {\n\tcase devicetoken.FieldToken:\n\t\tm.ClearToken()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *DeviceTokenMutation) ResetField(name string) error {\n\tswitch name {\n\tcase devicetoken.FieldDeviceCode:\n\t\tm.ResetDeviceCode()\n\t\treturn nil\n\tcase devicetoken.FieldStatus:\n\t\tm.ResetStatus()\n\t\treturn nil\n\tcase devicetoken.FieldToken:\n\t\tm.ResetToken()\n\t\treturn nil\n\tcase devicetoken.FieldExpiry:\n\t\tm.ResetExpiry()\n\t\treturn nil\n\tcase devicetoken.FieldLastRequest:\n\t\tm.ResetLastRequest()\n\t\treturn nil\n\tcase devicetoken.FieldPollInterval:\n\t\tm.ResetPollInterval()\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallenge:\n\t\tm.ResetCodeChallenge()\n\t\treturn nil\n\tcase devicetoken.FieldCodeChallengeMethod:\n\t\tm.ResetCodeChallengeMethod()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown DeviceToken field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *DeviceTokenMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *DeviceTokenMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *DeviceTokenMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *DeviceTokenMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *DeviceTokenMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *DeviceTokenMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *DeviceTokenMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceToken unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *DeviceTokenMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown DeviceToken edge %s\", name)\n}\n\n// KeysMutation represents an operation that mutates the Keys nodes in the graph.\ntype KeysMutation struct {\n\tconfig\n\top                Op\n\ttyp               string\n\tid                *string\n\tverification_keys *[]storage.VerificationKey\n\tsigning_key       *jose.JSONWebKey\n\tsigning_key_pub   *jose.JSONWebKey\n\tnext_rotation     *time.Time\n\tclearedFields     map[string]struct{}\n\tdone              bool\n\toldValue          func(context.Context) (*Keys, error)\n\tpredicates        []predicate.Keys\n}\n\nvar _ ent.Mutation = (*KeysMutation)(nil)\n\n// keysOption allows management of the mutation configuration using functional options.\ntype keysOption func(*KeysMutation)\n\n// newKeysMutation creates new mutation for the Keys entity.\nfunc newKeysMutation(c config, op Op, opts ...keysOption) *KeysMutation {\n\tm := &KeysMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeKeys,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withKeysID sets the ID field of the mutation.\nfunc withKeysID(id string) keysOption {\n\treturn func(m *KeysMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Keys\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Keys, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Keys.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withKeys sets the old Keys of the mutation.\nfunc withKeys(node *Keys) keysOption {\n\treturn func(m *KeysMutation) {\n\t\tm.oldValue = func(context.Context) (*Keys, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m KeysMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m KeysMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of Keys entities.\nfunc (m *KeysMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *KeysMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *KeysMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().Keys.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetVerificationKeys sets the \"verification_keys\" field.\nfunc (m *KeysMutation) SetVerificationKeys(sk []storage.VerificationKey) {\n\tm.verification_keys = &sk\n}\n\n// VerificationKeys returns the value of the \"verification_keys\" field in the mutation.\nfunc (m *KeysMutation) VerificationKeys() (r []storage.VerificationKey, exists bool) {\n\tv := m.verification_keys\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldVerificationKeys returns the old \"verification_keys\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldVerificationKeys(ctx context.Context) (v []storage.VerificationKey, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldVerificationKeys is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldVerificationKeys requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldVerificationKeys: %w\", err)\n\t}\n\treturn oldValue.VerificationKeys, nil\n}\n\n// ResetVerificationKeys resets all changes to the \"verification_keys\" field.\nfunc (m *KeysMutation) ResetVerificationKeys() {\n\tm.verification_keys = nil\n}\n\n// SetSigningKey sets the \"signing_key\" field.\nfunc (m *KeysMutation) SetSigningKey(jwk jose.JSONWebKey) {\n\tm.signing_key = &jwk\n}\n\n// SigningKey returns the value of the \"signing_key\" field in the mutation.\nfunc (m *KeysMutation) SigningKey() (r jose.JSONWebKey, exists bool) {\n\tv := m.signing_key\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldSigningKey returns the old \"signing_key\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldSigningKey(ctx context.Context) (v jose.JSONWebKey, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldSigningKey is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldSigningKey requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldSigningKey: %w\", err)\n\t}\n\treturn oldValue.SigningKey, nil\n}\n\n// ResetSigningKey resets all changes to the \"signing_key\" field.\nfunc (m *KeysMutation) ResetSigningKey() {\n\tm.signing_key = nil\n}\n\n// SetSigningKeyPub sets the \"signing_key_pub\" field.\nfunc (m *KeysMutation) SetSigningKeyPub(jwk jose.JSONWebKey) {\n\tm.signing_key_pub = &jwk\n}\n\n// SigningKeyPub returns the value of the \"signing_key_pub\" field in the mutation.\nfunc (m *KeysMutation) SigningKeyPub() (r jose.JSONWebKey, exists bool) {\n\tv := m.signing_key_pub\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldSigningKeyPub returns the old \"signing_key_pub\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldSigningKeyPub(ctx context.Context) (v jose.JSONWebKey, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldSigningKeyPub is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldSigningKeyPub requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldSigningKeyPub: %w\", err)\n\t}\n\treturn oldValue.SigningKeyPub, nil\n}\n\n// ResetSigningKeyPub resets all changes to the \"signing_key_pub\" field.\nfunc (m *KeysMutation) ResetSigningKeyPub() {\n\tm.signing_key_pub = nil\n}\n\n// SetNextRotation sets the \"next_rotation\" field.\nfunc (m *KeysMutation) SetNextRotation(t time.Time) {\n\tm.next_rotation = &t\n}\n\n// NextRotation returns the value of the \"next_rotation\" field in the mutation.\nfunc (m *KeysMutation) NextRotation() (r time.Time, exists bool) {\n\tv := m.next_rotation\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNextRotation returns the old \"next_rotation\" field's value of the Keys entity.\n// If the Keys object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *KeysMutation) OldNextRotation(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNextRotation is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNextRotation requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNextRotation: %w\", err)\n\t}\n\treturn oldValue.NextRotation, nil\n}\n\n// ResetNextRotation resets all changes to the \"next_rotation\" field.\nfunc (m *KeysMutation) ResetNextRotation() {\n\tm.next_rotation = nil\n}\n\n// Where appends a list predicates to the KeysMutation builder.\nfunc (m *KeysMutation) Where(ps ...predicate.Keys) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *KeysMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (Keys).\nfunc (m *KeysMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *KeysMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m.verification_keys != nil {\n\t\tfields = append(fields, keys.FieldVerificationKeys)\n\t}\n\tif m.signing_key != nil {\n\t\tfields = append(fields, keys.FieldSigningKey)\n\t}\n\tif m.signing_key_pub != nil {\n\t\tfields = append(fields, keys.FieldSigningKeyPub)\n\t}\n\tif m.next_rotation != nil {\n\t\tfields = append(fields, keys.FieldNextRotation)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *KeysMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\treturn m.VerificationKeys()\n\tcase keys.FieldSigningKey:\n\t\treturn m.SigningKey()\n\tcase keys.FieldSigningKeyPub:\n\t\treturn m.SigningKeyPub()\n\tcase keys.FieldNextRotation:\n\t\treturn m.NextRotation()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *KeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\treturn m.OldVerificationKeys(ctx)\n\tcase keys.FieldSigningKey:\n\t\treturn m.OldSigningKey(ctx)\n\tcase keys.FieldSigningKeyPub:\n\t\treturn m.OldSigningKeyPub(ctx)\n\tcase keys.FieldNextRotation:\n\t\treturn m.OldNextRotation(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown Keys field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *KeysMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\tv, ok := value.([]storage.VerificationKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetVerificationKeys(v)\n\t\treturn nil\n\tcase keys.FieldSigningKey:\n\t\tv, ok := value.(jose.JSONWebKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetSigningKey(v)\n\t\treturn nil\n\tcase keys.FieldSigningKeyPub:\n\t\tv, ok := value.(jose.JSONWebKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetSigningKeyPub(v)\n\t\treturn nil\n\tcase keys.FieldNextRotation:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNextRotation(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Keys field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *KeysMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *KeysMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *KeysMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown Keys numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *KeysMutation) ClearedFields() []string {\n\treturn nil\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *KeysMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *KeysMutation) ClearField(name string) error {\n\treturn fmt.Errorf(\"unknown Keys nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *KeysMutation) ResetField(name string) error {\n\tswitch name {\n\tcase keys.FieldVerificationKeys:\n\t\tm.ResetVerificationKeys()\n\t\treturn nil\n\tcase keys.FieldSigningKey:\n\t\tm.ResetSigningKey()\n\t\treturn nil\n\tcase keys.FieldSigningKeyPub:\n\t\tm.ResetSigningKeyPub()\n\t\treturn nil\n\tcase keys.FieldNextRotation:\n\t\tm.ResetNextRotation()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Keys field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *KeysMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *KeysMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *KeysMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *KeysMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *KeysMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *KeysMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *KeysMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Keys unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *KeysMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Keys edge %s\", name)\n}\n\n// OAuth2ClientMutation represents an operation that mutates the OAuth2Client nodes in the graph.\ntype OAuth2ClientMutation struct {\n\tconfig\n\top            Op\n\ttyp           string\n\tid            *string\n\tsecret        *string\n\tredirect_uris *[]string\n\ttrusted_peers *[]string\n\tpublic        *bool\n\tname          *string\n\tlogo_url      *string\n\tclearedFields map[string]struct{}\n\tdone          bool\n\toldValue      func(context.Context) (*OAuth2Client, error)\n\tpredicates    []predicate.OAuth2Client\n}\n\nvar _ ent.Mutation = (*OAuth2ClientMutation)(nil)\n\n// oauth2clientOption allows management of the mutation configuration using functional options.\ntype oauth2clientOption func(*OAuth2ClientMutation)\n\n// newOAuth2ClientMutation creates new mutation for the OAuth2Client entity.\nfunc newOAuth2ClientMutation(c config, op Op, opts ...oauth2clientOption) *OAuth2ClientMutation {\n\tm := &OAuth2ClientMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeOAuth2Client,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withOAuth2ClientID sets the ID field of the mutation.\nfunc withOAuth2ClientID(id string) oauth2clientOption {\n\treturn func(m *OAuth2ClientMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *OAuth2Client\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*OAuth2Client, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().OAuth2Client.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withOAuth2Client sets the old OAuth2Client of the mutation.\nfunc withOAuth2Client(node *OAuth2Client) oauth2clientOption {\n\treturn func(m *OAuth2ClientMutation) {\n\t\tm.oldValue = func(context.Context) (*OAuth2Client, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m OAuth2ClientMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m OAuth2ClientMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of OAuth2Client entities.\nfunc (m *OAuth2ClientMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *OAuth2ClientMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *OAuth2ClientMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().OAuth2Client.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetSecret sets the \"secret\" field.\nfunc (m *OAuth2ClientMutation) SetSecret(s string) {\n\tm.secret = &s\n}\n\n// Secret returns the value of the \"secret\" field in the mutation.\nfunc (m *OAuth2ClientMutation) Secret() (r string, exists bool) {\n\tv := m.secret\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldSecret returns the old \"secret\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldSecret(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldSecret is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldSecret requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldSecret: %w\", err)\n\t}\n\treturn oldValue.Secret, nil\n}\n\n// ResetSecret resets all changes to the \"secret\" field.\nfunc (m *OAuth2ClientMutation) ResetSecret() {\n\tm.secret = nil\n}\n\n// SetRedirectUris sets the \"redirect_uris\" field.\nfunc (m *OAuth2ClientMutation) SetRedirectUris(s []string) {\n\tm.redirect_uris = &s\n}\n\n// RedirectUris returns the value of the \"redirect_uris\" field in the mutation.\nfunc (m *OAuth2ClientMutation) RedirectUris() (r []string, exists bool) {\n\tv := m.redirect_uris\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRedirectUris returns the old \"redirect_uris\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRedirectUris is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRedirectUris requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRedirectUris: %w\", err)\n\t}\n\treturn oldValue.RedirectUris, nil\n}\n\n// ClearRedirectUris clears the value of the \"redirect_uris\" field.\nfunc (m *OAuth2ClientMutation) ClearRedirectUris() {\n\tm.redirect_uris = nil\n\tm.clearedFields[oauth2client.FieldRedirectUris] = struct{}{}\n}\n\n// RedirectUrisCleared returns if the \"redirect_uris\" field was cleared in this mutation.\nfunc (m *OAuth2ClientMutation) RedirectUrisCleared() bool {\n\t_, ok := m.clearedFields[oauth2client.FieldRedirectUris]\n\treturn ok\n}\n\n// ResetRedirectUris resets all changes to the \"redirect_uris\" field.\nfunc (m *OAuth2ClientMutation) ResetRedirectUris() {\n\tm.redirect_uris = nil\n\tdelete(m.clearedFields, oauth2client.FieldRedirectUris)\n}\n\n// SetTrustedPeers sets the \"trusted_peers\" field.\nfunc (m *OAuth2ClientMutation) SetTrustedPeers(s []string) {\n\tm.trusted_peers = &s\n}\n\n// TrustedPeers returns the value of the \"trusted_peers\" field in the mutation.\nfunc (m *OAuth2ClientMutation) TrustedPeers() (r []string, exists bool) {\n\tv := m.trusted_peers\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldTrustedPeers returns the old \"trusted_peers\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldTrustedPeers(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldTrustedPeers is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldTrustedPeers requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldTrustedPeers: %w\", err)\n\t}\n\treturn oldValue.TrustedPeers, nil\n}\n\n// ClearTrustedPeers clears the value of the \"trusted_peers\" field.\nfunc (m *OAuth2ClientMutation) ClearTrustedPeers() {\n\tm.trusted_peers = nil\n\tm.clearedFields[oauth2client.FieldTrustedPeers] = struct{}{}\n}\n\n// TrustedPeersCleared returns if the \"trusted_peers\" field was cleared in this mutation.\nfunc (m *OAuth2ClientMutation) TrustedPeersCleared() bool {\n\t_, ok := m.clearedFields[oauth2client.FieldTrustedPeers]\n\treturn ok\n}\n\n// ResetTrustedPeers resets all changes to the \"trusted_peers\" field.\nfunc (m *OAuth2ClientMutation) ResetTrustedPeers() {\n\tm.trusted_peers = nil\n\tdelete(m.clearedFields, oauth2client.FieldTrustedPeers)\n}\n\n// SetPublic sets the \"public\" field.\nfunc (m *OAuth2ClientMutation) SetPublic(b bool) {\n\tm.public = &b\n}\n\n// Public returns the value of the \"public\" field in the mutation.\nfunc (m *OAuth2ClientMutation) Public() (r bool, exists bool) {\n\tv := m.public\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldPublic returns the old \"public\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldPublic(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldPublic is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldPublic requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldPublic: %w\", err)\n\t}\n\treturn oldValue.Public, nil\n}\n\n// ResetPublic resets all changes to the \"public\" field.\nfunc (m *OAuth2ClientMutation) ResetPublic() {\n\tm.public = nil\n}\n\n// SetName sets the \"name\" field.\nfunc (m *OAuth2ClientMutation) SetName(s string) {\n\tm.name = &s\n}\n\n// Name returns the value of the \"name\" field in the mutation.\nfunc (m *OAuth2ClientMutation) Name() (r string, exists bool) {\n\tv := m.name\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldName returns the old \"name\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldName(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldName is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldName requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldName: %w\", err)\n\t}\n\treturn oldValue.Name, nil\n}\n\n// ResetName resets all changes to the \"name\" field.\nfunc (m *OAuth2ClientMutation) ResetName() {\n\tm.name = nil\n}\n\n// SetLogoURL sets the \"logo_url\" field.\nfunc (m *OAuth2ClientMutation) SetLogoURL(s string) {\n\tm.logo_url = &s\n}\n\n// LogoURL returns the value of the \"logo_url\" field in the mutation.\nfunc (m *OAuth2ClientMutation) LogoURL() (r string, exists bool) {\n\tv := m.logo_url\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLogoURL returns the old \"logo_url\" field's value of the OAuth2Client entity.\n// If the OAuth2Client object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OAuth2ClientMutation) OldLogoURL(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLogoURL is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLogoURL requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLogoURL: %w\", err)\n\t}\n\treturn oldValue.LogoURL, nil\n}\n\n// ResetLogoURL resets all changes to the \"logo_url\" field.\nfunc (m *OAuth2ClientMutation) ResetLogoURL() {\n\tm.logo_url = nil\n}\n\n// Where appends a list predicates to the OAuth2ClientMutation builder.\nfunc (m *OAuth2ClientMutation) Where(ps ...predicate.OAuth2Client) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *OAuth2ClientMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (OAuth2Client).\nfunc (m *OAuth2ClientMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *OAuth2ClientMutation) Fields() []string {\n\tfields := make([]string, 0, 6)\n\tif m.secret != nil {\n\t\tfields = append(fields, oauth2client.FieldSecret)\n\t}\n\tif m.redirect_uris != nil {\n\t\tfields = append(fields, oauth2client.FieldRedirectUris)\n\t}\n\tif m.trusted_peers != nil {\n\t\tfields = append(fields, oauth2client.FieldTrustedPeers)\n\t}\n\tif m.public != nil {\n\t\tfields = append(fields, oauth2client.FieldPublic)\n\t}\n\tif m.name != nil {\n\t\tfields = append(fields, oauth2client.FieldName)\n\t}\n\tif m.logo_url != nil {\n\t\tfields = append(fields, oauth2client.FieldLogoURL)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *OAuth2ClientMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\treturn m.Secret()\n\tcase oauth2client.FieldRedirectUris:\n\t\treturn m.RedirectUris()\n\tcase oauth2client.FieldTrustedPeers:\n\t\treturn m.TrustedPeers()\n\tcase oauth2client.FieldPublic:\n\t\treturn m.Public()\n\tcase oauth2client.FieldName:\n\t\treturn m.Name()\n\tcase oauth2client.FieldLogoURL:\n\t\treturn m.LogoURL()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *OAuth2ClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\treturn m.OldSecret(ctx)\n\tcase oauth2client.FieldRedirectUris:\n\t\treturn m.OldRedirectUris(ctx)\n\tcase oauth2client.FieldTrustedPeers:\n\t\treturn m.OldTrustedPeers(ctx)\n\tcase oauth2client.FieldPublic:\n\t\treturn m.OldPublic(ctx)\n\tcase oauth2client.FieldName:\n\t\treturn m.OldName(ctx)\n\tcase oauth2client.FieldLogoURL:\n\t\treturn m.OldLogoURL(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown OAuth2Client field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OAuth2ClientMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetSecret(v)\n\t\treturn nil\n\tcase oauth2client.FieldRedirectUris:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRedirectUris(v)\n\t\treturn nil\n\tcase oauth2client.FieldTrustedPeers:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetTrustedPeers(v)\n\t\treturn nil\n\tcase oauth2client.FieldPublic:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetPublic(v)\n\t\treturn nil\n\tcase oauth2client.FieldName:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetName(v)\n\t\treturn nil\n\tcase oauth2client.FieldLogoURL:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLogoURL(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *OAuth2ClientMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *OAuth2ClientMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OAuth2ClientMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *OAuth2ClientMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(oauth2client.FieldRedirectUris) {\n\t\tfields = append(fields, oauth2client.FieldRedirectUris)\n\t}\n\tif m.FieldCleared(oauth2client.FieldTrustedPeers) {\n\t\tfields = append(fields, oauth2client.FieldTrustedPeers)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *OAuth2ClientMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ClearField(name string) error {\n\tswitch name {\n\tcase oauth2client.FieldRedirectUris:\n\t\tm.ClearRedirectUris()\n\t\treturn nil\n\tcase oauth2client.FieldTrustedPeers:\n\t\tm.ClearTrustedPeers()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ResetField(name string) error {\n\tswitch name {\n\tcase oauth2client.FieldSecret:\n\t\tm.ResetSecret()\n\t\treturn nil\n\tcase oauth2client.FieldRedirectUris:\n\t\tm.ResetRedirectUris()\n\t\treturn nil\n\tcase oauth2client.FieldTrustedPeers:\n\t\tm.ResetTrustedPeers()\n\t\treturn nil\n\tcase oauth2client.FieldPublic:\n\t\tm.ResetPublic()\n\t\treturn nil\n\tcase oauth2client.FieldName:\n\t\tm.ResetName()\n\t\treturn nil\n\tcase oauth2client.FieldLogoURL:\n\t\tm.ResetLogoURL()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OAuth2Client field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *OAuth2ClientMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *OAuth2ClientMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *OAuth2ClientMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *OAuth2ClientMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *OAuth2ClientMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *OAuth2ClientMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OAuth2Client unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *OAuth2ClientMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OAuth2Client edge %s\", name)\n}\n\n// OfflineSessionMutation represents an operation that mutates the OfflineSession nodes in the graph.\ntype OfflineSessionMutation struct {\n\tconfig\n\top             Op\n\ttyp            string\n\tid             *string\n\tuser_id        *string\n\tconn_id        *string\n\trefresh        *[]byte\n\tconnector_data *[]byte\n\tclearedFields  map[string]struct{}\n\tdone           bool\n\toldValue       func(context.Context) (*OfflineSession, error)\n\tpredicates     []predicate.OfflineSession\n}\n\nvar _ ent.Mutation = (*OfflineSessionMutation)(nil)\n\n// offlinesessionOption allows management of the mutation configuration using functional options.\ntype offlinesessionOption func(*OfflineSessionMutation)\n\n// newOfflineSessionMutation creates new mutation for the OfflineSession entity.\nfunc newOfflineSessionMutation(c config, op Op, opts ...offlinesessionOption) *OfflineSessionMutation {\n\tm := &OfflineSessionMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeOfflineSession,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withOfflineSessionID sets the ID field of the mutation.\nfunc withOfflineSessionID(id string) offlinesessionOption {\n\treturn func(m *OfflineSessionMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *OfflineSession\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*OfflineSession, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().OfflineSession.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withOfflineSession sets the old OfflineSession of the mutation.\nfunc withOfflineSession(node *OfflineSession) offlinesessionOption {\n\treturn func(m *OfflineSessionMutation) {\n\t\tm.oldValue = func(context.Context) (*OfflineSession, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m OfflineSessionMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m OfflineSessionMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of OfflineSession entities.\nfunc (m *OfflineSessionMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *OfflineSessionMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *OfflineSessionMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().OfflineSession.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetUserID sets the \"user_id\" field.\nfunc (m *OfflineSessionMutation) SetUserID(s string) {\n\tm.user_id = &s\n}\n\n// UserID returns the value of the \"user_id\" field in the mutation.\nfunc (m *OfflineSessionMutation) UserID() (r string, exists bool) {\n\tv := m.user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUserID returns the old \"user_id\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUserID: %w\", err)\n\t}\n\treturn oldValue.UserID, nil\n}\n\n// ResetUserID resets all changes to the \"user_id\" field.\nfunc (m *OfflineSessionMutation) ResetUserID() {\n\tm.user_id = nil\n}\n\n// SetConnID sets the \"conn_id\" field.\nfunc (m *OfflineSessionMutation) SetConnID(s string) {\n\tm.conn_id = &s\n}\n\n// ConnID returns the value of the \"conn_id\" field in the mutation.\nfunc (m *OfflineSessionMutation) ConnID() (r string, exists bool) {\n\tv := m.conn_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnID returns the old \"conn_id\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldConnID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnID: %w\", err)\n\t}\n\treturn oldValue.ConnID, nil\n}\n\n// ResetConnID resets all changes to the \"conn_id\" field.\nfunc (m *OfflineSessionMutation) ResetConnID() {\n\tm.conn_id = nil\n}\n\n// SetRefresh sets the \"refresh\" field.\nfunc (m *OfflineSessionMutation) SetRefresh(b []byte) {\n\tm.refresh = &b\n}\n\n// Refresh returns the value of the \"refresh\" field in the mutation.\nfunc (m *OfflineSessionMutation) Refresh() (r []byte, exists bool) {\n\tv := m.refresh\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldRefresh returns the old \"refresh\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldRefresh(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldRefresh is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldRefresh requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldRefresh: %w\", err)\n\t}\n\treturn oldValue.Refresh, nil\n}\n\n// ResetRefresh resets all changes to the \"refresh\" field.\nfunc (m *OfflineSessionMutation) ResetRefresh() {\n\tm.refresh = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *OfflineSessionMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *OfflineSessionMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the OfflineSession entity.\n// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *OfflineSessionMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *OfflineSessionMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[offlinesession.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *OfflineSessionMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[offlinesession.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *OfflineSessionMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, offlinesession.FieldConnectorData)\n}\n\n// Where appends a list predicates to the OfflineSessionMutation builder.\nfunc (m *OfflineSessionMutation) Where(ps ...predicate.OfflineSession) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *OfflineSessionMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (OfflineSession).\nfunc (m *OfflineSessionMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *OfflineSessionMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m.user_id != nil {\n\t\tfields = append(fields, offlinesession.FieldUserID)\n\t}\n\tif m.conn_id != nil {\n\t\tfields = append(fields, offlinesession.FieldConnID)\n\t}\n\tif m.refresh != nil {\n\t\tfields = append(fields, offlinesession.FieldRefresh)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, offlinesession.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *OfflineSessionMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\treturn m.UserID()\n\tcase offlinesession.FieldConnID:\n\t\treturn m.ConnID()\n\tcase offlinesession.FieldRefresh:\n\t\treturn m.Refresh()\n\tcase offlinesession.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *OfflineSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\treturn m.OldUserID(ctx)\n\tcase offlinesession.FieldConnID:\n\t\treturn m.OldConnID(ctx)\n\tcase offlinesession.FieldRefresh:\n\t\treturn m.OldRefresh(ctx)\n\tcase offlinesession.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown OfflineSession field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OfflineSessionMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUserID(v)\n\t\treturn nil\n\tcase offlinesession.FieldConnID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnID(v)\n\t\treturn nil\n\tcase offlinesession.FieldRefresh:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetRefresh(v)\n\t\treturn nil\n\tcase offlinesession.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *OfflineSessionMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *OfflineSessionMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *OfflineSessionMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *OfflineSessionMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(offlinesession.FieldConnectorData) {\n\t\tfields = append(fields, offlinesession.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *OfflineSessionMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *OfflineSessionMutation) ClearField(name string) error {\n\tswitch name {\n\tcase offlinesession.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *OfflineSessionMutation) ResetField(name string) error {\n\tswitch name {\n\tcase offlinesession.FieldUserID:\n\t\tm.ResetUserID()\n\t\treturn nil\n\tcase offlinesession.FieldConnID:\n\t\tm.ResetConnID()\n\t\treturn nil\n\tcase offlinesession.FieldRefresh:\n\t\tm.ResetRefresh()\n\t\treturn nil\n\tcase offlinesession.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown OfflineSession field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *OfflineSessionMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *OfflineSessionMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *OfflineSessionMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *OfflineSessionMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *OfflineSessionMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *OfflineSessionMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *OfflineSessionMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OfflineSession unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *OfflineSessionMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown OfflineSession edge %s\", name)\n}\n\n// PasswordMutation represents an operation that mutates the Password nodes in the graph.\ntype PasswordMutation struct {\n\tconfig\n\top            Op\n\ttyp           string\n\tid            *int\n\temail         *string\n\thash          *[]byte\n\tusername      *string\n\tuser_id       *string\n\tclearedFields map[string]struct{}\n\tdone          bool\n\toldValue      func(context.Context) (*Password, error)\n\tpredicates    []predicate.Password\n}\n\nvar _ ent.Mutation = (*PasswordMutation)(nil)\n\n// passwordOption allows management of the mutation configuration using functional options.\ntype passwordOption func(*PasswordMutation)\n\n// newPasswordMutation creates new mutation for the Password entity.\nfunc newPasswordMutation(c config, op Op, opts ...passwordOption) *PasswordMutation {\n\tm := &PasswordMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypePassword,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withPasswordID sets the ID field of the mutation.\nfunc withPasswordID(id int) passwordOption {\n\treturn func(m *PasswordMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *Password\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*Password, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().Password.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withPassword sets the old Password of the mutation.\nfunc withPassword(node *Password) passwordOption {\n\treturn func(m *PasswordMutation) {\n\t\tm.oldValue = func(context.Context) (*Password, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m PasswordMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m PasswordMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *PasswordMutation) ID() (id int, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *PasswordMutation) IDs(ctx context.Context) ([]int, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []int{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().Password.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetEmail sets the \"email\" field.\nfunc (m *PasswordMutation) SetEmail(s string) {\n\tm.email = &s\n}\n\n// Email returns the value of the \"email\" field in the mutation.\nfunc (m *PasswordMutation) Email() (r string, exists bool) {\n\tv := m.email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldEmail returns the old \"email\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldEmail: %w\", err)\n\t}\n\treturn oldValue.Email, nil\n}\n\n// ResetEmail resets all changes to the \"email\" field.\nfunc (m *PasswordMutation) ResetEmail() {\n\tm.email = nil\n}\n\n// SetHash sets the \"hash\" field.\nfunc (m *PasswordMutation) SetHash(b []byte) {\n\tm.hash = &b\n}\n\n// Hash returns the value of the \"hash\" field in the mutation.\nfunc (m *PasswordMutation) Hash() (r []byte, exists bool) {\n\tv := m.hash\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldHash returns the old \"hash\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldHash(ctx context.Context) (v []byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldHash is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldHash requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldHash: %w\", err)\n\t}\n\treturn oldValue.Hash, nil\n}\n\n// ResetHash resets all changes to the \"hash\" field.\nfunc (m *PasswordMutation) ResetHash() {\n\tm.hash = nil\n}\n\n// SetUsername sets the \"username\" field.\nfunc (m *PasswordMutation) SetUsername(s string) {\n\tm.username = &s\n}\n\n// Username returns the value of the \"username\" field in the mutation.\nfunc (m *PasswordMutation) Username() (r string, exists bool) {\n\tv := m.username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUsername returns the old \"username\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUsername: %w\", err)\n\t}\n\treturn oldValue.Username, nil\n}\n\n// ResetUsername resets all changes to the \"username\" field.\nfunc (m *PasswordMutation) ResetUsername() {\n\tm.username = nil\n}\n\n// SetUserID sets the \"user_id\" field.\nfunc (m *PasswordMutation) SetUserID(s string) {\n\tm.user_id = &s\n}\n\n// UserID returns the value of the \"user_id\" field in the mutation.\nfunc (m *PasswordMutation) UserID() (r string, exists bool) {\n\tv := m.user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldUserID returns the old \"user_id\" field's value of the Password entity.\n// If the Password object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *PasswordMutation) OldUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldUserID: %w\", err)\n\t}\n\treturn oldValue.UserID, nil\n}\n\n// ResetUserID resets all changes to the \"user_id\" field.\nfunc (m *PasswordMutation) ResetUserID() {\n\tm.user_id = nil\n}\n\n// Where appends a list predicates to the PasswordMutation builder.\nfunc (m *PasswordMutation) Where(ps ...predicate.Password) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *PasswordMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (Password).\nfunc (m *PasswordMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *PasswordMutation) Fields() []string {\n\tfields := make([]string, 0, 4)\n\tif m.email != nil {\n\t\tfields = append(fields, password.FieldEmail)\n\t}\n\tif m.hash != nil {\n\t\tfields = append(fields, password.FieldHash)\n\t}\n\tif m.username != nil {\n\t\tfields = append(fields, password.FieldUsername)\n\t}\n\tif m.user_id != nil {\n\t\tfields = append(fields, password.FieldUserID)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *PasswordMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\treturn m.Email()\n\tcase password.FieldHash:\n\t\treturn m.Hash()\n\tcase password.FieldUsername:\n\t\treturn m.Username()\n\tcase password.FieldUserID:\n\t\treturn m.UserID()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *PasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\treturn m.OldEmail(ctx)\n\tcase password.FieldHash:\n\t\treturn m.OldHash(ctx)\n\tcase password.FieldUsername:\n\t\treturn m.OldUsername(ctx)\n\tcase password.FieldUserID:\n\t\treturn m.OldUserID(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown Password field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *PasswordMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetEmail(v)\n\t\treturn nil\n\tcase password.FieldHash:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetHash(v)\n\t\treturn nil\n\tcase password.FieldUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUsername(v)\n\t\treturn nil\n\tcase password.FieldUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetUserID(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Password field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *PasswordMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *PasswordMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *PasswordMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown Password numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *PasswordMutation) ClearedFields() []string {\n\treturn nil\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *PasswordMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *PasswordMutation) ClearField(name string) error {\n\treturn fmt.Errorf(\"unknown Password nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *PasswordMutation) ResetField(name string) error {\n\tswitch name {\n\tcase password.FieldEmail:\n\t\tm.ResetEmail()\n\t\treturn nil\n\tcase password.FieldHash:\n\t\tm.ResetHash()\n\t\treturn nil\n\tcase password.FieldUsername:\n\t\tm.ResetUsername()\n\t\treturn nil\n\tcase password.FieldUserID:\n\t\tm.ResetUserID()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown Password field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *PasswordMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *PasswordMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *PasswordMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *PasswordMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *PasswordMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *PasswordMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *PasswordMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Password unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *PasswordMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown Password edge %s\", name)\n}\n\n// RefreshTokenMutation represents an operation that mutates the RefreshToken nodes in the graph.\ntype RefreshTokenMutation struct {\n\tconfig\n\top                        Op\n\ttyp                       string\n\tid                        *string\n\tclient_id                 *string\n\tscopes                    *[]string\n\tnonce                     *string\n\tclaims_user_id            *string\n\tclaims_username           *string\n\tclaims_email              *string\n\tclaims_email_verified     *bool\n\tclaims_groups             *[]string\n\tclaims_preferred_username *string\n\tconnector_id              *string\n\tconnector_data            *[]byte\n\ttoken                     *string\n\tobsolete_token            *string\n\tcreated_at                *time.Time\n\tlast_used                 *time.Time\n\tclearedFields             map[string]struct{}\n\tdone                      bool\n\toldValue                  func(context.Context) (*RefreshToken, error)\n\tpredicates                []predicate.RefreshToken\n}\n\nvar _ ent.Mutation = (*RefreshTokenMutation)(nil)\n\n// refreshtokenOption allows management of the mutation configuration using functional options.\ntype refreshtokenOption func(*RefreshTokenMutation)\n\n// newRefreshTokenMutation creates new mutation for the RefreshToken entity.\nfunc newRefreshTokenMutation(c config, op Op, opts ...refreshtokenOption) *RefreshTokenMutation {\n\tm := &RefreshTokenMutation{\n\t\tconfig:        c,\n\t\top:            op,\n\t\ttyp:           TypeRefreshToken,\n\t\tclearedFields: make(map[string]struct{}),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}\n\n// withRefreshTokenID sets the ID field of the mutation.\nfunc withRefreshTokenID(id string) refreshtokenOption {\n\treturn func(m *RefreshTokenMutation) {\n\t\tvar (\n\t\t\terr   error\n\t\t\tonce  sync.Once\n\t\t\tvalue *RefreshToken\n\t\t)\n\t\tm.oldValue = func(ctx context.Context) (*RefreshToken, error) {\n\t\t\tonce.Do(func() {\n\t\t\t\tif m.done {\n\t\t\t\t\terr = errors.New(\"querying old values post mutation is not allowed\")\n\t\t\t\t} else {\n\t\t\t\t\tvalue, err = m.Client().RefreshToken.Get(ctx, id)\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn value, err\n\t\t}\n\t\tm.id = &id\n\t}\n}\n\n// withRefreshToken sets the old RefreshToken of the mutation.\nfunc withRefreshToken(node *RefreshToken) refreshtokenOption {\n\treturn func(m *RefreshTokenMutation) {\n\t\tm.oldValue = func(context.Context) (*RefreshToken, error) {\n\t\t\treturn node, nil\n\t\t}\n\t\tm.id = &node.ID\n\t}\n}\n\n// Client returns a new `ent.Client` from the mutation. If the mutation was\n// executed in a transaction (ent.Tx), a transactional client is returned.\nfunc (m RefreshTokenMutation) Client() *Client {\n\tclient := &Client{config: m.config}\n\tclient.init()\n\treturn client\n}\n\n// Tx returns an `ent.Tx` for mutations that were executed in transactions;\n// it returns an error otherwise.\nfunc (m RefreshTokenMutation) Tx() (*Tx, error) {\n\tif _, ok := m.driver.(*txDriver); !ok {\n\t\treturn nil, errors.New(\"db: mutation is not running in a transaction\")\n\t}\n\ttx := &Tx{config: m.config}\n\ttx.init()\n\treturn tx, nil\n}\n\n// SetID sets the value of the id field. Note that this\n// operation is only accepted on creation of RefreshToken entities.\nfunc (m *RefreshTokenMutation) SetID(id string) {\n\tm.id = &id\n}\n\n// ID returns the ID value in the mutation. Note that the ID is only available\n// if it was provided to the builder or after it was returned from the database.\nfunc (m *RefreshTokenMutation) ID() (id string, exists bool) {\n\tif m.id == nil {\n\t\treturn\n\t}\n\treturn *m.id, true\n}\n\n// IDs queries the database and returns the entity ids that match the mutation's predicate.\n// That means, if the mutation is applied within a transaction with an isolation level such\n// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated\n// or updated by the mutation.\nfunc (m *RefreshTokenMutation) IDs(ctx context.Context) ([]string, error) {\n\tswitch {\n\tcase m.op.Is(OpUpdateOne | OpDeleteOne):\n\t\tid, exists := m.ID()\n\t\tif exists {\n\t\t\treturn []string{id}, nil\n\t\t}\n\t\tfallthrough\n\tcase m.op.Is(OpUpdate | OpDelete):\n\t\treturn m.Client().RefreshToken.Query().Where(m.predicates...).IDs(ctx)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"IDs is not allowed on %s operations\", m.op)\n\t}\n}\n\n// SetClientID sets the \"client_id\" field.\nfunc (m *RefreshTokenMutation) SetClientID(s string) {\n\tm.client_id = &s\n}\n\n// ClientID returns the value of the \"client_id\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClientID() (r string, exists bool) {\n\tv := m.client_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClientID returns the old \"client_id\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClientID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClientID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClientID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClientID: %w\", err)\n\t}\n\treturn oldValue.ClientID, nil\n}\n\n// ResetClientID resets all changes to the \"client_id\" field.\nfunc (m *RefreshTokenMutation) ResetClientID() {\n\tm.client_id = nil\n}\n\n// SetScopes sets the \"scopes\" field.\nfunc (m *RefreshTokenMutation) SetScopes(s []string) {\n\tm.scopes = &s\n}\n\n// Scopes returns the value of the \"scopes\" field in the mutation.\nfunc (m *RefreshTokenMutation) Scopes() (r []string, exists bool) {\n\tv := m.scopes\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldScopes returns the old \"scopes\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldScopes is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldScopes requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldScopes: %w\", err)\n\t}\n\treturn oldValue.Scopes, nil\n}\n\n// ClearScopes clears the value of the \"scopes\" field.\nfunc (m *RefreshTokenMutation) ClearScopes() {\n\tm.scopes = nil\n\tm.clearedFields[refreshtoken.FieldScopes] = struct{}{}\n}\n\n// ScopesCleared returns if the \"scopes\" field was cleared in this mutation.\nfunc (m *RefreshTokenMutation) ScopesCleared() bool {\n\t_, ok := m.clearedFields[refreshtoken.FieldScopes]\n\treturn ok\n}\n\n// ResetScopes resets all changes to the \"scopes\" field.\nfunc (m *RefreshTokenMutation) ResetScopes() {\n\tm.scopes = nil\n\tdelete(m.clearedFields, refreshtoken.FieldScopes)\n}\n\n// SetNonce sets the \"nonce\" field.\nfunc (m *RefreshTokenMutation) SetNonce(s string) {\n\tm.nonce = &s\n}\n\n// Nonce returns the value of the \"nonce\" field in the mutation.\nfunc (m *RefreshTokenMutation) Nonce() (r string, exists bool) {\n\tv := m.nonce\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldNonce returns the old \"nonce\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldNonce(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldNonce is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldNonce requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldNonce: %w\", err)\n\t}\n\treturn oldValue.Nonce, nil\n}\n\n// ResetNonce resets all changes to the \"nonce\" field.\nfunc (m *RefreshTokenMutation) ResetNonce() {\n\tm.nonce = nil\n}\n\n// SetClaimsUserID sets the \"claims_user_id\" field.\nfunc (m *RefreshTokenMutation) SetClaimsUserID(s string) {\n\tm.claims_user_id = &s\n}\n\n// ClaimsUserID returns the value of the \"claims_user_id\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsUserID() (r string, exists bool) {\n\tv := m.claims_user_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUserID returns the old \"claims_user_id\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUserID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUserID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUserID: %w\", err)\n\t}\n\treturn oldValue.ClaimsUserID, nil\n}\n\n// ResetClaimsUserID resets all changes to the \"claims_user_id\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsUserID() {\n\tm.claims_user_id = nil\n}\n\n// SetClaimsUsername sets the \"claims_username\" field.\nfunc (m *RefreshTokenMutation) SetClaimsUsername(s string) {\n\tm.claims_username = &s\n}\n\n// ClaimsUsername returns the value of the \"claims_username\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsUsername() (r string, exists bool) {\n\tv := m.claims_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsUsername returns the old \"claims_username\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsUsername, nil\n}\n\n// ResetClaimsUsername resets all changes to the \"claims_username\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsUsername() {\n\tm.claims_username = nil\n}\n\n// SetClaimsEmail sets the \"claims_email\" field.\nfunc (m *RefreshTokenMutation) SetClaimsEmail(s string) {\n\tm.claims_email = &s\n}\n\n// ClaimsEmail returns the value of the \"claims_email\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsEmail() (r string, exists bool) {\n\tv := m.claims_email\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmail returns the old \"claims_email\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmail is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmail requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmail: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmail, nil\n}\n\n// ResetClaimsEmail resets all changes to the \"claims_email\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsEmail() {\n\tm.claims_email = nil\n}\n\n// SetClaimsEmailVerified sets the \"claims_email_verified\" field.\nfunc (m *RefreshTokenMutation) SetClaimsEmailVerified(b bool) {\n\tm.claims_email_verified = &b\n}\n\n// ClaimsEmailVerified returns the value of the \"claims_email_verified\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsEmailVerified() (r bool, exists bool) {\n\tv := m.claims_email_verified\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsEmailVerified returns the old \"claims_email_verified\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsEmailVerified requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsEmailVerified: %w\", err)\n\t}\n\treturn oldValue.ClaimsEmailVerified, nil\n}\n\n// ResetClaimsEmailVerified resets all changes to the \"claims_email_verified\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsEmailVerified() {\n\tm.claims_email_verified = nil\n}\n\n// SetClaimsGroups sets the \"claims_groups\" field.\nfunc (m *RefreshTokenMutation) SetClaimsGroups(s []string) {\n\tm.claims_groups = &s\n}\n\n// ClaimsGroups returns the value of the \"claims_groups\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsGroups() (r []string, exists bool) {\n\tv := m.claims_groups\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsGroups returns the old \"claims_groups\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsGroups is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsGroups requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsGroups: %w\", err)\n\t}\n\treturn oldValue.ClaimsGroups, nil\n}\n\n// ClearClaimsGroups clears the value of the \"claims_groups\" field.\nfunc (m *RefreshTokenMutation) ClearClaimsGroups() {\n\tm.claims_groups = nil\n\tm.clearedFields[refreshtoken.FieldClaimsGroups] = struct{}{}\n}\n\n// ClaimsGroupsCleared returns if the \"claims_groups\" field was cleared in this mutation.\nfunc (m *RefreshTokenMutation) ClaimsGroupsCleared() bool {\n\t_, ok := m.clearedFields[refreshtoken.FieldClaimsGroups]\n\treturn ok\n}\n\n// ResetClaimsGroups resets all changes to the \"claims_groups\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsGroups() {\n\tm.claims_groups = nil\n\tdelete(m.clearedFields, refreshtoken.FieldClaimsGroups)\n}\n\n// SetClaimsPreferredUsername sets the \"claims_preferred_username\" field.\nfunc (m *RefreshTokenMutation) SetClaimsPreferredUsername(s string) {\n\tm.claims_preferred_username = &s\n}\n\n// ClaimsPreferredUsername returns the value of the \"claims_preferred_username\" field in the mutation.\nfunc (m *RefreshTokenMutation) ClaimsPreferredUsername() (r string, exists bool) {\n\tv := m.claims_preferred_username\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldClaimsPreferredUsername returns the old \"claims_preferred_username\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldClaimsPreferredUsername requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldClaimsPreferredUsername: %w\", err)\n\t}\n\treturn oldValue.ClaimsPreferredUsername, nil\n}\n\n// ResetClaimsPreferredUsername resets all changes to the \"claims_preferred_username\" field.\nfunc (m *RefreshTokenMutation) ResetClaimsPreferredUsername() {\n\tm.claims_preferred_username = nil\n}\n\n// SetConnectorID sets the \"connector_id\" field.\nfunc (m *RefreshTokenMutation) SetConnectorID(s string) {\n\tm.connector_id = &s\n}\n\n// ConnectorID returns the value of the \"connector_id\" field in the mutation.\nfunc (m *RefreshTokenMutation) ConnectorID() (r string, exists bool) {\n\tv := m.connector_id\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorID returns the old \"connector_id\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldConnectorID(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorID is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorID requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorID: %w\", err)\n\t}\n\treturn oldValue.ConnectorID, nil\n}\n\n// ResetConnectorID resets all changes to the \"connector_id\" field.\nfunc (m *RefreshTokenMutation) ResetConnectorID() {\n\tm.connector_id = nil\n}\n\n// SetConnectorData sets the \"connector_data\" field.\nfunc (m *RefreshTokenMutation) SetConnectorData(b []byte) {\n\tm.connector_data = &b\n}\n\n// ConnectorData returns the value of the \"connector_data\" field in the mutation.\nfunc (m *RefreshTokenMutation) ConnectorData() (r []byte, exists bool) {\n\tv := m.connector_data\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldConnectorData returns the old \"connector_data\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldConnectorData(ctx context.Context) (v *[]byte, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldConnectorData is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldConnectorData requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldConnectorData: %w\", err)\n\t}\n\treturn oldValue.ConnectorData, nil\n}\n\n// ClearConnectorData clears the value of the \"connector_data\" field.\nfunc (m *RefreshTokenMutation) ClearConnectorData() {\n\tm.connector_data = nil\n\tm.clearedFields[refreshtoken.FieldConnectorData] = struct{}{}\n}\n\n// ConnectorDataCleared returns if the \"connector_data\" field was cleared in this mutation.\nfunc (m *RefreshTokenMutation) ConnectorDataCleared() bool {\n\t_, ok := m.clearedFields[refreshtoken.FieldConnectorData]\n\treturn ok\n}\n\n// ResetConnectorData resets all changes to the \"connector_data\" field.\nfunc (m *RefreshTokenMutation) ResetConnectorData() {\n\tm.connector_data = nil\n\tdelete(m.clearedFields, refreshtoken.FieldConnectorData)\n}\n\n// SetToken sets the \"token\" field.\nfunc (m *RefreshTokenMutation) SetToken(s string) {\n\tm.token = &s\n}\n\n// Token returns the value of the \"token\" field in the mutation.\nfunc (m *RefreshTokenMutation) Token() (r string, exists bool) {\n\tv := m.token\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldToken returns the old \"token\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldToken(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldToken is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldToken requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldToken: %w\", err)\n\t}\n\treturn oldValue.Token, nil\n}\n\n// ResetToken resets all changes to the \"token\" field.\nfunc (m *RefreshTokenMutation) ResetToken() {\n\tm.token = nil\n}\n\n// SetObsoleteToken sets the \"obsolete_token\" field.\nfunc (m *RefreshTokenMutation) SetObsoleteToken(s string) {\n\tm.obsolete_token = &s\n}\n\n// ObsoleteToken returns the value of the \"obsolete_token\" field in the mutation.\nfunc (m *RefreshTokenMutation) ObsoleteToken() (r string, exists bool) {\n\tv := m.obsolete_token\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldObsoleteToken returns the old \"obsolete_token\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldObsoleteToken(ctx context.Context) (v string, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldObsoleteToken is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldObsoleteToken requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldObsoleteToken: %w\", err)\n\t}\n\treturn oldValue.ObsoleteToken, nil\n}\n\n// ResetObsoleteToken resets all changes to the \"obsolete_token\" field.\nfunc (m *RefreshTokenMutation) ResetObsoleteToken() {\n\tm.obsolete_token = nil\n}\n\n// SetCreatedAt sets the \"created_at\" field.\nfunc (m *RefreshTokenMutation) SetCreatedAt(t time.Time) {\n\tm.created_at = &t\n}\n\n// CreatedAt returns the value of the \"created_at\" field in the mutation.\nfunc (m *RefreshTokenMutation) CreatedAt() (r time.Time, exists bool) {\n\tv := m.created_at\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldCreatedAt returns the old \"created_at\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldCreatedAt is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldCreatedAt requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldCreatedAt: %w\", err)\n\t}\n\treturn oldValue.CreatedAt, nil\n}\n\n// ResetCreatedAt resets all changes to the \"created_at\" field.\nfunc (m *RefreshTokenMutation) ResetCreatedAt() {\n\tm.created_at = nil\n}\n\n// SetLastUsed sets the \"last_used\" field.\nfunc (m *RefreshTokenMutation) SetLastUsed(t time.Time) {\n\tm.last_used = &t\n}\n\n// LastUsed returns the value of the \"last_used\" field in the mutation.\nfunc (m *RefreshTokenMutation) LastUsed() (r time.Time, exists bool) {\n\tv := m.last_used\n\tif v == nil {\n\t\treturn\n\t}\n\treturn *v, true\n}\n\n// OldLastUsed returns the old \"last_used\" field's value of the RefreshToken entity.\n// If the RefreshToken object wasn't provided to the builder, the object is fetched from the database.\n// An error is returned if the mutation operation is not UpdateOne, or the database query fails.\nfunc (m *RefreshTokenMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {\n\tif !m.op.Is(OpUpdateOne) {\n\t\treturn v, errors.New(\"OldLastUsed is only allowed on UpdateOne operations\")\n\t}\n\tif m.id == nil || m.oldValue == nil {\n\t\treturn v, errors.New(\"OldLastUsed requires an ID field in the mutation\")\n\t}\n\toldValue, err := m.oldValue(ctx)\n\tif err != nil {\n\t\treturn v, fmt.Errorf(\"querying old value for OldLastUsed: %w\", err)\n\t}\n\treturn oldValue.LastUsed, nil\n}\n\n// ResetLastUsed resets all changes to the \"last_used\" field.\nfunc (m *RefreshTokenMutation) ResetLastUsed() {\n\tm.last_used = nil\n}\n\n// Where appends a list predicates to the RefreshTokenMutation builder.\nfunc (m *RefreshTokenMutation) Where(ps ...predicate.RefreshToken) {\n\tm.predicates = append(m.predicates, ps...)\n}\n\n// Op returns the operation name.\nfunc (m *RefreshTokenMutation) Op() Op {\n\treturn m.op\n}\n\n// Type returns the node type of this mutation (RefreshToken).\nfunc (m *RefreshTokenMutation) Type() string {\n\treturn m.typ\n}\n\n// Fields returns all fields that were changed during this mutation. Note that in\n// order to get all numeric fields that were incremented/decremented, call\n// AddedFields().\nfunc (m *RefreshTokenMutation) Fields() []string {\n\tfields := make([]string, 0, 15)\n\tif m.client_id != nil {\n\t\tfields = append(fields, refreshtoken.FieldClientID)\n\t}\n\tif m.scopes != nil {\n\t\tfields = append(fields, refreshtoken.FieldScopes)\n\t}\n\tif m.nonce != nil {\n\t\tfields = append(fields, refreshtoken.FieldNonce)\n\t}\n\tif m.claims_user_id != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsUserID)\n\t}\n\tif m.claims_username != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsUsername)\n\t}\n\tif m.claims_email != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsEmail)\n\t}\n\tif m.claims_email_verified != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsEmailVerified)\n\t}\n\tif m.claims_groups != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsGroups)\n\t}\n\tif m.claims_preferred_username != nil {\n\t\tfields = append(fields, refreshtoken.FieldClaimsPreferredUsername)\n\t}\n\tif m.connector_id != nil {\n\t\tfields = append(fields, refreshtoken.FieldConnectorID)\n\t}\n\tif m.connector_data != nil {\n\t\tfields = append(fields, refreshtoken.FieldConnectorData)\n\t}\n\tif m.token != nil {\n\t\tfields = append(fields, refreshtoken.FieldToken)\n\t}\n\tif m.obsolete_token != nil {\n\t\tfields = append(fields, refreshtoken.FieldObsoleteToken)\n\t}\n\tif m.created_at != nil {\n\t\tfields = append(fields, refreshtoken.FieldCreatedAt)\n\t}\n\tif m.last_used != nil {\n\t\tfields = append(fields, refreshtoken.FieldLastUsed)\n\t}\n\treturn fields\n}\n\n// Field returns the value of a field with the given name. The second boolean\n// return value indicates that this field was not set, or was not defined in the\n// schema.\nfunc (m *RefreshTokenMutation) Field(name string) (ent.Value, bool) {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\treturn m.ClientID()\n\tcase refreshtoken.FieldScopes:\n\t\treturn m.Scopes()\n\tcase refreshtoken.FieldNonce:\n\t\treturn m.Nonce()\n\tcase refreshtoken.FieldClaimsUserID:\n\t\treturn m.ClaimsUserID()\n\tcase refreshtoken.FieldClaimsUsername:\n\t\treturn m.ClaimsUsername()\n\tcase refreshtoken.FieldClaimsEmail:\n\t\treturn m.ClaimsEmail()\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\treturn m.ClaimsEmailVerified()\n\tcase refreshtoken.FieldClaimsGroups:\n\t\treturn m.ClaimsGroups()\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\treturn m.ClaimsPreferredUsername()\n\tcase refreshtoken.FieldConnectorID:\n\t\treturn m.ConnectorID()\n\tcase refreshtoken.FieldConnectorData:\n\t\treturn m.ConnectorData()\n\tcase refreshtoken.FieldToken:\n\t\treturn m.Token()\n\tcase refreshtoken.FieldObsoleteToken:\n\t\treturn m.ObsoleteToken()\n\tcase refreshtoken.FieldCreatedAt:\n\t\treturn m.CreatedAt()\n\tcase refreshtoken.FieldLastUsed:\n\t\treturn m.LastUsed()\n\t}\n\treturn nil, false\n}\n\n// OldField returns the old value of the field from the database. An error is\n// returned if the mutation operation is not UpdateOne, or the query to the\n// database failed.\nfunc (m *RefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\treturn m.OldClientID(ctx)\n\tcase refreshtoken.FieldScopes:\n\t\treturn m.OldScopes(ctx)\n\tcase refreshtoken.FieldNonce:\n\t\treturn m.OldNonce(ctx)\n\tcase refreshtoken.FieldClaimsUserID:\n\t\treturn m.OldClaimsUserID(ctx)\n\tcase refreshtoken.FieldClaimsUsername:\n\t\treturn m.OldClaimsUsername(ctx)\n\tcase refreshtoken.FieldClaimsEmail:\n\t\treturn m.OldClaimsEmail(ctx)\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\treturn m.OldClaimsEmailVerified(ctx)\n\tcase refreshtoken.FieldClaimsGroups:\n\t\treturn m.OldClaimsGroups(ctx)\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\treturn m.OldClaimsPreferredUsername(ctx)\n\tcase refreshtoken.FieldConnectorID:\n\t\treturn m.OldConnectorID(ctx)\n\tcase refreshtoken.FieldConnectorData:\n\t\treturn m.OldConnectorData(ctx)\n\tcase refreshtoken.FieldToken:\n\t\treturn m.OldToken(ctx)\n\tcase refreshtoken.FieldObsoleteToken:\n\t\treturn m.OldObsoleteToken(ctx)\n\tcase refreshtoken.FieldCreatedAt:\n\t\treturn m.OldCreatedAt(ctx)\n\tcase refreshtoken.FieldLastUsed:\n\t\treturn m.OldLastUsed(ctx)\n\t}\n\treturn nil, fmt.Errorf(\"unknown RefreshToken field %s\", name)\n}\n\n// SetField sets the value of a field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *RefreshTokenMutation) SetField(name string, value ent.Value) error {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClientID(v)\n\t\treturn nil\n\tcase refreshtoken.FieldScopes:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetScopes(v)\n\t\treturn nil\n\tcase refreshtoken.FieldNonce:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetNonce(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUserID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUserID(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsUsername(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmail:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmail(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsEmailVerified(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsGroups:\n\t\tv, ok := value.([]string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsGroups(v)\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetClaimsPreferredUsername(v)\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorID:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorID(v)\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorData:\n\t\tv, ok := value.([]byte)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetConnectorData(v)\n\t\treturn nil\n\tcase refreshtoken.FieldToken:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetToken(v)\n\t\treturn nil\n\tcase refreshtoken.FieldObsoleteToken:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetObsoleteToken(v)\n\t\treturn nil\n\tcase refreshtoken.FieldCreatedAt:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetCreatedAt(v)\n\t\treturn nil\n\tcase refreshtoken.FieldLastUsed:\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unexpected type %T for field %s\", value, name)\n\t\t}\n\t\tm.SetLastUsed(v)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken field %s\", name)\n}\n\n// AddedFields returns all numeric fields that were incremented/decremented during\n// this mutation.\nfunc (m *RefreshTokenMutation) AddedFields() []string {\n\treturn nil\n}\n\n// AddedField returns the numeric value that was incremented/decremented on a field\n// with the given name. The second boolean return value indicates that this field\n// was not set, or was not defined in the schema.\nfunc (m *RefreshTokenMutation) AddedField(name string) (ent.Value, bool) {\n\treturn nil, false\n}\n\n// AddField adds the value to the field with the given name. It returns an error if\n// the field is not defined in the schema, or if the type mismatched the field\n// type.\nfunc (m *RefreshTokenMutation) AddField(name string, value ent.Value) error {\n\tswitch name {\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken numeric field %s\", name)\n}\n\n// ClearedFields returns all nullable fields that were cleared during this\n// mutation.\nfunc (m *RefreshTokenMutation) ClearedFields() []string {\n\tvar fields []string\n\tif m.FieldCleared(refreshtoken.FieldScopes) {\n\t\tfields = append(fields, refreshtoken.FieldScopes)\n\t}\n\tif m.FieldCleared(refreshtoken.FieldClaimsGroups) {\n\t\tfields = append(fields, refreshtoken.FieldClaimsGroups)\n\t}\n\tif m.FieldCleared(refreshtoken.FieldConnectorData) {\n\t\tfields = append(fields, refreshtoken.FieldConnectorData)\n\t}\n\treturn fields\n}\n\n// FieldCleared returns a boolean indicating if a field with the given name was\n// cleared in this mutation.\nfunc (m *RefreshTokenMutation) FieldCleared(name string) bool {\n\t_, ok := m.clearedFields[name]\n\treturn ok\n}\n\n// ClearField clears the value of the field with the given name. It returns an\n// error if the field is not defined in the schema.\nfunc (m *RefreshTokenMutation) ClearField(name string) error {\n\tswitch name {\n\tcase refreshtoken.FieldScopes:\n\t\tm.ClearScopes()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsGroups:\n\t\tm.ClearClaimsGroups()\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorData:\n\t\tm.ClearConnectorData()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken nullable field %s\", name)\n}\n\n// ResetField resets all changes in the mutation for the field with the given name.\n// It returns an error if the field is not defined in the schema.\nfunc (m *RefreshTokenMutation) ResetField(name string) error {\n\tswitch name {\n\tcase refreshtoken.FieldClientID:\n\t\tm.ResetClientID()\n\t\treturn nil\n\tcase refreshtoken.FieldScopes:\n\t\tm.ResetScopes()\n\t\treturn nil\n\tcase refreshtoken.FieldNonce:\n\t\tm.ResetNonce()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUserID:\n\t\tm.ResetClaimsUserID()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsUsername:\n\t\tm.ResetClaimsUsername()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmail:\n\t\tm.ResetClaimsEmail()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsEmailVerified:\n\t\tm.ResetClaimsEmailVerified()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsGroups:\n\t\tm.ResetClaimsGroups()\n\t\treturn nil\n\tcase refreshtoken.FieldClaimsPreferredUsername:\n\t\tm.ResetClaimsPreferredUsername()\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorID:\n\t\tm.ResetConnectorID()\n\t\treturn nil\n\tcase refreshtoken.FieldConnectorData:\n\t\tm.ResetConnectorData()\n\t\treturn nil\n\tcase refreshtoken.FieldToken:\n\t\tm.ResetToken()\n\t\treturn nil\n\tcase refreshtoken.FieldObsoleteToken:\n\t\tm.ResetObsoleteToken()\n\t\treturn nil\n\tcase refreshtoken.FieldCreatedAt:\n\t\tm.ResetCreatedAt()\n\t\treturn nil\n\tcase refreshtoken.FieldLastUsed:\n\t\tm.ResetLastUsed()\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown RefreshToken field %s\", name)\n}\n\n// AddedEdges returns all edge names that were set/added in this mutation.\nfunc (m *RefreshTokenMutation) AddedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// AddedIDs returns all IDs (to other nodes) that were added for the given edge\n// name in this mutation.\nfunc (m *RefreshTokenMutation) AddedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// RemovedEdges returns all edge names that were removed in this mutation.\nfunc (m *RefreshTokenMutation) RemovedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with\n// the given name in this mutation.\nfunc (m *RefreshTokenMutation) RemovedIDs(name string) []ent.Value {\n\treturn nil\n}\n\n// ClearedEdges returns all edge names that were cleared in this mutation.\nfunc (m *RefreshTokenMutation) ClearedEdges() []string {\n\tedges := make([]string, 0, 0)\n\treturn edges\n}\n\n// EdgeCleared returns a boolean which indicates if the edge with the given name\n// was cleared in this mutation.\nfunc (m *RefreshTokenMutation) EdgeCleared(name string) bool {\n\treturn false\n}\n\n// ClearEdge clears the value of the edge with the given name. It returns an error\n// if that edge is not defined in the schema.\nfunc (m *RefreshTokenMutation) ClearEdge(name string) error {\n\treturn fmt.Errorf(\"unknown RefreshToken unique edge %s\", name)\n}\n\n// ResetEdge resets all changes to the edge with the given name in this mutation.\n// It returns an error if the edge is not defined in the schema.\nfunc (m *RefreshTokenMutation) ResetEdge(name string) error {\n\treturn fmt.Errorf(\"unknown RefreshToken edge %s\", name)\n}\n", "package schema\n\nimport (\n\t\"entgo.io/ent\"\n\t\"entgo.io/ent/schema/field\"\n)\n\n/* Original SQL table:\ncreate table auth_request\n(\n    id                        text      not null  primary key,\n    client_id                 text      not null,\n    response_types            blob      not null,\n    scopes                    blob      not null,\n    redirect_uri              text      not null,\n    nonce                     text      not null,\n    state                     text      not null,\n    force_approval_prompt     integer   not null,\n    logged_in                 integer   not null,\n    claims_user_id            text      not null,\n    claims_username           text      not null,\n    claims_email              text      not null,\n    claims_email_verified     integer   not null,\n    claims_groups             blob      not null,\n    connector_id              text      not null,\n    connector_data            blob,\n    expiry                    timestamp not null,\n    claims_preferred_username text default '' not null,\n    code_challenge            text default '' not null,\n    code_challenge_method     text default '' not null,\n    hmac_key                  blob\n);\n*/\n\n// AuthRequest holds the schema definition for the AuthRequest entity.\ntype AuthRequest struct {\n\tent.Schema\n}\n\n// Fields of the AuthRequest.\nfunc (AuthRequest) Fields() []ent.Field {\n\treturn []ent.Field{\n\t\tfield.Text(\"id\").\n\t\t\tSchemaType(textSchema).\n\t\t\tNotEmpty().\n\t\t\tUnique(),\n\t\tfield.Text(\"client_id\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.JSON(\"scopes\", []string{}).\n\t\t\tOptional(),\n\t\tfield.JSON(\"response_types\", []string{}).\n\t\t\tOptional(),\n\t\tfield.Text(\"redirect_uri\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"nonce\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"state\").\n\t\t\tSchemaType(textSchema),\n\n\t\tfield.Bool(\"force_approval_prompt\"),\n\t\tfield.Bool(\"logged_in\"),\n\n\t\tfield.Text(\"claims_user_id\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"claims_username\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Text(\"claims_email\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Bool(\"claims_email_verified\"),\n\t\tfield.JSON(\"claims_groups\", []string{}).\n\t\t\tOptional(),\n\t\tfield.Text(\"claims_preferred_username\").\n\t\t\tSchemaType(textSchema).\n\t\t\tDefault(\"\"),\n\n\t\tfield.Text(\"connector_id\").\n\t\t\tSchemaType(textSchema),\n\t\tfield.Bytes(\"connector_data\").\n\t\t\tNillable().\n\t\t\tOptional(),\n\t\tfield.Time(\"expiry\").\n\t\t\tSchemaType(timeSchema),\n\n\t\tfield.Text(\"code_challenge\").\n\t\t\tSchemaType(textSchema).\n\t\t\tDefault(\"\"),\n\t\tfield.Text(\"code_challenge_method\").\n\t\t\tSchemaType(textSchema).\n\t\t\tDefault(\"\"),\n\t\tfield.Bytes(\"hmac_key\"),\n\t}\n}\n\n// Edges of the AuthRequest.\nfunc (AuthRequest) Edges() []ent.Edge {\n\treturn []ent.Edge{}\n}\n", "package etcd\n\nimport (\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// AuthCode is a mirrored struct from storage with JSON struct tags\ntype AuthCode struct {\n\tID          string   `json:\"ID\"`\n\tClientID    string   `json:\"clientID\"`\n\tRedirectURI string   `json:\"redirectURI\"`\n\tNonce       string   `json:\"nonce,omitempty\"`\n\tScopes      []string `json:\"scopes,omitempty\"`\n\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n\tClaims        Claims `json:\"claims,omitempty\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\nfunc toStorageAuthCode(a AuthCode) storage.AuthCode {\n\treturn storage.AuthCode{\n\t\tID:            a.ID,\n\t\tClientID:      a.ClientID,\n\t\tRedirectURI:   a.RedirectURI,\n\t\tConnectorID:   a.ConnectorID,\n\t\tConnectorData: a.ConnectorData,\n\t\tNonce:         a.Nonce,\n\t\tScopes:        a.Scopes,\n\t\tClaims:        toStorageClaims(a.Claims),\n\t\tExpiry:        a.Expiry,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\nfunc fromStorageAuthCode(a storage.AuthCode) AuthCode {\n\treturn AuthCode{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tNonce:               a.Nonce,\n\t\tScopes:              a.Scopes,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tExpiry:              a.Expiry,\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t}\n}\n\n// AuthRequest is a mirrored struct from storage with JSON struct tags\ntype AuthRequest struct {\n\tID       string `json:\"id\"`\n\tClientID string `json:\"client_id\"`\n\n\tResponseTypes []string `json:\"response_types\"`\n\tScopes        []string `json:\"scopes\"`\n\tRedirectURI   string   `json:\"redirect_uri\"`\n\tNonce         string   `json:\"nonce\"`\n\tState         string   `json:\"state\"`\n\n\tForceApprovalPrompt bool `json:\"force_approval_prompt\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tLoggedIn bool `json:\"logged_in\"`\n\n\tClaims Claims `json:\"claims\"`\n\n\tConnectorID   string `json:\"connector_id\"`\n\tConnectorData []byte `json:\"connector_data\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n\n\tHMACKey []byte `json:\"hmac_key\"`\n}\n\nfunc fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {\n\treturn AuthRequest{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tExpiry:              a.Expiry,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t\tHMACKey:             a.HMACKey,\n\t}\n}\n\nfunc toStorageAuthRequest(a AuthRequest) storage.AuthRequest {\n\treturn storage.AuthRequest{\n\t\tID:                  a.ID,\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tExpiry:              a.Expiry,\n\t\tClaims:              toStorageClaims(a.Claims),\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t\tHMACKey: a.HMACKey,\n\t}\n}\n\n// RefreshToken is a mirrored struct from storage with JSON struct tags\ntype RefreshToken struct {\n\tID string `json:\"id\"`\n\n\tToken         string `json:\"token\"`\n\tObsoleteToken string `json:\"obsolete_token\"`\n\n\tCreatedAt time.Time `json:\"created_at\"`\n\tLastUsed  time.Time `json:\"last_used\"`\n\n\tClientID string `json:\"client_id\"`\n\n\tConnectorID   string `json:\"connector_id\"`\n\tConnectorData []byte `json:\"connector_data\"`\n\tClaims        Claims `json:\"claims\"`\n\n\tScopes []string `json:\"scopes\"`\n\n\tNonce string `json:\"nonce\"`\n}\n\nfunc toStorageRefreshToken(r RefreshToken) storage.RefreshToken {\n\treturn storage.RefreshToken{\n\t\tID:            r.ID,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        toStorageClaims(r.Claims),\n\t}\n}\n\nfunc fromStorageRefreshToken(r storage.RefreshToken) RefreshToken {\n\treturn RefreshToken{\n\t\tID:            r.ID,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        fromStorageClaims(r.Claims),\n\t}\n}\n\n// Claims is a mirrored struct from storage with JSON struct tags.\ntype Claims struct {\n\tUserID            string   `json:\"userID\"`\n\tUsername          string   `json:\"username\"`\n\tPreferredUsername string   `json:\"preferredUsername\"`\n\tEmail             string   `json:\"email\"`\n\tEmailVerified     bool     `json:\"emailVerified\"`\n\tGroups            []string `json:\"groups,omitempty\"`\n}\n\nfunc fromStorageClaims(i storage.Claims) Claims {\n\treturn Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\nfunc toStorageClaims(i Claims) storage.Claims {\n\treturn storage.Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\n// Keys is a mirrored struct from storage with JSON struct tags\ntype Keys struct {\n\tSigningKey       *jose.JSONWebKey          `json:\"signing_key,omitempty\"`\n\tSigningKeyPub    *jose.JSONWebKey          `json:\"signing_key_pub,omitempty\"`\n\tVerificationKeys []storage.VerificationKey `json:\"verification_keys\"`\n\tNextRotation     time.Time                 `json:\"next_rotation\"`\n}\n\n// OfflineSessions is a mirrored struct from storage with JSON struct tags\ntype OfflineSessions struct {\n\tUserID        string                              `json:\"user_id,omitempty\"`\n\tConnID        string                              `json:\"conn_id,omitempty\"`\n\tRefresh       map[string]*storage.RefreshTokenRef `json:\"refresh,omitempty\"`\n\tConnectorData []byte                              `json:\"connectorData,omitempty\"`\n}\n\nfunc fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {\n\treturn OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n}\n\nfunc toStorageOfflineSessions(o OfflineSessions) storage.OfflineSessions {\n\ts := storage.OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n\tif s.Refresh == nil {\n\t\t// Server code assumes this will be non-nil.\n\t\ts.Refresh = make(map[string]*storage.RefreshTokenRef)\n\t}\n\treturn s\n}\n\n// DeviceRequest is a mirrored struct from storage with JSON struct tags\ntype DeviceRequest struct {\n\tUserCode     string    `json:\"user_code\"`\n\tDeviceCode   string    `json:\"device_code\"`\n\tClientID     string    `json:\"client_id\"`\n\tClientSecret string    `json:\"client_secret\"`\n\tScopes       []string  `json:\"scopes\"`\n\tExpiry       time.Time `json:\"expiry\"`\n}\n\nfunc fromStorageDeviceRequest(d storage.DeviceRequest) DeviceRequest {\n\treturn DeviceRequest{\n\t\tUserCode:     d.UserCode,\n\t\tDeviceCode:   d.DeviceCode,\n\t\tClientID:     d.ClientID,\n\t\tClientSecret: d.ClientSecret,\n\t\tScopes:       d.Scopes,\n\t\tExpiry:       d.Expiry,\n\t}\n}\n\n// DeviceToken is a mirrored struct from storage with JSON struct tags\ntype DeviceToken struct {\n\tDeviceCode          string    `json:\"device_code\"`\n\tStatus              string    `json:\"status\"`\n\tToken               string    `json:\"token\"`\n\tExpiry              time.Time `json:\"expiry\"`\n\tLastRequestTime     time.Time `json:\"last_request\"`\n\tPollIntervalSeconds int       `json:\"poll_interval\"`\n\tCodeChallenge       string    `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string    `json:\"code_challenge_method,omitempty\"`\n}\n\nfunc fromStorageDeviceToken(t storage.DeviceToken) DeviceToken {\n\treturn DeviceToken{\n\t\tDeviceCode:          t.DeviceCode,\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tCodeChallenge:       t.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: t.PKCE.CodeChallengeMethod,\n\t}\n}\n\nfunc toStorageDeviceToken(t DeviceToken) storage.DeviceToken {\n\treturn storage.DeviceToken{\n\t\tDeviceCode:          t.DeviceCode,\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       t.CodeChallenge,\n\t\t\tCodeChallengeMethod: t.CodeChallengeMethod,\n\t\t},\n\t}\n}\n", "package storage\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// NewCustomHealthCheckFunc returns a new health check function.\nfunc NewCustomHealthCheckFunc(s Storage, now func() time.Time) func(context.Context) (details interface{}, err error) {\n\treturn func(_ context.Context) (details interface{}, err error) {\n\t\ta := AuthRequest{\n\t\t\tID:       NewID(),\n\t\t\tClientID: NewID(),\n\n\t\t\t// Set a short expiry so if the delete fails this will be cleaned up quickly by garbage collection.\n\t\t\tExpiry:  now().Add(time.Minute),\n\t\t\tHMACKey: NewHMACKey(crypto.SHA256),\n\t\t}\n\n\t\tif err := s.CreateAuthRequest(a); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"create auth request: %v\", err)\n\t\t}\n\n\t\tif err := s.DeleteAuthRequest(a.ID); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"delete auth request: %v\", err)\n\t\t}\n\n\t\treturn nil, nil\n\t}\n}\n", "package kubernetes\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t\"github.com/dexidp/dex/storage\"\n\t\"github.com/dexidp/dex/storage/kubernetes/k8sapi\"\n)\n\nconst (\n\tapiGroup = \"dex.coreos.com\"\n\n\tlegacyCRDAPIVersion = \"apiextensions.k8s.io/v1beta1\"\n\tcrdAPIVersion       = \"apiextensions.k8s.io/v1\"\n)\n\n// The set of custom resource definitions required by the storage. These are managed by\n// the storage so it can migrate itself by creating new resources.\nfunc customResourceDefinitions(apiVersion string) []k8sapi.CustomResourceDefinition {\n\tcrdMeta := k8sapi.TypeMeta{\n\t\tAPIVersion: apiVersion,\n\t\tKind:       \"CustomResourceDefinition\",\n\t}\n\n\tvar version string\n\tvar scope k8sapi.ResourceScope\n\tvar versions []k8sapi.CustomResourceDefinitionVersion\n\n\tswitch apiVersion {\n\tcase crdAPIVersion:\n\t\tpreserveUnknownFields := true\n\t\tversions = []k8sapi.CustomResourceDefinitionVersion{\n\t\t\t{\n\t\t\t\tName:    \"v1\",\n\t\t\t\tServed:  true,\n\t\t\t\tStorage: true,\n\t\t\t\tSchema: &k8sapi.CustomResourceValidation{\n\t\t\t\t\tOpenAPIV3Schema: &k8sapi.JSONSchemaProps{\n\t\t\t\t\t\tType:                   \"object\",\n\t\t\t\t\t\tXPreserveUnknownFields: &preserveUnknownFields,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tscope = k8sapi.NamespaceScoped\n\tcase legacyCRDAPIVersion:\n\t\tversion = \"v1\"\n\tdefault:\n\t\tpanic(\"unknown apiVersion \" + apiVersion)\n\t}\n\n\treturn []k8sapi.CustomResourceDefinition{\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"authcodes.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"authcodes\",\n\t\t\t\t\tSingular: \"authcode\",\n\t\t\t\t\tKind:     \"AuthCode\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"authrequests.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"authrequests\",\n\t\t\t\t\tSingular: \"authrequest\",\n\t\t\t\t\tKind:     \"AuthRequest\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"oauth2clients.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"oauth2clients\",\n\t\t\t\t\tSingular: \"oauth2client\",\n\t\t\t\t\tKind:     \"OAuth2Client\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"signingkeies.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\t// `signingkeies` is an artifact from the old TPR pluralization.\n\t\t\t\t\t// Users don't directly interact with this value, hence leaving it\n\t\t\t\t\t// as is.\n\t\t\t\t\tPlural:   \"signingkeies\",\n\t\t\t\t\tSingular: \"signingkey\",\n\t\t\t\t\tKind:     \"SigningKey\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"refreshtokens.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"refreshtokens\",\n\t\t\t\t\tSingular: \"refreshtoken\",\n\t\t\t\t\tKind:     \"RefreshToken\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"passwords.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"passwords\",\n\t\t\t\t\tSingular: \"password\",\n\t\t\t\t\tKind:     \"Password\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"offlinesessionses.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"offlinesessionses\",\n\t\t\t\t\tSingular: \"offlinesessions\",\n\t\t\t\t\tKind:     \"OfflineSessions\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"connectors.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"connectors\",\n\t\t\t\t\tSingular: \"connector\",\n\t\t\t\t\tKind:     \"Connector\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"devicerequests.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"devicerequests\",\n\t\t\t\t\tSingular: \"devicerequest\",\n\t\t\t\t\tKind:     \"DeviceRequest\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\t\tName: \"devicetokens.dex.coreos.com\",\n\t\t\t},\n\t\t\tTypeMeta: crdMeta,\n\t\t\tSpec: k8sapi.CustomResourceDefinitionSpec{\n\t\t\t\tGroup:    apiGroup,\n\t\t\t\tVersion:  version,\n\t\t\t\tVersions: versions,\n\t\t\t\tScope:    scope,\n\t\t\t\tNames: k8sapi.CustomResourceDefinitionNames{\n\t\t\t\t\tPlural:   \"devicetokens\",\n\t\t\t\t\tSingular: \"devicetoken\",\n\t\t\t\t\tKind:     \"DeviceToken\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\n// There will only ever be a single keys resource. Maintain this by setting a\n// common name.\nconst keysName = \"openid-connect-keys\"\n\n// Client is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype Client struct {\n\t// Name is a hash of the ID.\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// ID is immutable, since it's a primary key and should not be changed.\n\tID string `json:\"id,omitempty\"`\n\n\tSecret       string   `json:\"secret,omitempty\"`\n\tRedirectURIs []string `json:\"redirectURIs,omitempty\"`\n\tTrustedPeers []string `json:\"trustedPeers,omitempty\"`\n\n\tPublic bool `json:\"public\"`\n\n\tName    string `json:\"name,omitempty\"`\n\tLogoURL string `json:\"logoURL,omitempty\"`\n}\n\n// ClientList is a list of Clients.\ntype ClientList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tClients         []Client `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageClient(c storage.Client) Client {\n\treturn Client{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindClient,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      cli.idToName(c.ID),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tID:           c.ID,\n\t\tSecret:       c.Secret,\n\t\tRedirectURIs: c.RedirectURIs,\n\t\tTrustedPeers: c.TrustedPeers,\n\t\tPublic:       c.Public,\n\t\tName:         c.Name,\n\t\tLogoURL:      c.LogoURL,\n\t}\n}\n\nfunc toStorageClient(c Client) storage.Client {\n\treturn storage.Client{\n\t\tID:           c.ID,\n\t\tSecret:       c.Secret,\n\t\tRedirectURIs: c.RedirectURIs,\n\t\tTrustedPeers: c.TrustedPeers,\n\t\tPublic:       c.Public,\n\t\tName:         c.Name,\n\t\tLogoURL:      c.LogoURL,\n\t}\n}\n\n// Claims is a mirrored struct from storage with JSON struct tags.\ntype Claims struct {\n\tUserID            string   `json:\"userID\"`\n\tUsername          string   `json:\"username\"`\n\tPreferredUsername string   `json:\"preferredUsername\"`\n\tEmail             string   `json:\"email\"`\n\tEmailVerified     bool     `json:\"emailVerified\"`\n\tGroups            []string `json:\"groups,omitempty\"`\n}\n\nfunc fromStorageClaims(i storage.Claims) Claims {\n\treturn Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\nfunc toStorageClaims(i Claims) storage.Claims {\n\treturn storage.Claims{\n\t\tUserID:            i.UserID,\n\t\tUsername:          i.Username,\n\t\tPreferredUsername: i.PreferredUsername,\n\t\tEmail:             i.Email,\n\t\tEmailVerified:     i.EmailVerified,\n\t\tGroups:            i.Groups,\n\t}\n}\n\n// AuthRequest is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype AuthRequest struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tClientID      string   `json:\"clientID\"`\n\tResponseTypes []string `json:\"responseTypes,omitempty\"`\n\tScopes        []string `json:\"scopes,omitempty\"`\n\tRedirectURI   string   `json:\"redirectURI\"`\n\n\tNonce string `json:\"nonce,omitempty\"`\n\tState string `json:\"state,omitempty\"`\n\n\t// The client has indicated that the end user must be shown an approval prompt\n\t// on all requests. The server cannot cache their initial action for subsequent\n\t// attempts.\n\tForceApprovalPrompt bool `json:\"forceApprovalPrompt,omitempty\"`\n\n\tLoggedIn bool `json:\"loggedIn\"`\n\n\t// The identity of the end user. Generally nil until the user authenticates\n\t// with a backend.\n\tClaims Claims `json:\"claims,omitempty\"`\n\t// The connector used to login the user. Set when the user authenticates.\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n\n\tHMACKey []byte `json:\"hmac_key\"`\n}\n\n// AuthRequestList is a list of AuthRequests.\ntype AuthRequestList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tAuthRequests    []AuthRequest `json:\"items\"`\n}\n\nfunc toStorageAuthRequest(req AuthRequest) storage.AuthRequest {\n\ta := storage.AuthRequest{\n\t\tID:                  req.ObjectMeta.Name,\n\t\tClientID:            req.ClientID,\n\t\tResponseTypes:       req.ResponseTypes,\n\t\tScopes:              req.Scopes,\n\t\tRedirectURI:         req.RedirectURI,\n\t\tNonce:               req.Nonce,\n\t\tState:               req.State,\n\t\tForceApprovalPrompt: req.ForceApprovalPrompt,\n\t\tLoggedIn:            req.LoggedIn,\n\t\tConnectorID:         req.ConnectorID,\n\t\tConnectorData:       req.ConnectorData,\n\t\tExpiry:              req.Expiry,\n\t\tClaims:              toStorageClaims(req.Claims),\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       req.CodeChallenge,\n\t\t\tCodeChallengeMethod: req.CodeChallengeMethod,\n\t\t},\n\t\tHMACKey: req.HMACKey,\n\t}\n\treturn a\n}\n\nfunc (cli *client) fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {\n\treq := AuthRequest{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindAuthRequest,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      a.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tClientID:            a.ClientID,\n\t\tResponseTypes:       a.ResponseTypes,\n\t\tScopes:              a.Scopes,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tNonce:               a.Nonce,\n\t\tState:               a.State,\n\t\tLoggedIn:            a.LoggedIn,\n\t\tForceApprovalPrompt: a.ForceApprovalPrompt,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tExpiry:              a.Expiry,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t\tHMACKey:             a.HMACKey,\n\t}\n\treturn req\n}\n\n// Password is a mirrored struct from the storage with JSON struct tags and\n// Kubernetes type metadata.\ntype Password struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// The Kubernetes name is actually an encoded version of this value.\n\t//\n\t// This field is IMMUTABLE. Do not change.\n\tEmail string `json:\"email,omitempty\"`\n\n\tHash     []byte `json:\"hash,omitempty\"`\n\tUsername string `json:\"username,omitempty\"`\n\tUserID   string `json:\"userID,omitempty\"`\n}\n\n// PasswordList is a list of Passwords.\ntype PasswordList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tPasswords       []Password `json:\"items\"`\n}\n\nfunc (cli *client) fromStoragePassword(p storage.Password) Password {\n\temail := strings.ToLower(p.Email)\n\treturn Password{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindPassword,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      cli.idToName(email),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tEmail:    email,\n\t\tHash:     p.Hash,\n\t\tUsername: p.Username,\n\t\tUserID:   p.UserID,\n\t}\n}\n\nfunc toStoragePassword(p Password) storage.Password {\n\treturn storage.Password{\n\t\tEmail:    p.Email,\n\t\tHash:     p.Hash,\n\t\tUsername: p.Username,\n\t\tUserID:   p.UserID,\n\t}\n}\n\n// AuthCode is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype AuthCode struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tClientID    string   `json:\"clientID\"`\n\tScopes      []string `json:\"scopes,omitempty\"`\n\tRedirectURI string   `json:\"redirectURI\"`\n\n\tNonce string `json:\"nonce,omitempty\"`\n\tState string `json:\"state,omitempty\"`\n\n\tClaims Claims `json:\"claims,omitempty\"`\n\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n\n\tExpiry time.Time `json:\"expiry\"`\n\n\tCodeChallenge       string `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string `json:\"code_challenge_method,omitempty\"`\n}\n\n// AuthCodeList is a list of AuthCodes.\ntype AuthCodeList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tAuthCodes       []AuthCode `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageAuthCode(a storage.AuthCode) AuthCode {\n\treturn AuthCode{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindAuthCode,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      a.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tClientID:            a.ClientID,\n\t\tRedirectURI:         a.RedirectURI,\n\t\tConnectorID:         a.ConnectorID,\n\t\tConnectorData:       a.ConnectorData,\n\t\tNonce:               a.Nonce,\n\t\tScopes:              a.Scopes,\n\t\tClaims:              fromStorageClaims(a.Claims),\n\t\tExpiry:              a.Expiry,\n\t\tCodeChallenge:       a.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: a.PKCE.CodeChallengeMethod,\n\t}\n}\n\nfunc toStorageAuthCode(a AuthCode) storage.AuthCode {\n\treturn storage.AuthCode{\n\t\tID:            a.ObjectMeta.Name,\n\t\tClientID:      a.ClientID,\n\t\tRedirectURI:   a.RedirectURI,\n\t\tConnectorID:   a.ConnectorID,\n\t\tConnectorData: a.ConnectorData,\n\t\tNonce:         a.Nonce,\n\t\tScopes:        a.Scopes,\n\t\tClaims:        toStorageClaims(a.Claims),\n\t\tExpiry:        a.Expiry,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       a.CodeChallenge,\n\t\t\tCodeChallengeMethod: a.CodeChallengeMethod,\n\t\t},\n\t}\n}\n\n// RefreshToken is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype RefreshToken struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tCreatedAt time.Time\n\tLastUsed  time.Time\n\n\tClientID string   `json:\"clientID\"`\n\tScopes   []string `json:\"scopes,omitempty\"`\n\n\tToken         string `json:\"token,omitempty\"`\n\tObsoleteToken string `json:\"obsoleteToken,omitempty\"`\n\n\tNonce string `json:\"nonce,omitempty\"`\n\n\tClaims        Claims `json:\"claims,omitempty\"`\n\tConnectorID   string `json:\"connectorID,omitempty\"`\n\tConnectorData []byte `json:\"connectorData,omitempty\"`\n}\n\n// RefreshList is a list of refresh tokens.\ntype RefreshList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tRefreshTokens   []RefreshToken `json:\"items\"`\n}\n\nfunc toStorageRefreshToken(r RefreshToken) storage.RefreshToken {\n\treturn storage.RefreshToken{\n\t\tID:            r.ObjectMeta.Name,\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        toStorageClaims(r.Claims),\n\t}\n}\n\nfunc (cli *client) fromStorageRefreshToken(r storage.RefreshToken) RefreshToken {\n\treturn RefreshToken{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindRefreshToken,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      r.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tToken:         r.Token,\n\t\tObsoleteToken: r.ObsoleteToken,\n\t\tCreatedAt:     r.CreatedAt,\n\t\tLastUsed:      r.LastUsed,\n\t\tClientID:      r.ClientID,\n\t\tConnectorID:   r.ConnectorID,\n\t\tConnectorData: r.ConnectorData,\n\t\tScopes:        r.Scopes,\n\t\tNonce:         r.Nonce,\n\t\tClaims:        fromStorageClaims(r.Claims),\n\t}\n}\n\n// Keys is a mirrored struct from storage with JSON struct tags and Kubernetes\n// type metadata.\ntype Keys struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// Key for creating and verifying signatures. These may be nil.\n\tSigningKey    *jose.JSONWebKey `json:\"signingKey,omitempty\"`\n\tSigningKeyPub *jose.JSONWebKey `json:\"signingKeyPub,omitempty\"`\n\t// Old signing keys which have been rotated but can still be used to validate\n\t// existing signatures.\n\tVerificationKeys []storage.VerificationKey `json:\"verificationKeys,omitempty\"`\n\n\t// The next time the signing key will rotate.\n\t//\n\t// For caching purposes, implementations MUST NOT update keys before this time.\n\tNextRotation time.Time `json:\"nextRotation\"`\n}\n\nfunc (cli *client) fromStorageKeys(keys storage.Keys) Keys {\n\treturn Keys{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindKeys,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      keysName,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tSigningKey:       keys.SigningKey,\n\t\tSigningKeyPub:    keys.SigningKeyPub,\n\t\tVerificationKeys: keys.VerificationKeys,\n\t\tNextRotation:     keys.NextRotation,\n\t}\n}\n\nfunc toStorageKeys(keys Keys) storage.Keys {\n\treturn storage.Keys{\n\t\tSigningKey:       keys.SigningKey,\n\t\tSigningKeyPub:    keys.SigningKeyPub,\n\t\tVerificationKeys: keys.VerificationKeys,\n\t\tNextRotation:     keys.NextRotation,\n\t}\n}\n\n// OfflineSessions is a mirrored struct from storage with JSON struct tags and Kubernetes\n// type metadata.\ntype OfflineSessions struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tUserID        string                              `json:\"userID,omitempty\"`\n\tConnID        string                              `json:\"connID,omitempty\"`\n\tRefresh       map[string]*storage.RefreshTokenRef `json:\"refresh,omitempty\"`\n\tConnectorData []byte                              `json:\"connectorData,omitempty\"`\n}\n\nfunc (cli *client) fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {\n\treturn OfflineSessions{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindOfflineSessions,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      cli.offlineTokenName(o.UserID, o.ConnID),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n}\n\nfunc toStorageOfflineSessions(o OfflineSessions) storage.OfflineSessions {\n\ts := storage.OfflineSessions{\n\t\tUserID:        o.UserID,\n\t\tConnID:        o.ConnID,\n\t\tRefresh:       o.Refresh,\n\t\tConnectorData: o.ConnectorData,\n\t}\n\tif s.Refresh == nil {\n\t\t// Server code assumes this will be non-nil.\n\t\ts.Refresh = make(map[string]*storage.RefreshTokenRef)\n\t}\n\treturn s\n}\n\n// Connector is a mirrored struct from storage with JSON struct tags and Kubernetes\n// type metadata.\ntype Connector struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tID   string `json:\"id,omitempty\"`\n\tType string `json:\"type,omitempty\"`\n\tName string `json:\"name,omitempty\"`\n\t// Config holds connector specific configuration information\n\tConfig []byte `json:\"config,omitempty\"`\n}\n\nfunc (cli *client) fromStorageConnector(c storage.Connector) Connector {\n\treturn Connector{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindConnector,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      c.ID,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tID:     c.ID,\n\t\tType:   c.Type,\n\t\tName:   c.Name,\n\t\tConfig: c.Config,\n\t}\n}\n\nfunc toStorageConnector(c Connector) storage.Connector {\n\treturn storage.Connector{\n\t\tID:              c.ID,\n\t\tType:            c.Type,\n\t\tName:            c.Name,\n\t\tResourceVersion: c.ObjectMeta.ResourceVersion,\n\t\tConfig:          c.Config,\n\t}\n}\n\n// ConnectorList is a list of Connectors.\ntype ConnectorList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tConnectors      []Connector `json:\"items\"`\n}\n\n// DeviceRequest is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype DeviceRequest struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tDeviceCode   string    `json:\"device_code,omitempty\"`\n\tClientID     string    `json:\"client_id,omitempty\"`\n\tClientSecret string    `json:\"client_secret,omitempty\"`\n\tScopes       []string  `json:\"scopes,omitempty\"`\n\tExpiry       time.Time `json:\"expiry\"`\n}\n\n// DeviceRequestList is a list of DeviceRequests.\ntype DeviceRequestList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tDeviceRequests  []DeviceRequest `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageDeviceRequest(a storage.DeviceRequest) DeviceRequest {\n\treq := DeviceRequest{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindDeviceRequest,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      strings.ToLower(a.UserCode),\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tDeviceCode:   a.DeviceCode,\n\t\tClientID:     a.ClientID,\n\t\tClientSecret: a.ClientSecret,\n\t\tScopes:       a.Scopes,\n\t\tExpiry:       a.Expiry,\n\t}\n\treturn req\n}\n\nfunc toStorageDeviceRequest(req DeviceRequest) storage.DeviceRequest {\n\treturn storage.DeviceRequest{\n\t\tUserCode:     strings.ToUpper(req.ObjectMeta.Name),\n\t\tDeviceCode:   req.DeviceCode,\n\t\tClientID:     req.ClientID,\n\t\tClientSecret: req.ClientSecret,\n\t\tScopes:       req.Scopes,\n\t\tExpiry:       req.Expiry,\n\t}\n}\n\n// DeviceToken is a mirrored struct from storage with JSON struct tags and\n// Kubernetes type metadata.\ntype DeviceToken struct {\n\tk8sapi.TypeMeta   `json:\",inline\"`\n\tk8sapi.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tStatus              string    `json:\"status,omitempty\"`\n\tToken               string    `json:\"token,omitempty\"`\n\tExpiry              time.Time `json:\"expiry\"`\n\tLastRequestTime     time.Time `json:\"last_request\"`\n\tPollIntervalSeconds int       `json:\"poll_interval\"`\n\tCodeChallenge       string    `json:\"code_challenge,omitempty\"`\n\tCodeChallengeMethod string    `json:\"code_challenge_method,omitempty\"`\n}\n\n// DeviceTokenList is a list of DeviceTokens.\ntype DeviceTokenList struct {\n\tk8sapi.TypeMeta `json:\",inline\"`\n\tk8sapi.ListMeta `json:\"metadata,omitempty\"`\n\tDeviceTokens    []DeviceToken `json:\"items\"`\n}\n\nfunc (cli *client) fromStorageDeviceToken(t storage.DeviceToken) DeviceToken {\n\treq := DeviceToken{\n\t\tTypeMeta: k8sapi.TypeMeta{\n\t\t\tKind:       kindDeviceToken,\n\t\t\tAPIVersion: cli.apiVersion,\n\t\t},\n\t\tObjectMeta: k8sapi.ObjectMeta{\n\t\t\tName:      t.DeviceCode,\n\t\t\tNamespace: cli.namespace,\n\t\t},\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tCodeChallenge:       t.PKCE.CodeChallenge,\n\t\tCodeChallengeMethod: t.PKCE.CodeChallengeMethod,\n\t}\n\treturn req\n}\n\nfunc toStorageDeviceToken(t DeviceToken) storage.DeviceToken {\n\treturn storage.DeviceToken{\n\t\tDeviceCode:          t.ObjectMeta.Name,\n\t\tStatus:              t.Status,\n\t\tToken:               t.Token,\n\t\tExpiry:              t.Expiry,\n\t\tLastRequestTime:     t.LastRequestTime,\n\t\tPollIntervalSeconds: t.PollIntervalSeconds,\n\t\tPKCE: storage.PKCE{\n\t\t\tCodeChallenge:       t.CodeChallenge,\n\t\t\tCodeChallengeMethod: t.CodeChallengeMethod,\n\t\t},\n\t}\n}\n", "package sql\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/dexidp/dex/storage\"\n)\n\n// TODO(ericchiang): The update, insert, and select methods queries are all\n// very repetitive. Consider creating them programmatically.\n\n// keysRowID is the ID of the only row we expect to populate the \"keys\" table.\nconst keysRowID = \"keys\"\n\n// encoder wraps the underlying value in a JSON marshaler which is automatically\n// called by the database/sql package.\n//\n//\t\ts := []string{\"planes\", \"bears\"}\n//\t\terr := db.Exec(`insert into t1 (id, things) values (1, $1)`, encoder(s))\n//\t\tif err != nil {\n//\t\t\t// handle error\n//\t\t}\n//\n//\t\tvar r []byte\n//\t\terr = db.QueryRow(`select things from t1 where id = 1;`).Scan(&r)\n//\t\tif err != nil {\n//\t\t\t// handle error\n//\t\t}\n//\t\tfmt.Printf(\"%s\\n\", r) // [\"planes\",\"bears\"]\n//\nfunc encoder(i interface{}) driver.Valuer {\n\treturn jsonEncoder{i}\n}\n\n// decoder wraps the underlying value in a JSON unmarshaler which can then be passed\n// to a database Scan() method.\nfunc decoder(i interface{}) sql.Scanner {\n\treturn jsonDecoder{i}\n}\n\ntype jsonEncoder struct {\n\ti interface{}\n}\n\nfunc (j jsonEncoder) Value() (driver.Value, error) {\n\tb, err := json.Marshal(j.i)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"marshal: %v\", err)\n\t}\n\treturn b, nil\n}\n\ntype jsonDecoder struct {\n\ti interface{}\n}\n\nfunc (j jsonDecoder) Scan(dest interface{}) error {\n\tif dest == nil {\n\t\treturn errors.New(\"nil value\")\n\t}\n\tb, ok := dest.([]byte)\n\tif !ok {\n\t\treturn fmt.Errorf(\"expected []byte got %T\", dest)\n\t}\n\tif err := json.Unmarshal(b, &j.i); err != nil {\n\t\treturn fmt.Errorf(\"unmarshal: %v\", err)\n\t}\n\treturn nil\n}\n\n// Abstract conn vs trans.\ntype querier interface {\n\tQueryRow(query string, args ...interface{}) *sql.Row\n}\n\n// Abstract row vs rows.\ntype scanner interface {\n\tScan(dest ...interface{}) error\n}\n\nfunc (c *conn) GarbageCollect(now time.Time) (storage.GCResult, error) {\n\tresult := storage.GCResult{}\n\n\tr, err := c.Exec(`delete from auth_request where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc auth_request: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.AuthRequests = n\n\t}\n\n\tr, err = c.Exec(`delete from auth_code where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc auth_code: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.AuthCodes = n\n\t}\n\n\tr, err = c.Exec(`delete from device_request where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc device_request: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.DeviceRequests = n\n\t}\n\n\tr, err = c.Exec(`delete from device_token where expiry < $1`, now)\n\tif err != nil {\n\t\treturn result, fmt.Errorf(\"gc device_token: %v\", err)\n\t}\n\tif n, err := r.RowsAffected(); err == nil {\n\t\tresult.DeviceTokens = n\n\t}\n\n\treturn result, err\n}\n\nfunc (c *conn) CreateAuthRequest(a storage.AuthRequest) error {\n\t_, err := c.Exec(`\n\t\tinsert into auth_request (\n\t\t\tid, client_id, response_types, scopes, redirect_uri, nonce, state,\n\t\t\tforce_approval_prompt, logged_in,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\texpiry,\n\t\t\tcode_challenge, code_challenge_method,\n\t\t\thmac_key\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21\n\t\t);\n\t`,\n\t\ta.ID, a.ClientID, encoder(a.ResponseTypes), encoder(a.Scopes), a.RedirectURI, a.Nonce, a.State,\n\t\ta.ForceApprovalPrompt, a.LoggedIn,\n\t\ta.Claims.UserID, a.Claims.Username, a.Claims.PreferredUsername,\n\t\ta.Claims.Email, a.Claims.EmailVerified, encoder(a.Claims.Groups),\n\t\ta.ConnectorID, a.ConnectorData,\n\t\ta.Expiry,\n\t\ta.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod,\n\t\ta.HMACKey,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert auth request: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateAuthRequest(id string, updater func(a storage.AuthRequest) (storage.AuthRequest, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tr, err := getAuthRequest(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ta, err := updater(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate auth_request\n\t\t\tset\n\t\t\t\tclient_id = $1, response_types = $2, scopes = $3, redirect_uri = $4,\n\t\t\t\tnonce = $5, state = $6, force_approval_prompt = $7, logged_in = $8,\n\t\t\t\tclaims_user_id = $9, claims_username = $10, claims_preferred_username = $11,\n\t\t\t\tclaims_email = $12, claims_email_verified = $13,\n\t\t\t\tclaims_groups = $14,\n\t\t\t\tconnector_id = $15, connector_data = $16,\n\t\t\t\texpiry = $17,\n\t\t\t\tcode_challenge = $18, code_challenge_method = $19,\n\t\t\t\thmac_key = $20\n\t\t\twhere id = $21;\n\t\t`,\n\t\t\ta.ClientID, encoder(a.ResponseTypes), encoder(a.Scopes), a.RedirectURI, a.Nonce, a.State,\n\t\t\ta.ForceApprovalPrompt, a.LoggedIn,\n\t\t\ta.Claims.UserID, a.Claims.Username, a.Claims.PreferredUsername,\n\t\t\ta.Claims.Email, a.Claims.EmailVerified,\n\t\t\tencoder(a.Claims.Groups),\n\t\t\ta.ConnectorID, a.ConnectorData,\n\t\t\ta.Expiry,\n\t\t\ta.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod, a.HMACKey,\n\t\t\tr.ID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update auth request: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetAuthRequest(id string) (storage.AuthRequest, error) {\n\treturn getAuthRequest(c, id)\n}\n\nfunc getAuthRequest(q querier, id string) (a storage.AuthRequest, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n\t\t\tid, client_id, response_types, scopes, redirect_uri, nonce, state,\n\t\t\tforce_approval_prompt, logged_in,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data, expiry,\n\t\t\tcode_challenge, code_challenge_method, hmac_key\n\t\tfrom auth_request where id = $1;\n\t`, id).Scan(\n\t\t&a.ID, &a.ClientID, decoder(&a.ResponseTypes), decoder(&a.Scopes), &a.RedirectURI, &a.Nonce, &a.State,\n\t\t&a.ForceApprovalPrompt, &a.LoggedIn,\n\t\t&a.Claims.UserID, &a.Claims.Username, &a.Claims.PreferredUsername,\n\t\t&a.Claims.Email, &a.Claims.EmailVerified,\n\t\tdecoder(&a.Claims.Groups),\n\t\t&a.ConnectorID, &a.ConnectorData, &a.Expiry,\n\t\t&a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod, &a.HMACKey,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn a, storage.ErrNotFound\n\t\t}\n\t\treturn a, fmt.Errorf(\"select auth request: %v\", err)\n\t}\n\treturn a, nil\n}\n\nfunc (c *conn) CreateAuthCode(a storage.AuthCode) error {\n\t_, err := c.Exec(`\n\t\tinsert into auth_code (\n\t\t\tid, client_id, scopes, nonce, redirect_uri,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\texpiry,\n\t\t\tcode_challenge, code_challenge_method\n\t\t)\n\t\tvalues ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16);\n\t`,\n\t\ta.ID, a.ClientID, encoder(a.Scopes), a.Nonce, a.RedirectURI, a.Claims.UserID,\n\t\ta.Claims.Username, a.Claims.PreferredUsername, a.Claims.Email, a.Claims.EmailVerified,\n\t\tencoder(a.Claims.Groups), a.ConnectorID, a.ConnectorData, a.Expiry,\n\t\ta.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert auth code: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) GetAuthCode(id string) (a storage.AuthCode, err error) {\n\terr = c.QueryRow(`\n\t\tselect\n\t\t\tid, client_id, scopes, nonce, redirect_uri,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\texpiry,\n\t\t\tcode_challenge, code_challenge_method\n\t\tfrom auth_code where id = $1;\n\t`, id).Scan(\n\t\t&a.ID, &a.ClientID, decoder(&a.Scopes), &a.Nonce, &a.RedirectURI, &a.Claims.UserID,\n\t\t&a.Claims.Username, &a.Claims.PreferredUsername, &a.Claims.Email, &a.Claims.EmailVerified,\n\t\tdecoder(&a.Claims.Groups), &a.ConnectorID, &a.ConnectorData, &a.Expiry,\n\t\t&a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn a, storage.ErrNotFound\n\t\t}\n\t\treturn a, fmt.Errorf(\"select auth code: %v\", err)\n\t}\n\treturn a, nil\n}\n\nfunc (c *conn) CreateRefresh(r storage.RefreshToken) error {\n\t_, err := c.Exec(`\n\t\tinsert into refresh_token (\n\t\t\tid, client_id, scopes, nonce,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\ttoken, obsolete_token, created_at, last_used\n\t\t)\n\t\tvalues ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16);\n\t`,\n\t\tr.ID, r.ClientID, encoder(r.Scopes), r.Nonce,\n\t\tr.Claims.UserID, r.Claims.Username, r.Claims.PreferredUsername,\n\t\tr.Claims.Email, r.Claims.EmailVerified,\n\t\tencoder(r.Claims.Groups),\n\t\tr.ConnectorID, r.ConnectorData,\n\t\tr.Token, r.ObsoleteToken, r.CreatedAt, r.LastUsed,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert refresh_token: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateRefreshToken(id string, updater func(old storage.RefreshToken) (storage.RefreshToken, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tr, err := getRefresh(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r, err = updater(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate refresh_token\n\t\t\tset\n\t\t\t\tclient_id = $1,\n\t\t\t\tscopes = $2,\n\t\t\t\tnonce = $3,\n\t\t\t\tclaims_user_id = $4,\n\t\t\t\tclaims_username = $5,\n\t\t\t\tclaims_preferred_username = $6,\n\t\t\t\tclaims_email = $7,\n\t\t\t\tclaims_email_verified = $8,\n\t\t\t\tclaims_groups = $9,\n\t\t\t\tconnector_id = $10,\n\t\t\t\tconnector_data = $11,\n\t\t\t\ttoken = $12,\n                obsolete_token = $13,\n\t\t\t\tcreated_at = $14,\n\t\t\t\tlast_used = $15\n\t\t\twhere\n\t\t\t\tid = $16\n\t\t`,\n\t\t\tr.ClientID, encoder(r.Scopes), r.Nonce,\n\t\t\tr.Claims.UserID, r.Claims.Username, r.Claims.PreferredUsername,\n\t\t\tr.Claims.Email, r.Claims.EmailVerified,\n\t\t\tencoder(r.Claims.Groups),\n\t\t\tr.ConnectorID, r.ConnectorData,\n\t\t\tr.Token, r.ObsoleteToken, r.CreatedAt, r.LastUsed, id,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update refresh token: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetRefresh(id string) (storage.RefreshToken, error) {\n\treturn getRefresh(c, id)\n}\n\nfunc getRefresh(q querier, id string) (storage.RefreshToken, error) {\n\treturn scanRefresh(q.QueryRow(`\n\t\tselect\n\t\t\tid, client_id, scopes, nonce,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified,\n\t\t\tclaims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\ttoken, obsolete_token, created_at, last_used\n\t\tfrom refresh_token where id = $1;\n\t`, id))\n}\n\nfunc (c *conn) ListRefreshTokens() ([]storage.RefreshToken, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\tid, client_id, scopes, nonce,\n\t\t\tclaims_user_id, claims_username, claims_preferred_username,\n\t\t\tclaims_email, claims_email_verified, claims_groups,\n\t\t\tconnector_id, connector_data,\n\t\t\ttoken, obsolete_token, created_at, last_used\n\t\tfrom refresh_token;\n\t`)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query: %v\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar tokens []storage.RefreshToken\n\tfor rows.Next() {\n\t\tr, err := scanRefresh(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttokens = append(tokens, r)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"scan: %v\", err)\n\t}\n\treturn tokens, nil\n}\n\nfunc scanRefresh(s scanner) (r storage.RefreshToken, err error) {\n\terr = s.Scan(\n\t\t&r.ID, &r.ClientID, decoder(&r.Scopes), &r.Nonce,\n\t\t&r.Claims.UserID, &r.Claims.Username, &r.Claims.PreferredUsername,\n\t\t&r.Claims.Email, &r.Claims.EmailVerified,\n\t\tdecoder(&r.Claims.Groups),\n\t\t&r.ConnectorID, &r.ConnectorData,\n\t\t&r.Token, &r.ObsoleteToken, &r.CreatedAt, &r.LastUsed,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn r, storage.ErrNotFound\n\t\t}\n\t\treturn r, fmt.Errorf(\"scan refresh_token: %v\", err)\n\t}\n\treturn r, nil\n}\n\nfunc (c *conn) UpdateKeys(updater func(old storage.Keys) (storage.Keys, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tfirstUpdate := false\n\t\t// TODO(ericchiang): errors may cause a transaction be rolled back by the SQL\n\t\t// server. Test this, and consider adding a COUNT() command beforehand.\n\t\told, err := getKeys(tx)\n\t\tif err != nil {\n\t\t\tif err != storage.ErrNotFound {\n\t\t\t\treturn fmt.Errorf(\"get keys: %v\", err)\n\t\t\t}\n\t\t\tfirstUpdate = true\n\t\t\told = storage.Keys{}\n\t\t}\n\n\t\tnk, err := updater(old)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif firstUpdate {\n\t\t\t_, err = tx.Exec(`\n\t\t\t\tinsert into keys (\n\t\t\t\t\tid, verification_keys, signing_key, signing_key_pub, next_rotation\n\t\t\t\t)\n\t\t\t\tvalues ($1, $2, $3, $4, $5);\n\t\t\t`,\n\t\t\t\tkeysRowID, encoder(nk.VerificationKeys), encoder(nk.SigningKey),\n\t\t\t\tencoder(nk.SigningKeyPub), nk.NextRotation,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"insert: %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t_, err = tx.Exec(`\n\t\t\t\tupdate keys\n\t\t\t\tset\n\t\t\t\t    verification_keys = $1,\n\t\t\t\t\tsigning_key = $2,\n\t\t\t\t\tsigning_key_pub = $3,\n\t\t\t\t\tnext_rotation = $4\n\t\t\t\twhere id = $5;\n\t\t\t`,\n\t\t\t\tencoder(nk.VerificationKeys), encoder(nk.SigningKey),\n\t\t\t\tencoder(nk.SigningKeyPub), nk.NextRotation, keysRowID,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"update: %v\", err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetKeys() (keys storage.Keys, err error) {\n\treturn getKeys(c)\n}\n\nfunc getKeys(q querier) (keys storage.Keys, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n\t\t\tverification_keys, signing_key, signing_key_pub, next_rotation\n\t\tfrom keys\n\t\twhere id=$1\n\t`, keysRowID).Scan(\n\t\tdecoder(&keys.VerificationKeys), decoder(&keys.SigningKey),\n\t\tdecoder(&keys.SigningKeyPub), &keys.NextRotation,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn keys, storage.ErrNotFound\n\t\t}\n\t\treturn keys, fmt.Errorf(\"query keys: %v\", err)\n\t}\n\treturn keys, nil\n}\n\nfunc (c *conn) UpdateClient(id string, updater func(old storage.Client) (storage.Client, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tcli, err := getClient(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnc, err := updater(cli)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = tx.Exec(`\n\t\t\tupdate client\n\t\t\tset\n\t\t\t\tsecret = $1,\n\t\t\t\tredirect_uris = $2,\n\t\t\t\ttrusted_peers = $3,\n\t\t\t\tpublic = $4,\n\t\t\t\tname = $5,\n\t\t\t\tlogo_url = $6\n\t\t\twhere id = $7;\n\t\t`, nc.Secret, encoder(nc.RedirectURIs), encoder(nc.TrustedPeers), nc.Public, nc.Name, nc.LogoURL, id,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update client: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) CreateClient(cli storage.Client) error {\n\t_, err := c.Exec(`\n\t\tinsert into client (\n\t\t\tid, secret, redirect_uris, trusted_peers, public, name, logo_url\n\t\t)\n\t\tvalues ($1, $2, $3, $4, $5, $6, $7);\n\t`,\n\t\tcli.ID, cli.Secret, encoder(cli.RedirectURIs), encoder(cli.TrustedPeers),\n\t\tcli.Public, cli.Name, cli.LogoURL,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert client: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc getClient(q querier, id string) (storage.Client, error) {\n\treturn scanClient(q.QueryRow(`\n\t\tselect\n\t\t\tid, secret, redirect_uris, trusted_peers, public, name, logo_url\n\t    from client where id = $1;\n\t`, id))\n}\n\nfunc (c *conn) GetClient(id string) (storage.Client, error) {\n\treturn getClient(c, id)\n}\n\nfunc (c *conn) ListClients() ([]storage.Client, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\tid, secret, redirect_uris, trusted_peers, public, name, logo_url\n\t\tfrom client;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar clients []storage.Client\n\tfor rows.Next() {\n\t\tcli, err := scanClient(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tclients = append(clients, cli)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn clients, nil\n}\n\nfunc scanClient(s scanner) (cli storage.Client, err error) {\n\terr = s.Scan(\n\t\t&cli.ID, &cli.Secret, decoder(&cli.RedirectURIs), decoder(&cli.TrustedPeers),\n\t\t&cli.Public, &cli.Name, &cli.LogoURL,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn cli, storage.ErrNotFound\n\t\t}\n\t\treturn cli, fmt.Errorf(\"get client: %v\", err)\n\t}\n\treturn cli, nil\n}\n\nfunc (c *conn) CreatePassword(p storage.Password) error {\n\tp.Email = strings.ToLower(p.Email)\n\t_, err := c.Exec(`\n\t\tinsert into password (\n\t\t\temail, hash, username, user_id\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4\n\t\t);\n\t`,\n\t\tp.Email, p.Hash, p.Username, p.UserID,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert password: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdatePassword(email string, updater func(p storage.Password) (storage.Password, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tp, err := getPassword(tx, email)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnp, err := updater(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate password\n\t\t\tset\n\t\t\t\thash = $1, username = $2, user_id = $3\n\t\t\twhere email = $4;\n\t\t`,\n\t\t\tnp.Hash, np.Username, np.UserID, p.Email,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update password: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetPassword(email string) (storage.Password, error) {\n\treturn getPassword(c, email)\n}\n\nfunc getPassword(q querier, email string) (p storage.Password, err error) {\n\treturn scanPassword(q.QueryRow(`\n\t\tselect\n\t\t\temail, hash, username, user_id\n\t\tfrom password where email = $1;\n\t`, strings.ToLower(email)))\n}\n\nfunc (c *conn) ListPasswords() ([]storage.Password, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\temail, hash, username, user_id\n\t\tfrom password;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar passwords []storage.Password\n\tfor rows.Next() {\n\t\tp, err := scanPassword(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpasswords = append(passwords, p)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn passwords, nil\n}\n\nfunc scanPassword(s scanner) (p storage.Password, err error) {\n\terr = s.Scan(\n\t\t&p.Email, &p.Hash, &p.Username, &p.UserID,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn p, storage.ErrNotFound\n\t\t}\n\t\treturn p, fmt.Errorf(\"select password: %v\", err)\n\t}\n\treturn p, nil\n}\n\nfunc (c *conn) CreateOfflineSessions(s storage.OfflineSessions) error {\n\t_, err := c.Exec(`\n\t\tinsert into offline_session (\n\t\t\tuser_id, conn_id, refresh, connector_data\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4\n\t\t);\n\t`,\n\t\ts.UserID, s.ConnID, encoder(s.Refresh), s.ConnectorData,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert offline session: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateOfflineSessions(userID string, connID string, updater func(s storage.OfflineSessions) (storage.OfflineSessions, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\ts, err := getOfflineSessions(tx, userID, connID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnewSession, err := updater(s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate offline_session\n\t\t\tset\n\t\t\t\trefresh = $1,\n\t\t\t\tconnector_data = $2\n\t\t\twhere user_id = $3 AND conn_id = $4;\n\t\t`,\n\t\t\tencoder(newSession.Refresh), newSession.ConnectorData, s.UserID, s.ConnID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update offline session: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetOfflineSessions(userID string, connID string) (storage.OfflineSessions, error) {\n\treturn getOfflineSessions(c, userID, connID)\n}\n\nfunc getOfflineSessions(q querier, userID string, connID string) (storage.OfflineSessions, error) {\n\treturn scanOfflineSessions(q.QueryRow(`\n\t\tselect\n\t\t\tuser_id, conn_id, refresh, connector_data\n\t\tfrom offline_session\n\t\twhere user_id = $1 AND conn_id = $2;\n\t\t`, userID, connID))\n}\n\nfunc scanOfflineSessions(s scanner) (o storage.OfflineSessions, err error) {\n\terr = s.Scan(\n\t\t&o.UserID, &o.ConnID, decoder(&o.Refresh), &o.ConnectorData,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn o, storage.ErrNotFound\n\t\t}\n\t\treturn o, fmt.Errorf(\"select offline session: %v\", err)\n\t}\n\treturn o, nil\n}\n\nfunc (c *conn) CreateConnector(connector storage.Connector) error {\n\t_, err := c.Exec(`\n\t\tinsert into connector (\n\t\t\tid, type, name, resource_version, config\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5\n\t\t);\n\t`,\n\t\tconnector.ID, connector.Type, connector.Name, connector.ResourceVersion, connector.Config,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert connector: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) UpdateConnector(id string, updater func(s storage.Connector) (storage.Connector, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tconnector, err := getConnector(tx, id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnewConn, err := updater(connector)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate connector\n\t\t\tset\n\t\t\t    type = $1,\n\t\t\t    name = $2,\n\t\t\t    resource_version = $3,\n\t\t\t    config = $4\n\t\t\twhere id = $5;\n\t\t`,\n\t\t\tnewConn.Type, newConn.Name, newConn.ResourceVersion, newConn.Config, connector.ID,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update connector: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (c *conn) GetConnector(id string) (storage.Connector, error) {\n\treturn getConnector(c, id)\n}\n\nfunc getConnector(q querier, id string) (storage.Connector, error) {\n\treturn scanConnector(q.QueryRow(`\n\t\tselect\n\t\t\tid, type, name, resource_version, config\n\t\tfrom connector\n\t\twhere id = $1;\n\t\t`, id))\n}\n\nfunc scanConnector(s scanner) (c storage.Connector, err error) {\n\terr = s.Scan(\n\t\t&c.ID, &c.Type, &c.Name, &c.ResourceVersion, &c.Config,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn c, storage.ErrNotFound\n\t\t}\n\t\treturn c, fmt.Errorf(\"select connector: %v\", err)\n\t}\n\treturn c, nil\n}\n\nfunc (c *conn) ListConnectors() ([]storage.Connector, error) {\n\trows, err := c.Query(`\n\t\tselect\n\t\t\tid, type, name, resource_version, config\n\t\tfrom connector;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar connectors []storage.Connector\n\tfor rows.Next() {\n\t\tconn, err := scanConnector(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconnectors = append(connectors, conn)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn connectors, nil\n}\n\nfunc (c *conn) DeleteAuthRequest(id string) error { return c.delete(\"auth_request\", \"id\", id) }\nfunc (c *conn) DeleteAuthCode(id string) error    { return c.delete(\"auth_code\", \"id\", id) }\nfunc (c *conn) DeleteClient(id string) error      { return c.delete(\"client\", \"id\", id) }\nfunc (c *conn) DeleteRefresh(id string) error     { return c.delete(\"refresh_token\", \"id\", id) }\nfunc (c *conn) DeletePassword(email string) error {\n\treturn c.delete(\"password\", \"email\", strings.ToLower(email))\n}\nfunc (c *conn) DeleteConnector(id string) error { return c.delete(\"connector\", \"id\", id) }\n\nfunc (c *conn) DeleteOfflineSessions(userID string, connID string) error {\n\tresult, err := c.Exec(`delete from offline_session where user_id = $1 AND conn_id = $2`, userID, connID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete offline_session: user_id = %s, conn_id = %s\", userID, connID)\n\t}\n\n\t// For now mandate that the driver implements RowsAffected. If we ever need to support\n\t// a driver that doesn't implement this, we can run this in a transaction with a get beforehand.\n\tn, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rows affected: %v\", err)\n\t}\n\tif n < 1 {\n\t\treturn storage.ErrNotFound\n\t}\n\treturn nil\n}\n\n// Do NOT call directly. Does not escape table.\nfunc (c *conn) delete(table, field, id string) error {\n\tresult, err := c.Exec(`delete from `+table+` where `+field+` = $1`, id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete %s: %v\", table, id)\n\t}\n\n\t// For now mandate that the driver implements RowsAffected. If we ever need to support\n\t// a driver that doesn't implement this, we can run this in a transaction with a get beforehand.\n\tn, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rows affected: %v\", err)\n\t}\n\tif n < 1 {\n\t\treturn storage.ErrNotFound\n\t}\n\treturn nil\n}\n\nfunc (c *conn) CreateDeviceRequest(d storage.DeviceRequest) error {\n\t_, err := c.Exec(`\n\t\tinsert into device_request (\n\t\t\tuser_code, device_code, client_id, client_secret, scopes, expiry\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5, $6\n\t\t);`,\n\t\td.UserCode, d.DeviceCode, d.ClientID, d.ClientSecret, encoder(d.Scopes), d.Expiry,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert device request: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) CreateDeviceToken(t storage.DeviceToken) error {\n\t_, err := c.Exec(`\n\t\tinsert into device_token (\n\t\t\tdevice_code, status, token, expiry, last_request, poll_interval, code_challenge, code_challenge_method\n\t\t)\n\t\tvalues (\n\t\t\t$1, $2, $3, $4, $5, $6, $7, $8\n\t\t);`,\n\t\tt.DeviceCode, t.Status, t.Token, t.Expiry, t.LastRequestTime, t.PollIntervalSeconds, t.PKCE.CodeChallenge, t.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif c.alreadyExistsCheck(err) {\n\t\t\treturn storage.ErrAlreadyExists\n\t\t}\n\t\treturn fmt.Errorf(\"insert device token: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *conn) GetDeviceRequest(userCode string) (storage.DeviceRequest, error) {\n\treturn getDeviceRequest(c, userCode)\n}\n\nfunc getDeviceRequest(q querier, userCode string) (d storage.DeviceRequest, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n            device_code, client_id, client_secret, scopes, expiry\n\t\tfrom device_request where user_code = $1;\n\t`, userCode).Scan(\n\t\t&d.DeviceCode, &d.ClientID, &d.ClientSecret, decoder(&d.Scopes), &d.Expiry,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn d, storage.ErrNotFound\n\t\t}\n\t\treturn d, fmt.Errorf(\"select device token: %v\", err)\n\t}\n\td.UserCode = userCode\n\treturn d, nil\n}\n\nfunc (c *conn) GetDeviceToken(deviceCode string) (storage.DeviceToken, error) {\n\treturn getDeviceToken(c, deviceCode)\n}\n\nfunc getDeviceToken(q querier, deviceCode string) (a storage.DeviceToken, err error) {\n\terr = q.QueryRow(`\n\t\tselect\n            status, token, expiry, last_request, poll_interval, code_challenge, code_challenge_method\n\t\tfrom device_token where device_code = $1;\n\t`, deviceCode).Scan(\n\t\t&a.Status, &a.Token, &a.Expiry, &a.LastRequestTime, &a.PollIntervalSeconds, &a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod,\n\t)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn a, storage.ErrNotFound\n\t\t}\n\t\treturn a, fmt.Errorf(\"select device token: %v\", err)\n\t}\n\ta.DeviceCode = deviceCode\n\treturn a, nil\n}\n\nfunc (c *conn) UpdateDeviceToken(deviceCode string, updater func(old storage.DeviceToken) (storage.DeviceToken, error)) error {\n\treturn c.ExecTx(func(tx *trans) error {\n\t\tr, err := getDeviceToken(tx, deviceCode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r, err = updater(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tx.Exec(`\n\t\t\tupdate device_token\n\t\t\tset\n\t\t\t\tstatus = $1, \n\t\t\t\ttoken = $2,\n\t\t\t\tlast_request = $3,\n\t\t\t\tpoll_interval = $4,\n\t\t\t\tcode_challenge = $5,\n\t\t\t\tcode_challenge_method = $6\n\t\t\twhere\n\t\t\t\tdevice_code = $7\n\t\t`,\n\t\t\tr.Status, r.Token, r.LastRequestTime, r.PollIntervalSeconds, r.PKCE.CodeChallenge, r.PKCE.CodeChallengeMethod, r.DeviceCode,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"update device token: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package sql\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n)\n\nfunc (c *conn) migrate() (int, error) {\n\t_, err := c.Exec(`\n\t\tcreate table if not exists migrations (\n\t\t\tnum integer not null,\n\t\t\tat timestamptz not null\n\t\t);\n\t`)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"creating migration table: %v\", err)\n\t}\n\n\ti := 0\n\tdone := false\n\n\tvar flavorMigrations []migration\n\tfor _, m := range migrations {\n\t\tif m.flavor == nil || m.flavor == c.flavor {\n\t\t\tflavorMigrations = append(flavorMigrations, m)\n\t\t}\n\t}\n\n\tfor {\n\t\terr := c.ExecTx(func(tx *trans) error {\n\t\t\t// Within a transaction, perform a single migration.\n\t\t\tvar (\n\t\t\t\tnum sql.NullInt64\n\t\t\t\tn   int\n\t\t\t)\n\t\t\tif err := tx.QueryRow(`select max(num) from migrations;`).Scan(&num); err != nil {\n\t\t\t\treturn fmt.Errorf(\"select max migration: %v\", err)\n\t\t\t}\n\t\t\tif num.Valid {\n\t\t\t\tn = int(num.Int64)\n\t\t\t}\n\t\t\tif n >= len(flavorMigrations) {\n\t\t\t\tdone = true\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tmigrationNum := n + 1\n\t\t\tm := flavorMigrations[n]\n\t\t\tfor i := range m.stmts {\n\t\t\t\tif _, err := tx.Exec(m.stmts[i]); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"migration %d statement %d failed: %v\", migrationNum, i+1, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq := `insert into migrations (num, at) values ($1, now());`\n\t\t\tif _, err := tx.Exec(q, migrationNum); err != nil {\n\t\t\t\treturn fmt.Errorf(\"update migration table: %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn i, err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\ti++\n\t}\n\n\treturn i, nil\n}\n\ntype migration struct {\n\tstmts []string\n\n\t// If flavor is nil the migration will take place for all database backend flavors.\n\t// If specified, only for that corresponding flavor, in that case stmts can be written\n\t// in the specific SQL dialect.\n\tflavor *flavor\n}\n\n// All SQL flavors share migration strategies.\nvar migrations = []migration{\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table client (\n\t\t\t\tid text not null primary key,\n\t\t\t\tsecret text not null,\n\t\t\t\tredirect_uris bytea not null, -- JSON array of strings\n\t\t\t\ttrusted_peers bytea not null, -- JSON array of strings\n\t\t\t\tpublic boolean not null,\n\t\t\t\tname text not null,\n\t\t\t\tlogo_url text not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table auth_request (\n\t\t\t\tid text not null primary key,\n\t\t\t\tclient_id text not null,\n\t\t\t\tresponse_types bytea not null, -- JSON array of strings\n\t\t\t\tscopes bytea not null,         -- JSON array of strings\n\t\t\t\tredirect_uri text not null,\n\t\t\t\tnonce text not null,\n\t\t\t\tstate text not null,\n\t\t\t\tforce_approval_prompt boolean not null,\n\n\t\t\t\tlogged_in boolean not null,\n\n\t\t\t\tclaims_user_id text not null,\n\t\t\t\tclaims_username text not null,\n\t\t\t\tclaims_email text not null,\n\t\t\t\tclaims_email_verified boolean not null,\n\t\t\t\tclaims_groups bytea not null, -- JSON array of strings\n\n\t\t\t\tconnector_id text not null,\n\t\t\t\tconnector_data bytea,\n\n\t\t\t\texpiry timestamptz not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table auth_code (\n\t\t\t\tid text not null primary key,\n\t\t\t\tclient_id text not null,\n\t\t\t\tscopes bytea not null, -- JSON array of strings\n\t\t\t\tnonce text not null,\n\t\t\t\tredirect_uri text not null,\n\n\t\t\t\tclaims_user_id text not null,\n\t\t\t\tclaims_username text not null,\n\t\t\t\tclaims_email text not null,\n\t\t\t\tclaims_email_verified boolean not null,\n\t\t\t\tclaims_groups bytea not null, -- JSON array of strings\n\n\t\t\t\tconnector_id text not null,\n\t\t\t\tconnector_data bytea,\n\n\t\t\t\texpiry timestamptz not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table refresh_token (\n\t\t\t\tid text not null primary key,\n\t\t\t\tclient_id text not null,\n\t\t\t\tscopes bytea not null, -- JSON array of strings\n\t\t\t\tnonce text not null,\n\n\t\t\t\tclaims_user_id text not null,\n\t\t\t\tclaims_username text not null,\n\t\t\t\tclaims_email text not null,\n\t\t\t\tclaims_email_verified boolean not null,\n\t\t\t\tclaims_groups bytea not null, -- JSON array of strings\n\n\t\t\t\tconnector_id text not null,\n\t\t\t\tconnector_data bytea\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table password (\n\t\t\t\temail text not null primary key,\n\t\t\t\thash bytea not null,\n\t\t\t\tusername text not null,\n\t\t\t\tuser_id text not null\n\t\t\t);`,\n\t\t\t`\n\t\t\t-- keys is a weird table because we only ever expect there to be a single row\n\t\t\tcreate table keys (\n\t\t\t\tid text not null primary key,\n\t\t\t\tverification_keys bytea not null, -- JSON array\n\t\t\t\tsigning_key bytea not null,       -- JSON object\n\t\t\t\tsigning_key_pub bytea not null,   -- JSON object\n\t\t\t\tnext_rotation timestamptz not null\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column token text not null default '';`,\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column created_at timestamptz not null default '0001-01-01 00:00:00 UTC';`,\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column last_used timestamptz not null default '0001-01-01 00:00:00 UTC';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table offline_session (\n\t\t\t\tuser_id text not null,\n\t\t\t\tconn_id text not null,\n\t\t\t\trefresh bytea not null,\n\t\t\t\tPRIMARY KEY (user_id, conn_id)\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table connector (\n\t\t\t\tid text not null primary key,\n\t\t\t\ttype text not null,\n\t\t\t\tname text not null,\n\t\t\t\tresource_version text not null,\n\t\t\t\tconfig bytea\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_code\n\t\t\t\tadd column claims_preferred_username text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column claims_preferred_username text not null default '';`,\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column claims_preferred_username text not null default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table offline_session\n\t\t\t\tadd column connector_data bytea;\n\t\t\t`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tmodify column state varchar(4096);\n\t\t\t`,\n\t\t},\n\t\tflavor: &flavorMySQL,\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\tcreate table device_request (\n\t\t\t\tuser_code text not null primary key,\n\t\t\t\tdevice_code text not null,\n\t\t\t\tclient_id text not null,\n\t\t\t\tclient_secret text ,\n\t\t\t\tscopes bytea not null, -- JSON array of strings\n\t\t\t\texpiry timestamptz not null\n\t\t\t);`,\n\t\t\t`\n\t\t\tcreate table device_token (\n\t\t\t\tdevice_code text not null primary key,\n\t\t\t\tstatus text not null,\n\t\t\t\ttoken bytea,\n\t\t\t\texpiry timestamptz not null,\n\t\t\t\tlast_request timestamptz not null,\n                poll_interval integer not null\n\t\t\t);`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column code_challenge text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column code_challenge_method text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_code\n\t\t\t\tadd column code_challenge text not null default '';`,\n\t\t\t`\n\t\t\talter table auth_code\n\t\t\t\tadd column code_challenge_method text not null default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table refresh_token\n\t\t\t\tadd column obsolete_token text default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table device_token\n\t\t\t\tadd column code_challenge text not null default '';`,\n\t\t\t`\n\t\t\talter table device_token\n\t\t\t\tadd column code_challenge_method text not null default '';`,\n\t\t},\n\t},\n\t{\n\t\tstmts: []string{\n\t\t\t`\n\t\t\talter table auth_request\n\t\t\t\tadd column hmac_key bytea;`,\n\t\t},\n\t},\n}\n", "package storage\n\nimport (\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"encoding/base32\"\n\t\"errors\"\n\t\"io\"\n\t\"math/big\"\n\t\"strings\"\n\t\"time\"\n\n\tjose \"gopkg.in/square/go-jose.v2\"\n)\n\nvar (\n\t// ErrNotFound is the error returned by storages if a resource cannot be found.\n\tErrNotFound = errors.New(\"not found\")\n\n\t// ErrAlreadyExists is the error returned by storages if a resource ID is taken during a create.\n\tErrAlreadyExists = errors.New(\"ID already exists\")\n)\n\n// Kubernetes only allows lower case letters for names.\n//\n// TODO(ericchiang): refactor ID creation onto the storage.\nvar encoding = base32.NewEncoding(\"abcdefghijklmnopqrstuvwxyz234567\")\n\n// Valid characters for user codes\nconst validUserCharacters = \"BCDFGHJKLMNPQRSTVWXZ\"\n\n// NewDeviceCode returns a 32 char alphanumeric cryptographically secure string\nfunc NewDeviceCode() string {\n\treturn newSecureID(32)\n}\n\n// NewID returns a random string which can be used as an ID for objects.\nfunc NewID() string {\n\treturn newSecureID(16)\n}\n\nfunc newSecureID(len int) string {\n\tbuff := make([]byte, len) // random ID.\n\tif _, err := io.ReadFull(rand.Reader, buff); err != nil {\n\t\tpanic(err)\n\t}\n\t// Avoid the identifier to begin with number and trim padding\n\treturn string(buff[0]%26+'a') + strings.TrimRight(encoding.EncodeToString(buff[1:]), \"=\")\n}\n\n// NewHMACKey returns a random key which can be used in the computation of an HMAC\nfunc NewHMACKey(h crypto.Hash) []byte {\n\treturn []byte(newSecureID(h.Size()))\n}\n\n// GCResult returns the number of objects deleted by garbage collection.\ntype GCResult struct {\n\tAuthRequests   int64\n\tAuthCodes      int64\n\tDeviceRequests int64\n\tDeviceTokens   int64\n}\n\n// IsEmpty returns whether the garbage collection result is empty or not.\nfunc (g *GCResult) IsEmpty() bool {\n\treturn g.AuthRequests == 0 &&\n\t\tg.AuthCodes == 0 &&\n\t\tg.DeviceRequests == 0 &&\n\t\tg.DeviceTokens == 0\n}\n\n// Storage is the storage interface used by the server. Implementations are\n// required to be able to perform atomic compare-and-swap updates and either\n// support timezones or standardize on UTC.\ntype Storage interface {\n\tClose() error\n\n\t// TODO(ericchiang): Let the storages set the IDs of these objects.\n\tCreateAuthRequest(a AuthRequest) error\n\tCreateClient(c Client) error\n\tCreateAuthCode(c AuthCode) error\n\tCreateRefresh(r RefreshToken) error\n\tCreatePassword(p Password) error\n\tCreateOfflineSessions(s OfflineSessions) error\n\tCreateConnector(c Connector) error\n\tCreateDeviceRequest(d DeviceRequest) error\n\tCreateDeviceToken(d DeviceToken) error\n\n\t// TODO(ericchiang): return (T, bool, error) so we can indicate not found\n\t// requests that way instead of using ErrNotFound.\n\tGetAuthRequest(id string) (AuthRequest, error)\n\tGetAuthCode(id string) (AuthCode, error)\n\tGetClient(id string) (Client, error)\n\tGetKeys() (Keys, error)\n\tGetRefresh(id string) (RefreshToken, error)\n\tGetPassword(email string) (Password, error)\n\tGetOfflineSessions(userID string, connID string) (OfflineSessions, error)\n\tGetConnector(id string) (Connector, error)\n\tGetDeviceRequest(userCode string) (DeviceRequest, error)\n\tGetDeviceToken(deviceCode string) (DeviceToken, error)\n\n\tListClients() ([]Client, error)\n\tListRefreshTokens() ([]RefreshToken, error)\n\tListPasswords() ([]Password, error)\n\tListConnectors() ([]Connector, error)\n\n\t// Delete methods MUST be atomic.\n\tDeleteAuthRequest(id string) error\n\tDeleteAuthCode(code string) error\n\tDeleteClient(id string) error\n\tDeleteRefresh(id string) error\n\tDeletePassword(email string) error\n\tDeleteOfflineSessions(userID string, connID string) error\n\tDeleteConnector(id string) error\n\n\t// Update methods take a function for updating an object then performs that update within\n\t// a transaction. \"updater\" functions may be called multiple times by a single update call.\n\t//\n\t// Because new fields may be added to resources, updaters should only modify existing\n\t// fields on the old object rather then creating new structs. For example:\n\t//\n\t//\t\tupdater := func(old storage.Client) (storage.Client, error) {\n\t//\t\t\told.Secret = newSecret\n\t//\t\t\treturn old, nil\n\t//\t\t}\n\t//\t\tif err := s.UpdateClient(clientID, updater); err != nil {\n\t//\t\t\t// update failed, handle error\n\t//\t\t}\n\t//\n\tUpdateClient(id string, updater func(old Client) (Client, error)) error\n\tUpdateKeys(updater func(old Keys) (Keys, error)) error\n\tUpdateAuthRequest(id string, updater func(a AuthRequest) (AuthRequest, error)) error\n\tUpdateRefreshToken(id string, updater func(r RefreshToken) (RefreshToken, error)) error\n\tUpdatePassword(email string, updater func(p Password) (Password, error)) error\n\tUpdateOfflineSessions(userID string, connID string, updater func(s OfflineSessions) (OfflineSessions, error)) error\n\tUpdateConnector(id string, updater func(c Connector) (Connector, error)) error\n\tUpdateDeviceToken(deviceCode string, updater func(t DeviceToken) (DeviceToken, error)) error\n\n\t// GarbageCollect deletes all expired AuthCodes,\n\t// AuthRequests, DeviceRequests, and DeviceTokens.\n\tGarbageCollect(now time.Time) (GCResult, error)\n}\n\n// Client represents an OAuth2 client.\n//\n// For further reading see:\n//   * Trusted peers: https://developers.google.com/identity/protocols/CrossClientAuth\n//   * Public clients: https://developers.google.com/api-client-library/python/auth/installed-app\ntype Client struct {\n\t// Client ID and secret used to identify the client.\n\tID        string `json:\"id\" yaml:\"id\"`\n\tIDEnv     string `json:\"idEnv\" yaml:\"idEnv\"`\n\tSecret    string `json:\"secret\" yaml:\"secret\"`\n\tSecretEnv string `json:\"secretEnv\" yaml:\"secretEnv\"`\n\n\t// A registered set of redirect URIs. When redirecting from dex to the client, the URI\n\t// requested to redirect to MUST match one of these values, unless the client is \"public\".\n\tRedirectURIs []string `json:\"redirectURIs\" yaml:\"redirectURIs\"`\n\n\t// TrustedPeers are a list of peers which can issue tokens on this client's behalf using\n\t// the dynamic \"oauth2:server:client_id:(client_id)\" scope. If a peer makes such a request,\n\t// this client's ID will appear as the ID Token's audience.\n\t//\n\t// Clients inherently trust themselves.\n\tTrustedPeers []string `json:\"trustedPeers\" yaml:\"trustedPeers\"`\n\n\t// Public clients must use either use a redirectURL 127.0.0.1:X or \"urn:ietf:wg:oauth:2.0:oob\"\n\tPublic bool `json:\"public\" yaml:\"public\"`\n\n\t// Name and LogoURL used when displaying this client to the end user.\n\tName    string `json:\"name\" yaml:\"name\"`\n\tLogoURL string `json:\"logoURL\" yaml:\"logoURL\"`\n}\n\n// Claims represents the ID Token claims supported by the server.\ntype Claims struct {\n\tUserID            string\n\tUsername          string\n\tPreferredUsername string\n\tEmail             string\n\tEmailVerified     bool\n\n\tGroups []string\n}\n\n// PKCE is a container for the data needed to perform Proof Key for Code Exchange (RFC 7636) auth flow\ntype PKCE struct {\n\tCodeChallenge       string\n\tCodeChallengeMethod string\n}\n\n// AuthRequest represents a OAuth2 client authorization request. It holds the state\n// of a single auth flow up to the point that the user authorizes the client.\ntype AuthRequest struct {\n\t// ID used to identify the authorization request.\n\tID string\n\n\t// ID of the client requesting authorization from a user.\n\tClientID string\n\n\t// Values parsed from the initial request. These describe the resources the client is\n\t// requesting as well as values describing the form of the response.\n\tResponseTypes []string\n\tScopes        []string\n\tRedirectURI   string\n\tNonce         string\n\tState         string\n\n\t// The client has indicated that the end user must be shown an approval prompt\n\t// on all requests. The server cannot cache their initial action for subsequent\n\t// attempts.\n\tForceApprovalPrompt bool\n\n\tExpiry time.Time\n\n\t// Has the user proved their identity through a backing identity provider?\n\t//\n\t// If false, the following fields are invalid.\n\tLoggedIn bool\n\n\t// The identity of the end user. Generally nil until the user authenticates\n\t// with a backend.\n\tClaims Claims\n\n\t// The connector used to login the user and any data the connector wishes to persists.\n\t// Set when the user authenticates.\n\tConnectorID   string\n\tConnectorData []byte\n\n\t// PKCE CodeChallenge and CodeChallengeMethod\n\tPKCE PKCE\n\n\t// HMACKey is used when generating an AuthRequest-specific HMAC\n\tHMACKey []byte\n}\n\n// AuthCode represents a code which can be exchanged for an OAuth2 token response.\n//\n// This value is created once an end user has authorized a client, the server has\n// redirect the end user back to the client, but the client hasn't exchanged the\n// code for an access_token and id_token.\ntype AuthCode struct {\n\t// Actual string returned as the \"code\" value.\n\tID string\n\n\t// The client this code value is valid for. When exchanging the code for a\n\t// token response, the client must use its client_secret to authenticate.\n\tClientID string\n\n\t// As part of the OAuth2 spec when a client makes a token request it MUST\n\t// present the same redirect_uri as the initial redirect. This values is saved\n\t// to make this check.\n\t//\n\t// https://tools.ietf.org/html/rfc6749#section-4.1.3\n\tRedirectURI string\n\n\t// If provided by the client in the initial request, the provider MUST create\n\t// a ID Token with this nonce in the JWT payload.\n\tNonce string\n\n\t// Scopes authorized by the end user for the client.\n\tScopes []string\n\n\t// Authentication data provided by an upstream source.\n\tConnectorID   string\n\tConnectorData []byte\n\tClaims        Claims\n\n\tExpiry time.Time\n\n\t// PKCE CodeChallenge and CodeChallengeMethod\n\tPKCE PKCE\n}\n\n// RefreshToken is an OAuth2 refresh token which allows a client to request new\n// tokens on the end user's behalf.\ntype RefreshToken struct {\n\tID string\n\n\t// A single token that's rotated every time the refresh token is refreshed.\n\t//\n\t// May be empty.\n\tToken         string\n\tObsoleteToken string\n\n\tCreatedAt time.Time\n\tLastUsed  time.Time\n\n\t// Client this refresh token is valid for.\n\tClientID string\n\n\t// Authentication data provided by an upstream source.\n\tConnectorID   string\n\tConnectorData []byte\n\tClaims        Claims\n\n\t// Scopes present in the initial request. Refresh requests may specify a set\n\t// of scopes different from the initial request when refreshing a token,\n\t// however those scopes must be encompassed by this set.\n\tScopes []string\n\n\t// Nonce value supplied during the initial redirect. This is required to be part\n\t// of the claims of any future id_token generated by the client.\n\tNonce string\n}\n\n// RefreshTokenRef is a reference object that contains metadata about refresh tokens.\ntype RefreshTokenRef struct {\n\tID string\n\n\t// Client the refresh token is valid for.\n\tClientID string\n\n\tCreatedAt time.Time\n\tLastUsed  time.Time\n}\n\n// OfflineSessions objects are sessions pertaining to users with refresh tokens.\ntype OfflineSessions struct {\n\t// UserID of an end user who has logged in to the server.\n\tUserID string\n\n\t// The ID of the connector used to login the user.\n\tConnID string\n\n\t// Refresh is a hash table of refresh token reference objects\n\t// indexed by the ClientID of the refresh token.\n\tRefresh map[string]*RefreshTokenRef\n\n\t// Authentication data provided by an upstream source.\n\tConnectorData []byte\n}\n\n// Password is an email to password mapping managed by the storage.\ntype Password struct {\n\t// Email and identifying name of the password. Emails are assumed to be valid and\n\t// determining that an end-user controls the address is left to an outside application.\n\t//\n\t// Emails are case insensitive and should be standardized by the storage.\n\t//\n\t// Storages that don't support an extended character set for IDs, such as '.' and '@'\n\t// (cough cough, kubernetes), must map this value appropriately.\n\tEmail string `json:\"email\"`\n\n\t// Bcrypt encoded hash of the password. This package enforces a min cost value of 10\n\tHash []byte `json:\"hash\"`\n\n\t// Bcrypt encoded hash of the password set in environment variable of this name.\n\tHashFromEnv string `json:\"hashFromEnv\"`\n\n\t// Optional username to display. NOT used during login.\n\tUsername string `json:\"username\"`\n\n\t// Randomly generated user ID. This is NOT the primary ID of the Password object.\n\tUserID string `json:\"userID\"`\n}\n\n// Connector is an object that contains the metadata about connectors used to login to Dex.\ntype Connector struct {\n\t// ID that will uniquely identify the connector object.\n\tID string `json:\"id\"`\n\t// The Type of the connector. E.g. 'oidc' or 'ldap'\n\tType string `json:\"type\"`\n\t// The Name of the connector that is used when displaying it to the end user.\n\tName string `json:\"name\"`\n\t// ResourceVersion is the static versioning used to keep track of dynamic configuration\n\t// changes to the connector object made by the API calls.\n\tResourceVersion string `json:\"resourceVersion\"`\n\t// Config holds all the configuration information specific to the connector type. Since there\n\t// no generic struct we can use for this purpose, it is stored as a byte stream.\n\tConfig []byte `json:\"email\"`\n}\n\n// VerificationKey is a rotated signing key which can still be used to verify\n// signatures.\ntype VerificationKey struct {\n\tPublicKey *jose.JSONWebKey `json:\"publicKey\"`\n\tExpiry    time.Time        `json:\"expiry\"`\n}\n\n// Keys hold encryption and signing keys.\ntype Keys struct {\n\t// Key for creating and verifying signatures. These may be nil.\n\tSigningKey    *jose.JSONWebKey\n\tSigningKeyPub *jose.JSONWebKey\n\n\t// Old signing keys which have been rotated but can still be used to validate\n\t// existing signatures.\n\tVerificationKeys []VerificationKey\n\n\t// The next time the signing key will rotate.\n\t//\n\t// For caching purposes, implementations MUST NOT update keys before this time.\n\tNextRotation time.Time\n}\n\n// NewUserCode returns a randomized 8 character user code for the device flow.\n// No vowels are included to prevent accidental generation of words\nfunc NewUserCode() string {\n\tcode := randomString(8)\n\treturn code[:4] + \"-\" + code[4:]\n}\n\nfunc randomString(n int) string {\n\tv := big.NewInt(int64(len(validUserCharacters)))\n\tbytes := make([]byte, n)\n\tfor i := 0; i < n; i++ {\n\t\tc, _ := rand.Int(rand.Reader, v)\n\t\tbytes[i] = validUserCharacters[c.Int64()]\n\t}\n\treturn string(bytes)\n}\n\n// DeviceRequest represents an OIDC device authorization request. It holds the state of a device request until the user\n// authenticates using their user code or the expiry time passes.\ntype DeviceRequest struct {\n\t// The code the user will enter in a browser\n\tUserCode string\n\t// The unique device code for device authentication\n\tDeviceCode string\n\t// The client ID the code is for\n\tClientID string\n\t// The Client Secret\n\tClientSecret string\n\t// The scopes the device requests\n\tScopes []string\n\t// The expire time\n\tExpiry time.Time\n}\n\n// DeviceToken is a structure which represents the actual token of an authorized device and its rotation parameters\ntype DeviceToken struct {\n\tDeviceCode          string\n\tStatus              string\n\tToken               string\n\tExpiry              time.Time\n\tLastRequestTime     time.Time\n\tPollIntervalSeconds int\n\tPKCE                PKCE\n}\n"], "filenames": ["server/handlers.go", "server/oauth2.go", "storage/conformance/conformance.go", "storage/ent/client/authrequest.go", "storage/ent/client/types.go", "storage/ent/db/authrequest.go", "storage/ent/db/authrequest/authrequest.go", "storage/ent/db/authrequest/where.go", "storage/ent/db/authrequest_create.go", "storage/ent/db/authrequest_update.go", "storage/ent/db/migrate/schema.go", "storage/ent/db/mutation.go", "storage/ent/schema/authrequest.go", "storage/etcd/types.go", "storage/health.go", "storage/kubernetes/types.go", "storage/sql/crud.go", "storage/sql/migrate.go", "storage/storage.go"], "buggy_code_start_loc": [3, 4, 107, 33, 47, 57, 47, 194, 157, 189, 57, 1207, 30, 86, 4, 358, 134, 293, 3], "buggy_code_end_loc": [555, 578, 819, 96, 47, 299, 73, 1506, 496, 871, 57, 2497, 88, 127, 18, 414, 220, 293, 225], "fixing_code_start_loc": [4, 5, 107, 34, 48, 58, 48, 195, 158, 190, 58, 1208, 30, 87, 5, 359, 134, 294, 4], "fixing_code_end_loc": [586, 581, 823, 99, 49, 310, 77, 1590, 514, 898, 59, 2552, 91, 132, 20, 419, 223, 301, 235], "type": "CWE-200", "message": "Dex is an identity service that uses OpenID Connect to drive authentication for other apps. Dex instances with public clients (and by extension, clients accepting tokens issued by those Dex instances) are affected by this vulnerability if they are running a version prior to 2.35.0. An attacker can exploit this vulnerability by making a victim navigate to a malicious website and guiding them through the OIDC flow, stealing the OAuth authorization code in the process. The authorization code then can be exchanged by the attacker for a token, gaining access to applications accepting that token. Version 2.35.0 has introduced a fix for this issue. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39222", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-06T18:16:09.037", "lastModified": "2022-12-03T02:33:47.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dex is an identity service that uses OpenID Connect to drive authentication for other apps. Dex instances with public clients (and by extension, clients accepting tokens issued by those Dex instances) are affected by this vulnerability if they are running a version prior to 2.35.0. An attacker can exploit this vulnerability by making a victim navigate to a malicious website and guiding them through the OIDC flow, stealing the OAuth authorization code in the process. The authorization code then can be exchanged by the attacker for a token, gaining access to applications accepting that token. Version 2.35.0 has introduced a fix for this issue. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Dex es un servicio de identidad que usa OpenID Connect para impulsar la autenticaci\u00f3n de otras aplicaciones. Las instancias de Dex con clientes p\u00fablicos (y por extensi\u00f3n, los clientes que aceptan tokens emitidos por esas instancias de Dex) est\u00e1n afectadas por esta vulnerabilidad si est\u00e1n ejecutando una versi\u00f3n anterior a la 2.35.0. Un atacante puede explotar esta vulnerabilidad al hacer que una v\u00edctima navegue a un sitio web malicioso y gui\u00e1ndola mediante el flujo OIDC, robando el c\u00f3digo de autorizaci\u00f3n OAuth en el proceso. El c\u00f3digo de autorizaci\u00f3n puede entonces ser intercambiado por el atacante por un token, consiguiendo acceso a las aplicaciones que aceptan ese token. La versi\u00f3n 2.35.0 ha introducido una correcci\u00f3n para este problema. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dex:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.35.0", "matchCriteriaId": "1B52FCE8-6C6A-4223-97CC-96FA565388BD"}]}]}], "references": [{"url": "https://github.com/dexidp/dex/commit/49471b14c8080ddb034d4855841123d378b7a634", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dexidp/dex/security/advisories/GHSA-vh7g-p26c-j2cw", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dexidp/dex/commit/49471b14c8080ddb034d4855841123d378b7a634"}}