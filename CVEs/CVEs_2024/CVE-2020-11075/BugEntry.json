{"buggy_code": ["import json\nimport os\nimport re\nimport tempfile\n\nimport anchore_engine.configuration.localconfig\nfrom anchore_engine.utils import run_command, run_command_list, manifest_to_digest, AnchoreException\nfrom anchore_engine.subsys import logger\nfrom anchore_engine.common.errors import AnchoreError\n\ndef manifest_to_digest_shellout(rawmanifest):\n    ret = None\n    tmpmanifest = None\n    try:\n        fd,tmpmanifest = tempfile.mkstemp()\n        os.write(fd, rawmanifest.encode('utf-8'))\n        os.close(fd)\n\n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)\n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        cmd = \"skopeo {} manifest-digest {}\".format(global_timeout_str, tmpmanifest)\n        rc, sout, serr = run_command(cmd)\n        if rc == 0 and re.match(\"^sha256:.*\", str(sout, 'utf-8')):\n            ret = sout.strip()\n        else:\n            logger.warn(\"failed to calculate digest from schema v1 manifest: cmd={} rc={} sout={} serr={}\".format(cmd, rc, sout, serr))\n            raise SkopeoError(cmd=cmd, rc=rc, err=serr, out=sout, msg='Failed to calculate digest from schema v1 manifest', )\n    except Exception as err:\n        raise err\n    finally:\n        if tmpmanifest:\n            os.remove(tmpmanifest)\n\n    return(ret)\n\ndef copy_image_from_docker_archive(source_archive, dest_dir):\n    cmdstr = \"skopeo copy docker-archive:{} oci:{}:image\".format(source_archive, dest_dir)\n    cmd = cmdstr.split()\n    try:\n        rc, sout, serr = run_command_list(cmd)\n        if rc != 0:\n            raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n        else:\n            logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n\n    except Exception as err:\n        logger.error(\"command failed with exception - \" + str(err))\n        raise err\n\ndef download_image(fulltag, copydir, user=None, pw=None, verify=True, manifest=None, parent_manifest=None, use_cache_dir=None, dest_type='oci'):\n    try:\n        proc_env = os.environ.copy()\n        if user and pw:\n            proc_env['SKOPUSER'] = user\n            proc_env['SKOPPASS'] = pw\n            credstr = '--src-creds \\\"${SKOPUSER}\\\":\\\"${SKOPPASS}\\\"'\n        else:\n            credstr = \"\"\n\n        if verify:\n            tlsverifystr = \"--src-tls-verify=true\"\n        else:\n            tlsverifystr = \"--src-tls-verify=false\"\n\n        if use_cache_dir and os.path.exists(use_cache_dir):\n            cachestr = \"--dest-shared-blob-dir \" + use_cache_dir\n        else:\n            cachestr = \"\"\n\n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)\n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        os_overrides = [\"\"]\n        if manifest:\n            manifest_data = json.loads(manifest)\n\n            # skopeo doesn't support references in manifests for copy/download operations, with oci dest type - if found, override with dir dest_type\n            for l in manifest_data.get('layers', []):\n                if 'foreign.diff' in l.get('mediaType', \"\"):\n                    dest_type = 'dir'\n\n            if parent_manifest:\n                parent_manifest_data = json.loads(parent_manifest)\n            else:\n                parent_manifest_data = {}\n\n            if parent_manifest_data:\n                for mlist in parent_manifest_data.get('manifests', []):\n                    imageos = mlist.get('platform', {}).get('os', \"\")\n                    if imageos not in [\"\", 'linux'] and imageos not in os_overrides:\n                        dest_type = 'dir'\n                        os_overrides.insert(0, imageos)\n\n        for os_override in os_overrides:\n            success = False\n            if os_override not in [\"\", 'linux']:\n                dest_type = 'dir'\n                os_override_str = \"--override-os {}\".format(os_override)\n            else:\n                os_override_str = \"\"\n                \n            if dest_type == 'oci':\n                if manifest:\n                    with open(os.path.join(copydir, \"manifest.json\"), 'w') as OFH:\n                        OFH.write(manifest)\n\n                if parent_manifest:\n                    with open(os.path.join(copydir, \"parent_manifest.json\"), 'w') as OFH:\n                        OFH.write(parent_manifest)\n                        \n                cmd = [\"/bin/sh\", \"-c\", \"skopeo {} {} copy {} {} {} docker://{} oci:{}:image\".format(os_override_str, global_timeout_str, tlsverifystr, credstr, cachestr, fulltag, copydir)]\n            else:\n                cmd = [\"/bin/sh\", \"-c\", \"skopeo {} {} copy {} {} docker://{} dir:{}\".format(os_override_str, global_timeout_str, tlsverifystr, credstr, fulltag, copydir)]\n\n            cmdstr = ' '.join(cmd)\n            try:\n                rc, sout, serr = run_command_list(cmd, env=proc_env)\n                if rc != 0:\n                    skopeo_error = SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n                    if skopeo_error.error_code != AnchoreError.OSARCH_MISMATCH.name:\n                        raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)                    \n                else:\n                    logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n                    success = True                    \n\n            except Exception as err:\n                logger.error(\"command failed with exception - \" + str(err))\n                raise err\n\n            if success:\n                break\n        if not success:\n            logger.error(\"could not download image\")\n            raise Exception(\"could not download image\")\n    except Exception as err:\n        raise err\n\n    return(True)\n\ndef get_repo_tags_skopeo(url, registry, repo, user=None, pw=None, verify=None, lookuptag=None):\n    try:\n        proc_env = os.environ.copy()\n        if user and pw:\n            proc_env['SKOPUSER'] = user\n            proc_env['SKOPPASS'] = pw\n            credstr = '--creds \\\"${SKOPUSER}\\\":\\\"${SKOPPASS}\\\"'\n        else:\n            credstr = \"\"\n\n        if verify:\n            tlsverifystr = \"--tls-verify=true\"\n        else:\n            tlsverifystr = \"--tls-verify=false\"\n            \n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)\n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        pullstring = registry + \"/\" + repo\n        if lookuptag:\n            pullstring = pullstring + \":\" + lookuptag\n\n        repotags = []\n\n        cmd = [\"/bin/sh\", \"-c\", \"skopeo {} inspect {} {} docker://{}\".format(global_timeout_str, tlsverifystr, credstr, pullstring)]\n        cmdstr = ' '.join(cmd)\n        try:\n            rc, sout, serr = run_command_list(cmd, env=proc_env)\n            sout = str(sout, 'utf-8') if sout else None\n            if rc != 0:\n                raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n            else:\n                logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n        except Exception as err:\n            logger.error(\"command failed with exception - \" + str(err))\n            raise err\n\n        data = json.loads(sout)\n        repotags = data.get('RepoTags', [])\n    except Exception as err:\n        raise err\n\n    if not repotags:\n        raise Exception(\"no tags found for input repo from skopeo\")\n\n    return(repotags)\n\ndef get_image_manifest_skopeo_raw(pullstring, user=None, pw=None, verify=True):\n    ret = None\n    try:\n        proc_env = os.environ.copy()\n        if user and pw:\n            proc_env['SKOPUSER'] = user\n            proc_env['SKOPPASS'] = pw\n            credstr = '--creds \\\"${SKOPUSER}\\\":\\\"${SKOPPASS}\\\"'\n        else:\n            credstr = \"\"\n\n        if verify:\n            tlsverifystr = \"--tls-verify=true\"\n        else:\n            tlsverifystr = \"--tls-verify=false\"\n\n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)            \n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        os_override_strs = [\"\", \"--override-os windows\"]\n        try:\n            success = False\n            for os_override_str in os_override_strs:\n                cmd = [\"/bin/sh\", \"-c\", \"skopeo {} {} inspect --raw {} {} docker://{}\".format(global_timeout_str, os_override_str, tlsverifystr, credstr, pullstring)]\n                cmdstr = ' '.join(cmd)\n                try:\n                    rc, sout, serr = run_command_list(cmd, env=proc_env)\n                    if rc != 0:\n                        skopeo_error = SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n                        if skopeo_error.error_code != AnchoreError.OSARCH_MISMATCH.name:\n                            raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n                    else:\n                        logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n                        success = True\n                except Exception as err:\n                    logger.error(\"command failed with exception - \" + str(err))\n                    raise err\n\n                if success:\n                    sout = str(sout, 'utf-8') if sout else None    \n                    ret = sout\n                    break\n\n            if not success:\n                logger.error(\"could not retrieve manifest\")\n                raise Exception(\"could not retrieve manifest\")\n            \n        except Exception as err:\n            raise err\n    except Exception as err:\n        raise err\n\n    return(ret)\n\ndef get_image_manifest_skopeo(url, registry, repo, intag=None, indigest=None, topdigest=None, user=None, pw=None, verify=True, topmanifest=None):\n    manifest = {}\n    digest = None\n    testDigest = None\n\n    if indigest:\n        pullstring = registry + \"/\" + repo + \"@\" + indigest\n    elif intag:\n        pullstring = registry + \"/\" + repo + \":\" + intag\n    else:\n        raise Exception(\"invalid input - must supply either an intag or indigest\")\n\n    try:\n        try:\n            rawmanifest = get_image_manifest_skopeo_raw(pullstring, user=user, pw=pw, verify=verify)\n            digest = manifest_to_digest(rawmanifest)\n            manifest = json.loads(rawmanifest)\n            if topmanifest is None:\n                topmanifest = json.loads(rawmanifest)\n            if not topdigest:\n                topdigest = digest\n\n            if manifest.get('schemaVersion') == 2 and manifest.get('mediaType') == 'application/vnd.docker.distribution.manifest.list.v2+json':\n                # Get the arch-specific version for amd64 and linux\n                new_digest = None\n                for entry in manifest.get('manifests'):\n                    platform = entry.get('platform')\n                    if platform and platform.get('architecture') in ['amd64'] and platform.get('os') in ['linux', 'windows']:\n                        new_digest = entry.get('digest')\n                        break\n\n                return get_image_manifest_skopeo(url=url, registry=registry, repo=repo, intag=None, indigest=new_digest, user=user, pw=pw, verify=verify, topdigest=topdigest, topmanifest=topmanifest)\n        except Exception as err:\n            logger.warn(\"CMD failed - exception: \" + str(err))\n            raise err\n\n    except Exception as err:\n        import traceback\n        traceback.print_exc()\n        raise err\n\n    if not manifest or not digest:\n        raise SkopeoError(msg=\"No digest/manifest from skopeo\")\n\n    return(manifest, digest, topdigest, topmanifest)\n\nclass SkopeoError(AnchoreException):\n\n    def __init__(self, cmd=None, rc=None, err=None, out=None, msg='Error encountered in skopeo operation'):\n        from anchore_engine.common.errors import AnchoreError\n\n        self.cmd = ' '.join(cmd) if isinstance(cmd, list) else cmd\n        self.exitcode = rc\n        self.stderr = str(err).replace('\\r', ' ').replace('\\n', ' ').strip() if err else None\n        self.stdout = str(out).replace('\\r', ' ').replace('\\n', ' ').strip() if out else None\n        self.msg = msg\n        try:\n            if \"unauthorized\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_PERMISSION_DENIED.name\n            elif \"manifest unknown\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_IMAGE_NOT_FOUND.name\n            elif \"connection refused\" in self.stderr or \"no route to host\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_NOT_ACCESSIBLE.name\n            elif \"error pinging registry\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_NOT_SUPPORTED.name\n            elif \"no image found in manifest list for architecture amd64, OS linux\" in self.stderr:\n                self.error_code = AnchoreError.OSARCH_MISMATCH.name\n            else:\n                self.error_code = AnchoreError.SKOPEO_UNKNOWN_ERROR.name\n        except:\n            self.error_code = AnchoreError.UNKNOWN.name\n        \n\n    def __repr__(self):\n        return '{}. cmd={}, rc={}, stdout={}, stderr={}, error_code={}'.format(self.msg, self.cmd, self.exitcode, self.stdout, self.stderr, self.error_code)\n\n    def __str__(self):\n        return '{}. cmd={}, rc={}, stdout={}, stderr={}, error_code={}'.format(self.msg, self.cmd, self.exitcode, self.stdout, self.stderr, self.error_code)\n"], "fixing_code": ["import json\nimport os\nimport re\nimport tempfile\n\nimport anchore_engine.configuration.localconfig\nfrom anchore_engine.utils import run_command, run_command_list, manifest_to_digest, AnchoreException\nfrom anchore_engine.subsys import logger\nfrom anchore_engine.common.errors import AnchoreError\n\ndef manifest_to_digest_shellout(rawmanifest):\n    ret = None\n    tmpmanifest = None\n    try:\n        fd,tmpmanifest = tempfile.mkstemp()\n        os.write(fd, rawmanifest.encode('utf-8'))\n        os.close(fd)\n\n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)\n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        cmd = \"skopeo {} manifest-digest {}\".format(global_timeout_str, tmpmanifest)\n        rc, sout, serr = run_command(cmd)\n        if rc == 0 and re.match(\"^sha256:.*\", str(sout, 'utf-8')):\n            ret = sout.strip()\n        else:\n            logger.warn(\"failed to calculate digest from schema v1 manifest: cmd={} rc={} sout={} serr={}\".format(cmd, rc, sout, serr))\n            raise SkopeoError(cmd=cmd, rc=rc, err=serr, out=sout, msg='Failed to calculate digest from schema v1 manifest', )\n    except Exception as err:\n        raise err\n    finally:\n        if tmpmanifest:\n            os.remove(tmpmanifest)\n\n    return(ret)\n\ndef copy_image_from_docker_archive(source_archive, dest_dir):\n    cmdstr = \"skopeo copy docker-archive:{} oci:{}:image\".format(source_archive, dest_dir)\n    cmd = cmdstr.split()\n    try:\n        rc, sout, serr = run_command_list(cmd)\n        if rc != 0:\n            raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n        else:\n            logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n\n    except Exception as err:\n        logger.error(\"command failed with exception - \" + str(err))\n        raise err\n\ndef download_image(fulltag, copydir, user=None, pw=None, verify=True, manifest=None, parent_manifest=None, use_cache_dir=None, dest_type='oci'):\n    try:\n        proc_env = os.environ.copy()\n        if user and pw:\n            proc_env['SKOPUSER'] = user\n            proc_env['SKOPPASS'] = pw\n            credstr = '--src-creds \\\"${SKOPUSER}\\\":\\\"${SKOPPASS}\\\"'\n        else:\n            credstr = \"\"\n\n        if verify:\n            tlsverifystr = \"--src-tls-verify=true\"\n        else:\n            tlsverifystr = \"--src-tls-verify=false\"\n\n        if use_cache_dir and os.path.exists(use_cache_dir):\n            cachestr = \"--dest-shared-blob-dir \" + use_cache_dir\n        else:\n            cachestr = \"\"\n\n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)\n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        os_overrides = [\"\"]\n        if manifest:\n            manifest_data = json.loads(manifest)\n\n            # skopeo doesn't support references in manifests for copy/download operations, with oci dest type - if found, override with dir dest_type\n            for l in manifest_data.get('layers', []):\n                if 'foreign.diff' in l.get('mediaType', \"\"):\n                    dest_type = 'dir'\n\n            if parent_manifest:\n                parent_manifest_data = json.loads(parent_manifest)\n            else:\n                parent_manifest_data = {}\n\n            if parent_manifest_data:\n                for mlist in parent_manifest_data.get('manifests', []):\n                    imageos = mlist.get('platform', {}).get('os', \"\")\n                    if imageos not in [\"\", 'linux']:\n                        # add a windows os override to the list of override attempts, to complete the options that are supported by skopeo\n                        dest_type = 'dir'\n                        os_overrides.insert(0, \"windows\")\n                        break\n\n        for os_override in os_overrides:\n            success = False\n            if os_override not in [\"\", 'linux']:\n                dest_type = 'dir'\n                os_override_str = \"--override-os {}\".format(os_override)\n            else:\n                os_override_str = \"\"\n                \n            if dest_type == 'oci':\n                if manifest:\n                    with open(os.path.join(copydir, \"manifest.json\"), 'w') as OFH:\n                        OFH.write(manifest)\n\n                if parent_manifest:\n                    with open(os.path.join(copydir, \"parent_manifest.json\"), 'w') as OFH:\n                        OFH.write(parent_manifest)\n                        \n                cmd = [\"/bin/sh\", \"-c\", \"skopeo {} {} copy {} {} {} docker://{} oci:{}:image\".format(os_override_str, global_timeout_str, tlsverifystr, credstr, cachestr, fulltag, copydir)]\n            else:\n                cmd = [\"/bin/sh\", \"-c\", \"skopeo {} {} copy {} {} docker://{} dir:{}\".format(os_override_str, global_timeout_str, tlsverifystr, credstr, fulltag, copydir)]\n\n            cmdstr = ' '.join(cmd)\n            try:\n                rc, sout, serr = run_command_list(cmd, env=proc_env)\n                if rc != 0:\n                    skopeo_error = SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n                    if skopeo_error.error_code != AnchoreError.OSARCH_MISMATCH.name:\n                        raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)                    \n                else:\n                    logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n                    success = True                    \n\n            except Exception as err:\n                logger.error(\"command failed with exception - \" + str(err))\n                raise err\n\n            if success:\n                break\n        if not success:\n            logger.error(\"could not download image\")\n            raise Exception(\"could not download image\")\n    except Exception as err:\n        raise err\n\n    return(True)\n\ndef get_repo_tags_skopeo(url, registry, repo, user=None, pw=None, verify=None, lookuptag=None):\n    try:\n        proc_env = os.environ.copy()\n        if user and pw:\n            proc_env['SKOPUSER'] = user\n            proc_env['SKOPPASS'] = pw\n            credstr = '--creds \\\"${SKOPUSER}\\\":\\\"${SKOPPASS}\\\"'\n        else:\n            credstr = \"\"\n\n        if verify:\n            tlsverifystr = \"--tls-verify=true\"\n        else:\n            tlsverifystr = \"--tls-verify=false\"\n            \n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)\n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        pullstring = registry + \"/\" + repo\n        if lookuptag:\n            pullstring = pullstring + \":\" + lookuptag\n\n        repotags = []\n\n        cmd = [\"/bin/sh\", \"-c\", \"skopeo {} inspect {} {} docker://{}\".format(global_timeout_str, tlsverifystr, credstr, pullstring)]\n        cmdstr = ' '.join(cmd)\n        try:\n            rc, sout, serr = run_command_list(cmd, env=proc_env)\n            sout = str(sout, 'utf-8') if sout else None\n            if rc != 0:\n                raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n            else:\n                logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n        except Exception as err:\n            logger.error(\"command failed with exception - \" + str(err))\n            raise err\n\n        data = json.loads(sout)\n        repotags = data.get('RepoTags', [])\n    except Exception as err:\n        raise err\n\n    if not repotags:\n        raise Exception(\"no tags found for input repo from skopeo\")\n\n    return(repotags)\n\ndef get_image_manifest_skopeo_raw(pullstring, user=None, pw=None, verify=True):\n    ret = None\n    try:\n        proc_env = os.environ.copy()\n        if user and pw:\n            proc_env['SKOPUSER'] = user\n            proc_env['SKOPPASS'] = pw\n            credstr = '--creds \\\"${SKOPUSER}\\\":\\\"${SKOPPASS}\\\"'\n        else:\n            credstr = \"\"\n\n        if verify:\n            tlsverifystr = \"--tls-verify=true\"\n        else:\n            tlsverifystr = \"--tls-verify=false\"\n\n        localconfig = anchore_engine.configuration.localconfig.get_config()\n        global_timeout = localconfig.get('skopeo_global_timeout', 0)            \n        try:\n            global_timeout = int(global_timeout)\n            if global_timeout < 0:\n                global_timeout = 0\n        except:\n            global_timeout = 0\n\n        if global_timeout:\n            global_timeout_str = \"--command-timeout {}s\".format(global_timeout)\n        else:\n            global_timeout_str = \"\"\n\n        os_override_strs = [\"\", \"--override-os windows\"]\n        try:\n            success = False\n            for os_override_str in os_override_strs:\n                cmd = [\"/bin/sh\", \"-c\", \"skopeo {} {} inspect --raw {} {} docker://{}\".format(global_timeout_str, os_override_str, tlsverifystr, credstr, pullstring)]\n                cmdstr = ' '.join(cmd)\n                try:\n                    rc, sout, serr = run_command_list(cmd, env=proc_env)\n                    if rc != 0:\n                        skopeo_error = SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n                        if skopeo_error.error_code != AnchoreError.OSARCH_MISMATCH.name:\n                            raise SkopeoError(cmd=cmd, rc=rc, out=sout, err=serr)\n                    else:\n                        logger.debug(\"command succeeded: cmd=\"+str(cmdstr)+\" stdout=\"+str(sout).strip()+\" stderr=\"+str(serr).strip())\n                        success = True\n                except Exception as err:\n                    logger.error(\"command failed with exception - \" + str(err))\n                    raise err\n\n                if success:\n                    sout = str(sout, 'utf-8') if sout else None    \n                    ret = sout\n                    break\n\n            if not success:\n                logger.error(\"could not retrieve manifest\")\n                raise Exception(\"could not retrieve manifest\")\n            \n        except Exception as err:\n            raise err\n    except Exception as err:\n        raise err\n\n    return(ret)\n\ndef get_image_manifest_skopeo(url, registry, repo, intag=None, indigest=None, topdigest=None, user=None, pw=None, verify=True, topmanifest=None):\n    manifest = {}\n    digest = None\n    testDigest = None\n\n    if indigest:\n        pullstring = registry + \"/\" + repo + \"@\" + indigest\n    elif intag:\n        pullstring = registry + \"/\" + repo + \":\" + intag\n    else:\n        raise Exception(\"invalid input - must supply either an intag or indigest\")\n\n    try:\n        try:\n            rawmanifest = get_image_manifest_skopeo_raw(pullstring, user=user, pw=pw, verify=verify)\n            digest = manifest_to_digest(rawmanifest)\n            manifest = json.loads(rawmanifest)\n            if topmanifest is None:\n                topmanifest = json.loads(rawmanifest)\n            if not topdigest:\n                topdigest = digest\n\n            if manifest.get('schemaVersion') == 2 and manifest.get('mediaType') == 'application/vnd.docker.distribution.manifest.list.v2+json':\n                # Get the arch-specific version for amd64 and linux\n                new_digest = None\n                for entry in manifest.get('manifests'):\n                    platform = entry.get('platform')\n                    if platform and platform.get('architecture') in ['amd64'] and platform.get('os') in ['linux', 'windows']:\n                        new_digest = entry.get('digest')\n                        break\n\n                return get_image_manifest_skopeo(url=url, registry=registry, repo=repo, intag=None, indigest=new_digest, user=user, pw=pw, verify=verify, topdigest=topdigest, topmanifest=topmanifest)\n        except Exception as err:\n            logger.warn(\"CMD failed - exception: \" + str(err))\n            raise err\n\n    except Exception as err:\n        import traceback\n        traceback.print_exc()\n        raise err\n\n    if not manifest or not digest:\n        raise SkopeoError(msg=\"No digest/manifest from skopeo\")\n\n    return(manifest, digest, topdigest, topmanifest)\n\nclass SkopeoError(AnchoreException):\n\n    def __init__(self, cmd=None, rc=None, err=None, out=None, msg='Error encountered in skopeo operation'):\n        from anchore_engine.common.errors import AnchoreError\n\n        self.cmd = ' '.join(cmd) if isinstance(cmd, list) else cmd\n        self.exitcode = rc\n        self.stderr = str(err).replace('\\r', ' ').replace('\\n', ' ').strip() if err else None\n        self.stdout = str(out).replace('\\r', ' ').replace('\\n', ' ').strip() if out else None\n        self.msg = msg\n        try:\n            if \"unauthorized\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_PERMISSION_DENIED.name\n            elif \"manifest unknown\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_IMAGE_NOT_FOUND.name\n            elif \"connection refused\" in self.stderr or \"no route to host\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_NOT_ACCESSIBLE.name\n            elif \"error pinging registry\" in self.stderr:\n                self.error_code = AnchoreError.REGISTRY_NOT_SUPPORTED.name\n            elif \"no image found in manifest list for architecture amd64, OS linux\" in self.stderr:\n                self.error_code = AnchoreError.OSARCH_MISMATCH.name\n            else:\n                self.error_code = AnchoreError.SKOPEO_UNKNOWN_ERROR.name\n        except:\n            self.error_code = AnchoreError.UNKNOWN.name\n        \n\n    def __repr__(self):\n        return '{}. cmd={}, rc={}, stdout={}, stderr={}, error_code={}'.format(self.msg, self.cmd, self.exitcode, self.stdout, self.stderr, self.error_code)\n\n    def __str__(self):\n        return '{}. cmd={}, rc={}, stdout={}, stderr={}, error_code={}'.format(self.msg, self.cmd, self.exitcode, self.stdout, self.stderr, self.error_code)\n"], "filenames": ["anchore_engine/clients/skopeo_wrapper.py"], "buggy_code_start_loc": [113], "buggy_code_end_loc": [116], "fixing_code_start_loc": [113], "fixing_code_end_loc": [118], "type": "NVD-CWE-Other", "message": "In Anchore Engine version 0.7.0, a specially crafted container image manifest, fetched from a registry, can be used to trigger a shell escape flaw in the anchore engine analyzer service during an image analysis process. The image analysis operation can only be executed by an authenticated user via a valid API request to anchore engine, or if an already added image that anchore is monitoring has its manifest altered to exploit the same flaw. A successful attack can be used to execute commands that run in the analyzer environment, with the same permissions as the user that anchore engine is run as - including access to the credentials that Engine uses to access its own database which have read-write ability, as well as access to the running engien analyzer service environment. By default Anchore Engine is released and deployed as a container where the user is non-root, but if users run Engine directly or explicitly set the user to 'root' then that level of access may be gained in the execution environment where Engine runs. This issue is fixed in version 0.7.1.", "other": {"cve": {"id": "CVE-2020-11075", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-27T22:15:11.000", "lastModified": "2020-06-03T15:58:21.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Anchore Engine version 0.7.0, a specially crafted container image manifest, fetched from a registry, can be used to trigger a shell escape flaw in the anchore engine analyzer service during an image analysis process. The image analysis operation can only be executed by an authenticated user via a valid API request to anchore engine, or if an already added image that anchore is monitoring has its manifest altered to exploit the same flaw. A successful attack can be used to execute commands that run in the analyzer environment, with the same permissions as the user that anchore engine is run as - including access to the credentials that Engine uses to access its own database which have read-write ability, as well as access to the running engien analyzer service environment. By default Anchore Engine is released and deployed as a container where the user is non-root, but if users run Engine directly or explicitly set the user to 'root' then that level of access may be gained in the execution environment where Engine runs. This issue is fixed in version 0.7.1."}, {"lang": "es", "value": "En Anchore Engine versi\u00f3n 0.7.0, un manifiesto de imagen de contenedor especialmente dise\u00f1ado, extra\u00eddo de un registro, puede ser utilizado para desencadenar un fallo de escape del shell en el servicio del analizador de anchore engine durante un proceso de an\u00e1lisis de imagen. La operaci\u00f3n de an\u00e1lisis de imagen solo puede ser ejecutada por un usuario autenticado por medio de una petici\u00f3n de API v\u00e1lida al anchore engine, o si una imagen ya agregada que anchore est\u00e1 monitoreando tiene su manifiesto alterado para explotar el mismo fallo. Un ataque con \u00e9xito puede ser utilizado para ejecutar comandos que son realizados en el entorno del analizador, con los mismos permisos que el usuario que ejecuta anchore engine, incluido el acceso a las credenciales que usa Engine para acceder a su propia base de datos que tiene capacidad de lectura y escritura, as\u00ed como tambi\u00e9n acceso al entorno de servicio del analizador de engine en ejecuci\u00f3n. Por defecto, Anchore Engine es iniciado y se despliega como un contenedor donde el usuario no es root, pero si los usuarios ejecutan Engine directa o expl\u00edcitamente configuran al usuario como \"root\", entonces ese nivel de acceso puede ser alcanzado en el entorno de ejecuci\u00f3n donde se ejecuta Engine. Este problema es corregido en la versi\u00f3n 0.7.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-114"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:anchore:engine:0.7.0:-:*:*:*:*:*:*", "matchCriteriaId": "CCBB339C-2583-4E05-9F59-70B8C6B677D3"}]}]}], "references": [{"url": "https://github.com/anchore/anchore-engine/commit/e41786901f097fd32104447a45864073105d37db", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/anchore/anchore-engine/issues/430", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/anchore/anchore-engine/pull/431", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/anchore/anchore-engine/security/advisories/GHSA-w4rm-w22x-h7m5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/anchore/anchore-engine/commit/e41786901f097fd32104447a45864073105d37db"}}