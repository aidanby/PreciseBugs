{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   DDDD   BBBB                               %\n%                            P   P  D   D  B   B                              %\n%                            PPPP   D   D  BBBB                               %\n%                            P      D   D  B   B                              %\n%                            P      DDDD   BBBB                               %\n%                                                                             %\n%                                                                             %\n%               Read/Write Palm Database ImageViewer Image Format             %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%   20071202 TS * rewrote RLE decoder - old version could cause buffer overflows\n%               * failure of RLE decoding now thows error RLEDecoderError\n%               * fixed bug in RLE decoding - now all rows are decoded, not just\n%     the first one\n%   * fixed bug in reader - record offsets now handled correctly\n%   * fixed bug in reader - only bits 0..2 indicate compression type\n%               * in writer: now using image color count instead of depth\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/constitute.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _PDBInfo\n{\n  char\n    name[32];\n\n  short int\n    attributes,\n    version;\n\n  size_t\n    create_time,\n    modify_time,\n    archive_time,\n    modify_number,\n    application_info,\n    sort_info;\n\n  char\n    type[4],  /* database type identifier \"vIMG\" */\n    id[4];    /* database creator identifier \"View\" */\n\n  size_t\n    seed,\n    next_record;\n\n  short int\n    number_records;\n} PDBInfo;\n\ntypedef struct _PDBImage\n{\n  char\n    name[32],\n    version;\n\n  size_t\n    reserved_1,\n    note;\n\n  short int\n    x_last,\n    y_last;\n\n  size_t\n    reserved_2;\n\n  short int\n    width,\n    height;\n\n  unsigned char\n    type;\n\n  unsigned short\n    x_anchor,\n    y_anchor;\n\n} PDBImage;\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePDBImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into runlength-encoded\n%  pixel packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,unsigned char *pixels,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the decoding process.\n%\n%    o length:  Number of bytes to read into buffer 'pixels'.\n%\n*/\nstatic MagickBooleanType DecodeImage(Image *image, unsigned char *pixels,\n  const size_t length)\n{\n#define RLE_MODE_NONE -1\n#define RLE_MODE_COPY  0\n#define RLE_MODE_RUN   1\n\n  int           data = 0, count = 0;\n  unsigned char *p;\n  int           mode = RLE_MODE_NONE;\n\n  for (p = pixels; p < pixels + length; p++) {\n    if (0 == count) {\n      data = ReadBlobByte( image );\n      if (-1 == data) return MagickFalse;\n      if (data > 128) {\n        mode  = RLE_MODE_RUN;\n        count = data - 128 + 1;\n        data  = ReadBlobByte( image );\n        if (-1 == data) return MagickFalse;\n      } else {\n        mode  = RLE_MODE_COPY;\n        count = data + 1;\n      }\n    }\n\n    if (RLE_MODE_COPY == mode) {\n      data = ReadBlobByte( image );\n      if (-1 == data) return MagickFalse;\n    }\n    *p = (unsigned char)data;\n    --count;\n  }\n  return MagickTrue;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P D B                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPDB() returns MagickTrue if the image format type, identified by the\n%  magick string, is PDB.\n%\n%  The format of the ReadPDBImage method is:\n%\n%      MagickBooleanType IsPDB(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPDB(const unsigned char *magick,const size_t length)\n{\n  if (length < 68)\n    return(MagickFalse);\n  if (memcmp(magick+60,\"vIMGView\",8) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P D B I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPDBImage() reads an Pilot image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPDBImage method is:\n%\n%      Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n  attributes=(unsigned char) ((int) ReadBlobByte(image));\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n      attributes=(unsigned char) ((int) ReadBlobByte(image));\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) ReadBlobByte(image);\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07)\n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image, pixels, packets * image -> rows))\n        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\n         \"UnrecognizedImageCompressionType\" );\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));\n          SetPixelIndex(indexes+x+1,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));\n          SetPixelIndex(indexes+x+2,index);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));\n          SetPixelIndex(indexes+x+3,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MaxTextExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MaxTextExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MaxTextExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P D B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPDBImage() adds properties for the PDB image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPDBImage method is:\n%\n%      size_t RegisterPDBImage(void)\n%\n*/\nModuleExport size_t RegisterPDBImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"PDB\");\n  entry->decoder=(DecodeImageHandler *) ReadPDBImage;\n  entry->encoder=(EncodeImageHandler *) WritePDBImage;\n  entry->magick=(IsImageFormatHandler *) IsPDB;\n  entry->description=ConstantString(\"Palm Database ImageViewer Format\");\n  entry->module=ConstantString(\"PDB\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P D B I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPDBImage() removes format registrations made by the\n%  PDB module from the list of supported formats.\n%\n%  The format of the UnregisterPDBImage method is:\n%\n%      UnregisterPDBImage(void)\n%\n*/\nModuleExport void UnregisterPDBImage(void)\n{\n  (void) UnregisterMagickInfo(\"PDB\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P D B I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePDBImage() writes an image\n%\n%  The format of the WritePDBImage method is:\n%\n%      MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%\n*/\n\nstatic unsigned char *EncodeRLE(unsigned char *destination,\n  unsigned char *source,size_t literal,size_t repeat)\n{\n  if (literal > 0)\n    *destination++=(unsigned char) (literal-1);\n  (void) CopyMagickMemory(destination,source,literal);\n  destination+=literal;\n  if (repeat > 0)\n    {\n      *destination++=(unsigned char) (0x80 | (repeat-1));\n      *destination++=source[literal];\n    }\n  return(destination);\n}\n\nstatic MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n  (void) CopyMagickMemory(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  if (runlength == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  buffer=(unsigned char *) AcquireQuantumMemory(256,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  packet_size=(size_t) (image->depth > 8 ? 2: 1);\n  scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n  literal=0;\n  repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   DDDD   BBBB                               %\n%                            P   P  D   D  B   B                              %\n%                            PPPP   D   D  BBBB                               %\n%                            P      D   D  B   B                              %\n%                            P      DDDD   BBBB                               %\n%                                                                             %\n%                                                                             %\n%               Read/Write Palm Database ImageViewer Image Format             %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%   20071202 TS * rewrote RLE decoder - old version could cause buffer overflows\n%               * failure of RLE decoding now thows error RLEDecoderError\n%               * fixed bug in RLE decoding - now all rows are decoded, not just\n%     the first one\n%   * fixed bug in reader - record offsets now handled correctly\n%   * fixed bug in reader - only bits 0..2 indicate compression type\n%               * in writer: now using image color count instead of depth\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/constitute.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _PDBInfo\n{\n  char\n    name[32];\n\n  short int\n    attributes,\n    version;\n\n  size_t\n    create_time,\n    modify_time,\n    archive_time,\n    modify_number,\n    application_info,\n    sort_info;\n\n  char\n    type[4],  /* database type identifier \"vIMG\" */\n    id[4];    /* database creator identifier \"View\" */\n\n  size_t\n    seed,\n    next_record;\n\n  short int\n    number_records;\n} PDBInfo;\n\ntypedef struct _PDBImage\n{\n  char\n    name[32],\n    version;\n\n  size_t\n    reserved_1,\n    note;\n\n  short int\n    x_last,\n    y_last;\n\n  size_t\n    reserved_2;\n\n  short int\n    width,\n    height;\n\n  unsigned char\n    type;\n\n  unsigned short\n    x_anchor,\n    y_anchor;\n\n} PDBImage;\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePDBImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into runlength-encoded\n%  pixel packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,unsigned char *pixels,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the decoding process.\n%\n%    o length:  Number of bytes to read into buffer 'pixels'.\n%\n*/\nstatic MagickBooleanType DecodeImage(Image *image, unsigned char *pixels,\n  const size_t length)\n{\n#define RLE_MODE_NONE -1\n#define RLE_MODE_COPY  0\n#define RLE_MODE_RUN   1\n\n  int           data = 0, count = 0;\n  unsigned char *p;\n  int           mode = RLE_MODE_NONE;\n\n  for (p = pixels; p < pixels + length; p++) {\n    if (0 == count) {\n      data = ReadBlobByte( image );\n      if (-1 == data) return MagickFalse;\n      if (data > 128) {\n        mode  = RLE_MODE_RUN;\n        count = data - 128 + 1;\n        data  = ReadBlobByte( image );\n        if (-1 == data) return MagickFalse;\n      } else {\n        mode  = RLE_MODE_COPY;\n        count = data + 1;\n      }\n    }\n\n    if (RLE_MODE_COPY == mode) {\n      data = ReadBlobByte( image );\n      if (-1 == data) return MagickFalse;\n    }\n    *p = (unsigned char)data;\n    --count;\n  }\n  return MagickTrue;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P D B                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPDB() returns MagickTrue if the image format type, identified by the\n%  magick string, is PDB.\n%\n%  The format of the ReadPDBImage method is:\n%\n%      MagickBooleanType IsPDB(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPDB(const unsigned char *magick,const size_t length)\n{\n  if (length < 68)\n    return(MagickFalse);\n  if (memcmp(magick+60,\"vIMGView\",8) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P D B I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPDBImage() reads an Pilot image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPDBImage method is:\n%\n%      Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n  attributes=(unsigned char) ((int) ReadBlobByte(image));\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n      attributes=(unsigned char) ((int) ReadBlobByte(image));\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) ReadBlobByte(image);\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07)\n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image, pixels, packets * image -> rows))\n        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\n         \"UnrecognizedImageCompressionType\" );\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));\n          SetPixelIndex(indexes+x+1,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));\n          SetPixelIndex(indexes+x+2,index);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));\n          SetPixelIndex(indexes+x+3,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MaxTextExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MaxTextExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MaxTextExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P D B I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPDBImage() adds properties for the PDB image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPDBImage method is:\n%\n%      size_t RegisterPDBImage(void)\n%\n*/\nModuleExport size_t RegisterPDBImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"PDB\");\n  entry->decoder=(DecodeImageHandler *) ReadPDBImage;\n  entry->encoder=(EncodeImageHandler *) WritePDBImage;\n  entry->magick=(IsImageFormatHandler *) IsPDB;\n  entry->description=ConstantString(\"Palm Database ImageViewer Format\");\n  entry->module=ConstantString(\"PDB\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P D B I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPDBImage() removes format registrations made by the\n%  PDB module from the list of supported formats.\n%\n%  The format of the UnregisterPDBImage method is:\n%\n%      UnregisterPDBImage(void)\n%\n*/\nModuleExport void UnregisterPDBImage(void)\n{\n  (void) UnregisterMagickInfo(\"PDB\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P D B I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePDBImage() writes an image\n%\n%  The format of the WritePDBImage method is:\n%\n%      MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%\n*/\n\nstatic unsigned char *EncodeRLE(unsigned char *destination,\n  unsigned char *source,size_t literal,size_t repeat)\n{\n  if (literal > 0)\n    *destination++=(unsigned char) (literal-1);\n  (void) CopyMagickMemory(destination,source,literal);\n  destination+=literal;\n  if (repeat > 0)\n    {\n      *destination++=(unsigned char) (0x80 | (repeat-1));\n      *destination++=source[literal];\n    }\n  return(destination);\n}\n\nstatic MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n  (void) CopyMagickMemory(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  if (runlength == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  buffer=(unsigned char *) AcquireQuantumMemory(257,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  packet_size=(size_t) (image->depth > 8 ? 2: 1);\n  scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n  literal=0;\n  repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/pdb.c"], "buggy_code_start_loc": [428], "buggy_code_end_loc": [834], "fixing_code_start_loc": [428], "fixing_code_end_loc": [834], "type": "CWE-125", "message": "MagickCore/memory.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted PDB file.", "other": {"cve": {"id": "CVE-2016-7537", "sourceIdentifier": "security@debian.org", "published": "2017-04-19T14:59:00.553", "lastModified": "2020-11-16T19:34:09.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MagickCore/memory.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted PDB file."}, {"lang": "es", "value": "MagickCore/memory.c en ImageMagick permite a atacantes remotos provocar una denegaci\u00f3n de servicio (acceso fuera de l\u00edmites) a trav\u00e9s de un archivo PDB manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:-:*:*:*:*:*:*:*", "matchCriteriaId": "6E6BE7A5-6FF7-4916-B671-9EE11CA54F65"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93131", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1553366", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378773", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/424d40ebfcde48bb872eba75179d3d73704fdf1f", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/143", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/424d40ebfcde48bb872eba75179d3d73704fdf1f"}}