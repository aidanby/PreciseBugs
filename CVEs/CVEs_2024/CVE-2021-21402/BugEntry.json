{"buggy_code": ["using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Jellyfin.Api.Attributes;\nusing Jellyfin.Api.Constants;\nusing Jellyfin.Api.Helpers;\nusing MediaBrowser.Common.Configuration;\nusing MediaBrowser.Common.Extensions;\nusing MediaBrowser.Controller.Configuration;\nusing MediaBrowser.Controller.MediaEncoding;\nusing MediaBrowser.Model.IO;\nusing MediaBrowser.Model.Net;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace Jellyfin.Api.Controllers\n{\n    /// <summary>\n    /// The hls segment controller.\n    /// </summary>\n    [Route(\"\")]\n    public class HlsSegmentController : BaseJellyfinApiController\n    {\n        private readonly IFileSystem _fileSystem;\n        private readonly IServerConfigurationManager _serverConfigurationManager;\n        private readonly TranscodingJobHelper _transcodingJobHelper;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"HlsSegmentController\"/> class.\n        /// </summary>\n        /// <param name=\"fileSystem\">Instance of the <see cref=\"IFileSystem\"/> interface.</param>\n        /// <param name=\"serverConfigurationManager\">Instance of the <see cref=\"IServerConfigurationManager\"/> interface.</param>\n        /// <param name=\"transcodingJobHelper\">Initialized instance of the <see cref=\"TranscodingJobHelper\"/>.</param>\n        public HlsSegmentController(\n            IFileSystem fileSystem,\n            IServerConfigurationManager serverConfigurationManager,\n            TranscodingJobHelper transcodingJobHelper)\n        {\n            _fileSystem = fileSystem;\n            _serverConfigurationManager = serverConfigurationManager;\n            _transcodingJobHelper = transcodingJobHelper;\n        }\n\n        /// <summary>\n        /// Gets the specified audio segment for an audio item.\n        /// </summary>\n        /// <param name=\"itemId\">The item id.</param>\n        /// <param name=\"segmentId\">The segment id.</param>\n        /// <response code=\"200\">Hls audio segment returned.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the audio stream.</returns>\n        // Can't require authentication just yet due to seeing some requests come from Chrome without full query string\n        // [Authenticated]\n        [HttpGet(\"Audio/{itemId}/hls/{segmentId}/stream.mp3\", Name = \"GetHlsAudioSegmentLegacyMp3\")]\n        [HttpGet(\"Audio/{itemId}/hls/{segmentId}/stream.aac\", Name = \"GetHlsAudioSegmentLegacyAac\")]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesAudioFile]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1801:ReviewUnusedParameters\", MessageId = \"itemId\", Justification = \"Required for ServiceStack\")]\n        public ActionResult GetHlsAudioSegmentLegacy([FromRoute, Required] string itemId, [FromRoute, Required] string segmentId)\n        {\n            // TODO: Deprecate with new iOS app\n            var file = segmentId + Path.GetExtension(Request.Path);\n            file = Path.Combine(_serverConfigurationManager.GetTranscodePath(), file);\n\n            return FileStreamResponseHelpers.GetStaticFileResult(file, MimeTypes.GetMimeType(file)!, false, HttpContext);\n        }\n\n        /// <summary>\n        /// Gets a hls video playlist.\n        /// </summary>\n        /// <param name=\"itemId\">The video id.</param>\n        /// <param name=\"playlistId\">The playlist id.</param>\n        /// <response code=\"200\">Hls video playlist returned.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the playlist.</returns>\n        [HttpGet(\"Videos/{itemId}/hls/{playlistId}/stream.m3u8\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesPlaylistFile]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1801:ReviewUnusedParameters\", MessageId = \"itemId\", Justification = \"Required for ServiceStack\")]\n        public ActionResult GetHlsPlaylistLegacy([FromRoute, Required] string itemId, [FromRoute, Required] string playlistId)\n        {\n            var file = playlistId + Path.GetExtension(Request.Path);\n            file = Path.Combine(_serverConfigurationManager.GetTranscodePath(), file);\n\n            return GetFileResult(file, file);\n        }\n\n        /// <summary>\n        /// Stops an active encoding.\n        /// </summary>\n        /// <param name=\"deviceId\">The device id of the client requesting. Used to stop encoding processes when needed.</param>\n        /// <param name=\"playSessionId\">The play session id.</param>\n        /// <response code=\"204\">Encoding stopped successfully.</response>\n        /// <returns>A <see cref=\"NoContentResult\"/> indicating success.</returns>\n        [HttpDelete(\"Videos/ActiveEncodings\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status204NoContent)]\n        public ActionResult StopEncodingProcess(\n            [FromQuery, Required] string deviceId,\n            [FromQuery, Required] string playSessionId)\n        {\n            _transcodingJobHelper.KillTranscodingJobs(deviceId, playSessionId, path => true);\n            return NoContent();\n        }\n\n        /// <summary>\n        /// Gets a hls video segment.\n        /// </summary>\n        /// <param name=\"itemId\">The item id.</param>\n        /// <param name=\"playlistId\">The playlist id.</param>\n        /// <param name=\"segmentId\">The segment id.</param>\n        /// <param name=\"segmentContainer\">The segment container.</param>\n        /// <response code=\"200\">Hls video segment returned.</response>\n        /// <response code=\"404\">Hls segment not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the video segment.</returns>\n        // Can't require authentication just yet due to seeing some requests come from Chrome without full query string\n        // [Authenticated]\n        [HttpGet(\"Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}\")]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesVideoFile]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1801:ReviewUnusedParameters\", MessageId = \"itemId\", Justification = \"Required for ServiceStack\")]\n        public ActionResult GetHlsVideoSegmentLegacy(\n            [FromRoute, Required] string itemId,\n            [FromRoute, Required] string playlistId,\n            [FromRoute, Required] string segmentId,\n            [FromRoute, Required] string segmentContainer)\n        {\n            var file = segmentId + Path.GetExtension(Request.Path);\n            var transcodeFolderPath = _serverConfigurationManager.GetTranscodePath();\n\n            file = Path.Combine(transcodeFolderPath, file);\n\n            var normalizedPlaylistId = playlistId;\n\n            var filePaths = _fileSystem.GetFilePaths(transcodeFolderPath);\n            // Add . to start of segment container for future use.\n            segmentContainer = segmentContainer.Insert(0, \".\");\n            string? playlistPath = null;\n            foreach (var path in filePaths)\n            {\n                var pathExtension = Path.GetExtension(path);\n                if ((string.Equals(pathExtension, segmentContainer, StringComparison.OrdinalIgnoreCase)\n                     || string.Equals(pathExtension, \".m3u8\", StringComparison.OrdinalIgnoreCase))\n                    && path.IndexOf(normalizedPlaylistId, StringComparison.OrdinalIgnoreCase) != -1)\n                {\n                    playlistPath = path;\n                    break;\n                }\n            }\n\n            return playlistPath == null\n                ? NotFound(\"Hls segment not found.\")\n                : GetFileResult(file, playlistPath);\n        }\n\n        private ActionResult GetFileResult(string path, string playlistPath)\n        {\n            var transcodingJob = _transcodingJobHelper.OnTranscodeBeginRequest(playlistPath, TranscodingJobType.Hls);\n\n            Response.OnCompleted(() =>\n            {\n                if (transcodingJob != null)\n                {\n                    _transcodingJobHelper.OnTranscodeEndRequest(transcodingJob);\n                }\n\n                return Task.CompletedTask;\n            });\n\n            return FileStreamResponseHelpers.GetStaticFileResult(path, MimeTypes.GetMimeType(path)!, false, HttpContext);\n        }\n    }\n}\n", "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Mime;\nusing Jellyfin.Api.Attributes;\nusing Jellyfin.Api.Constants;\nusing MediaBrowser.Controller;\nusing MediaBrowser.Controller.Configuration;\nusing MediaBrowser.Controller.Entities;\nusing MediaBrowser.Model.Dto;\nusing MediaBrowser.Model.IO;\nusing MediaBrowser.Model.Net;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace Jellyfin.Api.Controllers\n{\n    /// <summary>\n    ///     Images By Name Controller.\n    /// </summary>\n    [Route(\"Images\")]\n    public class ImageByNameController : BaseJellyfinApiController\n    {\n        private readonly IServerApplicationPaths _applicationPaths;\n        private readonly IFileSystem _fileSystem;\n\n        /// <summary>\n        ///     Initializes a new instance of the <see cref=\"ImageByNameController\" /> class.\n        /// </summary>\n        /// <param name=\"serverConfigurationManager\">Instance of the <see cref=\"IServerConfigurationManager\" /> interface.</param>\n        /// <param name=\"fileSystem\">Instance of the <see cref=\"IFileSystem\" /> interface.</param>\n        public ImageByNameController(\n            IServerConfigurationManager serverConfigurationManager,\n            IFileSystem fileSystem)\n        {\n            _applicationPaths = serverConfigurationManager.ApplicationPaths;\n            _fileSystem = fileSystem;\n        }\n\n        /// <summary>\n        ///     Get all general images.\n        /// </summary>\n        /// <response code=\"200\">Retrieved list of images.</response>\n        /// <returns>An <see cref=\"OkResult\"/> containing the list of images.</returns>\n        [HttpGet(\"General\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        public ActionResult<IEnumerable<ImageByNameInfo>> GetGeneralImages()\n        {\n            return GetImageList(_applicationPaths.GeneralPath, false);\n        }\n\n        /// <summary>\n        ///     Get General Image.\n        /// </summary>\n        /// <param name=\"name\">The name of the image.</param>\n        /// <param name=\"type\">Image Type (primary, backdrop, logo, etc).</param>\n        /// <response code=\"200\">Image stream retrieved.</response>\n        /// <response code=\"404\">Image not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        [HttpGet(\"General/{name}/{type}\")]\n        [AllowAnonymous]\n        [Produces(MediaTypeNames.Application.Octet)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesImageFile]\n        public ActionResult GetGeneralImage([FromRoute, Required] string name, [FromRoute, Required] string type)\n        {\n            var filename = string.Equals(type, \"primary\", StringComparison.OrdinalIgnoreCase)\n                ? \"folder\"\n                : type;\n\n            var path = BaseItem.SupportedImageExtensions\n                .Select(i => Path.Combine(_applicationPaths.GeneralPath, name, filename + i))\n                .FirstOrDefault(System.IO.File.Exists);\n\n            if (path == null)\n            {\n                return NotFound();\n            }\n\n            var contentType = MimeTypes.GetMimeType(path);\n            return File(System.IO.File.OpenRead(path), contentType);\n        }\n\n        /// <summary>\n        ///     Get all general images.\n        /// </summary>\n        /// <response code=\"200\">Retrieved list of images.</response>\n        /// <returns>An <see cref=\"OkResult\"/> containing the list of images.</returns>\n        [HttpGet(\"Ratings\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        public ActionResult<IEnumerable<ImageByNameInfo>> GetRatingImages()\n        {\n            return GetImageList(_applicationPaths.RatingsPath, false);\n        }\n\n        /// <summary>\n        ///     Get rating image.\n        /// </summary>\n        /// <param name=\"theme\">The theme to get the image from.</param>\n        /// <param name=\"name\">The name of the image.</param>\n        /// <response code=\"200\">Image stream retrieved.</response>\n        /// <response code=\"404\">Image not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        [HttpGet(\"Ratings/{theme}/{name}\")]\n        [AllowAnonymous]\n        [Produces(MediaTypeNames.Application.Octet)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesImageFile]\n        public ActionResult GetRatingImage(\n            [FromRoute, Required] string theme,\n            [FromRoute, Required] string name)\n        {\n            return GetImageFile(_applicationPaths.RatingsPath, theme, name);\n        }\n\n        /// <summary>\n        ///     Get all media info images.\n        /// </summary>\n        /// <response code=\"200\">Image list retrieved.</response>\n        /// <returns>An <see cref=\"OkResult\"/> containing the list of images.</returns>\n        [HttpGet(\"MediaInfo\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        public ActionResult<IEnumerable<ImageByNameInfo>> GetMediaInfoImages()\n        {\n            return GetImageList(_applicationPaths.MediaInfoImagesPath, false);\n        }\n\n        /// <summary>\n        ///     Get media info image.\n        /// </summary>\n        /// <param name=\"theme\">The theme to get the image from.</param>\n        /// <param name=\"name\">The name of the image.</param>\n        /// <response code=\"200\">Image stream retrieved.</response>\n        /// <response code=\"404\">Image not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        [HttpGet(\"MediaInfo/{theme}/{name}\")]\n        [AllowAnonymous]\n        [Produces(MediaTypeNames.Application.Octet)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesImageFile]\n        public ActionResult GetMediaInfoImage(\n            [FromRoute, Required] string theme,\n            [FromRoute, Required] string name)\n        {\n            return GetImageFile(_applicationPaths.MediaInfoImagesPath, theme, name);\n        }\n\n        /// <summary>\n        ///     Internal FileHelper.\n        /// </summary>\n        /// <param name=\"basePath\">Path to begin search.</param>\n        /// <param name=\"theme\">Theme to search.</param>\n        /// <param name=\"name\">File name to search for.</param>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        private ActionResult GetImageFile(string basePath, string theme, string? name)\n        {\n            var themeFolder = Path.Combine(basePath, theme);\n            if (Directory.Exists(themeFolder))\n            {\n                var path = BaseItem.SupportedImageExtensions.Select(i => Path.Combine(themeFolder, name + i))\n                    .FirstOrDefault(System.IO.File.Exists);\n\n                if (!string.IsNullOrEmpty(path) && System.IO.File.Exists(path))\n                {\n                    var contentType = MimeTypes.GetMimeType(path);\n                    return PhysicalFile(path, contentType);\n                }\n            }\n\n            var allFolder = Path.Combine(basePath, \"all\");\n            if (Directory.Exists(allFolder))\n            {\n                var path = BaseItem.SupportedImageExtensions.Select(i => Path.Combine(allFolder, name + i))\n                    .FirstOrDefault(System.IO.File.Exists);\n\n                if (!string.IsNullOrEmpty(path) && System.IO.File.Exists(path))\n                {\n                    var contentType = MimeTypes.GetMimeType(path);\n                    return PhysicalFile(path, contentType);\n                }\n            }\n\n            return NotFound();\n        }\n\n        private List<ImageByNameInfo> GetImageList(string path, bool supportsThemes)\n        {\n            try\n            {\n                return _fileSystem.GetFiles(path, BaseItem.SupportedImageExtensions, false, true)\n                    .Select(i => new ImageByNameInfo\n                    {\n                        Name = _fileSystem.GetFileNameWithoutExtension(i),\n                        FileLength = i.Length,\n\n                        // For themeable images, use the Theme property\n                        // For general images, the same object structure is fine,\n                        // but it's not owned by a theme, so call it Context\n                        Theme = supportsThemes ? GetThemeName(i.FullName, path) : null,\n                        Context = supportsThemes ? null : GetThemeName(i.FullName, path),\n                        Format = i.Extension.ToLowerInvariant().TrimStart('.')\n                    })\n                    .OrderBy(i => i.Name)\n                    .ToList();\n            }\n            catch (IOException)\n            {\n                return new List<ImageByNameInfo>();\n            }\n        }\n\n        private string? GetThemeName(string path, string rootImagePath)\n        {\n            var parentName = Path.GetDirectoryName(path);\n\n            if (string.Equals(parentName, rootImagePath, StringComparison.OrdinalIgnoreCase))\n            {\n                return null;\n            }\n\n            parentName = Path.GetFileName(parentName);\n\n            return string.Equals(parentName, \"all\", StringComparison.OrdinalIgnoreCase) ? null : parentName;\n        }\n    }\n}\n", "#pragma warning disable CS1591\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing MediaBrowser.Common.Extensions;\nusing MediaBrowser.Controller.Entities;\nusing MediaBrowser.Controller.Entities.Movies;\nusing MediaBrowser.Controller.Entities.TV;\nusing MediaBrowser.Controller.Library;\nusing MediaBrowser.Controller.Persistence;\nusing MediaBrowser.Controller.Providers;\nusing MediaBrowser.Controller.Subtitles;\nusing MediaBrowser.Model.Configuration;\nusing MediaBrowser.Model.Entities;\nusing MediaBrowser.Model.Globalization;\nusing MediaBrowser.Model.IO;\nusing MediaBrowser.Model.Providers;\nusing Microsoft.Extensions.Logging;\nusing static MediaBrowser.Model.IO.IODefaults;\n\nnamespace MediaBrowser.Providers.Subtitles\n{\n    public class SubtitleManager : ISubtitleManager\n    {\n        private readonly ILogger<SubtitleManager> _logger;\n        private readonly IFileSystem _fileSystem;\n        private readonly ILibraryMonitor _monitor;\n        private readonly IMediaSourceManager _mediaSourceManager;\n        private readonly ILocalizationManager _localization;\n\n        private ISubtitleProvider[] _subtitleProviders;\n\n        public SubtitleManager(\n            ILogger<SubtitleManager> logger,\n            IFileSystem fileSystem,\n            ILibraryMonitor monitor,\n            IMediaSourceManager mediaSourceManager,\n            ILocalizationManager localizationManager)\n        {\n            _logger = logger;\n            _fileSystem = fileSystem;\n            _monitor = monitor;\n            _mediaSourceManager = mediaSourceManager;\n            _localization = localizationManager;\n        }\n\n        /// <inheritdoc />\n        public event EventHandler<SubtitleDownloadFailureEventArgs> SubtitleDownloadFailure;\n\n        /// <inheritdoc />\n        public void AddParts(IEnumerable<ISubtitleProvider> subtitleProviders)\n        {\n            _subtitleProviders = subtitleProviders\n                .OrderBy(i => i is IHasOrder hasOrder ? hasOrder.Order : 0)\n                .ToArray();\n        }\n\n        /// <inheritdoc />\n        public async Task<RemoteSubtitleInfo[]> SearchSubtitles(SubtitleSearchRequest request, CancellationToken cancellationToken)\n        {\n            if (request.Language != null)\n            {\n                var culture = _localization.FindLanguageInfo(request.Language);\n\n                if (culture != null)\n                {\n                    request.TwoLetterISOLanguageName = culture.TwoLetterISOLanguageName;\n                }\n            }\n\n            var contentType = request.ContentType;\n            var providers = _subtitleProviders\n                .Where(i => i.SupportedMediaTypes.Contains(contentType))\n                .Where(i => !request.DisabledSubtitleFetchers.Contains(i.Name, StringComparer.OrdinalIgnoreCase))\n                .OrderBy(i =>\n                {\n                    var index = request.SubtitleFetcherOrder.ToList().IndexOf(i.Name);\n                    return index == -1 ? int.MaxValue : index;\n                })\n                .ToArray();\n\n            // If not searching all, search one at a time until something is found\n            if (!request.SearchAllProviders)\n            {\n                foreach (var provider in providers)\n                {\n                    try\n                    {\n                        var searchResults = await provider.Search(request, cancellationToken).ConfigureAwait(false);\n\n                        var list = searchResults.ToArray();\n\n                        if (list.Length > 0)\n                        {\n                            Normalize(list);\n                            return list;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(ex, \"Error downloading subtitles from {Provider}\", provider.Name);\n                    }\n                }\n\n                return Array.Empty<RemoteSubtitleInfo>();\n            }\n\n            var tasks = providers.Select(async i =>\n            {\n                try\n                {\n                    var searchResults = await i.Search(request, cancellationToken).ConfigureAwait(false);\n\n                    var list = searchResults.ToArray();\n                    Normalize(list);\n                    return list;\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"Error downloading subtitles from {0}\", i.Name);\n                    return Array.Empty<RemoteSubtitleInfo>();\n                }\n            });\n\n            var results = await Task.WhenAll(tasks).ConfigureAwait(false);\n\n            return results.SelectMany(i => i).ToArray();\n        }\n\n        /// <inheritdoc />\n        public Task DownloadSubtitles(Video video, string subtitleId, CancellationToken cancellationToken)\n        {\n            var libraryOptions = BaseItem.LibraryManager.GetLibraryOptions(video);\n\n            return DownloadSubtitles(video, libraryOptions, subtitleId, cancellationToken);\n        }\n\n        /// <inheritdoc />\n        public async Task DownloadSubtitles(\n            Video video,\n            LibraryOptions libraryOptions,\n            string subtitleId,\n            CancellationToken cancellationToken)\n        {\n            var parts = subtitleId.Split('_', 2);\n            var provider = GetProvider(parts[0]);\n\n            try\n            {\n                var response = await GetRemoteSubtitles(subtitleId, cancellationToken).ConfigureAwait(false);\n\n                await TrySaveSubtitle(video, libraryOptions, response).ConfigureAwait(false);\n            }\n            catch (RateLimitExceededException)\n            {\n                throw;\n            }\n            catch (Exception ex)\n            {\n                SubtitleDownloadFailure?.Invoke(this, new SubtitleDownloadFailureEventArgs\n                {\n                    Item = video,\n                    Exception = ex,\n                    Provider = provider.Name\n                });\n\n                throw;\n            }\n        }\n\n        /// <inheritdoc />\n        public Task UploadSubtitle(Video video, SubtitleResponse response)\n        {\n            var libraryOptions = BaseItem.LibraryManager.GetLibraryOptions(video);\n            return TrySaveSubtitle(video, libraryOptions, response);\n        }\n\n        private async Task TrySaveSubtitle(\n            Video video,\n            LibraryOptions libraryOptions,\n            SubtitleResponse response)\n        {\n            var saveInMediaFolder = libraryOptions.SaveSubtitlesWithMedia;\n\n            using (var stream = response.Stream)\n            using (var memoryStream = new MemoryStream())\n            {\n                await stream.CopyToAsync(memoryStream).ConfigureAwait(false);\n                memoryStream.Position = 0;\n\n                var savePaths = new List<string>();\n                var saveFileName = Path.GetFileNameWithoutExtension(video.Path) + \".\" + response.Language.ToLowerInvariant();\n\n                if (response.IsForced)\n                {\n                    saveFileName += \".forced\";\n                }\n\n                saveFileName += \".\" + response.Format.ToLowerInvariant();\n\n                if (saveInMediaFolder)\n                {\n                    savePaths.Add(Path.Combine(video.ContainingFolderPath, saveFileName));\n                }\n\n                savePaths.Add(Path.Combine(video.GetInternalMetadataPath(), saveFileName));\n\n                await TrySaveToFiles(memoryStream, savePaths).ConfigureAwait(false);\n            }\n        }\n\n        private async Task TrySaveToFiles(Stream stream, List<string> savePaths)\n        {\n            Exception exceptionToThrow = null;\n\n            foreach (var savePath in savePaths)\n            {\n                _logger.LogInformation(\"Saving subtitles to {0}\", savePath);\n\n                _monitor.ReportFileSystemChangeBeginning(savePath);\n\n                try\n                {\n                    Directory.CreateDirectory(Path.GetDirectoryName(savePath));\n\n                    // use FileShare.None as this bypasses dotnet bug dotnet/runtime#42790 .\n                    using (var fs = new FileStream(savePath, FileMode.Create, FileAccess.Write, FileShare.None, FileStreamBufferSize, true))\n                    {\n                        await stream.CopyToAsync(fs).ConfigureAwait(false);\n                    }\n\n                    return;\n                }\n                catch (Exception ex)\n                {\n                    if (exceptionToThrow == null)\n                    {\n                        exceptionToThrow = ex;\n                    }\n                }\n                finally\n                {\n                    _monitor.ReportFileSystemChangeComplete(savePath, false);\n                }\n\n                stream.Position = 0;\n            }\n\n            if (exceptionToThrow != null)\n            {\n                throw exceptionToThrow;\n            }\n        }\n\n        /// <inheritdoc />\n        public Task<RemoteSubtitleInfo[]> SearchSubtitles(Video video, string language, bool? isPerfectMatch, CancellationToken cancellationToken)\n        {\n            if (video.VideoType != VideoType.VideoFile)\n            {\n                return Task.FromResult(Array.Empty<RemoteSubtitleInfo>());\n            }\n\n            VideoContentType mediaType;\n\n            if (video is Episode)\n            {\n                mediaType = VideoContentType.Episode;\n            }\n            else if (video is Movie)\n            {\n                mediaType = VideoContentType.Movie;\n            }\n            else\n            {\n                // These are the only supported types\n                return Task.FromResult(Array.Empty<RemoteSubtitleInfo>());\n            }\n\n            var request = new SubtitleSearchRequest\n            {\n                ContentType = mediaType,\n                IndexNumber = video.IndexNumber,\n                Language = language,\n                MediaPath = video.Path,\n                Name = video.Name,\n                ParentIndexNumber = video.ParentIndexNumber,\n                ProductionYear = video.ProductionYear,\n                ProviderIds = video.ProviderIds,\n                RuntimeTicks = video.RunTimeTicks,\n                IsPerfectMatch = isPerfectMatch ?? false\n            };\n\n            if (video is Episode episode)\n            {\n                request.IndexNumberEnd = episode.IndexNumberEnd;\n                request.SeriesName = episode.SeriesName;\n            }\n\n            return SearchSubtitles(request, cancellationToken);\n        }\n\n        private void Normalize(IEnumerable<RemoteSubtitleInfo> subtitles)\n        {\n            foreach (var sub in subtitles)\n            {\n                sub.Id = GetProviderId(sub.ProviderName) + \"_\" + sub.Id;\n            }\n        }\n\n        private string GetProviderId(string name)\n        {\n            return name.ToLowerInvariant().GetMD5().ToString(\"N\", CultureInfo.InvariantCulture);\n        }\n\n        private ISubtitleProvider GetProvider(string id)\n        {\n            return _subtitleProviders.First(i => string.Equals(id, GetProviderId(i.Name), StringComparison.Ordinal));\n        }\n\n        /// <inheritdoc />\n        public Task DeleteSubtitles(BaseItem item, int index)\n        {\n            var stream = _mediaSourceManager.GetMediaStreams(new MediaStreamQuery\n            {\n                Index = index,\n                ItemId = item.Id,\n                Type = MediaStreamType.Subtitle\n            })[0];\n\n            var path = stream.Path;\n            _monitor.ReportFileSystemChangeBeginning(path);\n\n            try\n            {\n                _fileSystem.DeleteFile(path);\n            }\n            finally\n            {\n                _monitor.ReportFileSystemChangeComplete(path, false);\n            }\n\n            return item.RefreshMetadata(CancellationToken.None);\n        }\n\n        /// <inheritdoc />\n        public Task<SubtitleResponse> GetRemoteSubtitles(string id, CancellationToken cancellationToken)\n        {\n            var parts = id.Split('_', 2);\n\n            var provider = GetProvider(parts[0]);\n            id = parts[^1];\n\n            return provider.GetSubtitles(id, cancellationToken);\n        }\n\n        /// <inheritdoc />\n        public SubtitleProviderInfo[] GetSupportedProviders(BaseItem video)\n        {\n            VideoContentType mediaType;\n\n            if (video is Episode)\n            {\n                mediaType = VideoContentType.Episode;\n            }\n            else if (video is Movie)\n            {\n                mediaType = VideoContentType.Movie;\n            }\n            else\n            {\n                // These are the only supported types\n                return Array.Empty<SubtitleProviderInfo>();\n            }\n\n            return _subtitleProviders\n                .Where(i => i.SupportedMediaTypes.Contains(mediaType))\n                .Select(i => new SubtitleProviderInfo\n                {\n                    Name = i.Name,\n                    Id = GetProviderId(i.Name)\n                }).ToArray();\n        }\n    }\n}\n"], "fixing_code": ["using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Jellyfin.Api.Attributes;\nusing Jellyfin.Api.Constants;\nusing Jellyfin.Api.Helpers;\nusing MediaBrowser.Common.Configuration;\nusing MediaBrowser.Common.Extensions;\nusing MediaBrowser.Controller.Configuration;\nusing MediaBrowser.Controller.MediaEncoding;\nusing MediaBrowser.Model.IO;\nusing MediaBrowser.Model.Net;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace Jellyfin.Api.Controllers\n{\n    /// <summary>\n    /// The hls segment controller.\n    /// </summary>\n    [Route(\"\")]\n    public class HlsSegmentController : BaseJellyfinApiController\n    {\n        private readonly IFileSystem _fileSystem;\n        private readonly IServerConfigurationManager _serverConfigurationManager;\n        private readonly TranscodingJobHelper _transcodingJobHelper;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"HlsSegmentController\"/> class.\n        /// </summary>\n        /// <param name=\"fileSystem\">Instance of the <see cref=\"IFileSystem\"/> interface.</param>\n        /// <param name=\"serverConfigurationManager\">Instance of the <see cref=\"IServerConfigurationManager\"/> interface.</param>\n        /// <param name=\"transcodingJobHelper\">Initialized instance of the <see cref=\"TranscodingJobHelper\"/>.</param>\n        public HlsSegmentController(\n            IFileSystem fileSystem,\n            IServerConfigurationManager serverConfigurationManager,\n            TranscodingJobHelper transcodingJobHelper)\n        {\n            _fileSystem = fileSystem;\n            _serverConfigurationManager = serverConfigurationManager;\n            _transcodingJobHelper = transcodingJobHelper;\n        }\n\n        /// <summary>\n        /// Gets the specified audio segment for an audio item.\n        /// </summary>\n        /// <param name=\"itemId\">The item id.</param>\n        /// <param name=\"segmentId\">The segment id.</param>\n        /// <response code=\"200\">Hls audio segment returned.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the audio stream.</returns>\n        // Can't require authentication just yet due to seeing some requests come from Chrome without full query string\n        // [Authenticated]\n        [HttpGet(\"Audio/{itemId}/hls/{segmentId}/stream.mp3\", Name = \"GetHlsAudioSegmentLegacyMp3\")]\n        [HttpGet(\"Audio/{itemId}/hls/{segmentId}/stream.aac\", Name = \"GetHlsAudioSegmentLegacyAac\")]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesAudioFile]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1801:ReviewUnusedParameters\", MessageId = \"itemId\", Justification = \"Required for ServiceStack\")]\n        public ActionResult GetHlsAudioSegmentLegacy([FromRoute, Required] string itemId, [FromRoute, Required] string segmentId)\n        {\n            // TODO: Deprecate with new iOS app\n            var file = segmentId + Path.GetExtension(Request.Path);\n            var transcodePath = _serverConfigurationManager.GetTranscodePath();\n            file = Path.GetFullPath(Path.Combine(transcodePath, file));\n            var fileDir = Path.GetDirectoryName(file);\n            if (string.IsNullOrEmpty(fileDir) || !fileDir.StartsWith(transcodePath))\n            {\n                return BadRequest(\"Invalid segment.\");\n            }\n\n            return FileStreamResponseHelpers.GetStaticFileResult(file, MimeTypes.GetMimeType(file)!, false, HttpContext);\n        }\n\n        /// <summary>\n        /// Gets a hls video playlist.\n        /// </summary>\n        /// <param name=\"itemId\">The video id.</param>\n        /// <param name=\"playlistId\">The playlist id.</param>\n        /// <response code=\"200\">Hls video playlist returned.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the playlist.</returns>\n        [HttpGet(\"Videos/{itemId}/hls/{playlistId}/stream.m3u8\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesPlaylistFile]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1801:ReviewUnusedParameters\", MessageId = \"itemId\", Justification = \"Required for ServiceStack\")]\n        public ActionResult GetHlsPlaylistLegacy([FromRoute, Required] string itemId, [FromRoute, Required] string playlistId)\n        {\n            var file = playlistId + Path.GetExtension(Request.Path);\n            var transcodePath = _serverConfigurationManager.GetTranscodePath();\n            file = Path.GetFullPath(Path.Combine(transcodePath, file));\n            var fileDir = Path.GetDirectoryName(file);\n            if (string.IsNullOrEmpty(fileDir) || !fileDir.StartsWith(transcodePath) || Path.GetExtension(file) != \".m3u8\")\n            {\n                return BadRequest(\"Invalid segment.\");\n            }\n\n            return GetFileResult(file, file);\n        }\n\n        /// <summary>\n        /// Stops an active encoding.\n        /// </summary>\n        /// <param name=\"deviceId\">The device id of the client requesting. Used to stop encoding processes when needed.</param>\n        /// <param name=\"playSessionId\">The play session id.</param>\n        /// <response code=\"204\">Encoding stopped successfully.</response>\n        /// <returns>A <see cref=\"NoContentResult\"/> indicating success.</returns>\n        [HttpDelete(\"Videos/ActiveEncodings\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status204NoContent)]\n        public ActionResult StopEncodingProcess(\n            [FromQuery, Required] string deviceId,\n            [FromQuery, Required] string playSessionId)\n        {\n            _transcodingJobHelper.KillTranscodingJobs(deviceId, playSessionId, path => true);\n            return NoContent();\n        }\n\n        /// <summary>\n        /// Gets a hls video segment.\n        /// </summary>\n        /// <param name=\"itemId\">The item id.</param>\n        /// <param name=\"playlistId\">The playlist id.</param>\n        /// <param name=\"segmentId\">The segment id.</param>\n        /// <param name=\"segmentContainer\">The segment container.</param>\n        /// <response code=\"200\">Hls video segment returned.</response>\n        /// <response code=\"404\">Hls segment not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the video segment.</returns>\n        // Can't require authentication just yet due to seeing some requests come from Chrome without full query string\n        // [Authenticated]\n        [HttpGet(\"Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}\")]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesVideoFile]\n        [SuppressMessage(\"Microsoft.Performance\", \"CA1801:ReviewUnusedParameters\", MessageId = \"itemId\", Justification = \"Required for ServiceStack\")]\n        public ActionResult GetHlsVideoSegmentLegacy(\n            [FromRoute, Required] string itemId,\n            [FromRoute, Required] string playlistId,\n            [FromRoute, Required] string segmentId,\n            [FromRoute, Required] string segmentContainer)\n        {\n            var file = segmentId + Path.GetExtension(Request.Path);\n            var transcodeFolderPath = _serverConfigurationManager.GetTranscodePath();\n\n            file = Path.GetFullPath(Path.Combine(transcodeFolderPath, file));\n            var fileDir = Path.GetDirectoryName(file);\n            if (string.IsNullOrEmpty(fileDir) || !fileDir.StartsWith(transcodeFolderPath))\n            {\n                return BadRequest(\"Invalid segment.\");\n            }\n\n            var normalizedPlaylistId = playlistId;\n\n            var filePaths = _fileSystem.GetFilePaths(transcodeFolderPath);\n            // Add . to start of segment container for future use.\n            segmentContainer = segmentContainer.Insert(0, \".\");\n            string? playlistPath = null;\n            foreach (var path in filePaths)\n            {\n                var pathExtension = Path.GetExtension(path);\n                if ((string.Equals(pathExtension, segmentContainer, StringComparison.OrdinalIgnoreCase)\n                     || string.Equals(pathExtension, \".m3u8\", StringComparison.OrdinalIgnoreCase))\n                    && path.IndexOf(normalizedPlaylistId, StringComparison.OrdinalIgnoreCase) != -1)\n                {\n                    playlistPath = path;\n                    break;\n                }\n            }\n\n            return playlistPath == null\n                ? NotFound(\"Hls segment not found.\")\n                : GetFileResult(file, playlistPath);\n        }\n\n        private ActionResult GetFileResult(string path, string playlistPath)\n        {\n            var transcodingJob = _transcodingJobHelper.OnTranscodeBeginRequest(playlistPath, TranscodingJobType.Hls);\n\n            Response.OnCompleted(() =>\n            {\n                if (transcodingJob != null)\n                {\n                    _transcodingJobHelper.OnTranscodeEndRequest(transcodingJob);\n                }\n\n                return Task.CompletedTask;\n            });\n\n            return FileStreamResponseHelpers.GetStaticFileResult(path, MimeTypes.GetMimeType(path)!, false, HttpContext);\n        }\n    }\n}\n", "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Mime;\nusing Jellyfin.Api.Attributes;\nusing Jellyfin.Api.Constants;\nusing MediaBrowser.Controller;\nusing MediaBrowser.Controller.Configuration;\nusing MediaBrowser.Controller.Entities;\nusing MediaBrowser.Model.Dto;\nusing MediaBrowser.Model.IO;\nusing MediaBrowser.Model.Net;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace Jellyfin.Api.Controllers\n{\n    /// <summary>\n    ///     Images By Name Controller.\n    /// </summary>\n    [Route(\"Images\")]\n    public class ImageByNameController : BaseJellyfinApiController\n    {\n        private readonly IServerApplicationPaths _applicationPaths;\n        private readonly IFileSystem _fileSystem;\n\n        /// <summary>\n        ///     Initializes a new instance of the <see cref=\"ImageByNameController\" /> class.\n        /// </summary>\n        /// <param name=\"serverConfigurationManager\">Instance of the <see cref=\"IServerConfigurationManager\" /> interface.</param>\n        /// <param name=\"fileSystem\">Instance of the <see cref=\"IFileSystem\" /> interface.</param>\n        public ImageByNameController(\n            IServerConfigurationManager serverConfigurationManager,\n            IFileSystem fileSystem)\n        {\n            _applicationPaths = serverConfigurationManager.ApplicationPaths;\n            _fileSystem = fileSystem;\n        }\n\n        /// <summary>\n        ///     Get all general images.\n        /// </summary>\n        /// <response code=\"200\">Retrieved list of images.</response>\n        /// <returns>An <see cref=\"OkResult\"/> containing the list of images.</returns>\n        [HttpGet(\"General\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        public ActionResult<IEnumerable<ImageByNameInfo>> GetGeneralImages()\n        {\n            return GetImageList(_applicationPaths.GeneralPath, false);\n        }\n\n        /// <summary>\n        ///     Get General Image.\n        /// </summary>\n        /// <param name=\"name\">The name of the image.</param>\n        /// <param name=\"type\">Image Type (primary, backdrop, logo, etc).</param>\n        /// <response code=\"200\">Image stream retrieved.</response>\n        /// <response code=\"404\">Image not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        [HttpGet(\"General/{name}/{type}\")]\n        [AllowAnonymous]\n        [Produces(MediaTypeNames.Application.Octet)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesImageFile]\n        public ActionResult GetGeneralImage([FromRoute, Required] string name, [FromRoute, Required] string type)\n        {\n            var filename = string.Equals(type, \"primary\", StringComparison.OrdinalIgnoreCase)\n                ? \"folder\"\n                : type;\n\n            var path = BaseItem.SupportedImageExtensions\n                .Select(i => Path.GetFullPath(Path.Combine(_applicationPaths.GeneralPath, name, filename + i)))\n                .FirstOrDefault(System.IO.File.Exists);\n\n            if (path == null)\n            {\n                return NotFound();\n            }\n\n            if (!path.StartsWith(_applicationPaths.GeneralPath))\n            {\n                return BadRequest(\"Invalid image path.\");\n            }\n\n            var contentType = MimeTypes.GetMimeType(path);\n            return File(System.IO.File.OpenRead(path), contentType);\n        }\n\n        /// <summary>\n        ///     Get all general images.\n        /// </summary>\n        /// <response code=\"200\">Retrieved list of images.</response>\n        /// <returns>An <see cref=\"OkResult\"/> containing the list of images.</returns>\n        [HttpGet(\"Ratings\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        public ActionResult<IEnumerable<ImageByNameInfo>> GetRatingImages()\n        {\n            return GetImageList(_applicationPaths.RatingsPath, false);\n        }\n\n        /// <summary>\n        ///     Get rating image.\n        /// </summary>\n        /// <param name=\"theme\">The theme to get the image from.</param>\n        /// <param name=\"name\">The name of the image.</param>\n        /// <response code=\"200\">Image stream retrieved.</response>\n        /// <response code=\"404\">Image not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        [HttpGet(\"Ratings/{theme}/{name}\")]\n        [AllowAnonymous]\n        [Produces(MediaTypeNames.Application.Octet)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesImageFile]\n        public ActionResult GetRatingImage(\n            [FromRoute, Required] string theme,\n            [FromRoute, Required] string name)\n        {\n            return GetImageFile(_applicationPaths.RatingsPath, theme, name);\n        }\n\n        /// <summary>\n        ///     Get all media info images.\n        /// </summary>\n        /// <response code=\"200\">Image list retrieved.</response>\n        /// <returns>An <see cref=\"OkResult\"/> containing the list of images.</returns>\n        [HttpGet(\"MediaInfo\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        public ActionResult<IEnumerable<ImageByNameInfo>> GetMediaInfoImages()\n        {\n            return GetImageList(_applicationPaths.MediaInfoImagesPath, false);\n        }\n\n        /// <summary>\n        ///     Get media info image.\n        /// </summary>\n        /// <param name=\"theme\">The theme to get the image from.</param>\n        /// <param name=\"name\">The name of the image.</param>\n        /// <response code=\"200\">Image stream retrieved.</response>\n        /// <response code=\"404\">Image not found.</response>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        [HttpGet(\"MediaInfo/{theme}/{name}\")]\n        [AllowAnonymous]\n        [Produces(MediaTypeNames.Application.Octet)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status404NotFound)]\n        [ProducesImageFile]\n        public ActionResult GetMediaInfoImage(\n            [FromRoute, Required] string theme,\n            [FromRoute, Required] string name)\n        {\n            return GetImageFile(_applicationPaths.MediaInfoImagesPath, theme, name);\n        }\n\n        /// <summary>\n        ///     Internal FileHelper.\n        /// </summary>\n        /// <param name=\"basePath\">Path to begin search.</param>\n        /// <param name=\"theme\">Theme to search.</param>\n        /// <param name=\"name\">File name to search for.</param>\n        /// <returns>A <see cref=\"FileStreamResult\"/> containing the image contents on success, or a <see cref=\"NotFoundResult\"/> if the image could not be found.</returns>\n        private ActionResult GetImageFile(string basePath, string theme, string? name)\n        {\n            var themeFolder = Path.GetFullPath(Path.Combine(basePath, theme));\n\n            if (Directory.Exists(themeFolder))\n            {\n                var path = BaseItem.SupportedImageExtensions.Select(i => Path.Combine(themeFolder, name + i))\n                    .FirstOrDefault(System.IO.File.Exists);\n\n                if (!string.IsNullOrEmpty(path) && System.IO.File.Exists(path))\n                {\n                    if (!path.StartsWith(basePath))\n                    {\n                        return BadRequest(\"Invalid image path.\");\n                    }\n\n                    var contentType = MimeTypes.GetMimeType(path);\n\n                    return PhysicalFile(path, contentType);\n                }\n            }\n\n            var allFolder = Path.GetFullPath(Path.Combine(basePath, \"all\"));\n            if (Directory.Exists(allFolder))\n            {\n                var path = BaseItem.SupportedImageExtensions.Select(i => Path.Combine(allFolder, name + i))\n                    .FirstOrDefault(System.IO.File.Exists);\n\n                if (!string.IsNullOrEmpty(path) && System.IO.File.Exists(path))\n                {\n                    if (!path.StartsWith(basePath))\n                    {\n                        return BadRequest(\"Invalid image path.\");\n                    }\n\n                    var contentType = MimeTypes.GetMimeType(path);\n                    return PhysicalFile(path, contentType);\n                }\n            }\n\n            return NotFound();\n        }\n\n        private List<ImageByNameInfo> GetImageList(string path, bool supportsThemes)\n        {\n            try\n            {\n                return _fileSystem.GetFiles(path, BaseItem.SupportedImageExtensions, false, true)\n                    .Select(i => new ImageByNameInfo\n                    {\n                        Name = _fileSystem.GetFileNameWithoutExtension(i),\n                        FileLength = i.Length,\n\n                        // For themeable images, use the Theme property\n                        // For general images, the same object structure is fine,\n                        // but it's not owned by a theme, so call it Context\n                        Theme = supportsThemes ? GetThemeName(i.FullName, path) : null,\n                        Context = supportsThemes ? null : GetThemeName(i.FullName, path),\n                        Format = i.Extension.ToLowerInvariant().TrimStart('.')\n                    })\n                    .OrderBy(i => i.Name)\n                    .ToList();\n            }\n            catch (IOException)\n            {\n                return new List<ImageByNameInfo>();\n            }\n        }\n\n        private string? GetThemeName(string path, string rootImagePath)\n        {\n            var parentName = Path.GetDirectoryName(path);\n\n            if (string.Equals(parentName, rootImagePath, StringComparison.OrdinalIgnoreCase))\n            {\n                return null;\n            }\n\n            parentName = Path.GetFileName(parentName);\n\n            return string.Equals(parentName, \"all\", StringComparison.OrdinalIgnoreCase) ? null : parentName;\n        }\n    }\n}\n", "#pragma warning disable CS1591\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing MediaBrowser.Common.Extensions;\nusing MediaBrowser.Controller.Entities;\nusing MediaBrowser.Controller.Entities.Movies;\nusing MediaBrowser.Controller.Entities.TV;\nusing MediaBrowser.Controller.Library;\nusing MediaBrowser.Controller.Persistence;\nusing MediaBrowser.Controller.Providers;\nusing MediaBrowser.Controller.Subtitles;\nusing MediaBrowser.Model.Configuration;\nusing MediaBrowser.Model.Entities;\nusing MediaBrowser.Model.Globalization;\nusing MediaBrowser.Model.IO;\nusing MediaBrowser.Model.Providers;\nusing Microsoft.Extensions.Logging;\nusing static MediaBrowser.Model.IO.IODefaults;\n\nnamespace MediaBrowser.Providers.Subtitles\n{\n    public class SubtitleManager : ISubtitleManager\n    {\n        private readonly ILogger<SubtitleManager> _logger;\n        private readonly IFileSystem _fileSystem;\n        private readonly ILibraryMonitor _monitor;\n        private readonly IMediaSourceManager _mediaSourceManager;\n        private readonly ILocalizationManager _localization;\n\n        private ISubtitleProvider[] _subtitleProviders;\n\n        public SubtitleManager(\n            ILogger<SubtitleManager> logger,\n            IFileSystem fileSystem,\n            ILibraryMonitor monitor,\n            IMediaSourceManager mediaSourceManager,\n            ILocalizationManager localizationManager)\n        {\n            _logger = logger;\n            _fileSystem = fileSystem;\n            _monitor = monitor;\n            _mediaSourceManager = mediaSourceManager;\n            _localization = localizationManager;\n        }\n\n        /// <inheritdoc />\n        public event EventHandler<SubtitleDownloadFailureEventArgs> SubtitleDownloadFailure;\n\n        /// <inheritdoc />\n        public void AddParts(IEnumerable<ISubtitleProvider> subtitleProviders)\n        {\n            _subtitleProviders = subtitleProviders\n                .OrderBy(i => i is IHasOrder hasOrder ? hasOrder.Order : 0)\n                .ToArray();\n        }\n\n        /// <inheritdoc />\n        public async Task<RemoteSubtitleInfo[]> SearchSubtitles(SubtitleSearchRequest request, CancellationToken cancellationToken)\n        {\n            if (request.Language != null)\n            {\n                var culture = _localization.FindLanguageInfo(request.Language);\n\n                if (culture != null)\n                {\n                    request.TwoLetterISOLanguageName = culture.TwoLetterISOLanguageName;\n                }\n            }\n\n            var contentType = request.ContentType;\n            var providers = _subtitleProviders\n                .Where(i => i.SupportedMediaTypes.Contains(contentType))\n                .Where(i => !request.DisabledSubtitleFetchers.Contains(i.Name, StringComparer.OrdinalIgnoreCase))\n                .OrderBy(i =>\n                {\n                    var index = request.SubtitleFetcherOrder.ToList().IndexOf(i.Name);\n                    return index == -1 ? int.MaxValue : index;\n                })\n                .ToArray();\n\n            // If not searching all, search one at a time until something is found\n            if (!request.SearchAllProviders)\n            {\n                foreach (var provider in providers)\n                {\n                    try\n                    {\n                        var searchResults = await provider.Search(request, cancellationToken).ConfigureAwait(false);\n\n                        var list = searchResults.ToArray();\n\n                        if (list.Length > 0)\n                        {\n                            Normalize(list);\n                            return list;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(ex, \"Error downloading subtitles from {Provider}\", provider.Name);\n                    }\n                }\n\n                return Array.Empty<RemoteSubtitleInfo>();\n            }\n\n            var tasks = providers.Select(async i =>\n            {\n                try\n                {\n                    var searchResults = await i.Search(request, cancellationToken).ConfigureAwait(false);\n\n                    var list = searchResults.ToArray();\n                    Normalize(list);\n                    return list;\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"Error downloading subtitles from {0}\", i.Name);\n                    return Array.Empty<RemoteSubtitleInfo>();\n                }\n            });\n\n            var results = await Task.WhenAll(tasks).ConfigureAwait(false);\n\n            return results.SelectMany(i => i).ToArray();\n        }\n\n        /// <inheritdoc />\n        public Task DownloadSubtitles(Video video, string subtitleId, CancellationToken cancellationToken)\n        {\n            var libraryOptions = BaseItem.LibraryManager.GetLibraryOptions(video);\n\n            return DownloadSubtitles(video, libraryOptions, subtitleId, cancellationToken);\n        }\n\n        /// <inheritdoc />\n        public async Task DownloadSubtitles(\n            Video video,\n            LibraryOptions libraryOptions,\n            string subtitleId,\n            CancellationToken cancellationToken)\n        {\n            var parts = subtitleId.Split('_', 2);\n            var provider = GetProvider(parts[0]);\n\n            try\n            {\n                var response = await GetRemoteSubtitles(subtitleId, cancellationToken).ConfigureAwait(false);\n\n                await TrySaveSubtitle(video, libraryOptions, response).ConfigureAwait(false);\n            }\n            catch (RateLimitExceededException)\n            {\n                throw;\n            }\n            catch (Exception ex)\n            {\n                SubtitleDownloadFailure?.Invoke(this, new SubtitleDownloadFailureEventArgs\n                {\n                    Item = video,\n                    Exception = ex,\n                    Provider = provider.Name\n                });\n\n                throw;\n            }\n        }\n\n        /// <inheritdoc />\n        public Task UploadSubtitle(Video video, SubtitleResponse response)\n        {\n            var libraryOptions = BaseItem.LibraryManager.GetLibraryOptions(video);\n            return TrySaveSubtitle(video, libraryOptions, response);\n        }\n\n        private async Task TrySaveSubtitle(\n            Video video,\n            LibraryOptions libraryOptions,\n            SubtitleResponse response)\n        {\n            var saveInMediaFolder = libraryOptions.SaveSubtitlesWithMedia;\n\n            using (var stream = response.Stream)\n            using (var memoryStream = new MemoryStream())\n            {\n                await stream.CopyToAsync(memoryStream).ConfigureAwait(false);\n                memoryStream.Position = 0;\n\n                var savePaths = new List<string>();\n                var saveFileName = Path.GetFileNameWithoutExtension(video.Path) + \".\" + response.Language.ToLowerInvariant();\n\n                if (response.IsForced)\n                {\n                    saveFileName += \".forced\";\n                }\n\n                saveFileName += \".\" + response.Format.ToLowerInvariant();\n\n                if (saveInMediaFolder)\n                {\n                    var mediaFolderPath = Path.GetFullPath(Path.Combine(video.ContainingFolderPath, saveFileName));\n                    // TODO: Add some error handling to the API user: return BadRequest(\"Could not save subtitle, bad path.\");\n                    if (mediaFolderPath.StartsWith(video.ContainingFolderPath))\n                    {\n                        savePaths.Add(mediaFolderPath);\n                    }\n                }\n\n                var internalPath = Path.GetFullPath(Path.Combine(video.GetInternalMetadataPath(), saveFileName));\n\n                // TODO: Add some error to the user: return BadRequest(\"Could not save subtitle, bad path.\");\n                if (internalPath.StartsWith(video.GetInternalMetadataPath()))\n                {\n                    savePaths.Add(internalPath);\n                }\n\n                if (savePaths.Count > 0)\n                {\n                    await TrySaveToFiles(memoryStream, savePaths).ConfigureAwait(false);\n                }\n                else\n                {\n                    _logger.LogError(\"An uploaded subtitle could not be saved because the resulting paths were invalid.\");\n                }\n            }\n        }\n\n        private async Task TrySaveToFiles(Stream stream, List<string> savePaths)\n        {\n            Exception exceptionToThrow = null;\n\n            foreach (var savePath in savePaths)\n            {\n                _logger.LogInformation(\"Saving subtitles to {0}\", savePath);\n\n                _monitor.ReportFileSystemChangeBeginning(savePath);\n\n                try\n                {\n                    Directory.CreateDirectory(Path.GetDirectoryName(savePath));\n\n                    // use FileShare.None as this bypasses dotnet bug dotnet/runtime#42790 .\n                    using (var fs = new FileStream(savePath, FileMode.Create, FileAccess.Write, FileShare.None, FileStreamBufferSize, true))\n                    {\n                        await stream.CopyToAsync(fs).ConfigureAwait(false);\n                    }\n\n                    return;\n                }\n                catch (Exception ex)\n                {\n                    if (exceptionToThrow == null)\n                    {\n                        exceptionToThrow = ex;\n                    }\n                }\n                finally\n                {\n                    _monitor.ReportFileSystemChangeComplete(savePath, false);\n                }\n\n                stream.Position = 0;\n            }\n\n            if (exceptionToThrow != null)\n            {\n                throw exceptionToThrow;\n            }\n        }\n\n        /// <inheritdoc />\n        public Task<RemoteSubtitleInfo[]> SearchSubtitles(Video video, string language, bool? isPerfectMatch, CancellationToken cancellationToken)\n        {\n            if (video.VideoType != VideoType.VideoFile)\n            {\n                return Task.FromResult(Array.Empty<RemoteSubtitleInfo>());\n            }\n\n            VideoContentType mediaType;\n\n            if (video is Episode)\n            {\n                mediaType = VideoContentType.Episode;\n            }\n            else if (video is Movie)\n            {\n                mediaType = VideoContentType.Movie;\n            }\n            else\n            {\n                // These are the only supported types\n                return Task.FromResult(Array.Empty<RemoteSubtitleInfo>());\n            }\n\n            var request = new SubtitleSearchRequest\n            {\n                ContentType = mediaType,\n                IndexNumber = video.IndexNumber,\n                Language = language,\n                MediaPath = video.Path,\n                Name = video.Name,\n                ParentIndexNumber = video.ParentIndexNumber,\n                ProductionYear = video.ProductionYear,\n                ProviderIds = video.ProviderIds,\n                RuntimeTicks = video.RunTimeTicks,\n                IsPerfectMatch = isPerfectMatch ?? false\n            };\n\n            if (video is Episode episode)\n            {\n                request.IndexNumberEnd = episode.IndexNumberEnd;\n                request.SeriesName = episode.SeriesName;\n            }\n\n            return SearchSubtitles(request, cancellationToken);\n        }\n\n        private void Normalize(IEnumerable<RemoteSubtitleInfo> subtitles)\n        {\n            foreach (var sub in subtitles)\n            {\n                sub.Id = GetProviderId(sub.ProviderName) + \"_\" + sub.Id;\n            }\n        }\n\n        private string GetProviderId(string name)\n        {\n            return name.ToLowerInvariant().GetMD5().ToString(\"N\", CultureInfo.InvariantCulture);\n        }\n\n        private ISubtitleProvider GetProvider(string id)\n        {\n            return _subtitleProviders.First(i => string.Equals(id, GetProviderId(i.Name), StringComparison.Ordinal));\n        }\n\n        /// <inheritdoc />\n        public Task DeleteSubtitles(BaseItem item, int index)\n        {\n            var stream = _mediaSourceManager.GetMediaStreams(new MediaStreamQuery\n            {\n                Index = index,\n                ItemId = item.Id,\n                Type = MediaStreamType.Subtitle\n            })[0];\n\n            var path = stream.Path;\n            _monitor.ReportFileSystemChangeBeginning(path);\n\n            try\n            {\n                _fileSystem.DeleteFile(path);\n            }\n            finally\n            {\n                _monitor.ReportFileSystemChangeComplete(path, false);\n            }\n\n            return item.RefreshMetadata(CancellationToken.None);\n        }\n\n        /// <inheritdoc />\n        public Task<SubtitleResponse> GetRemoteSubtitles(string id, CancellationToken cancellationToken)\n        {\n            var parts = id.Split('_', 2);\n\n            var provider = GetProvider(parts[0]);\n            id = parts[^1];\n\n            return provider.GetSubtitles(id, cancellationToken);\n        }\n\n        /// <inheritdoc />\n        public SubtitleProviderInfo[] GetSupportedProviders(BaseItem video)\n        {\n            VideoContentType mediaType;\n\n            if (video is Episode)\n            {\n                mediaType = VideoContentType.Episode;\n            }\n            else if (video is Movie)\n            {\n                mediaType = VideoContentType.Movie;\n            }\n            else\n            {\n                // These are the only supported types\n                return Array.Empty<SubtitleProviderInfo>();\n            }\n\n            return _subtitleProviders\n                .Where(i => i.SupportedMediaTypes.Contains(mediaType))\n                .Select(i => new SubtitleProviderInfo\n                {\n                    Name = i.Name,\n                    Id = GetProviderId(i.Name)\n                }).ToArray();\n        }\n    }\n}\n"], "filenames": ["Jellyfin.Api/Controllers/HlsSegmentController.cs", "Jellyfin.Api/Controllers/ImageByNameController.cs", "MediaBrowser.Providers/Subtitles/SubtitleManager.cs"], "buggy_code_start_loc": [66, 77, 208], "buggy_code_end_loc": [136, 186, 214], "fixing_code_start_loc": [66, 77, 208], "fixing_code_end_loc": [153, 204, 232], "type": "CWE-22", "message": "Jellyfin is a Free Software Media System. In Jellyfin before version 10.7.1, with certain endpoints, well crafted requests will allow arbitrary file read from a Jellyfin server's file system. This issue is more prevalent when Windows is used as the host OS. Servers that are exposed to the public Internet are potentially at risk. This is fixed in version 10.7.1. As a workaround, users may be able to restrict some access by enforcing strict security permissions on their filesystem, however, it is recommended to update as soon as possible.", "other": {"cve": {"id": "CVE-2021-21402", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-23T20:15:13.120", "lastModified": "2021-03-27T02:16:08.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Jellyfin is a Free Software Media System. In Jellyfin before version 10.7.1, with certain endpoints, well crafted requests will allow arbitrary file read from a Jellyfin server's file system. This issue is more prevalent when Windows is used as the host OS. Servers that are exposed to the public Internet are potentially at risk. This is fixed in version 10.7.1. As a workaround, users may be able to restrict some access by enforcing strict security permissions on their filesystem, however, it is recommended to update as soon as possible."}, {"lang": "es", "value": "Jellyfin es un sistema multimedia de software libre.&#xa0;En Jellyfin versiones anteriores a 10.7.1, con determinados endpoints, las peticiones bien dise\u00f1adas permitir\u00e1n la lectura de archivos arbitrarios desde el sistema de archivos de un servidor Jellyfin.&#xa0;Este problema es m\u00e1s frecuente cuando es usado Windows como el Sistema Operativo host.&#xa0;Unos servidores que est\u00e1n expuestos a la Internet p\u00fablica est\u00e1n potencialmente en riesgo.&#xa0;Esto es corregido en versi\u00f3n 10.7.1.&#xa0;Como soluci\u00f3n alternativa, los usuarios pueden ser capaces de restringir algunos accesos imponiendo permisos de seguridad estrictos en su sistema de archivos; sin embargo, se recomienda actualizar lo antes posible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jellyfin:jellyfin:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.7.1", "matchCriteriaId": "F1DD62BC-C2DF-4847-8580-CEA58D17D528"}]}]}], "references": [{"url": "https://github.com/jellyfin/jellyfin/commit/0183ef8e89195f420c48d2600bc0b72f6d3a7fd7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jellyfin/jellyfin/releases/tag/v10.7.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/jellyfin/jellyfin/security/advisories/GHSA-wg4c-c9g9-rxhx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jellyfin/jellyfin/commit/0183ef8e89195f420c48d2600bc0b72f6d3a7fd7"}}